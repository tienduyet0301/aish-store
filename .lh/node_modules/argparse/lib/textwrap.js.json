{
    "sourceFile": "node_modules/argparse/lib/textwrap.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892017351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):\n// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py\n\n'use strict'\n\n/*\n * Text wrapping and filling.\n */\n\n// Copyright (C) 1999-2001 Gregory P. Ward.\n// Copyright (C) 2002, 2003 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n// Originally written by Greg Ward <gward@python.net>\n\n// Hardcode the recognized whitespace characters to the US-ASCII\n// whitespace characters.  The main reason for doing this is that\n// some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n//\n// This less funky little regex just split on recognized spaces. E.g.\n//   \"Hello there -- you goof-ball, use the -b option!\"\n// splits into\n//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\nconst wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/\n\nclass TextWrapper {\n    /*\n     *  Object for wrapping/filling text.  The public interface consists of\n     *  the wrap() and fill() methods; the other methods are just there for\n     *  subclasses to override in order to tweak the default behaviour.\n     *  If you want to completely replace the main wrapping algorithm,\n     *  you'll probably have to override _wrap_chunks().\n     *\n     *  Several instance attributes control various aspects of wrapping:\n     *    width (default: 70)\n     *      the maximum width of wrapped lines (unless break_long_words\n     *      is false)\n     *    initial_indent (default: \"\")\n     *      string that will be prepended to the first line of wrapped\n     *      output.  Counts towards the line's width.\n     *    subsequent_indent (default: \"\")\n     *      string that will be prepended to all lines save the first\n     *      of wrapped output; also counts towards each line's width.\n     *    expand_tabs (default: true)\n     *      Expand tabs in input text to spaces before further processing.\n     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position\n     *      in its line.  If false, each tab is treated as a single character.\n     *    tabsize (default: 8)\n     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n     *      'expand_tabs' is false.\n     *    replace_whitespace (default: true)\n     *      Replace all whitespace characters in the input text by spaces\n     *      after tab expansion.  Note that if expand_tabs is false and\n     *      replace_whitespace is true, every tab will be converted to a\n     *      single space!\n     *    fix_sentence_endings (default: false)\n     *      Ensure that sentence-ending punctuation is always followed\n     *      by two spaces.  Off by default because the algorithm is\n     *      (unavoidably) imperfect.\n     *    break_long_words (default: true)\n     *      Break words longer than 'width'.  If false, those words will not\n     *      be broken, and some lines might be longer than 'width'.\n     *    break_on_hyphens (default: true)\n     *      Allow breaking hyphenated words. If true, wrapping will occur\n     *      preferably on whitespaces and right after hyphens part of\n     *      compound words.\n     *    drop_whitespace (default: true)\n     *      Drop leading and trailing whitespace from lines.\n     *    max_lines (default: None)\n     *      Truncate wrapped lines.\n     *    placeholder (default: ' [...]')\n     *      Append to the last line of truncated text.\n     */\n\n    constructor(options = {}) {\n        let {\n            width = 70,\n            initial_indent = '',\n            subsequent_indent = '',\n            expand_tabs = true,\n            replace_whitespace = true,\n            fix_sentence_endings = false,\n            break_long_words = true,\n            drop_whitespace = true,\n            break_on_hyphens = true,\n            tabsize = 8,\n            max_lines = undefined,\n            placeholder=' [...]'\n        } = options\n\n        this.width = width\n        this.initial_indent = initial_indent\n        this.subsequent_indent = subsequent_indent\n        this.expand_tabs = expand_tabs\n        this.replace_whitespace = replace_whitespace\n        this.fix_sentence_endings = fix_sentence_endings\n        this.break_long_words = break_long_words\n        this.drop_whitespace = drop_whitespace\n        this.break_on_hyphens = break_on_hyphens\n        this.tabsize = tabsize\n        this.max_lines = max_lines\n        this.placeholder = placeholder\n    }\n\n\n    // -- Private methods -----------------------------------------------\n    // (possibly useful for subclasses to override)\n\n    _munge_whitespace(text) {\n        /*\n         *  _munge_whitespace(text : string) -> string\n         *\n         *  Munge whitespace in text: expand tabs and convert all other\n         *  whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n         *  becomes \" foo    bar  baz\".\n         */\n        if (this.expand_tabs) {\n            text = text.replace(/\\t/g, ' '.repeat(this.tabsize)) // not strictly correct in js\n        }\n        if (this.replace_whitespace) {\n            text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ')\n        }\n        return text\n    }\n\n    _split(text) {\n        /*\n         *  _split(text : string) -> [string]\n         *\n         *  Split the text to wrap into indivisible chunks.  Chunks are\n         *  not quite the same as words; see _wrap_chunks() for full\n         *  details.  As an example, the text\n         *    Look, goof-ball -- use the -b option!\n         *  breaks into the following chunks:\n         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n         *  if break_on_hyphens is True, or in:\n         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', option!'\n         *  otherwise.\n         */\n        let chunks = text.split(wordsep_simple_re)\n        chunks = chunks.filter(Boolean)\n        return chunks\n    }\n\n    _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n        /*\n         *  _handle_long_word(chunks : [string],\n         *                    cur_line : [string],\n         *                    cur_len : int, width : int)\n         *\n         *  Handle a chunk of text (most likely a word, not whitespace) that\n         *  is too long to fit in any line.\n         */\n        // Figure out when indent is larger than the specified width, and make\n        // sure at least one character is stripped off on every pass\n        let space_left\n        if (width < 1) {\n            space_left = 1\n        } else {\n            space_left = width - cur_len\n        }\n\n        // If we're allowed to break long words, then do so: put as much\n        // of the next chunk onto the current line as will fit.\n        if (this.break_long_words) {\n            cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left))\n            reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left)\n\n        // Otherwise, we have to preserve the long word intact.  Only add\n        // it to the current line if there's nothing already there --\n        // that minimizes how much we violate the width constraint.\n        } else if (!cur_line) {\n            cur_line.push(...reversed_chunks.pop())\n        }\n\n        // If we're not allowed to break long words, and there's already\n        // text on the current line, do nothing.  Next time through the\n        // main loop of _wrap_chunks(), we'll wind up here again, but\n        // cur_len will be zero, so the next line will be entirely\n        // devoted to the long word that we can't handle right now.\n    }\n\n    _wrap_chunks(chunks) {\n        /*\n         *  _wrap_chunks(chunks : [string]) -> [string]\n         *\n         *  Wrap a sequence of text chunks and return a list of lines of\n         *  length 'self.width' or less.  (If 'break_long_words' is false,\n         *  some lines may be longer than this.)  Chunks correspond roughly\n         *  to words and the whitespace between them: each chunk is\n         *  indivisible (modulo 'break_long_words'), but a line break can\n         *  come between any two chunks.  Chunks should not have internal\n         *  whitespace; ie. a chunk is either all whitespace or a \"word\".\n         *  Whitespace chunks will be removed from the beginning and end of\n         *  lines, but apart from that whitespace is preserved.\n         */\n        let lines = []\n        let indent\n        if (this.width <= 0) {\n            throw Error(`invalid width ${this.width} (must be > 0)`)\n        }\n        if (this.max_lines !== undefined) {\n            if (this.max_lines > 1) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n            if (indent.length + this.placeholder.trimStart().length > this.width) {\n                throw Error('placeholder too large for max width')\n            }\n        }\n\n        // Arrange in reverse order so items can be efficiently popped\n        // from a stack of chucks.\n        chunks = chunks.reverse()\n\n        while (chunks.length > 0) {\n\n            // Start the list of chunks that will make up the current line.\n            // cur_len is just the length of all the chunks in cur_line.\n            let cur_line = []\n            let cur_len = 0\n\n            // Figure out which static string will prefix this line.\n            let indent\n            if (lines) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n\n            // Maximum width for this line.\n            let width = this.width - indent.length\n\n            // First chunk on line is whitespace -- drop it, unless this\n            // is the very beginning of the text (ie. no lines started yet).\n            if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n                chunks.pop()\n            }\n\n            while (chunks.length > 0) {\n                let l = chunks[chunks.length - 1].length\n\n                // Can at least squeeze this chunk onto the current line.\n                if (cur_len + l <= width) {\n                    cur_line.push(chunks.pop())\n                    cur_len += l\n\n                // Nope, this line is full.\n                } else {\n                    break\n                }\n            }\n\n            // The current line is full, and the next chunk is too big to\n            // fit on *any* line (not just this one).\n            if (chunks.length && chunks[chunks.length - 1].length > width) {\n                this._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0)\n            }\n\n            // If the last chunk on this line is all whitespace, drop it.\n            if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n                cur_len -= cur_line[cur_line.length - 1].length\n                cur_line.pop()\n            }\n\n            if (cur_line) {\n                if (this.max_lines === undefined ||\n                    lines.length + 1 < this.max_lines ||\n                    (chunks.length === 0 ||\n                     this.drop_whitespace &&\n                     chunks.length === 1 &&\n                     !chunks[0].trim()) && cur_len <= width) {\n                    // Convert current line back to a string and store it in\n                    // list of all lines (return value).\n                    lines.push(indent + cur_line.join(''))\n                } else {\n                    let had_break = false\n                    while (cur_line) {\n                        if (cur_line[cur_line.length - 1].trim() &&\n                            cur_len + this.placeholder.length <= width) {\n                            cur_line.push(this.placeholder)\n                            lines.push(indent + cur_line.join(''))\n                            had_break = true\n                            break\n                        }\n                        cur_len -= cur_line[-1].length\n                        cur_line.pop()\n                    }\n                    if (!had_break) {\n                        if (lines) {\n                            let prev_line = lines[lines.length - 1].trimEnd()\n                            if (prev_line.length + this.placeholder.length <=\n                                    this.width) {\n                                lines[lines.length - 1] = prev_line + this.placeholder\n                                break\n                            }\n                        }\n                        lines.push(indent + this.placeholder.lstrip())\n                    }\n                    break\n                }\n            }\n        }\n\n        return lines\n    }\n\n    _split_chunks(text) {\n        text = this._munge_whitespace(text)\n        return this._split(text)\n    }\n\n    // -- Public interface ----------------------------------------------\n\n    wrap(text) {\n        /*\n         *  wrap(text : string) -> [string]\n         *\n         *  Reformat the single paragraph in 'text' so it fits in lines of\n         *  no more than 'self.width' columns, and return a list of wrapped\n         *  lines.  Tabs in 'text' are expanded with string.expandtabs(),\n         *  and all other whitespace characters (including newline) are\n         *  converted to space.\n         */\n        let chunks = this._split_chunks(text)\n        // not implemented in js\n        //if (this.fix_sentence_endings) {\n        //    this._fix_sentence_endings(chunks)\n        //}\n        return this._wrap_chunks(chunks)\n    }\n\n    fill(text) {\n        /*\n         *  fill(text : string) -> string\n         *\n         *  Reformat the single paragraph in 'text' to fit in lines of no\n         *  more than 'self.width' columns, and return a new string\n         *  containing the entire wrapped paragraph.\n         */\n        return this.wrap(text).join('\\n')\n    }\n}\n\n\n// -- Convenience interface ---------------------------------------------\n\nfunction wrap(text, options = {}) {\n    /*\n     *  Wrap a single paragraph of text, returning a list of wrapped lines.\n     *\n     *  Reformat the single paragraph in 'text' so it fits in lines of no\n     *  more than 'width' columns, and return a list of wrapped lines.  By\n     *  default, tabs in 'text' are expanded with string.expandtabs(), and\n     *  all other whitespace characters (including newline) are converted to\n     *  space.  See TextWrapper class for available keyword args to customize\n     *  wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.wrap(text)\n}\n\nfunction fill(text, options = {}) {\n    /*\n     *  Fill a single paragraph of text, returning a new string.\n     *\n     *  Reformat the single paragraph in 'text' to fit in lines of no more\n     *  than 'width' columns, and return a new string containing the entire\n     *  wrapped paragraph.  As with wrap(), tabs are expanded and other\n     *  whitespace characters converted to space.  See TextWrapper class for\n     *  available keyword args to customize wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.fill(text)\n}\n\n// -- Loosely related functionality -------------------------------------\n\nlet _whitespace_only_re = /^[ \\t]+$/mg\nlet _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg\n\nfunction dedent(text) {\n    /*\n     *  Remove any common leading whitespace from every line in `text`.\n     *\n     *  This can be used to make triple-quoted strings line up with the left\n     *  edge of the display, while still presenting them in the source code\n     *  in indented form.\n     *\n     *  Note that tabs and spaces are both treated as whitespace, but they\n     *  are not equal: the lines \"  hello\" and \"\\\\thello\" are\n     *  considered to have no common leading whitespace.\n     *\n     *  Entirely blank lines are normalized to a newline character.\n     */\n    // Look for the longest leading string of spaces and tabs common to\n    // all lines.\n    let margin = undefined\n    text = text.replace(_whitespace_only_re, '')\n    let indents = text.match(_leading_whitespace_re) || []\n    for (let indent of indents) {\n        indent = indent.slice(0, -1)\n\n        if (margin === undefined) {\n            margin = indent\n\n        // Current line more deeply indented than previous winner:\n        // no change (previous winner is still on top).\n        } else if (indent.startsWith(margin)) {\n            // pass\n\n        // Current line consistent with and no deeper than previous winner:\n        // it's the new winner.\n        } else if (margin.startsWith(indent)) {\n            margin = indent\n\n        // Find the largest common whitespace between current line and previous\n        // winner.\n        } else {\n            for (let i = 0; i < margin.length && i < indent.length; i++) {\n                if (margin[i] !== indent[i]) {\n                    margin = margin.slice(0, i)\n                    break\n                }\n            }\n        }\n    }\n\n    if (margin) {\n        text = text.replace(new RegExp('^' + margin, 'mg'), '')\n    }\n    return text\n}\n\nmodule.exports = { wrap, fill, dedent }\n"
        }
    ]
}