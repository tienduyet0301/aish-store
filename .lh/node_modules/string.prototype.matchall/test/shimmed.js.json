{
    "sourceFile": "node_modules/string.prototype.matchall/test/shimmed.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893038303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nrequire('es5-shim');\nrequire('es6-shim');\nrequire('../auto');\n\nvar test = require('tape');\nvar defineProperties = require('define-properties');\nvar callBind = require('call-bind');\nvar hasSymbols = require('has-symbols')();\nvar mockProperty = require('mock-property');\n\nvar regexMatchAll = require('../regexp-matchall');\n\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\nvar functionsHaveNames = require('functions-have-names')();\nvar functionNamesConfigurable = require('functions-have-names').functionsHaveConfigurableNames();\n\nvar runTests = require('./tests');\n\ntest('shimmed', function (t) {\n\tt.equal(String.prototype.matchAll.length, 1, 'String#matchAll has a length of 1');\n\tt.test('Function name', { skip: !functionsHaveNames }, function (st) {\n\t\tst.equal(String.prototype.matchAll.name, 'matchAll', 'String#matchAll has name \"matchAll\"');\n\t\tst.end();\n\t});\n\n\tt.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {\n\t\tet.equal(false, isEnumerable.call(String.prototype, 'matchAll'), 'String#matchAll is not enumerable');\n\t\tet.end();\n\t});\n\n\tt.test('Symbol.matchAll', { skip: !hasSymbols }, function (st) {\n\t\tst.equal(typeof Symbol.matchAll, 'symbol', 'Symbol.matchAll is a symbol');\n\n\t\tst.equal(typeof RegExp.prototype[Symbol.matchAll], 'function', 'Symbol.matchAll function is on RegExp.prototype');\n\n\t\tst.test('Function name', { skip: !functionsHaveNames }, function (s2t) {\n\t\t\tif (functionNamesConfigurable) {\n\t\t\t\ts2t.equal(RegExp.prototype[Symbol.matchAll].name, '[Symbol.matchAll]', 'RegExp.prototype[Symbol.matchAll] has name \"[Symbol.matchAll]\"');\n\t\t\t} else {\n\t\t\t\ts2t.equal(RegExp.prototype[Symbol.matchAll].name, 'SymbolMatchAll', 'RegExp.prototype[Symbol.matchAll] has best guess name \"SymbolMatchAll\"');\n\t\t\t}\n\t\t\ts2t.end();\n\t\t});\n\n\t\tst.test('no symbol present', function (s2t) {\n\t\t\ts2t.doesNotThrow(function () { 'abc'.matchAll('b'); }, 'does not throw on string input, with the symbol on regex prototype');\n\n\t\t\ts2t.teardown(mockProperty(RegExp.prototype, Symbol.matchAll, {\n\t\t\t\tnonEnumerable: true,\n\t\t\t\tvalue: undefined,\n\t\t\t\tnonWritable: false\n\t\t\t}));\n\n\t\t\ts2t['throws'](function () { 'abc'.matchAll('b'); }, 'throws on string input, without the symbol on regex prototype');\n\n\t\t\ts2t.end();\n\t\t});\n\n\t\tst.end();\n\t});\n\n\trunTests(\n\t\tcallBind(String.prototype.matchAll),\n\t\tcallBind(hasSymbols ? RegExp.prototype[Symbol.matchAll] : regexMatchAll),\n\t\tt\n\t);\n\n\tt.end();\n});\n"
        }
    ]
}