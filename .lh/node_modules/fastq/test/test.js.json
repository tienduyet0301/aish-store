{
    "sourceFile": "node_modules/fastq/test/test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892294248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict'\n\n/* eslint-disable no-var */\n\nvar test = require('tape')\nvar buildQueue = require('../')\n\ntest('concurrency', function (t) {\n  t.plan(6)\n  t.throws(buildQueue.bind(null, worker, 0))\n  t.throws(buildQueue.bind(null, worker, NaN))\n  t.doesNotThrow(buildQueue.bind(null, worker, 1))\n\n  var queue = buildQueue(worker, 1)\n  t.throws(function () {\n    queue.concurrency = 0\n  })\n  t.throws(function () {\n    queue.concurrency = NaN\n  })\n  t.doesNotThrow(function () {\n    queue.concurrency = 2\n  })\n\n  function worker (arg, cb) {\n    cb(null, true)\n  }\n})\n\ntest('worker execution', function (t) {\n  t.plan(3)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    cb(null, true)\n  }\n})\n\ntest('limit', function (t) {\n  t.plan(4)\n\n  var expected = [10, 0]\n  var queue = buildQueue(worker, 1)\n\n  queue.push(10, result)\n  queue.push(0, result)\n\n  function result (err, arg) {\n    t.error(err, 'no error')\n    t.equal(arg, expected.shift(), 'the result matches')\n  }\n\n  function worker (arg, cb) {\n    setTimeout(cb, arg, null, arg)\n  }\n})\n\ntest('multiple executions', function (t) {\n  t.plan(15)\n\n  var queue = buildQueue(worker, 1)\n  var toExec = [1, 2, 3, 4, 5]\n  var count = 0\n\n  toExec.forEach(function (task) {\n    queue.push(task, done)\n  })\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, toExec[count - 1], 'the result matches')\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, toExec[count], 'arg matches')\n    count++\n    setImmediate(cb, null, arg)\n  }\n})\n\ntest('multiple executions, one after another', function (t) {\n  t.plan(15)\n\n  var queue = buildQueue(worker, 1)\n  var toExec = [1, 2, 3, 4, 5]\n  var count = 0\n\n  queue.push(toExec[0], done)\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, toExec[count - 1], 'the result matches')\n    if (count < toExec.length) {\n      queue.push(toExec[count], done)\n    }\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, toExec[count], 'arg matches')\n    count++\n    setImmediate(cb, null, arg)\n  }\n})\n\ntest('set this', function (t) {\n  t.plan(3)\n\n  var that = {}\n  var queue = buildQueue(that, worker, 1)\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(this, that, 'this matches')\n  })\n\n  function worker (arg, cb) {\n    t.equal(this, that, 'this matches')\n    cb(null, true)\n  }\n})\n\ntest('drain', function (t) {\n  t.plan(4)\n\n  var queue = buildQueue(worker, 1)\n  var worked = false\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  queue.drain = function () {\n    t.equal(true, worked, 'drained')\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    worked = true\n    setImmediate(cb, null, true)\n  }\n})\n\ntest('pause && resume', function (t) {\n  t.plan(13)\n\n  var queue = buildQueue(worker, 1)\n  var worked = false\n  var expected = [42, 24]\n\n  t.notOk(queue.paused, 'it should not be paused')\n\n  queue.pause()\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  queue.push(24, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  t.notOk(worked, 'it should be paused')\n  t.ok(queue.paused, 'it should be paused')\n\n  queue.resume()\n  queue.pause()\n  queue.resume()\n  queue.resume() // second resume is a no-op\n\n  function worker (arg, cb) {\n    t.notOk(queue.paused, 'it should not be paused')\n    t.ok(queue.running() <= queue.concurrency, 'should respect the concurrency')\n    t.equal(arg, expected.shift())\n    worked = true\n    process.nextTick(function () { cb(null, true) })\n  }\n})\n\ntest('pause in flight && resume', function (t) {\n  t.plan(16)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [42, 24, 12]\n\n  t.notOk(queue.paused, 'it should not be paused')\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.ok(queue.paused, 'it should be paused')\n    process.nextTick(function () {\n      queue.resume()\n      queue.pause()\n      queue.resume()\n    })\n  })\n\n  queue.push(24, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.notOk(queue.paused, 'it should not be paused')\n  })\n\n  queue.push(12, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.notOk(queue.paused, 'it should not be paused')\n  })\n\n  queue.pause()\n\n  function worker (arg, cb) {\n    t.ok(queue.running() <= queue.concurrency, 'should respect the concurrency')\n    t.equal(arg, expected.shift())\n    process.nextTick(function () { cb(null, true) })\n  }\n})\n\ntest('altering concurrency', function (t) {\n  t.plan(24)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.push(24, workDone)\n  queue.push(24, workDone)\n  queue.push(24, workDone)\n\n  queue.pause()\n\n  queue.concurrency = 3 // concurrency changes are ignored while paused\n  queue.concurrency = 2\n\n  queue.resume()\n\n  t.equal(queue.running(), 2, '2 jobs running')\n\n  queue.concurrency = 3\n\n  t.equal(queue.running(), 3, '3 jobs running')\n\n  queue.concurrency = 1\n\n  t.equal(queue.running(), 3, '3 jobs running') // running jobs can't be killed\n\n  queue.push(24, workDone)\n  queue.push(24, workDone)\n  queue.push(24, workDone)\n  queue.push(24, workDone)\n\n  function workDone (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  }\n\n  function worker (arg, cb) {\n    t.ok(queue.running() <= queue.concurrency, 'should respect the concurrency')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('idle()', function (t) {\n  t.plan(12)\n\n  var queue = buildQueue(worker, 1)\n\n  t.ok(queue.idle(), 'queue is idle')\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    t.notOk(queue.idle(), 'queue is not idle')\n  })\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n    // it will go idle after executing this function\n    setImmediate(function () {\n      t.ok(queue.idle(), 'queue is now idle')\n    })\n  })\n\n  t.notOk(queue.idle(), 'queue is not idle')\n\n  function worker (arg, cb) {\n    t.notOk(queue.idle(), 'queue is not idle')\n    t.equal(arg, 42)\n    setImmediate(cb, null, true)\n  }\n})\n\ntest('saturated', function (t) {\n  t.plan(9)\n\n  var queue = buildQueue(worker, 1)\n  var preworked = 0\n  var worked = 0\n\n  queue.saturated = function () {\n    t.pass('saturated')\n    t.equal(preworked, 1, 'started 1 task')\n    t.equal(worked, 0, 'worked zero task')\n  }\n\n  queue.push(42, done)\n  queue.push(42, done)\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  }\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    preworked++\n    setImmediate(function () {\n      worked++\n      cb(null, true)\n    })\n  }\n})\n\ntest('length', function (t) {\n  t.plan(7)\n\n  var queue = buildQueue(worker, 1)\n\n  t.equal(queue.length(), 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.length(), 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.length(), 1, 'one task waiting')\n  queue.push(42, done)\n  t.equal(queue.length(), 2, 'two tasks waiting')\n\n  function done (err, result) {\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('getQueue', function (t) {\n  t.plan(10)\n\n  var queue = buildQueue(worker, 1)\n\n  t.equal(queue.getQueue().length, 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.getQueue().length, 0, 'nothing waiting')\n  queue.push(42, done)\n  t.equal(queue.getQueue().length, 1, 'one task waiting')\n  t.equal(queue.getQueue()[0], 42, 'should be equal')\n  queue.push(43, done)\n  t.equal(queue.getQueue().length, 2, 'two tasks waiting')\n  t.equal(queue.getQueue()[0], 42, 'should be equal')\n  t.equal(queue.getQueue()[1], 43, 'should be equal')\n\n  function done (err, result) {\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('unshift', function (t) {\n  t.plan(8)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [1, 2, 3, 4]\n\n  queue.push(1, done)\n  queue.push(4, done)\n  queue.unshift(3, done)\n  queue.unshift(2, done)\n\n  function done (err, result) {\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('unshift && empty', function (t) {\n  t.plan(2)\n\n  var queue = buildQueue(worker, 1)\n  var completed = false\n\n  queue.pause()\n\n  queue.empty = function () {\n    t.notOk(completed, 'the task has not completed yet')\n  }\n\n  queue.unshift(1, done)\n\n  queue.resume()\n\n  function done (err, result) {\n    completed = true\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('push && empty', function (t) {\n  t.plan(2)\n\n  var queue = buildQueue(worker, 1)\n  var completed = false\n\n  queue.pause()\n\n  queue.empty = function () {\n    t.notOk(completed, 'the task has not completed yet')\n  }\n\n  queue.push(1, done)\n\n  queue.resume()\n\n  function done (err, result) {\n    completed = true\n    t.error(err, 'no error')\n  }\n\n  function worker (arg, cb) {\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('kill', function (t) {\n  t.plan(5)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [1]\n\n  var predrain = queue.drain\n\n  queue.drain = function drain () {\n    t.fail('drain should never be called')\n  }\n\n  queue.push(1, done)\n  queue.push(4, done)\n  queue.unshift(3, done)\n  queue.unshift(2, done)\n  queue.kill()\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    setImmediate(function () {\n      t.equal(queue.length(), 0, 'no queued tasks')\n      t.equal(queue.running(), 0, 'no running tasks')\n      t.equal(queue.drain, predrain, 'drain is back to default')\n    })\n  }\n\n  function worker (arg, cb) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('killAndDrain', function (t) {\n  t.plan(6)\n\n  var queue = buildQueue(worker, 1)\n  var expected = [1]\n\n  var predrain = queue.drain\n\n  queue.drain = function drain () {\n    t.pass('drain has been called')\n  }\n\n  queue.push(1, done)\n  queue.push(4, done)\n  queue.unshift(3, done)\n  queue.unshift(2, done)\n  queue.killAndDrain()\n\n  function done (err, result) {\n    t.error(err, 'no error')\n    setImmediate(function () {\n      t.equal(queue.length(), 0, 'no queued tasks')\n      t.equal(queue.running(), 0, 'no running tasks')\n      t.equal(queue.drain, predrain, 'drain is back to default')\n    })\n  }\n\n  function worker (arg, cb) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n    setImmediate(function () {\n      cb(null, true)\n    })\n  }\n})\n\ntest('pause && idle', function (t) {\n  t.plan(11)\n\n  var queue = buildQueue(worker, 1)\n  var worked = false\n\n  t.notOk(queue.paused, 'it should not be paused')\n  t.ok(queue.idle(), 'should be idle')\n\n  queue.pause()\n\n  queue.push(42, function (err, result) {\n    t.error(err, 'no error')\n    t.equal(result, true, 'result matches')\n  })\n\n  t.notOk(worked, 'it should be paused')\n  t.ok(queue.paused, 'it should be paused')\n  t.notOk(queue.idle(), 'should not be idle')\n\n  queue.resume()\n\n  t.notOk(queue.paused, 'it should not be paused')\n  t.notOk(queue.idle(), 'it should not be idle')\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    worked = true\n    process.nextTick(cb.bind(null, null, true))\n    process.nextTick(function () {\n      t.ok(queue.idle(), 'is should be idle')\n    })\n  }\n})\n\ntest('push without cb', function (t) {\n  t.plan(1)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.push(42)\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    cb()\n  }\n})\n\ntest('unshift without cb', function (t) {\n  t.plan(1)\n\n  var queue = buildQueue(worker, 1)\n\n  queue.unshift(42)\n\n  function worker (arg, cb) {\n    t.equal(arg, 42)\n    cb()\n  }\n})\n\ntest('push with worker throwing error', function (t) {\n  t.plan(5)\n  var q = buildQueue(function (task, cb) {\n    cb(new Error('test error'), null)\n  }, 1)\n  q.error(function (err, task) {\n    t.ok(err instanceof Error, 'global error handler should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n    t.equal(task, 42, 'The task executed should be passed')\n  })\n  q.push(42, function (err) {\n    t.ok(err instanceof Error, 'push callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  })\n})\n\ntest('unshift with worker throwing error', function (t) {\n  t.plan(5)\n  var q = buildQueue(function (task, cb) {\n    cb(new Error('test error'), null)\n  }, 1)\n  q.error(function (err, task) {\n    t.ok(err instanceof Error, 'global error handler should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n    t.equal(task, 42, 'The task executed should be passed')\n  })\n  q.unshift(42, function (err) {\n    t.ok(err instanceof Error, 'unshift callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  })\n})\n\ntest('pause/resume should trigger drain event', function (t) {\n  t.plan(1)\n\n  var queue = buildQueue(worker, 1)\n  queue.pause()\n  queue.drain = function () {\n    t.pass('drain should be called')\n  }\n\n  function worker (arg, cb) {\n    cb(null, true)\n  }\n\n  queue.resume()\n})\n\ntest('paused flag', function (t) {\n  t.plan(2)\n\n  var queue = buildQueue(function (arg, cb) {\n    cb(null)\n  }, 1)\n  t.equal(queue.paused, false)\n  queue.pause()\n  t.equal(queue.paused, true)\n})\n"
        }
    ]
}