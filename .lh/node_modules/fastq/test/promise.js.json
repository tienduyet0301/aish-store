{
    "sourceFile": "node_modules/fastq/test/promise.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892294202,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict'\n\nconst test = require('tape')\nconst buildQueue = require('../').promise\nconst { promisify } = require('util')\nconst sleep = promisify(setTimeout)\nconst immediate = promisify(setImmediate)\n\ntest('concurrency', function (t) {\n  t.plan(2)\n  t.throws(buildQueue.bind(null, worker, 0))\n  t.doesNotThrow(buildQueue.bind(null, worker, 1))\n\n  async function worker (arg) {\n    return true\n  }\n})\n\ntest('worker execution', async function (t) {\n  const queue = buildQueue(worker, 1)\n\n  const result = await queue.push(42)\n\n  t.equal(result, true, 'result matches')\n\n  async function worker (arg) {\n    t.equal(arg, 42)\n    return true\n  }\n})\n\ntest('limit', async function (t) {\n  const queue = buildQueue(worker, 1)\n\n  const [res1, res2] = await Promise.all([queue.push(10), queue.push(0)])\n  t.equal(res1, 10, 'the result matches')\n  t.equal(res2, 0, 'the result matches')\n\n  async function worker (arg) {\n    await sleep(arg)\n    return arg\n  }\n})\n\ntest('multiple executions', async function (t) {\n  const queue = buildQueue(worker, 1)\n  const toExec = [1, 2, 3, 4, 5]\n  const expected = ['a', 'b', 'c', 'd', 'e']\n  let count = 0\n\n  await Promise.all(toExec.map(async function (task, i) {\n    const result = await queue.push(task)\n    t.equal(result, expected[i], 'the result matches')\n  }))\n\n  async function worker (arg) {\n    t.equal(arg, toExec[count], 'arg matches')\n    return expected[count++]\n  }\n})\n\ntest('drained', async function (t) {\n  const queue = buildQueue(worker, 2)\n\n  const toExec = new Array(10).fill(10)\n  let count = 0\n\n  async function worker (arg) {\n    await sleep(arg)\n    count++\n  }\n\n  toExec.forEach(function (i) {\n    queue.push(i)\n  })\n\n  await queue.drained()\n\n  t.equal(count, toExec.length)\n\n  toExec.forEach(function (i) {\n    queue.push(i)\n  })\n\n  await queue.drained()\n\n  t.equal(count, toExec.length * 2)\n})\n\ntest('drained with exception should not throw', async function (t) {\n  const queue = buildQueue(worker, 2)\n\n  const toExec = new Array(10).fill(10)\n\n  async function worker () {\n    throw new Error('foo')\n  }\n\n  toExec.forEach(function (i) {\n    queue.push(i)\n  })\n\n  await queue.drained()\n})\n\ntest('drained with drain function', async function (t) {\n  let drainCalled = false\n  const queue = buildQueue(worker, 2)\n\n  queue.drain = function () {\n    drainCalled = true\n  }\n\n  const toExec = new Array(10).fill(10)\n  let count = 0\n\n  async function worker (arg) {\n    await sleep(arg)\n    count++\n  }\n\n  toExec.forEach(function () {\n    queue.push()\n  })\n\n  await queue.drained()\n\n  t.equal(count, toExec.length)\n  t.equal(drainCalled, true)\n})\n\ntest('drained while idle should resolve', async function (t) {\n  const queue = buildQueue(worker, 2)\n\n  async function worker (arg) {\n    await sleep(arg)\n  }\n\n  await queue.drained()\n})\n\ntest('drained while idle should not call the drain function', async function (t) {\n  let drainCalled = false\n  const queue = buildQueue(worker, 2)\n\n  queue.drain = function () {\n    drainCalled = true\n  }\n\n  async function worker (arg) {\n    await sleep(arg)\n  }\n\n  await queue.drained()\n\n  t.equal(drainCalled, false)\n})\n\ntest('set this', async function (t) {\n  t.plan(1)\n  const that = {}\n  const queue = buildQueue(that, worker, 1)\n\n  await queue.push(42)\n\n  async function worker (arg) {\n    t.equal(this, that, 'this matches')\n  }\n})\n\ntest('unshift', async function (t) {\n  const queue = buildQueue(worker, 1)\n  const expected = [1, 2, 3, 4]\n\n  await Promise.all([\n    queue.push(1),\n    queue.push(4),\n    queue.unshift(3),\n    queue.unshift(2)\n  ])\n\n  t.is(expected.length, 0)\n\n  async function worker (arg) {\n    t.equal(expected.shift(), arg, 'tasks come in order')\n  }\n})\n\ntest('push with worker throwing error', async function (t) {\n  t.plan(5)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n  q.error(function (err, task) {\n    t.ok(err instanceof Error, 'global error handler should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n    t.equal(task, 42, 'The task executed should be passed')\n  })\n  try {\n    await q.push(42)\n  } catch (err) {\n    t.ok(err instanceof Error, 'push callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  }\n})\n\ntest('unshift with worker throwing error', async function (t) {\n  t.plan(2)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n  try {\n    await q.unshift(42)\n  } catch (err) {\n    t.ok(err instanceof Error, 'push callback should catch the error')\n    t.match(err.message, /test error/, 'error message should be \"test error\"')\n  }\n})\n\ntest('no unhandledRejection (push)', async function (t) {\n  function handleRejection () {\n    t.fail('unhandledRejection')\n  }\n  process.once('unhandledRejection', handleRejection)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n\n  q.push(42)\n\n  await immediate()\n  process.removeListener('unhandledRejection', handleRejection)\n})\n\ntest('no unhandledRejection (unshift)', async function (t) {\n  function handleRejection () {\n    t.fail('unhandledRejection')\n  }\n  process.once('unhandledRejection', handleRejection)\n  const q = buildQueue(async function (task, cb) {\n    throw new Error('test error')\n  }, 1)\n\n  q.unshift(42)\n\n  await immediate()\n  process.removeListener('unhandledRejection', handleRejection)\n})\n\ntest('drained should resolve after async tasks complete', async function (t) {\n  const logs = []\n\n  async function processTask () {\n    await new Promise(resolve => setTimeout(resolve, 0))\n    logs.push('processed')\n  }\n\n  const queue = buildQueue(processTask, 1)\n  queue.drain = () => logs.push('called drain')\n\n  queue.drained().then(() => logs.push('drained promise resolved'))\n\n  await Promise.all([\n    queue.push(),\n    queue.push(),\n    queue.push()\n  ])\n\n  t.deepEqual(logs, [\n    'processed',\n    'processed',\n    'processed',\n    'called drain',\n    'drained promise resolved'\n  ], 'events happened in correct order')\n})\n\ntest('drained should handle undefined drain function', async function (t) {\n  const queue = buildQueue(worker, 1)\n\n  async function worker (arg) {\n    await sleep(10)\n    return arg\n  }\n\n  queue.drain = undefined\n  queue.push(1)\n  await queue.drained()\n\n  t.pass('drained resolved successfully with undefined drain')\n})\n"
        }
    ]
}