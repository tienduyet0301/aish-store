{
    "sourceFile": "node_modules/motion-dom/dist/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892644824,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { Box, Easing, EasingFunction, BezierDefinition } from 'motion-utils';\n\ninterface SVGAttributes {\n    accentHeight?: number | string | undefined;\n    accumulate?: \"none\" | \"sum\" | undefined;\n    additive?: \"replace\" | \"sum\" | undefined;\n    alignmentBaseline?: \"auto\" | \"baseline\" | \"before-edge\" | \"text-before-edge\" | \"middle\" | \"central\" | \"after-edge\" | \"text-after-edge\" | \"ideographic\" | \"alphabetic\" | \"hanging\" | \"mathematical\" | \"inherit\" | undefined;\n    allowReorder?: \"no\" | \"yes\" | undefined;\n    alphabetic?: number | string | undefined;\n    amplitude?: number | string | undefined;\n    arabicForm?: \"initial\" | \"medial\" | \"terminal\" | \"isolated\" | undefined;\n    ascent?: number | string | undefined;\n    attributeName?: string | undefined;\n    attributeType?: string | undefined;\n    autoReverse?: boolean | undefined;\n    azimuth?: number | string | undefined;\n    baseFrequency?: number | string | undefined;\n    baselineShift?: number | string | undefined;\n    baseProfile?: number | string | undefined;\n    bbox?: number | string | undefined;\n    begin?: number | string | undefined;\n    bias?: number | string | undefined;\n    by?: number | string | undefined;\n    calcMode?: number | string | undefined;\n    capHeight?: number | string | undefined;\n    clip?: number | string | undefined;\n    clipPath?: string | undefined;\n    clipPathUnits?: number | string | undefined;\n    clipRule?: number | string | undefined;\n    colorInterpolation?: number | string | undefined;\n    colorInterpolationFilters?: \"auto\" | \"sRGB\" | \"linearRGB\" | \"inherit\" | undefined;\n    colorProfile?: number | string | undefined;\n    colorRendering?: number | string | undefined;\n    contentScriptType?: number | string | undefined;\n    contentStyleType?: number | string | undefined;\n    cursor?: number | string | undefined;\n    cx?: number | string | undefined;\n    cy?: number | string | undefined;\n    d?: string | undefined;\n    decelerate?: number | string | undefined;\n    descent?: number | string | undefined;\n    diffuseConstant?: number | string | undefined;\n    direction?: number | string | undefined;\n    display?: number | string | undefined;\n    divisor?: number | string | undefined;\n    dominantBaseline?: number | string | undefined;\n    dur?: number | string | undefined;\n    dx?: number | string | undefined;\n    dy?: number | string | undefined;\n    edgeMode?: number | string | undefined;\n    elevation?: number | string | undefined;\n    enableBackground?: number | string | undefined;\n    end?: number | string | undefined;\n    exponent?: number | string | undefined;\n    externalResourcesRequired?: boolean | undefined;\n    fill?: string | undefined;\n    fillOpacity?: number | string | undefined;\n    fillRule?: \"nonzero\" | \"evenodd\" | \"inherit\" | undefined;\n    filter?: string | undefined;\n    filterRes?: number | string | undefined;\n    filterUnits?: number | string | undefined;\n    floodColor?: number | string | undefined;\n    floodOpacity?: number | string | undefined;\n    focusable?: boolean | \"auto\" | undefined;\n    fontFamily?: string | undefined;\n    fontSize?: number | string | undefined;\n    fontSizeAdjust?: number | string | undefined;\n    fontStretch?: number | string | undefined;\n    fontStyle?: number | string | undefined;\n    fontVariant?: number | string | undefined;\n    fontWeight?: number | string | undefined;\n    format?: number | string | undefined;\n    fr?: number | string | undefined;\n    from?: number | string | undefined;\n    fx?: number | string | undefined;\n    fy?: number | string | undefined;\n    g1?: number | string | undefined;\n    g2?: number | string | undefined;\n    glyphName?: number | string | undefined;\n    glyphOrientationHorizontal?: number | string | undefined;\n    glyphOrientationVertical?: number | string | undefined;\n    glyphRef?: number | string | undefined;\n    gradientTransform?: string | undefined;\n    gradientUnits?: string | undefined;\n    hanging?: number | string | undefined;\n    horizAdvX?: number | string | undefined;\n    horizOriginX?: number | string | undefined;\n    href?: string | undefined;\n    ideographic?: number | string | undefined;\n    imageRendering?: number | string | undefined;\n    in2?: number | string | undefined;\n    in?: string | undefined;\n    intercept?: number | string | undefined;\n    k1?: number | string | undefined;\n    k2?: number | string | undefined;\n    k3?: number | string | undefined;\n    k4?: number | string | undefined;\n    k?: number | string | undefined;\n    kernelMatrix?: number | string | undefined;\n    kernelUnitLength?: number | string | undefined;\n    kerning?: number | string | undefined;\n    keyPoints?: number | string | undefined;\n    keySplines?: number | string | undefined;\n    keyTimes?: number | string | undefined;\n    lengthAdjust?: number | string | undefined;\n    letterSpacing?: number | string | undefined;\n    lightingColor?: number | string | undefined;\n    limitingConeAngle?: number | string | undefined;\n    local?: number | string | undefined;\n    markerEnd?: string | undefined;\n    markerHeight?: number | string | undefined;\n    markerMid?: string | undefined;\n    markerStart?: string | undefined;\n    markerUnits?: number | string | undefined;\n    markerWidth?: number | string | undefined;\n    mask?: string | undefined;\n    maskContentUnits?: number | string | undefined;\n    maskUnits?: number | string | undefined;\n    mathematical?: number | string | undefined;\n    mode?: number | string | undefined;\n    numOctaves?: number | string | undefined;\n    offset?: number | string | undefined;\n    opacity?: number | string | undefined;\n    operator?: number | string | undefined;\n    order?: number | string | undefined;\n    orient?: number | string | undefined;\n    orientation?: number | string | undefined;\n    origin?: number | string | undefined;\n    overflow?: number | string | undefined;\n    overlinePosition?: number | string | undefined;\n    overlineThickness?: number | string | undefined;\n    paintOrder?: number | string | undefined;\n    panose1?: number | string | undefined;\n    path?: string | undefined;\n    pathLength?: number | string | undefined;\n    patternContentUnits?: string | undefined;\n    patternTransform?: number | string | undefined;\n    patternUnits?: string | undefined;\n    pointerEvents?: number | string | undefined;\n    points?: string | undefined;\n    pointsAtX?: number | string | undefined;\n    pointsAtY?: number | string | undefined;\n    pointsAtZ?: number | string | undefined;\n    preserveAlpha?: boolean | undefined;\n    preserveAspectRatio?: string | undefined;\n    primitiveUnits?: number | string | undefined;\n    r?: number | string | undefined;\n    radius?: number | string | undefined;\n    refX?: number | string | undefined;\n    refY?: number | string | undefined;\n    renderingIntent?: number | string | undefined;\n    repeatCount?: number | string | undefined;\n    repeatDur?: number | string | undefined;\n    requiredExtensions?: number | string | undefined;\n    requiredFeatures?: number | string | undefined;\n    restart?: number | string | undefined;\n    result?: string | undefined;\n    rotate?: number | string | undefined;\n    rx?: number | string | undefined;\n    ry?: number | string | undefined;\n    scale?: number | string | undefined;\n    seed?: number | string | undefined;\n    shapeRendering?: number | string | undefined;\n    slope?: number | string | undefined;\n    spacing?: number | string | undefined;\n    specularConstant?: number | string | undefined;\n    specularExponent?: number | string | undefined;\n    speed?: number | string | undefined;\n    spreadMethod?: string | undefined;\n    startOffset?: number | string | undefined;\n    stdDeviation?: number | string | undefined;\n    stemh?: number | string | undefined;\n    stemv?: number | string | undefined;\n    stitchTiles?: number | string | undefined;\n    stopColor?: string | undefined;\n    stopOpacity?: number | string | undefined;\n    strikethroughPosition?: number | string | undefined;\n    strikethroughThickness?: number | string | undefined;\n    string?: number | string | undefined;\n    stroke?: string | undefined;\n    strokeDasharray?: string | number | undefined;\n    strokeDashoffset?: string | number | undefined;\n    strokeLinecap?: \"butt\" | \"round\" | \"square\" | \"inherit\" | undefined;\n    strokeLinejoin?: \"miter\" | \"round\" | \"bevel\" | \"inherit\" | undefined;\n    strokeMiterlimit?: number | string | undefined;\n    strokeOpacity?: number | string | undefined;\n    strokeWidth?: number | string | undefined;\n    surfaceScale?: number | string | undefined;\n    systemLanguage?: number | string | undefined;\n    tableValues?: number | string | undefined;\n    targetX?: number | string | undefined;\n    targetY?: number | string | undefined;\n    textAnchor?: string | undefined;\n    textDecoration?: number | string | undefined;\n    textLength?: number | string | undefined;\n    textRendering?: number | string | undefined;\n    to?: number | string | undefined;\n    transform?: string | undefined;\n    u1?: number | string | undefined;\n    u2?: number | string | undefined;\n    underlinePosition?: number | string | undefined;\n    underlineThickness?: number | string | undefined;\n    unicode?: number | string | undefined;\n    unicodeBidi?: number | string | undefined;\n    unicodeRange?: number | string | undefined;\n    unitsPerEm?: number | string | undefined;\n    vAlphabetic?: number | string | undefined;\n    values?: string | undefined;\n    vectorEffect?: number | string | undefined;\n    version?: string | undefined;\n    vertAdvY?: number | string | undefined;\n    vertOriginX?: number | string | undefined;\n    vertOriginY?: number | string | undefined;\n    vHanging?: number | string | undefined;\n    vIdeographic?: number | string | undefined;\n    viewBox?: string | undefined;\n    viewTarget?: number | string | undefined;\n    visibility?: number | string | undefined;\n    vMathematical?: number | string | undefined;\n    widths?: number | string | undefined;\n    wordSpacing?: number | string | undefined;\n    writingMode?: number | string | undefined;\n    x1?: number | string | undefined;\n    x2?: number | string | undefined;\n    x?: number | string | undefined;\n    xChannelSelector?: string | undefined;\n    xHeight?: number | string | undefined;\n    xlinkActuate?: string | undefined;\n    xlinkArcrole?: string | undefined;\n    xlinkHref?: string | undefined;\n    xlinkRole?: string | undefined;\n    xlinkShow?: string | undefined;\n    xlinkTitle?: string | undefined;\n    xlinkType?: string | undefined;\n    xmlBase?: string | undefined;\n    xmlLang?: string | undefined;\n    xmlns?: string | undefined;\n    xmlnsXlink?: string | undefined;\n    xmlSpace?: string | undefined;\n    y1?: number | string | undefined;\n    y2?: number | string | undefined;\n    y?: number | string | undefined;\n    yChannelSelector?: string | undefined;\n    z?: number | string | undefined;\n    zoomAndPan?: string | undefined;\n}\n\n/**\n * An update function. It accepts a timestamp used to advance the animation.\n */\ntype Update$1 = (timestamp: number) => void;\n/**\n * Drivers accept a update function and call it at an interval. This interval\n * could be a synchronous loop, a setInterval, or tied to the device's framerate.\n */\ninterface DriverControls {\n    start: () => void;\n    stop: () => void;\n    now: () => number;\n}\ntype Driver = (update: Update$1) => DriverControls;\n\n/**\n * Temporary subset of VisualElement until VisualElement is\n * moved to motion-dom\n */\ninterface WithRender {\n    render: () => void;\n    readValue: (name: string, keyframe: any) => any;\n    getValue: (name: string, defaultValue?: any) => any;\n    current?: HTMLElement | SVGElement;\n    measureViewportBox: () => Box;\n}\n\ninterface ProgressTimeline {\n    currentTime: null | {\n        value: number;\n    };\n    cancel?: VoidFunction;\n}\ninterface ValueAnimationOptionsWithRenderContext<V extends string | number = number> extends ValueAnimationOptions<V> {\n    KeyframeResolver?: typeof KeyframeResolver;\n    motionValue?: MotionValue<V>;\n    element?: WithRender;\n}\ninterface TimelineWithFallback {\n    timeline?: ProgressTimeline;\n    observe: (animation: AnimationPlaybackControls) => VoidFunction;\n}\n/**\n * Methods to control an animation.\n */\ninterface AnimationPlaybackControls {\n    /**\n     * The current time of the animation, in seconds.\n     */\n    time: number;\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    speed: number;\n    /**\n     * The start time of the animation, in milliseconds.\n     */\n    startTime: number | null;\n    /**\n     * The state of the animation.\n     *\n     * This is currently for internal use only.\n     */\n    state: AnimationPlayState;\n    duration: number;\n    /**\n     * Stops the animation at its current state, and prevents it from\n     * resuming when the animation is played again.\n     */\n    stop: () => void;\n    /**\n     * Plays the animation.\n     */\n    play: () => void;\n    /**\n     * Pauses the animation.\n     */\n    pause: () => void;\n    /**\n     * Completes the animation and applies the final state.\n     */\n    complete: () => void;\n    /**\n     * Cancels the animation and applies the initial state.\n     */\n    cancel: () => void;\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     *\n     * This is currently for internal use only.\n     */\n    attachTimeline: (timeline: TimelineWithFallback) => VoidFunction;\n    finished: Promise<any>;\n}\ntype AnimationPlaybackControlsWithThen = AnimationPlaybackControls & {\n    then: (onResolve: VoidFunction, onReject?: VoidFunction) => Promise<void>;\n};\ninterface AnimationState<V> {\n    value: V;\n    done: boolean;\n}\ninterface KeyframeGenerator<V> {\n    calculatedDuration: null | number;\n    next: (t: number) => AnimationState<V>;\n    toString: () => string;\n}\ninterface DOMValueAnimationOptions<V extends string | number = number> extends ValueAnimationTransition<V> {\n    element: HTMLElement | SVGElement;\n    keyframes: ValueKeyframesDefinition;\n    name: string;\n    pseudoElement?: string;\n    allowFlatten?: boolean;\n}\ninterface ValueAnimationOptions<V extends string | number = number> extends ValueAnimationTransition {\n    keyframes: V[];\n    element?: any;\n    name?: string;\n    motionValue?: MotionValue<V>;\n    from?: V;\n    isHandoff?: boolean;\n    allowFlatten?: boolean;\n    finalKeyframe?: V;\n}\ntype GeneratorFactoryFunction = (options: ValueAnimationOptions<any>) => KeyframeGenerator<any>;\ninterface GeneratorFactory extends GeneratorFactoryFunction {\n    applyToOptions?: (options: Transition) => Transition;\n}\ntype AnimationGeneratorType = GeneratorFactory | \"decay\" | \"spring\" | \"keyframes\" | \"tween\" | \"inertia\";\ninterface AnimationPlaybackLifecycles<V> {\n    onUpdate?: (latest: V) => void;\n    onPlay?: () => void;\n    onComplete?: () => void;\n    onRepeat?: () => void;\n    onStop?: () => void;\n}\ninterface ValueAnimationTransition<V = any> extends Transition, AnimationPlaybackLifecycles<V> {\n}\ntype RepeatType = \"loop\" | \"reverse\" | \"mirror\";\ninterface AnimationPlaybackOptions {\n    repeat?: number;\n    repeatType?: RepeatType;\n    repeatDelay?: number;\n}\ninterface VelocityOptions {\n    velocity?: number;\n    restSpeed?: number;\n    restDelta?: number;\n}\ninterface DurationSpringOptions {\n    duration?: number;\n    visualDuration?: number;\n    bounce?: number;\n}\ninterface SpringOptions extends DurationSpringOptions, VelocityOptions {\n    stiffness?: number;\n    damping?: number;\n    mass?: number;\n}\ninterface DecayOptions extends VelocityOptions {\n    keyframes?: number[];\n    power?: number;\n    timeConstant?: number;\n    modifyTarget?: (v: number) => number;\n}\ninterface InertiaOptions extends DecayOptions {\n    bounceStiffness?: number;\n    bounceDamping?: number;\n    min?: number;\n    max?: number;\n}\ninterface KeyframeOptions {\n    ease?: Easing | Easing[];\n    times?: number[];\n}\ninterface Transition extends AnimationPlaybackOptions, Omit<SpringOptions, \"keyframes\">, Omit<InertiaOptions, \"keyframes\">, KeyframeOptions {\n    delay?: number;\n    elapsed?: number;\n    driver?: Driver;\n    type?: AnimationGeneratorType;\n    duration?: number;\n    autoplay?: boolean;\n    startTime?: number;\n}\ntype SVGPathTransitions = {\n    [K in keyof SVGPathProperties]: Transition;\n};\ntype SVGTransitions = {\n    [K in keyof SVGAttributes]: Transition;\n};\ntype VariableTransitions = {\n    [key: `--${string}`]: Transition;\n};\ntype StyleTransitions = {\n    [K in keyof CSSStyleDeclarationWithTransform]?: Transition;\n};\ntype ValueKeyframe = string | number;\ntype UnresolvedValueKeyframe = ValueKeyframe | null;\ntype ResolvedValueKeyframe = ValueKeyframe | ValueKeyframe[];\ntype ValueKeyframesDefinition = ValueKeyframe | ValueKeyframe[] | UnresolvedValueKeyframe[];\ntype StyleKeyframesDefinition = {\n    [K in keyof CSSStyleDeclarationWithTransform]?: ValueKeyframesDefinition;\n};\ntype SVGKeyframesDefinition = {\n    [K in keyof SVGAttributes]?: ValueKeyframesDefinition;\n};\ntype VariableKeyframesDefinition = {\n    [key: `--${string}`]: ValueKeyframesDefinition;\n};\ntype SVGPathKeyframesDefinition = {\n    [K in keyof SVGPathProperties]?: ValueKeyframesDefinition;\n};\ntype DOMKeyframesDefinition = StyleKeyframesDefinition & SVGKeyframesDefinition & SVGPathKeyframesDefinition & VariableKeyframesDefinition;\ninterface CSSStyleDeclarationWithTransform extends Omit<CSSStyleDeclaration, \"direction\" | \"transition\" | \"x\" | \"y\" | \"z\"> {\n    x: number | string;\n    y: number | string;\n    z: number | string;\n    rotateX: number | string;\n    rotateY: number | string;\n    rotateZ: number | string;\n    scaleX: number;\n    scaleY: number;\n    scaleZ: number;\n    skewX: number | string;\n    skewY: number | string;\n}\ntype AnimationOptionsWithValueOverrides<V = any> = StyleTransitions & SVGPathTransitions & SVGTransitions & VariableTransitions & ValueAnimationTransition<V>;\ntype DynamicOption<T> = (i: number, total: number) => T;\ninterface AnimationOptions extends Omit<AnimationOptionsWithValueOverrides, \"delay\"> {\n    delay?: number | DynamicOption<number>;\n}\ninterface TransformProperties {\n    x?: string | number;\n    y?: string | number;\n    z?: string | number;\n    translateX?: string | number;\n    translateY?: string | number;\n    translateZ?: string | number;\n    rotate?: string | number;\n    rotateX?: string | number;\n    rotateY?: string | number;\n    rotateZ?: string | number;\n    scale?: string | number;\n    scaleX?: string | number;\n    scaleY?: string | number;\n    scaleZ?: string | number;\n    skew?: string | number;\n    skewX?: string | number;\n    skewY?: string | number;\n    originX?: string | number;\n    originY?: string | number;\n    originZ?: string | number;\n    perspective?: string | number;\n    transformPerspective?: string | number;\n}\ninterface SVGPathProperties {\n    pathLength?: number;\n    pathOffset?: number;\n    pathSpacing?: number;\n}\n\n/**\n * @public\n */\ntype Subscriber<T> = (v: T) => void;\n/**\n * @public\n */\ntype PassiveEffect<T> = (v: T, safeSetter: (v: T) => void) => void;\ntype StartAnimation = (complete: () => void) => AnimationPlaybackControlsWithThen | undefined;\ninterface MotionValueEventCallbacks<V> {\n    animationStart: () => void;\n    animationComplete: () => void;\n    animationCancel: () => void;\n    change: (latestValue: V) => void;\n    renderRequest: () => void;\n    destroy: () => void;\n}\ninterface ResolvedValues {\n    [key: string]: string | number;\n}\ninterface Owner {\n    current: HTMLElement | unknown;\n    getProps: () => {\n        onUpdate?: (latest: ResolvedValues) => void;\n        transformTemplate?: (transform: TransformProperties, generatedTransform: string) => string;\n    };\n}\ninterface MotionValueOptions {\n    owner?: Owner;\n}\ndeclare const collectMotionValues: {\n    current: MotionValue[] | undefined;\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\ndeclare class MotionValue<V = any> {\n    /**\n     * This will be replaced by the build step with the latest version number.\n     * When MotionValues are provided to motion components, warn if versions are mixed.\n     */\n    version: string;\n    /**\n     * If a MotionValue has an owner, it was created internally within Motion\n     * and therefore has no external listeners. It is therefore safe to animate via WAAPI.\n     */\n    owner?: Owner;\n    /**\n     * The current state of the `MotionValue`.\n     */\n    private current;\n    /**\n     * The previous state of the `MotionValue`.\n     */\n    private prev;\n    /**\n     * The previous state of the `MotionValue` at the end of the previous frame.\n     */\n    private prevFrameValue;\n    /**\n     * The last time the `MotionValue` was updated.\n     */\n    updatedAt: number;\n    /**\n     * The time `prevFrameValue` was updated.\n     */\n    prevUpdatedAt: number | undefined;\n    private stopPassiveEffect?;\n    /**\n     * A reference to the currently-controlling animation.\n     */\n    animation?: AnimationPlaybackControlsWithThen;\n    /**\n     * Tracks whether this value should be removed\n     */\n    liveStyle?: boolean;\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     */\n    constructor(init: V, options?: MotionValueOptions);\n    setCurrent(current: V): void;\n    setPrevFrameValue(prevFrameValue?: V | undefined): void;\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription: Subscriber<V>): () => void;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events;\n    on<EventName extends keyof MotionValueEventCallbacks<V>>(eventName: EventName, callback: MotionValueEventCallbacks<V>[EventName]): VoidFunction;\n    clearListeners(): void;\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     */\n    attach(passiveEffect: PassiveEffect<V>, stopPassiveEffect: VoidFunction): void;\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v: V, render?: boolean): void;\n    setWithVelocity(prev: V, current: V, delta: number): void;\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v: V, endAnimation?: boolean): void;\n    updateAndNotify: (v: V, render?: boolean) => void;\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get(): NonNullable<V>;\n    /**\n     * @public\n     */\n    getPrevious(): V | undefined;\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity(): number;\n    hasAnimated: boolean;\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     */\n    start(startAnimation: StartAnimation): Promise<void>;\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop(): void;\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating(): boolean;\n    private clearAnimation;\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy(): void;\n}\ndeclare function motionValue<V>(init: V, options?: MotionValueOptions): MotionValue<V>;\n\ntype UnresolvedKeyframes<T extends string | number> = Array<T | null>;\ntype ResolvedKeyframes<T extends string | number> = Array<T>;\ndeclare function flushKeyframeResolvers(): void;\ntype OnKeyframesResolved<T extends string | number> = (resolvedKeyframes: ResolvedKeyframes<T>, finalKeyframe: T, forced: boolean) => void;\ndeclare class KeyframeResolver<T extends string | number = any> {\n    name?: string;\n    element?: WithRender;\n    finalKeyframe?: T;\n    suspendedScrollY?: number;\n    protected unresolvedKeyframes: UnresolvedKeyframes<string | number>;\n    private motionValue?;\n    private onComplete;\n    /**\n     * Track whether this resolver has completed. Once complete, it never\n     * needs to attempt keyframe resolution again.\n     */\n    private isComplete;\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n    private isAsync;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n    needsMeasurement: boolean;\n    /**\n     * Track whether this resolver is currently scheduled to resolve\n     * to allow it to be cancelled and resumed externally.\n     */\n    isScheduled: boolean;\n    constructor(unresolvedKeyframes: UnresolvedKeyframes<string | number>, onComplete: OnKeyframesResolved<T>, name?: string, motionValue?: MotionValue<T>, element?: WithRender, isAsync?: boolean);\n    scheduleResolve(): void;\n    readKeyframes(): void;\n    setFinalKeyframe(): void;\n    measureInitialState(): void;\n    renderEndStyles(): void;\n    measureEndState(): void;\n    complete(isForced?: boolean): void;\n    cancel(): void;\n    resume(): void;\n}\n\ndeclare class WithPromise {\n    protected _finished: Promise<void>;\n    resolve: VoidFunction;\n    count: number;\n    constructor();\n    get finished(): Promise<void>;\n    protected updateFinished(): void;\n    protected notifyFinished(): void;\n    /**\n     * Allows the animation to be awaited.\n     *\n     * @deprecated Use `finished` instead.\n     */\n    then(onResolve: VoidFunction, onReject?: VoidFunction): Promise<void>;\n}\n\ntype OptionsWithoutKeyframes<T extends string | number> = Omit<ValueAnimationOptions<T>, \"keyframes\">;\ndeclare class AsyncMotionValueAnimation<T extends string | number> extends WithPromise implements AnimationPlaybackControls {\n    private createdAt;\n    private resolvedAt;\n    private _animation;\n    private pendingTimeline;\n    private keyframeResolver;\n    private stopTimeline;\n    constructor({ autoplay, delay, type, repeat, repeatDelay, repeatType, keyframes, name, motionValue, element, ...options }: ValueAnimationOptions<T>);\n    onKeyframesResolved(keyframes: ResolvedKeyframes<T>, finalKeyframe: T, options: OptionsWithoutKeyframes<T>, sync: boolean): void;\n    get finished(): Promise<any>;\n    then(onResolve: VoidFunction, _onReject?: VoidFunction): Promise<void>;\n    get animation(): AnimationPlaybackControls;\n    get duration(): number;\n    get time(): number;\n    set time(newTime: number);\n    get speed(): number;\n    get state(): AnimationPlayState;\n    set speed(newSpeed: number);\n    get startTime(): number | null;\n    attachTimeline(timeline: TimelineWithFallback): () => void;\n    play(): void;\n    pause(): void;\n    complete(): void;\n    cancel(): void;\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    stop: () => void;\n}\n\ntype AcceptedAnimations = AnimationPlaybackControls;\ntype GroupedAnimations = AcceptedAnimations[];\ndeclare class GroupAnimation implements AnimationPlaybackControls {\n    animations: GroupedAnimations;\n    constructor(animations: Array<AcceptedAnimations | undefined>);\n    get finished(): Promise<any[]>;\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    private getAll;\n    private setAll;\n    attachTimeline(timeline: TimelineWithFallback): () => void;\n    get time(): number;\n    set time(time: number);\n    get speed(): number;\n    set speed(speed: number);\n    get state(): any;\n    get startTime(): any;\n    get duration(): number;\n    private runAll;\n    play(): void;\n    pause(): void;\n    stop: () => void;\n    cancel(): void;\n    complete(): void;\n}\n\ndeclare class GroupAnimationWithThen extends GroupAnimation implements AnimationPlaybackControlsWithThen {\n    then(onResolve: VoidFunction, _onReject?: VoidFunction): Promise<void>;\n}\n\ndeclare class JSAnimation<T extends number | string> extends WithPromise implements AnimationPlaybackControlsWithThen {\n    state: AnimationPlayState;\n    startTime: number | null;\n    /**\n     * The driver that's controlling the animation loop. Normally this is a requestAnimationFrame loop\n     * but in tests we can pass in a synchronous loop.\n     */\n    private driver?;\n    private isStopped;\n    private generator;\n    private calculatedDuration;\n    private resolvedDuration;\n    private totalDuration;\n    private options;\n    /**\n     * The current time of the animation.\n     */\n    private currentTime;\n    /**\n     * The time at which the animation was paused.\n     */\n    private holdTime;\n    /**\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n     */\n    private playbackSpeed;\n    private mixKeyframes;\n    private mirroredGenerator;\n    constructor(options: ValueAnimationOptions<T>);\n    initAnimation(): void;\n    updateTime(timestamp: number): void;\n    tick(timestamp: number, sample?: boolean): AnimationState<T>;\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve: VoidFunction, reject?: VoidFunction): Promise<void>;\n    get duration(): number;\n    get time(): number;\n    set time(newTime: number);\n    get speed(): number;\n    set speed(newSpeed: number);\n    play(): void;\n    pause(): void;\n    /**\n     * This method is bound to the instance to fix a pattern where\n     * animation.stop is returned as a reference from a useEffect.\n     */\n    stop: () => void;\n    complete(): void;\n    finish(): void;\n    cancel(): void;\n    private teardown;\n    private stopDriver;\n    sample(sampleTime: number): AnimationState<T>;\n    attachTimeline(timeline: TimelineWithFallback): VoidFunction;\n}\ndeclare function animateValue<T extends number | string>(options: ValueAnimationOptions<T>): JSAnimation<T>;\n\ninterface NativeAnimationOptions<V extends string | number = number> extends DOMValueAnimationOptions<V> {\n    pseudoElement?: string;\n    startTime?: number;\n}\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\ndeclare class NativeAnimation<T extends string | number> extends WithPromise implements AnimationPlaybackControlsWithThen {\n    /**\n     * The interfaced Web Animation API animation\n     */\n    protected animation: Animation;\n    protected finishedTime: number | null;\n    protected options: NativeAnimationOptions;\n    private allowFlatten;\n    private isStopped;\n    private isPseudoElement;\n    constructor(options?: NativeAnimationOptions);\n    updateMotionValue?(value?: T): void;\n    play(): void;\n    pause(): void;\n    complete(): void;\n    cancel(): void;\n    stop(): void;\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    protected commitStyles(): void;\n    get duration(): number;\n    get time(): number;\n    set time(newTime: number);\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed(): number;\n    set speed(newSpeed: number);\n    get state(): AnimationPlayState;\n    get startTime(): number;\n    set startTime(newStartTime: number);\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }: TimelineWithFallback): VoidFunction;\n}\n\ntype NativeAnimationOptionsExtended<T extends string | number> = NativeAnimationOptions & ValueAnimationOptions<T> & NativeAnimationOptions;\ndeclare class NativeAnimationExtended<T extends string | number> extends NativeAnimation<T> {\n    options: NativeAnimationOptionsExtended<T>;\n    constructor(options: NativeAnimationOptionsExtended<T>);\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    updateMotionValue(value?: T): void;\n}\n\ndeclare class NativeAnimationWrapper<T extends string | number> extends NativeAnimation<T> {\n    constructor(animation: Animation);\n}\n\ndeclare const animationMapKey: (name: string, pseudoElement?: string) => string;\ndeclare function getAnimationMap(element: Element): Map<any, any>;\n\ntype CSSVariableName = `--${string}`;\ntype CSSVariableToken = `var(${CSSVariableName})`;\ndeclare const isCSSVariableName: (key?: string | number | null) => key is `--${string}`;\ndeclare const isCSSVariableToken: (value?: string) => value is `var(--${string})`;\n\ndeclare function parseCSSVariable(current: string): string[] | undefined[];\ndeclare function getVariableValue(current: CSSVariableToken, element: Element, depth?: number): string | number | undefined;\n\ndeclare function getValueTransition(transition: any, key: string): any;\n\ndeclare function inertia({ keyframes, velocity, power, timeConstant, bounceDamping, bounceStiffness, modifyTarget, min, max, restDelta, restSpeed, }: ValueAnimationOptions<number>): KeyframeGenerator<number>;\n\ndeclare function defaultEasing(values: any[], easing?: EasingFunction): EasingFunction[];\ndeclare function keyframes<T extends string | number>({ duration, keyframes: keyframeValues, times, ease, }: ValueAnimationOptions<T>): KeyframeGenerator<T>;\n\ndeclare function spring(optionsOrVisualDuration?: ValueAnimationOptions<number> | number, bounce?: number): KeyframeGenerator<number>;\ndeclare namespace spring {\n    var applyToOptions: (options: Transition) => Transition;\n}\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\ndeclare const maxGeneratorDuration = 20000;\ndeclare function calcGeneratorDuration(generator: KeyframeGenerator<unknown>): number;\n\n/**\n * Create a progress => progress easing function from a generator.\n */\ndeclare function createGeneratorEasing(options: Transition, scale: number | undefined, createGenerator: GeneratorFactory): {\n    type: string;\n    ease: (progress: number) => number;\n    duration: number;\n};\n\ndeclare function isGenerator(type?: AnimationGeneratorType): type is GeneratorFactory;\n\ndeclare class DOMKeyframesResolver<T extends string | number> extends KeyframeResolver<T> {\n    name: string;\n    element?: WithRender;\n    private removedTransforms?;\n    private measuredOrigin?;\n    constructor(unresolvedKeyframes: UnresolvedKeyframes<string | number>, onComplete: OnKeyframesResolved<T>, name?: string, motionValue?: MotionValue<T>, element?: WithRender);\n    readKeyframes(): void;\n    resolveNoneKeyframes(): void;\n    measureInitialState(): void;\n    measureEndState(): void;\n}\n\ndeclare function defaultOffset(arr: any[]): number[];\n\ndeclare function fillOffset(offset: number[], remaining: number): void;\n\ndeclare function convertOffsetToTimes(offset: number[], duration: number): number[];\n\ndeclare function applyPxDefaults(keyframes: ValueKeyframe[] | UnresolvedValueKeyframe[], name: string): void;\n\ndeclare function fillWildcards(keyframes: ValueKeyframe[] | UnresolvedValueKeyframe[]): void;\n\ndeclare const cubicBezierAsString: ([a, b, c, d]: BezierDefinition) => string;\n\ndeclare function isWaapiSupportedEasing(easing?: Easing | Easing[]): boolean;\n\ndeclare function mapEasingToNativeEasing(easing: Easing | Easing[] | undefined, duration: number): undefined | string | string[];\n\ndeclare const supportedWaapiEasing: {\n    linear: string;\n    ease: string;\n    easeIn: string;\n    easeOut: string;\n    easeInOut: string;\n    circIn: string;\n    circOut: string;\n    backIn: string;\n    backOut: string;\n};\n\ndeclare function startWaapiAnimation(element: Element, valueName: string, keyframes: ValueKeyframesDefinition, { delay, duration, repeat, repeatType, ease, times, }?: Transition, pseudoElement?: string | undefined): Animation;\n\ndeclare const supportsPartialKeyframes: () => boolean;\n\ndeclare function supportsBrowserAnimation<T extends string | number>(options: ValueAnimationOptionsWithRenderContext<T>): any;\n\n/**\n * A list of values that can be hardware-accelerated.\n */\ndeclare const acceleratedValues: Set<string>;\n\ndeclare const generateLinearEasing: (easing: EasingFunction, duration: number, resolution?: number) => string;\n\ntype ElementOrSelector = Element | Element[] | NodeListOf<Element> | string;\ninterface WithQuerySelectorAll {\n    querySelectorAll: Element[\"querySelectorAll\"];\n}\ninterface AnimationScope<T = any> {\n    readonly current: T;\n    animations: any[];\n}\ninterface SelectorCache {\n    [key: string]: NodeListOf<Element>;\n}\ndeclare function resolveElements(elementOrSelector: ElementOrSelector, scope?: AnimationScope, selectorCache?: SelectorCache): Element[];\n\ndeclare function styleEffect(subject: ElementOrSelector, values: Record<string, MotionValue>): () => void;\n\ndeclare const frame: Batcher;\ndeclare const cancelFrame: (process: Process) => void;\ndeclare const frameData: FrameData;\ndeclare const frameSteps: Steps;\n\ntype Process = (data: FrameData) => void;\ntype Schedule = (process: Process, keepAlive?: boolean, immediate?: boolean) => Process;\ninterface Step {\n    schedule: Schedule;\n    cancel: (process: Process) => void;\n    process: (data: FrameData) => void;\n}\ntype StepId = \"setup\" | \"read\" | \"resolveKeyframes\" | \"preUpdate\" | \"update\" | \"preRender\" | \"render\" | \"postRender\";\ntype CancelProcess = (process: Process) => void;\ntype Batcher = {\n    [key in StepId]: Schedule;\n};\ntype Steps = {\n    [key in StepId]: Step;\n};\ninterface FrameData {\n    delta: number;\n    timestamp: number;\n    isProcessing: boolean;\n}\n\ndeclare function createRenderBatcher(scheduleNextBatch: (callback: Function) => void, allowKeepAlive: boolean): {\n    schedule: Batcher;\n    cancel: (process: Process) => void;\n    state: FrameData;\n    steps: Steps;\n};\n\ndeclare const microtask: Batcher;\ndeclare const cancelMicrotask: (process: Process) => void;\n\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn't useful for animations when we're usually\n * trying to sync animations to the same frame.\n */\ndeclare const time: {\n    now: () => number;\n    set: (newTime: number) => void;\n};\n\ndeclare const isDragging: {\n    x: boolean;\n    y: boolean;\n};\ndeclare function isDragActive(): boolean;\n\ndeclare function setDragLock(axis: boolean | \"x\" | \"y\" | \"lockDirection\"): (() => void) | null;\n\n/**\n * Options for the hover gesture.\n *\n * @public\n */\ninterface EventOptions {\n    /**\n     * Use passive event listeners. Doing so allows the browser to optimize\n     * scrolling performance by not allowing the use of `preventDefault()`.\n     *\n     * @default true\n     */\n    passive?: boolean;\n    /**\n     * Remove the event listener after the first event.\n     *\n     * @default false\n     */\n    once?: boolean;\n}\n\n/**\n * A function to be called when a hover gesture starts.\n *\n * This function can optionally return a function that will be called\n * when the hover gesture ends.\n *\n * @public\n */\ntype OnHoverStartEvent = (element: Element, event: PointerEvent) => void | OnHoverEndEvent;\n/**\n * A function to be called when a hover gesture ends.\n *\n * @public\n */\ntype OnHoverEndEvent = (event: PointerEvent) => void;\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\ndeclare function hover(elementOrSelector: ElementOrSelector, onHoverStart: OnHoverStartEvent, options?: EventOptions): VoidFunction;\n\ninterface PressGestureInfo {\n    success: boolean;\n}\ntype OnPressEndEvent = (event: PointerEvent, info: PressGestureInfo) => void;\ntype OnPressStartEvent = (element: Element, event: PointerEvent) => OnPressEndEvent | void;\n\ninterface PointerEventOptions extends EventOptions {\n    useGlobalTarget?: boolean;\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\ndeclare function press(targetOrSelector: ElementOrSelector, onPressStart: OnPressStartEvent, options?: PointerEventOptions): VoidFunction;\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\ndeclare const isNodeOrChild: (parent: Element | null, child?: Element | null) => boolean;\n\ndeclare const isPrimaryPointer: (event: PointerEvent) => boolean;\n\ndeclare function parseValueFromTransform(transform: string | undefined, name: string): number;\ndeclare const readTransformValue: (instance: HTMLElement, name: string) => number;\n\ndeclare function getComputedStyle(element: HTMLElement | SVGElement, name: string): string;\n\ndeclare function setStyle(element: HTMLElement | SVGElement, name: string, value: string | number): void;\n\ndeclare const positionalKeys: Set<string>;\n\n/**\n * Generate a list of every possible transform key.\n */\ndeclare const transformPropOrder: string[];\n/**\n * A quick lookup for transform props.\n */\ndeclare const transformProps: Set<string>;\n\ntype Update = (progress: number) => void;\ndeclare function observeTimeline(update: Update, timeline: ProgressTimeline): () => void;\n\ndeclare const stepsOrder: StepId[];\ntype StepNames = (typeof stepsOrder)[number];\n\ninterface Summary {\n    min: number;\n    max: number;\n    avg: number;\n}\ntype FrameloopStatNames = \"rate\" | StepNames;\ninterface Stats<T> {\n    frameloop: {\n        [key in FrameloopStatNames]: T;\n    };\n    animations: {\n        mainThread: T;\n        waapi: T;\n        layout: T;\n    };\n    layoutProjection: {\n        nodes: T;\n        calculatedTargetDeltas: T;\n        calculatedProjections: T;\n    };\n}\ntype StatsBuffer = number[];\ntype FrameStats = Stats<number>;\ntype StatsRecording = Stats<StatsBuffer>;\ntype StatsSummary = Stats<Summary>;\n\ndeclare function reportStats(): StatsSummary;\ndeclare function recordStats(): typeof reportStats;\n\ndeclare const activeAnimations: {\n    layout: number;\n    mainThread: number;\n    waapi: number;\n};\n\ntype InactiveStatsBuffer = {\n    value: null;\n    addProjectionMetrics: null;\n};\ntype ActiveStatsBuffer = {\n    value: StatsRecording;\n    addProjectionMetrics: (metrics: {\n        nodes: number;\n        calculatedTargetDeltas: number;\n        calculatedProjections: number;\n    }) => void;\n};\ndeclare const statsBuffer: InactiveStatsBuffer | ActiveStatsBuffer;\n\ntype Mixer<T> = (p: number) => T;\ntype MixerFactory<T> = (a: T, b: T) => Mixer<T>;\n\ninterface InterpolateOptions<T> {\n    clamp?: boolean;\n    ease?: EasingFunction | EasingFunction[];\n    mixer?: MixerFactory<T>;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\ndeclare function interpolate<T>(input: number[], output: T[], { clamp: isClamp, ease, mixer }?: InterpolateOptions<T>): (v: number) => T;\n\ndeclare function mix<T>(from: T, to: T): Mixer<T>;\ndeclare function mix(from: number, to: number, p: number): number;\n\ntype Transformer = (v: any) => any;\ntype ValueType = {\n    test: (v: any) => boolean;\n    parse: (v: any) => any;\n    transform?: Transformer;\n    createTransformer?: (template: string) => Transformer;\n    default?: any;\n    getAnimatableNone?: (v: any) => any;\n};\ntype NumberMap = {\n    [key: string]: number;\n};\ntype RGBA = {\n    red: number;\n    green: number;\n    blue: number;\n    alpha: number;\n};\ntype HSLA = {\n    hue: number;\n    saturation: number;\n    lightness: number;\n    alpha: number;\n};\ntype Color = HSLA | RGBA;\n\ndeclare const mixLinearColor: (from: number, to: number, v: number) => number;\ndeclare const mixColor: (from: Color | string, to: Color | string) => (p: number) => string | Color;\n\ntype MixableArray = Array<number | RGBA | HSLA | string>;\ntype MixableObject = {\n    [key: string]: string | number | RGBA | HSLA;\n};\ndeclare function getMixer<T>(a: T): ((from: string | Color, to: string | Color) => (p: number) => string | Color) | ((origin: string | number, target: string | number) => Function) | typeof mixArray | typeof mixObject;\ndeclare function mixArray(a: MixableArray, b: MixableArray): (p: number) => (string | number | RGBA | HSLA)[];\ndeclare function mixObject(a: MixableObject, b: MixableObject): (v: number) => {\n    [x: string]: string | number | RGBA | HSLA;\n};\ndeclare const mixComplex: (origin: string | number, target: string | number) => Function;\n\ndeclare function mixImmediate<T>(a: T, b: T): (p: number) => T;\n\ndeclare const mixNumber: (from: number, to: number, progress: number) => number;\n\ndeclare const invisibleValues: Set<string>;\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the \"none\" or \"hidden\" string only when the progress is that of\n * the origin or target.\n */\ndeclare function mixVisibility(origin: string, target: string): (p: number) => string;\n\n/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\ndeclare const supportsFlags: Record<string, boolean | undefined>;\n\ndeclare const supportsLinearEasing: () => boolean;\n\ndeclare global {\n    interface Window {\n        ScrollTimeline: ScrollTimeline;\n    }\n}\ndeclare class ScrollTimeline implements ProgressTimeline {\n    constructor(options: ScrollOptions);\n    currentTime: null | {\n        value: number;\n    };\n    cancel?: VoidFunction;\n}\ndeclare const supportsScrollTimeline: () => boolean;\n\n/**\n * @public\n */\ninterface TransformOptions<T> {\n    /**\n     * Clamp values to within the given range. Defaults to `true`\n     *\n     * @public\n     */\n    clamp?: boolean;\n    /**\n     * Easing functions to use on the interpolations between each value in the input and output ranges.\n     *\n     * If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition **between** each.\n     *\n     * @public\n     */\n    ease?: EasingFunction | EasingFunction[];\n    /**\n     * Provide a function that can interpolate between any two values in the provided range.\n     *\n     * @public\n     */\n    mixer?: (from: T, to: T) => (v: number) => any;\n}\n/**\n * Transforms numbers into other values by mapping them from an input range to an output range.\n * Returns the type of the input provided.\n *\n * @remarks\n *\n * Given an input range of `[0, 200]` and an output range of\n * `[0, 1]`, this function will return a value between `0` and `1`.\n * The input range must be a linear series of numbers. The output range\n * can be any supported value type, such as numbers, colors, shadows, arrays, objects and more.\n * Every value in the output range must be of the same type and in the same format.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { transform } from \"framer-motion\"\n *\n * export function MyComponent() {\n *    const inputRange = [0, 200]\n *    const outputRange = [0, 1]\n *    const output = transform(100, inputRange, outputRange)\n *\n *    // Returns 0.5\n *    return <div>{output}</div>\n * }\n * ```\n *\n * @param inputValue - A number to transform between the input and output ranges.\n * @param inputRange - A linear series of numbers (either all increasing or decreasing).\n * @param outputRange - A series of numbers, colors, strings, or arrays/objects of those. Must be the same length as `inputRange`.\n * @param options - Clamp: Clamp values to within the given range. Defaults to `true`.\n *\n * @public\n */\ndeclare function transform<T>(inputValue: number, inputRange: number[], outputRange: T[], options?: TransformOptions<T>): T;\n/**\n *\n * Transforms numbers into other values by mapping them from an input range to an output range.\n *\n * Given an input range of `[0, 200]` and an output range of\n * `[0, 1]`, this function will return a value between `0` and `1`.\n * The input range must be a linear series of numbers. The output range\n * can be any supported value type, such as numbers, colors, shadows, arrays, objects and more.\n * Every value in the output range must be of the same type and in the same format.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, transform } from \"framer\"\n *\n * export function MyComponent() {\n *     const inputRange = [-200, -100, 100, 200]\n *     const outputRange = [0, 1, 1, 0]\n *     const convertRange = transform(inputRange, outputRange)\n *     const output = convertRange(-150)\n *\n *     // Returns 0.5\n *     return <div>{output}</div>\n * }\n *\n * ```\n *\n * @param inputRange - A linear series of numbers (either all increasing or decreasing).\n * @param outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.\n * @param options - Clamp: clamp values to within the given range. Defaults to `true`.\n *\n * @public\n */\ndeclare function transform<T>(inputRange: number[], outputRange: T[], options?: TransformOptions<T>): (inputValue: number) => T;\n\ntype MapInputRange = number[];\n/**\n * Create a `MotionValue` that maps the output of another `MotionValue` by\n * mapping it from one range of values into another.\n *\n * @remarks\n *\n * Given an input range of `[-200, -100, 100, 200]` and an output range of\n * `[0, 1, 1, 0]`, the returned `MotionValue` will:\n *\n * - When provided a value between `-200` and `-100`, will return a value between `0` and  `1`.\n * - When provided a value between `-100` and `100`, will return `1`.\n * - When provided a value between `100` and `200`, will return a value between `1` and  `0`\n *\n * The input range must be a linear series of numbers. The output range\n * can be any value type supported by Motion: numbers, colors, shadows, etc.\n *\n * Every value in the output range must be of the same type and in the same format.\n *\n * ```jsx\n * const x = motionValue(0)\n * const xRange = [-200, -100, 100, 200]\n * const opacityRange = [0, 1, 1, 0]\n * const opacity = mapValue(x, xRange, opacityRange)\n * ```\n *\n * @param inputValue - `MotionValue`\n * @param inputRange - A linear series of numbers (either all increasing or decreasing)\n * @param outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.\n * @param options -\n *\n *  - clamp: boolean. Clamp values to within the given range. Defaults to `true`\n *  - ease: EasingFunction[]. Easing functions to use on the interpolations between each value in the input and output ranges. If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition between each.\n *\n * @returns `MotionValue`\n *\n * @public\n */\ndeclare function mapValue<O>(inputValue: MotionValue<number>, inputRange: MapInputRange, outputRange: O[], options?: TransformOptions<O>): MotionValue<O>;\n\ntype TransformInputRange = number[];\ntype SingleTransformer<I, O> = (input: I) => O;\ntype MultiTransformer<I, O> = (input: I[]) => O;\ntype ValueTransformer<I, O> = SingleTransformer<I, O> | MultiTransformer<I, O>;\n/**\n * Create a `MotionValue` that transforms the output of other `MotionValue`s by\n * passing their latest values through a transform function.\n *\n * Whenever a `MotionValue` referred to in the provided function is updated,\n * it will be re-evaluated.\n *\n * ```jsx\n * const x = motionValue(0)\n * const y = transformValue(() => x.get() * 2) // double x\n * ```\n *\n * @param transformer - A transform function. This function must be pure with no side-effects or conditional statements.\n * @returns `MotionValue`\n *\n * @public\n */\ndeclare function transformValue<O>(transform: () => O): MotionValue<O>;\n\ndeclare const color: {\n    test: (v: any) => boolean;\n    parse: (v: any) => RGBA | HSLA;\n    transform: (v: HSLA | RGBA | string) => string;\n};\n\ndeclare function parseHex(v: string): RGBA;\ndeclare const hex: {\n    test: (v: any) => boolean;\n    parse: typeof parseHex;\n    transform: ({ red, green, blue, alpha }: RGBA) => string;\n};\n\ndeclare const hsla: {\n    test: (v: any) => boolean;\n    parse: (v: string | Color) => HSLA;\n    transform: ({ hue, saturation, lightness, alpha }: HSLA) => string;\n};\n\ndeclare function hslaToRgba({ hue, saturation, lightness, alpha }: HSLA): RGBA;\n\ndeclare const rgbUnit: {\n    transform: (v: number) => number;\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n};\ndeclare const rgba: {\n    test: (v: any) => boolean;\n    parse: (v: string | Color) => RGBA;\n    transform: ({ red, green, blue, alpha }: RGBA) => string;\n};\n\ndeclare function test(v: any): boolean;\ntype ComplexValues = Array<CSSVariableToken | string | number | Color>;\ntype ValueIndexes = {\n    color: number[];\n    number: number[];\n    var: number[];\n};\ninterface ComplexValueInfo {\n    values: ComplexValues;\n    split: string[];\n    indexes: ValueIndexes;\n    types: Array<keyof ValueIndexes>;\n}\ndeclare function analyseComplexValue(value: string | number): ComplexValueInfo;\ndeclare function parseComplexValue(v: string | number): ComplexValues;\ndeclare function createTransformer(source: string | number): (v: Array<CSSVariableToken | Color | number | string>) => string;\ndeclare function getAnimatableNone$1(v: string | number): string;\ndeclare const complex: {\n    test: typeof test;\n    parse: typeof parseComplexValue;\n    createTransformer: typeof createTransformer;\n    getAnimatableNone: typeof getAnimatableNone$1;\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\ndeclare const dimensionValueTypes: (ValueType | {\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number) => number;\n} | {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: string | number) => string;\n})[];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\ndeclare const findDimensionValueType: (v: any) => ValueType | {\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number) => number;\n} | {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: string | number) => string;\n} | undefined;\n\ninterface ValueTypeMap {\n    [key: string]: ValueType;\n}\n\n/**\n * A map of default value types for common values\n */\ndeclare const defaultValueTypes: ValueTypeMap;\n/**\n * Gets the default ValueType for the provided value key\n */\ndeclare const getDefaultValueType: (key: string) => ValueType;\n\ndeclare const numberValueTypes: ValueTypeMap;\n\ndeclare const transformValueTypes: ValueTypeMap;\n\ndeclare const number: {\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number) => number;\n};\ndeclare const alpha: {\n    transform: (v: number) => number;\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n};\ndeclare const scale: {\n    default: number;\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number) => number;\n};\n\ndeclare const degrees: {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number | string) => string;\n};\ndeclare const percent: {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number | string) => string;\n};\ndeclare const px: {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number | string) => string;\n};\ndeclare const vh: {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number | string) => string;\n};\ndeclare const vw: {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number | string) => string;\n};\ndeclare const progressPercentage: {\n    parse: (v: string) => number;\n    transform: (v: number) => string;\n    test: (v: string | number) => boolean;\n};\n\n/**\n * Tests a provided value against a ValueType\n */\ndeclare const testValueType: (v: any) => (type: ValueType) => boolean;\n\ndeclare function getAnimatableNone(key: string, value: string): any;\n\n/**\n * Tests a value against the list of ValueTypes\n */\ndeclare const findValueType: (v: any) => ValueType | {\n    test: (v: number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: number) => number;\n} | {\n    test: (v: string | number) => boolean;\n    parse: typeof parseFloat;\n    transform: (v: string | number) => string;\n} | {\n    test: (v: any) => boolean;\n    parse: (v: any) => RGBA | HSLA;\n    transform: (v: string | RGBA | HSLA) => string;\n} | {\n    test: (v: any) => boolean;\n    parse: (v: string | number) => ComplexValues;\n    createTransformer: (source: string | number) => (v: (string | number | Color)[]) => string;\n    getAnimatableNone: (v: string | number) => string;\n} | undefined;\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\ndeclare const getValueAsType: (value: any, type?: ValueType) => any;\n\ntype ViewTransitionAnimationDefinition = {\n    keyframes: DOMKeyframesDefinition;\n    options: AnimationOptions;\n};\ntype ViewTransitionTarget = {\n    layout?: ViewTransitionAnimationDefinition;\n    enter?: ViewTransitionAnimationDefinition;\n    exit?: ViewTransitionAnimationDefinition;\n    new?: ViewTransitionAnimationDefinition;\n    old?: ViewTransitionAnimationDefinition;\n};\ninterface ViewTransitionOptions extends AnimationOptions {\n    interrupt?: \"wait\" | \"immediate\";\n}\ntype Target = string | Element;\n\ndeclare class ViewTransitionBuilder {\n    private currentTarget;\n    targets: Map<Target, ViewTransitionTarget>;\n    update: () => void | Promise<void>;\n    options: ViewTransitionOptions;\n    notifyReady: (value: GroupAnimation) => void;\n    private readyPromise;\n    constructor(update: () => void | Promise<void>, options?: ViewTransitionOptions);\n    get(selector: Target): this;\n    layout(keyframes: DOMKeyframesDefinition, options?: AnimationOptions): this;\n    new(keyframes: DOMKeyframesDefinition, options?: AnimationOptions): this;\n    old(keyframes: DOMKeyframesDefinition, options?: AnimationOptions): this;\n    enter(keyframes: DOMKeyframesDefinition, options?: AnimationOptions): this;\n    exit(keyframes: DOMKeyframesDefinition, options?: AnimationOptions): this;\n    crossfade(options?: AnimationOptions): this;\n    updateTarget(target: \"enter\" | \"exit\" | \"layout\" | \"new\" | \"old\", keyframes: DOMKeyframesDefinition, options?: AnimationOptions): void;\n    then(resolve: () => void, reject?: () => void): Promise<void>;\n}\ndeclare function animateView(update: () => void | Promise<void>, defaultOptions?: ViewTransitionOptions): ViewTransitionBuilder;\n\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\ndeclare const sync: Batcher;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\ndeclare const cancelSync: Record<string, (process: Process) => void>;\n\nexport { type AcceptedAnimations, type ActiveStatsBuffer, type AnimationGeneratorType, type AnimationOptions, type AnimationOptionsWithValueOverrides, type AnimationPlaybackControls, type AnimationPlaybackControlsWithThen, type AnimationPlaybackLifecycles, type AnimationPlaybackOptions, type AnimationScope, type AnimationState, AsyncMotionValueAnimation, type Batcher, type CSSStyleDeclarationWithTransform, type CSSVariableName, type CSSVariableToken, type CancelProcess, type Color, type ComplexValueInfo, type ComplexValues, type DOMKeyframesDefinition, DOMKeyframesResolver, type DOMValueAnimationOptions, type DecayOptions, type DurationSpringOptions, type DynamicOption, type ElementOrSelector, type EventOptions, type FrameData, type FrameStats, type GeneratorFactory, type GeneratorFactoryFunction, GroupAnimation, GroupAnimationWithThen, type GroupedAnimations, type HSLA, type InactiveStatsBuffer, type InertiaOptions, type InterpolateOptions, JSAnimation, type KeyframeGenerator, type KeyframeOptions, KeyframeResolver, type MapInputRange, type Mixer, type MixerFactory, MotionValue, type MotionValueEventCallbacks, type MotionValueOptions, type MultiTransformer, NativeAnimation, NativeAnimationExtended, type NativeAnimationOptions, type NativeAnimationOptionsExtended, NativeAnimationWrapper, type NumberMap, type OnHoverEndEvent, type OnHoverStartEvent, type OnKeyframesResolved, type OnPressEndEvent, type OnPressStartEvent, type Owner, type PassiveEffect, type PointerEventOptions, type PressGestureInfo, type Process, type ProgressTimeline, type RGBA, type RepeatType, type ResolvedKeyframes, type ResolvedValueKeyframe, type SVGAttributes, type SVGKeyframesDefinition, type SVGPathKeyframesDefinition, type SVGPathProperties, type SVGPathTransitions, type SVGTransitions, type Schedule, type SelectorCache, type SingleTransformer, type SpringOptions, type StartAnimation, type Stats, type StatsBuffer, type StatsRecording, type StatsSummary, type Step, type StepId, type Steps, type StyleKeyframesDefinition, type StyleTransitions, type Subscriber, type Summary, type Target, type TimelineWithFallback, type TransformInputRange, type TransformOptions, type TransformProperties, type Transformer, type Transition, type UnresolvedKeyframes, type UnresolvedValueKeyframe, type ValueAnimationOptions, type ValueAnimationOptionsWithRenderContext, type ValueAnimationTransition, type ValueIndexes, type ValueKeyframe, type ValueKeyframesDefinition, type ValueTransformer, type ValueType, type ValueTypeMap, type VariableKeyframesDefinition, type VariableTransitions, type VelocityOptions, type ViewTransitionAnimationDefinition, ViewTransitionBuilder, type ViewTransitionOptions, type ViewTransitionTarget, type WithQuerySelectorAll, acceleratedValues, activeAnimations, alpha, analyseComplexValue, animateValue, animateView, animationMapKey, applyPxDefaults, calcGeneratorDuration, cancelFrame, cancelMicrotask, cancelSync, collectMotionValues, color, complex, convertOffsetToTimes, createGeneratorEasing, createRenderBatcher, cubicBezierAsString, defaultEasing, defaultOffset, defaultValueTypes, degrees, dimensionValueTypes, fillOffset, fillWildcards, findDimensionValueType, findValueType, flushKeyframeResolvers, frame, frameData, frameSteps, generateLinearEasing, getAnimatableNone, getAnimationMap, getComputedStyle, getDefaultValueType, getMixer, getValueAsType, getValueTransition, getVariableValue, hex, hover, hsla, hslaToRgba, inertia, interpolate, invisibleValues, isCSSVariableName, isCSSVariableToken, isDragActive, isDragging, isGenerator, isNodeOrChild, isPrimaryPointer, isWaapiSupportedEasing, keyframes, mapEasingToNativeEasing, mapValue, maxGeneratorDuration, microtask, mix, mixArray, mixColor, mixComplex, mixImmediate, mixLinearColor, mixNumber, mixObject, mixVisibility, motionValue, number, numberValueTypes, observeTimeline, parseCSSVariable, parseValueFromTransform, percent, positionalKeys, press, progressPercentage, px, readTransformValue, recordStats, resolveElements, rgbUnit, rgba, scale, setDragLock, setStyle, spring, startWaapiAnimation, statsBuffer, styleEffect, supportedWaapiEasing, supportsBrowserAnimation, supportsFlags, supportsLinearEasing, supportsPartialKeyframes, supportsScrollTimeline, sync, testValueType, time, transform, transformPropOrder, transformProps, transformValue, transformValueTypes, vh, vw };\n"
        }
    ]
}