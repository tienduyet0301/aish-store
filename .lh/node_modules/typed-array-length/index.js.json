{
    "sourceFile": "node_modules/typed-array-length/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893070748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\n// / <reference types=\"node\" />\n\nvar callBind = require('call-bind');\nvar forEach = require('for-each');\nvar gOPD = require('gopd');\nvar isTypedArray = require('is-typed-array');\nvar typedArrays = require('possible-typed-array-names');\nvar gPO = require('reflect.getprototypeof/polyfill')();\n\n/** @typedef {(value: import('.').TypedArray) => number} TypedArrayLengthGetter */\n/** @typedef {{ [k in `$${import('.').TypedArrayName}` | '__proto__']: k extends '__proto__' ? null : TypedArrayLengthGetter }} Cache */\n\n/** @type {Cache} */\n// @ts-expect-error TS doesn't seem to have a \"will eventually satisfy\" type\nvar getters = { __proto__: null };\nvar oDP = Object.defineProperty;\nif (gOPD) {\n\tvar getLength = /** @type {TypedArrayLengthGetter} */ function (x) {\n\t\treturn x.length;\n\t};\n\tforEach(typedArrays, /** @type {(typedArray: import('.').TypedArrayName) => void} */ function (typedArray) {\n\t\tvar TA = global[typedArray];\n\t\t// In Safari 7, Typed Array constructors are typeof object\n\t\tif (typeof TA === 'function' || typeof TA === 'object') {\n\t\t\tvar Proto = TA.prototype;\n\t\t\t// @ts-expect-error TS doesn't narrow types inside callbacks, which is weird\n\t\t\tvar descriptor = gOPD(Proto, 'length');\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = gPO(Proto);\n\t\t\t\t// @ts-expect-error TS doesn't narrow types inside callbacks, which is weird\n\t\t\t\tdescriptor = gOPD(superProto, 'length');\n\t\t\t}\n\t\t\t// Opera 12.16 has a magic length data property on instances AND on Proto\n\t\t\tif (descriptor && descriptor.get) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tgetters[/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)] = callBind(descriptor.get);\n\t\t\t} else if (oDP) {\n\t\t\t\t// this is likely an engine where instances have a magic length data property\n\t\t\t\tvar arr = new global[typedArray](2);\n\t\t\t\t// @ts-expect-error TS doesn't narrow types inside callbacks, which is weird\n\t\t\t\tdescriptor = gOPD(arr, 'length');\n\t\t\t\tif (descriptor && descriptor.configurable) {\n\t\t\t\t\toDP(arr, 'length', { value: 3 });\n\t\t\t\t}\n\t\t\t\tif (arr.length === 2) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\tgetters[/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)] = getLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\n/** @type {TypedArrayLengthGetter} */\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\t/** @type {number} */ var foundLength;\n\t// @ts-expect-error not sure why this won't work\n\tforEach(getters, /** @type {(getter: TypedArrayLengthGetter) => void} */ function (getter) {\n\t\tif (typeof foundLength !== 'number') {\n\t\t\ttry {\n\t\t\t\tvar length = getter(value);\n\t\t\t\tif (typeof length === 'number') {\n\t\t\t\t\tfoundLength = length;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\t// @ts-expect-error TS can't guarantee the above callback is invoked sync\n\treturn foundLength;\n};\n\n/** @type {import('.')} */\nmodule.exports = function typedArrayLength(value) {\n\tif (!isTypedArray(value)) {\n\t\treturn false;\n\t}\n\treturn tryTypedArrays(value);\n};\n"
        }
    ]
}