{
    "sourceFile": "node_modules/@react-aria/focus/dist/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891905694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { ShadowTreeWalker } from \"@react-aria/utils\";\nimport { FocusableElement, RefObject, DOMAttributes } from \"@react-types/shared\";\nimport { ReactNode, ReactElement } from \"react\";\nexport interface FocusScopeProps {\n    /** The contents of the focus scope. */\n    children: ReactNode;\n    /**\n     * Whether to contain focus inside the scope, so users cannot\n     * move focus outside, for example in a modal dialog.\n     */\n    contain?: boolean;\n    /**\n     * Whether to restore focus back to the element that was focused\n     * when the focus scope mounted, after the focus scope unmounts.\n     */\n    restoreFocus?: boolean;\n    /** Whether to auto focus the first focusable element in the focus scope on mount. */\n    autoFocus?: boolean;\n}\nexport interface FocusManagerOptions {\n    /** The element to start searching from. The currently focused element by default. */\n    from?: Element;\n    /** Whether to only include tabbable elements, or all focusable elements. */\n    tabbable?: boolean;\n    /** Whether focus should wrap around when it reaches the end of the scope. */\n    wrap?: boolean;\n    /** A callback that determines whether the given element is focused. */\n    accept?: (node: Element) => boolean;\n}\nexport interface FocusManager {\n    /** Moves focus to the next focusable or tabbable element in the focus scope. */\n    focusNext(opts?: FocusManagerOptions): FocusableElement | null;\n    /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n    focusPrevious(opts?: FocusManagerOptions): FocusableElement | null;\n    /** Moves focus to the first focusable or tabbable element in the focus scope. */\n    focusFirst(opts?: FocusManagerOptions): FocusableElement | null;\n    /** Moves focus to the last focusable or tabbable element in the focus scope. */\n    focusLast(opts?: FocusManagerOptions): FocusableElement | null;\n}\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps): ReactNode;\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined;\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element): boolean;\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]): ShadowTreeWalker | TreeWalker;\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element | null>, defaultOptions?: FocusManagerOptions): FocusManager;\nexport interface AriaFocusRingProps {\n    /**\n     * Whether to show the focus ring when something\n     * inside the container element has focus (true), or\n     * only if the container itself has focus (false).\n     * @default 'false'\n     */\n    within?: boolean;\n    /** Whether the element is a text input. */\n    isTextInput?: boolean;\n    /** Whether the element will be auto focused. */\n    autoFocus?: boolean;\n}\nexport interface FocusRingAria {\n    /** Whether the element is currently focused. */\n    isFocused: boolean;\n    /** Whether keyboard focus should be visible. */\n    isFocusVisible: boolean;\n    /** Props to apply to the container element with the focus ring. */\n    focusProps: DOMAttributes;\n}\n/**\n * Determines whether a focus ring should be shown to indicate keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard,\n * not with a mouse, touch, or other input methods.\n */\nexport function useFocusRing(props?: AriaFocusRingProps): FocusRingAria;\nexport interface FocusRingProps {\n    /** Child element to apply CSS classes to. */\n    children: ReactElement;\n    /** CSS class to apply when the element is focused. */\n    focusClass?: string;\n    /** CSS class to apply when the element has keyboard focus. */\n    focusRingClass?: string;\n    /**\n     * Whether to show the focus ring when something\n     * inside the container element has focus (true), or\n     * only if the container itself has focus (false).\n     * @default false\n     */\n    within?: boolean;\n    /** Whether the element is a text input. */\n    isTextInput?: boolean;\n    /** Whether the element will be auto focused. */\n    autoFocus?: boolean;\n}\n/**\n * A utility component that applies a CSS class when an element has keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard,\n * not with a mouse, touch, or other input methods.\n */\nexport function FocusRing(props: FocusRingProps): ReactNode;\ninterface AriaHasTabbableChildOptions {\n    isDisabled?: boolean;\n}\n/**\n * Returns whether an element has a tabbable child, and updates as children change.\n * @private\n */\nexport function useHasTabbableChild(ref: RefObject<Element | null>, options?: AriaHasTabbableChildOptions): boolean;\nexport function moveVirtualFocus(to: Element | null): void;\nexport function dispatchVirtualBlur(from: Element, to: Element | null): void;\nexport function dispatchVirtualFocus(to: Element, from: Element | null): void;\nexport function getVirtuallyFocusedElement(document: Document): Element | null;\nexport { isFocusable } from '@react-aria/utils';\nexport { FocusableProvider, Focusable, useFocusable, focusSafely } from '@react-aria/interactions';\nexport type { FocusableAria, FocusableOptions, FocusableProviderProps } from '@react-aria/interactions';\n\n//# sourceMappingURL=types.d.ts.map\n"
        }
    ]
}