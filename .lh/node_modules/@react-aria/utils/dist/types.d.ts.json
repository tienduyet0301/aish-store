{
    "sourceFile": "node_modules/@react-aria/utils/dist/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891914591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import React, { ForwardedRef, MutableRefObject, DOMAttributes, ReactNode, HTMLAttributes, EffectCallback, Dispatch, RefObject as _RefObject1 } from \"react\";\nimport { AriaLabelingProps, DOMProps, LinkDOMProps, FocusableElement, Orientation, Href, RouterOptions, RefObject } from \"@react-types/shared\";\nexport const useLayoutEffect: typeof React.useLayoutEffect;\n/**\n * If a default is not provided, generate an id.\n * @param defaultId - Default component id.\n */\nexport function useId(defaultId?: string): string;\n/**\n * Merges two ids.\n * Different ids will trigger a side-effect and re-render components hooked up with `useId`.\n */\nexport function mergeIds(idA: string, idB: string): string;\n/**\n * Used to generate an id, and after render, check if that id is rendered so we know\n * if we can use it in places such as labelledby.\n * @param depArray - When to recalculate if the id is in the DOM.\n */\nexport function useSlotId(depArray?: ReadonlyArray<any>): string;\n/**\n * Calls all functions in the order they were chained with the same arguments.\n */\nexport function chain(...callbacks: any[]): (...args: any[]) => void;\nexport const getOwnerDocument: (el: Element | null | undefined) => Document;\nexport const getOwnerWindow: (el: (Window & typeof global) | Element | null | undefined) => Window & typeof global;\n/**\n * Type guard that checks if a node is a ShadowRoot. Uses nodeType and host property checks to\n * distinguish ShadowRoot from other DocumentFragments.\n */\nexport function isShadowRoot(node: Node | null): node is ShadowRoot;\n/**\n * ShadowDOM safe version of Node.contains.\n */\nexport function nodeContains(node: Node | null | undefined, otherNode: Node | null | undefined): boolean;\n/**\n * ShadowDOM safe version of document.activeElement.\n */\nexport const getActiveElement: (doc?: Document) => Element | null;\n/**\n * ShadowDOM safe version of event.target.\n */\nexport function getEventTarget<T extends Event>(event: T): Element;\nexport class ShadowTreeWalker implements TreeWalker {\n    readonly filter: NodeFilter | null;\n    readonly root: Node;\n    readonly whatToShow: number;\n    constructor(doc: Document, root: Node, whatToShow?: number, filter?: NodeFilter | null);\n    get currentNode(): Node;\n    set currentNode(node: Node);\n    get doc(): Document;\n    firstChild(): Node | null;\n    lastChild(): Node | null;\n    nextNode(): Node | null;\n    previousNode(): Node | null;\n    /**\n     * @deprecated\n     */\n    nextSibling(): Node | null;\n    /**\n     * @deprecated\n     */\n    previousSibling(): Node | null;\n    /**\n     * @deprecated\n     */\n    parentNode(): Node | null;\n}\n/**\n * ShadowDOM safe version of document.createTreeWalker.\n */\nexport function createShadowTreeWalker(doc: Document, root: Node, whatToShow?: number, filter?: NodeFilter | null): TreeWalker;\ninterface Props {\n    [key: string]: any;\n}\ntype PropsArg = Props | null | undefined;\ntype TupleTypes<T> = {\n    [P in keyof T]: T[P];\n} extends {\n    [key: number]: infer V;\n} ? NullToObject<V> : never;\ntype NullToObject<T> = T extends (null | undefined) ? {} : T;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n/**\n * Merges multiple props objects together. Event handlers are chained,\n * classNames are combined, and ids are deduplicated - different ids\n * will trigger a side-effect and re-render components hooked up with `useId`.\n * For all other props, the last prop object overrides all previous ones.\n * @param args - Multiple sets of props to merge together.\n */\nexport function mergeProps<T extends PropsArg[]>(...args: T): UnionToIntersection<TupleTypes<T>>;\n/**\n * Merges multiple refs into one. Works with either callback or object refs.\n */\nexport function mergeRefs<T>(...refs: Array<ForwardedRef<T> | MutableRefObject<T> | null | undefined>): ForwardedRef<T>;\ninterface Options {\n    /**\n     * If labelling associated aria properties should be included in the filter.\n     */\n    labelable?: boolean;\n    /** Whether the element is a link and should include DOM props for <a> elements. */\n    isLink?: boolean;\n    /**\n     * A Set of other property names that should be included in the filter.\n     */\n    propNames?: Set<string>;\n}\n/**\n * Filters out all props that aren't valid DOM props or defined via override prop obj.\n * @param props - The component props to be filtered.\n * @param opts - Props to override.\n */\nexport function filterDOMProps(props: DOMProps & AriaLabelingProps & LinkDOMProps, opts?: Options): DOMProps & AriaLabelingProps;\nexport function focusWithoutScrolling(element: FocusableElement): void;\nexport function getOffset(element: HTMLElement, reverse?: boolean, orientation?: Orientation): number;\nexport const isMac: () => boolean;\nexport const isIPhone: () => boolean;\nexport const isIPad: () => boolean;\nexport const isIOS: () => boolean;\nexport const isAppleDevice: () => boolean;\nexport const isWebKit: () => boolean;\nexport const isChrome: () => boolean;\nexport const isAndroid: () => boolean;\nexport const isFirefox: () => boolean;\ninterface Router {\n    isNative: boolean;\n    open: (target: Element, modifiers: Modifiers, href: Href, routerOptions: RouterOptions | undefined) => void;\n    useHref: (href: Href) => string;\n}\ninterface RouterProviderProps {\n    navigate: (path: Href, routerOptions: RouterOptions | undefined) => void;\n    useHref?: (href: Href) => string;\n    children: ReactNode;\n}\n/**\n * A RouterProvider accepts a `navigate` function from a framework or client side router,\n * and provides it to all nested React Aria links to enable client side navigation.\n */\nexport function RouterProvider(props: RouterProviderProps): ReactNode;\nexport function useRouter(): Router;\ninterface Modifiers {\n    metaKey?: boolean;\n    ctrlKey?: boolean;\n    altKey?: boolean;\n    shiftKey?: boolean;\n}\nexport function shouldClientNavigate(link: HTMLAnchorElement, modifiers: Modifiers): boolean;\nexport function openLink(target: HTMLAnchorElement, modifiers: Modifiers, setOpening?: boolean): void;\nexport function useSyntheticLinkProps(props: LinkDOMProps): DOMAttributes<HTMLElement>;\n/** @deprecated - For backward compatibility. */\nexport function getSyntheticLinkProps(props: LinkDOMProps): DOMAttributes<HTMLElement>;\nexport function useLinkProps(props?: LinkDOMProps): LinkDOMProps;\nexport function runAfterTransition(fn: () => void): void;\ninterface UseDrag1DProps {\n    containerRef: MutableRefObject<HTMLElement>;\n    reverse?: boolean;\n    orientation?: Orientation;\n    onHover?: (hovered: boolean) => void;\n    onDrag?: (dragging: boolean) => void;\n    onPositionChange?: (position: number) => void;\n    onIncrement?: () => void;\n    onDecrement?: () => void;\n    onIncrementToMax?: () => void;\n    onDecrementToMin?: () => void;\n    onCollapseToggle?: () => void;\n}\nexport function useDrag1D(props: UseDrag1DProps): HTMLAttributes<HTMLElement>;\ninterface GlobalListeners {\n    addGlobalListener<K extends keyof WindowEventMap>(el: Window, type: K, listener: (this: Document, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addGlobalListener<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addGlobalListener(el: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeGlobalListener<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeGlobalListener(el: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n    removeAllGlobalListeners(): void;\n}\nexport function useGlobalListeners(): GlobalListeners;\n/**\n * Merges aria-label and aria-labelledby into aria-labelledby when both exist.\n * @param props - Aria label props.\n * @param defaultLabel - Default value for aria-label when not present.\n */\nexport function useLabels(props: DOMProps & AriaLabelingProps, defaultLabel?: string): DOMProps & AriaLabelingProps;\n/**\n * Offers an object ref for a given callback ref or an object ref. Especially\n * helfpul when passing forwarded refs (created using `React.forwardRef`) to\n * React Aria hooks.\n *\n * @param forwardedRef The original ref intended to be used.\n * @returns An object ref that updates the given ref.\n * @see https://reactjs.org/docs/forwarding-refs.html\n */\nexport function useObjectRef<T>(forwardedRef?: ((instance: T | null) => void) | MutableRefObject<T | null> | null): MutableRefObject<T | null>;\nexport function useUpdateEffect(effect: EffectCallback, dependencies: any[]): void;\nexport function useUpdateLayoutEffect(effect: EffectCallback, dependencies: any[]): void;\ntype useResizeObserverOptionsType<T> = {\n    ref: RefObject<T | undefined | null> | undefined;\n    box?: ResizeObserverBoxOptions;\n    onResize: () => void;\n};\nexport function useResizeObserver<T extends Element>(options: useResizeObserverOptionsType<T>): void;\ninterface ContextValue<T> {\n    ref?: MutableRefObject<T | null>;\n}\nexport function useSyncRef<T>(context?: ContextValue<T> | null, ref?: RefObject<T | null>): void;\nexport function isScrollable(node: Element | null, checkForOverflow?: boolean): boolean;\nexport function getScrollParent(node: Element, checkForOverflow?: boolean): Element;\nexport function getScrollParents(node: Element, checkForOverflow?: boolean): Element[];\ninterface ViewportSize {\n    width: number;\n    height: number;\n}\nexport function useViewportSize(): ViewportSize;\nexport function useDescription(description?: string): AriaLabelingProps;\nexport function useEffectEvent<T extends Function>(fn?: T): T;\nexport function useEvent<K extends keyof GlobalEventHandlersEventMap>(ref: RefObject<EventTarget | null>, event: K | (string & {}), handler?: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\ntype SetValueAction<S> = (prev: S) => Generator<any, void, unknown>;\nexport function useValueEffect<S>(defaultValue: S | (() => S)): [S, Dispatch<SetValueAction<S>>];\ninterface ScrollIntoViewportOpts {\n    /** The optional containing element of the target to be centered in the viewport. */\n    containingElement?: Element | null;\n}\n/**\n * Scrolls `scrollView` so that `element` is visible.\n * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),\n * but doesn't affect parents above `scrollView`.\n */\nexport function scrollIntoView(scrollView: HTMLElement, element: HTMLElement): void;\n/**\n * Scrolls the `targetElement` so it is visible in the viewport. Accepts an optional `opts.containingElement`\n * that will be centered in the viewport prior to scrolling the targetElement into view. If scrolling is prevented on\n * the body (e.g. targetElement is in a popover), this will only scroll the scroll parents of the targetElement up to but not including the body itself.\n */\nexport function scrollIntoViewport(targetElement: Element | null, opts?: ScrollIntoViewportOpts): void;\nexport function isVirtualClick(event: MouseEvent | PointerEvent): boolean;\nexport function isVirtualPointerEvent(event: PointerEvent): boolean;\nexport function useDeepMemo<T>(value: T, isEqual: (a: T, b: T) => boolean): T;\nexport function useFormReset<T>(ref: RefObject<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | null> | undefined, initialValue: T, onReset: (value: T) => void): void;\ninterface LoadMoreProps {\n    /** Whether data is currently being loaded. */\n    isLoading?: boolean;\n    /** Handler that is called when more items should be loaded, e.g. while scrolling near the bottom.  */\n    onLoadMore?: () => void;\n    /**\n     * The amount of offset from the bottom of your scrollable region that should trigger load more.\n     * Uses a percentage value relative to the scroll body's client height. Load more is then triggered\n     * when your current scroll position's distance from the bottom of the currently loaded list of items is less than\n     * or equal to the provided value. (e.g. 1 = 100% of the scroll region's height).\n     * @default 1\n     */\n    scrollOffset?: number;\n    /** The data currently loaded. */\n    items?: any;\n}\nexport function useLoadMore(props: LoadMoreProps, ref: _RefObject1<HTMLElement | null>): void;\nexport function inertValue(value?: boolean): string | boolean | undefined;\nexport const CLEAR_FOCUS_EVENT = \"react-aria-clear-focus\";\nexport const FOCUS_EVENT = \"react-aria-focus\";\ninterface Event {\n    altKey: boolean;\n    ctrlKey: boolean;\n    metaKey: boolean;\n}\nexport function isCtrlKeyPressed(e: Event): boolean;\nexport function useEnterAnimation(ref: _RefObject1<HTMLElement | null>, isReady?: boolean): boolean;\nexport function useExitAnimation(ref: _RefObject1<HTMLElement | null>, isOpen: boolean): boolean;\nexport function isFocusable(element: Element): boolean;\nexport function isTabbable(element: Element): boolean;\nexport { clamp, snapValueToStep } from '@react-stately/utils';\n\n//# sourceMappingURL=types.d.ts.map\n"
        }
    ]
}