{
    "sourceFile": "node_modules/@react-aria/interactions/dist/useFocusVisible.main.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891907657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var $625cf83917e112ad$exports = require(\"./utils.main.js\");\nvar $cR3F8$reactariautils = require(\"@react-aria/utils\");\nvar $cR3F8$react = require(\"react\");\nvar $cR3F8$reactariassr = require(\"@react-aria/ssr\");\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n$parcel$export(module.exports, \"addWindowFocusTracking\", () => $e77252a287ef94ab$export$2f1888112f558a7d);\n$parcel$export(module.exports, \"isFocusVisible\", () => $e77252a287ef94ab$export$b9b3dfddab17db27);\n$parcel$export(module.exports, \"getInteractionModality\", () => $e77252a287ef94ab$export$630ff653c5ada6a9);\n$parcel$export(module.exports, \"setInteractionModality\", () => $e77252a287ef94ab$export$8397ddfc504fdb9a);\n$parcel$export(module.exports, \"useInteractionModality\", () => $e77252a287ef94ab$export$98e20ec92f614cfe);\n$parcel$export(module.exports, \"useFocusVisible\", () => $e77252a287ef94ab$export$ffd9e5021c1fb2d6);\n$parcel$export(module.exports, \"useFocusVisibleListener\", () => $e77252a287ef94ab$export$ec71b4b83ac08ec3);\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n\n\n\nlet $e77252a287ef94ab$var$currentModality = null;\nlet $e77252a287ef94ab$var$changeHandlers = new Set();\nlet $e77252a287ef94ab$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.\nlet $e77252a287ef94ab$var$hasEventBeforeFocus = false;\nlet $e77252a287ef94ab$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $e77252a287ef94ab$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $e77252a287ef94ab$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !(0, $cR3F8$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\nfunction $e77252a287ef94ab$var$handleKeyboardEvent(e) {\n    $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n    if ($e77252a287ef94ab$var$isValidKey(e)) {\n        $e77252a287ef94ab$var$currentModality = 'keyboard';\n        $e77252a287ef94ab$var$triggerChangeHandlers('keyboard', e);\n    }\n}\nfunction $e77252a287ef94ab$var$handlePointerEvent(e) {\n    $e77252a287ef94ab$var$currentModality = 'pointer';\n    if (e.type === 'mousedown' || e.type === 'pointerdown') {\n        $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n        $e77252a287ef94ab$var$triggerChangeHandlers('pointer', e);\n    }\n}\nfunction $e77252a287ef94ab$var$handleClickEvent(e) {\n    if ((0, $cR3F8$reactariautils.isVirtualClick)(e)) {\n        $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n        $e77252a287ef94ab$var$currentModality = 'virtual';\n    }\n}\nfunction $e77252a287ef94ab$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document || (0, $625cf83917e112ad$exports.ignoreFocusEvent) || !e.isTrusted) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {\n        $e77252a287ef94ab$var$currentModality = 'virtual';\n        $e77252a287ef94ab$var$triggerChangeHandlers('virtual', e);\n    }\n    $e77252a287ef94ab$var$hasEventBeforeFocus = false;\n    $e77252a287ef94ab$var$hasBlurredWindowRecently = false;\n}\nfunction $e77252a287ef94ab$var$handleWindowBlur() {\n    if (0, $625cf83917e112ad$exports.ignoreFocusEvent) return;\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $e77252a287ef94ab$var$hasEventBeforeFocus = false;\n    $e77252a287ef94ab$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $e77252a287ef94ab$var$setupGlobalFocusEvents(element) {\n    if (typeof window === 'undefined' || $e77252a287ef94ab$export$d90243b58daecda7.get((0, $cR3F8$reactariautils.getOwnerWindow)(element))) return;\n    const windowObject = (0, $cR3F8$reactariautils.getOwnerWindow)(element);\n    const documentObject = (0, $cR3F8$reactariautils.getOwnerDocument)(element);\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = windowObject.HTMLElement.prototype.focus;\n    windowObject.HTMLElement.prototype.focus = function() {\n        $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    documentObject.addEventListener('keydown', $e77252a287ef94ab$var$handleKeyboardEvent, true);\n    documentObject.addEventListener('keyup', $e77252a287ef94ab$var$handleKeyboardEvent, true);\n    documentObject.addEventListener('click', $e77252a287ef94ab$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    windowObject.addEventListener('focus', $e77252a287ef94ab$var$handleFocusEvent, true);\n    windowObject.addEventListener('blur', $e77252a287ef94ab$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== 'undefined') {\n        documentObject.addEventListener('pointerdown', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.addEventListener('pointermove', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.addEventListener('pointerup', $e77252a287ef94ab$var$handlePointerEvent, true);\n    } else if (process.env.NODE_ENV === 'test') {\n        documentObject.addEventListener('mousedown', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.addEventListener('mousemove', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.addEventListener('mouseup', $e77252a287ef94ab$var$handlePointerEvent, true);\n    }\n    // Add unmount handler\n    windowObject.addEventListener('beforeunload', ()=>{\n        $e77252a287ef94ab$var$tearDownWindowFocusTracking(element);\n    }, {\n        once: true\n    });\n    $e77252a287ef94ab$export$d90243b58daecda7.set(windowObject, {\n        focus: focus\n    });\n}\nconst $e77252a287ef94ab$var$tearDownWindowFocusTracking = (element, loadListener)=>{\n    const windowObject = (0, $cR3F8$reactariautils.getOwnerWindow)(element);\n    const documentObject = (0, $cR3F8$reactariautils.getOwnerDocument)(element);\n    if (loadListener) documentObject.removeEventListener('DOMContentLoaded', loadListener);\n    if (!$e77252a287ef94ab$export$d90243b58daecda7.has(windowObject)) return;\n    windowObject.HTMLElement.prototype.focus = $e77252a287ef94ab$export$d90243b58daecda7.get(windowObject).focus;\n    documentObject.removeEventListener('keydown', $e77252a287ef94ab$var$handleKeyboardEvent, true);\n    documentObject.removeEventListener('keyup', $e77252a287ef94ab$var$handleKeyboardEvent, true);\n    documentObject.removeEventListener('click', $e77252a287ef94ab$var$handleClickEvent, true);\n    windowObject.removeEventListener('focus', $e77252a287ef94ab$var$handleFocusEvent, true);\n    windowObject.removeEventListener('blur', $e77252a287ef94ab$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== 'undefined') {\n        documentObject.removeEventListener('pointerdown', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.removeEventListener('pointermove', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.removeEventListener('pointerup', $e77252a287ef94ab$var$handlePointerEvent, true);\n    } else if (process.env.NODE_ENV === 'test') {\n        documentObject.removeEventListener('mousedown', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.removeEventListener('mousemove', $e77252a287ef94ab$var$handlePointerEvent, true);\n        documentObject.removeEventListener('mouseup', $e77252a287ef94ab$var$handlePointerEvent, true);\n    }\n    $e77252a287ef94ab$export$d90243b58daecda7.delete(windowObject);\n};\nfunction $e77252a287ef94ab$export$2f1888112f558a7d(element) {\n    const documentObject = (0, $cR3F8$reactariautils.getOwnerDocument)(element);\n    let loadListener;\n    if (documentObject.readyState !== 'loading') $e77252a287ef94ab$var$setupGlobalFocusEvents(element);\n    else {\n        loadListener = ()=>{\n            $e77252a287ef94ab$var$setupGlobalFocusEvents(element);\n        };\n        documentObject.addEventListener('DOMContentLoaded', loadListener);\n    }\n    return ()=>$e77252a287ef94ab$var$tearDownWindowFocusTracking(element, loadListener);\n}\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== 'undefined') $e77252a287ef94ab$export$2f1888112f558a7d();\nfunction $e77252a287ef94ab$export$b9b3dfddab17db27() {\n    return $e77252a287ef94ab$var$currentModality !== 'pointer';\n}\nfunction $e77252a287ef94ab$export$630ff653c5ada6a9() {\n    return $e77252a287ef94ab$var$currentModality;\n}\nfunction $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {\n    $e77252a287ef94ab$var$currentModality = modality;\n    $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);\n}\nfunction $e77252a287ef94ab$export$98e20ec92f614cfe() {\n    $e77252a287ef94ab$var$setupGlobalFocusEvents();\n    let [modality, setModality] = (0, $cR3F8$react.useState)($e77252a287ef94ab$var$currentModality);\n    (0, $cR3F8$react.useEffect)(()=>{\n        let handler = ()=>{\n            setModality($e77252a287ef94ab$var$currentModality);\n        };\n        $e77252a287ef94ab$var$changeHandlers.add(handler);\n        return ()=>{\n            $e77252a287ef94ab$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return (0, $cR3F8$reactariassr.useIsSSR)() ? null : modality;\n}\nconst $e77252a287ef94ab$var$nonTextInputTypes = new Set([\n    'checkbox',\n    'radio',\n    'range',\n    'color',\n    'file',\n    'image',\n    'button',\n    'submit',\n    'reset'\n]);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    let document1 = (0, $cR3F8$reactariautils.getOwnerDocument)(e === null || e === void 0 ? void 0 : e.target);\n    const IHTMLInputElement = typeof window !== 'undefined' ? (0, $cR3F8$reactariautils.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;\n    const IHTMLTextAreaElement = typeof window !== 'undefined' ? (0, $cR3F8$reactariautils.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;\n    const IHTMLElement = typeof window !== 'undefined' ? (0, $cR3F8$reactariautils.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;\n    const IKeyboardEvent = typeof window !== 'undefined' ? (0, $cR3F8$reactariautils.getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent;\n    // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)\n    // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element\n    isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$e77252a287ef94ab$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;\n    return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $e77252a287ef94ab$export$ffd9e5021c1fb2d6(props = {}) {\n    let { isTextInput: isTextInput, autoFocus: autoFocus } = props;\n    let [isFocusVisibleState, setFocusVisible] = (0, $cR3F8$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27());\n    $e77252a287ef94ab$export$ec71b4b83ac08ec3((isFocusVisible)=>{\n        setFocusVisible(isFocusVisible);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $e77252a287ef94ab$var$setupGlobalFocusEvents();\n    (0, $cR3F8$react.useEffect)(()=>{\n        let handler = (modality, e)=>{\n            // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape\n            if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n            fn($e77252a287ef94ab$export$b9b3dfddab17db27());\n        };\n        $e77252a287ef94ab$var$changeHandlers.add(handler);\n        return ()=>{\n            $e77252a287ef94ab$var$changeHandlers.delete(handler);\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, deps);\n}\n\n\n//# sourceMappingURL=useFocusVisible.main.js.map\n"
        }
    ]
}