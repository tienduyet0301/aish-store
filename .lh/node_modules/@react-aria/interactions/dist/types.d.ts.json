{
    "sourceFile": "node_modules/@react-aria/interactions/dist/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891907316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { DOMAttributes, PressEvents, RefObject, FocusableElement, FocusEvents, KeyboardEvents, FocusableDOMProps, FocusableProps, HoverEvents, MoveEvents, ScrollEvents, LongPressEvent } from \"@react-types/shared\";\nimport React, { MutableRefObject, ReactElement, ReactNode, FocusEvent } from \"react\";\nexport interface PressProps extends PressEvents {\n    /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n    isPressed?: boolean;\n    /** Whether the press events should be disabled. */\n    isDisabled?: boolean;\n    /** Whether the target should not receive focus on press. */\n    preventFocusOnPress?: boolean;\n    /**\n     * Whether press events should be canceled when the pointer leaves the target while pressed.\n     * By default, this is `false`, which means if the pointer returns back over the target while\n     * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n     * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n     */\n    shouldCancelOnPointerExit?: boolean;\n    /** Whether text selection should be enabled on the pressable element. */\n    allowTextSelectionOnPress?: boolean;\n}\nexport interface PressHookProps extends PressProps {\n    /** A ref to the target element. */\n    ref?: RefObject<Element | null>;\n}\nexport interface PressResult {\n    /** Whether the target is currently pressed. */\n    isPressed: boolean;\n    /** Props to spread on the target element. */\n    pressProps: DOMAttributes;\n}\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult;\nexport interface FocusProps<Target = FocusableElement> extends FocusEvents<Target> {\n    /** Whether the focus events should be disabled. */\n    isDisabled?: boolean;\n}\nexport interface FocusResult<Target = FocusableElement> {\n    /** Props to spread onto the target element. */\n    focusProps: DOMAttributes<Target>;\n}\n/**\n * Handles focus events for the immediate target.\n * Focus events on child elements will be ignored.\n */\nexport function useFocus<Target extends FocusableElement = FocusableElement>(props: FocusProps<Target>): FocusResult<Target>;\nexport interface KeyboardProps extends KeyboardEvents {\n    /** Whether the keyboard events should be disabled. */\n    isDisabled?: boolean;\n}\nexport interface KeyboardResult {\n    /** Props to spread onto the target element. */\n    keyboardProps: DOMAttributes;\n}\n/**\n * Handles keyboard interactions for a focusable element.\n */\nexport function useKeyboard(props: KeyboardProps): KeyboardResult;\nexport interface FocusableOptions<T = FocusableElement> extends FocusableProps<T>, FocusableDOMProps {\n    /** Whether focus should be disabled. */\n    isDisabled?: boolean;\n}\nexport interface FocusableProviderProps extends DOMAttributes {\n    /** The child element to provide DOM props to. */\n    children?: ReactNode;\n}\ninterface FocusableContextValue extends FocusableProviderProps {\n    ref?: MutableRefObject<FocusableElement | null>;\n}\n/** @private */\nexport let FocusableContext: React.Context<FocusableContextValue | null>;\n/**\n * Provides DOM props to the nearest focusable child.\n */\nexport const FocusableProvider: React.ForwardRefExoticComponent<FocusableProviderProps & React.RefAttributes<FocusableElement>>;\nexport interface FocusableAria {\n    /** Props for the focusable element. */\n    focusableProps: DOMAttributes;\n}\n/**\n * Used to make an element focusable and capable of auto focus.\n */\nexport function useFocusable<T extends FocusableElement = FocusableElement>(props: FocusableOptions<T>, domRef: RefObject<FocusableElement | null>): FocusableAria;\ninterface FocusableComponentProps extends FocusableOptions {\n    children: ReactElement<DOMAttributes, string>;\n}\nexport const Focusable: React.ForwardRefExoticComponent<FocusableComponentProps & React.RefAttributes<FocusableElement>>;\ninterface PressableProps extends PressProps {\n    children: ReactElement<DOMAttributes, string>;\n}\nexport const Pressable: React.ForwardRefExoticComponent<PressableProps & React.RefAttributes<FocusableElement>>;\ninterface PressResponderProps extends PressProps {\n    children: ReactNode;\n}\nexport const PressResponder: React.ForwardRefExoticComponent<PressResponderProps & React.RefAttributes<FocusableElement>>;\nexport function ClearPressResponder({ children }: {\n    children: ReactNode;\n}): ReactNode;\nexport type Modality = 'keyboard' | 'pointer' | 'virtual';\nexport type FocusVisibleHandler = (isFocusVisible: boolean) => void;\nexport interface FocusVisibleProps {\n    /** Whether the element is a text input. */\n    isTextInput?: boolean;\n    /** Whether the element will be auto focused. */\n    autoFocus?: boolean;\n}\nexport interface FocusVisibleResult {\n    /** Whether keyboard focus is visible globally. */\n    isFocusVisible: boolean;\n}\n/**\n * EXPERIMENTAL\n * Adds a window (i.e. iframe) to the list of windows that are being tracked for focus visible.\n *\n * Sometimes apps render portions of their tree into an iframe. In this case, we cannot accurately track if the focus\n * is visible because we cannot see interactions inside the iframe. If you have this in your application's architecture,\n * then this function will attach event listeners inside the iframe. You should call `addWindowFocusTracking` with an\n * element from inside the window you wish to add. We'll retrieve the relevant elements based on that.\n * Note, you do not need to call this for the default window, as we call it for you.\n *\n * When you are ready to stop listening, but you do not wish to unmount the iframe, you may call the cleanup function\n * returned by `addWindowFocusTracking`. Otherwise, when you unmount the iframe, all listeners and state will be cleaned\n * up automatically for you.\n *\n * @param element @default document.body - The element provided will be used to get the window to add.\n * @returns A function to remove the event listeners and cleanup the state.\n */\nexport function addWindowFocusTracking(element?: HTMLElement | null): () => void;\n/**\n * If true, keyboard focus is visible.\n */\nexport function isFocusVisible(): boolean;\nexport function getInteractionModality(): Modality | null;\nexport function setInteractionModality(modality: Modality): void;\n/**\n * Keeps state of the current modality.\n */\nexport function useInteractionModality(): Modality | null;\n/**\n * Manages focus visible state for the page, and subscribes individual components for updates.\n */\nexport function useFocusVisible(props?: FocusVisibleProps): FocusVisibleResult;\n/**\n * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).\n */\nexport function useFocusVisibleListener(fn: FocusVisibleHandler, deps: ReadonlyArray<any>, opts?: {\n    isTextInput?: boolean;\n}): void;\nexport interface FocusWithinProps {\n    /** Whether the focus within events should be disabled. */\n    isDisabled?: boolean;\n    /** Handler that is called when the target element or a descendant receives focus. */\n    onFocusWithin?: (e: FocusEvent) => void;\n    /** Handler that is called when the target element and all descendants lose focus. */\n    onBlurWithin?: (e: FocusEvent) => void;\n    /** Handler that is called when the the focus within state changes. */\n    onFocusWithinChange?: (isFocusWithin: boolean) => void;\n}\nexport interface FocusWithinResult {\n    /** Props to spread onto the target element. */\n    focusWithinProps: DOMAttributes;\n}\n/**\n * Handles focus events for the target and its descendants.\n */\nexport function useFocusWithin(props: FocusWithinProps): FocusWithinResult;\nexport interface HoverProps extends HoverEvents {\n    /** Whether the hover events should be disabled. */\n    isDisabled?: boolean;\n}\nexport interface HoverResult {\n    /** Props to spread on the target element. */\n    hoverProps: DOMAttributes;\n    isHovered: boolean;\n}\n/**\n * Handles pointer hover interactions for an element. Normalizes behavior\n * across browsers and platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useHover(props: HoverProps): HoverResult;\nexport interface InteractOutsideProps {\n    ref: RefObject<Element | null>;\n    onInteractOutside?: (e: PointerEvent) => void;\n    onInteractOutsideStart?: (e: PointerEvent) => void;\n    /** Whether the interact outside events should be disabled. */\n    isDisabled?: boolean;\n}\n/**\n * Example, used in components like Dialogs and Popovers so they can close\n * when a user clicks outside them.\n */\nexport function useInteractOutside(props: InteractOutsideProps): void;\nexport interface MoveResult {\n    /** Props to spread on the target element. */\n    moveProps: DOMAttributes;\n}\n/**\n * Handles move interactions across mouse, touch, and keyboard, including dragging with\n * the mouse or touch, and using the arrow keys. Normalizes behavior across browsers and\n * platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useMove(props: MoveEvents): MoveResult;\nexport interface ScrollWheelProps extends ScrollEvents {\n    /** Whether the scroll listener should be disabled. */\n    isDisabled?: boolean;\n}\nexport function useScrollWheel(props: ScrollWheelProps, ref: RefObject<HTMLElement | null>): void;\nexport interface LongPressProps {\n    /** Whether long press events should be disabled. */\n    isDisabled?: boolean;\n    /** Handler that is called when a long press interaction starts. */\n    onLongPressStart?: (e: LongPressEvent) => void;\n    /**\n     * Handler that is called when a long press interaction ends, either\n     * over the target or when the pointer leaves the target.\n     */\n    onLongPressEnd?: (e: LongPressEvent) => void;\n    /**\n     * Handler that is called when the threshold time is met while\n     * the press is over the target.\n     */\n    onLongPress?: (e: LongPressEvent) => void;\n    /**\n     * The amount of time in milliseconds to wait before triggering a long press.\n     * @default 500ms\n     */\n    threshold?: number;\n    /**\n     * A description for assistive techology users indicating that a long press\n     * action is available, e.g. \"Long press to open menu\".\n     */\n    accessibilityDescription?: string;\n}\nexport interface LongPressResult {\n    /** Props to spread on the target element. */\n    longPressProps: DOMAttributes;\n}\n/**\n * Handles long press interactions across mouse and touch devices. Supports a customizable time threshold,\n * accessibility description, and normalizes behavior across browsers and devices.\n */\nexport function useLongPress(props: LongPressProps): LongPressResult;\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement): void;\nexport type { PressEvent, PressEvents, MoveStartEvent, MoveMoveEvent, MoveEndEvent, MoveEvents, HoverEvent, HoverEvents, FocusEvents, KeyboardEvents } from '@react-types/shared';\n\n//# sourceMappingURL=types.d.ts.map\n"
        }
    ]
}