{
    "sourceFile": "node_modules/isexe/test/basic.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892353769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var t = require('tap')\nvar fs = require('fs')\nvar path = require('path')\nvar fixture = path.resolve(__dirname, 'fixtures')\nvar meow = fixture + '/meow.cat'\nvar mine = fixture + '/mine.cat'\nvar ours = fixture + '/ours.cat'\nvar fail = fixture + '/fail.false'\nvar noent = fixture + '/enoent.exe'\nvar mkdirp = require('mkdirp')\nvar rimraf = require('rimraf')\n\nvar isWindows = process.platform === 'win32'\nvar hasAccess = typeof fs.access === 'function'\nvar winSkip = isWindows && 'windows'\nvar accessSkip = !hasAccess && 'no fs.access function'\nvar hasPromise = typeof Promise === 'function'\nvar promiseSkip = !hasPromise && 'no global Promise'\n\nfunction reset () {\n  delete require.cache[require.resolve('../')]\n  return require('../')\n}\n\nt.test('setup fixtures', function (t) {\n  rimraf.sync(fixture)\n  mkdirp.sync(fixture)\n  fs.writeFileSync(meow, '#!/usr/bin/env cat\\nmeow\\n')\n  fs.chmodSync(meow, parseInt('0755', 8))\n  fs.writeFileSync(fail, '#!/usr/bin/env false\\n')\n  fs.chmodSync(fail, parseInt('0644', 8))\n  fs.writeFileSync(mine, '#!/usr/bin/env cat\\nmine\\n')\n  fs.chmodSync(mine, parseInt('0744', 8))\n  fs.writeFileSync(ours, '#!/usr/bin/env cat\\nours\\n')\n  fs.chmodSync(ours, parseInt('0754', 8))\n  t.end()\n})\n\nt.test('promise', { skip: promiseSkip }, function (t) {\n  var isexe = reset()\n  t.test('meow async', function (t) {\n    isexe(meow).then(function (is) {\n      t.ok(is)\n      t.end()\n    })\n  })\n  t.test('fail async', function (t) {\n    isexe(fail).then(function (is) {\n      t.notOk(is)\n      t.end()\n    })\n  })\n  t.test('noent async', function (t) {\n    isexe(noent).catch(function (er) {\n      t.ok(er)\n      t.end()\n    })\n  })\n  t.test('noent ignore async', function (t) {\n    isexe(noent, { ignoreErrors: true }).then(function (is) {\n      t.notOk(is)\n      t.end()\n    })\n  })\n  t.end()\n})\n\nt.test('no promise', function (t) {\n  global.Promise = null\n  var isexe = reset()\n  t.throws('try to meow a promise', function () {\n    isexe(meow)\n  })\n  t.end()\n})\n\nt.test('access', { skip: accessSkip || winSkip }, function (t) {\n  runTest(t)\n})\n\nt.test('mode', { skip: winSkip }, function (t) {\n  delete fs.access\n  delete fs.accessSync\n  var isexe = reset()\n  t.ok(isexe.sync(ours, { uid: 0, gid: 0 }))\n  t.ok(isexe.sync(mine, { uid: 0, gid: 0 }))\n  runTest(t)\n})\n\nt.test('windows', function (t) {\n  global.TESTING_WINDOWS = true\n  var pathExt = '.EXE;.CAT;.CMD;.COM'\n  t.test('pathExt option', function (t) {\n    runTest(t, { pathExt: '.EXE;.CAT;.CMD;.COM' })\n  })\n  t.test('pathExt env', function (t) {\n    process.env.PATHEXT = pathExt\n    runTest(t)\n  })\n  t.test('no pathExt', function (t) {\n    // with a pathExt of '', any filename is fine.\n    // so the \"fail\" one would still pass.\n    runTest(t, { pathExt: '', skipFail: true })\n  })\n  t.test('pathext with empty entry', function (t) {\n    // with a pathExt of '', any filename is fine.\n    // so the \"fail\" one would still pass.\n    runTest(t, { pathExt: ';' + pathExt, skipFail: true })\n  })\n  t.end()\n})\n\nt.test('cleanup', function (t) {\n  rimraf.sync(fixture)\n  t.end()\n})\n\nfunction runTest (t, options) {\n  var isexe = reset()\n\n  var optionsIgnore = Object.create(options || {})\n  optionsIgnore.ignoreErrors = true\n\n  if (!options || !options.skipFail) {\n    t.notOk(isexe.sync(fail, options))\n  }\n  t.notOk(isexe.sync(noent, optionsIgnore))\n  if (!options) {\n    t.ok(isexe.sync(meow))\n  } else {\n    t.ok(isexe.sync(meow, options))\n  }\n\n  t.ok(isexe.sync(mine, options))\n  t.ok(isexe.sync(ours, options))\n  t.throws(function () {\n    isexe.sync(noent, options)\n  })\n\n  t.test('meow async', function (t) {\n    if (!options) {\n      isexe(meow, function (er, is) {\n        if (er) {\n          throw er\n        }\n        t.ok(is)\n        t.end()\n      })\n    } else {\n      isexe(meow, options, function (er, is) {\n        if (er) {\n          throw er\n        }\n        t.ok(is)\n        t.end()\n      })\n    }\n  })\n\n  t.test('mine async', function (t) {\n    isexe(mine, options, function (er, is) {\n      if (er) {\n        throw er\n      }\n      t.ok(is)\n      t.end()\n    })\n  })\n\n  t.test('ours async', function (t) {\n    isexe(ours, options, function (er, is) {\n      if (er) {\n        throw er\n      }\n      t.ok(is)\n      t.end()\n    })\n  })\n\n  if (!options || !options.skipFail) {\n    t.test('fail async', function (t) {\n      isexe(fail, options, function (er, is) {\n        if (er) {\n          throw er\n        }\n        t.notOk(is)\n        t.end()\n      })\n    })\n  }\n\n  t.test('noent async', function (t) {\n    isexe(noent, options, function (er, is) {\n      t.ok(er)\n      t.notOk(is)\n      t.end()\n    })\n  })\n\n  t.test('noent ignore async', function (t) {\n    isexe(noent, optionsIgnore, function (er, is) {\n      if (er) {\n        throw er\n      }\n      t.notOk(is)\n      t.end()\n    })\n  })\n\n  t.test('directory is not executable', function (t) {\n    isexe(__dirname, options, function (er, is) {\n      if (er) {\n        throw er\n      }\n      t.notOk(is)\n      t.end()\n    })\n  })\n\n  t.end()\n}\n"
        }
    ]
}