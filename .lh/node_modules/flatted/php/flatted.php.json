{
    "sourceFile": "node_modules/flatted/php/flatted.php",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892296782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "<?php\n\n/*!\n * ISC License\n * \n * Copyright (c) 2018-2021, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\nclass FlattedString {\n  public $value = '';\n  public function __construct($value) {\n    $this->value = $value;\n  }\n}\n\nclass Flatted {\n\n  // public utilities\n  public static function parse($json, $assoc = false, $depth = 512, $options = 0) {\n    $input = array_map(\n      'Flatted::asString',\n      array_map(\n        'Flatted::wrap',\n        json_decode($json, $assoc, $depth, $options)\n      )\n    );\n    $value = &$input[0];\n    $set = array();\n    $set[] = &$value;\n    if (is_array($value))\n      return Flatted::loop(false, array_keys($value), $input, $set, $value);\n    if (is_object($value))\n      return Flatted::loop(true, Flatted::keys($value), $input, $set, $value);\n    return $value;\n  }\n\n  public static function stringify($value, $options = 0, $depth = 512) {\n    $known = new stdClass;\n    $known->key = array();\n    $known->value = array();\n    $input = array();\n    $output = array();\n    $i = intval(Flatted::index($known, $input, $value));\n    while ($i < count($input)) {\n      $output[$i] = Flatted::transform($known, $input, $input[$i]);\n      $i++;\n    }\n    return json_encode($output, $options, $depth);\n  }\n\n  // private helpers\n  private static function asString($value) {\n    return $value instanceof FlattedString ? $value->value : $value;\n  }\n\n  private static function index(&$known, &$input, &$value) {\n    $input[] = &$value;\n    $index = strval(count($input) - 1);\n    $known->key[] = &$value;\n    $known->value[] = &$index;\n    return $index;\n  }\n\n  private static function keys(&$value) {\n    $obj = new ReflectionObject($value);\n    $props = $obj->getProperties();\n    $keys = array();\n    foreach ($props as $prop)\n      $keys[] = $prop->getName();\n    return $keys;\n  }\n\n  private static function loop($obj, $keys, &$input, &$set, &$output) {\n    foreach ($keys as $key) {\n      $value = $obj ? $output->$key : $output[$key];\n      if ($value instanceof FlattedString)\n        Flatted::ref($obj, $key, $input[$value->value], $input, $set, $output);\n    }\n    return $output;\n  }\n\n  private static function relate(&$known, &$input, &$value) {\n    if (is_string($value) || is_array($value) || is_object($value)) {\n      $key = array_search($value, $known->key, true);\n      if ($key !== false)\n        return $known->value[$key];\n      return Flatted::index($known, $input, $value);\n    }\n    return $value;\n  }\n\n  private static function ref($obj, &$key, &$value, &$input, &$set, &$output) {\n    if (is_array($value) && !in_array($value, $set, true)) {\n      $set[] = $value;\n      $value = Flatted::loop(false, array_keys($value), $input, $set, $value);\n    }\n    elseif (is_object($value) && !in_array($value, $set, true)) {\n      $set[] = $value;\n      $value = Flatted::loop(true, Flatted::keys($value), $input, $set, $value);\n    }\n    if ($obj) {\n      $output->$key = &$value;\n    }\n    else {\n      $output[$key] = &$value;\n    }\n  }\n\n  private static function transform(&$known, &$input, &$value) {\n    if (is_array($value)) {\n      return array_map(\n        function ($value) use(&$known, &$input) {\n          return Flatted::relate($known, $input, $value);\n        },\n        $value\n      );\n    }\n    if (is_object($value)) {\n      $object = new stdClass;\n      $keys = Flatted::keys($value);\n      foreach ($keys as $key)\n        $object->$key = Flatted::relate($known, $input, $value->$key);\n      return $object;\n    }\n    return $value;\n  }\n\n  private static function wrap($value) {\n    if (is_string($value)) {\n      return new FlattedString($value);\n    }\n    if (is_array($value)) {\n      return array_map('Flatted::wrap', $value);\n    }\n    if (is_object($value)) {\n      $keys = Flatted::keys($value);\n      foreach ($keys as $key) {\n        $value->$key = self::wrap($value->$key);\n      }\n    }\n    return $value;\n  }\n}\n?>"
        }
    ]
}