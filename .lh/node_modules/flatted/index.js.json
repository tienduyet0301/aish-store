{
    "sourceFile": "node_modules/flatted/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892296247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "self.Flatted = (function (exports) {\n  'use strict';\n\n  function _typeof(o) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n      return typeof o;\n    } : function (o) {\n      return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n  }\n\n  /// <reference types=\"../types/index.d.ts\" />\n\n  // (c) 2020-present Andrea Giammarchi\n\n  var $parse = JSON.parse,\n    $stringify = JSON.stringify;\n  var keys = Object.keys;\n  var Primitive = String; // it could be Number\n  var primitive = 'string'; // it could be 'number'\n\n  var ignore = {};\n  var object = 'object';\n  var noop = function noop(_, value) {\n    return value;\n  };\n  var primitives = function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  };\n  var Primitives = function Primitives(_, value) {\n    return _typeof(value) === primitive ? new Primitive(value) : value;\n  };\n  var _revive = function revive(input, parsed, output, $) {\n    var lazy = [];\n    for (var ke = keys(output), length = ke.length, y = 0; y < length; y++) {\n      var k = ke[y];\n      var value = output[k];\n      if (value instanceof Primitive) {\n        var tmp = input[value];\n        if (_typeof(tmp) === object && !parsed.has(tmp)) {\n          parsed.add(tmp);\n          output[k] = ignore;\n          lazy.push({\n            k: k,\n            a: [input, parsed, tmp, $]\n          });\n        } else output[k] = $.call(output, k, tmp);\n      } else if (output[k] !== ignore) output[k] = $.call(output, k, value);\n    }\n    for (var _length = lazy.length, i = 0; i < _length; i++) {\n      var _lazy$i = lazy[i],\n        _k = _lazy$i.k,\n        a = _lazy$i.a;\n      output[_k] = $.call(output, _k, _revive.apply(null, a));\n    }\n    return output;\n  };\n  var set = function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  };\n\n  /**\n   * Converts a specialized flatted string into a JS value.\n   * @param {string} text\n   * @param {(this: any, key: string, value: any) => any} [reviver]\n   * @returns {any}\n   */\n  var parse = function parse(text, reviver) {\n    var input = $parse(text, Primitives).map(primitives);\n    var value = input[0];\n    var $ = reviver || noop;\n    var tmp = _typeof(value) === object && value ? _revive(input, new Set(), value, $) : value;\n    return $.call({\n      '': tmp\n    }, '', tmp);\n  };\n\n  /**\n   * Converts a JS value into a specialized flatted string.\n   * @param {any} value\n   * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\n   * @param {string | number | undefined} [space]\n   * @returns {string}\n   */\n  var stringify = function stringify(value, replacer, space) {\n    var $ = replacer && _typeof(replacer) === object ? function (k, v) {\n      return k === '' || -1 < replacer.indexOf(k) ? v : void 0;\n    } : replacer || noop;\n    var known = new Map();\n    var input = [];\n    var output = [];\n    var i = +set(known, input, $.call({\n      '': value\n    }, '', value));\n    var firstRun = !i;\n    while (i < input.length) {\n      firstRun = true;\n      output[i] = $stringify(input[i++], replace, space);\n    }\n    return '[' + output.join(',') + ']';\n    function replace(key, value) {\n      if (firstRun) {\n        firstRun = !firstRun;\n        return value;\n      }\n      var after = $.call(this, key, value);\n      switch (_typeof(after)) {\n        case object:\n          if (after === null) return after;\n        case primitive:\n          return known.get(after) || set(known, input, after);\n      }\n      return after;\n    }\n  };\n\n  /**\n   * Converts a generic value into a JSON serializable object without losing recursion.\n   * @param {any} value\n   * @returns {any}\n   */\n  var toJSON = function toJSON(value) {\n    return $parse(stringify(value));\n  };\n\n  /**\n   * Converts a previously serialized object with recursion into a recursive one.\n   * @param {any} value\n   * @returns {any}\n   */\n  var fromJSON = function fromJSON(value) {\n    return parse($stringify(value));\n  };\n\n  exports.fromJSON = fromJSON;\n  exports.parse = parse;\n  exports.stringify = stringify;\n  exports.toJSON = toJSON;\n\n  return exports;\n\n})({});\n"
        }
    ]
}