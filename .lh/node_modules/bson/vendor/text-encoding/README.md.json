{
    "sourceFile": "node_modules/bson/vendor/text-encoding/README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892064509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "text-encoding\n==============\n\nThis is a polyfill for the [Encoding Living\nStandard](https://encoding.spec.whatwg.org/) API for the Web, allowing\nencoding and decoding of textual data to and from Typed Array buffers\nfor binary data in JavaScript.\n\nBy default it adheres to the spec and does not support *encoding* to\nlegacy encodings, only *decoding*. It is also implemented to match the\nspecification's algorithms, rather than for performance. The intended\nuse is within Web pages, so it has no dependency on server frameworks\nor particular module schemes.\n\nBasic examples and tests are included.\n\n### Install ###\n\nThere are a few ways you can get and use the `text-encoding` library.\n\n### HTML Page Usage ###\n\nClone the repo and include the files directly:\n\n```html\n  <!-- Required for non-UTF encodings -->\n  <script src=\"encoding-indexes.js\"></script>\n  <script src=\"encoding.js\"></script>\n```\n\nThis is the only use case the developer cares about. If you want those\nfancy module and/or package manager things that are popular these days\nyou should probably use a different library.\n\n#### Package Managers ####\n\nThe package is published to **npm** and **bower** as `text-encoding`.\nUse through these is not really supported, since they aren't used by\nthe developer of the library. Using `require()` in interesting ways\nprobably breaks. Patches welcome, as long as they don't break the\nbasic use of the files via `<script>`.\n\n### API Overview ###\n\nBasic Usage\n\n```js\n  var uint8array = new TextEncoder().encode(string);\n  var string = new TextDecoder(encoding).decode(uint8array);\n```\n\nStreaming Decode\n\n```js\n  var string = \"\", decoder = new TextDecoder(encoding), buffer;\n  while (buffer = next_chunk()) {\n    string += decoder.decode(buffer, {stream:true});\n  }\n  string += decoder.decode(); // finish the stream\n```\n\n### Encodings ###\n\nAll encodings from the Encoding specification are supported:\n\nutf-8 ibm866 iso-8859-2 iso-8859-3 iso-8859-4 iso-8859-5 iso-8859-6\niso-8859-7 iso-8859-8 iso-8859-8-i iso-8859-10 iso-8859-13 iso-8859-14\niso-8859-15 iso-8859-16 koi8-r koi8-u macintosh windows-874\nwindows-1250 windows-1251 windows-1252 windows-1253 windows-1254\nwindows-1255 windows-1256 windows-1257 windows-1258 x-mac-cyrillic\ngb18030 hz-gb-2312 big5 euc-jp iso-2022-jp shift_jis euc-kr\nreplacement utf-16be utf-16le x-user-defined\n\n(Some encodings may be supported under other names, e.g. ascii,\niso-8859-1, etc. See [Encoding](https://encoding.spec.whatwg.org/) for\nadditional labels for each encoding.)\n\nEncodings other than **utf-8**, **utf-16le** and **utf-16be** require\nan additional `encoding-indexes.js` file to be included. It is rather\nlarge (596kB uncompressed, 188kB gzipped); portions may be deleted if\nsupport for some encodings is not required.\n\n### Non-Standard Behavior ###\n\nAs required by the specification, only encoding to **utf-8** is\nsupported. If you want to try it out, you can force a non-standard\nbehavior by passing the `NONSTANDARD_allowLegacyEncoding` option to\nTextEncoder and a label. For example:\n\n```js\nvar uint8array = new TextEncoder(\n  'windows-1252', { NONSTANDARD_allowLegacyEncoding: true }).encode(text);\n```\n\nBut note that the above won't work if you're using the polyfill in a\nbrowser that natively supports the TextEncoder API natively, since the\npolyfill won't be used!\n\nYou can force the polyfill to be used by using this before the polyfill:\n\n```html\n<script>\nwindow.TextEncoder = window.TextDecoder = null;\n</script>\n```\n\nTo support the legacy encodings (which may be stateful), the\nTextEncoder `encode()` method accepts an optional dictionary and\n`stream` option, e.g. `encoder.encode(string, {stream: true});` This\nis not needed for standard encoding since the input is always in\ncomplete code points.\n"
        }
    ]
}