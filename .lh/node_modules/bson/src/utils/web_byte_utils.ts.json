{
    "sourceFile": "node_modules/bson/src/utils/web_byte_utils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892064083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { BSONError } from '../error';\nimport { tryReadBasicLatin } from './latin';\nimport { parseUtf8 } from '../parse_utf8';\n\ntype TextDecoder = {\n  readonly encoding: string;\n  readonly fatal: boolean;\n  readonly ignoreBOM: boolean;\n  decode(input?: Uint8Array): string;\n};\ntype TextDecoderConstructor = {\n  new (label: 'utf8', options: { fatal: boolean; ignoreBOM?: boolean }): TextDecoder;\n};\n\ntype TextEncoder = {\n  readonly encoding: string;\n  encode(input?: string): Uint8Array;\n};\ntype TextEncoderConstructor = {\n  new (): TextEncoder;\n};\n\n// Web global\ndeclare const TextDecoder: TextDecoderConstructor;\ndeclare const TextEncoder: TextEncoderConstructor;\ndeclare const atob: (base64: string) => string;\ndeclare const btoa: (binary: string) => string;\n\ntype ArrayBufferViewWithTag = ArrayBufferView & {\n  [Symbol.toStringTag]?: string;\n};\n\nfunction isReactNative() {\n  const { navigator } = globalThis as { navigator?: { product?: string } };\n  return typeof navigator === 'object' && navigator.product === 'ReactNative';\n}\n\n/** @internal */\nexport function webMathRandomBytes(byteLength: number) {\n  if (byteLength < 0) {\n    throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n  }\n  return webByteUtils.fromNumberArray(\n    Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256))\n  );\n}\n\n/** @internal */\nconst webRandomBytes: (byteLength: number) => Uint8Array = (() => {\n  const { crypto } = globalThis as {\n    crypto?: { getRandomValues?: (space: Uint8Array) => Uint8Array };\n  };\n  if (crypto != null && typeof crypto.getRandomValues === 'function') {\n    return (byteLength: number) => {\n      // @ts-expect-error: crypto.getRandomValues cannot actually be null here\n      // You cannot separate getRandomValues from crypto (need to have this === crypto)\n      return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n    };\n  } else {\n    if (isReactNative()) {\n      const { console } = globalThis as { console?: { warn?: (message: string) => void } };\n      console?.warn?.(\n        'BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.'\n      );\n    }\n    return webMathRandomBytes;\n  }\n})();\n\nconst HEX_DIGIT = /(\\d|[a-f])/i;\n\n/** @internal */\nexport const webByteUtils = {\n  toLocalBufferType(\n    potentialUint8array: Uint8Array | ArrayBufferViewWithTag | ArrayBuffer\n  ): Uint8Array {\n    const stringTag =\n      potentialUint8array?.[Symbol.toStringTag] ??\n      Object.prototype.toString.call(potentialUint8array);\n\n    if (stringTag === 'Uint8Array') {\n      return potentialUint8array as Uint8Array;\n    }\n\n    if (ArrayBuffer.isView(potentialUint8array)) {\n      return new Uint8Array(\n        potentialUint8array.buffer.slice(\n          potentialUint8array.byteOffset,\n          potentialUint8array.byteOffset + potentialUint8array.byteLength\n        )\n      );\n    }\n\n    if (\n      stringTag === 'ArrayBuffer' ||\n      stringTag === 'SharedArrayBuffer' ||\n      stringTag === '[object ArrayBuffer]' ||\n      stringTag === '[object SharedArrayBuffer]'\n    ) {\n      return new Uint8Array(potentialUint8array);\n    }\n\n    throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);\n  },\n\n  allocate(size: number): Uint8Array {\n    if (typeof size !== 'number') {\n      throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n    }\n    return new Uint8Array(size);\n  },\n\n  allocateUnsafe(size: number): Uint8Array {\n    return webByteUtils.allocate(size);\n  },\n\n  equals(a: Uint8Array, b: Uint8Array): boolean {\n    if (a.byteLength !== b.byteLength) {\n      return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  fromNumberArray(array: number[]): Uint8Array {\n    return Uint8Array.from(array);\n  },\n\n  fromBase64(base64: string): Uint8Array {\n    return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n  },\n\n  toBase64(uint8array: Uint8Array): string {\n    return btoa(webByteUtils.toISO88591(uint8array));\n  },\n\n  /** **Legacy** binary strings are an outdated method of data transfer. Do not add public API support for interpreting this format */\n  fromISO88591(codePoints: string): Uint8Array {\n    return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);\n  },\n\n  /** **Legacy** binary strings are an outdated method of data transfer. Do not add public API support for interpreting this format */\n  toISO88591(uint8array: Uint8Array): string {\n    return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');\n  },\n\n  fromHex(hex: string): Uint8Array {\n    const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n    const buffer = [];\n\n    for (let i = 0; i < evenLengthHex.length; i += 2) {\n      const firstDigit = evenLengthHex[i];\n      const secondDigit = evenLengthHex[i + 1];\n\n      if (!HEX_DIGIT.test(firstDigit)) {\n        break;\n      }\n      if (!HEX_DIGIT.test(secondDigit)) {\n        break;\n      }\n\n      const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n      buffer.push(hexDigit);\n    }\n\n    return Uint8Array.from(buffer);\n  },\n\n  toHex(uint8array: Uint8Array): string {\n    return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');\n  },\n\n  toUTF8(uint8array: Uint8Array, start: number, end: number, fatal: boolean): string {\n    const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;\n    if (basicLatin != null) {\n      return basicLatin;\n    }\n\n    return parseUtf8(uint8array, start, end, fatal);\n  },\n\n  utf8ByteLength(input: string): number {\n    return new TextEncoder().encode(input).byteLength;\n  },\n\n  encodeUTF8Into(uint8array: Uint8Array, source: string, byteOffset: number): number {\n    const bytes = new TextEncoder().encode(source);\n    uint8array.set(bytes, byteOffset);\n    return bytes.byteLength;\n  },\n\n  randomBytes: webRandomBytes,\n\n  swap32(buffer: Uint8Array): Uint8Array {\n    if (buffer.length % 4 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 32-bits');\n    }\n\n    for (let i = 0; i < buffer.length; i += 4) {\n      const byte0 = buffer[i];\n      const byte1 = buffer[i + 1];\n      const byte2 = buffer[i + 2];\n      const byte3 = buffer[i + 3];\n      buffer[i] = byte3;\n      buffer[i + 1] = byte2;\n      buffer[i + 2] = byte1;\n      buffer[i + 3] = byte0;\n    }\n\n    return buffer;\n  }\n};\n"
        }
    ]
}