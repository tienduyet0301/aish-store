{
    "sourceFile": "node_modules/bson/src/utils/latin.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892063931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This function is an optimization for small basic latin strings.\n * @internal\n * @remarks\n * ### Important characteristics:\n * - If the uint8array or distance between start and end is 0 this function returns an empty string\n * - If the byteLength of the string is 1, 2, or 3 we invoke String.fromCharCode and manually offset into the buffer\n * - If the byteLength of the string is less than or equal to 20 an array of bytes is built and `String.fromCharCode.apply` is called with the result\n * - If any byte exceeds 128 this function returns null\n *\n * @param uint8array - A sequence of bytes that may contain basic latin characters\n * @param start - The start index from which to search the uint8array\n * @param end - The index to stop searching the uint8array\n * @returns string if all bytes are within the basic latin range, otherwise null\n */\nexport function tryReadBasicLatin(\n  uint8array: Uint8Array,\n  start: number,\n  end: number\n): string | null {\n  if (uint8array.length === 0) {\n    return '';\n  }\n\n  const stringByteLength = end - start;\n  if (stringByteLength === 0) {\n    return '';\n  }\n\n  if (stringByteLength > 20) {\n    return null;\n  }\n\n  if (stringByteLength === 1 && uint8array[start] < 128) {\n    return String.fromCharCode(uint8array[start]);\n  }\n\n  if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {\n    return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);\n  }\n\n  if (\n    stringByteLength === 3 &&\n    uint8array[start] < 128 &&\n    uint8array[start + 1] < 128 &&\n    uint8array[start + 2] < 128\n  ) {\n    return (\n      String.fromCharCode(uint8array[start]) +\n      String.fromCharCode(uint8array[start + 1]) +\n      String.fromCharCode(uint8array[start + 2])\n    );\n  }\n\n  const latinBytes = [];\n  for (let i = start; i < end; i++) {\n    const byte = uint8array[i];\n    if (byte > 127) {\n      return null;\n    }\n    latinBytes.push(byte);\n  }\n\n  return String.fromCharCode(...latinBytes);\n}\n\n/**\n * This function is an optimization for writing small basic latin strings.\n * @internal\n * @remarks\n * ### Important characteristics:\n * - If the string length is 0 return 0, do not perform any work\n * - If a string is longer than 25 code units return null\n * - If any code unit exceeds 128 this function returns null\n *\n * @param destination - The uint8array to serialize the string to\n * @param source - The string to turn into UTF-8 bytes if it fits in the basic latin range\n * @param offset - The position in the destination to begin writing bytes to\n * @returns the number of bytes written to destination if all code units are below 128, otherwise null\n */\nexport function tryWriteBasicLatin(\n  destination: Uint8Array,\n  source: string,\n  offset: number\n): number | null {\n  if (source.length === 0) return 0;\n\n  if (source.length > 25) return null;\n\n  if (destination.length - offset < source.length) return null;\n\n  for (\n    let charOffset = 0, destinationOffset = offset;\n    charOffset < source.length;\n    charOffset++, destinationOffset++\n  ) {\n    const char = source.charCodeAt(charOffset);\n    if (char > 127) return null;\n\n    destination[destinationOffset] = char;\n  }\n\n  return source.length;\n}\n"
        }
    ]
}