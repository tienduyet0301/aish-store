{
    "sourceFile": "node_modules/bson/src/db_ref.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892062442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { Document } from './bson';\nimport { BSONValue } from './bson_value';\nimport type { EJSONOptions } from './extended_json';\nimport type { ObjectId } from './objectid';\nimport { type InspectFn, defaultInspect } from './parser/utils';\n\n/** @public */\nexport interface DBRefLike {\n  $ref: string;\n  $id: ObjectId;\n  $db?: string;\n}\n\n/** @internal */\nexport function isDBRefLike(value: unknown): value is DBRefLike {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    '$id' in value &&\n    value.$id != null &&\n    '$ref' in value &&\n    typeof value.$ref === 'string' &&\n    // If '$db' is defined it MUST be a string, otherwise it should be absent\n    (!('$db' in value) || ('$db' in value && typeof value.$db === 'string'))\n  );\n}\n\n/**\n * A class representation of the BSON DBRef type.\n * @public\n * @category BSONType\n */\nexport class DBRef extends BSONValue {\n  get _bsontype(): 'DBRef' {\n    return 'DBRef';\n  }\n\n  collection!: string;\n  oid!: ObjectId;\n  db?: string;\n  fields!: Document;\n\n  /**\n   * @param collection - the collection name.\n   * @param oid - the reference ObjectId.\n   * @param db - optional db name, if omitted the reference is local to the current db.\n   */\n  constructor(collection: string, oid: ObjectId, db?: string, fields?: Document) {\n    super();\n    // check if namespace has been provided\n    const parts = collection.split('.');\n    if (parts.length === 2) {\n      db = parts.shift();\n      collection = parts.shift()!;\n    }\n\n    this.collection = collection;\n    this.oid = oid;\n    this.db = db;\n    this.fields = fields || {};\n  }\n\n  // Property provided for compatibility with the 1.x parser\n  // the 1.x parser used a \"namespace\" property, while 4.x uses \"collection\"\n\n  /** @internal */\n  get namespace(): string {\n    return this.collection;\n  }\n\n  set namespace(value: string) {\n    this.collection = value;\n  }\n\n  toJSON(): DBRefLike & Document {\n    const o = Object.assign(\n      {\n        $ref: this.collection,\n        $id: this.oid\n      },\n      this.fields\n    );\n\n    if (this.db != null) o.$db = this.db;\n    return o;\n  }\n\n  /** @internal */\n  toExtendedJSON(options?: EJSONOptions): DBRefLike {\n    options = options || {};\n    let o: DBRefLike = {\n      $ref: this.collection,\n      $id: this.oid\n    };\n\n    if (options.legacy) {\n      return o;\n    }\n\n    if (this.db) o.$db = this.db;\n    o = Object.assign(o, this.fields);\n    return o;\n  }\n\n  /** @internal */\n  static fromExtendedJSON(doc: DBRefLike): DBRef {\n    const copy = Object.assign({}, doc) as Partial<DBRefLike>;\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n  }\n\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {\n    inspect ??= defaultInspect;\n\n    const args = [\n      inspect(this.namespace, options),\n      inspect(this.oid, options),\n      ...(this.db ? [inspect(this.db, options)] : []),\n      ...(Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : [])\n    ];\n\n    args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];\n\n    return `new DBRef(${args.join(', ')})`;\n  }\n}\n"
        }
    ]
}