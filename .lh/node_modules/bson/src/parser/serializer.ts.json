{
    "sourceFile": "node_modules/bson/src/parser/serializer.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892063294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { Binary, validateBinaryVector } from '../binary';\nimport type { BSONSymbol, DBRef, Document, MaxKey } from '../bson';\nimport type { Code } from '../code';\nimport * as constants from '../constants';\nimport type { DBRefLike } from '../db_ref';\nimport type { Decimal128 } from '../decimal128';\nimport type { Double } from '../double';\nimport { BSONError, BSONVersionError } from '../error';\nimport type { Int32 } from '../int_32';\nimport { Long } from '../long';\nimport type { MinKey } from '../min_key';\nimport type { ObjectId } from '../objectid';\nimport type { BSONRegExp } from '../regexp';\nimport { ByteUtils } from '../utils/byte_utils';\nimport { NumberUtils } from '../utils/number_utils';\nimport { isAnyArrayBuffer, isDate, isMap, isRegExp, isUint8Array } from './utils';\n\n/** @public */\nexport interface SerializeOptions {\n  /**\n   * the serializer will check if keys are valid.\n   * @defaultValue `false`\n   */\n  checkKeys?: boolean;\n  /**\n   * serialize the javascript functions\n   * @defaultValue `false`\n   */\n  serializeFunctions?: boolean;\n  /**\n   * serialize will not emit undefined fields\n   * note that the driver sets this to `false`\n   * @defaultValue `true`\n   */\n  ignoreUndefined?: boolean;\n  /** @internal Resize internal buffer */\n  minInternalBufferSize?: number;\n  /**\n   * the index in the buffer where we wish to start serializing into\n   * @defaultValue `0`\n   */\n  index?: number;\n}\n\nconst regexp = /\\x00/; // eslint-disable-line no-control-regex\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\n\n/*\n * isArray indicates if we are writing to a BSON array (type 0x04)\n * which forces the \"key\" which really an array index as a string to be written as ascii\n * This will catch any errors in index as a string generation\n */\n\nfunction serializeString(buffer: Uint8Array, key: string, value: string, index: number) {\n  // Encode String type\n  buffer[index++] = constants.BSON_DATA_STRING;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0;\n  // Write the string\n  const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n  // Write the size of the string to buffer\n  NumberUtils.setInt32LE(buffer, index, size + 1);\n  // Update index\n  index = index + 4 + size;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n}\n\nfunction serializeNumber(buffer: Uint8Array, key: string, value: number, index: number) {\n  const isNegativeZero = Object.is(value, -0);\n\n  const type =\n    !isNegativeZero &&\n    Number.isSafeInteger(value) &&\n    value <= constants.BSON_INT32_MAX &&\n    value >= constants.BSON_INT32_MIN\n      ? constants.BSON_DATA_INT\n      : constants.BSON_DATA_NUMBER;\n\n  buffer[index++] = type;\n\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0x00;\n\n  if (type === constants.BSON_DATA_INT) {\n    index += NumberUtils.setInt32LE(buffer, index, value);\n  } else {\n    index += NumberUtils.setFloat64LE(buffer, index, value);\n  }\n\n  return index;\n}\n\nfunction serializeBigInt(buffer: Uint8Array, key: string, value: bigint, index: number) {\n  buffer[index++] = constants.BSON_DATA_LONG;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index += numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  index += NumberUtils.setBigInt64LE(buffer, index, value);\n\n  return index;\n}\n\nfunction serializeNull(buffer: Uint8Array, key: string, _: unknown, index: number) {\n  // Set long type\n  buffer[index++] = constants.BSON_DATA_NULL;\n\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n}\n\nfunction serializeBoolean(buffer: Uint8Array, key: string, value: boolean, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_BOOLEAN;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Encode the boolean value\n  buffer[index++] = value ? 1 : 0;\n  return index;\n}\n\nfunction serializeDate(buffer: Uint8Array, key: string, value: Date, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_DATE;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write the date\n  const dateInMilis = Long.fromNumber(value.getTime());\n  const lowBits = dateInMilis.getLowBits();\n  const highBits = dateInMilis.getHighBits();\n  // Encode low bits\n  index += NumberUtils.setInt32LE(buffer, index, lowBits);\n  // Encode high bits\n  index += NumberUtils.setInt32LE(buffer, index, highBits);\n  return index;\n}\n\nfunction serializeRegExp(buffer: Uint8Array, key: string, value: RegExp, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_REGEXP;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw new BSONError('value ' + value.source + ' must not contain null bytes');\n  }\n  // Adjust the index\n  index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the parameters\n  if (value.ignoreCase) buffer[index++] = 0x69; // i\n  if (value.global) buffer[index++] = 0x73; // s\n  if (value.multiline) buffer[index++] = 0x6d; // m\n\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n}\n\nfunction serializeBSONRegExp(buffer: Uint8Array, key: string, value: BSONRegExp, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_REGEXP;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Check the pattern for 0 bytes\n  if (value.pattern.match(regexp) != null) {\n    // The BSON spec doesn't allow keys with null bytes because keys are\n    // null-terminated.\n    throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');\n  }\n\n  // Adjust the index\n  index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n  // Write zero\n  buffer[index++] = 0x00;\n  // Write the options\n  const sortedOptions = value.options.split('').sort().join('');\n  index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n  // Add ending zero\n  buffer[index++] = 0x00;\n  return index;\n}\n\nfunction serializeMinMax(buffer: Uint8Array, key: string, value: MinKey | MaxKey, index: number) {\n  // Write the type of either min or max key\n  if (value === null) {\n    buffer[index++] = constants.BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = constants.BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = constants.BSON_DATA_MAX_KEY;\n  }\n\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n}\n\nfunction serializeObjectId(buffer: Uint8Array, key: string, value: ObjectId, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_OID;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  index += value.serializeInto(buffer, index);\n\n  // Adjust index\n  return index;\n}\n\nfunction serializeBuffer(buffer: Uint8Array, key: string, value: Uint8Array, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_BINARY;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Get size of the buffer (current write point)\n  const size = value.length;\n  // Write the size of the string to buffer\n  index += NumberUtils.setInt32LE(buffer, index, size);\n  // Write the default subtype\n  buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;\n  // Copy the content form the binary field to the buffer\n  if (size <= 16) {\n    for (let i = 0; i < size; i++) buffer[index + i] = value[i];\n  } else {\n    buffer.set(value, index);\n  }\n  // Adjust the index\n  index = index + size;\n  return index;\n}\n\nfunction serializeObject(\n  buffer: Uint8Array,\n  key: string,\n  value: Document,\n  index: number,\n  checkKeys: boolean,\n  depth: number,\n  serializeFunctions: boolean,\n  ignoreUndefined: boolean,\n  path: Set<Document>\n) {\n  if (path.has(value)) {\n    throw new BSONError('Cannot convert circular structure to BSON');\n  }\n\n  path.add(value);\n\n  // Write the type\n  buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const endIndex = serializeInto(\n    buffer,\n    value,\n    checkKeys,\n    index,\n    depth + 1,\n    serializeFunctions,\n    ignoreUndefined,\n    path\n  );\n\n  path.delete(value);\n\n  return endIndex;\n}\n\nfunction serializeDecimal128(buffer: Uint8Array, key: string, value: Decimal128, index: number) {\n  buffer[index++] = constants.BSON_DATA_DECIMAL128;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the data from the value\n  for (let i = 0; i < 16; i++) buffer[index + i] = value.bytes[i];\n  return index + 16;\n}\n\nfunction serializeLong(buffer: Uint8Array, key: string, value: Long, index: number) {\n  // Write the type\n  buffer[index++] =\n    value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the date\n  const lowBits = value.getLowBits();\n  const highBits = value.getHighBits();\n  // Encode low bits\n  index += NumberUtils.setInt32LE(buffer, index, lowBits);\n  // Encode high bits\n  index += NumberUtils.setInt32LE(buffer, index, highBits);\n  return index;\n}\n\nfunction serializeInt32(buffer: Uint8Array, key: string, value: Int32 | number, index: number) {\n  value = value.valueOf();\n  // Set int type 32 bits or less\n  buffer[index++] = constants.BSON_DATA_INT;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the int value\n  index += NumberUtils.setInt32LE(buffer, index, value);\n  return index;\n}\n\nfunction serializeDouble(buffer: Uint8Array, key: string, value: Double, index: number) {\n  // Encode as double\n  buffer[index++] = constants.BSON_DATA_NUMBER;\n\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  // Write float\n  index += NumberUtils.setFloat64LE(buffer, index, value.value);\n\n  return index;\n}\n\nfunction serializeFunction(buffer: Uint8Array, key: string, value: Function, index: number) {\n  buffer[index++] = constants.BSON_DATA_CODE;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Function string\n  const functionString = value.toString();\n\n  // Write the string\n  const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n  // Write the size of the string to buffer\n  NumberUtils.setInt32LE(buffer, index, size);\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n}\n\nfunction serializeCode(\n  buffer: Uint8Array,\n  key: string,\n  value: Code,\n  index: number,\n  checkKeys = false,\n  depth = 0,\n  serializeFunctions = false,\n  ignoreUndefined = true,\n  path: Set<Document>\n) {\n  if (value.scope && typeof value.scope === 'object') {\n    // Write the type\n    buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE;\n    // Number of written bytes\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n\n    // Starting index\n    let startIndex = index;\n\n    // Serialize the function\n    // Get the function string\n    const functionString = value.code;\n    // Index adjustment\n    index = index + 4;\n    // Write string into buffer\n    const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    // Write the size of the string to buffer\n    NumberUtils.setInt32LE(buffer, index, codeSize);\n    // Write end 0\n    buffer[index + 4 + codeSize - 1] = 0;\n    // Write the\n    index = index + codeSize + 4;\n\n    // Serialize the scope value\n    const endIndex = serializeInto(\n      buffer,\n      value.scope,\n      checkKeys,\n      index,\n      depth + 1,\n      serializeFunctions,\n      ignoreUndefined,\n      path\n    );\n    index = endIndex - 1;\n\n    // Writ the total\n    const totalSize = endIndex - startIndex;\n\n    // Write the total size of the object\n    startIndex += NumberUtils.setInt32LE(buffer, startIndex, totalSize);\n    // Write trailing zero\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = constants.BSON_DATA_CODE;\n    // Number of written bytes\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    // Encode the name\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    // Function string\n    const functionString = value.code.toString();\n    // Write the string\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    // Write the size of the string to buffer\n    NumberUtils.setInt32LE(buffer, index, size);\n    // Update index\n    index = index + 4 + size - 1;\n    // Write zero\n    buffer[index++] = 0;\n  }\n\n  return index;\n}\n\nfunction serializeBinary(buffer: Uint8Array, key: string, value: Binary, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_BINARY;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Extract the buffer\n  const data = value.buffer;\n  // Calculate size\n  let size = value.position;\n  // Add the deprecated 02 type 4 bytes of size to total\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n  // Write the size of the string to buffer\n  index += NumberUtils.setInt32LE(buffer, index, size);\n  // Write the subtype to the buffer\n  buffer[index++] = value.sub_type;\n\n  // If we have binary type 2 the 4 first bytes are the size\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n  }\n\n  if (value.sub_type === Binary.SUBTYPE_VECTOR) {\n    validateBinaryVector(value);\n  }\n\n  if (size <= 16) {\n    for (let i = 0; i < size; i++) buffer[index + i] = data[i];\n  } else {\n    buffer.set(data, index);\n  }\n  // Adjust the index\n  index = index + value.position;\n  return index;\n}\n\nfunction serializeSymbol(buffer: Uint8Array, key: string, value: BSONSymbol, index: number) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_SYMBOL;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  // Write the string\n  const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n  // Write the size of the string to buffer\n  NumberUtils.setInt32LE(buffer, index, size);\n  // Update index\n  index = index + 4 + size - 1;\n  // Write zero\n  buffer[index++] = 0;\n  return index;\n}\n\nfunction serializeDBRef(\n  buffer: Uint8Array,\n  key: string,\n  value: DBRef,\n  index: number,\n  depth: number,\n  serializeFunctions: boolean,\n  path: Set<Document>\n) {\n  // Write the type\n  buffer[index++] = constants.BSON_DATA_OBJECT;\n  // Number of written bytes\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n\n  // Encode the name\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n\n  let startIndex = index;\n  let output: DBRefLike = {\n    $ref: value.collection || value.namespace, // \"namespace\" was what library 1.x called \"collection\"\n    $id: value.oid\n  };\n\n  if (value.db != null) {\n    output.$db = value.db;\n  }\n\n  output = Object.assign(output, value.fields);\n  const endIndex = serializeInto(\n    buffer,\n    output,\n    false,\n    index,\n    depth + 1,\n    serializeFunctions,\n    true,\n    path\n  );\n\n  // Calculate object size\n  const size = endIndex - startIndex;\n  // Write the size\n  startIndex += NumberUtils.setInt32LE(buffer, index, size);\n  // Set index\n  return endIndex;\n}\n\nexport function serializeInto(\n  buffer: Uint8Array,\n  object: Document,\n  checkKeys: boolean,\n  startingIndex: number,\n  depth: number,\n  serializeFunctions: boolean,\n  ignoreUndefined: boolean,\n  path: Set<Document> | null\n): number {\n  if (path == null) {\n    // We are at the root input\n    if (object == null) {\n      // ONLY the root should turn into an empty document\n      // BSON Empty document has a size of 5 (LE)\n      buffer[0] = 0x05;\n      buffer[1] = 0x00;\n      buffer[2] = 0x00;\n      buffer[3] = 0x00;\n      // All documents end with null terminator\n      buffer[4] = 0x00;\n      return 5;\n    }\n\n    if (Array.isArray(object)) {\n      throw new BSONError('serialize does not support an array as the root input');\n    }\n    if (typeof object !== 'object') {\n      throw new BSONError('serialize does not support non-object as the root input');\n    } else if ('_bsontype' in object && typeof object._bsontype === 'string') {\n      throw new BSONError(`BSON types cannot be serialized as a document`);\n    } else if (\n      isDate(object) ||\n      isRegExp(object) ||\n      isUint8Array(object) ||\n      isAnyArrayBuffer(object)\n    ) {\n      throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n    }\n\n    path = new Set();\n  }\n\n  // Push the object to the path\n  path.add(object);\n\n  // Start place to serialize into\n  let index = startingIndex + 4;\n\n  // Special case isArray\n  if (Array.isArray(object)) {\n    // Get object keys\n    for (let i = 0; i < object.length; i++) {\n      const key = `${i}`;\n      let value = object[i];\n\n      // Is there an override value\n      if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n      }\n\n      // Check the type of the value\n      const type = typeof value;\n\n      if (value === undefined) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        index = serializeBigInt(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype == null) {\n        if (value instanceof Date || isDate(value)) {\n          index = serializeDate(buffer, key, value, index);\n        } else if (value instanceof Uint8Array || isUint8Array(value)) {\n          index = serializeBuffer(buffer, key, value, index);\n        } else if (value instanceof RegExp || isRegExp(value)) {\n          index = serializeRegExp(buffer, key, value, index);\n        } else {\n          index = serializeObject(\n            buffer,\n            key,\n            value,\n            index,\n            checkKeys,\n            depth,\n            serializeFunctions,\n            ignoreUndefined,\n            path\n          );\n        }\n      } else if (type === 'object') {\n        if (value[constants.BSON_VERSION_SYMBOL] !== constants.BSON_MAJOR_VERSION) {\n          throw new BSONVersionError();\n        } else if (value._bsontype === 'ObjectId') {\n          index = serializeObjectId(buffer, key, value, index);\n        } else if (value._bsontype === 'Decimal128') {\n          index = serializeDecimal128(buffer, key, value, index);\n        } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n          index = serializeLong(buffer, key, value, index);\n        } else if (value._bsontype === 'Double') {\n          index = serializeDouble(buffer, key, value, index);\n        } else if (value._bsontype === 'Code') {\n          index = serializeCode(\n            buffer,\n            key,\n            value,\n            index,\n            checkKeys,\n            depth,\n            serializeFunctions,\n            ignoreUndefined,\n            path\n          );\n        } else if (value._bsontype === 'Binary') {\n          index = serializeBinary(buffer, key, value, index);\n        } else if (value._bsontype === 'BSONSymbol') {\n          index = serializeSymbol(buffer, key, value, index);\n        } else if (value._bsontype === 'DBRef') {\n          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n        } else if (value._bsontype === 'BSONRegExp') {\n          index = serializeBSONRegExp(buffer, key, value, index);\n        } else if (value._bsontype === 'Int32') {\n          index = serializeInt32(buffer, key, value, index);\n        } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n          index = serializeMinMax(buffer, key, value, index);\n        } else if (typeof value._bsontype !== 'undefined') {\n          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n        }\n      } else if (type === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index);\n      }\n    }\n  } else if (object instanceof Map || isMap(object)) {\n    const iterator = object.entries();\n    let done = false;\n\n    while (!done) {\n      // Unpack the next entry\n      const entry = iterator.next();\n      done = !!entry.done;\n      // Are we done, then skip and terminate\n      if (done) continue;\n\n      // Get the entry values\n      const key = entry.value ? entry.value[0] : undefined;\n      let value = entry.value ? entry.value[1] : undefined;\n\n      if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n      }\n\n      // Check the type of the value\n      const type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw new BSONError('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw new BSONError('key ' + key + \" must not start with '$'\");\n          } else if (key.includes('.')) {\n            throw new BSONError('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        index = serializeBigInt(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype == null) {\n        if (value instanceof Date || isDate(value)) {\n          index = serializeDate(buffer, key, value, index);\n        } else if (value instanceof Uint8Array || isUint8Array(value)) {\n          index = serializeBuffer(buffer, key, value, index);\n        } else if (value instanceof RegExp || isRegExp(value)) {\n          index = serializeRegExp(buffer, key, value, index);\n        } else {\n          index = serializeObject(\n            buffer,\n            key,\n            value,\n            index,\n            checkKeys,\n            depth,\n            serializeFunctions,\n            ignoreUndefined,\n            path\n          );\n        }\n      } else if (type === 'object') {\n        if (value[constants.BSON_VERSION_SYMBOL] !== constants.BSON_MAJOR_VERSION) {\n          throw new BSONVersionError();\n        } else if (value._bsontype === 'ObjectId') {\n          index = serializeObjectId(buffer, key, value, index);\n        } else if (value._bsontype === 'Decimal128') {\n          index = serializeDecimal128(buffer, key, value, index);\n        } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n          index = serializeLong(buffer, key, value, index);\n        } else if (value._bsontype === 'Double') {\n          index = serializeDouble(buffer, key, value, index);\n        } else if (value._bsontype === 'Code') {\n          index = serializeCode(\n            buffer,\n            key,\n            value,\n            index,\n            checkKeys,\n            depth,\n            serializeFunctions,\n            ignoreUndefined,\n            path\n          );\n        } else if (value._bsontype === 'Binary') {\n          index = serializeBinary(buffer, key, value, index);\n        } else if (value._bsontype === 'BSONSymbol') {\n          index = serializeSymbol(buffer, key, value, index);\n        } else if (value._bsontype === 'DBRef') {\n          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n        } else if (value._bsontype === 'BSONRegExp') {\n          index = serializeBSONRegExp(buffer, key, value, index);\n        } else if (value._bsontype === 'Int32') {\n          index = serializeInt32(buffer, key, value, index);\n        } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n          index = serializeMinMax(buffer, key, value, index);\n        } else if (typeof value._bsontype !== 'undefined') {\n          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n        }\n      } else if (type === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index);\n      }\n    }\n  } else {\n    if (typeof object?.toBSON === 'function') {\n      // Provided a custom serialization method\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object') {\n        throw new BSONError('toBSON function did not return an object');\n      }\n    }\n\n    // Iterate over all the keys\n    for (const key of Object.keys(object)) {\n      let value = object[key];\n      // Is there an override value\n      if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n      }\n\n      // Check the type of the value\n      const type = typeof value;\n\n      // Check the key and throw error if it's illegal\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          // The BSON spec doesn't allow keys with null bytes because keys are\n          // null-terminated.\n          throw new BSONError('key ' + key + ' must not contain null bytes');\n        }\n\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw new BSONError('key ' + key + \" must not start with '$'\");\n          } else if (key.includes('.')) {\n            throw new BSONError('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n\n      if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        index = serializeBigInt(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype == null) {\n        if (value instanceof Date || isDate(value)) {\n          index = serializeDate(buffer, key, value, index);\n        } else if (value instanceof Uint8Array || isUint8Array(value)) {\n          index = serializeBuffer(buffer, key, value, index);\n        } else if (value instanceof RegExp || isRegExp(value)) {\n          index = serializeRegExp(buffer, key, value, index);\n        } else {\n          index = serializeObject(\n            buffer,\n            key,\n            value,\n            index,\n            checkKeys,\n            depth,\n            serializeFunctions,\n            ignoreUndefined,\n            path\n          );\n        }\n      } else if (type === 'object') {\n        if (value[constants.BSON_VERSION_SYMBOL] !== constants.BSON_MAJOR_VERSION) {\n          throw new BSONVersionError();\n        } else if (value._bsontype === 'ObjectId') {\n          index = serializeObjectId(buffer, key, value, index);\n        } else if (value._bsontype === 'Decimal128') {\n          index = serializeDecimal128(buffer, key, value, index);\n        } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n          index = serializeLong(buffer, key, value, index);\n        } else if (value._bsontype === 'Double') {\n          index = serializeDouble(buffer, key, value, index);\n        } else if (value._bsontype === 'Code') {\n          index = serializeCode(\n            buffer,\n            key,\n            value,\n            index,\n            checkKeys,\n            depth,\n            serializeFunctions,\n            ignoreUndefined,\n            path\n          );\n        } else if (value._bsontype === 'Binary') {\n          index = serializeBinary(buffer, key, value, index);\n        } else if (value._bsontype === 'BSONSymbol') {\n          index = serializeSymbol(buffer, key, value, index);\n        } else if (value._bsontype === 'DBRef') {\n          index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n        } else if (value._bsontype === 'BSONRegExp') {\n          index = serializeBSONRegExp(buffer, key, value, index);\n        } else if (value._bsontype === 'Int32') {\n          index = serializeInt32(buffer, key, value, index);\n        } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n          index = serializeMinMax(buffer, key, value, index);\n        } else if (typeof value._bsontype !== 'undefined') {\n          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n        }\n      } else if (type === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index);\n      }\n    }\n  }\n\n  // Remove the path\n  path.delete(object);\n\n  // Final padding byte for object\n  buffer[index++] = 0x00;\n\n  // Final size\n  const size = index - startingIndex;\n  // Write the size of the object\n  startingIndex += NumberUtils.setInt32LE(buffer, startingIndex, size);\n  return index;\n}\n"
        }
    ]
}