{
    "sourceFile": "node_modules/bson/src/parser/deserializer.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892063121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { Binary, UUID } from '../binary';\nimport type { Document } from '../bson';\nimport { Code } from '../code';\nimport * as constants from '../constants';\nimport { DBRef, type DBRefLike, isDBRefLike } from '../db_ref';\nimport { Decimal128 } from '../decimal128';\nimport { Double } from '../double';\nimport { BSONError } from '../error';\nimport { Int32 } from '../int_32';\nimport { Long } from '../long';\nimport { MaxKey } from '../max_key';\nimport { MinKey } from '../min_key';\nimport { ObjectId } from '../objectid';\nimport { BSONRegExp } from '../regexp';\nimport { BSONSymbol } from '../symbol';\nimport { Timestamp } from '../timestamp';\nimport { ByteUtils } from '../utils/byte_utils';\nimport { NumberUtils } from '../utils/number_utils';\n\n/** @public */\nexport interface DeserializeOptions {\n  /**\n   * when deserializing a Long return as a BigInt.\n   * @defaultValue `false`\n   */\n  useBigInt64?: boolean;\n  /**\n   * when deserializing a Long will fit it into a Number if it's smaller than 53 bits.\n   * @defaultValue `true`\n   */\n  promoteLongs?: boolean;\n  /**\n   * when deserializing a Binary will return it as a node.js Buffer instance.\n   * @defaultValue `false`\n   */\n  promoteBuffers?: boolean;\n  /**\n   * when deserializing will promote BSON values to their Node.js closest equivalent types.\n   * @defaultValue `true`\n   */\n  promoteValues?: boolean;\n  /**\n   * allow to specify if there what fields we wish to return as unserialized raw buffer.\n   * @defaultValue `null`\n   */\n  fieldsAsRaw?: Document;\n  /**\n   * return BSON regular expressions as BSONRegExp instances.\n   * @defaultValue `false`\n   */\n  bsonRegExp?: boolean;\n  /**\n   * allows the buffer to be larger than the parsed BSON object.\n   * @defaultValue `false`\n   */\n  allowObjectSmallerThanBufferSize?: boolean;\n  /**\n   * Offset into buffer to begin reading document from\n   * @defaultValue `0`\n   */\n  index?: number;\n\n  raw?: boolean;\n  /** Allows for opt-out utf-8 validation for all keys or\n   * specified keys. Must be all true or all false.\n   *\n   * @example\n   * ```js\n   * // disables validation on all keys\n   *  validation: { utf8: false }\n   *\n   * // enables validation only on specified keys a, b, and c\n   *  validation: { utf8: { a: true, b: true, c: true } }\n   *\n   *  // disables validation only on specified keys a, b\n   *  validation: { utf8: { a: false, b: false } }\n   * ```\n   */\n  validation?: { utf8: boolean | Record<string, true> | Record<string, false> };\n}\n\n// Internal long versions\nconst JS_INT_MAX_LONG = Long.fromNumber(constants.JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(constants.JS_INT_MIN);\n\nexport function internalDeserialize(\n  buffer: Uint8Array,\n  options: DeserializeOptions,\n  isArray?: boolean\n): Document {\n  options = options == null ? {} : options;\n  const index = options && options.index ? options.index : 0;\n  // Read the document size\n  const size = NumberUtils.getInt32LE(buffer, index);\n\n  if (size < 5) {\n    throw new BSONError(`bson size must be >= 5, is ${size}`);\n  }\n\n  if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n    throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n  }\n\n  if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n    throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n  }\n\n  if (size + index > buffer.byteLength) {\n    throw new BSONError(\n      `(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`\n    );\n  }\n\n  // Illegal end value\n  if (buffer[index + size - 1] !== 0) {\n    throw new BSONError(\n      \"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\"\n    );\n  }\n\n  // Start deserialization\n  return deserializeObject(buffer, index, options, isArray);\n}\n\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\n\nfunction deserializeObject(\n  buffer: Uint8Array,\n  index: number,\n  options: DeserializeOptions,\n  isArray = false\n) {\n  const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n\n  // Return raw bson buffer instead of parsing it\n  const raw = options['raw'] == null ? false : options['raw'];\n\n  // Return BSONRegExp objects instead of native regular expressions\n  const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n\n  // Controls the promotion of values vs wrapper classes\n  const promoteBuffers = options.promoteBuffers ?? false;\n  const promoteLongs = options.promoteLongs ?? true;\n  const promoteValues = options.promoteValues ?? true;\n  const useBigInt64 = options.useBigInt64 ?? false;\n\n  if (useBigInt64 && !promoteValues) {\n    throw new BSONError('Must either request bigint or Long for int64 deserialization');\n  }\n\n  if (useBigInt64 && !promoteLongs) {\n    throw new BSONError('Must either request bigint or Long for int64 deserialization');\n  }\n\n  // Ensures default validation option if none given\n  const validation = options.validation == null ? { utf8: true } : options.validation;\n\n  // Shows if global utf-8 validation is enabled or disabled\n  let globalUTFValidation = true;\n  // Reflects utf-8 validation setting regardless of global or specific key validation\n  let validationSetting: boolean;\n  // Set of keys either to enable or disable validation on\n  let utf8KeysSet;\n\n  // Check for boolean uniformity and empty validation option\n  const utf8ValidatedKeys = validation.utf8;\n  if (typeof utf8ValidatedKeys === 'boolean') {\n    validationSetting = utf8ValidatedKeys;\n  } else {\n    globalUTFValidation = false;\n    const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n      return utf8ValidatedKeys[key];\n    });\n    if (utf8ValidationValues.length === 0) {\n      throw new BSONError('UTF-8 validation setting cannot be empty');\n    }\n    if (typeof utf8ValidationValues[0] !== 'boolean') {\n      throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\n    }\n    validationSetting = utf8ValidationValues[0];\n    // Ensures boolean uniformity in utf-8 validation (all true or all false)\n    if (!utf8ValidationValues.every(item => item === validationSetting)) {\n      throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n    }\n  }\n\n  // Add keys to set that will either be validated or not based on validationSetting\n  if (!globalUTFValidation) {\n    utf8KeysSet = new Set();\n\n    for (const key of Object.keys(utf8ValidatedKeys)) {\n      utf8KeysSet.add(key);\n    }\n  }\n\n  // Set the start index\n  const startIndex = index;\n\n  // Validate that we have at least 4 bytes of buffer\n  if (buffer.length < 5) throw new BSONError('corrupt bson message < 5 bytes long');\n\n  // Read the document size\n  const size = NumberUtils.getInt32LE(buffer, index);\n  index += 4;\n\n  // Ensure buffer is valid size\n  if (size < 5 || size > buffer.length) throw new BSONError('corrupt bson message');\n\n  // Create holding object\n  const object: Document = isArray ? [] : {};\n  // Used for arrays to skip having to perform utf8 decoding\n  let arrayIndex = 0;\n  const done = false;\n\n  let isPossibleDBRef = isArray ? false : null;\n\n  // While we have more left data left keep parsing\n  while (!done) {\n    // Read the type\n    const elementType = buffer[index++];\n\n    // If we get a zero it's the last byte, exit\n    if (elementType === 0) break;\n\n    // Get the start search index\n    let i = index;\n    // Locate the end of the c string\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    }\n\n    // If are at the end of the buffer there is a problem with the document\n    if (i >= buffer.byteLength) throw new BSONError('Bad BSON Document: illegal CString');\n\n    // Represents the key\n    const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);\n\n    // shouldValidateKey is true if the key should be validated, false otherwise\n    let shouldValidateKey = true;\n    if (globalUTFValidation || utf8KeysSet?.has(name)) {\n      shouldValidateKey = validationSetting;\n    } else {\n      shouldValidateKey = !validationSetting;\n    }\n\n    if (isPossibleDBRef !== false && (name as string)[0] === '$') {\n      isPossibleDBRef = allowedDBRefKeys.test(name as string);\n    }\n    let value;\n\n    index = i + 1;\n\n    if (elementType === constants.BSON_DATA_STRING) {\n      const stringSize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      ) {\n        throw new BSONError('bad string length in bson');\n      }\n      value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n    } else if (elementType === constants.BSON_DATA_OID) {\n      const oid = ByteUtils.allocateUnsafe(12);\n      for (let i = 0; i < 12; i++) oid[i] = buffer[index + i];\n      value = new ObjectId(oid);\n      index = index + 12;\n    } else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {\n      value = new Int32(NumberUtils.getInt32LE(buffer, index));\n      index += 4;\n    } else if (elementType === constants.BSON_DATA_INT) {\n      value = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n    } else if (elementType === constants.BSON_DATA_NUMBER) {\n      value = NumberUtils.getFloat64LE(buffer, index);\n      index += 8;\n      if (promoteValues === false) value = new Double(value);\n    } else if (elementType === constants.BSON_DATA_DATE) {\n      const lowBits = NumberUtils.getInt32LE(buffer, index);\n      const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n      index += 8;\n\n      value = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === constants.BSON_DATA_BOOLEAN) {\n      if (buffer[index] !== 0 && buffer[index] !== 1)\n        throw new BSONError('illegal boolean type value');\n      value = buffer[index++] === 1;\n    } else if (elementType === constants.BSON_DATA_OBJECT) {\n      const _index = index;\n      const objectSize = NumberUtils.getInt32LE(buffer, index);\n\n      if (objectSize <= 0 || objectSize > buffer.length - index)\n        throw new BSONError('bad embedded document length in bson');\n\n      // We have a raw value\n      if (raw) {\n        value = buffer.subarray(index, index + objectSize);\n      } else {\n        let objectOptions = options;\n        if (!globalUTFValidation) {\n          objectOptions = { ...options, validation: { utf8: shouldValidateKey } };\n        }\n        value = deserializeObject(buffer, _index, objectOptions, false);\n      }\n\n      index = index + objectSize;\n    } else if (elementType === constants.BSON_DATA_ARRAY) {\n      const _index = index;\n      const objectSize = NumberUtils.getInt32LE(buffer, index);\n      let arrayOptions: DeserializeOptions = options;\n\n      // Stop index\n      const stopIndex = index + objectSize;\n\n      // All elements of array to be returned as raw bson\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = { ...options, raw: true };\n      }\n\n      if (!globalUTFValidation) {\n        arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };\n      }\n      value = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n\n      if (buffer[index - 1] !== 0) throw new BSONError('invalid array terminator byte');\n      if (index !== stopIndex) throw new BSONError('corrupted array bson');\n    } else if (elementType === constants.BSON_DATA_UNDEFINED) {\n      value = undefined;\n    } else if (elementType === constants.BSON_DATA_NULL) {\n      value = null;\n    } else if (elementType === constants.BSON_DATA_LONG) {\n      if (useBigInt64) {\n        value = NumberUtils.getBigInt64LE(buffer, index);\n        index += 8;\n      } else {\n        // Unpack the low and high bits\n        const lowBits = NumberUtils.getInt32LE(buffer, index);\n        const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n        index += 8;\n\n        const long = new Long(lowBits, highBits);\n        // Promote the long if possible\n        if (promoteLongs && promoteValues === true) {\n          value =\n            long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\n              ? long.toNumber()\n              : long;\n        } else {\n          value = long;\n        }\n      }\n    } else if (elementType === constants.BSON_DATA_DECIMAL128) {\n      // Buffer to contain the decimal bytes\n      const bytes = ByteUtils.allocateUnsafe(16);\n      // Copy the next 16 bytes into the bytes buffer\n      for (let i = 0; i < 16; i++) bytes[i] = buffer[index + i];\n      // Update index\n      index = index + 16;\n      // Assign the new Decimal128 value\n      value = new Decimal128(bytes);\n    } else if (elementType === constants.BSON_DATA_BINARY) {\n      let binarySize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n      const totalBinarySize = binarySize;\n      const subType = buffer[index++];\n\n      // Did we have a negative binary size, throw\n      if (binarySize < 0) throw new BSONError('Negative binary type element size found');\n\n      // Is the length longer than the document\n      if (binarySize > buffer.byteLength)\n        throw new BSONError('Binary type size larger than document size');\n\n      // If we have subtype 2 skip the 4 bytes for the size\n      if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n        binarySize = NumberUtils.getInt32LE(buffer, index);\n        index += 4;\n        if (binarySize < 0)\n          throw new BSONError('Negative binary type element size found for subtype 0x02');\n        if (binarySize > totalBinarySize - 4)\n          throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n        if (binarySize < totalBinarySize - 4)\n          throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n      }\n\n      if (promoteBuffers && promoteValues) {\n        value = ByteUtils.toLocalBufferType(buffer.subarray(index, index + binarySize));\n      } else {\n        value = new Binary(buffer.subarray(index, index + binarySize), subType);\n        if (subType === constants.BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n          value = value.toUUID();\n        }\n      }\n\n      // Update the index\n      index = index + binarySize;\n    } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      const source = ByteUtils.toUTF8(buffer, index, i, false);\n      // Create the regexp\n      index = i + 1;\n\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n      index = i + 1;\n\n      // For each option add the corresponding one for javascript\n      const optionsArray = new Array(regExpOptions.length);\n\n      // Parse options\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n\n      value = new RegExp(source, optionsArray.join(''));\n    } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      const source = ByteUtils.toUTF8(buffer, index, i, false);\n      index = i + 1;\n\n      // Get the start search index\n      i = index;\n      // Locate the end of the c string\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      // If are at the end of the buffer there is a problem with the document\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      // Return the C string\n      const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n      index = i + 1;\n\n      // Set the object\n      value = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === constants.BSON_DATA_SYMBOL) {\n      const stringSize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      ) {\n        throw new BSONError('bad string length in bson');\n      }\n      const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n      value = promoteValues ? symbol : new BSONSymbol(symbol);\n      index = index + stringSize;\n    } else if (elementType === constants.BSON_DATA_TIMESTAMP) {\n      value = new Timestamp({\n        i: NumberUtils.getUint32LE(buffer, index),\n        t: NumberUtils.getUint32LE(buffer, index + 4)\n      });\n      index += 8;\n    } else if (elementType === constants.BSON_DATA_MIN_KEY) {\n      value = new MinKey();\n    } else if (elementType === constants.BSON_DATA_MAX_KEY) {\n      value = new MaxKey();\n    } else if (elementType === constants.BSON_DATA_CODE) {\n      const stringSize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      ) {\n        throw new BSONError('bad string length in bson');\n      }\n      const functionString = ByteUtils.toUTF8(\n        buffer,\n        index,\n        index + stringSize - 1,\n        shouldValidateKey\n      );\n\n      value = new Code(functionString);\n\n      // Update parse index position\n      index = index + stringSize;\n    } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {\n      const totalSize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n\n      // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new BSONError('code_w_scope total size shorter minimum expected length');\n      }\n\n      // Get the code string size\n      const stringSize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n      // Check if we have a valid string\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      ) {\n        throw new BSONError('bad string length in bson');\n      }\n\n      // Javascript function\n      const functionString = ByteUtils.toUTF8(\n        buffer,\n        index,\n        index + stringSize - 1,\n        shouldValidateKey\n      );\n      // Update parse index position\n      index = index + stringSize;\n      // Parse the element\n      const _index = index;\n      // Decode the size of the object document\n      const objectSize = NumberUtils.getInt32LE(buffer, index);\n      // Decode the scope object\n      const scopeObject = deserializeObject(buffer, _index, options, false);\n      // Adjust the index\n      index = index + objectSize;\n\n      // Check if field length is too short\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new BSONError('code_w_scope total size is too short, truncating scope');\n      }\n\n      // Check if totalSize field is too long\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new BSONError('code_w_scope total size is too long, clips outer document');\n      }\n\n      value = new Code(functionString, scopeObject);\n    } else if (elementType === constants.BSON_DATA_DBPOINTER) {\n      // Get the code string size\n      const stringSize = NumberUtils.getInt32LE(buffer, index);\n      index += 4;\n      // Check if we have a valid string\n      if (\n        stringSize <= 0 ||\n        stringSize > buffer.length - index ||\n        buffer[index + stringSize - 1] !== 0\n      )\n        throw new BSONError('bad string length in bson');\n      // Namespace\n      const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n      // Update parse index position\n      index = index + stringSize;\n\n      // Read the oid\n      const oidBuffer = ByteUtils.allocateUnsafe(12);\n      for (let i = 0; i < 12; i++) oidBuffer[i] = buffer[index + i];\n      const oid = new ObjectId(oidBuffer);\n\n      // Update the index\n      index = index + 12;\n\n      // Upgrade to DBRef type\n      value = new DBRef(namespace, oid);\n    } else {\n      throw new BSONError(\n        `Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`\n      );\n    }\n    if (name === '__proto__') {\n      Object.defineProperty(object, name, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      object[name] = value;\n    }\n  }\n\n  // Check if the deserialization was against a valid array/object\n  if (size !== index - startIndex) {\n    if (isArray) throw new BSONError('corrupt array bson');\n    throw new BSONError('corrupt object bson');\n  }\n\n  // if we did not find \"$ref\", \"$id\", \"$db\", or found an extraneous $key, don't make a DBRef\n  if (!isPossibleDBRef) return object;\n\n  if (isDBRefLike(object)) {\n    const copy = Object.assign({}, object) as Partial<DBRefLike>;\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(object.$ref, object.$id, object.$db, copy);\n  }\n\n  return object;\n}\n"
        }
    ]
}