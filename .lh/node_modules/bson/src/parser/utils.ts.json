{
    "sourceFile": "node_modules/bson/src/parser/utils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892063343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "const TypedArrayPrototypeGetSymbolToStringTag = (() => {\n  // Type check system lovingly referenced from:\n  // https://github.com/nodejs/node/blob/7450332339ed40481f470df2a3014e2ec355d8d8/lib/internal/util/types.js#L13-L15\n  // eslint-disable-next-line @typescript-eslint/unbound-method -- the intention is to call this method with a bound value\n  const g = Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(Uint8Array.prototype),\n    Symbol.toStringTag\n  )!.get!;\n\n  return (value: unknown) => g.call(value);\n})();\n\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nexport function isAnyArrayBuffer(value: unknown): value is ArrayBuffer {\n  return (\n    typeof value === 'object' &&\n    value != null &&\n    Symbol.toStringTag in value &&\n    (value[Symbol.toStringTag] === 'ArrayBuffer' ||\n      value[Symbol.toStringTag] === 'SharedArrayBuffer')\n  );\n}\n\nexport function isRegExp(regexp: unknown): regexp is RegExp {\n  return regexp instanceof RegExp || Object.prototype.toString.call(regexp) === '[object RegExp]';\n}\n\nexport function isMap(value: unknown): value is Map<unknown, unknown> {\n  return (\n    typeof value === 'object' &&\n    value != null &&\n    Symbol.toStringTag in value &&\n    value[Symbol.toStringTag] === 'Map'\n  );\n}\n\nexport function isDate(date: unknown): date is Date {\n  return date instanceof Date || Object.prototype.toString.call(date) === '[object Date]';\n}\n\nexport type InspectFn = (x: unknown, options?: unknown) => string;\nexport function defaultInspect(x: unknown, _options?: unknown): string {\n  return JSON.stringify(x, (k: string, v: unknown) => {\n    if (typeof v === 'bigint') {\n      return { $numberLong: `${v}` };\n    } else if (isMap(v)) {\n      return Object.fromEntries(v);\n    }\n    return v;\n  });\n}\n\n/** @internal */\ntype StylizeFunction = (x: string, style: string) => string;\n/** @internal */\nexport function getStylizeFunction(options?: unknown): StylizeFunction | undefined {\n  const stylizeExists =\n    options != null &&\n    typeof options === 'object' &&\n    'stylize' in options &&\n    typeof options.stylize === 'function';\n\n  if (stylizeExists) {\n    return options.stylize as StylizeFunction;\n  }\n}\n"
        }
    ]
}