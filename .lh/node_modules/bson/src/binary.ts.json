{
    "sourceFile": "node_modules/bson/src/binary.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892062166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { type InspectFn, defaultInspect, isAnyArrayBuffer, isUint8Array } from './parser/utils';\nimport type { EJSONOptions } from './extended_json';\nimport { BSONError } from './error';\nimport { BSON_BINARY_SUBTYPE_UUID_NEW } from './constants';\nimport { ByteUtils } from './utils/byte_utils';\nimport { BSONValue } from './bson_value';\nimport { NumberUtils } from './utils/number_utils';\n\n/** @public */\nexport type BinarySequence = Uint8Array | number[];\n\n/** @public */\nexport interface BinaryExtendedLegacy {\n  $type: string;\n  $binary: string;\n}\n\n/** @public */\nexport interface BinaryExtended {\n  $binary: {\n    subType: string;\n    base64: string;\n  };\n}\n\n/**\n * A class representation of the BSON Binary type.\n * @public\n * @category BSONType\n */\nexport class Binary extends BSONValue {\n  get _bsontype(): 'Binary' {\n    return 'Binary';\n  }\n\n  /**\n   * Binary default subtype\n   * @internal\n   */\n  private static readonly BSON_BINARY_SUBTYPE_DEFAULT = 0;\n\n  /** Initial buffer default size */\n  static readonly BUFFER_SIZE = 256;\n  /** Default BSON type */\n  static readonly SUBTYPE_DEFAULT = 0;\n  /** Function BSON type */\n  static readonly SUBTYPE_FUNCTION = 1;\n  /** Byte Array BSON type */\n  static readonly SUBTYPE_BYTE_ARRAY = 2;\n  /** Deprecated UUID BSON type @deprecated Please use SUBTYPE_UUID */\n  static readonly SUBTYPE_UUID_OLD = 3;\n  /** UUID BSON type */\n  static readonly SUBTYPE_UUID = 4;\n  /** MD5 BSON type */\n  static readonly SUBTYPE_MD5 = 5;\n  /** Encrypted BSON type */\n  static readonly SUBTYPE_ENCRYPTED = 6;\n  /** Column BSON type */\n  static readonly SUBTYPE_COLUMN = 7;\n  /** Sensitive BSON type */\n  static readonly SUBTYPE_SENSITIVE = 8;\n  /** Vector BSON type */\n  static readonly SUBTYPE_VECTOR = 9;\n  /** User BSON type */\n  static readonly SUBTYPE_USER_DEFINED = 128;\n\n  /** datatype of a Binary Vector (subtype: 9) */\n  static readonly VECTOR_TYPE = Object.freeze({\n    Int8: 0x03,\n    Float32: 0x27,\n    PackedBit: 0x10\n  } as const);\n\n  /**\n   * The bytes of the Binary value.\n   *\n   * The format of a Binary value in BSON is defined as:\n   * ```txt\n   * binary\t::= int32 subtype (byte*)\n   * ```\n   *\n   * This `buffer` is the \"(byte*)\" segment.\n   *\n   * Unless the value is subtype 2, then deserialize will read the first 4 bytes as an int32 and set this to the remaining bytes.\n   *\n   * ```txt\n   * binary\t::= int32 unsigned_byte(2) int32 (byte*)\n   * ```\n   *\n   * @see https://bsonspec.org/spec.html\n   */\n  public buffer: Uint8Array;\n  /**\n   * The binary subtype.\n   *\n   * Current defined values are:\n   *\n   * - `unsigned_byte(0)` Generic binary subtype\n   * - `unsigned_byte(1)` Function\n   * - `unsigned_byte(2)` Binary (Deprecated)\n   * - `unsigned_byte(3)` UUID (Deprecated)\n   * - `unsigned_byte(4)` UUID\n   * - `unsigned_byte(5)` MD5\n   * - `unsigned_byte(6)` Encrypted BSON value\n   * - `unsigned_byte(7)` Compressed BSON column\n   * - `unsigned_byte(8)` Sensitive\n   * - `unsigned_byte(9)` Vector\n   * - `unsigned_byte(128)` - `unsigned_byte(255)` User defined\n   */\n  public sub_type: number;\n  /**\n   * The Binary's `buffer` can be larger than the Binary's content.\n   * This property is used to determine where the content ends in the buffer.\n   */\n  public position: number;\n\n  /**\n   * Create a new Binary instance.\n   * @param buffer - a buffer object containing the binary data.\n   * @param subType - the option binary type.\n   */\n  constructor(buffer?: BinarySequence, subType?: number) {\n    super();\n    if (\n      !(buffer == null) &&\n      typeof buffer === 'string' &&\n      !ArrayBuffer.isView(buffer) &&\n      !isAnyArrayBuffer(buffer) &&\n      !Array.isArray(buffer)\n    ) {\n      throw new BSONError('Binary can only be constructed from Uint8Array or number[]');\n    }\n\n    this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n\n    if (buffer == null) {\n      // create an empty binary buffer\n      this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n      this.position = 0;\n    } else {\n      this.buffer = Array.isArray(buffer)\n        ? ByteUtils.fromNumberArray(buffer)\n        : ByteUtils.toLocalBufferType(buffer);\n      this.position = this.buffer.byteLength;\n    }\n  }\n\n  /**\n   * Updates this binary with byte_value.\n   *\n   * @param byteValue - a single byte we wish to write.\n   */\n  put(byteValue: string | number | Uint8Array | number[]): void {\n    // If it's a string and a has more than one character throw an error\n    if (typeof byteValue === 'string' && byteValue.length !== 1) {\n      throw new BSONError('only accepts single character String');\n    } else if (typeof byteValue !== 'number' && byteValue.length !== 1)\n      throw new BSONError('only accepts single character Uint8Array or Array');\n\n    // Decode the byte value once\n    let decodedByte: number;\n    if (typeof byteValue === 'string') {\n      decodedByte = byteValue.charCodeAt(0);\n    } else if (typeof byteValue === 'number') {\n      decodedByte = byteValue;\n    } else {\n      decodedByte = byteValue[0];\n    }\n\n    if (decodedByte < 0 || decodedByte > 255) {\n      throw new BSONError('only accepts number in a valid unsigned byte range 0-255');\n    }\n\n    if (this.buffer.byteLength > this.position) {\n      this.buffer[this.position++] = decodedByte;\n    } else {\n      const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n      newSpace.set(this.buffer, 0);\n      this.buffer = newSpace;\n      this.buffer[this.position++] = decodedByte;\n    }\n  }\n\n  /**\n   * Writes a buffer to the binary.\n   *\n   * @param sequence - a string or buffer to be written to the Binary BSON object.\n   * @param offset - specify the binary of where to write the content.\n   */\n  write(sequence: BinarySequence, offset: number): void {\n    offset = typeof offset === 'number' ? offset : this.position;\n\n    // If the buffer is to small let's extend the buffer\n    if (this.buffer.byteLength < offset + sequence.length) {\n      const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n      newSpace.set(this.buffer, 0);\n\n      // Assign the new buffer\n      this.buffer = newSpace;\n    }\n\n    if (ArrayBuffer.isView(sequence)) {\n      this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n      this.position =\n        offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n    } else if (typeof sequence === 'string') {\n      throw new BSONError('input cannot be string');\n    }\n  }\n\n  /**\n   * Returns a view of **length** bytes starting at **position**.\n   *\n   * @param position - read from the given position in the Binary.\n   * @param length - the number of bytes to read.\n   */\n  read(position: number, length: number): Uint8Array {\n    length = length && length > 0 ? length : this.position;\n    const end = position + length;\n    return this.buffer.subarray(position, end > this.position ? this.position : end);\n  }\n\n  /** returns a view of the binary value as a Uint8Array */\n  value(): Uint8Array {\n    // Optimize to serialize for the situation where the data == size of buffer\n    return this.buffer.length === this.position\n      ? this.buffer\n      : this.buffer.subarray(0, this.position);\n  }\n\n  /** the length of the binary sequence */\n  length(): number {\n    return this.position;\n  }\n\n  toJSON(): string {\n    return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n  }\n\n  toString(encoding?: 'hex' | 'base64' | 'utf8' | 'utf-8'): string {\n    if (encoding === 'hex') return ByteUtils.toHex(this.buffer.subarray(0, this.position));\n    if (encoding === 'base64') return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n    if (encoding === 'utf8' || encoding === 'utf-8')\n      return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n    return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n  }\n\n  /** @internal */\n  toExtendedJSON(options?: EJSONOptions): BinaryExtendedLegacy | BinaryExtended {\n    options = options || {};\n\n    if (this.sub_type === Binary.SUBTYPE_VECTOR) {\n      validateBinaryVector(this);\n    }\n\n    const base64String = ByteUtils.toBase64(this.buffer);\n\n    const subType = Number(this.sub_type).toString(16);\n    if (options.legacy) {\n      return {\n        $binary: base64String,\n        $type: subType.length === 1 ? '0' + subType : subType\n      };\n    }\n    return {\n      $binary: {\n        base64: base64String,\n        subType: subType.length === 1 ? '0' + subType : subType\n      }\n    };\n  }\n\n  toUUID(): UUID {\n    if (this.sub_type === Binary.SUBTYPE_UUID) {\n      return new UUID(this.buffer.subarray(0, this.position));\n    }\n\n    throw new BSONError(\n      `Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`\n    );\n  }\n\n  /** Creates an Binary instance from a hex digit string */\n  static createFromHexString(hex: string, subType?: number): Binary {\n    return new Binary(ByteUtils.fromHex(hex), subType);\n  }\n\n  /** Creates an Binary instance from a base64 string */\n  static createFromBase64(base64: string, subType?: number): Binary {\n    return new Binary(ByteUtils.fromBase64(base64), subType);\n  }\n\n  /** @internal */\n  static fromExtendedJSON(\n    doc: BinaryExtendedLegacy | BinaryExtended | UUIDExtended,\n    options?: EJSONOptions\n  ): Binary {\n    options = options || {};\n    let data: Uint8Array | undefined;\n    let type;\n    if ('$binary' in doc) {\n      if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n        type = doc.$type ? parseInt(doc.$type, 16) : 0;\n        data = ByteUtils.fromBase64(doc.$binary);\n      } else {\n        if (typeof doc.$binary !== 'string') {\n          type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n          data = ByteUtils.fromBase64(doc.$binary.base64);\n        }\n      }\n    } else if ('$uuid' in doc) {\n      type = 4;\n      data = UUID.bytesFromString(doc.$uuid);\n    }\n    if (!data) {\n      throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n    }\n    return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n  }\n\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {\n    inspect ??= defaultInspect;\n    const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n    const base64Arg = inspect(base64, options);\n    const subTypeArg = inspect(this.sub_type, options);\n    return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;\n  }\n\n  /**\n   * If this Binary represents a Int8 Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.Int8`),\n   * returns a copy of the bytes in a new Int8Array.\n   *\n   * If the Binary is not a Vector, or the datatype is not Int8, an error is thrown.\n   */\n  public toInt8Array(): Int8Array {\n    if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n      throw new BSONError('Binary sub_type is not Vector');\n    }\n\n    if (this.buffer[0] !== Binary.VECTOR_TYPE.Int8) {\n      throw new BSONError('Binary datatype field is not Int8');\n    }\n\n    return new Int8Array(\n      this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position)\n    );\n  }\n\n  /**\n   * If this Binary represents a Float32 Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.Float32`),\n   * returns a copy of the bytes in a new Float32Array.\n   *\n   * If the Binary is not a Vector, or the datatype is not Float32, an error is thrown.\n   */\n  public toFloat32Array(): Float32Array {\n    if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n      throw new BSONError('Binary sub_type is not Vector');\n    }\n\n    if (this.buffer[0] !== Binary.VECTOR_TYPE.Float32) {\n      throw new BSONError('Binary datatype field is not Float32');\n    }\n\n    const floatBytes = new Uint8Array(\n      this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position)\n    );\n\n    if (NumberUtils.isBigEndian) ByteUtils.swap32(floatBytes);\n\n    return new Float32Array(floatBytes.buffer);\n  }\n\n  /**\n   * If this Binary represents packed bit Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.PackedBit`),\n   * returns a copy of the bytes that are packed bits.\n   *\n   * Use `toBits` to get the unpacked bits.\n   *\n   * If the Binary is not a Vector, or the datatype is not PackedBit, an error is thrown.\n   */\n  public toPackedBits(): Uint8Array {\n    if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n      throw new BSONError('Binary sub_type is not Vector');\n    }\n\n    if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {\n      throw new BSONError('Binary datatype field is not packed bit');\n    }\n\n    return new Uint8Array(\n      this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position)\n    );\n  }\n\n  /**\n   * If this Binary represents a Packed bit Vector (`binary.buffer[0] === Binary.VECTOR_TYPE.PackedBit`),\n   * returns a copy of the bit unpacked into a new Int8Array.\n   *\n   * Use `toPackedBits` to get the bits still in packed form.\n   *\n   * If the Binary is not a Vector, or the datatype is not PackedBit, an error is thrown.\n   */\n  public toBits(): Int8Array {\n    if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n      throw new BSONError('Binary sub_type is not Vector');\n    }\n\n    if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {\n      throw new BSONError('Binary datatype field is not packed bit');\n    }\n\n    const byteCount = this.length() - 2;\n    const bitCount = byteCount * 8 - this.buffer[1];\n    const bits = new Int8Array(bitCount);\n\n    for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {\n      const byteOffset = (bitOffset / 8) | 0;\n      const byte = this.buffer[byteOffset + 2];\n      const shift = 7 - (bitOffset % 8);\n      const bit = (byte >> shift) & 1;\n      bits[bitOffset] = bit;\n    }\n\n    return bits;\n  }\n\n  /**\n   * Constructs a Binary representing an Int8 Vector.\n   * @param array - The array to store as a view on the Binary class\n   */\n  public static fromInt8Array(array: Int8Array): Binary {\n    const buffer = ByteUtils.allocate(array.byteLength + 2);\n    buffer[0] = Binary.VECTOR_TYPE.Int8;\n    buffer[1] = 0;\n    const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n    buffer.set(intBytes, 2);\n    return new this(buffer, this.SUBTYPE_VECTOR);\n  }\n\n  /** Constructs a Binary representing an Float32 Vector. */\n  public static fromFloat32Array(array: Float32Array): Binary {\n    const binaryBytes = ByteUtils.allocate(array.byteLength + 2);\n    binaryBytes[0] = Binary.VECTOR_TYPE.Float32;\n    binaryBytes[1] = 0;\n\n    const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n    binaryBytes.set(floatBytes, 2);\n\n    if (NumberUtils.isBigEndian) ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));\n\n    return new this(binaryBytes, this.SUBTYPE_VECTOR);\n  }\n\n  /**\n   * Constructs a Binary representing a packed bit Vector.\n   *\n   * Use `fromBits` to pack an array of 1s and 0s.\n   */\n  public static fromPackedBits(array: Uint8Array, padding = 0): Binary {\n    const buffer = ByteUtils.allocate(array.byteLength + 2);\n    buffer[0] = Binary.VECTOR_TYPE.PackedBit;\n    buffer[1] = padding;\n    buffer.set(array, 2);\n    return new this(buffer, this.SUBTYPE_VECTOR);\n  }\n\n  /**\n   * Constructs a Binary representing an Packed Bit Vector.\n   * @param array - The array of 1s and 0s to pack into the Binary instance\n   */\n  public static fromBits(bits: ArrayLike<number>): Binary {\n    const byteLength = (bits.length + 7) >>> 3; // ceil(bits.length / 8)\n    const bytes = new Uint8Array(byteLength + 2);\n    bytes[0] = Binary.VECTOR_TYPE.PackedBit;\n\n    const remainder = bits.length % 8;\n    bytes[1] = remainder === 0 ? 0 : 8 - remainder;\n\n    for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {\n      const byteOffset = bitOffset >>> 3; // floor(bitOffset / 8)\n      const bit = bits[bitOffset];\n\n      if (bit !== 0 && bit !== 1) {\n        throw new BSONError(\n          `Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`\n        );\n      }\n\n      if (bit === 0) continue;\n\n      const shift = 7 - (bitOffset % 8);\n      bytes[byteOffset + 2] |= bit << shift;\n    }\n\n    return new this(bytes, Binary.SUBTYPE_VECTOR);\n  }\n}\n\nexport function validateBinaryVector(vector: Binary): void {\n  if (vector.sub_type !== Binary.SUBTYPE_VECTOR) return;\n\n  const size = vector.position;\n\n  // NOTE: Validation is only applied to **KNOWN** vector types\n  // If a new datatype is introduced, a future version of the library will need to add validation\n  const datatype = vector.buffer[0];\n\n  // NOTE: We do not enable noUncheckedIndexedAccess so TS believes this is always number\n  // a Binary vector may be empty, in which case the padding is undefined\n  // this possible value is tolerable for our validation checks\n  const padding: number | undefined = vector.buffer[1];\n\n  if (\n    (datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) &&\n    padding !== 0\n  ) {\n    throw new BSONError('Invalid Vector: padding must be zero for int8 and float32 vectors');\n  }\n\n  if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {\n    throw new BSONError(\n      'Invalid Vector: padding must be zero for packed bit vectors that are empty'\n    );\n  }\n\n  if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {\n    throw new BSONError(\n      `Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`\n    );\n  }\n}\n\n/** @public */\nexport type UUIDExtended = {\n  $uuid: string;\n};\n\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\n\n/**\n * A class representation of the BSON UUID type.\n * @public\n */\nexport class UUID extends Binary {\n  /**\n   * Create a UUID type\n   *\n   * When the argument to the constructor is omitted a random v4 UUID will be generated.\n   *\n   * @param input - Can be a 32 or 36 character hex string (dashes excluded/included) or a 16 byte binary Buffer.\n   */\n  constructor(input?: string | Uint8Array | UUID) {\n    let bytes: Uint8Array;\n    if (input == null) {\n      bytes = UUID.generate();\n    } else if (input instanceof UUID) {\n      bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n      bytes = ByteUtils.toLocalBufferType(input);\n    } else if (typeof input === 'string') {\n      bytes = UUID.bytesFromString(input);\n    } else {\n      throw new BSONError(\n        'Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).'\n      );\n    }\n    super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n  }\n\n  /**\n   * The UUID bytes\n   * @readonly\n   */\n  get id(): Uint8Array {\n    return this.buffer;\n  }\n\n  set id(value: Uint8Array) {\n    this.buffer = value;\n  }\n\n  /**\n   * Returns the UUID id as a 32 or 36 character hex string representation, excluding/including dashes (defaults to 36 character dash separated)\n   * @param includeDashes - should the string exclude dash-separators.\n   */\n  toHexString(includeDashes = true): string {\n    if (includeDashes) {\n      return [\n        ByteUtils.toHex(this.buffer.subarray(0, 4)),\n        ByteUtils.toHex(this.buffer.subarray(4, 6)),\n        ByteUtils.toHex(this.buffer.subarray(6, 8)),\n        ByteUtils.toHex(this.buffer.subarray(8, 10)),\n        ByteUtils.toHex(this.buffer.subarray(10, 16))\n      ].join('-');\n    }\n    return ByteUtils.toHex(this.buffer);\n  }\n\n  /**\n   * Converts the id into a 36 character (dashes included) hex string, unless a encoding is specified.\n   */\n  toString(encoding?: 'hex' | 'base64'): string {\n    if (encoding === 'hex') return ByteUtils.toHex(this.id);\n    if (encoding === 'base64') return ByteUtils.toBase64(this.id);\n    return this.toHexString();\n  }\n\n  /**\n   * Converts the id into its JSON string representation.\n   * A 36 character (dashes included) hex string in the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n   */\n  toJSON(): string {\n    return this.toHexString();\n  }\n\n  /**\n   * Compares the equality of this UUID with `otherID`.\n   *\n   * @param otherId - UUID instance to compare against.\n   */\n  equals(otherId: string | Uint8Array | UUID): boolean {\n    if (!otherId) {\n      return false;\n    }\n\n    if (otherId instanceof UUID) {\n      return ByteUtils.equals(otherId.id, this.id);\n    }\n\n    try {\n      return ByteUtils.equals(new UUID(otherId).id, this.id);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Creates a Binary instance from the current UUID.\n   */\n  toBinary(): Binary {\n    return new Binary(this.id, Binary.SUBTYPE_UUID);\n  }\n\n  /**\n   * Generates a populated buffer containing a v4 uuid\n   */\n  static generate(): Uint8Array {\n    const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    // Kindly borrowed from https://github.com/uuidjs/uuid/blob/master/src/v4.js\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return bytes;\n  }\n\n  /**\n   * Checks if a value is a valid bson UUID\n   * @param input - UUID, string or Buffer to validate.\n   */\n  static isValid(input: string | Uint8Array | UUID | Binary): boolean {\n    if (!input) {\n      return false;\n    }\n\n    if (typeof input === 'string') {\n      return UUID.isValidUUIDString(input);\n    }\n\n    if (isUint8Array(input)) {\n      return input.byteLength === UUID_BYTE_LENGTH;\n    }\n\n    return (\n      input._bsontype === 'Binary' &&\n      input.sub_type === this.SUBTYPE_UUID &&\n      input.buffer.byteLength === 16\n    );\n  }\n\n  /**\n   * Creates an UUID from a hex string representation of an UUID.\n   * @param hexString - 32 or 36 character hex string (dashes excluded/included).\n   */\n  static override createFromHexString(hexString: string): UUID {\n    const buffer = UUID.bytesFromString(hexString);\n    return new UUID(buffer);\n  }\n\n  /** Creates an UUID from a base64 string representation of an UUID. */\n  static override createFromBase64(base64: string): UUID {\n    return new UUID(ByteUtils.fromBase64(base64));\n  }\n\n  /** @internal */\n  static bytesFromString(representation: string) {\n    if (!UUID.isValidUUIDString(representation)) {\n      throw new BSONError(\n        'UUID string representation must be 32 hex digits or canonical hyphenated representation'\n      );\n    }\n    return ByteUtils.fromHex(representation.replace(/-/g, ''));\n  }\n\n  /**\n   * @internal\n   *\n   * Validates a string to be a hex digit sequence with or without dashes.\n   * The canonical hyphenated representation of a uuid is hex in 8-4-4-4-12 groups.\n   */\n  static isValidUUIDString(representation: string) {\n    return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n  }\n\n  /**\n   * Converts to a string representation of this Id.\n   *\n   * @returns return the 36 character hex string representation.\n   *\n   */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {\n    inspect ??= defaultInspect;\n    return `new UUID(${inspect(this.toHexString(), options)})`;\n  }\n}\n"
        }
    ]
}