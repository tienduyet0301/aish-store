{
    "sourceFile": "node_modules/bson/src/int_32.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892062771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { BSONValue } from './bson_value';\nimport { BSON_INT32_MAX, BSON_INT32_MIN } from './constants';\nimport { BSONError } from './error';\nimport type { EJSONOptions } from './extended_json';\nimport { type InspectFn, defaultInspect } from './parser/utils';\nimport { removeLeadingZerosAndExplicitPlus } from './utils/string_utils';\n\n/** @public */\nexport interface Int32Extended {\n  $numberInt: string;\n}\n\n/**\n * A class representation of a BSON Int32 type.\n * @public\n * @category BSONType\n */\nexport class Int32 extends BSONValue {\n  get _bsontype(): 'Int32' {\n    return 'Int32';\n  }\n\n  value!: number;\n  /**\n   * Create an Int32 type\n   *\n   * @param value - the number we want to represent as an int32.\n   */\n  constructor(value: number | string) {\n    super();\n    if ((value as unknown) instanceof Number) {\n      value = value.valueOf();\n    }\n\n    this.value = +value | 0;\n  }\n\n  /**\n   * Attempt to create an Int32 type from string.\n   *\n   * This method will throw a BSONError on any string input that is not representable as an Int32.\n   * Notably, this method will also throw on the following string formats:\n   * - Strings in non-decimal formats (exponent notation, binary, hex, or octal digits)\n   * - Strings non-numeric and non-leading sign characters (ex: '2.0', '24,000')\n   * - Strings with leading and/or trailing whitespace\n   *\n   * Strings with leading zeros, however, are allowed.\n   *\n   * @param value - the string we want to represent as an int32.\n   */\n  static fromString(value: string): Int32 {\n    const cleanedValue = removeLeadingZerosAndExplicitPlus(value);\n\n    const coercedValue = Number(value);\n\n    if (BSON_INT32_MAX < coercedValue) {\n      throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);\n    } else if (BSON_INT32_MIN > coercedValue) {\n      throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);\n    } else if (!Number.isSafeInteger(coercedValue)) {\n      throw new BSONError(`Input: '${value}' is not a safe integer`);\n    } else if (coercedValue.toString() !== cleanedValue) {\n      // catch all case\n      throw new BSONError(`Input: '${value}' is not a valid Int32 string`);\n    }\n    return new Int32(coercedValue);\n  }\n\n  /**\n   * Access the number value.\n   *\n   * @returns returns the wrapped int32 number.\n   */\n  valueOf(): number {\n    return this.value;\n  }\n\n  toString(radix?: number): string {\n    return this.value.toString(radix);\n  }\n\n  toJSON(): number {\n    return this.value;\n  }\n\n  /** @internal */\n  toExtendedJSON(options?: EJSONOptions): number | Int32Extended {\n    if (options && (options.relaxed || options.legacy)) return this.value;\n    return { $numberInt: this.value.toString() };\n  }\n\n  /** @internal */\n  static fromExtendedJSON(doc: Int32Extended, options?: EJSONOptions): number | Int32 {\n    return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n  }\n\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {\n    inspect ??= defaultInspect;\n    return `new Int32(${inspect(this.value, options)})`;\n  }\n}\n"
        }
    ]
}