{
    "sourceFile": "node_modules/bson/src/objectid.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892062949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { BSONValue } from './bson_value';\nimport { BSONError } from './error';\nimport { type InspectFn, defaultInspect } from './parser/utils';\nimport { ByteUtils } from './utils/byte_utils';\nimport { NumberUtils } from './utils/number_utils';\n\n// Unique sequence for the current process (initialized on first use)\nlet PROCESS_UNIQUE: Uint8Array | null = null;\n\n/** ObjectId hexString cache @internal */\nconst __idCache = new WeakMap(); // TODO(NODE-6549): convert this to #__id private field when target updated to ES2022\n\n/** @public */\nexport interface ObjectIdLike {\n  id: string | Uint8Array;\n  __id?: string;\n  toHexString(): string;\n}\n\n/** @public */\nexport interface ObjectIdExtended {\n  $oid: string;\n}\n\n/**\n * A class representation of the BSON ObjectId type.\n * @public\n * @category BSONType\n */\nexport class ObjectId extends BSONValue {\n  get _bsontype(): 'ObjectId' {\n    return 'ObjectId';\n  }\n\n  /** @internal */\n  private static index = Math.floor(Math.random() * 0xffffff);\n\n  static cacheHexString: boolean;\n\n  /** ObjectId Bytes @internal */\n  private buffer!: Uint8Array;\n\n  /**\n   * Create ObjectId from a number.\n   *\n   * @param inputId - A number.\n   * @deprecated Instead, use `static createFromTime()` to set a numeric value for the new ObjectId.\n   */\n  constructor(inputId: number);\n  /**\n   * Create ObjectId from a 24 character hex string.\n   *\n   * @param inputId - A 24 character hex string.\n   */\n  constructor(inputId: string);\n  /**\n   * Create ObjectId from the BSON ObjectId type.\n   *\n   * @param inputId - The BSON ObjectId type.\n   */\n  constructor(inputId: ObjectId);\n  /**\n   * Create ObjectId from the object type that has the toHexString method.\n   *\n   * @param inputId - The ObjectIdLike type.\n   */\n  constructor(inputId: ObjectIdLike);\n  /**\n   * Create ObjectId from a 12 byte binary Buffer.\n   *\n   * @param inputId - A 12 byte binary Buffer.\n   */\n  constructor(inputId: Uint8Array);\n  /** To generate a new ObjectId, use ObjectId() with no argument. */\n  constructor();\n  /**\n   * Implementation overload.\n   *\n   * @param inputId - All input types that are used in the constructor implementation.\n   */\n  constructor(inputId?: string | number | ObjectId | ObjectIdLike | Uint8Array);\n  /**\n   * Create a new ObjectId.\n   *\n   * @param inputId - An input value to create a new ObjectId from.\n   */\n  constructor(inputId?: string | number | ObjectId | ObjectIdLike | Uint8Array) {\n    super();\n    // workingId is set based on type of input and whether valid id exists for the input\n    let workingId;\n    if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n      if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n        throw new BSONError('Argument passed in must have an id that is of type string or Buffer');\n      }\n      if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n        workingId = ByteUtils.fromHex(inputId.toHexString());\n      } else {\n        workingId = inputId.id;\n      }\n    } else {\n      workingId = inputId;\n    }\n\n    // The following cases use workingId to construct an ObjectId\n    if (workingId == null || typeof workingId === 'number') {\n      // The most common use case (blank id, new objectId instance)\n      // Generate a new id\n      this.buffer = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n      // If intstanceof matches we can escape calling ensure buffer in Node.js environments\n      this.buffer = ByteUtils.toLocalBufferType(workingId);\n    } else if (typeof workingId === 'string') {\n      if (ObjectId.validateHexString(workingId)) {\n        this.buffer = ByteUtils.fromHex(workingId);\n        // If we are caching the hex string\n        if (ObjectId.cacheHexString) {\n          __idCache.set(this, workingId);\n        }\n      } else {\n        throw new BSONError(\n          'input must be a 24 character hex string, 12 byte Uint8Array, or an integer'\n        );\n      }\n    } else {\n      throw new BSONError('Argument passed in does not match the accepted types');\n    }\n  }\n\n  /**\n   * The ObjectId bytes\n   * @readonly\n   */\n  get id(): Uint8Array {\n    return this.buffer;\n  }\n\n  set id(value: Uint8Array) {\n    this.buffer = value;\n    if (ObjectId.cacheHexString) {\n      __idCache.set(this, ByteUtils.toHex(value));\n    }\n  }\n\n  /**\n   * @internal\n   * Validates the input string is a valid hex representation of an ObjectId.\n   */\n  private static validateHexString(string: string): boolean {\n    if (string?.length !== 24) return false;\n    for (let i = 0; i < 24; i++) {\n      const char = string.charCodeAt(i);\n      if (\n        // Check for ASCII 0-9\n        (char >= 48 && char <= 57) ||\n        // Check for ASCII a-f\n        (char >= 97 && char <= 102) ||\n        // Check for ASCII A-F\n        (char >= 65 && char <= 70)\n      ) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n\n  /** Returns the ObjectId id as a 24 lowercase character hex string representation */\n  toHexString(): string {\n    if (ObjectId.cacheHexString) {\n      const __id = __idCache.get(this);\n      if (__id) return __id;\n    }\n\n    const hexString = ByteUtils.toHex(this.id);\n\n    if (ObjectId.cacheHexString) {\n      __idCache.set(this, hexString);\n    }\n\n    return hexString;\n  }\n\n  /**\n   * Update the ObjectId index\n   * @internal\n   */\n  private static getInc(): number {\n    return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);\n  }\n\n  /**\n   * Generate a 12 byte id buffer used in ObjectId's\n   *\n   * @param time - pass in a second based timestamp.\n   */\n  static generate(time?: number): Uint8Array {\n    if ('number' !== typeof time) {\n      time = Math.floor(Date.now() / 1000);\n    }\n\n    const inc = ObjectId.getInc();\n    const buffer = ByteUtils.allocateUnsafe(12);\n\n    // 4-byte timestamp\n    NumberUtils.setInt32BE(buffer, 0, time);\n\n    // set PROCESS_UNIQUE if yet not initialized\n    if (PROCESS_UNIQUE === null) {\n      PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n    }\n\n    // 5-byte process unique\n    buffer[4] = PROCESS_UNIQUE[0];\n    buffer[5] = PROCESS_UNIQUE[1];\n    buffer[6] = PROCESS_UNIQUE[2];\n    buffer[7] = PROCESS_UNIQUE[3];\n    buffer[8] = PROCESS_UNIQUE[4];\n\n    // 3-byte counter\n    buffer[11] = inc & 0xff;\n    buffer[10] = (inc >> 8) & 0xff;\n    buffer[9] = (inc >> 16) & 0xff;\n\n    return buffer;\n  }\n\n  /**\n   * Converts the id into a 24 character hex string for printing, unless encoding is provided.\n   * @param encoding - hex or base64\n   */\n  toString(encoding?: 'hex' | 'base64'): string {\n    // Is the id a buffer then use the buffer toString method to return the format\n    if (encoding === 'base64') return ByteUtils.toBase64(this.id);\n    if (encoding === 'hex') return this.toHexString();\n    return this.toHexString();\n  }\n\n  /** Converts to its JSON the 24 character hex string representation. */\n  toJSON(): string {\n    return this.toHexString();\n  }\n\n  /** @internal */\n  private static is(variable: unknown): variable is ObjectId {\n    return (\n      variable != null &&\n      typeof variable === 'object' &&\n      '_bsontype' in variable &&\n      variable._bsontype === 'ObjectId'\n    );\n  }\n\n  /**\n   * Compares the equality of this ObjectId with `otherID`.\n   *\n   * @param otherId - ObjectId instance to compare against.\n   */\n  equals(otherId: string | ObjectId | ObjectIdLike | undefined | null): boolean {\n    if (otherId === undefined || otherId === null) {\n      return false;\n    }\n\n    if (ObjectId.is(otherId)) {\n      return (\n        this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer)\n      );\n    }\n\n    if (typeof otherId === 'string') {\n      return otherId.toLowerCase() === this.toHexString();\n    }\n\n    if (typeof otherId === 'object' && typeof otherId.toHexString === 'function') {\n      const otherIdString = otherId.toHexString();\n      const thisIdString = this.toHexString();\n      return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n    }\n\n    return false;\n  }\n\n  /** Returns the generation date (accurate up to the second) that this ID was generated. */\n  getTimestamp(): Date {\n    const timestamp = new Date();\n    const time = NumberUtils.getUint32BE(this.buffer, 0);\n    timestamp.setTime(Math.floor(time) * 1000);\n    return timestamp;\n  }\n\n  /** @internal */\n  static createPk(): ObjectId {\n    return new ObjectId();\n  }\n\n  /** @internal */\n  serializeInto(uint8array: Uint8Array, index: number): 12 {\n    uint8array[index] = this.buffer[0];\n    uint8array[index + 1] = this.buffer[1];\n    uint8array[index + 2] = this.buffer[2];\n    uint8array[index + 3] = this.buffer[3];\n    uint8array[index + 4] = this.buffer[4];\n    uint8array[index + 5] = this.buffer[5];\n    uint8array[index + 6] = this.buffer[6];\n    uint8array[index + 7] = this.buffer[7];\n    uint8array[index + 8] = this.buffer[8];\n    uint8array[index + 9] = this.buffer[9];\n    uint8array[index + 10] = this.buffer[10];\n    uint8array[index + 11] = this.buffer[11];\n    return 12;\n  }\n\n  /**\n   * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\n   *\n   * @param time - an integer number representing a number of seconds.\n   */\n  static createFromTime(time: number): ObjectId {\n    const buffer = ByteUtils.allocate(12);\n    for (let i = 11; i >= 4; i--) buffer[i] = 0;\n    // Encode time into first 4 bytes\n    NumberUtils.setInt32BE(buffer, 0, time);\n    // Return the new objectId\n    return new ObjectId(buffer);\n  }\n\n  /**\n   * Creates an ObjectId from a hex string representation of an ObjectId.\n   *\n   * @param hexString - create a ObjectId from a passed in 24 character hexstring.\n   */\n  static createFromHexString(hexString: string): ObjectId {\n    if (hexString?.length !== 24) {\n      throw new BSONError('hex string must be 24 characters');\n    }\n\n    return new ObjectId(ByteUtils.fromHex(hexString));\n  }\n\n  /** Creates an ObjectId instance from a base64 string */\n  static createFromBase64(base64: string): ObjectId {\n    if (base64?.length !== 16) {\n      throw new BSONError('base64 string must be 16 characters');\n    }\n\n    return new ObjectId(ByteUtils.fromBase64(base64));\n  }\n\n  /**\n   * Checks if a value can be used to create a valid bson ObjectId\n   * @param id - any JS value\n   */\n  static isValid(id: string | number | ObjectId | ObjectIdLike | Uint8Array): boolean {\n    if (id == null) return false;\n    if (typeof id === 'string') return ObjectId.validateHexString(id);\n\n    try {\n      new ObjectId(id);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /** @internal */\n  toExtendedJSON(): ObjectIdExtended {\n    if (this.toHexString) return { $oid: this.toHexString() };\n    return { $oid: this.toString('hex') };\n  }\n\n  /** @internal */\n  static fromExtendedJSON(doc: ObjectIdExtended): ObjectId {\n    return new ObjectId(doc.$oid);\n  }\n\n  /** @internal */\n  private isCached(): boolean {\n    return ObjectId.cacheHexString && __idCache.has(this);\n  }\n\n  /**\n   * Converts to a string representation of this Id.\n   *\n   * @returns return the 24 character hex string representation.\n   */\n  inspect(depth?: number, options?: unknown, inspect?: InspectFn): string {\n    inspect ??= defaultInspect;\n    return `new ObjectId(${inspect(this.toHexString(), options)})`;\n  }\n}\n"
        }
    ]
}