{
    "sourceFile": "node_modules/damerau-levenshtein/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892108630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// TheSpanishInquisition\n\n// Cache the matrix. Note that if you not pass a limit this implementation will use a dynamically calculate one.\n\nmodule.exports = function(__this, that, limit) {\n\n  var thisLength = __this.length,\n      thatLength = that.length,\n      matrix = [];\n\n  // If the limit is not defined it will be calculate from this and that args.\n  limit = (limit || ((thatLength > thisLength ? thatLength : thisLength)))+1;\n\n  for (var i = 0; i < limit; i++) {\n    matrix[i] = [i];\n    matrix[i].length = limit;\n  }\n  for (i = 0; i < limit; i++) {\n    matrix[0][i] = i;\n  }\n\n  if (Math.abs(thisLength - thatLength) > (limit || 100)){\n    return prepare (limit || 100);\n  }\n  if (thisLength === 0){\n    return prepare (thatLength);\n  }\n  if (thatLength === 0){\n    return prepare (thisLength);\n  }\n\n  // Calculate matrix.\n  var j, this_i, that_j, cost, min, t;\n  for (i = 1; i <= thisLength; ++i) {\n    this_i = __this[i-1];\n\n    // Step 4\n    for (j = 1; j <= thatLength; ++j) {\n      // Check the jagged ld total so far\n      if (i === j && matrix[i][j] > 4) return prepare (thisLength);\n\n      that_j = that[j-1];\n      cost = (this_i === that_j) ? 0 : 1; // Step 5\n      // Calculate the minimum (much faster than Math.min(...)).\n      min    = matrix[i - 1][j    ] + 1; // Deletion.\n      if ((t = matrix[i    ][j - 1] + 1   ) < min) min = t;   // Insertion.\n      if ((t = matrix[i - 1][j - 1] + cost) < min) min = t;   // Substitution.\n\n      // Update matrix.\n      matrix[i][j] = (i > 1 && j > 1 && this_i === that[j-2] && __this[i-2] === that_j && (t = matrix[i-2][j-2]+cost) < min) ? t : min; // Transposition.\n    }\n  }\n\n  return prepare (matrix[thisLength][thatLength]);\n\n/**\n *\n */\n  function prepare(steps) {\n    var length = Math.max(thisLength, thatLength)\n    var relative = length === 0\n      ? 0\n      : (steps / length);\n    var similarity = 1 - relative\n    return {\n      steps: steps,\n      relative: relative,\n      similarity: similarity\n    };\n  }\n\n};\n"
        }
    ]
}