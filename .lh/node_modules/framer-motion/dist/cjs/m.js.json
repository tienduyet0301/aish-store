{
    "sourceFile": "node_modules/framer-motion/dist/cjs/m.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892299758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar jsxRuntime = require('react/jsx-runtime');\nvar motionUtils = require('motion-utils');\nvar react = require('react');\nvar motionDom = require('motion-dom');\n\nconst LayoutGroupContext = react.createContext({});\n\nconst LazyContext = react.createContext({ strict: false });\n\n/**\n * @public\n */\nconst MotionConfigContext = react.createContext({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\nconst MotionContext = /* @__PURE__ */ react.createContext({});\n\nfunction isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === \"object\" &&\n        typeof v.start === \"function\");\n}\n\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nconst variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, react.useContext(MotionContext));\n    return react.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\nconst isBrowser = typeof window !== \"undefined\";\n\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\nconst motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\n\nfunction isRefObject(ref) {\n    return (ref &&\n        typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return react.useCallback((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\n/**\n * @public\n */\nconst PresenceContext = \n/* @__PURE__ */ react.createContext(null);\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = react.createContext({});\n\nconst useIsomorphicLayoutEffect = isBrowser ? react.useLayoutEffect : react.useEffect;\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    const { visualElement: parent } = react.useContext(MotionContext);\n    const lazyContext = react.useContext(LazyContext);\n    const presenceContext = react.useContext(PresenceContext);\n    const reducedMotionConfig = react.useContext(MotionConfigContext).reducedMotion;\n    const visualElementRef = react.useRef(null);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = react.useContext(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = react.useRef(false);\n    react.useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = react.useRef(Boolean(optimisedAppearId) &&\n        !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n        window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        motionDom.microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    react.useEffect(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...react.useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (jsxRuntime.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsxRuntime.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\n    }\n    MotionComponent.displayName = `motion.${typeof Component === \"string\"\n        ? Component\n        : `create(${Component.displayName ?? Component.name ?? \"\"})`}`;\n    const ForwardRefMotionComponent = react.forwardRef(MotionComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = react.useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = react.useContext(LazyContext).strict;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        isStrict) {\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n        configAndProps.ignoreStrict\n            ? motionUtils.warning(false, strictMessage)\n            : motionUtils.invariant(false, strictMessage);\n    }\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\nconst scaleCorrectors = {};\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (motionDom.transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = motionDom.transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = motionDom.transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === \"number\") {\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (motionDom.transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (motionDom.isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> \"0px\"\n            const valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);\n            if (key.startsWith(\"origin\")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nconst createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return react.useMemo(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"initial\",\n    \"style\",\n    \"values\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"custom\",\n    \"inherit\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"_dragX\",\n    \"_dragY\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"onViewportEnter\",\n    \"onViewportLeave\",\n    \"globalTapTarget\",\n    \"ignoreStrict\",\n    \"viewport\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith(\"while\") ||\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\n        key.startsWith(\"layout\") ||\n        key.startsWith(\"onTap\") ||\n        key.startsWith(\"onPan\") ||\n        key.startsWith(\"onLayout\") ||\n        validMotionProps.has(key));\n}\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp)\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won't be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\n}\ncatch {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it's present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === \"values\" && typeof props.values === \"object\")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props[\"draggable\"] &&\n                key.startsWith(\"onDrag\"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\n/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"switch\",\n    \"symbol\",\n    \"svg\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = motionDom.px.transform(-offset);\n    // Build the dash array\n    const pathLength = motionDom.px.transform(length);\n    const pathSpacing = motionDom.px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style } = state;\n    /**\n     * However, we apply transforms as CSS transforms.\n     * So if we detect a transform, transformOrigin we take it from attrs and copy it into style.\n     */\n    if (attrs.transform) {\n        style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    if (style.transform || attrs.transformOrigin) {\n        style.transformOrigin = attrs.transformOrigin ?? \"50% 50%\";\n        delete attrs.transformOrigin;\n    }\n    if (style.transform) {\n        /**\n         * SVG's element transform-origin uses its own median as a reference.\n         * Therefore, transformBox becomes a fill-box\n         */\n        style.transformBox = \"fill-box\";\n        delete attrs.transformBox;\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\nconst isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = react.useMemo(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps = false) {\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\n        const useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n        const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        const elementProps = Component !== react.Fragment\n            ? { ...filteredProps, ...visualProps, ref }\n            : {};\n        /**\n         * If component has been handed a motion value as its child,\n         * memoise its initial value and render that. Subsequent updates\n         * will be handled by the onChange handler\n         */\n        const { children } = props;\n        const renderedChildren = react.useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\n        return react.createElement(Component, {\n            ...elementProps,\n            children: renderedChildren,\n        });\n    };\n    return useRender;\n}\n\nfunction getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement?.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = react.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    return isMotionValue(value) ? value.get() : value;\n}\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = react.useContext(MotionContext);\n    const presenceContext = react.useContext(PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\n\nfunction scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            visualElement?.getValue(key)?.liveStyle !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = motionDom.transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n    }),\n};\n\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\n        const baseConfig = isSVGComponent(Component)\n            ? svgMotionConfig\n            : htmlMotionConfig;\n        const config = {\n            ...baseConfig,\n            preloadedFeatures,\n            useRender: createUseRender(forwardMotionProps),\n            createVisualElement,\n            Component,\n        };\n        return createRendererMotionComponent(config);\n    };\n}\n\nconst createMinimalMotionComponent = \n/*@__PURE__*/ createMotionComponentFactory();\n\n/**\n * HTML components\n */\nconst MotionA = /*@__PURE__*/ createMinimalMotionComponent(\"a\");\nconst MotionAbbr = /*@__PURE__*/ createMinimalMotionComponent(\"abbr\");\nconst MotionAddress = \n/*@__PURE__*/ createMinimalMotionComponent(\"address\");\nconst MotionArea = /*@__PURE__*/ createMinimalMotionComponent(\"area\");\nconst MotionArticle = \n/*@__PURE__*/ createMinimalMotionComponent(\"article\");\nconst MotionAside = /*@__PURE__*/ createMinimalMotionComponent(\"aside\");\nconst MotionAudio = /*@__PURE__*/ createMinimalMotionComponent(\"audio\");\nconst MotionB = /*@__PURE__*/ createMinimalMotionComponent(\"b\");\nconst MotionBase = /*@__PURE__*/ createMinimalMotionComponent(\"base\");\nconst MotionBdi = /*@__PURE__*/ createMinimalMotionComponent(\"bdi\");\nconst MotionBdo = /*@__PURE__*/ createMinimalMotionComponent(\"bdo\");\nconst MotionBig = /*@__PURE__*/ createMinimalMotionComponent(\"big\");\nconst MotionBlockquote = \n/*@__PURE__*/ createMinimalMotionComponent(\"blockquote\");\nconst MotionBody = /*@__PURE__*/ createMinimalMotionComponent(\"body\");\nconst MotionButton = /*@__PURE__*/ createMinimalMotionComponent(\"button\");\nconst MotionCanvas = /*@__PURE__*/ createMinimalMotionComponent(\"canvas\");\nconst MotionCaption = \n/*@__PURE__*/ createMinimalMotionComponent(\"caption\");\nconst MotionCite = /*@__PURE__*/ createMinimalMotionComponent(\"cite\");\nconst MotionCode = /*@__PURE__*/ createMinimalMotionComponent(\"code\");\nconst MotionCol = /*@__PURE__*/ createMinimalMotionComponent(\"col\");\nconst MotionColgroup = \n/*@__PURE__*/ createMinimalMotionComponent(\"colgroup\");\nconst MotionData = /*@__PURE__*/ createMinimalMotionComponent(\"data\");\nconst MotionDatalist = \n/*@__PURE__*/ createMinimalMotionComponent(\"datalist\");\nconst MotionDd = /*@__PURE__*/ createMinimalMotionComponent(\"dd\");\nconst MotionDel = /*@__PURE__*/ createMinimalMotionComponent(\"del\");\nconst MotionDetails = \n/*@__PURE__*/ createMinimalMotionComponent(\"details\");\nconst MotionDfn = /*@__PURE__*/ createMinimalMotionComponent(\"dfn\");\nconst MotionDialog = /*@__PURE__*/ createMinimalMotionComponent(\"dialog\");\nconst MotionDiv = /*@__PURE__*/ createMinimalMotionComponent(\"div\");\nconst MotionDl = /*@__PURE__*/ createMinimalMotionComponent(\"dl\");\nconst MotionDt = /*@__PURE__*/ createMinimalMotionComponent(\"dt\");\nconst MotionEm = /*@__PURE__*/ createMinimalMotionComponent(\"em\");\nconst MotionEmbed = /*@__PURE__*/ createMinimalMotionComponent(\"embed\");\nconst MotionFieldset = \n/*@__PURE__*/ createMinimalMotionComponent(\"fieldset\");\nconst MotionFigcaption = \n/*@__PURE__*/ createMinimalMotionComponent(\"figcaption\");\nconst MotionFigure = /*@__PURE__*/ createMinimalMotionComponent(\"figure\");\nconst MotionFooter = /*@__PURE__*/ createMinimalMotionComponent(\"footer\");\nconst MotionForm = /*@__PURE__*/ createMinimalMotionComponent(\"form\");\nconst MotionH1 = /*@__PURE__*/ createMinimalMotionComponent(\"h1\");\nconst MotionH2 = /*@__PURE__*/ createMinimalMotionComponent(\"h2\");\nconst MotionH3 = /*@__PURE__*/ createMinimalMotionComponent(\"h3\");\nconst MotionH4 = /*@__PURE__*/ createMinimalMotionComponent(\"h4\");\nconst MotionH5 = /*@__PURE__*/ createMinimalMotionComponent(\"h5\");\nconst MotionH6 = /*@__PURE__*/ createMinimalMotionComponent(\"h6\");\nconst MotionHead = /*@__PURE__*/ createMinimalMotionComponent(\"head\");\nconst MotionHeader = /*@__PURE__*/ createMinimalMotionComponent(\"header\");\nconst MotionHgroup = /*@__PURE__*/ createMinimalMotionComponent(\"hgroup\");\nconst MotionHr = /*@__PURE__*/ createMinimalMotionComponent(\"hr\");\nconst MotionHtml = /*@__PURE__*/ createMinimalMotionComponent(\"html\");\nconst MotionI = /*@__PURE__*/ createMinimalMotionComponent(\"i\");\nconst MotionIframe = /*@__PURE__*/ createMinimalMotionComponent(\"iframe\");\nconst MotionImg = /*@__PURE__*/ createMinimalMotionComponent(\"img\");\nconst MotionInput = /*@__PURE__*/ createMinimalMotionComponent(\"input\");\nconst MotionIns = /*@__PURE__*/ createMinimalMotionComponent(\"ins\");\nconst MotionKbd = /*@__PURE__*/ createMinimalMotionComponent(\"kbd\");\nconst MotionKeygen = /*@__PURE__*/ createMinimalMotionComponent(\"keygen\");\nconst MotionLabel = /*@__PURE__*/ createMinimalMotionComponent(\"label\");\nconst MotionLegend = /*@__PURE__*/ createMinimalMotionComponent(\"legend\");\nconst MotionLi = /*@__PURE__*/ createMinimalMotionComponent(\"li\");\nconst MotionLink = /*@__PURE__*/ createMinimalMotionComponent(\"link\");\nconst MotionMain = /*@__PURE__*/ createMinimalMotionComponent(\"main\");\nconst MotionMap = /*@__PURE__*/ createMinimalMotionComponent(\"map\");\nconst MotionMark = /*@__PURE__*/ createMinimalMotionComponent(\"mark\");\nconst MotionMenu = /*@__PURE__*/ createMinimalMotionComponent(\"menu\");\nconst MotionMenuitem = \n/*@__PURE__*/ createMinimalMotionComponent(\"menuitem\");\nconst MotionMeter = /*@__PURE__*/ createMinimalMotionComponent(\"meter\");\nconst MotionNav = /*@__PURE__*/ createMinimalMotionComponent(\"nav\");\nconst MotionObject = /*@__PURE__*/ createMinimalMotionComponent(\"object\");\nconst MotionOl = /*@__PURE__*/ createMinimalMotionComponent(\"ol\");\nconst MotionOptgroup = \n/*@__PURE__*/ createMinimalMotionComponent(\"optgroup\");\nconst MotionOption = /*@__PURE__*/ createMinimalMotionComponent(\"option\");\nconst MotionOutput = /*@__PURE__*/ createMinimalMotionComponent(\"output\");\nconst MotionP = /*@__PURE__*/ createMinimalMotionComponent(\"p\");\nconst MotionParam = /*@__PURE__*/ createMinimalMotionComponent(\"param\");\nconst MotionPicture = \n/*@__PURE__*/ createMinimalMotionComponent(\"picture\");\nconst MotionPre = /*@__PURE__*/ createMinimalMotionComponent(\"pre\");\nconst MotionProgress = \n/*@__PURE__*/ createMinimalMotionComponent(\"progress\");\nconst MotionQ = /*@__PURE__*/ createMinimalMotionComponent(\"q\");\nconst MotionRp = /*@__PURE__*/ createMinimalMotionComponent(\"rp\");\nconst MotionRt = /*@__PURE__*/ createMinimalMotionComponent(\"rt\");\nconst MotionRuby = /*@__PURE__*/ createMinimalMotionComponent(\"ruby\");\nconst MotionS = /*@__PURE__*/ createMinimalMotionComponent(\"s\");\nconst MotionSamp = /*@__PURE__*/ createMinimalMotionComponent(\"samp\");\nconst MotionScript = /*@__PURE__*/ createMinimalMotionComponent(\"script\");\nconst MotionSection = \n/*@__PURE__*/ createMinimalMotionComponent(\"section\");\nconst MotionSelect = /*@__PURE__*/ createMinimalMotionComponent(\"select\");\nconst MotionSmall = /*@__PURE__*/ createMinimalMotionComponent(\"small\");\nconst MotionSource = /*@__PURE__*/ createMinimalMotionComponent(\"source\");\nconst MotionSpan = /*@__PURE__*/ createMinimalMotionComponent(\"span\");\nconst MotionStrong = /*@__PURE__*/ createMinimalMotionComponent(\"strong\");\nconst MotionStyle = /*@__PURE__*/ createMinimalMotionComponent(\"style\");\nconst MotionSub = /*@__PURE__*/ createMinimalMotionComponent(\"sub\");\nconst MotionSummary = \n/*@__PURE__*/ createMinimalMotionComponent(\"summary\");\nconst MotionSup = /*@__PURE__*/ createMinimalMotionComponent(\"sup\");\nconst MotionTable = /*@__PURE__*/ createMinimalMotionComponent(\"table\");\nconst MotionTbody = /*@__PURE__*/ createMinimalMotionComponent(\"tbody\");\nconst MotionTd = /*@__PURE__*/ createMinimalMotionComponent(\"td\");\nconst MotionTextarea = \n/*@__PURE__*/ createMinimalMotionComponent(\"textarea\");\nconst MotionTfoot = /*@__PURE__*/ createMinimalMotionComponent(\"tfoot\");\nconst MotionTh = /*@__PURE__*/ createMinimalMotionComponent(\"th\");\nconst MotionThead = /*@__PURE__*/ createMinimalMotionComponent(\"thead\");\nconst MotionTime = /*@__PURE__*/ createMinimalMotionComponent(\"time\");\nconst MotionTitle = /*@__PURE__*/ createMinimalMotionComponent(\"title\");\nconst MotionTr = /*@__PURE__*/ createMinimalMotionComponent(\"tr\");\nconst MotionTrack = /*@__PURE__*/ createMinimalMotionComponent(\"track\");\nconst MotionU = /*@__PURE__*/ createMinimalMotionComponent(\"u\");\nconst MotionUl = /*@__PURE__*/ createMinimalMotionComponent(\"ul\");\nconst MotionVideo = /*@__PURE__*/ createMinimalMotionComponent(\"video\");\nconst MotionWbr = /*@__PURE__*/ createMinimalMotionComponent(\"wbr\");\nconst MotionWebview = \n/*@__PURE__*/ createMinimalMotionComponent(\"webview\");\n/**\n * SVG components\n */\nconst MotionAnimate = \n/*@__PURE__*/ createMinimalMotionComponent(\"animate\");\nconst MotionCircle = /*@__PURE__*/ createMinimalMotionComponent(\"circle\");\nconst MotionDefs = /*@__PURE__*/ createMinimalMotionComponent(\"defs\");\nconst MotionDesc = /*@__PURE__*/ createMinimalMotionComponent(\"desc\");\nconst MotionEllipse = \n/*@__PURE__*/ createMinimalMotionComponent(\"ellipse\");\nconst MotionG = /*@__PURE__*/ createMinimalMotionComponent(\"g\");\nconst MotionImage = /*@__PURE__*/ createMinimalMotionComponent(\"image\");\nconst MotionLine = /*@__PURE__*/ createMinimalMotionComponent(\"line\");\nconst MotionFilter = /*@__PURE__*/ createMinimalMotionComponent(\"filter\");\nconst MotionMarker = /*@__PURE__*/ createMinimalMotionComponent(\"marker\");\nconst MotionMask = /*@__PURE__*/ createMinimalMotionComponent(\"mask\");\nconst MotionMetadata = \n/*@__PURE__*/ createMinimalMotionComponent(\"metadata\");\nconst MotionPath = /*@__PURE__*/ createMinimalMotionComponent(\"path\");\nconst MotionPattern = \n/*@__PURE__*/ createMinimalMotionComponent(\"pattern\");\nconst MotionPolygon = \n/*@__PURE__*/ createMinimalMotionComponent(\"polygon\");\nconst MotionPolyline = \n/*@__PURE__*/ createMinimalMotionComponent(\"polyline\");\nconst MotionRect = /*@__PURE__*/ createMinimalMotionComponent(\"rect\");\nconst MotionStop = /*@__PURE__*/ createMinimalMotionComponent(\"stop\");\nconst MotionSvg = /*@__PURE__*/ createMinimalMotionComponent(\"svg\");\nconst MotionSymbol = /*@__PURE__*/ createMinimalMotionComponent(\"symbol\");\nconst MotionText = /*@__PURE__*/ createMinimalMotionComponent(\"text\");\nconst MotionTspan = /*@__PURE__*/ createMinimalMotionComponent(\"tspan\");\nconst MotionUse = /*@__PURE__*/ createMinimalMotionComponent(\"use\");\nconst MotionView = /*@__PURE__*/ createMinimalMotionComponent(\"view\");\nconst MotionClipPath = \n/*@__PURE__*/ createMinimalMotionComponent(\"clipPath\");\nconst MotionFeBlend = \n/*@__PURE__*/ createMinimalMotionComponent(\"feBlend\");\nconst MotionFeColorMatrix = \n/*@__PURE__*/ createMinimalMotionComponent(\"feColorMatrix\");\nconst MotionFeComponentTransfer = \n/*@__PURE__*/ createMinimalMotionComponent(\"feComponentTransfer\");\nconst MotionFeComposite = \n/*@__PURE__*/ createMinimalMotionComponent(\"feComposite\");\nconst MotionFeConvolveMatrix = \n/*@__PURE__*/ createMinimalMotionComponent(\"feConvolveMatrix\");\nconst MotionFeDiffuseLighting = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDiffuseLighting\");\nconst MotionFeDisplacementMap = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDisplacementMap\");\nconst MotionFeDistantLight = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDistantLight\");\nconst MotionFeDropShadow = \n/*@__PURE__*/ createMinimalMotionComponent(\"feDropShadow\");\nconst MotionFeFlood = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFlood\");\nconst MotionFeFuncA = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncA\");\nconst MotionFeFuncB = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncB\");\nconst MotionFeFuncG = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncG\");\nconst MotionFeFuncR = \n/*@__PURE__*/ createMinimalMotionComponent(\"feFuncR\");\nconst MotionFeGaussianBlur = \n/*@__PURE__*/ createMinimalMotionComponent(\"feGaussianBlur\");\nconst MotionFeImage = \n/*@__PURE__*/ createMinimalMotionComponent(\"feImage\");\nconst MotionFeMerge = \n/*@__PURE__*/ createMinimalMotionComponent(\"feMerge\");\nconst MotionFeMergeNode = \n/*@__PURE__*/ createMinimalMotionComponent(\"feMergeNode\");\nconst MotionFeMorphology = \n/*@__PURE__*/ createMinimalMotionComponent(\"feMorphology\");\nconst MotionFeOffset = \n/*@__PURE__*/ createMinimalMotionComponent(\"feOffset\");\nconst MotionFePointLight = \n/*@__PURE__*/ createMinimalMotionComponent(\"fePointLight\");\nconst MotionFeSpecularLighting = \n/*@__PURE__*/ createMinimalMotionComponent(\"feSpecularLighting\");\nconst MotionFeSpotLight = \n/*@__PURE__*/ createMinimalMotionComponent(\"feSpotLight\");\nconst MotionFeTile = /*@__PURE__*/ createMinimalMotionComponent(\"feTile\");\nconst MotionFeTurbulence = \n/*@__PURE__*/ createMinimalMotionComponent(\"feTurbulence\");\nconst MotionForeignObject = \n/*@__PURE__*/ createMinimalMotionComponent(\"foreignObject\");\nconst MotionLinearGradient = \n/*@__PURE__*/ createMinimalMotionComponent(\"linearGradient\");\nconst MotionRadialGradient = \n/*@__PURE__*/ createMinimalMotionComponent(\"radialGradient\");\nconst MotionTextPath = \n/*@__PURE__*/ createMinimalMotionComponent(\"textPath\");\n\nexports.a = MotionA;\nexports.abbr = MotionAbbr;\nexports.address = MotionAddress;\nexports.animate = MotionAnimate;\nexports.area = MotionArea;\nexports.article = MotionArticle;\nexports.aside = MotionAside;\nexports.audio = MotionAudio;\nexports.b = MotionB;\nexports.base = MotionBase;\nexports.bdi = MotionBdi;\nexports.bdo = MotionBdo;\nexports.big = MotionBig;\nexports.blockquote = MotionBlockquote;\nexports.body = MotionBody;\nexports.button = MotionButton;\nexports.canvas = MotionCanvas;\nexports.caption = MotionCaption;\nexports.circle = MotionCircle;\nexports.cite = MotionCite;\nexports.clipPath = MotionClipPath;\nexports.code = MotionCode;\nexports.col = MotionCol;\nexports.colgroup = MotionColgroup;\nexports.create = createMinimalMotionComponent;\nexports.data = MotionData;\nexports.datalist = MotionDatalist;\nexports.dd = MotionDd;\nexports.defs = MotionDefs;\nexports.del = MotionDel;\nexports.desc = MotionDesc;\nexports.details = MotionDetails;\nexports.dfn = MotionDfn;\nexports.dialog = MotionDialog;\nexports.div = MotionDiv;\nexports.dl = MotionDl;\nexports.dt = MotionDt;\nexports.ellipse = MotionEllipse;\nexports.em = MotionEm;\nexports.embed = MotionEmbed;\nexports.feBlend = MotionFeBlend;\nexports.feColorMatrix = MotionFeColorMatrix;\nexports.feComponentTransfer = MotionFeComponentTransfer;\nexports.feComposite = MotionFeComposite;\nexports.feConvolveMatrix = MotionFeConvolveMatrix;\nexports.feDiffuseLighting = MotionFeDiffuseLighting;\nexports.feDisplacementMap = MotionFeDisplacementMap;\nexports.feDistantLight = MotionFeDistantLight;\nexports.feDropShadow = MotionFeDropShadow;\nexports.feFlood = MotionFeFlood;\nexports.feFuncA = MotionFeFuncA;\nexports.feFuncB = MotionFeFuncB;\nexports.feFuncG = MotionFeFuncG;\nexports.feFuncR = MotionFeFuncR;\nexports.feGaussianBlur = MotionFeGaussianBlur;\nexports.feImage = MotionFeImage;\nexports.feMerge = MotionFeMerge;\nexports.feMergeNode = MotionFeMergeNode;\nexports.feMorphology = MotionFeMorphology;\nexports.feOffset = MotionFeOffset;\nexports.fePointLight = MotionFePointLight;\nexports.feSpecularLighting = MotionFeSpecularLighting;\nexports.feSpotLight = MotionFeSpotLight;\nexports.feTile = MotionFeTile;\nexports.feTurbulence = MotionFeTurbulence;\nexports.fieldset = MotionFieldset;\nexports.figcaption = MotionFigcaption;\nexports.figure = MotionFigure;\nexports.filter = MotionFilter;\nexports.footer = MotionFooter;\nexports.foreignObject = MotionForeignObject;\nexports.form = MotionForm;\nexports.g = MotionG;\nexports.h1 = MotionH1;\nexports.h2 = MotionH2;\nexports.h3 = MotionH3;\nexports.h4 = MotionH4;\nexports.h5 = MotionH5;\nexports.h6 = MotionH6;\nexports.head = MotionHead;\nexports.header = MotionHeader;\nexports.hgroup = MotionHgroup;\nexports.hr = MotionHr;\nexports.html = MotionHtml;\nexports.i = MotionI;\nexports.iframe = MotionIframe;\nexports.image = MotionImage;\nexports.img = MotionImg;\nexports.input = MotionInput;\nexports.ins = MotionIns;\nexports.kbd = MotionKbd;\nexports.keygen = MotionKeygen;\nexports.label = MotionLabel;\nexports.legend = MotionLegend;\nexports.li = MotionLi;\nexports.line = MotionLine;\nexports.linearGradient = MotionLinearGradient;\nexports.link = MotionLink;\nexports.main = MotionMain;\nexports.map = MotionMap;\nexports.mark = MotionMark;\nexports.marker = MotionMarker;\nexports.mask = MotionMask;\nexports.menu = MotionMenu;\nexports.menuitem = MotionMenuitem;\nexports.metadata = MotionMetadata;\nexports.meter = MotionMeter;\nexports.nav = MotionNav;\nexports.object = MotionObject;\nexports.ol = MotionOl;\nexports.optgroup = MotionOptgroup;\nexports.option = MotionOption;\nexports.output = MotionOutput;\nexports.p = MotionP;\nexports.param = MotionParam;\nexports.path = MotionPath;\nexports.pattern = MotionPattern;\nexports.picture = MotionPicture;\nexports.polygon = MotionPolygon;\nexports.polyline = MotionPolyline;\nexports.pre = MotionPre;\nexports.progress = MotionProgress;\nexports.q = MotionQ;\nexports.radialGradient = MotionRadialGradient;\nexports.rect = MotionRect;\nexports.rp = MotionRp;\nexports.rt = MotionRt;\nexports.ruby = MotionRuby;\nexports.s = MotionS;\nexports.samp = MotionSamp;\nexports.script = MotionScript;\nexports.section = MotionSection;\nexports.select = MotionSelect;\nexports.small = MotionSmall;\nexports.source = MotionSource;\nexports.span = MotionSpan;\nexports.stop = MotionStop;\nexports.strong = MotionStrong;\nexports.style = MotionStyle;\nexports.sub = MotionSub;\nexports.summary = MotionSummary;\nexports.sup = MotionSup;\nexports.svg = MotionSvg;\nexports.symbol = MotionSymbol;\nexports.table = MotionTable;\nexports.tbody = MotionTbody;\nexports.td = MotionTd;\nexports.text = MotionText;\nexports.textPath = MotionTextPath;\nexports.textarea = MotionTextarea;\nexports.tfoot = MotionTfoot;\nexports.th = MotionTh;\nexports.thead = MotionThead;\nexports.time = MotionTime;\nexports.title = MotionTitle;\nexports.tr = MotionTr;\nexports.track = MotionTrack;\nexports.tspan = MotionTspan;\nexports.u = MotionU;\nexports.ul = MotionUl;\nexports.use = MotionUse;\nexports.video = MotionVideo;\nexports.view = MotionView;\nexports.wbr = MotionWbr;\nexports.webview = MotionWebview;\n"
        }
    ]
}