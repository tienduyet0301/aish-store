{
    "sourceFile": "node_modules/framer-motion/dist/types/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892310183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/// <reference types=\"react\" />\nimport { F as FeatureBundle, M as MotionProps, a as MotionConfigContext, H as HTMLMotionProps, b as HTMLElements, G as GenericKeyframesTarget, D as DOMMotionComponents, c as MotionComponentProps, d as HTMLMotionComponents, S as SVGMotionComponents, E as EventInfo, e as FeaturePackages, A as AnimationControls, V as VisualElement, f as AnimationDefinition, g as VisualElementAnimationOptions, I as IProjectionNode, R as ResolvedValues, h as HTMLRenderState } from '../types.d-DDSxwf0n.js';\nexport { U as AnimationLifecycles, z as AnimationProps, k as AnimationType, W as CreateVisualElement, l as DragControls, w as DragElastic, y as DragHandlers, x as DraggableProps, ah as FeatureDefinition, ai as FeatureDefinitions, aj as FeaturePackage, X as FlatTree, n as FocusHandlers, N as ForwardRefComponent, o as HoverHandlers, af as HydratedFeatureDefinition, ag as HydratedFeatureDefinitions, Y as Inertia, Z as Keyframes, _ as KeyframesTarget, L as LayoutProps, ak as LazyFeatureBundle, B as MotionAdvancedProps, C as MotionStyle, J as MotionTransform, $ as None, a0 as Orchestration, p as PanHandlers, P as PanInfo, t as PresenceContext, al as RenderComponent, a1 as Repeat, ae as ResolveKeyframes, a2 as ResolvedKeyframesTarget, a3 as ResolvedSingleTarget, a4 as ResolvedValueTarget, O as SVGAttributesAsMotionValues, Q as SVGMotionProps, i as ScrapeMotionValuesFromProps, a5 as SingleTarget, a6 as Spring, v as SwitchLayoutGroupContext, T as TapHandlers, q as TapInfo, a7 as Target, a8 as TargetAndTransition, a9 as Transition, aa as Tween, ab as ValueTarget, ac as Variant, K as VariantLabels, ad as Variants, j as VisualState, r as createRendererMotionComponent, m as makeUseVisualState, s as optimizedAppearDataAttribute, u as useDragControls } from '../types.d-DDSxwf0n.js';\nimport * as react_jsx_runtime from 'react/jsx-runtime';\nimport * as React$1 from 'react';\nimport { useEffect, RefObject } from 'react';\nimport * as motion_dom from 'motion-dom';\nimport { MotionValue, UnresolvedValueKeyframe, Transition, ElementOrSelector, DOMKeyframesDefinition, AnimationOptions, AnimationPlaybackOptions, AnimationScope, AnimationPlaybackControlsWithThen, ValueAnimationTransition, AnimationPlaybackControls, DynamicOption, MotionValueEventCallbacks, SpringOptions, TransformOptions } from 'motion-dom';\nexport * from 'motion-dom';\nimport { Easing, EasingFunction, Point, Axis, Box } from 'motion-utils';\nexport * from 'motion-utils';\nexport { MotionGlobalConfig } from 'motion-utils';\n\n/**\n * @public\n */\ninterface AnimatePresenceProps {\n    /**\n     * By passing `initial={false}`, `AnimatePresence` will disable any initial animations on children\n     * that are present when the component is first rendered.\n     *\n     * ```jsx\n     * <AnimatePresence initial={false}>\n     *   {isVisible && (\n     *     <motion.div\n     *       key=\"modal\"\n     *       initial={{ opacity: 0 }}\n     *       animate={{ opacity: 1 }}\n     *       exit={{ opacity: 0 }}\n     *     />\n     *   )}\n     * </AnimatePresence>\n     * ```\n     *\n     * @public\n     */\n    initial?: boolean;\n    /**\n     * When a component is removed, there's no longer a chance to update its props. So if a component's `exit`\n     * prop is defined as a dynamic variant and you want to pass a new `custom` prop, you can do so via `AnimatePresence`.\n     * This will ensure all leaving components animate using the latest data.\n     *\n     * @public\n     */\n    custom?: any;\n    /**\n     * Fires when all exiting nodes have completed animating out.\n     *\n     * @public\n     */\n    onExitComplete?: () => void;\n    /**\n     * Determines how to handle entering and exiting elements.\n     *\n     * - `\"sync\"`: Default. Elements animate in and out as soon as they're added/removed.\n     * - `\"popLayout\"`: Exiting elements are \"popped\" from the page layout, allowing sibling\n     *      elements to immediately occupy their new layouts.\n     * - `\"wait\"`: Only renders one component at a time. Wait for the exiting component to animate out\n     *      before animating the next component in.\n     *\n     * @public\n     */\n    mode?: \"sync\" | \"popLayout\" | \"wait\";\n    /**\n     * Internal. Used in Framer to flag that sibling children *shouldn't* re-render as a result of a\n     * child being removed.\n     */\n    presenceAffectsLayout?: boolean;\n    /**\n     * If true, the `AnimatePresence` component will propagate parent exit animations\n     * to its children.\n     */\n    propagate?: boolean;\n    /**\n     * Internal. Set whether to anchor the x position of the exiting element to the left or right\n     * when using `mode=\"popLayout\"`.\n     */\n    anchorX?: \"left\" | \"right\";\n}\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\ndeclare const AnimatePresence: ({ children, custom, initial, onExitComplete, presenceAffectsLayout, mode, propagate, anchorX, }: React$1.PropsWithChildren<AnimatePresenceProps>) => react_jsx_runtime.JSX.Element | null;\n\ntype InheritOption = boolean | \"id\";\ninterface Props$2 {\n    id?: string;\n    inherit?: InheritOption;\n}\ndeclare const LayoutGroup: React$1.FunctionComponent<React$1.PropsWithChildren<Props$2>>;\n\ntype LazyFeatureBundle = () => Promise<FeatureBundle>;\n/**\n * @public\n */\ninterface LazyProps {\n    children?: React.ReactNode;\n    /**\n     * Can be used to provide a feature bundle synchronously or asynchronously.\n     *\n     * ```jsx\n     * // features.js\n     * import { domAnimation } from \"framer-motion\"\n     * export default domAnimation\n     *\n     * // index.js\n     * import { LazyMotion, m } from \"framer-motion\"\n     *\n     * const loadFeatures = import(\"./features.js\")\n     *   .then(res => res.default)\n     *\n     * function Component() {\n     *   return (\n     *     <LazyMotion features={loadFeatures}>\n     *       <m.div animate={{ scale: 1.5 }} />\n     *     </LazyMotion>\n     *   )\n     * }\n     * ```\n     *\n     * @public\n     */\n    features: FeatureBundle | LazyFeatureBundle;\n    /**\n     * If `true`, will throw an error if a `motion` component renders within\n     * a `LazyMotion` component.\n     *\n     * ```jsx\n     * // This component will throw an error that explains using a motion component\n     * // instead of the m component will break the benefits of code-splitting.\n     * function Component() {\n     *   return (\n     *     <LazyMotion features={domAnimation} strict>\n     *       <motion.div />\n     *     </LazyMotion>\n     *   )\n     * }\n     * ```\n     *\n     * @public\n     */\n    strict?: boolean;\n}\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimation } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimation}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimation')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\ndeclare function LazyMotion({ children, features, strict }: LazyProps): react_jsx_runtime.JSX.Element;\n\ntype IsValidProp = (key: string) => boolean;\ndeclare function filterProps(props: MotionProps, isDom: boolean, forwardMotionProps: boolean): MotionProps;\n\ninterface MotionConfigProps extends Partial<MotionConfigContext> {\n    children?: React$1.ReactNode;\n    isValidProp?: IsValidProp;\n}\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\ndeclare function MotionConfig({ children, isValidProp, ...config }: MotionConfigProps): react_jsx_runtime.JSX.Element;\n\ninterface Props$1<V> {\n    /**\n     * A HTML element to render this component as. Defaults to `\"ul\"`.\n     *\n     * @public\n     */\n    as?: keyof HTMLElements;\n    /**\n     * The axis to reorder along. By default, items will be draggable on this axis.\n     * To make draggable on both axes, set `<Reorder.Item drag />`\n     *\n     * @public\n     */\n    axis?: \"x\" | \"y\";\n    /**\n     * A callback to fire with the new value order. For instance, if the values\n     * are provided as a state from `useState`, this could be the set state function.\n     *\n     * @public\n     */\n    onReorder: (newOrder: V[]) => void;\n    /**\n     * The latest values state.\n     *\n     * ```jsx\n     * function Component() {\n     *   const [items, setItems] = useState([0, 1, 2])\n     *\n     *   return (\n     *     <Reorder.Group values={items} onReorder={setItems}>\n     *         {items.map((item) => <Reorder.Item key={item} value={item} />)}\n     *     </Reorder.Group>\n     *   )\n     * }\n     * ```\n     *\n     * @public\n     */\n    values: V[];\n}\ntype ReorderGroupProps<V> = Props$1<V> & Omit<HTMLMotionProps<any>, \"values\"> & React$1.PropsWithChildren<{}>;\ndeclare function ReorderGroupComponent<V>({ children, as, axis, onReorder, values, ...props }: ReorderGroupProps<V>, externalRef?: React$1.ForwardedRef<any>): react_jsx_runtime.JSX.Element;\ndeclare const ReorderGroup: <V>(props: ReorderGroupProps<V> & {\n    ref?: React$1.ForwardedRef<any>;\n}) => ReturnType<typeof ReorderGroupComponent>;\n\ninterface Props<V> {\n    /**\n     * A HTML element to render this component as. Defaults to `\"li\"`.\n     *\n     * @public\n     */\n    as?: keyof HTMLElements;\n    /**\n     * The value in the list that this component represents.\n     *\n     * @public\n     */\n    value: V;\n    /**\n     * A subset of layout options primarily used to disable layout=\"size\"\n     *\n     * @public\n     * @default true\n     */\n    layout?: true | \"position\";\n}\ntype ReorderItemProps<V> = Props<V> & HTMLMotionProps<any> & React$1.PropsWithChildren<{}>;\ndeclare function ReorderItemComponent<V>({ children, style, value, as, onDrag, layout, ...props }: ReorderItemProps<V>, externalRef?: React$1.ForwardedRef<any>): react_jsx_runtime.JSX.Element;\ndeclare const ReorderItem: <V>(props: ReorderItemProps<V> & {\n    ref?: React$1.ForwardedRef<any>;\n}) => ReturnType<typeof ReorderItemComponent>;\n\ndeclare namespace namespace_d {\n  export { ReorderGroup as Group, ReorderItem as Item };\n}\n\ntype ObjectTarget<O> = {\n    [K in keyof O]?: O[K] | GenericKeyframesTarget<O[K]>;\n};\ntype SequenceTime = number | \"<\" | `+${number}` | `-${number}` | `${string}`;\ntype SequenceLabel = string;\ninterface SequenceLabelWithTime {\n    name: SequenceLabel;\n    at: SequenceTime;\n}\ninterface At {\n    at?: SequenceTime;\n}\ntype MotionValueSegment = [\n    MotionValue,\n    UnresolvedValueKeyframe | UnresolvedValueKeyframe[]\n];\ntype MotionValueSegmentWithTransition = [\n    MotionValue,\n    UnresolvedValueKeyframe | UnresolvedValueKeyframe[],\n    Transition & At\n];\ntype DOMSegment = [ElementOrSelector, DOMKeyframesDefinition];\ntype DOMSegmentWithTransition = [\n    ElementOrSelector,\n    DOMKeyframesDefinition,\n    AnimationOptions & At\n];\ntype ObjectSegment<O extends {} = {}> = [O, ObjectTarget<O>];\ntype ObjectSegmentWithTransition<O extends {} = {}> = [\n    O,\n    ObjectTarget<O>,\n    AnimationOptions & At\n];\ntype Segment = ObjectSegment | ObjectSegmentWithTransition | SequenceLabel | SequenceLabelWithTime | MotionValueSegment | MotionValueSegmentWithTransition | DOMSegment | DOMSegmentWithTransition;\ntype AnimationSequence = Segment[];\ninterface SequenceOptions extends AnimationPlaybackOptions {\n    delay?: number;\n    duration?: number;\n    defaultTransition?: Transition;\n}\ninterface AbsoluteKeyframe {\n    value: string | number | null;\n    at: number;\n    easing?: Easing;\n}\ntype ValueSequence = AbsoluteKeyframe[];\ninterface SequenceMap {\n    [key: string]: ValueSequence;\n}\ntype ResolvedAnimationDefinition = {\n    keyframes: {\n        [key: string]: UnresolvedValueKeyframe[];\n    };\n    transition: {\n        [key: string]: Transition;\n    };\n};\ntype ResolvedAnimationDefinitions = Map<Element | MotionValue, ResolvedAnimationDefinition>;\n\n/**\n * Creates an animation function that is optionally scoped\n * to a specific element.\n */\ndeclare function createScopedAnimate(scope?: AnimationScope): {\n    (sequence: AnimationSequence, options?: SequenceOptions): AnimationPlaybackControlsWithThen;\n    (value: string | MotionValue<string>, keyframes: string | GenericKeyframesTarget<string>, options?: ValueAnimationTransition<string>): AnimationPlaybackControlsWithThen;\n    (value: number | MotionValue<number>, keyframes: number | GenericKeyframesTarget<number>, options?: ValueAnimationTransition<number>): AnimationPlaybackControlsWithThen;\n    <V>(value: V | MotionValue<V>, keyframes: V | GenericKeyframesTarget<V>, options?: ValueAnimationTransition<V>): AnimationPlaybackControlsWithThen;\n    (element: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: AnimationOptions): AnimationPlaybackControlsWithThen;\n    <O extends {}>(object: O | O[], keyframes: ObjectTarget<O>, options?: AnimationOptions): AnimationPlaybackControlsWithThen;\n};\ndeclare const animate: {\n    (sequence: AnimationSequence, options?: SequenceOptions): AnimationPlaybackControlsWithThen;\n    (value: string | MotionValue<string>, keyframes: string | GenericKeyframesTarget<string>, options?: ValueAnimationTransition<string>): AnimationPlaybackControlsWithThen;\n    (value: number | MotionValue<number>, keyframes: number | GenericKeyframesTarget<number>, options?: ValueAnimationTransition<number>): AnimationPlaybackControlsWithThen;\n    <V>(value: V | MotionValue<V>, keyframes: V | GenericKeyframesTarget<V>, options?: ValueAnimationTransition<V>): AnimationPlaybackControlsWithThen;\n    (element: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: AnimationOptions): AnimationPlaybackControlsWithThen;\n    <O extends {}>(object: O | O[], keyframes: ObjectTarget<O>, options?: AnimationOptions): AnimationPlaybackControlsWithThen;\n};\n\ndeclare const animateMini: (elementOrSelector: ElementOrSelector, keyframes: DOMKeyframesDefinition, options?: AnimationOptions) => AnimationPlaybackControlsWithThen;\n\ninterface ScrollOptions {\n    source?: HTMLElement;\n    container?: HTMLElement;\n    target?: Element;\n    axis?: \"x\" | \"y\";\n    offset?: ScrollOffset;\n}\ntype OnScrollProgress = (progress: number) => void;\ntype OnScrollWithInfo = (progress: number, info: ScrollInfo) => void;\ntype OnScroll = OnScrollProgress | OnScrollWithInfo;\ninterface AxisScrollInfo {\n    current: number;\n    offset: number[];\n    progress: number;\n    scrollLength: number;\n    velocity: number;\n    targetOffset: number;\n    targetLength: number;\n    containerLength: number;\n    interpolatorOffsets?: number[];\n    interpolate?: EasingFunction;\n}\ninterface ScrollInfo {\n    time: number;\n    x: AxisScrollInfo;\n    y: AxisScrollInfo;\n}\ntype OnScrollInfo = (info: ScrollInfo) => void;\ntype SupportedEdgeUnit = \"px\" | \"vw\" | \"vh\" | \"%\";\ntype EdgeUnit = `${number}${SupportedEdgeUnit}`;\ntype NamedEdges = \"start\" | \"end\" | \"center\";\ntype EdgeString = NamedEdges | EdgeUnit | `${number}`;\ntype Edge = EdgeString | number;\ntype ProgressIntersection = [number, number];\ntype Intersection = `${Edge} ${Edge}`;\ntype ScrollOffset = Array<Edge | Intersection | ProgressIntersection>;\ninterface ScrollInfoOptions {\n    container?: HTMLElement;\n    target?: Element;\n    axis?: \"x\" | \"y\";\n    offset?: ScrollOffset;\n}\n\ndeclare function scroll(onScroll: OnScroll | AnimationPlaybackControls, { axis, container, ...options }?: ScrollOptions): VoidFunction;\n\ndeclare function scrollInfo(onScroll: OnScrollInfo, { container, ...options }?: ScrollInfoOptions): () => void;\n\ntype ViewChangeHandler = (entry: IntersectionObserverEntry) => void;\ntype MarginValue = `${number}${\"px\" | \"%\"}`;\ntype MarginType = MarginValue | `${MarginValue} ${MarginValue}` | `${MarginValue} ${MarginValue} ${MarginValue}` | `${MarginValue} ${MarginValue} ${MarginValue} ${MarginValue}`;\ninterface InViewOptions {\n    root?: Element | Document;\n    margin?: MarginType;\n    amount?: \"some\" | \"all\" | number;\n}\ndeclare function inView(elementOrSelector: ElementOrSelector, onStart: (element: Element, entry: IntersectionObserverEntry) => void | ViewChangeHandler, { root, margin: rootMargin, amount }?: InViewOptions): VoidFunction;\n\ntype StaggerOrigin = \"first\" | \"last\" | \"center\" | number;\ntype StaggerOptions = {\n    startDelay?: number;\n    from?: StaggerOrigin;\n    ease?: Easing;\n};\ndeclare function stagger(duration?: number, { startDelay, from, ease }?: StaggerOptions): DynamicOption<number>;\n\ntype DelayedFunction = (overshoot: number) => void;\n/**\n * Timeout defined in ms\n */\ndeclare function delay(callback: DelayedFunction, timeout: number): () => void;\n\ndeclare const distance: (a: number, b: number) => number;\ndeclare function distance2D(a: Point, b: Point): number;\n\ndeclare const m: (<Props, TagName extends string = \"div\">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {\n    forwardMotionProps: boolean;\n}) => TagName extends \"symbol\" | \"clipPath\" | \"filter\" | \"mask\" | \"marker\" | \"text\" | \"path\" | \"animate\" | \"circle\" | \"switch\" | \"svg\" | \"stop\" | keyof HTMLElements | \"defs\" | \"desc\" | \"ellipse\" | \"feBlend\" | \"feColorMatrix\" | \"feComponentTransfer\" | \"feComposite\" | \"feConvolveMatrix\" | \"feDiffuseLighting\" | \"feDisplacementMap\" | \"feDistantLight\" | \"feDropShadow\" | \"feFlood\" | \"feFuncA\" | \"feFuncB\" | \"feFuncG\" | \"feFuncR\" | \"feGaussianBlur\" | \"feImage\" | \"feMerge\" | \"feMergeNode\" | \"feMorphology\" | \"feOffset\" | \"fePointLight\" | \"feSpecularLighting\" | \"feSpotLight\" | \"feTile\" | \"feTurbulence\" | \"foreignObject\" | \"g\" | \"image\" | \"line\" | \"linearGradient\" | \"metadata\" | \"pattern\" | \"polygon\" | \"polyline\" | \"radialGradient\" | \"rect\" | \"textPath\" | \"tspan\" | \"use\" | \"view\" ? DOMMotionComponents[TagName] : React$1.ComponentType<Omit<MotionComponentProps<Props>, \"children\"> & {\n    children?: (\"children\" extends keyof Props ? Props[keyof Props & \"children\"] | MotionComponentProps<Props>[keyof Props & \"children\"] : MotionComponentProps<Props>[\"children\"]) | undefined;\n}>) & HTMLMotionComponents & SVGMotionComponents & {\n    create: <Props, TagName extends string = \"div\">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {\n        forwardMotionProps: boolean;\n    }) => TagName extends \"symbol\" | \"clipPath\" | \"filter\" | \"mask\" | \"marker\" | \"text\" | \"path\" | \"animate\" | \"circle\" | \"switch\" | \"svg\" | \"stop\" | keyof HTMLElements | \"defs\" | \"desc\" | \"ellipse\" | \"feBlend\" | \"feColorMatrix\" | \"feComponentTransfer\" | \"feComposite\" | \"feConvolveMatrix\" | \"feDiffuseLighting\" | \"feDisplacementMap\" | \"feDistantLight\" | \"feDropShadow\" | \"feFlood\" | \"feFuncA\" | \"feFuncB\" | \"feFuncG\" | \"feFuncR\" | \"feGaussianBlur\" | \"feImage\" | \"feMerge\" | \"feMergeNode\" | \"feMorphology\" | \"feOffset\" | \"fePointLight\" | \"feSpecularLighting\" | \"feSpotLight\" | \"feTile\" | \"feTurbulence\" | \"foreignObject\" | \"g\" | \"image\" | \"line\" | \"linearGradient\" | \"metadata\" | \"pattern\" | \"polygon\" | \"polyline\" | \"radialGradient\" | \"rect\" | \"textPath\" | \"tspan\" | \"use\" | \"view\" ? DOMMotionComponents[TagName] : React$1.ComponentType<Omit<MotionComponentProps<Props>, \"children\"> & {\n        children?: (\"children\" extends keyof Props ? Props[keyof Props & \"children\"] | MotionComponentProps<Props>[keyof Props & \"children\"] : MotionComponentProps<Props>[\"children\"]) | undefined;\n    }>;\n};\n\ndeclare const motion: (<Props, TagName extends string = \"div\">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {\n    forwardMotionProps: boolean;\n}) => TagName extends \"symbol\" | \"clipPath\" | \"filter\" | \"mask\" | \"marker\" | \"text\" | \"path\" | \"animate\" | \"circle\" | \"switch\" | \"svg\" | \"stop\" | keyof HTMLElements | \"defs\" | \"desc\" | \"ellipse\" | \"feBlend\" | \"feColorMatrix\" | \"feComponentTransfer\" | \"feComposite\" | \"feConvolveMatrix\" | \"feDiffuseLighting\" | \"feDisplacementMap\" | \"feDistantLight\" | \"feDropShadow\" | \"feFlood\" | \"feFuncA\" | \"feFuncB\" | \"feFuncG\" | \"feFuncR\" | \"feGaussianBlur\" | \"feImage\" | \"feMerge\" | \"feMergeNode\" | \"feMorphology\" | \"feOffset\" | \"fePointLight\" | \"feSpecularLighting\" | \"feSpotLight\" | \"feTile\" | \"feTurbulence\" | \"foreignObject\" | \"g\" | \"image\" | \"line\" | \"linearGradient\" | \"metadata\" | \"pattern\" | \"polygon\" | \"polyline\" | \"radialGradient\" | \"rect\" | \"textPath\" | \"tspan\" | \"use\" | \"view\" ? DOMMotionComponents[TagName] : React$1.ComponentType<Omit<MotionComponentProps<Props>, \"children\"> & {\n    children?: (\"children\" extends keyof Props ? Props[keyof Props & \"children\"] | MotionComponentProps<Props>[keyof Props & \"children\"] : MotionComponentProps<Props>[\"children\"]) | undefined;\n}>) & HTMLMotionComponents & SVGMotionComponents & {\n    create: <Props, TagName extends string = \"div\">(Component: string | TagName | React$1.ComponentType<Props>, { forwardMotionProps }?: {\n        forwardMotionProps: boolean;\n    }) => TagName extends \"symbol\" | \"clipPath\" | \"filter\" | \"mask\" | \"marker\" | \"text\" | \"path\" | \"animate\" | \"circle\" | \"switch\" | \"svg\" | \"stop\" | keyof HTMLElements | \"defs\" | \"desc\" | \"ellipse\" | \"feBlend\" | \"feColorMatrix\" | \"feComponentTransfer\" | \"feComposite\" | \"feConvolveMatrix\" | \"feDiffuseLighting\" | \"feDisplacementMap\" | \"feDistantLight\" | \"feDropShadow\" | \"feFlood\" | \"feFuncA\" | \"feFuncB\" | \"feFuncG\" | \"feFuncR\" | \"feGaussianBlur\" | \"feImage\" | \"feMerge\" | \"feMergeNode\" | \"feMorphology\" | \"feOffset\" | \"fePointLight\" | \"feSpecularLighting\" | \"feSpotLight\" | \"feTile\" | \"feTurbulence\" | \"foreignObject\" | \"g\" | \"image\" | \"line\" | \"linearGradient\" | \"metadata\" | \"pattern\" | \"polygon\" | \"polyline\" | \"radialGradient\" | \"rect\" | \"textPath\" | \"tspan\" | \"use\" | \"view\" ? DOMMotionComponents[TagName] : React$1.ComponentType<Omit<MotionComponentProps<Props>, \"children\"> & {\n        children?: (\"children\" extends keyof Props ? Props[keyof Props & \"children\"] | MotionComponentProps<Props>[keyof Props & \"children\"] : MotionComponentProps<Props>[\"children\"]) | undefined;\n    }>;\n};\n\ntype EventListenerWithPointInfo = (e: PointerEvent, info: EventInfo) => void;\ndeclare const addPointerInfo: (handler: EventListenerWithPointInfo) => EventListener;\n\ndeclare function addPointerEvent(target: EventTarget, eventName: string, handler: EventListenerWithPointInfo, options?: AddEventListenerOptions): () => void;\n\ndeclare const animations: FeaturePackages;\n\ndeclare function calcLength(axis: Axis): number;\n\ndeclare const createBox: () => Box;\n\ndeclare const isBrowser: boolean;\n\ndeclare function useForceUpdate(): [VoidFunction, number];\n\ndeclare const useIsomorphicLayoutEffect: typeof useEffect;\n\ndeclare function useUnmountEffect(callback: () => void): void;\n\ndeclare const isMotionValue: (value: any) => value is MotionValue<any>;\n\n/**\n * @public\n */\ndeclare const domAnimation: FeatureBundle;\n\n/**\n * @public\n */\ndeclare const domMax: FeatureBundle;\n\n/**\n * @public\n */\ndeclare const domMin: FeatureBundle;\n\ndeclare function useMotionValueEvent<V, EventName extends keyof MotionValueEventCallbacks<V>>(value: MotionValue<V>, event: EventName, callback: MotionValueEventCallbacks<V>[EventName]): void;\n\n/**\n * @deprecated useElementScroll is deprecated. Convert to useScroll({ container: ref })\n */\ndeclare function useElementScroll(ref: RefObject<HTMLElement | null>): {\n    scrollX: motion_dom.MotionValue<number>;\n    scrollY: motion_dom.MotionValue<number>;\n    scrollXProgress: motion_dom.MotionValue<number>;\n    scrollYProgress: motion_dom.MotionValue<number>;\n};\n\n/**\n * @deprecated useViewportScroll is deprecated. Convert to useScroll()\n */\ndeclare function useViewportScroll(): {\n    scrollX: motion_dom.MotionValue<number>;\n    scrollY: motion_dom.MotionValue<number>;\n    scrollXProgress: motion_dom.MotionValue<number>;\n    scrollYProgress: motion_dom.MotionValue<number>;\n};\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\ndeclare function useMotionTemplate(fragments: TemplateStringsArray, ...values: Array<MotionValue | number | string>): MotionValue<string>;\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\ndeclare function useMotionValue<T>(initial: T): MotionValue<T>;\n\ninterface UseScrollOptions extends Omit<ScrollInfoOptions, \"container\" | \"target\"> {\n    container?: RefObject<HTMLElement | null>;\n    target?: RefObject<HTMLElement | null>;\n    layoutEffect?: boolean;\n}\ndeclare function useScroll({ container, target, layoutEffect, ...options }?: UseScrollOptions): {\n    scrollX: motion_dom.MotionValue<number>;\n    scrollY: motion_dom.MotionValue<number>;\n    scrollXProgress: motion_dom.MotionValue<number>;\n    scrollYProgress: motion_dom.MotionValue<number>;\n};\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\ndeclare function useSpring(source: MotionValue<string>, config?: SpringOptions): MotionValue<string>;\ndeclare function useSpring(source: string, config?: SpringOptions): MotionValue<string>;\ndeclare function useSpring(source: MotionValue<number>, config?: SpringOptions): MotionValue<number>;\ndeclare function useSpring(source: number, config?: SpringOptions): MotionValue<number>;\n\ndeclare function useTime(): motion_dom.MotionValue<number>;\n\ntype InputRange = number[];\ntype SingleTransformer<I, O> = (input: I) => O;\ntype MultiTransformer<I, O> = (input: I[]) => O;\n/**\n * Create a `MotionValue` that transforms the output of another `MotionValue` by mapping it from one range of values into another.\n *\n * @remarks\n *\n * Given an input range of `[-200, -100, 100, 200]` and an output range of\n * `[0, 1, 1, 0]`, the returned `MotionValue` will:\n *\n * - When provided a value between `-200` and `-100`, will return a value between `0` and  `1`.\n * - When provided a value between `-100` and `100`, will return `1`.\n * - When provided a value between `100` and `200`, will return a value between `1` and  `0`\n *\n *\n * The input range must be a linear series of numbers. The output range\n * can be any value type supported by Motion: numbers, colors, shadows, etc.\n *\n * Every value in the output range must be of the same type and in the same format.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const x = useMotionValue(0)\n *   const xRange = [-200, -100, 100, 200]\n *   const opacityRange = [0, 1, 1, 0]\n *   const opacity = useTransform(x, xRange, opacityRange)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: 200 }}\n *       style={{ opacity, x }}\n *     />\n *   )\n * }\n * ```\n *\n * @param inputValue - `MotionValue`\n * @param inputRange - A linear series of numbers (either all increasing or decreasing)\n * @param outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.\n * @param options -\n *\n *  - clamp: boolean. Clamp values to within the given range. Defaults to `true`\n *  - ease: EasingFunction[]. Easing functions to use on the interpolations between each value in the input and output ranges. If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition between each.\n *\n * @returns `MotionValue`\n *\n * @public\n */\ndeclare function useTransform<I, O>(value: MotionValue<number>, inputRange: InputRange, outputRange: O[], options?: TransformOptions<O>): MotionValue<O>;\n/**\n * Create a `MotionValue` that transforms the output of another `MotionValue` through a function.\n * In this example, `y` will always be double `x`.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const x = useMotionValue(10)\n *   const y = useTransform(x, value => value * 2)\n *\n *   return <motion.div style={{ x, y }} />\n * }\n * ```\n *\n * @param input - A `MotionValue` that will pass its latest value through `transform` to update the returned `MotionValue`.\n * @param transform - A function that accepts the latest value from `input` and returns a new value.\n * @returns `MotionValue`\n *\n * @public\n */\ndeclare function useTransform<I, O>(input: MotionValue<I>, transformer: SingleTransformer<I, O>): MotionValue<O>;\n/**\n * Pass an array of `MotionValue`s and a function to combine them. In this example, `z` will be the `x` multiplied by `y`.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const x = useMotionValue(0)\n *   const y = useMotionValue(0)\n *   const z = useTransform([x, y], ([latestX, latestY]) => latestX * latestY)\n *\n *   return <motion.div style={{ x, y, z }} />\n * }\n * ```\n *\n * @param input - An array of `MotionValue`s that will pass their latest values through `transform` to update the returned `MotionValue`.\n * @param transform - A function that accepts the latest values from `input` and returns a new value.\n * @returns `MotionValue`\n *\n * @public\n */\ndeclare function useTransform<I, O>(input: MotionValue<string>[] | MotionValue<number>[] | MotionValue<string | number>[], transformer: MultiTransformer<I, O>): MotionValue<O>;\ndeclare function useTransform<I, O>(transformer: () => O): MotionValue<O>;\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\ndeclare function useVelocity(value: MotionValue<number>): MotionValue<number>;\n\ninterface WillChange extends MotionValue<string> {\n    add(name: string): void;\n}\n\ndeclare function useWillChange(): WillChange;\n\ndeclare class WillChangeMotionValue extends MotionValue<string> implements WillChange {\n    private values;\n    add(name: string): void;\n    private update;\n}\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\ndeclare function resolveMotionValue(value?: string | number | MotionValue): string | number;\n\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\ndeclare function useReducedMotion(): boolean | null;\n\ndeclare function useReducedMotionConfig(): boolean | null;\n\n/**\n * @public\n */\ndeclare function animationControls(): AnimationControls;\n\ndeclare function useAnimate<T extends Element = any>(): [AnimationScope<T>, {\n    (sequence: AnimationSequence, options?: SequenceOptions | undefined): motion_dom.AnimationPlaybackControlsWithThen;\n    (value: string | motion_dom.MotionValue<string>, keyframes: string | GenericKeyframesTarget<string>, options?: motion_dom.ValueAnimationTransition<string> | undefined): motion_dom.AnimationPlaybackControlsWithThen;\n    (value: number | motion_dom.MotionValue<number>, keyframes: number | GenericKeyframesTarget<number>, options?: motion_dom.ValueAnimationTransition<number> | undefined): motion_dom.AnimationPlaybackControlsWithThen;\n    <V>(value: V | motion_dom.MotionValue<V>, keyframes: V | GenericKeyframesTarget<V>, options?: motion_dom.ValueAnimationTransition<V> | undefined): motion_dom.AnimationPlaybackControlsWithThen;\n    (element: motion_dom.ElementOrSelector, keyframes: motion_dom.DOMKeyframesDefinition, options?: motion_dom.AnimationOptions | undefined): motion_dom.AnimationPlaybackControlsWithThen;\n    <O extends {}>(object: O | O[], keyframes: ObjectTarget<O>, options?: motion_dom.AnimationOptions | undefined): motion_dom.AnimationPlaybackControlsWithThen;\n}];\n\ndeclare function useAnimateMini<T extends Element = any>(): [AnimationScope<T>, (elementOrSelector: motion_dom.ElementOrSelector, keyframes: motion_dom.DOMKeyframesDefinition, options?: motion_dom.AnimationOptions | undefined) => motion_dom.AnimationPlaybackControlsWithThen];\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\ndeclare function useAnimationControls(): AnimationControls;\ndeclare const useAnimation: typeof useAnimationControls;\n\ndeclare function animateVisualElement(visualElement: VisualElement, definition: AnimationDefinition, options?: VisualElementAnimationOptions): Promise<void>;\n\ntype SafeToRemove = () => void;\ntype AlwaysPresent = [true, null];\ntype Present = [true];\ntype NotPresent = [false, SafeToRemove];\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\ndeclare function usePresence(subscribe?: boolean): AlwaysPresent | Present | NotPresent;\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\ndeclare function useIsPresent(): boolean;\n\ndeclare function usePresenceData(): any;\n\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\ndeclare function useDomEvent(ref: RefObject<EventTarget | null>, eventName: string, handler?: EventListener | undefined, options?: AddEventListenerOptions): void;\n\n/**\n * Checks if a component is a `motion` component.\n */\ndeclare function isMotionComponent(component: React.ComponentType | string): boolean;\n\n/**\n * Unwraps a `motion` component and returns either a string for `motion.div` or\n * the React component for `motion(Component)`.\n *\n * If the component is not a `motion` component it returns undefined.\n */\ndeclare function unwrapMotionComponent(component: React.ComponentType | string): React.ComponentType | string | undefined;\n\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\ndeclare function isValidMotionProp(key: string): boolean;\n\ntype ScaleCorrector = (latest: string | number, node: IProjectionNode) => string | number;\ninterface ScaleCorrectorDefinition {\n    correct: ScaleCorrector;\n    applyTo?: string[];\n    isCSSVariable?: boolean;\n}\ninterface ScaleCorrectorMap {\n    [key: string]: ScaleCorrectorDefinition;\n}\n\ndeclare function addScaleCorrector(correctors: ScaleCorrectorMap): void;\n\ndeclare function useInstantLayoutTransition(): (cb?: (() => void) | undefined) => void;\n\ndeclare function useResetProjection(): () => void;\n\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\ndeclare function buildTransform(latestValues: ResolvedValues, transform: HTMLRenderState[\"transform\"], transformTemplate?: MotionProps[\"transformTemplate\"]): string;\n\ndeclare const visualElementStore: WeakMap<any, VisualElement<unknown, unknown, {}>>;\n\ntype FrameCallback = (timestamp: number, delta: number) => void;\ndeclare function useAnimationFrame(callback: FrameCallback): void;\n\ntype Cycle = (i?: number) => void;\ntype CycleState<T> = [T, Cycle];\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\ndeclare function useCycle<T>(...items: T[]): CycleState<T>;\n\ninterface UseInViewOptions extends Omit<InViewOptions, \"root\" | \"amount\"> {\n    root?: RefObject<Element | null>;\n    once?: boolean;\n    amount?: \"some\" | \"all\" | number;\n    initial?: boolean;\n}\ndeclare function useInView(ref: RefObject<Element | null>, { root, margin, amount, once, initial, }?: UseInViewOptions): boolean;\n\ndeclare function useInstantTransition(): (callback: () => void) => void;\ndeclare function disableInstantTransitions(): void;\n\ndeclare function startOptimizedAppearAnimation(element: HTMLElement, name: string, keyframes: string[] | number[], options: ValueAnimationTransition<number | string>, onReady?: (animation: Animation) => void): void;\n\ninterface NodeGroup {\n    add: (node: IProjectionNode) => void;\n    remove: (node: IProjectionNode) => void;\n    dirty: VoidFunction;\n}\n\ninterface LayoutGroupContextProps {\n    id?: string;\n    group?: NodeGroup;\n    forceRender?: VoidFunction;\n}\ndeclare const LayoutGroupContext: React$1.Context<LayoutGroupContextProps>;\n\ninterface MotionContextProps<Instance = unknown> {\n    visualElement?: VisualElement<Instance>;\n    initial?: false | string | string[];\n    animate?: string | string[];\n}\ndeclare const MotionContext: React$1.Context<MotionContextProps<unknown>>;\n\n/**\n * @public\n */\ninterface ScrollMotionValues {\n    scrollX: MotionValue<number>;\n    scrollY: MotionValue<number>;\n    scrollXProgress: MotionValue<number>;\n    scrollYProgress: MotionValue<number>;\n}\n\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n */\ndeclare function useAnimatedState(initialState: any): any[];\n\ndeclare const AnimateSharedLayout: React$1.FunctionComponent<React$1.PropsWithChildren<unknown>>;\n\n/**\n * Note: Still used by components generated by old versions of Framer\n *\n * @deprecated\n */\ndeclare const DeprecatedLayoutGroupContext: React$1.Context<string | null>;\n\ninterface ScaleMotionValues {\n    scaleX: MotionValue<number>;\n    scaleY: MotionValue<number>;\n}\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @deprecated\n */\ndeclare function useInvertedScale(scale?: Partial<ScaleMotionValues>): ScaleMotionValues;\n\nexport { type AbsoluteKeyframe, AnimatePresence, type AnimatePresenceProps, AnimateSharedLayout, AnimationControls, AnimationDefinition, type AnimationSequence, type At, type Cycle, type CycleState, DOMMotionComponents, type DOMSegment, type DOMSegmentWithTransition, type DelayedFunction, DeprecatedLayoutGroupContext, EventInfo, FeatureBundle, FeaturePackages, HTMLMotionProps, IProjectionNode, LayoutGroup, LayoutGroupContext, LazyMotion, type LazyProps, MotionConfig, MotionConfigContext, type MotionConfigProps, MotionContext, MotionProps, type MotionValueSegment, type MotionValueSegmentWithTransition, type ObjectSegment, type ObjectSegmentWithTransition, type ObjectTarget, namespace_d as Reorder, type ResolvedAnimationDefinition, type ResolvedAnimationDefinitions, ResolvedValues, type ScrollMotionValues, type Segment, type SequenceLabel, type SequenceLabelWithTime, type SequenceMap, type SequenceOptions, type SequenceTime, type UseInViewOptions, type UseScrollOptions, type ValueSequence, VisualElement, WillChangeMotionValue, addPointerEvent, addPointerInfo, addScaleCorrector, animate, animateMini, animateVisualElement, animationControls, animations, buildTransform, calcLength, createBox, createScopedAnimate, delay, disableInstantTransitions, distance, distance2D, domAnimation, domMax, domMin, filterProps, inView, isBrowser, isMotionComponent, isMotionValue, isValidMotionProp, m, motion, resolveMotionValue, scroll, scrollInfo, stagger, startOptimizedAppearAnimation, unwrapMotionComponent, useAnimate, useAnimateMini, useAnimation, useAnimationControls, useAnimationFrame, useCycle, useAnimatedState as useDeprecatedAnimatedState, useInvertedScale as useDeprecatedInvertedScale, useDomEvent, useElementScroll, useForceUpdate, useInView, useInstantLayoutTransition, useInstantTransition, useIsPresent, useIsomorphicLayoutEffect, useMotionTemplate, useMotionValue, useMotionValueEvent, usePresence, usePresenceData, useReducedMotion, useReducedMotionConfig, useResetProjection, useScroll, useSpring, useTime, useTransform, useUnmountEffect, useVelocity, useViewportScroll, useWillChange, visualElementStore };\n"
        }
    ]
}