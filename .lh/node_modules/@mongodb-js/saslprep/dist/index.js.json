{
    "sourceFile": "node_modules/@mongodb-js/saslprep/dist/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891882163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nconst getCodePoint = (character) => character.codePointAt(0);\nconst first = (x) => x[0];\nconst last = (x) => x[x.length - 1];\nfunction toCodePoints(input) {\n    const codepoints = [];\n    const size = input.length;\n    for (let i = 0; i < size; i += 1) {\n        const before = input.charCodeAt(i);\n        if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {\n            const next = input.charCodeAt(i + 1);\n            if (next >= 0xdc00 && next <= 0xdfff) {\n                codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);\n                i += 1;\n                continue;\n            }\n        }\n        codepoints.push(before);\n    }\n    return codepoints;\n}\nfunction saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l, }, input, opts = {}) {\n    const mapping2space = non_ASCII_space_characters;\n    const mapping2nothing = commonly_mapped_to_nothing;\n    if (typeof input !== 'string') {\n        throw new TypeError('Expected string.');\n    }\n    if (input.length === 0) {\n        return '';\n    }\n    const mapped_input = toCodePoints(input)\n        .map((character) => (mapping2space.get(character) ? 0x20 : character))\n        .filter((character) => !mapping2nothing.get(character));\n    const normalized_input = String.fromCodePoint\n        .apply(null, mapped_input)\n        .normalize('NFKC');\n    const normalized_map = toCodePoints(normalized_input);\n    const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));\n    if (hasProhibited) {\n        throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');\n    }\n    if (opts.allowUnassigned !== true) {\n        const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));\n        if (hasUnassigned) {\n            throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');\n        }\n    }\n    const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));\n    const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));\n    if (hasBidiRAL && hasBidiL) {\n        throw new Error('String must not contain RandALCat and LCat at the same time,' +\n            ' see https://tools.ietf.org/html/rfc3454#section-6');\n    }\n    const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));\n    const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));\n    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {\n        throw new Error('Bidirectional RandALCat character must be the first and the last' +\n            ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');\n    }\n    return normalized_input;\n}\nsaslprep.saslprep = saslprep;\nsaslprep.default = saslprep;\nmodule.exports = saslprep;\n//# sourceMappingURL=index.js.map"
        }
    ]
}