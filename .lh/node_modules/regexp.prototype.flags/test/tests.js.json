{
    "sourceFile": "node_modules/regexp.prototype.flags/test/tests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893008361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar hasOwn = require('hasown');\nvar inspect = require('object-inspect');\nvar supportsDescriptors = require('define-properties').supportsDescriptors;\nvar v = require('es-value-fixtures');\n\nvar forEach = require('for-each');\nvar availableFlags = require('available-regexp-flags');\nvar regexProperties = require('available-regexp-flags/properties');\n\nvar sortedFlags = availableFlags.slice().sort(function (a, b) { return a.localeCompare(b); }).join('');\n\nvar getRegexLiteral = function (stringRegex) {\n\ttry {\n\t\t// eslint-disable-next-line no-new-func\n\t\treturn Function('return ' + stringRegex + ';')();\n\t} catch (e) { /**/ }\n\treturn null;\n};\n\nmodule.exports = function runTests(flags, t) {\n\tforEach(v.primitives, function (nonObject) {\n\t\tt['throws'](\n\t\t\tfunction () { flags(nonObject); },\n\t\t\tTypeError,\n\t\t\t'throws when called with a non-object receiver: ' + inspect(nonObject)\n\t\t);\n\t});\n\n\tt.equal(flags(/a/g), 'g', 'flags(/a/g) !== \"g\"');\n\tt.equal(flags(/a/gmi), 'gim', 'flags(/a/gmi) !== \"gim\"');\n\tt.equal(flags(new RegExp('a', 'gmi')), 'gim', 'flags(new RegExp(\"a\", \"gmi\")) !== \"gim\"');\n\tt.equal(flags(/a/), '', 'flags(/a/) !== \"\"');\n\tt.equal(flags(new RegExp('a')), '', 'flags(new RegExp(\"a\")) !== \"\"');\n\n\tforEach(availableFlags, function (flag) {\n\t\tvar property = regexProperties[flag];\n\t\tt.test(property + ' flag', function (st) {\n\t\t\tst.equal(flags(getRegexLiteral('/a/' + flag)), flag, 'flags(/a/' + flag + ') !== ' + inspect(flag));\n\t\t\tst.equal(flags(new RegExp('a', flag)), flag, 'flags(new RegExp(\"a\", ' + inspect(flag) + ')) !== ' + inspect(flag));\n\t\t\tst.end();\n\t\t});\n\t});\n\n\tt.test('sorting', function (st) {\n\t\tst.equal(flags(/a/gim), 'gim', 'flags(/a/gim) !== \"gim\"');\n\t\tst.equal(flags(/a/mig), 'gim', 'flags(/a/mig) !== \"gim\"');\n\t\tst.equal(flags(/a/mgi), 'gim', 'flags(/a/mgi) !== \"gim\"');\n\t\tif (hasOwn(RegExp.prototype, 'sticky')) {\n\t\t\tst.equal(flags(getRegexLiteral('/a/gyim')), 'gimy', 'flags(/a/gyim) !== \"gimy\"');\n\t\t}\n\t\tif (hasOwn(RegExp.prototype, 'unicode')) {\n\t\t\tst.equal(flags(getRegexLiteral('/a/ugmi')), 'gimu', 'flags(/a/ugmi) !== \"gimu\"');\n\t\t}\n\t\tif (hasOwn(RegExp.prototype, 'dotAll')) {\n\t\t\tst.equal(flags(getRegexLiteral('/a/sgmi')), 'gims', 'flags(/a/sgmi) !== \"gims\"');\n\t\t}\n\n\t\tvar randomFlags = availableFlags.slice().sort(function () { return Math.random() > 0.5 ? 1 : -1; }).join('').replace('v', '');\n\t\tst.equal(\n\t\t\tflags(getRegexLiteral('/a/' + randomFlags)),\n\t\t\tsortedFlags.replace('v', ''),\n\t\t\t'random: flags(/a/' + randomFlags + ') === ' + inspect(sortedFlags)\n\t\t);\n\n\t\tst.end();\n\t});\n\n\tt.test('basic examples', function (st) {\n\t\tst.equal(flags(/a/g), 'g', '(/a/g).flags !== \"g\"');\n\t\tst.equal(flags(/a/gmi), 'gim', '(/a/gmi).flags !== \"gim\"');\n\t\tst.equal(flags(new RegExp('a', 'gmi')), 'gim', 'new RegExp(\"a\", \"gmi\").flags !== \"gim\"');\n\t\tst.equal(flags(/a/), '', '(/a/).flags !== \"\"');\n\t\tst.equal(flags(new RegExp('a')), '', 'new RegExp(\"a\").flags !== \"\"');\n\n\t\tst.end();\n\t});\n\n\tt.test('generic flags', function (st) {\n\t\tst.equal(flags({}), '');\n\t\tst.equal(flags({ ignoreCase: true }), 'i');\n\t\tst.equal(flags({ dotAll: 1, global: 0, sticky: 1, unicode: 1 }), 'suy');\n\t\tst.equal(flags({ __proto__: { multiline: true } }), 'm');\n\n\t\tvar obj = {};\n\t\tforEach(availableFlags, function (flag) {\n\t\t\tif (flag !== 'v') {\n\t\t\t\tobj[regexProperties[flag]] = true;\n\t\t\t}\n\t\t});\n\t\tst.equal(flags(obj), sortedFlags.replace('v', ''), 'an object with every available flag: ' + sortedFlags);\n\n\t\tst.end();\n\t});\n\n\tt.test('getters', { skip: !supportsDescriptors }, function (st) {\n\t\t/* eslint getter-return: 0 */\n\t\tvar calls = '';\n\t\tvar re = {};\n\t\tObject.defineProperty(re, 'hasIndices', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 'd';\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(re, 'global', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 'g';\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(re, 'ignoreCase', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 'i';\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(re, 'multiline', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 'm';\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(re, 'dotAll', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 's';\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(re, 'unicode', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 'u';\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(re, 'sticky', {\n\t\t\tget: function () {\n\t\t\t\tcalls += 'y';\n\t\t\t}\n\t\t});\n\n\t\tflags(re);\n\n\t\tst.equal(calls, 'dgimsuy', 'getters are called in expected order');\n\n\t\tst.end();\n\t});\n};\n"
        }
    ]
}