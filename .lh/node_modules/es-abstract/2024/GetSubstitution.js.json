{
    "sourceFile": "node_modules/es-abstract/2024/GetSubstitution.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892172189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar $TypeError = require('es-errors/type');\nvar inspect = require('object-inspect');\nvar isInteger = require('math-intrinsics/isInteger');\nvar regexTester = require('safe-regex-test');\n\nvar Get = require('./Get');\nvar IsArray = require('./IsArray');\nvar min = require('./min');\nvar StringIndexOf = require('./StringIndexOf');\nvar StringToNumber = require('./StringToNumber');\nvar substring = require('./substring');\nvar ToString = require('./ToString');\n\nvar every = require('../helpers/every');\nvar isObject = require('../helpers/isObject');\nvar isPrefixOf = require('../helpers/isPrefixOf');\nvar isStringOrUndefined = require('../helpers/isStringOrUndefined');\n\nvar startsWithDollarDigit = regexTester(/^\\$[0-9]/);\nvar startsWithDollarTwoDigit = regexTester(/^\\$[0-9][0-9]/);\n\n// http://www.ecma-international.org/ecma-262/15.0/#sec-getsubstitution\n\n// eslint-disable-next-line max-statements, max-params, max-lines-per-function\nmodule.exports = function GetSubstitution(matched, str, position, captures, namedCaptures, replacementTemplate) {\n\tif (typeof matched !== 'string') {\n\t\tthrow new $TypeError('Assertion failed: `matched` must be a String');\n\t}\n\n\tif (typeof str !== 'string') {\n\t\tthrow new $TypeError('Assertion failed: `str` must be a String');\n\t}\n\n\tif (!isInteger(position) || position < 0) {\n\t\tthrow new $TypeError('Assertion failed: `position` must be a nonnegative integer, got ' + inspect(position));\n\t}\n\n\tif (!IsArray(captures) || !every(captures, isStringOrUndefined)) {\n\t\tthrow new $TypeError('Assertion failed: `captures` must be a possibly-empty List of Strings or `undefined`, got ' + inspect(captures));\n\t}\n\n\tif (typeof namedCaptures !== 'undefined' && !isObject(namedCaptures)) {\n\t\tthrow new $TypeError('Assertion failed: `namedCaptures` must be `undefined` or an Object');\n\t}\n\n\tif (typeof replacementTemplate !== 'string') {\n\t\tthrow new $TypeError('Assertion failed: `replacementTemplate` must be a String');\n\t}\n\n\tvar stringLength = str.length; // step 1\n\n\tif (position > stringLength) {\n\t\tthrow new $TypeError('Assertion failed: position > stringLength, got ' + inspect(position)); // step 2\n\t}\n\n\tvar templateRemainder = replacementTemplate; // step 3\n\n\tvar result = ''; // step 4\n\n\twhile (templateRemainder !== '') { // step 5\n\t\t// 5.a NOTE: The following steps isolate ref (a prefix of templateRemainder), determine refReplacement (its replacement), and then append that replacement to result.\n\n\t\tvar ref, refReplacement, capture;\n\t\tif (isPrefixOf('$$', templateRemainder)) { // step 5.b\n\t\t\tref = '$$'; // step 5.b.i\n\t\t\trefReplacement = '$'; // step 5.b.ii\n\t\t} else if (isPrefixOf('$`', templateRemainder)) { // step 5.c\n\t\t\tref = '$`'; // step 5.c.i\n\t\t\trefReplacement = substring(str, 0, position); // step 5.c.ii\n\t\t} else if (isPrefixOf('$&', templateRemainder)) { // step 5.d\n\t\t\tref = '$&'; // step 5.d.i\n\t\t\trefReplacement = matched; // step 5.d.ii\n\t\t} else if (isPrefixOf('$\\'', templateRemainder)) { // step 5.e\n\t\t\tref = '$\\''; // step 5.e.i\n\t\t\tvar matchLength = matched.length; // step 5.e.ii\n\t\t\tvar tailPos = position + matchLength; // step 5.e.iii\n\t\t\trefReplacement = substring(str, min(tailPos, stringLength)); // step 5.e.iv\n\t\t\t// 5.e.v NOTE: tailPos can exceed stringLength only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose \"exec\" property is not the intrinsic %RegExp.prototype.exec%.\n\t\t} else if (startsWithDollarDigit(templateRemainder)) { // step 5.f\n\t\t\tvar digitCount = startsWithDollarTwoDigit(templateRemainder) ? 2 : 1; // step 5.f.i\n\n\t\t\tvar digits = substring(templateRemainder, 1, 1 + digitCount); // step 5.f.ii\n\n\t\t\tvar index = StringToNumber(digits); // step 5.f.iii\n\n\t\t\tif (index < 0 || index > 99) {\n\t\t\t\tthrow new $TypeError('Assertion failed: `index` must be >= 0 and <= 99'); // step 5.f.iv\n\t\t\t}\n\n\t\t\tvar captureLen = captures.length; // step 5.f.v\n\n\t\t\tif (index > captureLen && digitCount === 2) { // step 5.f.vi\n\t\t\t\t//  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.\n\n\t\t\t\tdigitCount = 1; // step 5.f.vi.2\n\n\t\t\t\tdigits = substring(digits, 0, 1); // step 5.f.vi.3\n\n\t\t\t\tindex = StringToNumber(digits); // step 5.f.vi.4\n\t\t\t}\n\n\t\t\tref = substring(templateRemainder, 0, 1 + digitCount); // step 5.f.vii\n\n\t\t\tif (1 <= index && index <= captureLen) { // step 5.f.viii\n\t\t\t\tcapture = captures[index - 1]; // step 5.f.viii.1\n\n\t\t\t\tif (typeof capture === 'undefined') { // step 5.f.viii.2\n\t\t\t\t\trefReplacement = ''; // step 5.f.viii.2.a\n\t\t\t\t} else { // step 5.f.viii.3\n\t\t\t\t\trefReplacement = capture; // step 5.f.viii.3.a\n\t\t\t\t}\n\t\t\t} else { // step 5.f.ix\n\t\t\t\trefReplacement = ref; // step 5.f.ix.1\n\t\t\t}\n\t\t} else if (isPrefixOf('$<', templateRemainder)) { // step 5.g\n\t\t\tvar gtPos = StringIndexOf(templateRemainder, '>', 0); // step 5.g.i\n\t\t\tif (gtPos === -1 || typeof namedCaptures === 'undefined') { // step 5.g.ii\n\t\t\t\tref = '$<'; // step 5.g.ii.1\n\t\t\t\trefReplacement = ref; // step 5.g.ii.2\n\t\t\t} else { // step 5.g.iii\n\t\t\t\tref = substring(templateRemainder, 0, gtPos + 1); // step 5.g.iii.1\n\t\t\t\tvar groupName = substring(templateRemainder, 2, gtPos); // step 5.g.iii.2\n\t\t\t\tif (!isObject(namedCaptures)) {\n\t\t\t\t\tthrow new $TypeError('Assertion failed: Type(namedCaptures) is not Object'); // step 5.g.iii.3\n\t\t\t\t}\n\t\t\t\tcapture = Get(namedCaptures, groupName); // step 5.g.iii.4\n\t\t\t\tif (typeof capture === 'undefined') { // step 5.g.iii.5\n\t\t\t\t\trefReplacement = ''; // step 5.g.iii.5.a\n\t\t\t\t} else { // step 5.g.iii.6\n\t\t\t\t\trefReplacement = ToString(capture); // step 5.g.iii.6.a\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // step 5.h\n\t\t\tref = substring(templateRemainder, 0, 1); // step 5.h.i\n\t\t\trefReplacement = ref; // step 5.h.ii\n\t\t}\n\n\t\tvar refLength = ref.length; // step 5.i\n\n\t\ttemplateRemainder = substring(templateRemainder, refLength); // step 5.j\n\n\t\tresult += refReplacement; // step 5.k\n\t}\n\n\treturn result; // step 6\n};\n"
        }
    ]
}