{
    "sourceFile": "node_modules/es-abstract/2024/SetTypedArrayFromTypedArray.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892176768,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar $RangeError = require('es-errors/range');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\n\nvar CloneArrayBuffer = require('./CloneArrayBuffer');\nvar GetValueFromBuffer = require('./GetValueFromBuffer');\nvar IsSharedArrayBuffer = require('./IsSharedArrayBuffer');\nvar IsTypedArrayOutOfBounds = require('./IsTypedArrayOutOfBounds');\nvar MakeTypedArrayWithBufferWitnessRecord = require('./MakeTypedArrayWithBufferWitnessRecord');\nvar SameValue = require('./SameValue');\nvar SetValueInBuffer = require('./SetValueInBuffer');\nvar TypedArrayByteLength = require('./TypedArrayByteLength');\nvar TypedArrayElementSize = require('./TypedArrayElementSize');\nvar TypedArrayElementType = require('./TypedArrayElementType');\nvar TypedArrayLength = require('./TypedArrayLength');\n\nvar typedArrayBuffer = require('typed-array-buffer');\nvar typedArrayByteOffset = require('typed-array-byte-offset');\nvar whichTypedArray = require('which-typed-array');\nvar callBound = require('call-bound');\nvar isInteger = require('math-intrinsics/isInteger');\n\nvar $ArrayBuffer = callBound('ArrayBuffer', true);\n\n// https://262.ecma-international.org/15.0/#sec-settypedarrayfromtypedarray\n\nmodule.exports = function SetTypedArrayFromTypedArray(target, targetOffset, source) {\n\tvar whichTarget = whichTypedArray(target);\n\tif (!whichTarget) {\n\t\tthrow new $TypeError('Assertion failed: `target` must be a Typed Array');\n\t}\n\n\tif (targetOffset !== Infinity && (!isInteger(targetOffset) || targetOffset < 0)) {\n\t\tthrow new $TypeError('Assertion failed: `targetOffset` must be a non-negative integer or +Infinity');\n\t}\n\n\tvar whichSource = whichTypedArray(source);\n\tif (!whichSource) {\n\t\tthrow new $TypeError('Assertion failed: `source` must be a Typed Array');\n\t}\n\n\tvar targetBuffer = typedArrayBuffer(target); // step 1\n\n\tvar targetRecord = MakeTypedArrayWithBufferWitnessRecord(target, 'SEQ-CST'); // step 2\n\n\tif (IsTypedArrayOutOfBounds(targetRecord)) {\n\t\tthrow new $TypeError('target is out of bounds'); // step 3\n\t}\n\n\tvar targetLength = TypedArrayLength(targetRecord); // step 4\n\n\tvar srcBuffer = typedArrayBuffer(source); // step 5\n\n\tvar srcRecord = MakeTypedArrayWithBufferWitnessRecord(source, 'SEQ-CST'); // step 6\n\n\tif (IsTypedArrayOutOfBounds(srcRecord)) {\n\t\tthrow new $TypeError('target is out of bounds'); // step 7\n\t}\n\n\tvar srcLength = TypedArrayLength(srcRecord); // step 8\n\n\tvar targetType = TypedArrayElementType(target); // step 9\n\n\tvar targetElementSize = TypedArrayElementSize(target); // step 10\n\n\tvar targetByteOffset = typedArrayByteOffset(target); // step 11\n\n\tvar srcType = TypedArrayElementType(source); // step 12\n\n\tvar srcElementSize = TypedArrayElementSize(source); // step 13\n\n\tvar srcByteOffset = typedArrayByteOffset(source); // step 14\n\n\tif (targetOffset === Infinity) {\n\t\tthrow new $RangeError('targetOffset must be a non-negative integer or +Infinity'); // step 15\n\t}\n\n\tif (srcLength + targetOffset > targetLength) {\n\t\tthrow new $RangeError('targetOffset + source.length must not be greater than target.length'); // step 16\n\t}\n\n\tvar targetContentType = whichTarget === 'BigInt64Array' || whichTarget === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';\n\tvar sourceContentType = whichSource === 'BigInt64Array' || whichSource === 'BigUint64Array' ? 'BIGINT' : 'NUMBER';\n\tif (targetContentType !== sourceContentType) {\n\t\tthrow new $TypeError('source and target must have the same content type'); // step 17\n\t}\n\n\tvar sameSharedArrayBuffer = false;\n\tif (IsSharedArrayBuffer(srcBuffer) && IsSharedArrayBuffer(targetBuffer)) { // step 18\n\t\t// a. If srcBuffer.[[ArrayBufferData]] and targetBuffer.[[ArrayBufferData]] are the same Shared Data Block values, let same be true; else let same be false.\n\t\tthrow new $SyntaxError('SharedArrayBuffer is not supported by this implementation');\n\t}\n\n\tvar srcByteIndex;\n\tif (SameValue(srcBuffer, targetBuffer) || sameSharedArrayBuffer) { // step 19\n\t\tvar srcByteLength = TypedArrayByteLength(srcRecord); // step 19.a\n\t\tsrcBuffer = CloneArrayBuffer(srcBuffer, srcByteOffset, srcByteLength, $ArrayBuffer); // step 19.b\n\t\tsrcByteIndex = 0; // step 19.c\n\t} else { // step 20\n\t\tsrcByteIndex = srcByteOffset; // step 20.a\n\t}\n\n\tvar targetByteIndex = (targetOffset * targetElementSize) + targetByteOffset; // step 21\n\n\tvar limit = targetByteIndex + (targetElementSize * srcLength); // step 22\n\n\tvar value;\n\tif (srcType === targetType) { // step 23\n\t\t// a. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n\n\t\twhile (targetByteIndex < limit) { // step 23.b\n\t\t\tvalue = GetValueFromBuffer(srcBuffer, srcByteIndex, 'UINT8', true, 'UNORDERED'); // step 23.b.i\n\n\t\t\tSetValueInBuffer(targetBuffer, targetByteIndex, 'UINT8', value, true, 'UNORDERED'); // step 23.b.ii\n\n\t\t\tsrcByteIndex += 1; // step 23.b.iii\n\n\t\t\ttargetByteIndex += 1; // step 23.b.iv\n\t\t}\n\t} else { // step 24\n\t\twhile (targetByteIndex < limit) { // step 24.a\n\t\t\tvalue = GetValueFromBuffer(srcBuffer, srcByteIndex, srcType, true, 'UNORDERED'); // step 24.a.i\n\n\t\t\tSetValueInBuffer(targetBuffer, targetByteIndex, targetType, value, true, 'UNORDERED'); // step 24.a.ii\n\n\t\t\tsrcByteIndex += srcElementSize; // step 24.a.iii\n\n\t\t\ttargetByteIndex += targetElementSize; // step 24.a.iv\n\t\t}\n\t}\n};\n"
        }
    ]
}