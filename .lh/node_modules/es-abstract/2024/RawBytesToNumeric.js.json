{
    "sourceFile": "node_modules/es-abstract/2024/RawBytesToNumeric.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892175031,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bound');\n\nvar $RangeError = require('es-errors/range');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $BigInt = GetIntrinsic('%BigInt%', true);\n\nvar hasOwnProperty = require('./HasOwnProperty');\nvar IsArray = require('./IsArray');\nvar IsBigIntElementType = require('./IsBigIntElementType');\nvar IsUnsignedElementType = require('./IsUnsignedElementType');\n\nvar bytesAsFloat32 = require('../helpers/bytesAsFloat32');\nvar bytesAsFloat64 = require('../helpers/bytesAsFloat64');\nvar bytesAsInteger = require('../helpers/bytesAsInteger');\nvar every = require('../helpers/every');\nvar isByteValue = require('../helpers/isByteValue');\n\nvar $reverse = callBound('Array.prototype.reverse');\nvar $slice = callBound('Array.prototype.slice');\n\nvar keys = require('object-keys');\n\n// https://262.ecma-international.org/15.0/#table-the-typedarray-constructors\nvar TypeToSizes = {\n\t__proto__: null,\n\tINT8: 1,\n\tUINT8: 1,\n\tUINT8C: 1,\n\tINT16: 2,\n\tUINT16: 2,\n\tINT32: 4,\n\tUINT32: 4,\n\tBIGINT64: 8,\n\tBIGUINT64: 8,\n\tFLOAT32: 4,\n\tFLOAT64: 8\n};\n\n// https://262.ecma-international.org/15.0/#sec-rawbytestonumeric\n\nmodule.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {\n\tif (!hasOwnProperty(TypeToSizes, type)) {\n\t\tthrow new $TypeError('Assertion failed: `type` must be a TypedArray element type: ' + keys(TypeToSizes));\n\t}\n\tif (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {\n\t\tthrow new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');\n\t}\n\tif (typeof isLittleEndian !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');\n\t}\n\n\tvar elementSize = TypeToSizes[type]; // step 1\n\n\tif (rawBytes.length !== elementSize) {\n\t\t// this assertion is not in the spec, but it'd be an editorial error if it were ever violated\n\t\tthrow new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);\n\t}\n\n\tvar isBigInt = IsBigIntElementType(type);\n\tif (isBigInt && !$BigInt) {\n\t\tthrow new $SyntaxError('this environment does not support BigInts');\n\t}\n\n\t// eslint-disable-next-line no-param-reassign\n\trawBytes = $slice(rawBytes, 0, elementSize);\n\tif (!isLittleEndian) {\n\t\t$reverse(rawBytes); // step 2\n\t}\n\n\tif (type === 'FLOAT32') { // step 3\n\t\treturn bytesAsFloat32(rawBytes);\n\t}\n\n\tif (type === 'FLOAT64') { // step 4\n\t\treturn bytesAsFloat64(rawBytes);\n\t}\n\n\treturn bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);\n};\n"
        }
    ]
}