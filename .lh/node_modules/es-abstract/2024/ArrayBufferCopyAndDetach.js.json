{
    "sourceFile": "node_modules/es-abstract/2024/ArrayBufferCopyAndDetach.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892170740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar min = require('math-intrinsics/min');\nvar $TypeError = require('es-errors/type');\nvar $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\n\nvar callBound = require('call-bound');\n\nvar byteLength = require('array-buffer-byte-length');\nvar $maxByteLength = callBound('%ArrayBuffer.prototype.maxByteLength%', true);\nvar copy = function copyAB(src, start, end) {\n\tvar that = new $Uint8Array(src);\n\tif (typeof end === 'undefined') {\n\t\tend = that.length; // eslint-disable-line no-param-reassign\n\t}\n\tvar result = new $ArrayBuffer(end - start);\n\tvar resultArray = new $Uint8Array(result);\n\tfor (var i = 0; i < resultArray.length; i++) {\n\t\tresultArray[i] = that[i + start];\n\t}\n\treturn result;\n};\nvar $abSlice = callBound('%ArrayBuffer.prototype.slice%', true)\n\t|| function slice(ab, a, b) { // in node < 0.11, slice is an own nonconfigurable property\n\t\treturn ab.slice ? ab.slice(a, b) : copy(ab, a, b); // node 0.8 lacks `slice`\n\t};\n\nvar DetachArrayBuffer = require('./DetachArrayBuffer');\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar IsFixedLengthArrayBuffer = require('./IsFixedLengthArrayBuffer');\nvar ToIndex = require('./ToIndex');\n\nvar isArrayBuffer = require('is-array-buffer');\nvar isSharedArrayBuffer = require('is-shared-array-buffer');\n\nmodule.exports = function ArrayBufferCopyAndDetach(arrayBuffer, newLength, preserveResizability) {\n\tif (preserveResizability !== 'PRESERVE-RESIZABILITY' && preserveResizability !== 'FIXED-LENGTH') {\n\t\tthrow new $TypeError('`preserveResizability` must be ~PRESERVE-RESIZABILITY~ or ~FIXED-LENGTH~');\n\t}\n\n\tif (!isArrayBuffer(arrayBuffer) || isSharedArrayBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('`arrayBuffer` must be an ArrayBuffer'); // steps 1 - 2\n\t}\n\n\tvar abByteLength;\n\n\tvar newByteLength;\n\tif (typeof newLength === 'undefined') { // step 3\n\t\tnewByteLength = byteLength(arrayBuffer); // step 3.a\n\t\tabByteLength = newByteLength;\n\t} else { // step 4\n\t\tnewByteLength = ToIndex(newLength); // step 4.a\n\t}\n\n\tif (IsDetachedBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('`arrayBuffer` must not be detached'); // step 5\n\t}\n\n\tvar newMaxByteLength;\n\tif (preserveResizability === 'PRESERVE-RESIZABILITY' && !IsFixedLengthArrayBuffer(arrayBuffer)) { // step 6\n\t\tnewMaxByteLength = $maxByteLength(arrayBuffer); // step 6.a\n\t} else { // step 7\n\t\tnewMaxByteLength = 'EMPTY'; // step 7.a\n\t}\n\n\t// commented out since there's no way to set or access this key\n\n\t// 8. If arrayBuffer.[[ArrayBufferDetachKey]] is not undefined, throw a TypeError exception.\n\n\t// 9. Let newBuffer be ? AllocateArrayBuffer(%ArrayBuffer%, newByteLength, newMaxByteLength).\n\tvar newBuffer = newMaxByteLength === 'EMPTY' ? new $ArrayBuffer(newByteLength) : new $ArrayBuffer(newByteLength, { maxByteLength: newMaxByteLength });\n\n\tif (typeof abByteLength !== 'number') {\n\t\tabByteLength = byteLength(arrayBuffer);\n\t}\n\tvar copyLength = min(newByteLength, abByteLength); // step 10\n\tif (newByteLength > copyLength) {\n\t\tvar taNew = new $Uint8Array(newBuffer);\n\t\tvar taOld = new $Uint8Array(arrayBuffer);\n\t\tfor (var i = 0; i < copyLength; i++) {\n\t\t\ttaNew[i] = taOld[i];\n\t\t}\n\t} else {\n\t\tnewBuffer = $abSlice(arrayBuffer, 0, copyLength); // ? optimization for when the new buffer will not be larger than the old one\n\t}\n\t/*\n\t11. Let fromBlock be arrayBuffer.[[ArrayBufferData]].\n\t12. Let toBlock be newBuffer.[[ArrayBufferData]].\n\t13. Perform CopyDataBlockBytes(toBlock, 0, fromBlock, 0, copyLength).\n\t14. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a realloc.\n\t*/\n\n\tDetachArrayBuffer(arrayBuffer); // step 15\n\n\treturn newBuffer; // step 16\n};\n"
        }
    ]
}