{
    "sourceFile": "node_modules/es-abstract/2024/IsTypedArrayOutOfBounds.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892173109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar $TypeError = require('es-errors/type');\n\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar TypedArrayElementSize = require('./TypedArrayElementSize');\n\nvar isTypedArrayWithBufferWitnessRecord = require('../helpers/records/typed-array-with-buffer-witness-record');\n\nvar typedArrayBuffer = require('typed-array-buffer');\nvar typedArrayByteOffset = require('typed-array-byte-offset');\nvar typedArrayLength = require('typed-array-length');\n\n// https://262.ecma-international.org/15.0/#sec-istypedarrayoutofbounds\n\nmodule.exports = function IsTypedArrayOutOfBounds(taRecord) {\n\tif (!isTypedArrayWithBufferWitnessRecord(taRecord)) {\n\t\tthrow new $TypeError('Assertion failed: `taRecord` must be a TypedArray With Buffer Witness Record');\n\t}\n\n\tvar O = taRecord['[[Object]]']; // step 1\n\n\tvar bufferByteLength = taRecord['[[CachedBufferByteLength]]']; // step 2\n\n\tif (IsDetachedBuffer(typedArrayBuffer(O)) && bufferByteLength !== 'DETACHED') {\n\t\tthrow new $TypeError('Assertion failed: typed array is detached only if the byte length is ~DETACHED~'); // step 3\n\t}\n\n\tif (bufferByteLength === 'DETACHED') {\n\t\treturn true; // step 4\n\t}\n\n\tvar byteOffsetStart = typedArrayByteOffset(O); // step 5\n\n\tvar byteOffsetEnd;\n\tvar length = typedArrayLength(O);\n\t// TODO: probably use package for array length\n\t// seems to apply when TA is backed by a resizable/growable AB\n\tif (length === 'AUTO') { // step 6\n\t\tbyteOffsetEnd = bufferByteLength; // step 6.a\n\t} else {\n\t\tvar elementSize = TypedArrayElementSize(O); // step 7.a\n\n\t\tbyteOffsetEnd = byteOffsetStart + (length * elementSize); // step 7.b\n\t}\n\n\tif (byteOffsetStart > bufferByteLength || byteOffsetEnd > bufferByteLength) {\n\t\treturn true; // step 8\n\t}\n\n\t// 9. NOTE: 0-length TypedArrays are not considered out-of-bounds.\n\n\treturn false; // step 10\n};\n"
        }
    ]
}