{
    "sourceFile": "node_modules/es-abstract/2021/AbstractRelationalComparison.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892142222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $TypeError = require('es-errors/type');\n\nvar $isNaN = require('math-intrinsics/isNaN');\n\nvar IsStringPrefix = require('./IsStringPrefix');\nvar StringToBigInt = require('./StringToBigInt');\nvar ToNumeric = require('./ToNumeric');\nvar ToPrimitive = require('./ToPrimitive');\nvar Type = require('./Type');\n\nvar BigIntLessThan = require('./BigInt/lessThan');\nvar NumberLessThan = require('./Number/lessThan');\n\n// https://262.ecma-international.org/9.0/#sec-abstract-relational-comparison\n\n// eslint-disable-next-line max-statements, max-lines-per-function\nmodule.exports = function AbstractRelationalComparison(x, y, LeftFirst) {\n\tif (typeof LeftFirst !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');\n\t}\n\tvar px;\n\tvar py;\n\tif (LeftFirst) {\n\t\tpx = ToPrimitive(x, $Number);\n\t\tpy = ToPrimitive(y, $Number);\n\t} else {\n\t\tpy = ToPrimitive(y, $Number);\n\t\tpx = ToPrimitive(x, $Number);\n\t}\n\tif (typeof px === 'string' && typeof py === 'string') {\n\t\tif (IsStringPrefix(py, px)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (IsStringPrefix(px, py)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f\n\t}\n\n\tvar nx;\n\tvar ny;\n\tif (typeof px === 'bigint' && typeof py === 'string') {\n\t\tny = StringToBigInt(py);\n\t\tif ($isNaN(ny)) {\n\t\t\treturn void undefined;\n\t\t}\n\t\treturn BigIntLessThan(px, ny);\n\t}\n\tif (typeof px === 'string' && typeof py === 'bigint') {\n\t\tnx = StringToBigInt(px);\n\t\tif ($isNaN(nx)) {\n\t\t\treturn void undefined;\n\t\t}\n\t\treturn BigIntLessThan(nx, py);\n\t}\n\n\tnx = ToNumeric(px);\n\tny = ToNumeric(py);\n\tif (Type(nx) === Type(ny)) {\n\t\treturn typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);\n\t}\n\n\tif ($isNaN(nx) || $isNaN(ny)) {\n\t\treturn void undefined;\n\t}\n\tif (nx === -Infinity || ny === Infinity) {\n\t\treturn true;\n\t}\n\tif (nx === Infinity || ny === -Infinity) {\n\t\treturn false;\n\t}\n\n\treturn nx < ny; // by now, these are both nonzero, finite, and not equal\n};\n"
        }
    ]
}