{
    "sourceFile": "node_modules/es-abstract/2021/SetValueInBuffer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892145949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar isInteger = require('math-intrinsics/isInteger');\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\n\nvar IsBigIntElementType = require('./IsBigIntElementType');\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar NumericToRawBytes = require('./NumericToRawBytes');\n\nvar isArrayBuffer = require('is-array-buffer');\nvar isSharedArrayBuffer = require('is-shared-array-buffer');\nvar hasOwn = require('hasown');\n\nvar tableTAO = require('./tables/typed-array-objects');\n\nvar defaultEndianness = require('../helpers/defaultEndianness');\nvar forEach = require('../helpers/forEach');\n\n// https://262.ecma-international.org/12.0/#sec-setvalueinbuffer\n\n/* eslint max-params: 0 */\n\nmodule.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {\n\tvar isSAB = isSharedArrayBuffer(arrayBuffer);\n\tif (!isArrayBuffer(arrayBuffer) && !isSAB) {\n\t\tthrow new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');\n\t}\n\n\tif (!isInteger(byteIndex) || byteIndex < 0) {\n\t\tthrow new $TypeError('Assertion failed: `byteIndex` must be a non-negative integer');\n\t}\n\n\tif (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {\n\t\tthrow new $TypeError('Assertion failed: `type` must be a Typed Array Element Type');\n\t}\n\n\tif (typeof value !== 'number' && typeof value !== 'bigint') {\n\t\tthrow new $TypeError('Assertion failed: `value` must be a Number or a BigInt');\n\t}\n\n\tif (typeof isTypedArray !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isTypedArray` must be a boolean');\n\t}\n\tif (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {\n\t\tthrow new $TypeError('Assertion failed: `order` must be `\"SeqCst\"`, `\"Unordered\"`, or `\"Init\"`');\n\t}\n\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');\n\t}\n\n\tif (IsDetachedBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1\n\t}\n\n\t// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.\n\n\tif (IsBigIntElementType(type) ? typeof value !== 'bigint' : typeof value !== 'number') { // step 3\n\t\tthrow new $TypeError('Assertion failed: `value` must be a BigInt if type is BigInt64 or BigUint64, otherwise a Number');\n\t}\n\n\t// 4. Let block be arrayBufferâ€™s [[ArrayBufferData]] internal slot.\n\n\tvar elementSize = tableTAO.size['$' + type]; // step 5\n\n\t// 6. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.\n\tvar isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 6\n\n\tvar rawBytes = NumericToRawBytes(type, value, isLittleEndian); // step 7\n\n\tif (isSAB) { // step 8\n\t\t/*\n\t\t\tLet execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n\t\t\tLet eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n\t\t\tIf isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.\n\t\t\tAppend WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.\n\t\t*/\n\t\tthrow new $SyntaxError('SharedArrayBuffer is not supported by this implementation');\n\t} else {\n\t\t// 9. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].\n\t\tvar arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);\n\t\tforEach(rawBytes, function (rawByte, i) {\n\t\t\tarr[i] = rawByte;\n\t\t});\n\t}\n\n\t// 10. Return NormalCompletion(undefined).\n};\n"
        }
    ]
}