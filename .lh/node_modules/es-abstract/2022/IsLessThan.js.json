{
    "sourceFile": "node_modules/es-abstract/2022/IsLessThan.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892152551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $TypeError = require('es-errors/type');\n\nvar $isNaN = require('math-intrinsics/isNaN');\n\nvar IsStringPrefix = require('./IsStringPrefix');\nvar StringToBigInt = require('./StringToBigInt');\nvar ToNumeric = require('./ToNumeric');\nvar ToPrimitive = require('./ToPrimitive');\n\nvar BigIntLessThan = require('./BigInt/lessThan');\nvar NumberLessThan = require('./Number/lessThan');\n\n// https://262.ecma-international.org/13.0/#sec-islessthan\n\n// eslint-disable-next-line max-statements, max-lines-per-function\nmodule.exports = function IsLessThan(x, y, LeftFirst) {\n\tif (typeof LeftFirst !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');\n\t}\n\tvar px;\n\tvar py;\n\tif (LeftFirst) {\n\t\tpx = ToPrimitive(x, $Number);\n\t\tpy = ToPrimitive(y, $Number);\n\t} else {\n\t\tpy = ToPrimitive(y, $Number);\n\t\tpx = ToPrimitive(x, $Number);\n\t}\n\n\tif (typeof px === 'string' && typeof py === 'string') {\n\t\tif (IsStringPrefix(py, px)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (IsStringPrefix(px, py)) {\n\t\t\treturn true;\n\t\t}\n\t\t/*\n\t\tc. Let k be the smallest non-negative integer such that the code unit at index k within px is different from the code unit at index k within py. (There must be such a k, for neither String is a prefix of the other.)\n\t\td. Let m be the integer that is the numeric value of the code unit at index k within px.\n\t\te. Let n be the integer that is the numeric value of the code unit at index k within py.\n\t\tf. If m < n, return true. Otherwise, return false.\n\t\t*/\n\t\treturn px < py; // both strings, neither a prefix of the other. shortcut for steps 3 c-f\n\t}\n\n\tvar nx;\n\tvar ny;\n\tif (typeof px === 'bigint' && typeof py === 'string') {\n\t\tny = StringToBigInt(py);\n\t\tif (typeof ny === 'undefined') {\n\t\t\treturn void undefined;\n\t\t}\n\t\treturn BigIntLessThan(px, ny);\n\t}\n\tif (typeof px === 'string' && typeof py === 'bigint') {\n\t\tnx = StringToBigInt(px);\n\t\tif (typeof nx === 'undefined') {\n\t\t\treturn void undefined;\n\t\t}\n\t\treturn BigIntLessThan(nx, py);\n\t}\n\n\tnx = ToNumeric(px);\n\tny = ToNumeric(py);\n\n\tif (typeof nx === typeof ny) {\n\t\treturn typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);\n\t}\n\n\tif ($isNaN(nx) || $isNaN(ny)) {\n\t\treturn void undefined;\n\t}\n\n\tif (nx === -Infinity || ny === Infinity) {\n\t\treturn true;\n\t}\n\tif (nx === Infinity || ny === -Infinity) {\n\t\treturn false;\n\t}\n\n\treturn nx < ny; // by now, these are both finite, and the same type\n};\n"
        }
    ]
}