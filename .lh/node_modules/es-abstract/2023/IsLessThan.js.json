{
    "sourceFile": "node_modules/es-abstract/2023/IsLessThan.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892166025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $Number = GetIntrinsic('%Number%');\nvar $TypeError = require('es-errors/type');\nvar min = require('math-intrinsics/min');\nvar $isNaN = require('math-intrinsics/isNaN');\n\nvar $charCodeAt = require('call-bound')('String.prototype.charCodeAt');\n\nvar StringToBigInt = require('./StringToBigInt');\nvar ToNumeric = require('./ToNumeric');\nvar ToPrimitive = require('./ToPrimitive');\n\nvar BigIntLessThan = require('./BigInt/lessThan');\nvar NumberLessThan = require('./Number/lessThan');\n\n// https://262.ecma-international.org/14.0/#sec-islessthan\n\n// eslint-disable-next-line max-statements, max-lines-per-function\nmodule.exports = function IsLessThan(x, y, LeftFirst) {\n\tif (typeof LeftFirst !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');\n\t}\n\tvar px;\n\tvar py;\n\tif (LeftFirst) {\n\t\tpx = ToPrimitive(x, $Number);\n\t\tpy = ToPrimitive(y, $Number);\n\t} else {\n\t\tpy = ToPrimitive(y, $Number);\n\t\tpx = ToPrimitive(x, $Number);\n\t}\n\n\tif (typeof px === 'string' && typeof py === 'string') { // step 3\n\t\t// a. Let lx be the length of px.\n\t\t// b. Let ly be the length of py.\n\t\t// c. For each integer i starting with 0 such that i < min(lx, ly), in ascending order, do\n\t\t// i. Let cx be the integer that is the numeric value of the code unit at index i within px.\n\t\t// ii. Let cy be the integer that is the numeric value of the code unit at index i within py.\n\t\t// iii. If cx < cy, return true.\n\t\t// iv. If cx > cy, return false.\n\t\t// d. If lx < ly, return true. Otherwise, return false.\n\n\t\tvar lx = px.length; // step 3.a\n\t\tvar ly = py.length; // step 3.b\n\t\tfor (var i = 0; i < min(lx, ly); i++) { // step 3.c\n\t\t\tvar cx = $charCodeAt(px, i); // step 3.c.i\n\t\t\tvar cy = $charCodeAt(py, i); // step 3.c.ii\n\t\t\tif (cx < cy) {\n\t\t\t\treturn true; // step 3.c.iii\n\t\t\t}\n\t\t\tif (cx > cy) {\n\t\t\t\treturn false; // step 3.c.iv\n\t\t\t}\n\t\t}\n\t\treturn lx < ly; // step 3.d\n\t}\n\n\tvar nx;\n\tvar ny;\n\tif (typeof px === 'bigint' && typeof py === 'string') {\n\t\tny = StringToBigInt(py);\n\t\tif (typeof ny === 'undefined') {\n\t\t\treturn void undefined;\n\t\t}\n\t\treturn BigIntLessThan(px, ny);\n\t}\n\tif (typeof px === 'string' && typeof py === 'bigint') {\n\t\tnx = StringToBigInt(px);\n\t\tif (typeof nx === 'undefined') {\n\t\t\treturn void undefined;\n\t\t}\n\t\treturn BigIntLessThan(nx, py);\n\t}\n\n\tnx = ToNumeric(px);\n\tny = ToNumeric(py);\n\n\tif (typeof nx === typeof ny) {\n\t\treturn typeof nx === 'number' ? NumberLessThan(nx, ny) : BigIntLessThan(nx, ny);\n\t}\n\n\tif ($isNaN(nx) || $isNaN(ny)) {\n\t\treturn void undefined;\n\t}\n\n\tif (nx === -Infinity || ny === Infinity) {\n\t\treturn true;\n\t}\n\tif (nx === Infinity || ny === -Infinity) {\n\t\treturn false;\n\t}\n\n\treturn nx < ny; // by now, these are both finite, and the same type\n};\n"
        }
    ]
}