{
    "sourceFile": "node_modules/es-abstract/2015/SetValueInBuffer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892121644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = require('es-errors/type');\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\n\nvar isInteger = require('math-intrinsics/isInteger');\n\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\nvar ToInt16 = require('./ToInt16');\nvar ToInt32 = require('./ToInt32');\nvar ToInt8 = require('./ToInt8');\nvar ToUint16 = require('./ToUint16');\nvar ToUint32 = require('./ToUint32');\nvar ToUint8 = require('./ToUint8');\nvar ToUint8Clamp = require('./ToUint8Clamp');\n\nvar isArrayBuffer = require('is-array-buffer');\nvar hasOwn = require('hasown');\n\nvar tableTAO = require('./tables/typed-array-objects');\n\nvar TypeToAO = {\n\t__proto__: null,\n\t$Int8: ToInt8,\n\t$Uint8: ToUint8,\n\t$Uint8C: ToUint8Clamp,\n\t$Int16: ToInt16,\n\t$Uint16: ToUint16,\n\t$Int32: ToInt32,\n\t$Uint32: ToUint32\n};\n\nvar defaultEndianness = require('../helpers/defaultEndianness');\nvar forEach = require('../helpers/forEach');\nvar integerToNBytes = require('../helpers/integerToNBytes');\nvar valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');\nvar valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');\n\n// https://262.ecma-international.org/6.0/#sec-setvalueinbuffer\n\nmodule.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value) {\n\tif (!isArrayBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');\n\t}\n\n\tif (!isInteger(byteIndex)) {\n\t\tthrow new $TypeError('Assertion failed: `byteIndex` must be an integer');\n\t}\n\n\tif (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {\n\t\tthrow new $TypeError('Assertion failed: `type` must be a Typed Array Element Type');\n\t}\n\n\tif (typeof value !== 'number') {\n\t\tthrow new $TypeError('Assertion failed: `value` must be a number');\n\t}\n\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');\n\t}\n\n\tif (IsDetachedBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1\n\t}\n\n\t// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.\n\n\tif (byteIndex < 0) {\n\t\tthrow new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3\n\t}\n\n\t// 4. Assert: Type(value) is Number.\n\n\t// 5. Let block be arrayBufferâ€™s [[ArrayBufferData]] internal slot.\n\n\t// 6. Assert: block is not undefined.\n\n\tvar elementSize = tableTAO.size['$' + type]; // step 7\n\tif (!elementSize) {\n\t\tthrow new $TypeError('Assertion failed: `type` must be one of \"Int8\", \"Uint8\", \"Uint8C\", \"Int16\", \"Uint16\", \"Int32\", \"Uint32\", \"Float32\", or \"Float64\"');\n\t}\n\n\t// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.\n\tvar isLittleEndian = arguments.length > 4 ? arguments[4] : defaultEndianness === 'little'; // step 8\n\n\tvar rawBytes;\n\tif (type === 'Float32') { // step 1\n\t\trawBytes = valueToFloat32Bytes(value, isLittleEndian);\n\t} else if (type === 'Float64') { // step 2\n\t\trawBytes = valueToFloat64Bytes(value, isLittleEndian);\n\t} else {\n\t\tvar n = elementSize; // step 3.a\n\n\t\tvar convOp = TypeToAO['$' + type]; // step 3.b\n\n\t\tvar intValue = convOp(value); // step 3.c\n\n\t\trawBytes = integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4\n\t}\n\n\t// 12. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].\n\tvar arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);\n\tforEach(rawBytes, function (rawByte, i) {\n\t\tarr[i] = rawByte;\n\t});\n\n\t// 13. Return NormalCompletion(undefined).\n};\n"
        }
    ]
}