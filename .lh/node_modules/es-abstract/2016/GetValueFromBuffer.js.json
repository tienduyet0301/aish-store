{
    "sourceFile": "node_modules/es-abstract/2016/GetValueFromBuffer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892123353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = require('es-errors/type');\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\n\nvar isInteger = require('math-intrinsics/isInteger');\nvar callBound = require('call-bound');\n\nvar $charAt = callBound('String.prototype.charAt');\nvar $reverse = callBound('Array.prototype.reverse');\nvar $slice = callBound('Array.prototype.slice');\n\nvar bytesAsFloat32 = require('../helpers/bytesAsFloat32');\nvar bytesAsFloat64 = require('../helpers/bytesAsFloat64');\nvar bytesAsInteger = require('../helpers/bytesAsInteger');\nvar defaultEndianness = require('../helpers/defaultEndianness');\n\nvar IsDetachedBuffer = require('./IsDetachedBuffer');\n\nvar isArrayBuffer = require('is-array-buffer');\nvar safeConcat = require('safe-array-concat');\n\nvar tableTAO = require('./tables/typed-array-objects');\n\nvar isUnsignedElementType = function isUnsignedElementType(type) { return $charAt(type, 0) === 'U'; };\n\n// https://262.ecma-international.org/6.0/#sec-getvaluefrombuffer\n\nmodule.exports = function GetValueFromBuffer(arrayBuffer, byteIndex, type) {\n\tif (!isArrayBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');\n\t}\n\n\tif (!isInteger(byteIndex)) {\n\t\tthrow new $TypeError('Assertion failed: `byteIndex` must be an integer');\n\t}\n\n\tif (typeof type !== 'string') {\n\t\tthrow new $TypeError('Assertion failed: `type` must be a string');\n\t}\n\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean') {\n\t\tthrow new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');\n\t}\n\n\tif (IsDetachedBuffer(arrayBuffer)) {\n\t\tthrow new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1\n\t}\n\n\t// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.\n\n\tif (byteIndex < 0) {\n\t\tthrow new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3\n\t}\n\n\t// 4. Let block be arrayBufferâ€™s [[ArrayBufferData]] internal slot.\n\n\tvar elementSize = tableTAO.size['$' + type]; // step 5\n\tif (!elementSize) {\n\t\tthrow new $TypeError('Assertion failed: `type` must be one of \"Int8\", \"Uint8\", \"Uint8C\", \"Int16\", \"Uint16\", \"Int32\", \"Uint32\", \"Float32\", or \"Float64\"');\n\t}\n\n\t// 6. Let rawValue be a List of elementSize containing, in order, the elementSize sequence of bytes starting with block[byteIndex].\n\tvar rawValue = $slice(new $Uint8Array(arrayBuffer, byteIndex), 0, elementSize); // step 6\n\n\t// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation.\n\tvar isLittleEndian = arguments.length > 3 ? arguments[3] : defaultEndianness === 'little'; // step 7\n\n\tif (!isLittleEndian) {\n\t\t$reverse(rawValue); // step 8\n\t}\n\n\tvar bytes = $slice(safeConcat([0, 0, 0, 0, 0, 0, 0, 0], rawValue), -elementSize);\n\n\tif (type === 'Float32') { // step 3\n\t\treturn bytesAsFloat32(bytes);\n\t}\n\n\tif (type === 'Float64') { // step 4\n\t\treturn bytesAsFloat64(bytes);\n\t}\n\n\treturn bytesAsInteger(bytes, elementSize, isUnsignedElementType(type), false);\n};\n"
        }
    ]
}