{
    "sourceFile": "node_modules/es-abstract/helpers/valueToFloat64Bytes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892188674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $parseInt = GetIntrinsic('%parseInt%');\nvar $abs = require('math-intrinsics/abs');\nvar $floor = require('math-intrinsics/floor');\nvar isNegativeZero = require('math-intrinsics/isNegativeZero');\n\nvar callBound = require('call-bound');\n\nvar $strIndexOf = callBound('String.prototype.indexOf');\nvar $strSlice = callBound('String.prototype.slice');\n\nvar fractionToBitString = require('../helpers/fractionToBinaryString');\nvar intToBinString = require('../helpers/intToBinaryString');\n\nvar float64bias = 1023;\n\nvar elevenOnes = '11111111111';\nvar elevenZeroes = '00000000000';\nvar fiftyOneZeroes = elevenZeroes + elevenZeroes + elevenZeroes + elevenZeroes + '0000000';\n\n// IEEE 754-1985\nmodule.exports = function valueToFloat64Bytes(value, isLittleEndian) {\n\tvar signBit = value < 0 || isNegativeZero(value) ? '1' : '0';\n\tvar exponentBits;\n\tvar significandBits;\n\n\tif (isNaN(value)) {\n\t\texponentBits = elevenOnes;\n\t\tsignificandBits = '1' + fiftyOneZeroes;\n\t} else if (!isFinite(value)) {\n\t\texponentBits = elevenOnes;\n\t\tsignificandBits = '0' + fiftyOneZeroes;\n\t} else if (value === 0) {\n\t\texponentBits = elevenZeroes;\n\t\tsignificandBits = '0' + fiftyOneZeroes;\n\t} else {\n\t\tvalue = $abs(value); // eslint-disable-line no-param-reassign\n\n\t\t// Isolate the integer part (digits before the decimal):\n\t\tvar integerPart = $floor(value);\n\n\t\tvar intBinString = intToBinString(integerPart); // bit string for integer part\n\t\tvar fracBinString = fractionToBitString(value - integerPart); // bit string for fractional part\n\n\t\tvar numberOfBits;\n\t\t// find exponent needed to normalize integer+fractional parts\n\t\tif (intBinString) {\n\t\t\texponentBits = intBinString.length - 1; // move the decimal to the left\n\t\t} else {\n\t\t\tvar first1 = $strIndexOf(fracBinString, '1');\n\t\t\tif (first1 > -1) {\n\t\t\t\tnumberOfBits = first1 + 1;\n\t\t\t}\n\t\t\texponentBits = -numberOfBits; // move the decimal to the right\n\t\t}\n\n\t\tsignificandBits = intBinString + fracBinString;\n\t\tif (exponentBits < 0) {\n\t\t\t// subnormals\n\t\t\tif (exponentBits <= -float64bias) {\n\t\t\t\tnumberOfBits = float64bias - 1; // limit number of removed bits\n\t\t\t}\n\t\t\tsignificandBits = $strSlice(significandBits, numberOfBits); // remove all leading 0s and the first 1 for normal values; for subnormals, remove up to `float64bias - 1` leading bits\n\t\t} else {\n\t\t\tsignificandBits = $strSlice(significandBits, 1); // remove the leading '1' (implicit/hidden bit)\n\t\t}\n\t\texponentBits = $strSlice(elevenZeroes + intToBinString(exponentBits + float64bias), -11); // Convert the exponent to a bit string\n\n\t\tsignificandBits = $strSlice(significandBits + fiftyOneZeroes + '0', 0, 52); // fill in any trailing zeros and ensure we have only 52 fraction bits\n\t}\n\n\tvar bits = signBit + exponentBits + significandBits;\n\tvar rawBytes = [];\n\tfor (var i = 0; i < 8; i++) {\n\t\tvar targetIndex = isLittleEndian ? 8 - i - 1 : i;\n\t\trawBytes[targetIndex] = $parseInt($strSlice(bits, i * 8, (i + 1) * 8), 2);\n\t}\n\n\treturn rawBytes;\n};\n"
        }
    ]
}