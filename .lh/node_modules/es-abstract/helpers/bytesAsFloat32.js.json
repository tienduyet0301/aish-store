{
    "sourceFile": "node_modules/es-abstract/helpers/bytesAsFloat32.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892184544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar $pow = require('math-intrinsics/pow');\n\nmodule.exports = function bytesAsFloat32(rawBytes) {\n\t// return new $Float32Array(new $Uint8Array(rawBytes).buffer)[0];\n\n\t/*\n        Let value be the byte elements of rawBytes concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.\nIf value is an IEEE 754-2008 binary32 NaN value, return the NaN Number value.\nReturn the Number value that corresponds to value.\n        */\n\tvar sign = rawBytes[3] & 0x80 ? -1 : 1; // Check the sign bit\n\tvar exponent = ((rawBytes[3] & 0x7F) << 1)\n\t\t| (rawBytes[2] >> 7); // Combine bits for exponent\n\tvar mantissa = ((rawBytes[2] & 0x7F) << 16)\n\t\t| (rawBytes[1] << 8)\n\t\t| rawBytes[0]; // Combine bits for mantissa\n\n\tif (exponent === 0 && mantissa === 0) {\n\t\treturn sign === 1 ? 0 : -0;\n\t}\n\tif (exponent === 0xFF && mantissa === 0) {\n\t\treturn sign === 1 ? Infinity : -Infinity;\n\t}\n\tif (exponent === 0xFF && mantissa !== 0) {\n\t\treturn NaN;\n\t}\n\n\texponent -= 127; // subtract the bias\n\n\tif (exponent === -127) {\n\t\treturn sign * mantissa * $pow(2, -126 - 23);\n\t}\n\treturn sign * (1 + (mantissa * $pow(2, -23))) * $pow(2, exponent);\n};\n"
        }
    ]
}