{
    "sourceFile": "node_modules/es-iterator-helpers/test/Iterator.zipKeyed.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892199019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar defineProperties = require('define-properties');\nvar test = require('tape');\nvar callBind = require('call-bind');\nvar functionsHaveNames = require('functions-have-names')();\nvar forEach = require('for-each');\nvar debug = require('object-inspect');\nvar v = require('es-value-fixtures');\nvar hasSymbols = require('has-symbols/shams')();\nvar mockProperty = require('mock-property');\n\nvar index = require('../Iterator.zipKeyed');\nvar impl = require('../Iterator.zipKeyed/implementation');\nvar from = require('../Iterator.from/polyfill')();\n\nvar testIterator = require('./helpers/testIterator');\n\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = {\n\ttests: function (zipKeyed, name, t) {\n\t\tt['throws'](\n\t\t\tfunction () { return new zipKeyed(); }, // eslint-disable-line new-cap\n\t\t\tTypeError,\n\t\t\t'`' + name + '` itself is not a constructor'\n\t\t);\n\t\tt['throws'](\n\t\t\tfunction () { return new zipKeyed({}); }, // eslint-disable-line new-cap\n\t\t\tTypeError,\n\t\t\t'`' + name + '` itself is not a constructor, with an argument'\n\t\t);\n\n\t\tforEach(v.primitives, function (primitive) {\n\t\t\tt['throws'](\n\t\t\t\tfunction () { zipKeyed(primitive); },\n\t\t\t\tTypeError,\n\t\t\t\tdebug(primitive) + ' is not an Object'\n\t\t\t);\n\t\t\tif (primitive != null) {\n\t\t\t\tt['throws'](\n\t\t\t\t\tfunction () { zipKeyed({ a: primitive }); },\n\t\t\t\t\tTypeError,\n\t\t\t\t\t'key \"a\" on iterables object is ' + debug(primitive) + ' which is not an iterable Object'\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tforEach(v.objects, function (nonIterator) {\n\t\t\tt.doesNotThrow(function () { zipKeyed({ a: nonIterator }); }, 'does not throw until `.next()`');\n\n\t\t\tt['throws'](\n\t\t\t\tfunction () { zipKeyed({ a: nonIterator }).next(); },\n\t\t\t\tTypeError,\n\t\t\t\t'key \"a\" on iterables object is ' + debug(nonIterator) + ' which is not an iterable Object'\n\t\t\t);\n\t\t});\n\n\t\tt.test('actual iteration', { skip: !hasSymbols }, function (st) {\n\t\t\tforEach(v.nonFunctions, function (nonFunction) {\n\t\t\t\tif (nonFunction != null) {\n\t\t\t\t\tvar badIterable = {};\n\t\t\t\t\tbadIterable[Symbol.iterator] = nonFunction;\n\t\t\t\t\tst['throws'](\n\t\t\t\t\t\tfunction () { zipKeyed({ a: [], b: badIterable, c: [] }).next(); },\n\t\t\t\t\t\tTypeError,\n\t\t\t\t\t\t'key \"b\" on iterables object is ' + debug(badIterable) + ' is not a function'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tforEach(v.strings, function (string) {\n\t\t\t\tst['throws'](\n\t\t\t\t\tfunction () { zipKeyed({ a: string }); },\n\t\t\t\t\tTypeError,\n\t\t\t\t\t'key \"a\" on iterables object is an iterable primitive, but non-objects are not considered iterable'\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tst.test('real iterators', { skip: !hasSymbols }, function (s2t) {\n\t\t\t\tvar iter = [['a', 1], ['b', 2]][Symbol.iterator]();\n\t\t\t\tvar iterator = zipKeyed({ a: iter, b: ['a', 3], c: ['b', 4] });\n\n\t\t\t\ttestIterator(\n\t\t\t\t\titerator,\n\t\t\t\t\t[\n\t\t\t\t\t\t{ __proto__: null, a: ['a', 1], b: 'a', c: 'b' },\n\t\t\t\t\t\t{ __proto__: null, a: ['b', 2], b: 3, c: 4 }\n\t\t\t\t\t],\n\t\t\t\t\ts2t,\n\t\t\t\t\t'array iterator + array yields combined results'\n\t\t\t\t);\n\n\t\t\t\ts2t.end();\n\t\t\t});\n\n\t\t\tst.test('observability in a replaced String iterator', function (s2t) {\n\t\t\t\tvar originalStringIterator = String.prototype[Symbol.iterator];\n\t\t\t\tvar observedType;\n\t\t\t\ts2t.teardown(mockProperty(String.prototype, Symbol.iterator, {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\t'use strict'; // eslint-disable-line strict, lines-around-directive\n\n\t\t\t\t\t\tobservedType = typeof this;\n\t\t\t\t\t\treturn originalStringIterator;\n\t\t\t\t\t}\n\t\t\t\t}));\n\n\t\t\t\tzipKeyed([from('')]);\n\t\t\t\ts2t.equal(observedType, 'string', 'string primitive -> primitive receiver in Symbol.iterator getter');\n\t\t\t\tzipKeyed([from(Object(''))]);\n\t\t\t\ts2t.equal(observedType, 'object', 'boxed string -> boxed string in Symbol.iterator getter');\n\n\t\t\t\ts2t.end();\n\t\t\t});\n\n\t\t\tst.end();\n\t\t});\n\t},\n\tindex: function () {\n\t\ttest('Iterator.zipKeyed: index', function (t) {\n\t\t\tmodule.exports.tests(index, 'Iterator.zipKeyed', t);\n\n\t\t\tt.end();\n\t\t});\n\t},\n\timplementation: function () {\n\t\ttest('Iterator.zipKeyed: implementation', function (t) {\n\t\t\tmodule.exports.tests(impl, 'Iterator.zipKeyed', t);\n\n\t\t\tt.end();\n\t\t});\n\t},\n\tshimmed: function () {\n\t\ttest('Iterator.zipKeyed: shimmed', function (t) {\n\t\t\tt.test('Function name', { skip: !functionsHaveNames }, function (st) {\n\t\t\t\tst.equal(Iterator.zipKeyed.name, 'zipKeyed', 'Iterator.zipKeyed has name \"zipKeyed\"');\n\t\t\t\tst.end();\n\t\t\t});\n\n\t\t\tt.test('enumerability', { skip: !defineProperties.supportsDescriptors }, function (et) {\n\t\t\t\tet.equal(false, isEnumerable.call(Iterator, 'zipKeyed'), 'Iterator.zipKeyed is not enumerable');\n\t\t\t\tet.end();\n\t\t\t});\n\n\t\t\tmodule.exports.tests(callBind(Iterator.zipKeyed, Iterator), 'Iterator.zipKeyed', t);\n\n\t\t\tt.end();\n\t\t});\n\t}\n};\n"
        }
    ]
}