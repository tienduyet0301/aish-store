{
    "sourceFile": "node_modules/lightningcss/node/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892384333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { Angle, CssColor, Rule, CustomProperty, EnvironmentVariable, Function, Image, LengthValue, MediaQuery, Declaration, Ratio, Resolution, Selector, SupportsCondition, Time, Token, TokenOrValue, UnknownAtRule, Url, Variable, StyleRule, DeclarationBlock, ParsedComponent, Multiplier, StyleSheet, Location2 } from './ast';\nimport { Targets, Features } from './targets';\n\nexport * from './ast';\n\nexport { Targets, Features };\n\nexport interface TransformOptions<C extends CustomAtRules> {\n  /** The filename being transformed. Used for error messages and source maps. */\n  filename: string,\n  /** The source code to transform. */\n  code: Uint8Array,\n  /** Whether to enable minification. */\n  minify?: boolean,\n  /** Whether to output a source map. */\n  sourceMap?: boolean,\n  /** An input source map to extend. */\n  inputSourceMap?: string,\n  /**\n   * An optional project root path, used as the source root in the output source map.\n   * Also used to generate relative paths for sources used in CSS module hashes.\n   */\n  projectRoot?: string,\n  /** The browser targets for the generated code. */\n  targets?: Targets,\n  /** Features that should always be compiled, even when supported by targets. */\n  include?: number,\n  /** Features that should never be compiled, even when unsupported by targets. */\n  exclude?: number,\n  /** Whether to enable parsing various draft syntax. */\n  drafts?: Drafts,\n  /** Whether to enable various non-standard syntax. */\n  nonStandard?: NonStandard,\n  /** Whether to compile this file as a CSS module. */\n  cssModules?: boolean | CSSModulesConfig,\n  /**\n   * Whether to analyze dependencies (e.g. `@import` and `url()`).\n   * When enabled, `@import` rules are removed, and `url()` dependencies\n   * are replaced with hashed placeholders that can be replaced with the final\n   * urls later (after bundling). Dependencies are returned as part of the result.\n   */\n  analyzeDependencies?: boolean | DependencyOptions,\n  /**\n   * Replaces user action pseudo classes with class names that can be applied from JavaScript.\n   * This is useful for polyfills, for example.\n   */\n  pseudoClasses?: PseudoClasses,\n  /**\n   * A list of class names, ids, and custom identifiers (e.g. @keyframes) that are known\n   * to be unused. These will be removed during minification. Note that these are not\n   * selectors but individual names (without any . or # prefixes).\n   */\n  unusedSymbols?: string[],\n  /**\n   * Whether to ignore invalid rules and declarations rather than erroring.\n   * When enabled, warnings are returned, and the invalid rule or declaration is\n   * omitted from the output code.\n   */\n  errorRecovery?: boolean,\n  /**\n   * An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.\n   * Multiple visitors can be composed into one using the `composeVisitors` function.\n   * For optimal performance, visitors should be as specific as possible about what types of values\n   * they care about so that JavaScript has to be called as little as possible.\n   */\n  visitor?: Visitor<C>,\n  /**\n   * Defines how to parse custom CSS at-rules. Each at-rule can have a prelude, defined using a CSS\n   * [syntax string](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings), and\n   * a block body. The body can be a declaration list, rule list, or style block as defined in the\n   * [css spec](https://drafts.csswg.org/css-syntax/#declaration-rule-list).\n   */\n  customAtRules?: C\n}\n\n// This is a hack to make TS still provide autocomplete for `property` vs. just making it `string`.\ntype PropertyStart = '-' | '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';\nexport type ReturnedDeclaration = Declaration | {\n  /** The property name. */\n  property: `${PropertyStart}${string}`,\n  /** The raw string value for the declaration. */\n  raw: string\n};\n\nexport type ReturnedMediaQuery = MediaQuery | {\n  /** The raw string value for the media query. */\n  raw: string\n};\n\ntype FindByType<Union, Name> = Union extends { type: Name } ? Union : never;\nexport type ReturnedRule = Rule<ReturnedDeclaration, ReturnedMediaQuery>;\ntype RequiredValue<Rule> = Rule extends { value: object }\n  ? Rule['value'] extends StyleRule\n  ? Rule & { value: Required<StyleRule> & { declarations: Required<DeclarationBlock> } }\n  : Rule & { value: Required<Rule['value']> }\n  : Rule;\ntype RuleVisitor<R = RequiredValue<Rule>> = ((rule: R) => ReturnedRule | ReturnedRule[] | void);\ntype MappedRuleVisitors = {\n  [Name in Exclude<Rule['type'], 'unknown' | 'custom'>]?: RuleVisitor<RequiredValue<FindByType<Rule, Name>>>;\n}\n\ntype UnknownVisitors<T> = {\n  [name: string]: RuleVisitor<T>\n}\n\ntype CustomVisitors<T extends CustomAtRules> = {\n  [Name in keyof T]?: RuleVisitor<CustomAtRule<Name, T[Name]>>\n};\n\ntype AnyCustomAtRule<C extends CustomAtRules> = {\n  [Key in keyof C]: CustomAtRule<Key, C[Key]>\n}[keyof C];\n\ntype RuleVisitors<C extends CustomAtRules> = MappedRuleVisitors & {\n  unknown?: UnknownVisitors<UnknownAtRule> | Omit<RuleVisitor<UnknownAtRule>, keyof CallableFunction>,\n  custom?: CustomVisitors<C> | Omit<RuleVisitor<AnyCustomAtRule<C>>, keyof CallableFunction>\n};\n\ntype PreludeTypes = Exclude<ParsedComponent['type'], 'literal' | 'repeated' | 'token'>;\ntype SyntaxString = `<${PreludeTypes}>` | `<${PreludeTypes}>+` | `<${PreludeTypes}>#` | (string & {});\ntype ComponentTypes = {\n  [Key in PreludeTypes as `<${Key}>`]: FindByType<ParsedComponent, Key>\n};\n\ntype Repetitions = {\n  [Key in PreludeTypes as `<${Key}>+` | `<${Key}>#`]: {\n    type: \"repeated\",\n    value: {\n      components: FindByType<ParsedComponent, Key>[],\n      multiplier: Multiplier\n    }\n  }\n};\n\ntype MappedPrelude = ComponentTypes & Repetitions;\ntype MappedBody<P extends CustomAtRuleDefinition['body']> = P extends 'style-block' ? 'rule-list' : P;\ninterface CustomAtRule<N, R extends CustomAtRuleDefinition> {\n  name: N,\n  prelude: R['prelude'] extends keyof MappedPrelude ? MappedPrelude[R['prelude']] : ParsedComponent,\n  body: FindByType<CustomAtRuleBody, MappedBody<R['body']>>,\n  loc: Location2\n}\n\ntype CustomAtRuleBody = {\n  type: 'declaration-list',\n  value: Required<DeclarationBlock>\n} | {\n  type: 'rule-list',\n  value: RequiredValue<Rule>[]\n};\n\ntype FindProperty<Union, Name> = Union extends { property: Name } ? Union : never;\ntype DeclarationVisitor<P = Declaration> = ((property: P) => ReturnedDeclaration | ReturnedDeclaration[] | void);\ntype MappedDeclarationVisitors = {\n  [Name in Exclude<Declaration['property'], 'unparsed' | 'custom'>]?: DeclarationVisitor<FindProperty<Declaration, Name> | FindProperty<Declaration, 'unparsed'>>;\n}\n\ntype CustomPropertyVisitors = {\n  [name: string]: DeclarationVisitor<CustomProperty>\n}\n\ntype DeclarationVisitors = MappedDeclarationVisitors & {\n  custom?: CustomPropertyVisitors | DeclarationVisitor<CustomProperty>\n}\n\ninterface RawValue {\n  /** A raw string value which will be parsed like CSS. */\n  raw: string\n}\n\ntype TokenReturnValue = TokenOrValue | TokenOrValue[] | RawValue | void;\ntype TokenVisitor = (token: Token) => TokenReturnValue;\ntype VisitableTokenTypes = 'ident' | 'at-keyword' | 'hash' | 'id-hash' | 'string' | 'number' | 'percentage' | 'dimension';\ntype TokenVisitors = {\n  [Name in VisitableTokenTypes]?: (token: FindByType<Token, Name>) => TokenReturnValue;\n}\n\ntype FunctionVisitor = (fn: Function) => TokenReturnValue;\ntype EnvironmentVariableVisitor = (env: EnvironmentVariable) => TokenReturnValue;\ntype EnvironmentVariableVisitors = {\n  [name: string]: EnvironmentVariableVisitor\n};\n\nexport interface Visitor<C extends CustomAtRules> {\n  StyleSheet?(stylesheet: StyleSheet): StyleSheet<ReturnedDeclaration, ReturnedMediaQuery> | void;\n  StyleSheetExit?(stylesheet: StyleSheet): StyleSheet<ReturnedDeclaration, ReturnedMediaQuery> | void;\n  Rule?: RuleVisitor | RuleVisitors<C>;\n  RuleExit?: RuleVisitor | RuleVisitors<C>;\n  Declaration?: DeclarationVisitor | DeclarationVisitors;\n  DeclarationExit?: DeclarationVisitor | DeclarationVisitors;\n  Url?(url: Url): Url | void;\n  Color?(color: CssColor): CssColor | void;\n  Image?(image: Image): Image | void;\n  ImageExit?(image: Image): Image | void;\n  Length?(length: LengthValue): LengthValue | void;\n  Angle?(angle: Angle): Angle | void;\n  Ratio?(ratio: Ratio): Ratio | void;\n  Resolution?(resolution: Resolution): Resolution | void;\n  Time?(time: Time): Time | void;\n  CustomIdent?(ident: string): string | void;\n  DashedIdent?(ident: string): string | void;\n  MediaQuery?(query: MediaQuery): ReturnedMediaQuery | ReturnedMediaQuery[] | void;\n  MediaQueryExit?(query: MediaQuery): ReturnedMediaQuery | ReturnedMediaQuery[] | void;\n  SupportsCondition?(condition: SupportsCondition): SupportsCondition;\n  SupportsConditionExit?(condition: SupportsCondition): SupportsCondition;\n  Selector?(selector: Selector): Selector | Selector[] | void;\n  Token?: TokenVisitor | TokenVisitors;\n  Function?: FunctionVisitor | { [name: string]: FunctionVisitor };\n  FunctionExit?: FunctionVisitor | { [name: string]: FunctionVisitor };\n  Variable?(variable: Variable): TokenReturnValue;\n  VariableExit?(variable: Variable): TokenReturnValue;\n  EnvironmentVariable?: EnvironmentVariableVisitor | EnvironmentVariableVisitors;\n  EnvironmentVariableExit?: EnvironmentVariableVisitor | EnvironmentVariableVisitors;\n}\n\nexport interface CustomAtRules {\n  [name: string]: CustomAtRuleDefinition\n}\n\nexport interface CustomAtRuleDefinition {\n  /**\n   * Defines the syntax for a custom at-rule prelude. The value should be a\n   * CSS [syntax string](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings)\n   * representing the types of values that are accepted. This property may be omitted or\n   * set to null to indicate that no prelude is accepted.\n   */\n  prelude?: SyntaxString | null,\n  /**\n   * Defines the type of body contained within the at-rule block.\n   *   - declaration-list: A CSS declaration list, as in a style rule.\n   *   - rule-list: A list of CSS rules, as supported within a non-nested\n   *       at-rule such as `@media` or `@supports`.\n   *   - style-block: Both a declaration list and rule list, as accepted within\n   *       a nested at-rule within a style rule (e.g. `@media` inside a style rule\n   *       with directly nested declarations).\n   */\n  body?: 'declaration-list' | 'rule-list' | 'style-block' | null\n}\n\nexport interface DependencyOptions {\n  /** Whether to preserve `@import` rules rather than removing them. */\n  preserveImports?: boolean\n}\n\nexport type BundleOptions<C extends CustomAtRules> = Omit<TransformOptions<C>, 'code'>;\n\nexport interface BundleAsyncOptions<C extends CustomAtRules> extends BundleOptions<C> {\n  resolver?: Resolver;\n}\n\n/** Custom resolver to use when loading CSS files. */\nexport interface Resolver {\n  /** Read the given file and return its contents as a string. */\n  read?: (file: string) => string | Promise<string>;\n\n  /**\n   * Resolve the given CSS import specifier from the provided originating file to a\n   * path which gets passed to `read()`.\n   */\n  resolve?: (specifier: string, originatingFile: string) => string | Promise<string>;\n}\n\nexport interface Drafts {\n  /** Whether to enable @custom-media rules. */\n  customMedia?: boolean\n}\n\nexport interface NonStandard {\n  /** Whether to enable the non-standard >>> and /deep/ selector combinators used by Angular and Vue. */\n  deepSelectorCombinator?: boolean\n}\n\nexport interface PseudoClasses {\n  hover?: string,\n  active?: string,\n  focus?: string,\n  focusVisible?: string,\n  focusWithin?: string\n}\n\nexport interface TransformResult {\n  /** The transformed code. */\n  code: Uint8Array,\n  /** The generated source map, if enabled. */\n  map: Uint8Array | void,\n  /** CSS module exports, if enabled. */\n  exports: CSSModuleExports | void,\n  /** CSS module references, if `dashedIdents` is enabled. */\n  references: CSSModuleReferences,\n  /** `@import` and `url()` dependencies, if enabled. */\n  dependencies: Dependency[] | void,\n  /** Warnings that occurred during compilation. */\n  warnings: Warning[]\n}\n\nexport interface Warning {\n  message: string,\n  type: string,\n  value?: any,\n  loc: ErrorLocation\n}\n\nexport interface CSSModulesConfig {\n  /** The pattern to use when renaming class names and other identifiers. Default is `[hash]_[local]`. */\n  pattern?: string,\n  /** Whether to rename dashed identifiers, e.g. custom properties. */\n  dashedIdents?: boolean,\n  /** Whether to enable hashing for `@keyframes`. */\n  animation?: boolean,\n  /** Whether to enable hashing for CSS grid identifiers. */\n  grid?: boolean,\n  /** Whether to enable hashing for `@container` names. */\n  container?: boolean,\n  /** Whether to enable hashing for custom identifiers. */\n  customIdents?: boolean,\n  /** Whether to require at least one class or id selector in each rule. */\n  pure?: boolean\n}\n\nexport type CSSModuleExports = {\n  /** Maps exported (i.e. original) names to local names. */\n  [name: string]: CSSModuleExport\n};\n\nexport interface CSSModuleExport {\n  /** The local (compiled) name for this export. */\n  name: string,\n  /** Whether the export is referenced in this file. */\n  isReferenced: boolean,\n  /** Other names that are composed by this export. */\n  composes: CSSModuleReference[]\n}\n\nexport type CSSModuleReferences = {\n  /** Maps placeholder names to references. */\n  [name: string]: DependencyCSSModuleReference,\n};\n\nexport type CSSModuleReference = LocalCSSModuleReference | GlobalCSSModuleReference | DependencyCSSModuleReference;\n\nexport interface LocalCSSModuleReference {\n  type: 'local',\n  /** The local (compiled) name for the reference. */\n  name: string,\n}\n\nexport interface GlobalCSSModuleReference {\n  type: 'global',\n  /** The referenced global name. */\n  name: string,\n}\n\nexport interface DependencyCSSModuleReference {\n  type: 'dependency',\n  /** The name to reference within the dependency. */\n  name: string,\n  /** The dependency specifier for the referenced file. */\n  specifier: string\n}\n\nexport type Dependency = ImportDependency | UrlDependency;\n\nexport interface ImportDependency {\n  type: 'import',\n  /** The url of the `@import` dependency. */\n  url: string,\n  /** The media query for the `@import` rule. */\n  media: string | null,\n  /** The `supports()` query for the `@import` rule. */\n  supports: string | null,\n  /** The source location where the `@import` rule was found. */\n  loc: SourceLocation,\n  /** The placeholder that the import was replaced with. */\n  placeholder: string\n}\n\nexport interface UrlDependency {\n  type: 'url',\n  /** The url of the dependency. */\n  url: string,\n  /** The source location where the `url()` was found. */\n  loc: SourceLocation,\n  /** The placeholder that the url was replaced with. */\n  placeholder: string\n}\n\nexport interface SourceLocation {\n  /** The file path in which the dependency exists. */\n  filePath: string,\n  /** The start location of the dependency. */\n  start: Location,\n  /** The end location (inclusive) of the dependency. */\n  end: Location\n}\n\nexport interface Location {\n  /** The line number (1-based). */\n  line: number,\n  /** The column number (0-based). */\n  column: number\n}\n\nexport interface ErrorLocation extends Location {\n  filename: string\n}\n\n/**\n * Compiles a CSS file, including optionally minifying and lowering syntax to the given\n * targets. A source map may also be generated, but this is not enabled by default.\n */\nexport declare function transform<C extends CustomAtRules>(options: TransformOptions<C>): TransformResult;\n\nexport interface TransformAttributeOptions {\n  /** The filename in which the style attribute appeared. Used for error messages and dependencies. */\n  filename?: string,\n  /** The source code to transform. */\n  code: Uint8Array,\n  /** Whether to enable minification. */\n  minify?: boolean,\n  /** The browser targets for the generated code. */\n  targets?: Targets,\n  /**\n   * Whether to analyze `url()` dependencies.\n   * When enabled, `url()` dependencies are replaced with hashed placeholders\n   * that can be replaced with the final urls later (after bundling).\n   * Dependencies are returned as part of the result.\n   */\n  analyzeDependencies?: boolean,\n  /**\n   * Whether to ignore invalid rules and declarations rather than erroring.\n   * When enabled, warnings are returned, and the invalid rule or declaration is\n   * omitted from the output code.\n   */\n  errorRecovery?: boolean,\n  /**\n   * An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.\n   * Multiple visitors can be composed into one using the `composeVisitors` function.\n   * For optimal performance, visitors should be as specific as possible about what types of values\n   * they care about so that JavaScript has to be called as little as possible.\n   */\n  visitor?: Visitor<never>\n}\n\nexport interface TransformAttributeResult {\n  /** The transformed code. */\n  code: Uint8Array,\n  /** `@import` and `url()` dependencies, if enabled. */\n  dependencies: Dependency[] | void,\n  /** Warnings that occurred during compilation. */\n  warnings: Warning[]\n}\n\n/**\n * Compiles a single CSS declaration list, such as an inline style attribute in HTML.\n */\nexport declare function transformStyleAttribute(options: TransformAttributeOptions): TransformAttributeResult;\n\n/**\n * Converts a browserslist result into targets that can be passed to lightningcss.\n * @param browserslist the result of calling `browserslist`\n */\nexport declare function browserslistToTargets(browserslist: string[]): Targets;\n\n/**\n * Bundles a CSS file and its dependencies, inlining @import rules.\n */\nexport declare function bundle<C extends CustomAtRules>(options: BundleOptions<C>): TransformResult;\n\n/**\n * Bundles a CSS file and its dependencies asynchronously, inlining @import rules.\n */\nexport declare function bundleAsync<C extends CustomAtRules>(options: BundleAsyncOptions<C>): Promise<TransformResult>;\n\n/**\n * Composes multiple visitor objects into a single one.\n */\nexport declare function composeVisitors<C extends CustomAtRules>(visitors: Visitor<C>[]): Visitor<C>;\n"
        }
    ]
}