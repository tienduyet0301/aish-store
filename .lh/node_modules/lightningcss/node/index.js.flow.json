{
    "sourceFile": "node_modules/lightningcss/node/index.js.flow",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892384406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// @flow\n\ntype Exclude<A, B> = A;\n// see https://gist.github.com/thecotne/6e5969f4aaf8f253985ed36b30ac9fe0\ntype $FlowGen$If<X: boolean, Then, Else = empty> = $Call<\n  ((true, Then, Else) => Then) & ((false, Then, Else) => Else),\n  X,\n  Then,\n  Else\n>;\n\ntype $FlowGen$Assignable<A, B> = $Call<\n  ((...r: [B]) => true) & ((...r: [A]) => false),\n  A\n>;\n\nimport type {\n  Angle,\n  CssColor,\n  Rule,\n  CustomProperty,\n  EnvironmentVariable,\n  Function,\n  Image,\n  LengthValue,\n  MediaQuery,\n  Declaration,\n  Ratio,\n  Resolution,\n  Selector,\n  SupportsCondition,\n  Time,\n  Token,\n  TokenOrValue,\n  UnknownAtRule,\n  Url,\n  Variable,\n  StyleRule,\n  DeclarationBlock,\n  ParsedComponent,\n  Multiplier,\n  StyleSheet,\n  Location2,\n} from \"./ast.js.flow\";\nimport { Targets, Features } from \"./targets.js.flow\";\ndeclare export * from \"./ast.js.flow\";\ndeclare export { Targets, Features };\nexport type TransformOptions<C: CustomAtRules> = {|\n  /**\n   * The filename being transformed. Used for error messages and source maps.\n   */\n  filename: string,\n\n  /**\n   * The source code to transform.\n   */\n  code: Uint8Array,\n\n  /**\n   * Whether to enable minification.\n   */\n  minify?: boolean,\n\n  /**\n   * Whether to output a source map.\n   */\n  sourceMap?: boolean,\n\n  /**\n   * An input source map to extend.\n   */\n  inputSourceMap?: string,\n\n  /**\n   * An optional project root path, used as the source root in the output source map.\n   * Also used to generate relative paths for sources used in CSS module hashes.\n   */\n  projectRoot?: string,\n\n  /**\n   * The browser targets for the generated code.\n   */\n  targets?: Targets,\n\n  /**\n   * Features that should always be compiled, even when supported by targets.\n   */\n  include?: number,\n\n  /**\n   * Features that should never be compiled, even when unsupported by targets.\n   */\n  exclude?: number,\n\n  /**\n   * Whether to enable parsing various draft syntax.\n   */\n  drafts?: Drafts,\n\n  /**\n   * Whether to enable various non-standard syntax.\n   */\n  nonStandard?: NonStandard,\n\n  /**\n   * Whether to compile this file as a CSS module.\n   */\n  cssModules?: boolean | CSSModulesConfig,\n\n  /**\n   * Whether to analyze dependencies (e.g. string).\n   * When enabled, string dependencies\n   * are replaced with hashed placeholders that can be replaced with the final\n   * urls later (after bundling). Dependencies are returned as part of the result.\n   */\n  analyzeDependencies?: boolean | DependencyOptions,\n\n  /**\n   * Replaces user action pseudo classes with class names that can be applied from JavaScript.\n   * This is useful for polyfills, for example.\n   */\n  pseudoClasses?: PseudoClasses,\n\n  /**\n   * A list of class names, ids, and custom identifiers (e.g. @keyframes) that are known\n   * to be unused. These will be removed during minification. Note that these are not\n   * selectors but individual names (without any . or # prefixes).\n   */\n  unusedSymbols?: string[],\n\n  /**\n   * Whether to ignore invalid rules and declarations rather than erroring.\n   * When enabled, warnings are returned, and the invalid rule or declaration is\n   * omitted from the output code.\n   */\n  errorRecovery?: boolean,\n\n  /**\n   * An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.\n   * Multiple visitors can be composed into one using the string function.\n   * For optimal performance, visitors should be as specific as possible about what types of values\n   * they care about so that JavaScript has to be called as little as possible.\n   */\n  visitor?: Visitor<C>,\n\n  /**\n   * Defines how to parse custom CSS at-rules. Each at-rule can have a prelude, defined using a CSS\n   * [syntax string](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings), and\n   * a block body. The body can be a declaration list, rule list, or style block as defined in the\n   * [css spec](https://drafts.csswg.org/css-syntax/#declaration-rule-list).\n   */\n  customAtRules?: C,\n|};\ndeclare type PropertyStart =\n  | \"-\"\n  | \"_\"\n  | \"a\"\n  | \"b\"\n  | \"c\"\n  | \"d\"\n  | \"e\"\n  | \"f\"\n  | \"g\"\n  | \"h\"\n  | \"i\"\n  | \"j\"\n  | \"k\"\n  | \"l\"\n  | \"m\"\n  | \"n\"\n  | \"o\"\n  | \"p\"\n  | \"q\"\n  | \"r\"\n  | \"s\"\n  | \"t\"\n  | \"u\"\n  | \"v\"\n  | \"w\"\n  | \"x\"\n  | \"y\"\n  | \"z\";\nexport type ReturnedDeclaration =\n  | Declaration\n  | {|\n      /**\n       * The property name.\n       */\n      property: string,\n\n      /**\n       * The raw string value for the declaration.\n       */\n      raw: string,\n    |};\nexport type ReturnedMediaQuery =\n  | MediaQuery\n  | {|\n      /**\n       * The raw string value for the media query.\n       */\n      raw: string,\n    |};\ndeclare type FindByType<Union, Name> = $FlowGen$If<\n  $FlowGen$Assignable<\n    Union,\n    {|\n      type: Name,\n    |}\n  >,\n  Union,\n  empty\n>;\nexport type ReturnedRule = Rule<ReturnedDeclaration, ReturnedMediaQuery>;\ndeclare type RequiredValue<Rule> = $FlowGen$If<\n  $FlowGen$Assignable<\n    Rule,\n    {|\n      value: { [key: string]: any },\n    |}\n  >,\n  $FlowGen$If<\n    $FlowGen$Assignable<$PropertyType<Rule, \"value\">, StyleRule>,\n    {|\n      ...Rule,\n      ...{|\n        value: {|\n          ...Required<StyleRule>,\n          ...{|\n            declarations: Required<DeclarationBlock>,\n          |},\n        |},\n      |},\n    |},\n    {|\n      ...Rule,\n      ...{|\n        value: Required<$PropertyType<Rule, \"value\">>,\n      |},\n    |}\n  >,\n  Rule\n>;\ndeclare type RuleVisitor<R = RequiredValue<Rule>> = (\n  rule: R\n) => ReturnedRule | ReturnedRule[] | void;\ndeclare type MappedRuleVisitors = $ObjMapi<\n  { [k: Exclude<$PropertyType<Rule, \"type\">, \"unknown\" | \"custom\">]: any },\n  <Name>(Name) => RuleVisitor<RequiredValue<FindByType<Rule, Name>>>\n>;\ndeclare type UnknownVisitors<T> = {\n  [name: string]: RuleVisitor<T>,\n};\ndeclare type CustomVisitors<T: CustomAtRules> = $ObjMapi<\n  T,\n  <Name>(Name) => RuleVisitor<CustomAtRule<Name, $ElementType<T, Name>>>\n>;\ndeclare type AnyCustomAtRule<C: CustomAtRules> = $ElementType<\n  $ObjMapi<C, <Key>(Key) => CustomAtRule<Key, $ElementType<C, Key>>>,\n  $Keys<C>\n>;\ndeclare type RuleVisitors<C: CustomAtRules> = {|\n  ...MappedRuleVisitors,\n  ...{|\n    unknown?:\n      | UnknownVisitors<UnknownAtRule>\n      | $Diff<\n          RuleVisitor<UnknownAtRule>,\n          { [key: $Keys<CallableFunction>]: any }\n        >,\n    custom?:\n      | CustomVisitors<C>\n      | $Diff<\n          RuleVisitor<AnyCustomAtRule<C>>,\n          { [key: $Keys<CallableFunction>]: any }\n        >,\n  |},\n|};\ndeclare type PreludeTypes = Exclude<\n  $PropertyType<ParsedComponent, \"type\">,\n  \"literal\" | \"repeated\" | \"token\"\n>;\ndeclare type SyntaxString = string | string;\ndeclare type ComponentTypes = $ObjMapi<\n  { [k: PreludeTypes]: any },\n  <Key>(Key) => FindByType<ParsedComponent, Key>\n>;\ndeclare type Repetitions = $ObjMapi<\n  { [k: PreludeTypes]: any },\n  <Key>(Key) => {|\n    type: \"repeated\",\n    value: {|\n      components: FindByType<ParsedComponent, Key>[],\n      multiplier: Multiplier,\n    |},\n  |}\n>;\ndeclare type MappedPrelude = {| ...ComponentTypes, ...Repetitions |};\ndeclare type MappedBody<P: $PropertyType<CustomAtRuleDefinition, \"body\">> =\n  $FlowGen$If<$FlowGen$Assignable<P, \"style-block\">, \"rule-list\", P>;\ndeclare type CustomAtRule<N, R: CustomAtRuleDefinition> = {|\n  name: N,\n  prelude: $FlowGen$If<\n    $FlowGen$Assignable<$PropertyType<R, \"prelude\">, $Keys<MappedPrelude>>,\n    $ElementType<MappedPrelude, $PropertyType<R, \"prelude\">>,\n    ParsedComponent\n  >,\n  body: FindByType<CustomAtRuleBody, MappedBody<$PropertyType<R, \"body\">>>,\n  loc: Location2,\n|};\ndeclare type CustomAtRuleBody =\n  | {|\n      type: \"declaration-list\",\n      value: Required<DeclarationBlock>,\n    |}\n  | {|\n      type: \"rule-list\",\n      value: RequiredValue<Rule>[],\n    |};\ndeclare type FindProperty<Union, Name> = $FlowGen$If<\n  $FlowGen$Assignable<\n    Union,\n    {|\n      property: Name,\n    |}\n  >,\n  Union,\n  empty\n>;\ndeclare type DeclarationVisitor<P = Declaration> = (\n  property: P\n) => ReturnedDeclaration | ReturnedDeclaration[] | void;\ndeclare type MappedDeclarationVisitors = $ObjMapi<\n  {\n    [k: Exclude<\n      $PropertyType<Declaration, \"property\">,\n      \"unparsed\" | \"custom\"\n    >]: any,\n  },\n  <Name>(\n    Name\n  ) => DeclarationVisitor<\n    FindProperty<Declaration, Name> | FindProperty<Declaration, \"unparsed\">\n  >\n>;\ndeclare type CustomPropertyVisitors = {\n  [name: string]: DeclarationVisitor<CustomProperty>,\n};\ndeclare type DeclarationVisitors = {|\n  ...MappedDeclarationVisitors,\n  ...{|\n    custom?: CustomPropertyVisitors | DeclarationVisitor<CustomProperty>,\n  |},\n|};\ndeclare type RawValue = {|\n  /**\n   * A raw string value which will be parsed like CSS.\n   */\n  raw: string,\n|};\ndeclare type TokenReturnValue = TokenOrValue | TokenOrValue[] | RawValue | void;\ndeclare type TokenVisitor = (token: Token) => TokenReturnValue;\ndeclare type VisitableTokenTypes =\n  | \"ident\"\n  | \"at-keyword\"\n  | \"hash\"\n  | \"id-hash\"\n  | \"string\"\n  | \"number\"\n  | \"percentage\"\n  | \"dimension\";\ndeclare type TokenVisitors = $ObjMapi<\n  { [k: VisitableTokenTypes]: any },\n  <Name>(Name) => (token: FindByType<Token, Name>) => TokenReturnValue\n>;\ndeclare type FunctionVisitor = (fn: Function) => TokenReturnValue;\ndeclare type EnvironmentVariableVisitor = (\n  env: EnvironmentVariable\n) => TokenReturnValue;\ndeclare type EnvironmentVariableVisitors = {\n  [name: string]: EnvironmentVariableVisitor,\n};\nexport type Visitor<C: CustomAtRules> = {|\n  StyleSheet?: (\n    stylesheet: StyleSheet\n  ) => StyleSheet<ReturnedDeclaration, ReturnedMediaQuery> | void,\n  StyleSheetExit?: (\n    stylesheet: StyleSheet\n  ) => StyleSheet<ReturnedDeclaration, ReturnedMediaQuery> | void,\n  Rule?: RuleVisitor<> | RuleVisitors<C>,\n  RuleExit?: RuleVisitor<> | RuleVisitors<C>,\n  Declaration?: DeclarationVisitor<> | DeclarationVisitors,\n  DeclarationExit?: DeclarationVisitor<> | DeclarationVisitors,\n  Url?: (url: Url) => Url | void,\n  Color?: (color: CssColor) => CssColor | void,\n  Image?: (image: Image) => Image | void,\n  ImageExit?: (image: Image) => Image | void,\n  Length?: (length: LengthValue) => LengthValue | void,\n  Angle?: (angle: Angle) => Angle | void,\n  Ratio?: (ratio: Ratio) => Ratio | void,\n  Resolution?: (resolution: Resolution) => Resolution | void,\n  Time?: (time: Time) => Time | void,\n  CustomIdent?: (ident: string) => string | void,\n  DashedIdent?: (ident: string) => string | void,\n  MediaQuery?: (\n    query: MediaQuery\n  ) => ReturnedMediaQuery | ReturnedMediaQuery[] | void,\n  MediaQueryExit?: (\n    query: MediaQuery\n  ) => ReturnedMediaQuery | ReturnedMediaQuery[] | void,\n  SupportsCondition?: (condition: SupportsCondition) => SupportsCondition,\n  SupportsConditionExit?: (condition: SupportsCondition) => SupportsCondition,\n  Selector?: (selector: Selector) => Selector | Selector[] | void,\n  Token?: TokenVisitor | TokenVisitors,\n  Function?:\n    | FunctionVisitor\n    | {\n        [name: string]: FunctionVisitor,\n      },\n  FunctionExit?:\n    | FunctionVisitor\n    | {\n        [name: string]: FunctionVisitor,\n      },\n  Variable?: (variable: Variable) => TokenReturnValue,\n  VariableExit?: (variable: Variable) => TokenReturnValue,\n  EnvironmentVariable?:\n    | EnvironmentVariableVisitor\n    | EnvironmentVariableVisitors,\n  EnvironmentVariableExit?:\n    | EnvironmentVariableVisitor\n    | EnvironmentVariableVisitors,\n|};\nexport type CustomAtRules = {|\n  [name: string]: CustomAtRuleDefinition,\n|};\nexport type CustomAtRuleDefinition = {|\n  /**\n   * Defines the syntax for a custom at-rule prelude. The value should be a\n   * CSS [syntax string](https://drafts.css-houdini.org/css-properties-values-api/#syntax-strings)\n   * representing the types of values that are accepted. This property may be omitted or\n   * set to null to indicate that no prelude is accepted.\n   */\n  prelude?: SyntaxString | null,\n\n  /**\n   * Defines the type of body contained within the at-rule block.\n   *   - declaration-list: A CSS declaration list, as in a style rule.\n   *   - rule-list: A list of CSS rules, as supported within a non-nested\n   *       at-rule such as string.\n   *   - style-block: Both a declaration list and rule list, as accepted within\n   *       a nested at-rule within a style rule (e.g. string inside a style rule\n   *       with directly nested declarations).\n   */\n  body?: \"declaration-list\" | \"rule-list\" | \"style-block\" | null,\n|};\nexport type DependencyOptions = {|\n  /**\n   * Whether to preserve string rules rather than removing them.\n   */\n  preserveImports?: boolean,\n|};\nexport type BundleOptions<C: CustomAtRules> = $Diff<\n  TransformOptions<C>,\n  {| code: any |}\n>;\nexport type BundleAsyncOptions<C: CustomAtRules> = {|\n  ...$Exact<BundleOptions<C>>,\n\n  resolver?: Resolver,\n|};\n\n/**\n * Custom resolver to use when loading CSS files.\n */\nexport type Resolver = {|\n  /**\n   * Read the given file and return its contents as a string.\n   */\n  read?: (file: string) => string | Promise<string>,\n\n  /**\n   * Resolve the given CSS import specifier from the provided originating file to a\n   * path which gets passed to string.\n   */\n  resolve?: (\n    specifier: string,\n    originatingFile: string\n  ) => string | Promise<string>,\n|};\nexport type Drafts = {|\n  /**\n   * Whether to enable @custom-media rules.\n   */\n  customMedia?: boolean,\n|};\nexport type NonStandard = {|\n  /**\n   * Whether to enable the non-standard >>> and /deep/ selector combinators used by Angular and Vue.\n   */\n  deepSelectorCombinator?: boolean,\n|};\nexport type PseudoClasses = {|\n  hover?: string,\n  active?: string,\n  focus?: string,\n  focusVisible?: string,\n  focusWithin?: string,\n|};\nexport type TransformResult = {|\n  /**\n   * The transformed code.\n   */\n  code: Uint8Array,\n\n  /**\n   * The generated source map, if enabled.\n   */\n  map: Uint8Array | void,\n\n  /**\n   * CSS module exports, if enabled.\n   */\n  exports: CSSModuleExports | void,\n\n  /**\n   * CSS module references, if string is enabled.\n   */\n  references: CSSModuleReferences,\n\n  /**\n   * string dependencies, if enabled.\n   */\n  dependencies: Dependency[] | void,\n\n  /**\n   * Warnings that occurred during compilation.\n   */\n  warnings: Warning[],\n|};\nexport type Warning = {|\n  message: string,\n  type: string,\n  value?: any,\n  loc: ErrorLocation,\n|};\nexport type CSSModulesConfig = {|\n  /**\n   * The pattern to use when renaming class names and other identifiers. Default is string.\n   */\n  pattern?: string,\n\n  /**\n   * Whether to rename dashed identifiers, e.g. custom properties.\n   */\n  dashedIdents?: boolean,\n\n  /**\n   * Whether to enable hashing for string.\n   */\n  animation?: boolean,\n\n  /**\n   * Whether to enable hashing for CSS grid identifiers.\n   */\n  grid?: boolean,\n\n  /**\n   * Whether to enable hashing for string names.\n   */\n  container?: boolean,\n\n  /**\n   * Whether to enable hashing for custom identifiers.\n   */\n  customIdents?: boolean,\n\n  /**\n   * Whether to require at least one class or id selector in each rule.\n   */\n  pure?: boolean,\n|};\nexport type CSSModuleExports = {\n  /**\n   * Maps exported (i.e. original) names to local names.\n   */\n  [name: string]: CSSModuleExport,\n};\nexport type CSSModuleExport = {|\n  /**\n   * The local (compiled) name for this export.\n   */\n  name: string,\n\n  /**\n   * Whether the export is referenced in this file.\n   */\n  isReferenced: boolean,\n\n  /**\n   * Other names that are composed by this export.\n   */\n  composes: CSSModuleReference[],\n|};\nexport type CSSModuleReferences = {\n  /**\n   * Maps placeholder names to references.\n   */\n  [name: string]: DependencyCSSModuleReference,\n};\nexport type CSSModuleReference =\n  | LocalCSSModuleReference\n  | GlobalCSSModuleReference\n  | DependencyCSSModuleReference;\nexport type LocalCSSModuleReference = {|\n  type: \"local\",\n\n  /**\n   * The local (compiled) name for the reference.\n   */\n  name: string,\n|};\nexport type GlobalCSSModuleReference = {|\n  type: \"global\",\n\n  /**\n   * The referenced global name.\n   */\n  name: string,\n|};\nexport type DependencyCSSModuleReference = {|\n  type: \"dependency\",\n\n  /**\n   * The name to reference within the dependency.\n   */\n  name: string,\n\n  /**\n   * The dependency specifier for the referenced file.\n   */\n  specifier: string,\n|};\nexport type Dependency = ImportDependency | UrlDependency;\nexport type ImportDependency = {|\n  type: \"import\",\n\n  /**\n   * The url of the string dependency.\n   */\n  url: string,\n\n  /**\n   * The media query for the string rule.\n   */\n  media: string | null,\n\n  /**\n   * The string rule.\n   */\n  supports: string | null,\n\n  /**\n   * The source location where the string rule was found.\n   */\n  loc: SourceLocation,\n\n  /**\n   * The placeholder that the import was replaced with.\n   */\n  placeholder: string,\n|};\nexport type UrlDependency = {|\n  type: \"url\",\n\n  /**\n   * The url of the dependency.\n   */\n  url: string,\n\n  /**\n   * The source location where the string was found.\n   */\n  loc: SourceLocation,\n\n  /**\n   * The placeholder that the url was replaced with.\n   */\n  placeholder: string,\n|};\nexport type SourceLocation = {|\n  /**\n   * The file path in which the dependency exists.\n   */\n  filePath: string,\n\n  /**\n   * The start location of the dependency.\n   */\n  start: Location,\n\n  /**\n   * The end location (inclusive) of the dependency.\n   */\n  end: Location,\n|};\nexport type Location = {|\n  /**\n   * The line number (1-based).\n   */\n  line: number,\n\n  /**\n   * The column number (0-based).\n   */\n  column: number,\n|};\nexport type ErrorLocation = {|\n  ...$Exact<Location>,\n\n  filename: string,\n|};\n\n/**\n * Compiles a CSS file, including optionally minifying and lowering syntax to the given\n * targets. A source map may also be generated, but this is not enabled by default.\n */\ndeclare export function transform<C: CustomAtRules>(\n  options: TransformOptions<C>\n): TransformResult;\nexport type TransformAttributeOptions = {|\n  /**\n   * The filename in which the style attribute appeared. Used for error messages and dependencies.\n   */\n  filename?: string,\n\n  /**\n   * The source code to transform.\n   */\n  code: Uint8Array,\n\n  /**\n   * Whether to enable minification.\n   */\n  minify?: boolean,\n\n  /**\n   * The browser targets for the generated code.\n   */\n  targets?: Targets,\n\n  /**\n   * Whether to analyze string dependencies.\n   * When enabled, string dependencies are replaced with hashed placeholders\n   * that can be replaced with the final urls later (after bundling).\n   * Dependencies are returned as part of the result.\n   */\n  analyzeDependencies?: boolean,\n\n  /**\n   * Whether to ignore invalid rules and declarations rather than erroring.\n   * When enabled, warnings are returned, and the invalid rule or declaration is\n   * omitted from the output code.\n   */\n  errorRecovery?: boolean,\n\n  /**\n   * An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.\n   * Multiple visitors can be composed into one using the string function.\n   * For optimal performance, visitors should be as specific as possible about what types of values\n   * they care about so that JavaScript has to be called as little as possible.\n   */\n  visitor?: Visitor<empty>,\n|};\nexport type TransformAttributeResult = {|\n  /**\n   * The transformed code.\n   */\n  code: Uint8Array,\n\n  /**\n   * string dependencies, if enabled.\n   */\n  dependencies: Dependency[] | void,\n\n  /**\n   * Warnings that occurred during compilation.\n   */\n  warnings: Warning[],\n|};\n\n/**\n * Compiles a single CSS declaration list, such as an inline style attribute in HTML.\n */\ndeclare export function transformStyleAttribute(\n  options: TransformAttributeOptions\n): TransformAttributeResult;\n\n/**\n * Converts a browserslist result into targets that can be passed to lightningcss.\n * @param browserslist the result of calling string\n */\ndeclare export function browserslistToTargets(browserslist: string[]): Targets;\n\n/**\n * Bundles a CSS file and its dependencies, inlining @import rules.\n */\ndeclare export function bundle<C: CustomAtRules>(\n  options: BundleOptions<C>\n): TransformResult;\n\n/**\n * Bundles a CSS file and its dependencies asynchronously, inlining @import rules.\n */\ndeclare export function bundleAsync<C: CustomAtRules>(\n  options: BundleAsyncOptions<C>\n): Promise<TransformResult>;\n\n/**\n * Composes multiple visitor objects into a single one.\n */\ndeclare export function composeVisitors<C: CustomAtRules>(\n  visitors: Visitor<C>[]\n): Visitor<C>;\n"
        }
    ]
}