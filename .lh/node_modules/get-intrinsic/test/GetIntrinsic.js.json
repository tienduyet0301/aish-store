{
    "sourceFile": "node_modules/get-intrinsic/test/GetIntrinsic.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892314589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('../');\n\nvar test = require('tape');\nvar forEach = require('for-each');\nvar debug = require('object-inspect');\nvar generatorFns = require('make-generator-function')();\nvar asyncFns = require('make-async-function').list();\nvar asyncGenFns = require('make-async-generator-function')();\nvar mockProperty = require('mock-property');\n\nvar callBound = require('call-bound');\nvar v = require('es-value-fixtures');\nvar $gOPD = require('gopd');\nvar DefinePropertyOrThrow = require('es-abstract/2023/DefinePropertyOrThrow');\n\nvar $isProto = callBound('%Object.prototype.isPrototypeOf%');\n\ntest('export', function (t) {\n\tt.equal(typeof GetIntrinsic, 'function', 'it is a function');\n\tt.equal(GetIntrinsic.length, 2, 'function has length of 2');\n\n\tt.end();\n});\n\ntest('throws', function (t) {\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('not an intrinsic'); },\n\t\tSyntaxError,\n\t\t'nonexistent intrinsic throws a syntax error'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic(''); },\n\t\tTypeError,\n\t\t'empty string intrinsic throws a type error'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('.'); },\n\t\tSyntaxError,\n\t\t'\"just a dot\" intrinsic throws a syntax error'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('%String'); },\n\t\tSyntaxError,\n\t\t'Leading % without trailing % throws a syntax error'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('String%'); },\n\t\tSyntaxError,\n\t\t'Trailing % without leading % throws a syntax error'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic(\"String['prototype]\"); },\n\t\tSyntaxError,\n\t\t'Dynamic property access is disallowed for intrinsics (unterminated string)'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('%Proxy.prototype.undefined%'); },\n\t\tTypeError,\n\t\t\"Throws when middle part doesn't exist (%Proxy.prototype.undefined%)\"\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('%Array.prototype%garbage%'); },\n\t\tSyntaxError,\n\t\t'Throws with extra percent signs'\n\t);\n\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('%Array.prototype%push%'); },\n\t\tSyntaxError,\n\t\t'Throws with extra percent signs, even on an existing intrinsic'\n\t);\n\n\tforEach(v.nonStrings, function (nonString) {\n\t\tt['throws'](\n\t\t\tfunction () { GetIntrinsic(nonString); },\n\t\t\tTypeError,\n\t\t\tdebug(nonString) + ' is not a String'\n\t\t);\n\t});\n\n\tforEach(v.nonBooleans, function (nonBoolean) {\n\t\tt['throws'](\n\t\t\tfunction () { GetIntrinsic('%', nonBoolean); },\n\t\t\tTypeError,\n\t\t\tdebug(nonBoolean) + ' is not a Boolean'\n\t\t);\n\t});\n\n\tforEach([\n\t\t'toString',\n\t\t'propertyIsEnumerable',\n\t\t'hasOwnProperty'\n\t], function (objectProtoMember) {\n\t\tt['throws'](\n\t\t\tfunction () { GetIntrinsic(objectProtoMember); },\n\t\t\tSyntaxError,\n\t\t\tdebug(objectProtoMember) + ' is not an intrinsic'\n\t\t);\n\t});\n\n\tt.end();\n});\n\ntest('base intrinsics', function (t) {\n\tt.equal(GetIntrinsic('%Object%'), Object, '%Object% yields Object');\n\tt.equal(GetIntrinsic('Object'), Object, 'Object yields Object');\n\tt.equal(GetIntrinsic('%Array%'), Array, '%Array% yields Array');\n\tt.equal(GetIntrinsic('Array'), Array, 'Array yields Array');\n\n\tt.end();\n});\n\ntest('dotted paths', function (t) {\n\tt.equal(GetIntrinsic('%Object.prototype.toString%'), Object.prototype.toString, '%Object.prototype.toString% yields Object.prototype.toString');\n\tt.equal(GetIntrinsic('Object.prototype.toString'), Object.prototype.toString, 'Object.prototype.toString yields Object.prototype.toString');\n\tt.equal(GetIntrinsic('%Array.prototype.push%'), Array.prototype.push, '%Array.prototype.push% yields Array.prototype.push');\n\tt.equal(GetIntrinsic('Array.prototype.push'), Array.prototype.push, 'Array.prototype.push yields Array.prototype.push');\n\n\ttest('underscore paths are aliases for dotted paths', { skip: !Object.isFrozen || Object.isFrozen(Object.prototype) }, function (st) {\n\t\tvar original = GetIntrinsic('%ObjProto_toString%');\n\n\t\tforEach([\n\t\t\t'%Object.prototype.toString%',\n\t\t\t'Object.prototype.toString',\n\t\t\t'%ObjectPrototype.toString%',\n\t\t\t'ObjectPrototype.toString',\n\t\t\t'%ObjProto_toString%',\n\t\t\t'ObjProto_toString'\n\t\t], function (name) {\n\t\t\tDefinePropertyOrThrow(Object.prototype, 'toString', {\n\t\t\t\t'[[Value]]': function toString() {\n\t\t\t\t\treturn original.apply(this, arguments);\n\t\t\t\t}\n\t\t\t});\n\t\t\tst.equal(GetIntrinsic(name), original, name + ' yields original Object.prototype.toString');\n\t\t});\n\n\t\tDefinePropertyOrThrow(Object.prototype, 'toString', { '[[Value]]': original });\n\t\tst.end();\n\t});\n\n\ttest('dotted paths cache', { skip: !Object.isFrozen || Object.isFrozen(Object.prototype) }, function (st) {\n\t\tvar original = GetIntrinsic('%Object.prototype.propertyIsEnumerable%');\n\n\t\tforEach([\n\t\t\t'%Object.prototype.propertyIsEnumerable%',\n\t\t\t'Object.prototype.propertyIsEnumerable',\n\t\t\t'%ObjectPrototype.propertyIsEnumerable%',\n\t\t\t'ObjectPrototype.propertyIsEnumerable'\n\t\t], function (name) {\n\t\t\tvar restore = mockProperty(Object.prototype, 'propertyIsEnumerable', {\n\t\t\t\tvalue: function propertyIsEnumerable() {\n\t\t\t\t\treturn original.apply(this, arguments);\n\t\t\t\t}\n\t\t\t});\n\t\t\tst.equal(GetIntrinsic(name), original, name + ' yields cached Object.prototype.propertyIsEnumerable');\n\n\t\t\trestore();\n\t\t});\n\n\t\tst.end();\n\t});\n\n\ttest('dotted path reports correct error', function (st) {\n\t\tst['throws'](function () {\n\t\t\tGetIntrinsic('%NonExistentIntrinsic.prototype.property%');\n\t\t}, /%NonExistentIntrinsic%/, 'The base intrinsic of %NonExistentIntrinsic.prototype.property% is %NonExistentIntrinsic%');\n\n\t\tst['throws'](function () {\n\t\t\tGetIntrinsic('%NonExistentIntrinsicPrototype.property%');\n\t\t}, /%NonExistentIntrinsicPrototype%/, 'The base intrinsic of %NonExistentIntrinsicPrototype.property% is %NonExistentIntrinsicPrototype%');\n\n\t\tst.end();\n\t});\n\n\tt.end();\n});\n\ntest('accessors', { skip: !$gOPD || typeof Map !== 'function' }, function (t) {\n\tvar actual = $gOPD(Map.prototype, 'size');\n\tt.ok(actual, 'Map.prototype.size has a descriptor');\n\tt.equal(typeof actual.get, 'function', 'Map.prototype.size has a getter function');\n\tt.equal(GetIntrinsic('%Map.prototype.size%'), actual.get, '%Map.prototype.size% yields the getter for it');\n\tt.equal(GetIntrinsic('Map.prototype.size'), actual.get, 'Map.prototype.size yields the getter for it');\n\n\tt.end();\n});\n\ntest('generator functions', { skip: !generatorFns.length }, function (t) {\n\tvar $GeneratorFunction = GetIntrinsic('%GeneratorFunction%');\n\tvar $GeneratorFunctionPrototype = GetIntrinsic('%Generator%');\n\tvar $GeneratorPrototype = GetIntrinsic('%GeneratorPrototype%');\n\n\tforEach(generatorFns, function (genFn) {\n\t\tvar fnName = genFn.name;\n\t\tfnName = fnName ? \"'\" + fnName + \"'\" : 'genFn';\n\n\t\tt.ok(genFn instanceof $GeneratorFunction, fnName + ' instanceof %GeneratorFunction%');\n\t\tt.ok($isProto($GeneratorFunctionPrototype, genFn), '%Generator% is prototype of ' + fnName);\n\t\tt.ok($isProto($GeneratorPrototype, genFn.prototype), '%GeneratorPrototype% is prototype of ' + fnName + '.prototype');\n\t});\n\n\tt.end();\n});\n\ntest('async functions', { skip: !asyncFns.length }, function (t) {\n\tvar $AsyncFunction = GetIntrinsic('%AsyncFunction%');\n\tvar $AsyncFunctionPrototype = GetIntrinsic('%AsyncFunctionPrototype%');\n\n\tforEach(asyncFns, function (asyncFn) {\n\t\tvar fnName = asyncFn.name;\n\t\tfnName = fnName ? \"'\" + fnName + \"'\" : 'asyncFn';\n\n\t\tt.ok(asyncFn instanceof $AsyncFunction, fnName + ' instanceof %AsyncFunction%');\n\t\tt.ok($isProto($AsyncFunctionPrototype, asyncFn), '%AsyncFunctionPrototype% is prototype of ' + fnName);\n\t});\n\n\tt.end();\n});\n\ntest('async generator functions', { skip: asyncGenFns.length === 0 }, function (t) {\n\tvar $AsyncGeneratorFunction = GetIntrinsic('%AsyncGeneratorFunction%');\n\tvar $AsyncGeneratorFunctionPrototype = GetIntrinsic('%AsyncGenerator%');\n\tvar $AsyncGeneratorPrototype = GetIntrinsic('%AsyncGeneratorPrototype%');\n\n\tforEach(asyncGenFns, function (asyncGenFn) {\n\t\tvar fnName = asyncGenFn.name;\n\t\tfnName = fnName ? \"'\" + fnName + \"'\" : 'asyncGenFn';\n\n\t\tt.ok(asyncGenFn instanceof $AsyncGeneratorFunction, fnName + ' instanceof %AsyncGeneratorFunction%');\n\t\tt.ok($isProto($AsyncGeneratorFunctionPrototype, asyncGenFn), '%AsyncGenerator% is prototype of ' + fnName);\n\t\tt.ok($isProto($AsyncGeneratorPrototype, asyncGenFn.prototype), '%AsyncGeneratorPrototype% is prototype of ' + fnName + '.prototype');\n\t});\n\n\tt.end();\n});\n\ntest('%ThrowTypeError%', function (t) {\n\tvar $ThrowTypeError = GetIntrinsic('%ThrowTypeError%');\n\n\tt.equal(typeof $ThrowTypeError, 'function', 'is a function');\n\tt['throws'](\n\t\t$ThrowTypeError,\n\t\tTypeError,\n\t\t'%ThrowTypeError% throws a TypeError'\n\t);\n\n\tt.end();\n});\n\ntest('allowMissing', { skip: asyncGenFns.length > 0 }, function (t) {\n\tt['throws'](\n\t\tfunction () { GetIntrinsic('%AsyncGeneratorPrototype%'); },\n\t\tTypeError,\n\t\t'throws when missing'\n\t);\n\n\tt.equal(\n\t\tGetIntrinsic('%AsyncGeneratorPrototype%', true),\n\t\tundefined,\n\t\t'does not throw when allowMissing'\n\t);\n\n\tt.end();\n});\n"
        }
    ]
}