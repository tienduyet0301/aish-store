{
    "sourceFile": "node_modules/sharp/src/metadata.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <numeric>\n#include <vector>\n#include <cmath>\n\n#include <napi.h>\n#include <vips/vips8>\n\n#include \"common.h\"\n#include \"metadata.h\"\n\nstatic void* readPNGComment(VipsImage *image, const char *field, GValue *value, void *p);\n\nclass MetadataWorker : public Napi::AsyncWorker {\n public:\n  MetadataWorker(Napi::Function callback, MetadataBaton *baton, Napi::Function debuglog) :\n    Napi::AsyncWorker(callback), baton(baton), debuglog(Napi::Persistent(debuglog)) {}\n  ~MetadataWorker() {}\n\n  void Execute() {\n    // Decrement queued task counter\n    sharp::counterQueue--;\n\n    vips::VImage image;\n    sharp::ImageType imageType = sharp::ImageType::UNKNOWN;\n    try {\n      std::tie(image, imageType) = OpenInput(baton->input);\n    } catch (vips::VError const &err) {\n      (baton->err).append(err.what());\n    }\n    if (imageType != sharp::ImageType::UNKNOWN) {\n      // Image type\n      baton->format = sharp::ImageTypeId(imageType);\n      // VipsImage attributes\n      baton->width = image.width();\n      baton->height = image.height();\n      baton->space = vips_enum_nick(VIPS_TYPE_INTERPRETATION, image.interpretation());\n      baton->channels = image.bands();\n      baton->depth = vips_enum_nick(VIPS_TYPE_BAND_FORMAT, image.format());\n      if (sharp::HasDensity(image)) {\n        baton->density = sharp::GetDensity(image);\n      }\n      if (image.get_typeof(\"jpeg-chroma-subsample\") == VIPS_TYPE_REF_STRING) {\n        baton->chromaSubsampling = image.get_string(\"jpeg-chroma-subsample\");\n      }\n      if (image.get_typeof(\"interlaced\") == G_TYPE_INT) {\n        baton->isProgressive = image.get_int(\"interlaced\") == 1;\n      }\n      if (image.get_typeof(VIPS_META_PALETTE) == G_TYPE_INT) {\n        baton->isPalette = image.get_int(VIPS_META_PALETTE);\n      }\n      if (image.get_typeof(VIPS_META_BITS_PER_SAMPLE) == G_TYPE_INT) {\n        baton->bitsPerSample = image.get_int(VIPS_META_BITS_PER_SAMPLE);\n      }\n      if (image.get_typeof(VIPS_META_N_PAGES) == G_TYPE_INT) {\n        baton->pages = image.get_int(VIPS_META_N_PAGES);\n      }\n      if (image.get_typeof(VIPS_META_PAGE_HEIGHT) == G_TYPE_INT) {\n        baton->pageHeight = image.get_int(VIPS_META_PAGE_HEIGHT);\n      }\n      if (image.get_typeof(\"loop\") == G_TYPE_INT) {\n        baton->loop = image.get_int(\"loop\");\n      }\n      if (image.get_typeof(\"delay\") == VIPS_TYPE_ARRAY_INT) {\n        baton->delay = image.get_array_int(\"delay\");\n      }\n      if (image.get_typeof(\"heif-primary\") == G_TYPE_INT) {\n        baton->pagePrimary = image.get_int(\"heif-primary\");\n      }\n      if (image.get_typeof(\"heif-compression\") == VIPS_TYPE_REF_STRING) {\n        baton->compression = image.get_string(\"heif-compression\");\n      }\n      if (image.get_typeof(VIPS_META_RESOLUTION_UNIT) == VIPS_TYPE_REF_STRING) {\n        baton->resolutionUnit = image.get_string(VIPS_META_RESOLUTION_UNIT);\n      }\n      if (image.get_typeof(\"magick-format\") == VIPS_TYPE_REF_STRING) {\n        baton->formatMagick = image.get_string(\"magick-format\");\n      }\n      if (image.get_typeof(\"openslide.level-count\") == VIPS_TYPE_REF_STRING) {\n        int const levels = std::stoi(image.get_string(\"openslide.level-count\"));\n        for (int l = 0; l < levels; l++) {\n          std::string prefix = \"openslide.level[\" + std::to_string(l) + \"].\";\n          int const width = std::stoi(image.get_string((prefix + \"width\").data()));\n          int const height = std::stoi(image.get_string((prefix + \"height\").data()));\n          baton->levels.push_back(std::pair<int, int>(width, height));\n        }\n      }\n      if (image.get_typeof(VIPS_META_N_SUBIFDS) == G_TYPE_INT) {\n        baton->subifds = image.get_int(VIPS_META_N_SUBIFDS);\n      }\n      baton->hasProfile = sharp::HasProfile(image);\n      if (image.get_typeof(\"background\") == VIPS_TYPE_ARRAY_DOUBLE) {\n        baton->background = image.get_array_double(\"background\");\n      }\n      // Derived attributes\n      baton->hasAlpha = image.has_alpha();\n      baton->orientation = sharp::ExifOrientation(image);\n      // EXIF\n      if (image.get_typeof(VIPS_META_EXIF_NAME) == VIPS_TYPE_BLOB) {\n        size_t exifLength;\n        void const *exif = image.get_blob(VIPS_META_EXIF_NAME, &exifLength);\n        baton->exif = static_cast<char*>(g_malloc(exifLength));\n        memcpy(baton->exif, exif, exifLength);\n        baton->exifLength = exifLength;\n      }\n      // ICC profile\n      if (image.get_typeof(VIPS_META_ICC_NAME) == VIPS_TYPE_BLOB) {\n        size_t iccLength;\n        void const *icc = image.get_blob(VIPS_META_ICC_NAME, &iccLength);\n        baton->icc = static_cast<char*>(g_malloc(iccLength));\n        memcpy(baton->icc, icc, iccLength);\n        baton->iccLength = iccLength;\n      }\n      // IPTC\n      if (image.get_typeof(VIPS_META_IPTC_NAME) == VIPS_TYPE_BLOB) {\n        size_t iptcLength;\n        void const *iptc = image.get_blob(VIPS_META_IPTC_NAME, &iptcLength);\n        baton->iptc = static_cast<char *>(g_malloc(iptcLength));\n        memcpy(baton->iptc, iptc, iptcLength);\n        baton->iptcLength = iptcLength;\n      }\n      // XMP\n      if (image.get_typeof(VIPS_META_XMP_NAME) == VIPS_TYPE_BLOB) {\n        size_t xmpLength;\n        void const *xmp = image.get_blob(VIPS_META_XMP_NAME, &xmpLength);\n        baton->xmp = static_cast<char *>(g_malloc(xmpLength));\n        memcpy(baton->xmp, xmp, xmpLength);\n        baton->xmpLength = xmpLength;\n      }\n      // TIFFTAG_PHOTOSHOP\n      if (image.get_typeof(VIPS_META_PHOTOSHOP_NAME) == VIPS_TYPE_BLOB) {\n        size_t tifftagPhotoshopLength;\n        void const *tifftagPhotoshop = image.get_blob(VIPS_META_PHOTOSHOP_NAME, &tifftagPhotoshopLength);\n        baton->tifftagPhotoshop = static_cast<char *>(g_malloc(tifftagPhotoshopLength));\n        memcpy(baton->tifftagPhotoshop, tifftagPhotoshop, tifftagPhotoshopLength);\n        baton->tifftagPhotoshopLength = tifftagPhotoshopLength;\n      }\n      // PNG comments\n      vips_image_map(image.get_image(), readPNGComment, &baton->comments);\n    }\n\n    // Clean up\n    vips_error_clear();\n    vips_thread_shutdown();\n  }\n\n  void OnOK() {\n    Napi::Env env = Env();\n    Napi::HandleScope scope(env);\n\n    // Handle warnings\n    std::string warning = sharp::VipsWarningPop();\n    while (!warning.empty()) {\n      debuglog.Call(Receiver().Value(), { Napi::String::New(env, warning) });\n      warning = sharp::VipsWarningPop();\n    }\n\n    if (baton->err.empty()) {\n      Napi::Object info = Napi::Object::New(env);\n      info.Set(\"format\", baton->format);\n      if (baton->input->bufferLength > 0) {\n        info.Set(\"size\", baton->input->bufferLength);\n      }\n      info.Set(\"width\", baton->width);\n      info.Set(\"height\", baton->height);\n      info.Set(\"space\", baton->space);\n      info.Set(\"channels\", baton->channels);\n      info.Set(\"depth\", baton->depth);\n      if (baton->density > 0) {\n        info.Set(\"density\", baton->density);\n      }\n      if (!baton->chromaSubsampling.empty()) {\n        info.Set(\"chromaSubsampling\", baton->chromaSubsampling);\n      }\n      info.Set(\"isProgressive\", baton->isProgressive);\n      info.Set(\"isPalette\", baton->isPalette);\n      if (baton->bitsPerSample > 0) {\n        info.Set(\"bitsPerSample\", baton->bitsPerSample);\n        if (baton->isPalette) {\n          // Deprecated, remove with libvips 8.17.0\n          info.Set(\"paletteBitDepth\", baton->bitsPerSample);\n        }\n      }\n      if (baton->pages > 0) {\n        info.Set(\"pages\", baton->pages);\n      }\n      if (baton->pageHeight > 0) {\n        info.Set(\"pageHeight\", baton->pageHeight);\n      }\n      if (baton->loop >= 0) {\n        info.Set(\"loop\", baton->loop);\n      }\n      if (!baton->delay.empty()) {\n        int i = 0;\n        Napi::Array delay = Napi::Array::New(env, static_cast<size_t>(baton->delay.size()));\n        for (int const d : baton->delay) {\n          delay.Set(i++, d);\n        }\n        info.Set(\"delay\", delay);\n      }\n      if (baton->pagePrimary > -1) {\n        info.Set(\"pagePrimary\", baton->pagePrimary);\n      }\n      if (!baton->compression.empty()) {\n        info.Set(\"compression\", baton->compression);\n      }\n      if (!baton->resolutionUnit.empty()) {\n        info.Set(\"resolutionUnit\", baton->resolutionUnit == \"in\" ? \"inch\" : baton->resolutionUnit);\n      }\n      if (!baton->formatMagick.empty()) {\n        info.Set(\"formatMagick\", baton->formatMagick);\n      }\n      if (!baton->levels.empty()) {\n        int i = 0;\n        Napi::Array levels = Napi::Array::New(env, static_cast<size_t>(baton->levels.size()));\n        for (std::pair<int, int> const &l : baton->levels) {\n          Napi::Object level = Napi::Object::New(env);\n          level.Set(\"width\", l.first);\n          level.Set(\"height\", l.second);\n          levels.Set(i++, level);\n        }\n        info.Set(\"levels\", levels);\n      }\n      if (baton->subifds > 0) {\n        info.Set(\"subifds\", baton->subifds);\n      }\n      if (!baton->background.empty()) {\n        Napi::Object background = Napi::Object::New(env);\n        if (baton->background.size() == 3) {\n          background.Set(\"r\", baton->background[0]);\n          background.Set(\"g\", baton->background[1]);\n          background.Set(\"b\", baton->background[2]);\n        } else {\n          background.Set(\"gray\", round(baton->background[0] * 100 / 255));\n        }\n        info.Set(\"background\", background);\n      }\n      info.Set(\"hasProfile\", baton->hasProfile);\n      info.Set(\"hasAlpha\", baton->hasAlpha);\n      if (baton->orientation > 0) {\n        info.Set(\"orientation\", baton->orientation);\n      }\n      Napi::Object autoOrient = Napi::Object::New(env);\n      info.Set(\"autoOrient\", autoOrient);\n      if (baton->orientation >= 5) {\n        autoOrient.Set(\"width\", baton->height);\n        autoOrient.Set(\"height\", baton->width);\n      } else {\n        autoOrient.Set(\"width\", baton->width);\n        autoOrient.Set(\"height\", baton->height);\n      }\n      if (baton->exifLength > 0) {\n        info.Set(\"exif\", Napi::Buffer<char>::NewOrCopy(env, baton->exif, baton->exifLength, sharp::FreeCallback));\n      }\n      if (baton->iccLength > 0) {\n        info.Set(\"icc\", Napi::Buffer<char>::NewOrCopy(env, baton->icc, baton->iccLength, sharp::FreeCallback));\n      }\n      if (baton->iptcLength > 0) {\n        info.Set(\"iptc\", Napi::Buffer<char>::NewOrCopy(env, baton->iptc, baton->iptcLength, sharp::FreeCallback));\n      }\n      if (baton->xmpLength > 0) {\n        info.Set(\"xmp\", Napi::Buffer<char>::NewOrCopy(env, baton->xmp, baton->xmpLength, sharp::FreeCallback));\n      }\n      if (baton->tifftagPhotoshopLength > 0) {\n        info.Set(\"tifftagPhotoshop\",\n          Napi::Buffer<char>::NewOrCopy(env, baton->tifftagPhotoshop,\n            baton->tifftagPhotoshopLength, sharp::FreeCallback));\n      }\n      if (baton->comments.size() > 0) {\n        int i = 0;\n        Napi::Array comments = Napi::Array::New(env, baton->comments.size());\n        for (auto &c : baton->comments) {\n          Napi::Object comment = Napi::Object::New(env);\n          comment.Set(\"keyword\", c.first);\n          comment.Set(\"text\", c.second);\n          comments.Set(i++, comment);\n        }\n        info.Set(\"comments\", comments);\n      }\n      Callback().Call(Receiver().Value(), { env.Null(), info });\n    } else {\n      Callback().Call(Receiver().Value(), { Napi::Error::New(env, sharp::TrimEnd(baton->err)).Value() });\n    }\n\n    delete baton->input;\n    delete baton;\n  }\n\n private:\n  MetadataBaton* baton;\n  Napi::FunctionReference debuglog;\n};\n\n/*\n  metadata(options, callback)\n*/\nNapi::Value metadata(const Napi::CallbackInfo& info) {\n  // V8 objects are converted to non-V8 types held in the baton struct\n  MetadataBaton *baton = new MetadataBaton;\n  Napi::Object options = info[size_t(0)].As<Napi::Object>();\n\n  // Input\n  baton->input = sharp::CreateInputDescriptor(options.Get(\"input\").As<Napi::Object>());\n\n  // Function to notify of libvips warnings\n  Napi::Function debuglog = options.Get(\"debuglog\").As<Napi::Function>();\n\n  // Join queue for worker thread\n  Napi::Function callback = info[size_t(1)].As<Napi::Function>();\n  MetadataWorker *worker = new MetadataWorker(callback, baton, debuglog);\n  worker->Receiver().Set(\"options\", options);\n  worker->Queue();\n\n  // Increment queued task counter\n  sharp::counterQueue++;\n\n  return info.Env().Undefined();\n}\n\nconst char *PNG_COMMENT_START = \"png-comment-\";\nconst int PNG_COMMENT_START_LEN = strlen(PNG_COMMENT_START);\n\nstatic void* readPNGComment(VipsImage *image, const char *field, GValue *value, void *p) {\n  MetadataComments *comments = static_cast<MetadataComments *>(p);\n\n  if (vips_isprefix(PNG_COMMENT_START, field)) {\n    const char *keyword = strchr(field + PNG_COMMENT_START_LEN, '-');\n    const char *str;\n    if (keyword != NULL && !vips_image_get_string(image, field, &str)) {\n      keyword++;  // Skip the hyphen\n      comments->push_back(std::make_pair(keyword, str));\n    }\n  }\n\n  return NULL;\n}\n"
        }
    ]
}