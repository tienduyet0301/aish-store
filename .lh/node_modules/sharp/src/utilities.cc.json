{
    "sourceFile": "node_modules/sharp/src/utilities.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <cmath>\n#include <string>\n#include <cstdio>\n\n#include <napi.h>\n#include <vips/vips8>\n#include <vips/vector.h>\n\n#include \"common.h\"\n#include \"operations.h\"\n#include \"utilities.h\"\n\n/*\n  Get and set cache limits\n*/\nNapi::Value cache(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n\n  // Set memory limit\n  if (info[size_t(0)].IsNumber()) {\n    vips_cache_set_max_mem(info[size_t(0)].As<Napi::Number>().Int32Value() * 1048576);\n  }\n  // Set file limit\n  if (info[size_t(1)].IsNumber()) {\n    vips_cache_set_max_files(info[size_t(1)].As<Napi::Number>().Int32Value());\n  }\n  // Set items limit\n  if (info[size_t(2)].IsNumber()) {\n    vips_cache_set_max(info[size_t(2)].As<Napi::Number>().Int32Value());\n  }\n\n  // Get memory stats\n  Napi::Object memory = Napi::Object::New(env);\n  memory.Set(\"current\", round(vips_tracked_get_mem() / 1048576));\n  memory.Set(\"high\", round(vips_tracked_get_mem_highwater() / 1048576));\n  memory.Set(\"max\", round(vips_cache_get_max_mem() / 1048576));\n  // Get file stats\n  Napi::Object files = Napi::Object::New(env);\n  files.Set(\"current\", vips_tracked_get_files());\n  files.Set(\"max\", vips_cache_get_max_files());\n\n  // Get item stats\n  Napi::Object items = Napi::Object::New(env);\n  items.Set(\"current\", vips_cache_get_size());\n  items.Set(\"max\", vips_cache_get_max());\n\n  Napi::Object cache = Napi::Object::New(env);\n  cache.Set(\"memory\", memory);\n  cache.Set(\"files\", files);\n  cache.Set(\"items\", items);\n  return cache;\n}\n\n/*\n  Get and set size of thread pool\n*/\nNapi::Value concurrency(const Napi::CallbackInfo& info) {\n  // Set concurrency\n  if (info[size_t(0)].IsNumber()) {\n    vips_concurrency_set(info[size_t(0)].As<Napi::Number>().Int32Value());\n  }\n  // Get concurrency\n  return Napi::Number::New(info.Env(), vips_concurrency_get());\n}\n\n/*\n  Get internal counters (queued tasks, processing tasks)\n*/\nNapi::Value counters(const Napi::CallbackInfo& info) {\n  Napi::Object counters = Napi::Object::New(info.Env());\n  counters.Set(\"queue\", static_cast<int>(sharp::counterQueue));\n  counters.Set(\"process\", static_cast<int>(sharp::counterProcess));\n  return counters;\n}\n\n/*\n  Get and set use of SIMD vector unit instructions\n*/\nNapi::Value simd(const Napi::CallbackInfo& info) {\n  // Set state\n  if (info[size_t(0)].IsBoolean()) {\n    vips_vector_set_enabled(info[size_t(0)].As<Napi::Boolean>().Value());\n  }\n  // Get state\n  return Napi::Boolean::New(info.Env(), vips_vector_isenabled());\n}\n\n/*\n  Get libvips version\n*/\nNapi::Value libvipsVersion(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  Napi::Object version = Napi::Object::New(env);\n\n  char semver[9];\n  std::snprintf(semver, sizeof(semver), \"%d.%d.%d\", vips_version(0), vips_version(1), vips_version(2));\n  version.Set(\"semver\", Napi::String::New(env, semver));\n#ifdef SHARP_USE_GLOBAL_LIBVIPS\n  version.Set(\"isGlobal\", Napi::Boolean::New(env, true));\n#else\n  version.Set(\"isGlobal\", Napi::Boolean::New(env, false));\n#endif\n#ifdef __EMSCRIPTEN__\n  version.Set(\"isWasm\", Napi::Boolean::New(env, true));\n#else\n  version.Set(\"isWasm\", Napi::Boolean::New(env, false));\n#endif\n  return version;\n}\n\n/*\n  Get available input/output file/buffer/stream formats\n*/\nNapi::Value format(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  Napi::Object format = Napi::Object::New(env);\n  for (std::string const f : {\n    \"jpeg\", \"png\", \"webp\", \"tiff\", \"magick\", \"openslide\", \"dz\",\n    \"ppm\", \"fits\", \"gif\", \"svg\", \"heif\", \"pdf\", \"vips\", \"jp2k\", \"jxl\", \"rad\"\n  }) {\n    // Input\n    const VipsObjectClass *oc = vips_class_find(\"VipsOperation\", (f + \"load\").c_str());\n    Napi::Boolean hasInputFile = Napi::Boolean::New(env, oc);\n    Napi::Boolean hasInputBuffer =\n      Napi::Boolean::New(env, vips_type_find(\"VipsOperation\", (f + \"load_buffer\").c_str()));\n    Napi::Object input = Napi::Object::New(env);\n    input.Set(\"file\", hasInputFile);\n    input.Set(\"buffer\", hasInputBuffer);\n    input.Set(\"stream\", hasInputBuffer);\n    if (hasInputFile) {\n      const VipsForeignClass *fc = VIPS_FOREIGN_CLASS(oc);\n      if (fc->suffs) {\n        Napi::Array fileSuffix = Napi::Array::New(env);\n        const char **suffix = fc->suffs;\n        for (int i = 0; *suffix; i++, suffix++) {\n          fileSuffix.Set(i, Napi::String::New(env, *suffix));\n        }\n        input.Set(\"fileSuffix\", fileSuffix);\n      }\n    }\n    // Output\n    Napi::Boolean hasOutputFile =\n      Napi::Boolean::New(env, vips_type_find(\"VipsOperation\", (f + \"save\").c_str()));\n    Napi::Boolean hasOutputBuffer =\n      Napi::Boolean::New(env, vips_type_find(\"VipsOperation\", (f + \"save_buffer\").c_str()));\n    Napi::Object output = Napi::Object::New(env);\n    output.Set(\"file\", hasOutputFile);\n    output.Set(\"buffer\", hasOutputBuffer);\n    output.Set(\"stream\", hasOutputBuffer);\n    // Other attributes\n    Napi::Object container = Napi::Object::New(env);\n    container.Set(\"id\", f);\n    container.Set(\"input\", input);\n    container.Set(\"output\", output);\n    // Add to set of formats\n    format.Set(f, container);\n  }\n\n  // Raw, uncompressed data\n  Napi::Boolean supported = Napi::Boolean::New(env, true);\n  Napi::Boolean unsupported = Napi::Boolean::New(env, false);\n  Napi::Object rawInput = Napi::Object::New(env);\n  rawInput.Set(\"file\", unsupported);\n  rawInput.Set(\"buffer\", supported);\n  rawInput.Set(\"stream\", supported);\n  Napi::Object rawOutput = Napi::Object::New(env);\n  rawOutput.Set(\"file\", unsupported);\n  rawOutput.Set(\"buffer\", supported);\n  rawOutput.Set(\"stream\", supported);\n  Napi::Object raw = Napi::Object::New(env);\n  raw.Set(\"id\", \"raw\");\n  raw.Set(\"input\", rawInput);\n  raw.Set(\"output\", rawOutput);\n  format.Set(\"raw\", raw);\n\n  return format;\n}\n\n/*\n  (Un)block libvips operations at runtime.\n*/\nvoid block(const Napi::CallbackInfo& info) {\n  Napi::Array ops = info[size_t(0)].As<Napi::Array>();\n  bool const state = info[size_t(1)].As<Napi::Boolean>().Value();\n  for (unsigned int i = 0; i < ops.Length(); i++) {\n    vips_operation_block_set(ops.Get(i).As<Napi::String>().Utf8Value().c_str(), state);\n  }\n}\n\n/*\n  Synchronous, internal-only method used by some of the functional tests.\n  Calculates the maximum colour distance using the DE2000 algorithm\n  between two images of the same dimensions and number of channels.\n*/\nNapi::Value _maxColourDistance(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n\n  // Open input files\n  VImage image1;\n  sharp::ImageType imageType1 = sharp::DetermineImageType(info[size_t(0)].As<Napi::String>().Utf8Value().data());\n  if (imageType1 != sharp::ImageType::UNKNOWN) {\n    try {\n      image1 = VImage::new_from_file(info[size_t(0)].As<Napi::String>().Utf8Value().c_str());\n    } catch (...) {\n      throw Napi::Error::New(env, \"Input file 1 has corrupt header\");\n    }\n  } else {\n    throw Napi::Error::New(env, \"Input file 1 is of an unsupported image format\");\n  }\n  VImage image2;\n  sharp::ImageType imageType2 = sharp::DetermineImageType(info[size_t(1)].As<Napi::String>().Utf8Value().data());\n  if (imageType2 != sharp::ImageType::UNKNOWN) {\n    try {\n      image2 = VImage::new_from_file(info[size_t(1)].As<Napi::String>().Utf8Value().c_str());\n    } catch (...) {\n      throw Napi::Error::New(env, \"Input file 2 has corrupt header\");\n    }\n  } else {\n    throw Napi::Error::New(env, \"Input file 2 is of an unsupported image format\");\n  }\n  // Ensure same number of channels\n  if (image1.bands() != image2.bands()) {\n    throw Napi::Error::New(env, \"mismatchedBands\");\n  }\n  // Ensure same dimensions\n  if (image1.width() != image2.width() || image1.height() != image2.height()) {\n    throw Napi::Error::New(env, \"mismatchedDimensions\");\n  }\n\n  double maxColourDistance;\n  try {\n    // Premultiply and remove alpha\n    if (image1.has_alpha()) {\n      image1 = image1.premultiply().extract_band(1, VImage::option()->set(\"n\", image1.bands() - 1));\n    }\n    if (image2.has_alpha()) {\n      image2 = image2.premultiply().extract_band(1, VImage::option()->set(\"n\", image2.bands() - 1));\n    }\n    // Calculate colour distance\n    maxColourDistance = image1.dE00(image2).max();\n  } catch (vips::VError const &err) {\n    throw Napi::Error::New(env, err.what());\n  }\n\n  // Clean up libvips' per-request data and threads\n  vips_error_clear();\n  vips_thread_shutdown();\n\n  return Napi::Number::New(env, maxColourDistance);\n}\n\n#if defined(__GNUC__)\n// mallctl will be resolved by the runtime linker when jemalloc is being used\nextern \"C\" {\n  int mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp, size_t newlen) __attribute__((weak));\n}\nNapi::Value _isUsingJemalloc(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  return Napi::Boolean::New(env, mallctl != nullptr);\n}\n#else\nNapi::Value _isUsingJemalloc(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  return Napi::Boolean::New(env, false);\n}\n#endif\n\n#if defined(__GNUC__) && defined(__x86_64__)\n// Are SSE 4.2 intrinsics available at runtime?\nNapi::Value _isUsingX64V2(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  unsigned int eax, ebx, ecx, edx;\n  __asm__ __volatile__(\"cpuid\"\n    : \"=a\"(eax), \"=b\"(ebx), \"=c\"(ecx), \"=d\"(edx)\n    : \"a\"(1));\n  return Napi::Boolean::New(env, (ecx & 1U << 20) != 0);\n}\n#else\nNapi::Value _isUsingX64V2(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  return Napi::Boolean::New(env, false);\n}\n#endif\n"
        }
    ]
}