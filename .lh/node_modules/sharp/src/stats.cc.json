{
    "sourceFile": "node_modules/sharp/src/stats.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <numeric>\n#include <vector>\n#include <iostream>\n\n#include <napi.h>\n#include <vips/vips8>\n\n#include \"common.h\"\n#include \"stats.h\"\n\nclass StatsWorker : public Napi::AsyncWorker {\n public:\n  StatsWorker(Napi::Function callback, StatsBaton *baton, Napi::Function debuglog) :\n    Napi::AsyncWorker(callback), baton(baton), debuglog(Napi::Persistent(debuglog)) {}\n  ~StatsWorker() {}\n\n  const int STAT_MIN_INDEX = 0;\n  const int STAT_MAX_INDEX = 1;\n  const int STAT_SUM_INDEX = 2;\n  const int STAT_SQ_SUM_INDEX = 3;\n  const int STAT_MEAN_INDEX = 4;\n  const int STAT_STDEV_INDEX = 5;\n  const int STAT_MINX_INDEX = 6;\n  const int STAT_MINY_INDEX = 7;\n  const int STAT_MAXX_INDEX = 8;\n  const int STAT_MAXY_INDEX = 9;\n\n  void Execute() {\n    // Decrement queued task counter\n    sharp::counterQueue--;\n\n    vips::VImage image;\n    sharp::ImageType imageType = sharp::ImageType::UNKNOWN;\n    try {\n      std::tie(image, imageType) = OpenInput(baton->input);\n    } catch (vips::VError const &err) {\n      (baton->err).append(err.what());\n    }\n    if (imageType != sharp::ImageType::UNKNOWN) {\n      try {\n        vips::VImage stats = image.stats();\n        int const bands = image.bands();\n        for (int b = 1; b <= bands; b++) {\n          ChannelStats cStats(\n            static_cast<int>(stats.getpoint(STAT_MIN_INDEX, b).front()),\n            static_cast<int>(stats.getpoint(STAT_MAX_INDEX, b).front()),\n            stats.getpoint(STAT_SUM_INDEX, b).front(),\n            stats.getpoint(STAT_SQ_SUM_INDEX, b).front(),\n            stats.getpoint(STAT_MEAN_INDEX, b).front(),\n            stats.getpoint(STAT_STDEV_INDEX, b).front(),\n            static_cast<int>(stats.getpoint(STAT_MINX_INDEX, b).front()),\n            static_cast<int>(stats.getpoint(STAT_MINY_INDEX, b).front()),\n            static_cast<int>(stats.getpoint(STAT_MAXX_INDEX, b).front()),\n            static_cast<int>(stats.getpoint(STAT_MAXY_INDEX, b).front()));\n          baton->channelStats.push_back(cStats);\n        }\n        // Image is not opaque when alpha layer is present and contains a non-mamixa value\n        if (image.has_alpha()) {\n          double const minAlpha = static_cast<double>(stats.getpoint(STAT_MIN_INDEX, bands).front());\n          if (minAlpha != sharp::MaximumImageAlpha(image.interpretation())) {\n            baton->isOpaque = false;\n          }\n        }\n        // Convert to greyscale\n        vips::VImage greyscale = image.colourspace(VIPS_INTERPRETATION_B_W)[0];\n        // Estimate entropy via histogram of greyscale value frequency\n        baton->entropy = std::abs(greyscale.hist_find().hist_entropy());\n        // Estimate sharpness via standard deviation of greyscale laplacian\n        if (image.width() > 1 || image.height() > 1) {\n          VImage laplacian = VImage::new_matrixv(3, 3,\n            0.0,  1.0, 0.0,\n            1.0, -4.0, 1.0,\n            0.0,  1.0, 0.0);\n          laplacian.set(\"scale\", 9.0);\n          baton->sharpness = greyscale.conv(laplacian).deviate();\n        }\n        // Most dominant sRGB colour via 4096-bin 3D histogram\n        vips::VImage hist = sharp::RemoveAlpha(image)\n          .colourspace(VIPS_INTERPRETATION_sRGB)\n          .hist_find_ndim(VImage::option()->set(\"bins\", 16));\n        std::complex<double> maxpos = hist.maxpos();\n        int const dx = static_cast<int>(std::real(maxpos));\n        int const dy = static_cast<int>(std::imag(maxpos));\n        std::vector<double> pel = hist(dx, dy);\n        int const dz = std::distance(pel.begin(), std::find(pel.begin(), pel.end(), hist.max()));\n        baton->dominantRed = dx * 16 + 8;\n        baton->dominantGreen = dy * 16 + 8;\n        baton->dominantBlue = dz * 16 + 8;\n      } catch (vips::VError const &err) {\n        (baton->err).append(err.what());\n      }\n    }\n\n    // Clean up\n    vips_error_clear();\n    vips_thread_shutdown();\n  }\n\n  void OnOK() {\n    Napi::Env env = Env();\n    Napi::HandleScope scope(env);\n\n    // Handle warnings\n    std::string warning = sharp::VipsWarningPop();\n    while (!warning.empty()) {\n      debuglog.Call(Receiver().Value(), { Napi::String::New(env, warning) });\n      warning = sharp::VipsWarningPop();\n    }\n\n    if (baton->err.empty()) {\n      // Stats Object\n      Napi::Object info = Napi::Object::New(env);\n      Napi::Array channels = Napi::Array::New(env);\n\n      std::vector<ChannelStats>::iterator it;\n      int i = 0;\n      for (it = baton->channelStats.begin(); it < baton->channelStats.end(); it++, i++) {\n        Napi::Object channelStat = Napi::Object::New(env);\n        channelStat.Set(\"min\", it->min);\n        channelStat.Set(\"max\", it->max);\n        channelStat.Set(\"sum\", it->sum);\n        channelStat.Set(\"squaresSum\", it->squaresSum);\n        channelStat.Set(\"mean\", it->mean);\n        channelStat.Set(\"stdev\", it->stdev);\n        channelStat.Set(\"minX\", it->minX);\n        channelStat.Set(\"minY\", it->minY);\n        channelStat.Set(\"maxX\", it->maxX);\n        channelStat.Set(\"maxY\", it->maxY);\n        channels.Set(i, channelStat);\n      }\n\n      info.Set(\"channels\", channels);\n      info.Set(\"isOpaque\", baton->isOpaque);\n      info.Set(\"entropy\", baton->entropy);\n      info.Set(\"sharpness\", baton->sharpness);\n      Napi::Object dominant = Napi::Object::New(env);\n      dominant.Set(\"r\", baton->dominantRed);\n      dominant.Set(\"g\", baton->dominantGreen);\n      dominant.Set(\"b\", baton->dominantBlue);\n      info.Set(\"dominant\", dominant);\n      Callback().Call(Receiver().Value(), { env.Null(), info });\n    } else {\n      Callback().Call(Receiver().Value(), { Napi::Error::New(env, sharp::TrimEnd(baton->err)).Value() });\n    }\n\n    delete baton->input;\n    delete baton;\n  }\n\n private:\n  StatsBaton* baton;\n  Napi::FunctionReference debuglog;\n};\n\n/*\n  stats(options, callback)\n*/\nNapi::Value stats(const Napi::CallbackInfo& info) {\n  // V8 objects are converted to non-V8 types held in the baton struct\n  StatsBaton *baton = new StatsBaton;\n  Napi::Object options = info[size_t(0)].As<Napi::Object>();\n\n  // Input\n  baton->input = sharp::CreateInputDescriptor(options.Get(\"input\").As<Napi::Object>());\n  baton->input->access = VIPS_ACCESS_RANDOM;\n\n  // Function to notify of libvips warnings\n  Napi::Function debuglog = options.Get(\"debuglog\").As<Napi::Function>();\n\n  // Join queue for worker thread\n  Napi::Function callback = info[size_t(1)].As<Napi::Function>();\n  StatsWorker *worker = new StatsWorker(callback, baton, debuglog);\n  worker->Receiver().Set(\"options\", options);\n  worker->Queue();\n\n  // Increment queued task counter\n  sharp::counterQueue++;\n\n  return info.Env().Undefined();\n}\n"
        }
    ]
}