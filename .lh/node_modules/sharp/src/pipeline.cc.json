{
    "sourceFile": "node_modules/sharp/src/pipeline.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <algorithm>\n#include <cmath>\n#include <filesystem>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <vips/vips8>\n#include <napi.h>\n\n#include \"common.h\"\n#include \"operations.h\"\n#include \"pipeline.h\"\n\nclass PipelineWorker : public Napi::AsyncWorker {\n public:\n  PipelineWorker(Napi::Function callback, PipelineBaton *baton,\n    Napi::Function debuglog, Napi::Function queueListener) :\n    Napi::AsyncWorker(callback),\n    baton(baton),\n    debuglog(Napi::Persistent(debuglog)),\n    queueListener(Napi::Persistent(queueListener)) {}\n  ~PipelineWorker() {}\n\n  // libuv worker\n  void Execute() {\n    // Decrement queued task counter\n    sharp::counterQueue--;\n    // Increment processing task counter\n    sharp::counterProcess++;\n\n    try {\n      // Open input\n      vips::VImage image;\n      sharp::ImageType inputImageType;\n      if (baton->join.empty()) {\n        std::tie(image, inputImageType) = sharp::OpenInput(baton->input);\n      } else {\n        std::vector<VImage> images;\n        bool hasAlpha = false;\n        for (auto &join : baton->join) {\n          std::tie(image, inputImageType) = sharp::OpenInput(join);\n          image = sharp::EnsureColourspace(image, baton->colourspacePipeline);\n          images.push_back(image);\n          hasAlpha |= image.has_alpha();\n        }\n        if (hasAlpha) {\n          for (auto &image : images) {\n            if (!image.has_alpha()) {\n              image = sharp::EnsureAlpha(image, 1);\n            }\n          }\n        } else {\n          baton->input->joinBackground.pop_back();\n        }\n        inputImageType = sharp::ImageType::PNG;\n        image = VImage::arrayjoin(images, VImage::option()\n          ->set(\"across\", baton->input->joinAcross)\n          ->set(\"shim\", baton->input->joinShim)\n          ->set(\"background\", baton->input->joinBackground)\n          ->set(\"halign\", baton->input->joinHalign)\n          ->set(\"valign\", baton->input->joinValign));\n        if (baton->input->joinAnimated) {\n          image = image.copy();\n          image.set(VIPS_META_N_PAGES, static_cast<int>(images.size()));\n          image.set(VIPS_META_PAGE_HEIGHT, static_cast<int>(image.height() / images.size()));\n        }\n      }\n      VipsAccess access = baton->input->access;\n      image = sharp::EnsureColourspace(image, baton->colourspacePipeline);\n\n      int nPages = baton->input->pages;\n      if (nPages == -1) {\n        // Resolve the number of pages if we need to render until the end of the document\n        nPages = image.get_typeof(VIPS_META_N_PAGES) != 0\n          ? image.get_int(VIPS_META_N_PAGES) - baton->input->page\n          : 1;\n      }\n\n      // Get pre-resize page height\n      int pageHeight = sharp::GetPageHeight(image);\n\n      // Calculate angle of rotation\n      VipsAngle rotation = VIPS_ANGLE_D0;\n      VipsAngle autoRotation = VIPS_ANGLE_D0;\n      bool autoFlip = false;\n      bool autoFlop = false;\n\n      if (baton->input->autoOrient) {\n        // Rotate and flip image according to Exif orientation\n        std::tie(autoRotation, autoFlip, autoFlop) = CalculateExifRotationAndFlip(sharp::ExifOrientation(image));\n        image = sharp::RemoveExifOrientation(image);\n      }\n\n      rotation = CalculateAngleRotation(baton->angle);\n\n      // Rotate pre-extract\n      bool const shouldRotateBefore = baton->rotateBeforePreExtract &&\n        (rotation != VIPS_ANGLE_D0 || autoRotation != VIPS_ANGLE_D0 ||\n          autoFlip || baton->flip || autoFlop || baton->flop ||\n          baton->rotationAngle != 0.0);\n\n      if (shouldRotateBefore) {\n        image = sharp::StaySequential(image,\n          rotation != VIPS_ANGLE_D0 ||\n          autoRotation != VIPS_ANGLE_D0 ||\n          autoFlip ||\n          baton->flip ||\n          baton->rotationAngle != 0.0);\n\n        if (autoRotation != VIPS_ANGLE_D0) {\n          if (autoRotation != VIPS_ANGLE_D180) {\n            MultiPageUnsupported(nPages, \"Rotate\");\n          }\n          image = image.rot(autoRotation);\n          autoRotation = VIPS_ANGLE_D0;\n        }\n        if (autoFlip != baton->flip) {\n          image = image.flip(VIPS_DIRECTION_VERTICAL);\n          autoFlip = false;\n          baton->flip = false;\n        }\n        if (autoFlop != baton->flop) {\n          image = image.flip(VIPS_DIRECTION_HORIZONTAL);\n          autoFlop = false;\n          baton->flop = false;\n        }\n        if (rotation != VIPS_ANGLE_D0) {\n          if (rotation != VIPS_ANGLE_D180) {\n            MultiPageUnsupported(nPages, \"Rotate\");\n          }\n          image = image.rot(rotation);\n          rotation = VIPS_ANGLE_D0;\n        }\n        if (baton->rotationAngle != 0.0) {\n          MultiPageUnsupported(nPages, \"Rotate\");\n          std::vector<double> background;\n          std::tie(image, background) = sharp::ApplyAlpha(image, baton->rotationBackground, false);\n          image = image.rotate(baton->rotationAngle, VImage::option()->set(\"background\", background)).copy_memory();\n        }\n      }\n\n      // Trim\n      if (baton->trimThreshold >= 0.0) {\n        MultiPageUnsupported(nPages, \"Trim\");\n        image = sharp::StaySequential(image);\n        image = sharp::Trim(image, baton->trimBackground, baton->trimThreshold, baton->trimLineArt);\n        baton->trimOffsetLeft = image.xoffset();\n        baton->trimOffsetTop = image.yoffset();\n      }\n\n      // Pre extraction\n      if (baton->topOffsetPre != -1) {\n        image = nPages > 1\n          ? sharp::CropMultiPage(image,\n              baton->leftOffsetPre, baton->topOffsetPre, baton->widthPre, baton->heightPre, nPages, &pageHeight)\n          : image.extract_area(baton->leftOffsetPre, baton->topOffsetPre, baton->widthPre, baton->heightPre);\n      }\n\n      // Get pre-resize image width and height\n      int inputWidth = image.width();\n      int inputHeight = image.height();\n\n      // Is there just one page? Shrink to inputHeight instead\n      if (nPages == 1) {\n        pageHeight = inputHeight;\n      }\n\n      // Scaling calculations\n      double hshrink;\n      double vshrink;\n      int targetResizeWidth = baton->width;\n      int targetResizeHeight = baton->height;\n\n      // When auto-rotating by 90 or 270 degrees, swap the target width and\n      // height to ensure the behavior aligns with how it would have been if\n      // the rotation had taken place *before* resizing.\n      if (!baton->rotateBeforePreExtract &&\n        (autoRotation == VIPS_ANGLE_D90 || autoRotation == VIPS_ANGLE_D270)) {\n        std::swap(targetResizeWidth, targetResizeHeight);\n      }\n\n      // Shrink to pageHeight, so we work for multi-page images\n      std::tie(hshrink, vshrink) = sharp::ResolveShrink(\n        inputWidth, pageHeight, targetResizeWidth, targetResizeHeight,\n        baton->canvas, baton->withoutEnlargement, baton->withoutReduction);\n\n      // The jpeg preload shrink.\n      int jpegShrinkOnLoad = 1;\n\n      // WebP, PDF, SVG scale\n      double scale = 1.0;\n\n      // Try to reload input using shrink-on-load for JPEG, WebP, SVG and PDF, when:\n      //  - the width or height parameters are specified;\n      //  - gamma correction doesn't need to be applied;\n      //  - trimming or pre-resize extract isn't required;\n      //  - input colourspace is not specified;\n      bool const shouldPreShrink = (targetResizeWidth > 0 || targetResizeHeight > 0) &&\n        baton->gamma == 0 && baton->topOffsetPre == -1 && baton->trimThreshold < 0.0 &&\n        baton->colourspacePipeline == VIPS_INTERPRETATION_LAST && !shouldRotateBefore;\n\n      if (shouldPreShrink) {\n        // The common part of the shrink: the bit by which both axes must be shrunk\n        double shrink = std::min(hshrink, vshrink);\n\n        if (inputImageType == sharp::ImageType::JPEG) {\n          // Leave at least a factor of two for the final resize step, when fastShrinkOnLoad: false\n          // for more consistent results and to avoid extra sharpness to the image\n          int factor = baton->fastShrinkOnLoad ? 1 : 2;\n          if (shrink >= 8 * factor) {\n            jpegShrinkOnLoad = 8;\n          } else if (shrink >= 4 * factor) {\n            jpegShrinkOnLoad = 4;\n          } else if (shrink >= 2 * factor) {\n            jpegShrinkOnLoad = 2;\n          }\n          // Lower shrink-on-load for known libjpeg rounding errors\n          if (jpegShrinkOnLoad > 1 && static_cast<int>(shrink) == jpegShrinkOnLoad) {\n            jpegShrinkOnLoad /= 2;\n          }\n        } else if (inputImageType == sharp::ImageType::WEBP && baton->fastShrinkOnLoad && shrink > 1.0) {\n          // Avoid upscaling via webp\n          scale = 1.0 / shrink;\n        } else if (inputImageType == sharp::ImageType::SVG ||\n                   inputImageType == sharp::ImageType::PDF) {\n          scale = 1.0 / shrink;\n        }\n      }\n\n      // Reload input using shrink-on-load, it'll be an integer shrink\n      // factor for jpegload*, a double scale factor for webpload*,\n      // pdfload* and svgload*\n      if (jpegShrinkOnLoad > 1) {\n        vips::VOption *option = VImage::option()\n          ->set(\"access\", access)\n          ->set(\"shrink\", jpegShrinkOnLoad)\n          ->set(\"unlimited\", baton->input->unlimited)\n          ->set(\"fail_on\", baton->input->failOn);\n        if (baton->input->buffer != nullptr) {\n          // Reload JPEG buffer\n          VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);\n          image = VImage::jpegload_buffer(blob, option);\n          vips_area_unref(reinterpret_cast<VipsArea*>(blob));\n        } else {\n          // Reload JPEG file\n          image = VImage::jpegload(const_cast<char*>(baton->input->file.data()), option);\n        }\n      } else if (scale != 1.0) {\n        vips::VOption *option = VImage::option()\n          ->set(\"access\", access)\n          ->set(\"scale\", scale)\n          ->set(\"fail_on\", baton->input->failOn);\n        if (inputImageType == sharp::ImageType::WEBP) {\n          option->set(\"n\", baton->input->pages);\n          option->set(\"page\", baton->input->page);\n\n          if (baton->input->buffer != nullptr) {\n            // Reload WebP buffer\n            VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);\n            image = VImage::webpload_buffer(blob, option);\n            vips_area_unref(reinterpret_cast<VipsArea*>(blob));\n          } else {\n            // Reload WebP file\n            image = VImage::webpload(const_cast<char*>(baton->input->file.data()), option);\n          }\n        } else if (inputImageType == sharp::ImageType::SVG) {\n          option->set(\"unlimited\", baton->input->unlimited);\n          option->set(\"dpi\", baton->input->density);\n\n          if (baton->input->buffer != nullptr) {\n            // Reload SVG buffer\n            VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);\n            image = VImage::svgload_buffer(blob, option);\n            vips_area_unref(reinterpret_cast<VipsArea*>(blob));\n          } else {\n            // Reload SVG file\n            image = VImage::svgload(const_cast<char*>(baton->input->file.data()), option);\n          }\n          sharp::SetDensity(image, baton->input->density);\n          if (image.width() > 32767 || image.height() > 32767) {\n            throw vips::VError(\"Input SVG image will exceed 32767x32767 pixel limit when scaled\");\n          }\n        } else if (inputImageType == sharp::ImageType::PDF) {\n          option->set(\"n\", baton->input->pages);\n          option->set(\"page\", baton->input->page);\n          option->set(\"dpi\", baton->input->density);\n\n          if (baton->input->buffer != nullptr) {\n            // Reload PDF buffer\n            VipsBlob *blob = vips_blob_new(nullptr, baton->input->buffer, baton->input->bufferLength);\n            image = VImage::pdfload_buffer(blob, option);\n            vips_area_unref(reinterpret_cast<VipsArea*>(blob));\n          } else {\n            // Reload PDF file\n            image = VImage::pdfload(const_cast<char*>(baton->input->file.data()), option);\n          }\n\n          sharp::SetDensity(image, baton->input->density);\n        }\n      } else {\n        if (inputImageType == sharp::ImageType::SVG && (image.width() > 32767 || image.height() > 32767)) {\n          throw vips::VError(\"Input SVG image exceeds 32767x32767 pixel limit\");\n        }\n      }\n\n      // Any pre-shrinking may already have been done\n      inputWidth = image.width();\n      inputHeight = image.height();\n\n      // After pre-shrink, but before the main shrink stage\n      // Reuse the initial pageHeight if we didn't pre-shrink\n      if (shouldPreShrink) {\n        pageHeight = sharp::GetPageHeight(image);\n      }\n\n      // Shrink to pageHeight, so we work for multi-page images\n      std::tie(hshrink, vshrink) = sharp::ResolveShrink(\n        inputWidth, pageHeight, targetResizeWidth, targetResizeHeight,\n        baton->canvas, baton->withoutEnlargement, baton->withoutReduction);\n\n      int targetHeight = static_cast<int>(std::rint(static_cast<double>(pageHeight) / vshrink));\n      int targetPageHeight = targetHeight;\n\n      // In toilet-roll mode, we must adjust vshrink so that we exactly hit\n      // pageHeight or we'll have pixels straddling pixel boundaries\n      if (inputHeight > pageHeight) {\n        targetHeight *= nPages;\n        vshrink = static_cast<double>(inputHeight) / targetHeight;\n      }\n\n      // Ensure we're using a device-independent colour space\n      std::pair<char*, size_t> inputProfile(nullptr, 0);\n      if ((baton->keepMetadata & VIPS_FOREIGN_KEEP_ICC) && baton->withIccProfile.empty()) {\n        // Cache input profile for use with output\n        inputProfile = sharp::GetProfile(image);\n        baton->input->ignoreIcc = true;\n      }\n      char const *processingProfile = image.interpretation() == VIPS_INTERPRETATION_RGB16 ? \"p3\" : \"srgb\";\n      if (\n        sharp::HasProfile(image) &&\n        image.interpretation() != VIPS_INTERPRETATION_LABS &&\n        image.interpretation() != VIPS_INTERPRETATION_GREY16 &&\n        baton->colourspacePipeline != VIPS_INTERPRETATION_CMYK &&\n        !baton->input->ignoreIcc\n      ) {\n        // Convert to sRGB/P3 using embedded profile\n        try {\n          image = image.icc_transform(processingProfile, VImage::option()\n            ->set(\"embedded\", true)\n            ->set(\"depth\", sharp::Is16Bit(image.interpretation()) ? 16 : 8)\n            ->set(\"intent\", VIPS_INTENT_PERCEPTUAL));\n        } catch(...) {\n          sharp::VipsWarningCallback(nullptr, G_LOG_LEVEL_WARNING, \"Invalid embedded profile\", nullptr);\n        }\n      } else if (\n        image.interpretation() == VIPS_INTERPRETATION_CMYK &&\n        baton->colourspacePipeline != VIPS_INTERPRETATION_CMYK\n      ) {\n        image = image.icc_transform(processingProfile, VImage::option()\n          ->set(\"input_profile\", \"cmyk\")\n          ->set(\"intent\", VIPS_INTENT_PERCEPTUAL));\n      }\n\n      // Flatten image to remove alpha channel\n      if (baton->flatten && image.has_alpha()) {\n        image = sharp::Flatten(image, baton->flattenBackground);\n      }\n\n      // Gamma encoding (darken)\n      if (baton->gamma >= 1 && baton->gamma <= 3) {\n        image = sharp::Gamma(image, 1.0 / baton->gamma);\n      }\n\n      // Convert to greyscale (linear, therefore after gamma encoding, if any)\n      if (baton->greyscale) {\n        image = image.colourspace(VIPS_INTERPRETATION_B_W);\n      }\n\n      bool const shouldResize = hshrink != 1.0 || vshrink != 1.0;\n      bool const shouldBlur = baton->blurSigma != 0.0;\n      bool const shouldConv = baton->convKernelWidth * baton->convKernelHeight > 0;\n      bool const shouldSharpen = baton->sharpenSigma != 0.0;\n      bool const shouldComposite = !baton->composite.empty();\n\n      if (shouldComposite && !image.has_alpha()) {\n        image = sharp::EnsureAlpha(image, 1);\n      }\n\n      VipsBandFormat premultiplyFormat = image.format();\n      bool const shouldPremultiplyAlpha = image.has_alpha() &&\n        (shouldResize || shouldBlur || shouldConv || shouldSharpen);\n\n      if (shouldPremultiplyAlpha) {\n        image = image.premultiply().cast(premultiplyFormat);\n      }\n\n      // Resize\n      if (shouldResize) {\n        image = image.resize(1.0 / hshrink, VImage::option()\n          ->set(\"vscale\", 1.0 / vshrink)\n          ->set(\"kernel\", baton->kernel));\n      }\n\n      image = sharp::StaySequential(image,\n        autoRotation != VIPS_ANGLE_D0 ||\n        baton->flip ||\n        autoFlip ||\n        rotation != VIPS_ANGLE_D0);\n      // Auto-rotate post-extract\n      if (autoRotation != VIPS_ANGLE_D0) {\n        if (autoRotation != VIPS_ANGLE_D180) {\n          MultiPageUnsupported(nPages, \"Rotate\");\n        }\n        image = image.rot(autoRotation);\n      }\n      // Mirror vertically (up-down) about the x-axis\n      if (baton->flip != autoFlip) {\n        image = image.flip(VIPS_DIRECTION_VERTICAL);\n      }\n      // Mirror horizontally (left-right) about the y-axis\n      if (baton->flop != autoFlop) {\n        image = image.flip(VIPS_DIRECTION_HORIZONTAL);\n      }\n      // Rotate post-extract 90-angle\n      if (rotation != VIPS_ANGLE_D0) {\n        if (rotation != VIPS_ANGLE_D180) {\n          MultiPageUnsupported(nPages, \"Rotate\");\n        }\n        image = image.rot(rotation);\n      }\n\n      // Join additional color channels to the image\n      if (!baton->joinChannelIn.empty()) {\n        VImage joinImage;\n        sharp::ImageType joinImageType = sharp::ImageType::UNKNOWN;\n\n        for (unsigned int i = 0; i < baton->joinChannelIn.size(); i++) {\n          baton->joinChannelIn[i]->access = access;\n          std::tie(joinImage, joinImageType) = sharp::OpenInput(baton->joinChannelIn[i]);\n          joinImage = sharp::EnsureColourspace(joinImage, baton->colourspacePipeline);\n          image = image.bandjoin(joinImage);\n        }\n        image = image.copy(VImage::option()->set(\"interpretation\", baton->colourspace));\n        image = sharp::RemoveGifPalette(image);\n      }\n\n      inputWidth = image.width();\n      inputHeight = nPages > 1 ? targetPageHeight : image.height();\n\n      // Resolve dimensions\n      if (baton->width <= 0) {\n        baton->width = inputWidth;\n      }\n      if (baton->height <= 0) {\n        baton->height = inputHeight;\n      }\n\n      // Crop/embed\n      if (inputWidth != baton->width || inputHeight != baton->height) {\n        if (baton->canvas == sharp::Canvas::EMBED) {\n          std::vector<double> background;\n          std::tie(image, background) = sharp::ApplyAlpha(image, baton->resizeBackground, shouldPremultiplyAlpha);\n\n          // Embed\n          int left;\n          int top;\n          std::tie(left, top) = sharp::CalculateEmbedPosition(\n            inputWidth, inputHeight, baton->width, baton->height, baton->position);\n          int width = std::max(inputWidth, baton->width);\n          int height = std::max(inputHeight, baton->height);\n\n          image = nPages > 1\n            ? sharp::EmbedMultiPage(image,\n                left, top, width, height, VIPS_EXTEND_BACKGROUND, background, nPages, &targetPageHeight)\n            : image.embed(left, top, width, height, VImage::option()\n              ->set(\"extend\", VIPS_EXTEND_BACKGROUND)\n              ->set(\"background\", background));\n        } else if (baton->canvas == sharp::Canvas::CROP) {\n          if (baton->width > inputWidth) {\n            baton->width = inputWidth;\n          }\n          if (baton->height > inputHeight) {\n            baton->height = inputHeight;\n          }\n\n          // Crop\n          if (baton->position < 9) {\n            // Gravity-based crop\n            int left;\n            int top;\n\n            std::tie(left, top) = sharp::CalculateCrop(\n              inputWidth, inputHeight, baton->width, baton->height, baton->position);\n            int width = std::min(inputWidth, baton->width);\n            int height = std::min(inputHeight, baton->height);\n\n            image = nPages > 1\n              ? sharp::CropMultiPage(image,\n                  left, top, width, height, nPages, &targetPageHeight)\n              : image.extract_area(left, top, width, height);\n          } else {\n            int attention_x;\n            int attention_y;\n\n            // Attention-based or Entropy-based crop\n            MultiPageUnsupported(nPages, \"Resize strategy\");\n            image = sharp::StaySequential(image);\n            image = image.smartcrop(baton->width, baton->height, VImage::option()\n              ->set(\"interesting\", baton->position == 16 ? VIPS_INTERESTING_ENTROPY : VIPS_INTERESTING_ATTENTION)\n              ->set(\"premultiplied\", shouldPremultiplyAlpha)\n              ->set(\"attention_x\", &attention_x)\n              ->set(\"attention_y\", &attention_y));\n            baton->hasCropOffset = true;\n            baton->cropOffsetLeft = static_cast<int>(image.xoffset());\n            baton->cropOffsetTop = static_cast<int>(image.yoffset());\n            baton->hasAttentionCenter = true;\n            baton->attentionX = static_cast<int>(attention_x * jpegShrinkOnLoad / scale);\n            baton->attentionY = static_cast<int>(attention_y * jpegShrinkOnLoad / scale);\n          }\n        }\n      }\n\n      // Rotate post-extract non-90 angle\n      if (!baton->rotateBeforePreExtract && baton->rotationAngle != 0.0) {\n        MultiPageUnsupported(nPages, \"Rotate\");\n        image = sharp::StaySequential(image);\n        std::vector<double> background;\n        std::tie(image, background) = sharp::ApplyAlpha(image, baton->rotationBackground, shouldPremultiplyAlpha);\n        image = image.rotate(baton->rotationAngle, VImage::option()->set(\"background\", background));\n      }\n\n      // Post extraction\n      if (baton->topOffsetPost != -1) {\n        if (nPages > 1) {\n          image = sharp::CropMultiPage(image,\n            baton->leftOffsetPost, baton->topOffsetPost, baton->widthPost, baton->heightPost,\n            nPages, &targetPageHeight);\n\n          // heightPost is used in the info object, so update to reflect the number of pages\n          baton->heightPost *= nPages;\n        } else {\n          image = image.extract_area(\n            baton->leftOffsetPost, baton->topOffsetPost, baton->widthPost, baton->heightPost);\n        }\n      }\n\n      // Affine transform\n      if (!baton->affineMatrix.empty()) {\n        MultiPageUnsupported(nPages, \"Affine\");\n        image = sharp::StaySequential(image);\n        std::vector<double> background;\n        std::tie(image, background) = sharp::ApplyAlpha(image, baton->affineBackground, shouldPremultiplyAlpha);\n        vips::VInterpolate interp = vips::VInterpolate::new_from_name(\n          const_cast<char*>(baton->affineInterpolator.data()));\n        image = image.affine(baton->affineMatrix, VImage::option()->set(\"background\", background)\n          ->set(\"idx\", baton->affineIdx)\n          ->set(\"idy\", baton->affineIdy)\n          ->set(\"odx\", baton->affineOdx)\n          ->set(\"ody\", baton->affineOdy)\n          ->set(\"interpolate\", interp));\n      }\n\n      // Extend edges\n      if (baton->extendTop > 0 || baton->extendBottom > 0 || baton->extendLeft > 0 || baton->extendRight > 0) {\n        // Embed\n        baton->width = image.width() + baton->extendLeft + baton->extendRight;\n        baton->height = (nPages > 1 ? targetPageHeight : image.height()) + baton->extendTop + baton->extendBottom;\n\n        if (baton->extendWith == VIPS_EXTEND_BACKGROUND) {\n          std::vector<double> background;\n          std::tie(image, background) = sharp::ApplyAlpha(image, baton->extendBackground, shouldPremultiplyAlpha);\n\n          image = sharp::StaySequential(image, nPages > 1);\n          image = nPages > 1\n            ? sharp::EmbedMultiPage(image,\n                baton->extendLeft, baton->extendTop, baton->width, baton->height,\n                baton->extendWith, background, nPages, &targetPageHeight)\n            : image.embed(baton->extendLeft, baton->extendTop, baton->width, baton->height,\n                VImage::option()->set(\"extend\", baton->extendWith)->set(\"background\", background));\n        } else {\n          std::vector<double> ignoredBackground(1);\n          image = sharp::StaySequential(image);\n          image = nPages > 1\n            ? sharp::EmbedMultiPage(image,\n                baton->extendLeft, baton->extendTop, baton->width, baton->height,\n                baton->extendWith, ignoredBackground, nPages, &targetPageHeight)\n            : image.embed(baton->extendLeft, baton->extendTop, baton->width, baton->height,\n                VImage::option()->set(\"extend\", baton->extendWith));\n        }\n      }\n      // Median - must happen before blurring, due to the utility of blurring after thresholding\n      if (baton->medianSize > 0) {\n        image = image.median(baton->medianSize);\n      }\n\n      // Threshold - must happen before blurring, due to the utility of blurring after thresholding\n      // Threshold - must happen before unflatten to enable non-white unflattening\n      if (baton->threshold != 0) {\n        image = sharp::Threshold(image, baton->threshold, baton->thresholdGrayscale);\n      }\n\n      // Dilate - must happen before blurring, due to the utility of dilating after thresholding\n      if (baton->dilateWidth != 0) {\n        image = sharp::Dilate(image, baton->dilateWidth);\n      }\n\n      // Erode - must happen before blurring, due to the utility of eroding after thresholding\n      if (baton->erodeWidth != 0) {\n        image = sharp::Erode(image, baton->erodeWidth);\n      }\n\n      // Blur\n      if (shouldBlur) {\n        image = sharp::Blur(image, baton->blurSigma, baton->precision, baton->minAmpl);\n      }\n\n      // Unflatten the image\n      if (baton->unflatten) {\n        image = sharp::Unflatten(image);\n      }\n\n      // Convolve\n      if (shouldConv) {\n        image = sharp::Convolve(image,\n          baton->convKernelWidth, baton->convKernelHeight,\n          baton->convKernelScale, baton->convKernelOffset,\n          baton->convKernel);\n      }\n\n      // Recomb\n      if (!baton->recombMatrix.empty()) {\n        image = sharp::Recomb(image, baton->recombMatrix);\n      }\n\n      // Modulate\n      if (baton->brightness != 1.0 || baton->saturation != 1.0 || baton->hue != 0.0 || baton->lightness != 0.0) {\n        image = sharp::Modulate(image, baton->brightness, baton->saturation, baton->hue, baton->lightness);\n      }\n\n      // Sharpen\n      if (shouldSharpen) {\n        image = sharp::Sharpen(image, baton->sharpenSigma, baton->sharpenM1, baton->sharpenM2,\n          baton->sharpenX1, baton->sharpenY2, baton->sharpenY3);\n      }\n\n      // Reverse premultiplication after all transformations\n      if (shouldPremultiplyAlpha) {\n        image = image.unpremultiply().cast(premultiplyFormat);\n      }\n      baton->premultiplied = shouldPremultiplyAlpha;\n\n      // Composite\n      if (shouldComposite) {\n        std::vector<VImage> images = { image };\n        std::vector<int> modes, xs, ys;\n        for (Composite *composite : baton->composite) {\n          VImage compositeImage;\n          sharp::ImageType compositeImageType = sharp::ImageType::UNKNOWN;\n          composite->input->access = access;\n          std::tie(compositeImage, compositeImageType) = sharp::OpenInput(composite->input);\n          compositeImage = sharp::EnsureColourspace(compositeImage, baton->colourspacePipeline);\n\n          if (composite->input->autoOrient) {\n            // Respect EXIF Orientation\n            VipsAngle compositeAutoRotation = VIPS_ANGLE_D0;\n            bool compositeAutoFlip = false;\n            bool compositeAutoFlop = false;\n            std::tie(compositeAutoRotation, compositeAutoFlip, compositeAutoFlop) =\n              CalculateExifRotationAndFlip(sharp::ExifOrientation(compositeImage));\n\n            compositeImage = sharp::RemoveExifOrientation(compositeImage);\n            compositeImage = sharp::StaySequential(compositeImage,\n              compositeAutoRotation != VIPS_ANGLE_D0 || compositeAutoFlip);\n\n            if (compositeAutoRotation != VIPS_ANGLE_D0) {\n              compositeImage = compositeImage.rot(compositeAutoRotation);\n            }\n            if (compositeAutoFlip) {\n              compositeImage = compositeImage.flip(VIPS_DIRECTION_VERTICAL);\n            }\n            if (compositeAutoFlop) {\n              compositeImage = compositeImage.flip(VIPS_DIRECTION_HORIZONTAL);\n            }\n          }\n\n          // Verify within current dimensions\n          if (compositeImage.width() > image.width() || compositeImage.height() > image.height()) {\n            throw vips::VError(\"Image to composite must have same dimensions or smaller\");\n          }\n          // Check if overlay is tiled\n          if (composite->tile) {\n            int across = 0;\n            int down = 0;\n            // Use gravity in overlay\n            if (compositeImage.width() <= image.width()) {\n              across = static_cast<int>(ceil(static_cast<double>(image.width()) / compositeImage.width()));\n              // Ensure odd number of tiles across when gravity is centre, north or south\n              if (composite->gravity == 0 || composite->gravity == 1 || composite->gravity == 3) {\n                across |= 1;\n              }\n            }\n            if (compositeImage.height() <= image.height()) {\n              down = static_cast<int>(ceil(static_cast<double>(image.height()) / compositeImage.height()));\n              // Ensure odd number of tiles down when gravity is centre, east or west\n              if (composite->gravity == 0 || composite->gravity == 2 || composite->gravity == 4) {\n                down |= 1;\n              }\n            }\n            if (across != 0 || down != 0) {\n              int left;\n              int top;\n              compositeImage = sharp::StaySequential(compositeImage).replicate(across, down);\n              if (composite->hasOffset) {\n                std::tie(left, top) = sharp::CalculateCrop(\n                  compositeImage.width(), compositeImage.height(), image.width(), image.height(),\n                  composite->left, composite->top);\n              } else {\n                std::tie(left, top) = sharp::CalculateCrop(\n                  compositeImage.width(), compositeImage.height(), image.width(), image.height(), composite->gravity);\n              }\n              compositeImage = compositeImage.extract_area(left, top, image.width(), image.height());\n            }\n            // gravity was used for extract_area, set it back to its default value of 0\n            composite->gravity = 0;\n          }\n          // Ensure image to composite is sRGB with unpremultiplied alpha\n          compositeImage = compositeImage.colourspace(VIPS_INTERPRETATION_sRGB);\n          compositeImage = sharp::EnsureAlpha(compositeImage, 1);\n          if (composite->premultiplied) compositeImage = compositeImage.unpremultiply();\n          // Calculate position\n          int left;\n          int top;\n          if (composite->hasOffset) {\n            // Composite image at given offsets\n            if (composite->tile) {\n              std::tie(left, top) = sharp::CalculateCrop(image.width(), image.height(),\n                compositeImage.width(), compositeImage.height(), composite->left, composite->top);\n            } else {\n              left = composite->left;\n              top = composite->top;\n            }\n          } else {\n            // Composite image with given gravity\n            std::tie(left, top) = sharp::CalculateCrop(image.width(), image.height(),\n              compositeImage.width(), compositeImage.height(), composite->gravity);\n          }\n          images.push_back(compositeImage);\n          modes.push_back(composite->mode);\n          xs.push_back(left);\n          ys.push_back(top);\n        }\n        image = VImage::composite(images, modes, VImage::option()->set(\"x\", xs)->set(\"y\", ys));\n        image = sharp::RemoveGifPalette(image);\n      }\n\n      // Gamma decoding (brighten)\n      if (baton->gammaOut >= 1 && baton->gammaOut <= 3) {\n        image = sharp::Gamma(image, baton->gammaOut);\n      }\n\n      // Linear adjustment (a * in + b)\n      if (!baton->linearA.empty()) {\n        image = sharp::Linear(image, baton->linearA, baton->linearB);\n      }\n\n      // Apply normalisation - stretch luminance to cover full dynamic range\n      if (baton->normalise) {\n        image = sharp::StaySequential(image);\n        image = sharp::Normalise(image, baton->normaliseLower, baton->normaliseUpper);\n      }\n\n      // Apply contrast limiting adaptive histogram equalization (CLAHE)\n      if (baton->claheWidth != 0 && baton->claheHeight != 0) {\n        image = sharp::StaySequential(image);\n        image = sharp::Clahe(image, baton->claheWidth, baton->claheHeight, baton->claheMaxSlope);\n      }\n\n      // Apply bitwise boolean operation between images\n      if (baton->boolean != nullptr) {\n        VImage booleanImage;\n        sharp::ImageType booleanImageType = sharp::ImageType::UNKNOWN;\n        baton->boolean->access = access;\n        std::tie(booleanImage, booleanImageType) = sharp::OpenInput(baton->boolean);\n        booleanImage = sharp::EnsureColourspace(booleanImage, baton->colourspacePipeline);\n        image = sharp::Boolean(image, booleanImage, baton->booleanOp);\n        image = sharp::RemoveGifPalette(image);\n      }\n\n      // Apply per-channel Bandbool bitwise operations after all other operations\n      if (baton->bandBoolOp >= VIPS_OPERATION_BOOLEAN_AND && baton->bandBoolOp < VIPS_OPERATION_BOOLEAN_LAST) {\n        image = sharp::Bandbool(image, baton->bandBoolOp);\n      }\n\n      // Tint the image\n      if (baton->tint[0] >= 0.0) {\n        image = sharp::Tint(image, baton->tint);\n      }\n\n      // Remove alpha channel, if any\n      if (baton->removeAlpha) {\n        image = sharp::RemoveAlpha(image);\n      }\n\n      // Ensure alpha channel, if missing\n      if (baton->ensureAlpha != -1) {\n        image = sharp::EnsureAlpha(image, baton->ensureAlpha);\n      }\n\n      // Convert image to sRGB, if not already\n      if (sharp::Is16Bit(image.interpretation())) {\n        image = image.cast(VIPS_FORMAT_USHORT);\n      }\n      if (image.interpretation() != baton->colourspace) {\n        // Convert colourspace, pass the current known interpretation so libvips doesn't have to guess\n        image = image.colourspace(baton->colourspace, VImage::option()->set(\"source_space\", image.interpretation()));\n        // Transform colours from embedded profile to output profile\n        if ((baton->keepMetadata & VIPS_FOREIGN_KEEP_ICC) && baton->colourspacePipeline != VIPS_INTERPRETATION_CMYK &&\n          baton->withIccProfile.empty() && sharp::HasProfile(image)) {\n          image = image.icc_transform(processingProfile, VImage::option()\n            ->set(\"embedded\", true)\n            ->set(\"depth\", sharp::Is16Bit(image.interpretation()) ? 16 : 8)\n            ->set(\"intent\", VIPS_INTENT_PERCEPTUAL));\n        }\n      }\n\n      // Extract channel\n      if (baton->extractChannel > -1) {\n        if (baton->extractChannel >= image.bands()) {\n          if (baton->extractChannel == 3 && image.has_alpha()) {\n            baton->extractChannel = image.bands() - 1;\n          } else {\n            (baton->err)\n              .append(\"Cannot extract channel \").append(std::to_string(baton->extractChannel))\n              .append(\" from image with channels 0-\").append(std::to_string(image.bands() - 1));\n            return Error();\n          }\n        }\n        VipsInterpretation colourspace = sharp::Is16Bit(image.interpretation())\n          ? VIPS_INTERPRETATION_GREY16\n          : VIPS_INTERPRETATION_B_W;\n        image = image\n          .extract_band(baton->extractChannel)\n          .copy(VImage::option()->set(\"interpretation\", colourspace));\n      }\n\n      // Apply output ICC profile\n      if (!baton->withIccProfile.empty()) {\n        try {\n          image = image.icc_transform(const_cast<char*>(baton->withIccProfile.data()), VImage::option()\n            ->set(\"input_profile\", processingProfile)\n            ->set(\"embedded\", true)\n            ->set(\"depth\", sharp::Is16Bit(image.interpretation()) ? 16 : 8)\n            ->set(\"intent\", VIPS_INTENT_PERCEPTUAL));\n        } catch(...) {\n          sharp::VipsWarningCallback(nullptr, G_LOG_LEVEL_WARNING, \"Invalid profile\", nullptr);\n        }\n      } else if (baton->keepMetadata & VIPS_FOREIGN_KEEP_ICC) {\n        image = sharp::SetProfile(image, inputProfile);\n      }\n\n      // Negate the colours in the image\n      if (baton->negate) {\n        image = sharp::Negate(image, baton->negateAlpha);\n      }\n\n      // Override EXIF Orientation tag\n      if (baton->withMetadataOrientation != -1) {\n        image = sharp::SetExifOrientation(image, baton->withMetadataOrientation);\n      }\n      // Override pixel density\n      if (baton->withMetadataDensity > 0) {\n        image = sharp::SetDensity(image, baton->withMetadataDensity);\n      }\n      // EXIF key/value pairs\n      if (baton->keepMetadata & VIPS_FOREIGN_KEEP_EXIF) {\n        image = image.copy();\n        if (!baton->withExifMerge) {\n          image = sharp::RemoveExif(image);\n        }\n        for (const auto& s : baton->withExif) {\n          image.set(s.first.data(), s.second.data());\n        }\n      }\n\n      // Number of channels used in output image\n      baton->channels = image.bands();\n      baton->width = image.width();\n      baton->height = image.height();\n\n      image = sharp::SetAnimationProperties(\n        image, nPages, targetPageHeight, baton->delay, baton->loop);\n\n      if (image.get_typeof(VIPS_META_PAGE_HEIGHT) == G_TYPE_INT) {\n        baton->pageHeightOut = image.get_int(VIPS_META_PAGE_HEIGHT);\n        baton->pagesOut = image.get_int(VIPS_META_N_PAGES);\n      }\n\n      // Output\n      sharp::SetTimeout(image, baton->timeoutSeconds);\n      if (baton->fileOut.empty()) {\n        // Buffer output\n        if (baton->formatOut == \"jpeg\" || (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::JPEG)) {\n          // Write JPEG to buffer\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::JPEG);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.jpegsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->jpegQuality)\n            ->set(\"interlace\", baton->jpegProgressive)\n            ->set(\"subsample_mode\", baton->jpegChromaSubsampling == \"4:4:4\"\n              ? VIPS_FOREIGN_SUBSAMPLE_OFF\n              : VIPS_FOREIGN_SUBSAMPLE_ON)\n            ->set(\"trellis_quant\", baton->jpegTrellisQuantisation)\n            ->set(\"quant_table\", baton->jpegQuantisationTable)\n            ->set(\"overshoot_deringing\", baton->jpegOvershootDeringing)\n            ->set(\"optimize_scans\", baton->jpegOptimiseScans)\n            ->set(\"optimize_coding\", baton->jpegOptimiseCoding)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"jpeg\";\n          if (baton->colourspace == VIPS_INTERPRETATION_CMYK) {\n            baton->channels = std::min(baton->channels, 4);\n          } else {\n            baton->channels = std::min(baton->channels, 3);\n          }\n        } else if (baton->formatOut == \"jp2\" || (baton->formatOut == \"input\"\n          && inputImageType == sharp::ImageType::JP2)) {\n          // Write JP2 to Buffer\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::JP2);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.jp2ksave_buffer(VImage::option()\n            ->set(\"Q\", baton->jp2Quality)\n            ->set(\"lossless\", baton->jp2Lossless)\n            ->set(\"subsample_mode\", baton->jp2ChromaSubsampling == \"4:4:4\"\n              ? VIPS_FOREIGN_SUBSAMPLE_OFF : VIPS_FOREIGN_SUBSAMPLE_ON)\n            ->set(\"tile_height\", baton->jp2TileHeight)\n            ->set(\"tile_width\", baton->jp2TileWidth)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"jp2\";\n        } else if (baton->formatOut == \"png\" || (baton->formatOut == \"input\" &&\n          (inputImageType == sharp::ImageType::PNG || inputImageType == sharp::ImageType::SVG))) {\n          // Write PNG to buffer\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::PNG);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.pngsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"interlace\", baton->pngProgressive)\n            ->set(\"compression\", baton->pngCompressionLevel)\n            ->set(\"filter\", baton->pngAdaptiveFiltering ? VIPS_FOREIGN_PNG_FILTER_ALL : VIPS_FOREIGN_PNG_FILTER_NONE)\n            ->set(\"palette\", baton->pngPalette)\n            ->set(\"Q\", baton->pngQuality)\n            ->set(\"effort\", baton->pngEffort)\n            ->set(\"bitdepth\", sharp::Is16Bit(image.interpretation()) ? 16 : baton->pngBitdepth)\n            ->set(\"dither\", baton->pngDither)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"png\";\n        } else if (baton->formatOut == \"webp\" ||\n          (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::WEBP)) {\n          // Write WEBP to buffer\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::WEBP);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.webpsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->webpQuality)\n            ->set(\"lossless\", baton->webpLossless)\n            ->set(\"near_lossless\", baton->webpNearLossless)\n            ->set(\"smart_subsample\", baton->webpSmartSubsample)\n            ->set(\"smart_deblock\", baton->webpSmartDeblock)\n            ->set(\"preset\", baton->webpPreset)\n            ->set(\"effort\", baton->webpEffort)\n            ->set(\"min_size\", baton->webpMinSize)\n            ->set(\"mixed\", baton->webpMixed)\n            ->set(\"alpha_q\", baton->webpAlphaQuality)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"webp\";\n        } else if (baton->formatOut == \"gif\" ||\n          (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::GIF)) {\n          // Write GIF to buffer\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::GIF);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.gifsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"bitdepth\", baton->gifBitdepth)\n            ->set(\"effort\", baton->gifEffort)\n            ->set(\"reuse\", baton->gifReuse)\n            ->set(\"interlace\", baton->gifProgressive)\n            ->set(\"interframe_maxerror\", baton->gifInterFrameMaxError)\n            ->set(\"interpalette_maxerror\", baton->gifInterPaletteMaxError)\n            ->set(\"dither\", baton->gifDither)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"gif\";\n        } else if (baton->formatOut == \"tiff\" ||\n          (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::TIFF)) {\n          // Write TIFF to buffer\n          if (baton->tiffCompression == VIPS_FOREIGN_TIFF_COMPRESSION_JPEG) {\n            sharp::AssertImageTypeDimensions(image, sharp::ImageType::JPEG);\n            baton->channels = std::min(baton->channels, 3);\n          }\n          // Cast pixel values to float, if required\n          if (baton->tiffPredictor == VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT) {\n            image = image.cast(VIPS_FORMAT_FLOAT);\n          }\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.tiffsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->tiffQuality)\n            ->set(\"bitdepth\", baton->tiffBitdepth)\n            ->set(\"compression\", baton->tiffCompression)\n            ->set(\"miniswhite\", baton->tiffMiniswhite)\n            ->set(\"predictor\", baton->tiffPredictor)\n            ->set(\"pyramid\", baton->tiffPyramid)\n            ->set(\"tile\", baton->tiffTile)\n            ->set(\"tile_height\", baton->tiffTileHeight)\n            ->set(\"tile_width\", baton->tiffTileWidth)\n            ->set(\"xres\", baton->tiffXres)\n            ->set(\"yres\", baton->tiffYres)\n            ->set(\"resunit\", baton->tiffResolutionUnit)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"tiff\";\n        } else if (baton->formatOut == \"heif\" ||\n          (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::HEIF)) {\n          // Write HEIF to buffer\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::HEIF);\n          image = sharp::RemoveAnimationProperties(image);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.heifsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->heifQuality)\n            ->set(\"compression\", baton->heifCompression)\n            ->set(\"effort\", baton->heifEffort)\n            ->set(\"bitdepth\", baton->heifBitdepth)\n            ->set(\"subsample_mode\", baton->heifChromaSubsampling == \"4:4:4\"\n              ? VIPS_FOREIGN_SUBSAMPLE_OFF : VIPS_FOREIGN_SUBSAMPLE_ON)\n            ->set(\"lossless\", baton->heifLossless)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"heif\";\n        } else if (baton->formatOut == \"dz\") {\n          // Write DZ to buffer\n          baton->tileContainer = VIPS_FOREIGN_DZ_CONTAINER_ZIP;\n          if (!image.has_alpha()) {\n            baton->tileBackground.pop_back();\n          }\n          image = sharp::StaySequential(image, baton->tileAngle != 0);\n          vips::VOption *options = BuildOptionsDZ(baton);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.dzsave_buffer(options));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"dz\";\n        } else if (baton->formatOut == \"jxl\" ||\n          (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::JXL)) {\n          // Write JXL to buffer\n          image = sharp::RemoveAnimationProperties(image);\n          VipsArea *area = reinterpret_cast<VipsArea*>(image.jxlsave_buffer(VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"distance\", baton->jxlDistance)\n            ->set(\"tier\", baton->jxlDecodingTier)\n            ->set(\"effort\", baton->jxlEffort)\n            ->set(\"lossless\", baton->jxlLossless)));\n          baton->bufferOut = static_cast<char*>(area->data);\n          baton->bufferOutLength = area->length;\n          area->free_fn = nullptr;\n          vips_area_unref(area);\n          baton->formatOut = \"jxl\";\n        } else if (baton->formatOut == \"raw\" ||\n          (baton->formatOut == \"input\" && inputImageType == sharp::ImageType::RAW)) {\n          // Write raw, uncompressed image data to buffer\n          if (baton->greyscale || image.interpretation() == VIPS_INTERPRETATION_B_W) {\n            // Extract first band for greyscale image\n            image = image[0];\n            baton->channels = 1;\n          }\n          if (image.format() != baton->rawDepth) {\n            // Cast pixels to requested format\n            image = image.cast(baton->rawDepth);\n          }\n          // Get raw image data\n          baton->bufferOut = static_cast<char*>(image.write_to_memory(&baton->bufferOutLength));\n          if (baton->bufferOut == nullptr) {\n            (baton->err).append(\"Could not allocate enough memory for raw output\");\n            return Error();\n          }\n          baton->formatOut = \"raw\";\n        } else {\n          // Unsupported output format\n          (baton->err).append(\"Unsupported output format \");\n          if (baton->formatOut == \"input\") {\n            (baton->err).append(\"when trying to match input format of \");\n            (baton->err).append(ImageTypeId(inputImageType));\n          } else {\n            (baton->err).append(baton->formatOut);\n          }\n          return Error();\n        }\n      } else {\n        // File output\n        bool const isJpeg = sharp::IsJpeg(baton->fileOut);\n        bool const isPng = sharp::IsPng(baton->fileOut);\n        bool const isWebp = sharp::IsWebp(baton->fileOut);\n        bool const isGif = sharp::IsGif(baton->fileOut);\n        bool const isTiff = sharp::IsTiff(baton->fileOut);\n        bool const isJp2 = sharp::IsJp2(baton->fileOut);\n        bool const isHeif = sharp::IsHeif(baton->fileOut);\n        bool const isJxl = sharp::IsJxl(baton->fileOut);\n        bool const isDz = sharp::IsDz(baton->fileOut);\n        bool const isDzZip = sharp::IsDzZip(baton->fileOut);\n        bool const isV = sharp::IsV(baton->fileOut);\n        bool const mightMatchInput = baton->formatOut == \"input\";\n        bool const willMatchInput = mightMatchInput &&\n         !(isJpeg || isPng || isWebp || isGif || isTiff || isJp2 || isHeif || isDz || isDzZip || isV);\n\n        if (baton->formatOut == \"jpeg\" || (mightMatchInput && isJpeg) ||\n          (willMatchInput && inputImageType == sharp::ImageType::JPEG)) {\n          // Write JPEG to file\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::JPEG);\n          image.jpegsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->jpegQuality)\n            ->set(\"interlace\", baton->jpegProgressive)\n            ->set(\"subsample_mode\", baton->jpegChromaSubsampling == \"4:4:4\"\n              ? VIPS_FOREIGN_SUBSAMPLE_OFF\n              : VIPS_FOREIGN_SUBSAMPLE_ON)\n            ->set(\"trellis_quant\", baton->jpegTrellisQuantisation)\n            ->set(\"quant_table\", baton->jpegQuantisationTable)\n            ->set(\"overshoot_deringing\", baton->jpegOvershootDeringing)\n            ->set(\"optimize_scans\", baton->jpegOptimiseScans)\n            ->set(\"optimize_coding\", baton->jpegOptimiseCoding));\n          baton->formatOut = \"jpeg\";\n          baton->channels = std::min(baton->channels, 3);\n        } else if (baton->formatOut == \"jp2\" || (mightMatchInput && isJp2) ||\n          (willMatchInput && (inputImageType == sharp::ImageType::JP2))) {\n          // Write JP2 to file\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::JP2);\n          image.jp2ksave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"Q\", baton->jp2Quality)\n            ->set(\"lossless\", baton->jp2Lossless)\n            ->set(\"subsample_mode\", baton->jp2ChromaSubsampling == \"4:4:4\"\n              ? VIPS_FOREIGN_SUBSAMPLE_OFF : VIPS_FOREIGN_SUBSAMPLE_ON)\n            ->set(\"tile_height\", baton->jp2TileHeight)\n            ->set(\"tile_width\", baton->jp2TileWidth));\n            baton->formatOut = \"jp2\";\n        } else if (baton->formatOut == \"png\" || (mightMatchInput && isPng) || (willMatchInput &&\n          (inputImageType == sharp::ImageType::PNG || inputImageType == sharp::ImageType::SVG))) {\n          // Write PNG to file\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::PNG);\n          image.pngsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"interlace\", baton->pngProgressive)\n            ->set(\"compression\", baton->pngCompressionLevel)\n            ->set(\"filter\", baton->pngAdaptiveFiltering ? VIPS_FOREIGN_PNG_FILTER_ALL : VIPS_FOREIGN_PNG_FILTER_NONE)\n            ->set(\"palette\", baton->pngPalette)\n            ->set(\"Q\", baton->pngQuality)\n            ->set(\"bitdepth\", sharp::Is16Bit(image.interpretation()) ? 16 : baton->pngBitdepth)\n            ->set(\"effort\", baton->pngEffort)\n            ->set(\"dither\", baton->pngDither));\n          baton->formatOut = \"png\";\n        } else if (baton->formatOut == \"webp\" || (mightMatchInput && isWebp) ||\n          (willMatchInput && inputImageType == sharp::ImageType::WEBP)) {\n          // Write WEBP to file\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::WEBP);\n          image.webpsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->webpQuality)\n            ->set(\"lossless\", baton->webpLossless)\n            ->set(\"near_lossless\", baton->webpNearLossless)\n            ->set(\"smart_subsample\", baton->webpSmartSubsample)\n            ->set(\"smart_deblock\", baton->webpSmartDeblock)\n            ->set(\"preset\", baton->webpPreset)\n            ->set(\"effort\", baton->webpEffort)\n            ->set(\"min_size\", baton->webpMinSize)\n            ->set(\"mixed\", baton->webpMixed)\n            ->set(\"alpha_q\", baton->webpAlphaQuality));\n          baton->formatOut = \"webp\";\n        } else if (baton->formatOut == \"gif\" || (mightMatchInput && isGif) ||\n          (willMatchInput && inputImageType == sharp::ImageType::GIF)) {\n          // Write GIF to file\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::GIF);\n          image.gifsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"bitdepth\", baton->gifBitdepth)\n            ->set(\"effort\", baton->gifEffort)\n            ->set(\"reuse\", baton->gifReuse)\n            ->set(\"interlace\", baton->gifProgressive)\n            ->set(\"dither\", baton->gifDither));\n          baton->formatOut = \"gif\";\n        } else if (baton->formatOut == \"tiff\" || (mightMatchInput && isTiff) ||\n          (willMatchInput && inputImageType == sharp::ImageType::TIFF)) {\n          // Write TIFF to file\n          if (baton->tiffCompression == VIPS_FOREIGN_TIFF_COMPRESSION_JPEG) {\n            sharp::AssertImageTypeDimensions(image, sharp::ImageType::JPEG);\n            baton->channels = std::min(baton->channels, 3);\n          }\n          // Cast pixel values to float, if required\n          if (baton->tiffPredictor == VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT) {\n            image = image.cast(VIPS_FORMAT_FLOAT);\n          }\n          image.tiffsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->tiffQuality)\n            ->set(\"bitdepth\", baton->tiffBitdepth)\n            ->set(\"compression\", baton->tiffCompression)\n            ->set(\"miniswhite\", baton->tiffMiniswhite)\n            ->set(\"predictor\", baton->tiffPredictor)\n            ->set(\"pyramid\", baton->tiffPyramid)\n            ->set(\"tile\", baton->tiffTile)\n            ->set(\"tile_height\", baton->tiffTileHeight)\n            ->set(\"tile_width\", baton->tiffTileWidth)\n            ->set(\"xres\", baton->tiffXres)\n            ->set(\"yres\", baton->tiffYres)\n            ->set(\"resunit\", baton->tiffResolutionUnit));\n          baton->formatOut = \"tiff\";\n        } else if (baton->formatOut == \"heif\" || (mightMatchInput && isHeif) ||\n          (willMatchInput && inputImageType == sharp::ImageType::HEIF)) {\n          // Write HEIF to file\n          sharp::AssertImageTypeDimensions(image, sharp::ImageType::HEIF);\n          image = sharp::RemoveAnimationProperties(image);\n          image.heifsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"Q\", baton->heifQuality)\n            ->set(\"compression\", baton->heifCompression)\n            ->set(\"effort\", baton->heifEffort)\n            ->set(\"bitdepth\", baton->heifBitdepth)\n            ->set(\"subsample_mode\", baton->heifChromaSubsampling == \"4:4:4\"\n              ? VIPS_FOREIGN_SUBSAMPLE_OFF : VIPS_FOREIGN_SUBSAMPLE_ON)\n            ->set(\"lossless\", baton->heifLossless));\n          baton->formatOut = \"heif\";\n        } else if (baton->formatOut == \"jxl\" || (mightMatchInput && isJxl) ||\n          (willMatchInput && inputImageType == sharp::ImageType::JXL)) {\n          // Write JXL to file\n          image = sharp::RemoveAnimationProperties(image);\n          image.jxlsave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata)\n            ->set(\"distance\", baton->jxlDistance)\n            ->set(\"tier\", baton->jxlDecodingTier)\n            ->set(\"effort\", baton->jxlEffort)\n            ->set(\"lossless\", baton->jxlLossless));\n          baton->formatOut = \"jxl\";\n        } else if (baton->formatOut == \"dz\" || isDz || isDzZip) {\n          // Write DZ to file\n          if (isDzZip) {\n            baton->tileContainer = VIPS_FOREIGN_DZ_CONTAINER_ZIP;\n          }\n          if (!image.has_alpha()) {\n            baton->tileBackground.pop_back();\n          }\n          image = sharp::StaySequential(image, baton->tileAngle != 0);\n          vips::VOption *options = BuildOptionsDZ(baton);\n          image.dzsave(const_cast<char*>(baton->fileOut.data()), options);\n          baton->formatOut = \"dz\";\n        } else if (baton->formatOut == \"v\" || (mightMatchInput && isV) ||\n          (willMatchInput && inputImageType == sharp::ImageType::VIPS)) {\n          // Write V to file\n          image.vipssave(const_cast<char*>(baton->fileOut.data()), VImage::option()\n            ->set(\"keep\", baton->keepMetadata));\n          baton->formatOut = \"v\";\n        } else {\n          // Unsupported output format\n          (baton->err).append(\"Unsupported output format \" + baton->fileOut);\n          return Error();\n        }\n      }\n    } catch (vips::VError const &err) {\n      char const *what = err.what();\n      if (what && what[0]) {\n        (baton->err).append(what);\n      } else {\n        (baton->err).append(\"Unknown error\");\n      }\n    }\n    // Clean up libvips' per-request data and threads\n    vips_error_clear();\n    vips_thread_shutdown();\n  }\n\n  void OnOK() {\n    Napi::Env env = Env();\n    Napi::HandleScope scope(env);\n\n    // Handle warnings\n    std::string warning = sharp::VipsWarningPop();\n    while (!warning.empty()) {\n      debuglog.Call(Receiver().Value(), { Napi::String::New(env, warning) });\n      warning = sharp::VipsWarningPop();\n    }\n\n    if (baton->err.empty()) {\n      int width = baton->width;\n      int height = baton->height;\n      if (baton->topOffsetPre != -1 && (baton->width == -1 || baton->height == -1)) {\n        width = baton->widthPre;\n        height = baton->heightPre;\n      }\n      if (baton->topOffsetPost != -1) {\n        width = baton->widthPost;\n        height = baton->heightPost;\n      }\n      // Info Object\n      Napi::Object info = Napi::Object::New(env);\n      info.Set(\"format\", baton->formatOut);\n      info.Set(\"width\", static_cast<uint32_t>(width));\n      info.Set(\"height\", static_cast<uint32_t>(height));\n      info.Set(\"channels\", static_cast<uint32_t>(baton->channels));\n      if (baton->formatOut == \"raw\") {\n        info.Set(\"depth\", vips_enum_nick(VIPS_TYPE_BAND_FORMAT, baton->rawDepth));\n      }\n      info.Set(\"premultiplied\", baton->premultiplied);\n      if (baton->hasCropOffset) {\n        info.Set(\"cropOffsetLeft\", static_cast<int32_t>(baton->cropOffsetLeft));\n        info.Set(\"cropOffsetTop\", static_cast<int32_t>(baton->cropOffsetTop));\n      }\n      if (baton->hasAttentionCenter) {\n        info.Set(\"attentionX\", static_cast<int32_t>(baton->attentionX));\n        info.Set(\"attentionY\", static_cast<int32_t>(baton->attentionY));\n      }\n      if (baton->trimThreshold >= 0.0) {\n        info.Set(\"trimOffsetLeft\", static_cast<int32_t>(baton->trimOffsetLeft));\n        info.Set(\"trimOffsetTop\", static_cast<int32_t>(baton->trimOffsetTop));\n      }\n      if (baton->input->textAutofitDpi) {\n        info.Set(\"textAutofitDpi\", static_cast<uint32_t>(baton->input->textAutofitDpi));\n      }\n      if (baton->pageHeightOut) {\n        info.Set(\"pageHeight\", static_cast<int32_t>(baton->pageHeightOut));\n        info.Set(\"pages\", static_cast<int32_t>(baton->pagesOut));\n      }\n\n      if (baton->bufferOutLength > 0) {\n        // Add buffer size to info\n        info.Set(\"size\", static_cast<uint32_t>(baton->bufferOutLength));\n        // Pass ownership of output data to Buffer instance\n        Napi::Buffer<char> data = Napi::Buffer<char>::NewOrCopy(env, static_cast<char*>(baton->bufferOut),\n          baton->bufferOutLength, sharp::FreeCallback);\n        Callback().Call(Receiver().Value(), { env.Null(), data, info });\n      } else {\n        // Add file size to info\n        if (baton->formatOut != \"dz\" || sharp::IsDzZip(baton->fileOut)) {\n          try {\n            uint32_t const size = static_cast<uint32_t>(std::filesystem::file_size(baton->fileOut));\n            info.Set(\"size\", size);\n          } catch (...) {}\n        }\n        Callback().Call(Receiver().Value(), { env.Null(), info });\n      }\n    } else {\n      Callback().Call(Receiver().Value(), { Napi::Error::New(env, sharp::TrimEnd(baton->err)).Value() });\n    }\n\n    // Delete baton\n    delete baton->input;\n    delete baton->boolean;\n    for (Composite *composite : baton->composite) {\n      delete composite->input;\n      delete composite;\n    }\n    for (sharp::InputDescriptor *input : baton->joinChannelIn) {\n      delete input;\n    }\n    for (sharp::InputDescriptor *input : baton->join) {\n      delete input;\n    }\n    delete baton;\n\n    // Decrement processing task counter\n    sharp::counterProcess--;\n    Napi::Number queueLength = Napi::Number::New(env, static_cast<int>(sharp::counterQueue));\n    queueListener.Call(Receiver().Value(), { queueLength });\n  }\n\n private:\n  PipelineBaton *baton;\n  Napi::FunctionReference debuglog;\n  Napi::FunctionReference queueListener;\n\n  void MultiPageUnsupported(int const pages, std::string op) {\n    if (pages > 1) {\n      throw vips::VError(op + \" is not supported for multi-page images\");\n    }\n  }\n\n  /*\n    Calculate the angle of rotation and need-to-flip for the given Exif orientation\n    By default, returns zero, i.e. no rotation.\n  */\n  std::tuple<VipsAngle, bool, bool>\n  CalculateExifRotationAndFlip(int const exifOrientation) {\n    VipsAngle rotate = VIPS_ANGLE_D0;\n    bool flip = false;\n    bool flop = false;\n    switch (exifOrientation) {\n      case 6: rotate = VIPS_ANGLE_D90; break;\n      case 3: rotate = VIPS_ANGLE_D180; break;\n      case 8: rotate = VIPS_ANGLE_D270; break;\n      case 2: flop = true; break;  // flop 1\n      case 7: flip = true; rotate = VIPS_ANGLE_D90; break;  // flip 6\n      case 4: flop = true; rotate = VIPS_ANGLE_D180; break;  // flop 3\n      case 5: flip = true; rotate = VIPS_ANGLE_D270; break;  // flip 8\n    }\n    return std::make_tuple(rotate, flip, flop);\n  }\n\n  /*\n    Calculate the rotation for the given angle.\n    Supports any positive or negative angle that is a multiple of 90.\n  */\n  VipsAngle\n  CalculateAngleRotation(int angle) {\n    angle = angle % 360;\n    if (angle < 0)\n      angle = 360 + angle;\n    switch (angle) {\n      case 90: return VIPS_ANGLE_D90;\n      case 180: return VIPS_ANGLE_D180;\n      case 270: return VIPS_ANGLE_D270;\n    }\n    return VIPS_ANGLE_D0;\n  }\n\n  /*\n    Assemble the suffix argument to dzsave, which is the format (by extname)\n    alongside comma-separated arguments to the corresponding `formatsave` vips\n    action.\n  */\n  std::string\n  AssembleSuffixString(std::string extname, std::vector<std::pair<std::string, std::string>> options) {\n    std::string argument;\n    for (auto const &option : options) {\n      if (!argument.empty()) {\n        argument += \",\";\n      }\n      argument += option.first + \"=\" + option.second;\n    }\n    return extname + \"[\" + argument + \"]\";\n  }\n\n  /*\n    Build VOption for dzsave\n  */\n  vips::VOption*\n  BuildOptionsDZ(PipelineBaton *baton) {\n    // Forward format options through suffix\n    std::string suffix;\n    if (baton->tileFormat == \"png\") {\n      std::vector<std::pair<std::string, std::string>> options {\n        {\"interlace\", baton->pngProgressive ? \"true\" : \"false\"},\n        {\"compression\", std::to_string(baton->pngCompressionLevel)},\n        {\"filter\", baton->pngAdaptiveFiltering ? \"all\" : \"none\"}\n      };\n      suffix = AssembleSuffixString(\".png\", options);\n    } else if (baton->tileFormat == \"webp\") {\n      std::vector<std::pair<std::string, std::string>> options {\n        {\"Q\", std::to_string(baton->webpQuality)},\n        {\"alpha_q\", std::to_string(baton->webpAlphaQuality)},\n        {\"lossless\", baton->webpLossless ? \"true\" : \"false\"},\n        {\"near_lossless\", baton->webpNearLossless ? \"true\" : \"false\"},\n        {\"smart_subsample\", baton->webpSmartSubsample ? \"true\" : \"false\"},\n        {\"smart_deblock\", baton->webpSmartDeblock ? \"true\" : \"false\"},\n        {\"preset\", vips_enum_nick(VIPS_TYPE_FOREIGN_WEBP_PRESET, baton->webpPreset)},\n        {\"min_size\", baton->webpMinSize ? \"true\" : \"false\"},\n        {\"mixed\", baton->webpMixed ? \"true\" : \"false\"},\n        {\"effort\", std::to_string(baton->webpEffort)}\n      };\n      suffix = AssembleSuffixString(\".webp\", options);\n    } else {\n      std::vector<std::pair<std::string, std::string>> options {\n        {\"Q\", std::to_string(baton->jpegQuality)},\n        {\"interlace\", baton->jpegProgressive ? \"true\" : \"false\"},\n        {\"subsample_mode\", baton->jpegChromaSubsampling == \"4:4:4\" ? \"off\" : \"on\"},\n        {\"trellis_quant\", baton->jpegTrellisQuantisation ? \"true\" : \"false\"},\n        {\"quant_table\", std::to_string(baton->jpegQuantisationTable)},\n        {\"overshoot_deringing\", baton->jpegOvershootDeringing ? \"true\": \"false\"},\n        {\"optimize_scans\", baton->jpegOptimiseScans ? \"true\": \"false\"},\n        {\"optimize_coding\", baton->jpegOptimiseCoding ? \"true\": \"false\"}\n      };\n      std::string extname = baton->tileLayout == VIPS_FOREIGN_DZ_LAYOUT_DZ ? \".jpeg\" : \".jpg\";\n      suffix = AssembleSuffixString(extname, options);\n    }\n    vips::VOption *options = VImage::option()\n      ->set(\"keep\", baton->keepMetadata)\n      ->set(\"tile_size\", baton->tileSize)\n      ->set(\"overlap\", baton->tileOverlap)\n      ->set(\"container\", baton->tileContainer)\n      ->set(\"layout\", baton->tileLayout)\n      ->set(\"suffix\", const_cast<char*>(suffix.data()))\n      ->set(\"angle\", CalculateAngleRotation(baton->tileAngle))\n      ->set(\"background\", baton->tileBackground)\n      ->set(\"centre\", baton->tileCentre)\n      ->set(\"id\", const_cast<char*>(baton->tileId.data()))\n      ->set(\"skip_blanks\", baton->tileSkipBlanks);\n    if (baton->tileDepth < VIPS_FOREIGN_DZ_DEPTH_LAST) {\n      options->set(\"depth\", baton->tileDepth);\n    }\n    if (!baton->tileBasename.empty()) {\n      options->set(\"basename\", const_cast<char*>(baton->tileBasename.data()));\n    }\n    return options;\n  }\n\n  /*\n    Clear all thread-local data.\n  */\n  void Error() {\n    // Clean up libvips' per-request data and threads\n    vips_error_clear();\n    vips_thread_shutdown();\n  }\n};\n\n/*\n  pipeline(options, output, callback)\n*/\nNapi::Value pipeline(const Napi::CallbackInfo& info) {\n  // V8 objects are converted to non-V8 types held in the baton struct\n  PipelineBaton *baton = new PipelineBaton;\n  Napi::Object options = info[size_t(0)].As<Napi::Object>();\n\n  // Input\n  baton->input = sharp::CreateInputDescriptor(options.Get(\"input\").As<Napi::Object>());\n  // Join images together\n  if (sharp::HasAttr(options, \"join\")) {\n    Napi::Array join = options.Get(\"join\").As<Napi::Array>();\n    for (unsigned int i = 0; i < join.Length(); i++) {\n      baton->join.push_back(\n        sharp::CreateInputDescriptor(join.Get(i).As<Napi::Object>()));\n    }\n  }\n  // Extract image options\n  baton->topOffsetPre = sharp::AttrAsInt32(options, \"topOffsetPre\");\n  baton->leftOffsetPre = sharp::AttrAsInt32(options, \"leftOffsetPre\");\n  baton->widthPre = sharp::AttrAsInt32(options, \"widthPre\");\n  baton->heightPre = sharp::AttrAsInt32(options, \"heightPre\");\n  baton->topOffsetPost = sharp::AttrAsInt32(options, \"topOffsetPost\");\n  baton->leftOffsetPost = sharp::AttrAsInt32(options, \"leftOffsetPost\");\n  baton->widthPost = sharp::AttrAsInt32(options, \"widthPost\");\n  baton->heightPost = sharp::AttrAsInt32(options, \"heightPost\");\n  // Output image dimensions\n  baton->width = sharp::AttrAsInt32(options, \"width\");\n  baton->height = sharp::AttrAsInt32(options, \"height\");\n  // Canvas option\n  std::string canvas = sharp::AttrAsStr(options, \"canvas\");\n  if (canvas == \"crop\") {\n    baton->canvas = sharp::Canvas::CROP;\n  } else if (canvas == \"embed\") {\n    baton->canvas = sharp::Canvas::EMBED;\n  } else if (canvas == \"max\") {\n    baton->canvas = sharp::Canvas::MAX;\n  } else if (canvas == \"min\") {\n    baton->canvas = sharp::Canvas::MIN;\n  } else if (canvas == \"ignore_aspect\") {\n    baton->canvas = sharp::Canvas::IGNORE_ASPECT;\n  }\n  // Composite\n  Napi::Array compositeArray = options.Get(\"composite\").As<Napi::Array>();\n  for (unsigned int i = 0; i < compositeArray.Length(); i++) {\n    Napi::Object compositeObject = compositeArray.Get(i).As<Napi::Object>();\n    Composite *composite = new Composite;\n    composite->input = sharp::CreateInputDescriptor(compositeObject.Get(\"input\").As<Napi::Object>());\n    composite->mode = sharp::AttrAsEnum<VipsBlendMode>(compositeObject, \"blend\", VIPS_TYPE_BLEND_MODE);\n    composite->gravity = sharp::AttrAsUint32(compositeObject, \"gravity\");\n    composite->left = sharp::AttrAsInt32(compositeObject, \"left\");\n    composite->top = sharp::AttrAsInt32(compositeObject, \"top\");\n    composite->hasOffset = sharp::AttrAsBool(compositeObject, \"hasOffset\");\n    composite->tile = sharp::AttrAsBool(compositeObject, \"tile\");\n    composite->premultiplied = sharp::AttrAsBool(compositeObject, \"premultiplied\");\n    baton->composite.push_back(composite);\n  }\n  // Resize options\n  baton->withoutEnlargement = sharp::AttrAsBool(options, \"withoutEnlargement\");\n  baton->withoutReduction = sharp::AttrAsBool(options, \"withoutReduction\");\n  baton->position = sharp::AttrAsInt32(options, \"position\");\n  baton->resizeBackground = sharp::AttrAsVectorOfDouble(options, \"resizeBackground\");\n  baton->kernel = sharp::AttrAsEnum<VipsKernel>(options, \"kernel\", VIPS_TYPE_KERNEL);\n  baton->fastShrinkOnLoad = sharp::AttrAsBool(options, \"fastShrinkOnLoad\");\n  // Join Channel Options\n  if (options.Has(\"joinChannelIn\")) {\n    Napi::Array joinChannelArray = options.Get(\"joinChannelIn\").As<Napi::Array>();\n    for (unsigned int i = 0; i < joinChannelArray.Length(); i++) {\n      baton->joinChannelIn.push_back(\n        sharp::CreateInputDescriptor(joinChannelArray.Get(i).As<Napi::Object>()));\n    }\n  }\n  // Operators\n  baton->flatten = sharp::AttrAsBool(options, \"flatten\");\n  baton->flattenBackground = sharp::AttrAsVectorOfDouble(options, \"flattenBackground\");\n  baton->unflatten = sharp::AttrAsBool(options, \"unflatten\");\n  baton->negate = sharp::AttrAsBool(options, \"negate\");\n  baton->negateAlpha = sharp::AttrAsBool(options, \"negateAlpha\");\n  baton->blurSigma = sharp::AttrAsDouble(options, \"blurSigma\");\n  baton->precision = sharp::AttrAsEnum<VipsPrecision>(options, \"precision\", VIPS_TYPE_PRECISION);\n  baton->minAmpl = sharp::AttrAsDouble(options, \"minAmpl\");\n  baton->brightness = sharp::AttrAsDouble(options, \"brightness\");\n  baton->saturation = sharp::AttrAsDouble(options, \"saturation\");\n  baton->hue = sharp::AttrAsInt32(options, \"hue\");\n  baton->lightness = sharp::AttrAsDouble(options, \"lightness\");\n  baton->medianSize = sharp::AttrAsUint32(options, \"medianSize\");\n  baton->sharpenSigma = sharp::AttrAsDouble(options, \"sharpenSigma\");\n  baton->sharpenM1 = sharp::AttrAsDouble(options, \"sharpenM1\");\n  baton->sharpenM2 = sharp::AttrAsDouble(options, \"sharpenM2\");\n  baton->sharpenX1 = sharp::AttrAsDouble(options, \"sharpenX1\");\n  baton->sharpenY2 = sharp::AttrAsDouble(options, \"sharpenY2\");\n  baton->sharpenY3 = sharp::AttrAsDouble(options, \"sharpenY3\");\n  baton->threshold = sharp::AttrAsInt32(options, \"threshold\");\n  baton->thresholdGrayscale = sharp::AttrAsBool(options, \"thresholdGrayscale\");\n  baton->trimBackground = sharp::AttrAsVectorOfDouble(options, \"trimBackground\");\n  baton->trimThreshold = sharp::AttrAsDouble(options, \"trimThreshold\");\n  baton->trimLineArt = sharp::AttrAsBool(options, \"trimLineArt\");\n  baton->gamma = sharp::AttrAsDouble(options, \"gamma\");\n  baton->gammaOut = sharp::AttrAsDouble(options, \"gammaOut\");\n  baton->linearA = sharp::AttrAsVectorOfDouble(options, \"linearA\");\n  baton->linearB = sharp::AttrAsVectorOfDouble(options, \"linearB\");\n  baton->dilateWidth = sharp::AttrAsUint32(options, \"dilateWidth\");\n  baton->erodeWidth = sharp::AttrAsUint32(options, \"erodeWidth\");\n  baton->greyscale = sharp::AttrAsBool(options, \"greyscale\");\n  baton->normalise = sharp::AttrAsBool(options, \"normalise\");\n  baton->normaliseLower = sharp::AttrAsUint32(options, \"normaliseLower\");\n  baton->normaliseUpper = sharp::AttrAsUint32(options, \"normaliseUpper\");\n  baton->tint = sharp::AttrAsVectorOfDouble(options, \"tint\");\n  baton->claheWidth = sharp::AttrAsUint32(options, \"claheWidth\");\n  baton->claheHeight = sharp::AttrAsUint32(options, \"claheHeight\");\n  baton->claheMaxSlope = sharp::AttrAsUint32(options, \"claheMaxSlope\");\n  baton->angle = sharp::AttrAsInt32(options, \"angle\");\n  baton->rotationAngle = sharp::AttrAsDouble(options, \"rotationAngle\");\n  baton->rotationBackground = sharp::AttrAsVectorOfDouble(options, \"rotationBackground\");\n  baton->rotateBeforePreExtract = sharp::AttrAsBool(options, \"rotateBeforePreExtract\");\n  baton->flip = sharp::AttrAsBool(options, \"flip\");\n  baton->flop = sharp::AttrAsBool(options, \"flop\");\n  baton->extendTop = sharp::AttrAsInt32(options, \"extendTop\");\n  baton->extendBottom = sharp::AttrAsInt32(options, \"extendBottom\");\n  baton->extendLeft = sharp::AttrAsInt32(options, \"extendLeft\");\n  baton->extendRight = sharp::AttrAsInt32(options, \"extendRight\");\n  baton->extendBackground = sharp::AttrAsVectorOfDouble(options, \"extendBackground\");\n  baton->extendWith = sharp::AttrAsEnum<VipsExtend>(options, \"extendWith\", VIPS_TYPE_EXTEND);\n  baton->extractChannel = sharp::AttrAsInt32(options, \"extractChannel\");\n  baton->affineMatrix = sharp::AttrAsVectorOfDouble(options, \"affineMatrix\");\n  baton->affineBackground = sharp::AttrAsVectorOfDouble(options, \"affineBackground\");\n  baton->affineIdx = sharp::AttrAsDouble(options, \"affineIdx\");\n  baton->affineIdy = sharp::AttrAsDouble(options, \"affineIdy\");\n  baton->affineOdx = sharp::AttrAsDouble(options, \"affineOdx\");\n  baton->affineOdy = sharp::AttrAsDouble(options, \"affineOdy\");\n  baton->affineInterpolator = sharp::AttrAsStr(options, \"affineInterpolator\");\n  baton->removeAlpha = sharp::AttrAsBool(options, \"removeAlpha\");\n  baton->ensureAlpha = sharp::AttrAsDouble(options, \"ensureAlpha\");\n  if (options.Has(\"boolean\")) {\n    baton->boolean = sharp::CreateInputDescriptor(options.Get(\"boolean\").As<Napi::Object>());\n    baton->booleanOp = sharp::AttrAsEnum<VipsOperationBoolean>(options, \"booleanOp\", VIPS_TYPE_OPERATION_BOOLEAN);\n  }\n  if (options.Has(\"bandBoolOp\")) {\n    baton->bandBoolOp = sharp::AttrAsEnum<VipsOperationBoolean>(options, \"bandBoolOp\", VIPS_TYPE_OPERATION_BOOLEAN);\n  }\n  if (options.Has(\"convKernel\")) {\n    Napi::Object kernel = options.Get(\"convKernel\").As<Napi::Object>();\n    baton->convKernelWidth = sharp::AttrAsUint32(kernel, \"width\");\n    baton->convKernelHeight = sharp::AttrAsUint32(kernel, \"height\");\n    baton->convKernelScale = sharp::AttrAsDouble(kernel, \"scale\");\n    baton->convKernelOffset = sharp::AttrAsDouble(kernel, \"offset\");\n    size_t const kernelSize = static_cast<size_t>(baton->convKernelWidth * baton->convKernelHeight);\n    baton->convKernel.resize(kernelSize);\n    Napi::Array kdata = kernel.Get(\"kernel\").As<Napi::Array>();\n    for (unsigned int i = 0; i < kernelSize; i++) {\n      baton->convKernel[i] = sharp::AttrAsDouble(kdata, i);\n    }\n  }\n  if (options.Has(\"recombMatrix\")) {\n    Napi::Array recombMatrix = options.Get(\"recombMatrix\").As<Napi::Array>();\n    unsigned int matrixElements = recombMatrix.Length();\n    baton->recombMatrix.resize(matrixElements);\n    for (unsigned int i = 0; i < matrixElements; i++) {\n      baton->recombMatrix[i] = sharp::AttrAsDouble(recombMatrix, i);\n    }\n  }\n  baton->colourspacePipeline = sharp::AttrAsEnum<VipsInterpretation>(\n    options, \"colourspacePipeline\", VIPS_TYPE_INTERPRETATION);\n  if (baton->colourspacePipeline == VIPS_INTERPRETATION_ERROR) {\n    baton->colourspacePipeline = VIPS_INTERPRETATION_LAST;\n  }\n  baton->colourspace = sharp::AttrAsEnum<VipsInterpretation>(options, \"colourspace\", VIPS_TYPE_INTERPRETATION);\n  if (baton->colourspace == VIPS_INTERPRETATION_ERROR) {\n    baton->colourspace = VIPS_INTERPRETATION_sRGB;\n  }\n  // Output\n  baton->formatOut = sharp::AttrAsStr(options, \"formatOut\");\n  baton->fileOut = sharp::AttrAsStr(options, \"fileOut\");\n  baton->keepMetadata = sharp::AttrAsUint32(options, \"keepMetadata\");\n  baton->withMetadataOrientation = sharp::AttrAsUint32(options, \"withMetadataOrientation\");\n  baton->withMetadataDensity = sharp::AttrAsDouble(options, \"withMetadataDensity\");\n  baton->withIccProfile = sharp::AttrAsStr(options, \"withIccProfile\");\n  Napi::Object withExif = options.Get(\"withExif\").As<Napi::Object>();\n  Napi::Array withExifKeys = withExif.GetPropertyNames();\n  for (unsigned int i = 0; i < withExifKeys.Length(); i++) {\n    std::string k = sharp::AttrAsStr(withExifKeys, i);\n    if (withExif.HasOwnProperty(k)) {\n      baton->withExif.insert(std::make_pair(k, sharp::AttrAsStr(withExif, k)));\n    }\n  }\n  baton->withExifMerge = sharp::AttrAsBool(options, \"withExifMerge\");\n  baton->timeoutSeconds = sharp::AttrAsUint32(options, \"timeoutSeconds\");\n  baton->loop = sharp::AttrAsUint32(options, \"loop\");\n  baton->delay = sharp::AttrAsInt32Vector(options, \"delay\");\n  // Format-specific\n  baton->jpegQuality = sharp::AttrAsUint32(options, \"jpegQuality\");\n  baton->jpegProgressive = sharp::AttrAsBool(options, \"jpegProgressive\");\n  baton->jpegChromaSubsampling = sharp::AttrAsStr(options, \"jpegChromaSubsampling\");\n  baton->jpegTrellisQuantisation = sharp::AttrAsBool(options, \"jpegTrellisQuantisation\");\n  baton->jpegQuantisationTable = sharp::AttrAsUint32(options, \"jpegQuantisationTable\");\n  baton->jpegOvershootDeringing = sharp::AttrAsBool(options, \"jpegOvershootDeringing\");\n  baton->jpegOptimiseScans = sharp::AttrAsBool(options, \"jpegOptimiseScans\");\n  baton->jpegOptimiseCoding = sharp::AttrAsBool(options, \"jpegOptimiseCoding\");\n  baton->pngProgressive = sharp::AttrAsBool(options, \"pngProgressive\");\n  baton->pngCompressionLevel = sharp::AttrAsUint32(options, \"pngCompressionLevel\");\n  baton->pngAdaptiveFiltering = sharp::AttrAsBool(options, \"pngAdaptiveFiltering\");\n  baton->pngPalette = sharp::AttrAsBool(options, \"pngPalette\");\n  baton->pngQuality = sharp::AttrAsUint32(options, \"pngQuality\");\n  baton->pngEffort = sharp::AttrAsUint32(options, \"pngEffort\");\n  baton->pngBitdepth = sharp::AttrAsUint32(options, \"pngBitdepth\");\n  baton->pngDither = sharp::AttrAsDouble(options, \"pngDither\");\n  baton->jp2Quality = sharp::AttrAsUint32(options, \"jp2Quality\");\n  baton->jp2Lossless = sharp::AttrAsBool(options, \"jp2Lossless\");\n  baton->jp2TileHeight = sharp::AttrAsUint32(options, \"jp2TileHeight\");\n  baton->jp2TileWidth = sharp::AttrAsUint32(options, \"jp2TileWidth\");\n  baton->jp2ChromaSubsampling = sharp::AttrAsStr(options, \"jp2ChromaSubsampling\");\n  baton->webpQuality = sharp::AttrAsUint32(options, \"webpQuality\");\n  baton->webpAlphaQuality = sharp::AttrAsUint32(options, \"webpAlphaQuality\");\n  baton->webpLossless = sharp::AttrAsBool(options, \"webpLossless\");\n  baton->webpNearLossless = sharp::AttrAsBool(options, \"webpNearLossless\");\n  baton->webpSmartSubsample = sharp::AttrAsBool(options, \"webpSmartSubsample\");\n  baton->webpSmartDeblock = sharp::AttrAsBool(options, \"webpSmartDeblock\");\n  baton->webpPreset = sharp::AttrAsEnum<VipsForeignWebpPreset>(options, \"webpPreset\", VIPS_TYPE_FOREIGN_WEBP_PRESET);\n  baton->webpEffort = sharp::AttrAsUint32(options, \"webpEffort\");\n  baton->webpMinSize = sharp::AttrAsBool(options, \"webpMinSize\");\n  baton->webpMixed = sharp::AttrAsBool(options, \"webpMixed\");\n  baton->gifBitdepth = sharp::AttrAsUint32(options, \"gifBitdepth\");\n  baton->gifEffort = sharp::AttrAsUint32(options, \"gifEffort\");\n  baton->gifDither = sharp::AttrAsDouble(options, \"gifDither\");\n  baton->gifInterFrameMaxError = sharp::AttrAsDouble(options, \"gifInterFrameMaxError\");\n  baton->gifInterPaletteMaxError = sharp::AttrAsDouble(options, \"gifInterPaletteMaxError\");\n  baton->gifReuse = sharp::AttrAsBool(options, \"gifReuse\");\n  baton->gifProgressive = sharp::AttrAsBool(options, \"gifProgressive\");\n  baton->tiffQuality = sharp::AttrAsUint32(options, \"tiffQuality\");\n  baton->tiffPyramid = sharp::AttrAsBool(options, \"tiffPyramid\");\n  baton->tiffMiniswhite = sharp::AttrAsBool(options, \"tiffMiniswhite\");\n  baton->tiffBitdepth = sharp::AttrAsUint32(options, \"tiffBitdepth\");\n  baton->tiffTile = sharp::AttrAsBool(options, \"tiffTile\");\n  baton->tiffTileWidth = sharp::AttrAsUint32(options, \"tiffTileWidth\");\n  baton->tiffTileHeight = sharp::AttrAsUint32(options, \"tiffTileHeight\");\n  baton->tiffXres = sharp::AttrAsDouble(options, \"tiffXres\");\n  baton->tiffYres = sharp::AttrAsDouble(options, \"tiffYres\");\n  if (baton->tiffXres == 1.0 && baton->tiffYres == 1.0 && baton->withMetadataDensity > 0) {\n    baton->tiffXres = baton->tiffYres = baton->withMetadataDensity / 25.4;\n  }\n  baton->tiffCompression = sharp::AttrAsEnum<VipsForeignTiffCompression>(\n    options, \"tiffCompression\", VIPS_TYPE_FOREIGN_TIFF_COMPRESSION);\n  baton->tiffPredictor = sharp::AttrAsEnum<VipsForeignTiffPredictor>(\n    options, \"tiffPredictor\", VIPS_TYPE_FOREIGN_TIFF_PREDICTOR);\n  baton->tiffResolutionUnit = sharp::AttrAsEnum<VipsForeignTiffResunit>(\n    options, \"tiffResolutionUnit\", VIPS_TYPE_FOREIGN_TIFF_RESUNIT);\n  baton->heifQuality = sharp::AttrAsUint32(options, \"heifQuality\");\n  baton->heifLossless = sharp::AttrAsBool(options, \"heifLossless\");\n  baton->heifCompression = sharp::AttrAsEnum<VipsForeignHeifCompression>(\n    options, \"heifCompression\", VIPS_TYPE_FOREIGN_HEIF_COMPRESSION);\n  baton->heifEffort = sharp::AttrAsUint32(options, \"heifEffort\");\n  baton->heifChromaSubsampling = sharp::AttrAsStr(options, \"heifChromaSubsampling\");\n  baton->heifBitdepth = sharp::AttrAsUint32(options, \"heifBitdepth\");\n  baton->jxlDistance = sharp::AttrAsDouble(options, \"jxlDistance\");\n  baton->jxlDecodingTier = sharp::AttrAsUint32(options, \"jxlDecodingTier\");\n  baton->jxlEffort = sharp::AttrAsUint32(options, \"jxlEffort\");\n  baton->jxlLossless = sharp::AttrAsBool(options, \"jxlLossless\");\n  baton->rawDepth = sharp::AttrAsEnum<VipsBandFormat>(options, \"rawDepth\", VIPS_TYPE_BAND_FORMAT);\n  baton->tileSize = sharp::AttrAsUint32(options, \"tileSize\");\n  baton->tileOverlap = sharp::AttrAsUint32(options, \"tileOverlap\");\n  baton->tileAngle = sharp::AttrAsInt32(options, \"tileAngle\");\n  baton->tileBackground = sharp::AttrAsVectorOfDouble(options, \"tileBackground\");\n  baton->tileSkipBlanks = sharp::AttrAsInt32(options, \"tileSkipBlanks\");\n  baton->tileContainer = sharp::AttrAsEnum<VipsForeignDzContainer>(\n    options, \"tileContainer\", VIPS_TYPE_FOREIGN_DZ_CONTAINER);\n  baton->tileLayout = sharp::AttrAsEnum<VipsForeignDzLayout>(options, \"tileLayout\", VIPS_TYPE_FOREIGN_DZ_LAYOUT);\n  baton->tileFormat = sharp::AttrAsStr(options, \"tileFormat\");\n  baton->tileDepth = sharp::AttrAsEnum<VipsForeignDzDepth>(options, \"tileDepth\", VIPS_TYPE_FOREIGN_DZ_DEPTH);\n  baton->tileCentre = sharp::AttrAsBool(options, \"tileCentre\");\n  baton->tileId = sharp::AttrAsStr(options, \"tileId\");\n  baton->tileBasename = sharp::AttrAsStr(options, \"tileBasename\");\n\n  // Function to notify of libvips warnings\n  Napi::Function debuglog = options.Get(\"debuglog\").As<Napi::Function>();\n\n  // Function to notify of queue length changes\n  Napi::Function queueListener = options.Get(\"queueListener\").As<Napi::Function>();\n\n  // Join queue for worker thread\n  Napi::Function callback = info[size_t(1)].As<Napi::Function>();\n  PipelineWorker *worker = new PipelineWorker(callback, baton, debuglog, queueListener);\n  worker->Receiver().Set(\"options\", options);\n  worker->Queue();\n\n  // Increment queued task counter\n  Napi::Number queueLength = Napi::Number::New(info.Env(), static_cast<int>(++sharp::counterQueue));\n  queueListener.Call(info.This(), { queueLength });\n\n  return info.Env().Undefined();\n}\n"
        }
    ]
}