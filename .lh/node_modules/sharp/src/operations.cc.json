{
    "sourceFile": "node_modules/sharp/src/operations.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <algorithm>\n#include <functional>\n#include <memory>\n#include <tuple>\n#include <vector>\n#include <vips/vips8>\n\n#include \"common.h\"\n#include \"operations.h\"\n\nusing vips::VImage;\nusing vips::VError;\n\nnamespace sharp {\n  /*\n   * Tint an image using the provided RGB.\n   */\n  VImage Tint(VImage image, std::vector<double> const tint) {\n    std::vector<double> const tintLab = (VImage::black(1, 1) + tint)\n      .colourspace(VIPS_INTERPRETATION_LAB, VImage::option()->set(\"source_space\", VIPS_INTERPRETATION_sRGB))\n      .getpoint(0, 0);\n    // LAB identity function\n    VImage identityLab = VImage::identity(VImage::option()->set(\"bands\", 3))\n      .colourspace(VIPS_INTERPRETATION_LAB, VImage::option()->set(\"source_space\", VIPS_INTERPRETATION_sRGB));\n    // Scale luminance range, 0.0 to 1.0\n    VImage l = identityLab[0] / 100;\n    // Weighting functions\n    VImage weightL = 1.0 - 4.0 * ((l - 0.5) * (l - 0.5));\n    VImage weightAB = (weightL * tintLab).extract_band(1, VImage::option()->set(\"n\", 2));\n    identityLab = identityLab[0].bandjoin(weightAB);\n    // Convert lookup table to sRGB\n    VImage lut = identityLab.colourspace(VIPS_INTERPRETATION_sRGB,\n      VImage::option()->set(\"source_space\", VIPS_INTERPRETATION_LAB));\n    // Original colourspace\n    VipsInterpretation typeBeforeTint = image.interpretation();\n    if (typeBeforeTint == VIPS_INTERPRETATION_RGB) {\n      typeBeforeTint = VIPS_INTERPRETATION_sRGB;\n    }\n    // Apply lookup table\n    if (image.has_alpha()) {\n      VImage alpha = image[image.bands() - 1];\n      image = RemoveAlpha(image)\n        .colourspace(VIPS_INTERPRETATION_B_W)\n        .maplut(lut)\n        .colourspace(typeBeforeTint)\n        .bandjoin(alpha);\n    } else {\n      image = image\n        .colourspace(VIPS_INTERPRETATION_B_W)\n        .maplut(lut)\n        .colourspace(typeBeforeTint);\n    }\n    return image;\n  }\n\n  /*\n   * Stretch luminance to cover full dynamic range.\n   */\n  VImage Normalise(VImage image, int const lower, int const upper) {\n    // Get original colourspace\n    VipsInterpretation typeBeforeNormalize = image.interpretation();\n    if (typeBeforeNormalize == VIPS_INTERPRETATION_RGB) {\n      typeBeforeNormalize = VIPS_INTERPRETATION_sRGB;\n    }\n    // Convert to LAB colourspace\n    VImage lab = image.colourspace(VIPS_INTERPRETATION_LAB);\n    // Extract luminance\n    VImage luminance = lab[0];\n\n    // Find luminance range\n    int const min = lower == 0 ? luminance.min() : luminance.percent(lower);\n    int const max = upper == 100 ? luminance.max() : luminance.percent(upper);\n\n    if (std::abs(max - min) > 1) {\n      // Extract chroma\n      VImage chroma = lab.extract_band(1, VImage::option()->set(\"n\", 2));\n      // Calculate multiplication factor and addition\n      double f = 100.0 / (max - min);\n      double a = -(min * f);\n      // Scale luminance, join to chroma, convert back to original colourspace\n      VImage normalized = luminance.linear(f, a).bandjoin(chroma).colourspace(typeBeforeNormalize);\n      // Attach original alpha channel, if any\n      if (image.has_alpha()) {\n        // Extract original alpha channel\n        VImage alpha = image[image.bands() - 1];\n        // Join alpha channel to normalised image\n        return normalized.bandjoin(alpha);\n      } else {\n        return normalized;\n      }\n    }\n    return image;\n  }\n\n  /*\n   * Contrast limiting adapative histogram equalization (CLAHE)\n   */\n  VImage Clahe(VImage image, int const width, int const height, int const maxSlope) {\n    return image.hist_local(width, height, VImage::option()->set(\"max_slope\", maxSlope));\n  }\n\n  /*\n   * Gamma encoding/decoding\n   */\n  VImage Gamma(VImage image, double const exponent) {\n    if (image.has_alpha()) {\n      // Separate alpha channel\n      VImage alpha = image[image.bands() - 1];\n      return RemoveAlpha(image).gamma(VImage::option()->set(\"exponent\", exponent)).bandjoin(alpha);\n    } else {\n      return image.gamma(VImage::option()->set(\"exponent\", exponent));\n    }\n  }\n\n  /*\n   * Flatten image to remove alpha channel\n   */\n  VImage Flatten(VImage image, std::vector<double> flattenBackground) {\n    double const multiplier = sharp::Is16Bit(image.interpretation()) ? 256.0 : 1.0;\n    std::vector<double> background {\n      flattenBackground[0] * multiplier,\n      flattenBackground[1] * multiplier,\n      flattenBackground[2] * multiplier\n    };\n    return image.flatten(VImage::option()->set(\"background\", background));\n  }\n\n  /**\n   * Produce the \"negative\" of the image.\n   */\n  VImage Negate(VImage image, bool const negateAlpha) {\n    if (image.has_alpha() && !negateAlpha) {\n      // Separate alpha channel\n      VImage alpha = image[image.bands() - 1];\n      return RemoveAlpha(image).invert().bandjoin(alpha);\n    } else {\n      return image.invert();\n    }\n  }\n\n  /*\n   * Gaussian blur. Use sigma of -1.0 for fast blur.\n   */\n  VImage Blur(VImage image, double const sigma, VipsPrecision precision, double const minAmpl) {\n    if (sigma == -1.0) {\n      // Fast, mild blur - averages neighbouring pixels\n      VImage blur = VImage::new_matrixv(3, 3,\n        1.0, 1.0, 1.0,\n        1.0, 1.0, 1.0,\n        1.0, 1.0, 1.0);\n      blur.set(\"scale\", 9.0);\n      return image.conv(blur);\n    } else {\n      // Slower, accurate Gaussian blur\n      return StaySequential(image).gaussblur(sigma, VImage::option()\n        ->set(\"precision\", precision)\n        ->set(\"min_ampl\", minAmpl));\n    }\n  }\n\n  /*\n   * Convolution with a kernel.\n   */\n  VImage Convolve(VImage image, int const width, int const height,\n    double const scale, double const offset,\n    std::vector<double> const &kernel_v\n  ) {\n    VImage kernel = VImage::new_from_memory(\n      static_cast<void*>(const_cast<double*>(kernel_v.data())),\n      width * height * sizeof(double),\n      width,\n      height,\n      1,\n      VIPS_FORMAT_DOUBLE);\n    kernel.set(\"scale\", scale);\n    kernel.set(\"offset\", offset);\n\n    return image.conv(kernel);\n  }\n\n  /*\n   * Recomb with a Matrix of the given bands/channel size.\n   * Eg. RGB will be a 3x3 matrix.\n   */\n  VImage Recomb(VImage image, std::vector<double> const& matrix) {\n    double* m = const_cast<double*>(matrix.data());\n    image = image.colourspace(VIPS_INTERPRETATION_sRGB);\n    if (matrix.size() == 9) {\n      return image\n        .recomb(image.bands() == 3\n          ? VImage::new_matrix(3, 3, m, 9)\n          : VImage::new_matrixv(4, 4,\n            m[0], m[1], m[2], 0.0,\n            m[3], m[4], m[5], 0.0,\n            m[6], m[7], m[8], 0.0,\n            0.0, 0.0, 0.0, 1.0));\n    } else {\n      return image.recomb(VImage::new_matrix(4, 4, m, 16));\n    }\n  }\n\n  VImage Modulate(VImage image, double const brightness, double const saturation,\n                  int const hue, double const lightness) {\n    VipsInterpretation colourspaceBeforeModulate = image.interpretation();\n    if (image.has_alpha()) {\n      // Separate alpha channel\n      VImage alpha = image[image.bands() - 1];\n      return RemoveAlpha(image)\n        .colourspace(VIPS_INTERPRETATION_LCH)\n        .linear(\n          { brightness, saturation, 1},\n          { lightness, 0.0, static_cast<double>(hue) }\n        )\n        .colourspace(colourspaceBeforeModulate)\n        .bandjoin(alpha);\n    } else {\n      return image\n        .colourspace(VIPS_INTERPRETATION_LCH)\n        .linear(\n          { brightness, saturation, 1 },\n          { lightness, 0.0, static_cast<double>(hue) }\n        )\n        .colourspace(colourspaceBeforeModulate);\n    }\n  }\n\n  /*\n   * Sharpen flat and jagged areas. Use sigma of -1.0 for fast sharpen.\n   */\n  VImage Sharpen(VImage image, double const sigma, double const m1, double const m2,\n    double const x1, double const y2, double const y3) {\n    if (sigma == -1.0) {\n      // Fast, mild sharpen\n      VImage sharpen = VImage::new_matrixv(3, 3,\n        -1.0, -1.0, -1.0,\n        -1.0, 32.0, -1.0,\n        -1.0, -1.0, -1.0);\n      sharpen.set(\"scale\", 24.0);\n      return image.conv(sharpen);\n    } else {\n      // Slow, accurate sharpen in LAB colour space, with control over flat vs jagged areas\n      VipsInterpretation colourspaceBeforeSharpen = image.interpretation();\n      if (colourspaceBeforeSharpen == VIPS_INTERPRETATION_RGB) {\n        colourspaceBeforeSharpen = VIPS_INTERPRETATION_sRGB;\n      }\n      return image\n        .sharpen(VImage::option()\n          ->set(\"sigma\", sigma)\n          ->set(\"m1\", m1)\n          ->set(\"m2\", m2)\n          ->set(\"x1\", x1)\n          ->set(\"y2\", y2)\n          ->set(\"y3\", y3))\n        .colourspace(colourspaceBeforeSharpen);\n    }\n  }\n\n  VImage Threshold(VImage image, double const threshold, bool const thresholdGrayscale) {\n    if (!thresholdGrayscale) {\n      return image >= threshold;\n    }\n    return image.colourspace(VIPS_INTERPRETATION_B_W) >= threshold;\n  }\n\n  /*\n    Perform boolean/bitwise operation on image color channels - results in one channel image\n  */\n  VImage Bandbool(VImage image, VipsOperationBoolean const boolean) {\n    image = image.bandbool(boolean);\n    return image.copy(VImage::option()->set(\"interpretation\", VIPS_INTERPRETATION_B_W));\n  }\n\n  /*\n    Perform bitwise boolean operation between images\n  */\n  VImage Boolean(VImage image, VImage imageR, VipsOperationBoolean const boolean) {\n    return image.boolean(imageR, boolean);\n  }\n\n  /*\n    Trim an image\n  */\n  VImage Trim(VImage image, std::vector<double> background, double threshold, bool const lineArt) {\n    if (image.width() < 3 && image.height() < 3) {\n      throw VError(\"Image to trim must be at least 3x3 pixels\");\n    }\n    if (background.size() == 0) {\n      // Top-left pixel provides the default background colour if none is given\n      background = image.extract_area(0, 0, 1, 1)(0, 0);\n    } else if (sharp::Is16Bit(image.interpretation())) {\n      for (size_t i = 0; i < background.size(); i++) {\n        background[i] *= 256.0;\n      }\n      threshold *= 256.0;\n    }\n    std::vector<double> backgroundAlpha({ background.back() });\n    if (image.has_alpha()) {\n      background.pop_back();\n    } else {\n      background.resize(image.bands());\n    }\n    int left, top, width, height;\n    left = image.find_trim(&top, &width, &height, VImage::option()\n      ->set(\"background\", background)\n      ->set(\"line_art\", lineArt)\n      ->set(\"threshold\", threshold));\n    if (image.has_alpha()) {\n      // Search alpha channel (A)\n      int leftA, topA, widthA, heightA;\n      VImage alpha = image[image.bands() - 1];\n      leftA = alpha.find_trim(&topA, &widthA, &heightA, VImage::option()\n        ->set(\"background\", backgroundAlpha)\n        ->set(\"line_art\", lineArt)\n        ->set(\"threshold\", threshold));\n      if (widthA > 0 && heightA > 0) {\n        if (width > 0 && height > 0) {\n          // Combined bounding box (B)\n          int const leftB = std::min(left, leftA);\n          int const topB = std::min(top, topA);\n          int const widthB = std::max(left + width, leftA + widthA) - leftB;\n          int const heightB = std::max(top + height, topA + heightA) - topB;\n          return image.extract_area(leftB, topB, widthB, heightB);\n        } else {\n          // Use alpha only\n          return image.extract_area(leftA, topA, widthA, heightA);\n        }\n      }\n    }\n    if (width > 0 && height > 0) {\n      return image.extract_area(left, top, width, height);\n    }\n    return image;\n  }\n\n  /*\n   * Calculate (a * in + b)\n   */\n  VImage Linear(VImage image, std::vector<double> const a, std::vector<double> const b) {\n    size_t const bands = static_cast<size_t>(image.bands());\n    if (a.size() > bands) {\n      throw VError(\"Band expansion using linear is unsupported\");\n    }\n    bool const uchar = !Is16Bit(image.interpretation());\n    if (image.has_alpha() && a.size() != bands && (a.size() == 1 || a.size() == bands - 1 || bands - 1 == 1)) {\n      // Separate alpha channel\n      VImage alpha = image[bands - 1];\n      return RemoveAlpha(image).linear(a, b, VImage::option()->set(\"uchar\", uchar)).bandjoin(alpha);\n    } else {\n      return image.linear(a, b, VImage::option()->set(\"uchar\", uchar));\n    }\n  }\n\n  /*\n   * Unflatten\n   */\n  VImage Unflatten(VImage image) {\n    if (image.has_alpha()) {\n      VImage alpha = image[image.bands() - 1];\n      VImage noAlpha = RemoveAlpha(image);\n      return noAlpha.bandjoin(alpha & (noAlpha.colourspace(VIPS_INTERPRETATION_B_W) < 255));\n    } else {\n      return image.bandjoin(image.colourspace(VIPS_INTERPRETATION_B_W) < 255);\n    }\n  }\n\n  /*\n   * Ensure the image is in a given colourspace\n   */\n  VImage EnsureColourspace(VImage image, VipsInterpretation colourspace) {\n    if (colourspace != VIPS_INTERPRETATION_LAST && image.interpretation() != colourspace) {\n      image = image.colourspace(colourspace,\n        VImage::option()->set(\"source_space\", image.interpretation()));\n    }\n    return image;\n  }\n\n  /*\n   * Split and crop each frame, reassemble, and update pageHeight.\n   */\n  VImage CropMultiPage(VImage image, int left, int top, int width, int height,\n                       int nPages, int *pageHeight) {\n    if (top == 0 && height == *pageHeight) {\n      // Fast path; no need to adjust the height of the multi-page image\n      return image.extract_area(left, 0, width, image.height());\n    } else {\n      std::vector<VImage> pages;\n      pages.reserve(nPages);\n\n      // Split the image into cropped frames\n      image = StaySequential(image);\n      for (int i = 0; i < nPages; i++) {\n        pages.push_back(\n          image.extract_area(left, *pageHeight * i + top, width, height));\n      }\n\n      // Reassemble the frames into a tall, thin image\n      VImage assembled = VImage::arrayjoin(pages,\n        VImage::option()->set(\"across\", 1));\n\n      // Update the page height\n      *pageHeight = height;\n\n      return assembled;\n    }\n  }\n\n  /*\n   * Split into frames, embed each frame, reassemble, and update pageHeight.\n   */\n  VImage EmbedMultiPage(VImage image, int left, int top, int width, int height,\n                        VipsExtend extendWith, std::vector<double> background, int nPages, int *pageHeight) {\n    if (top == 0 && height == *pageHeight) {\n      // Fast path; no need to adjust the height of the multi-page image\n      return image.embed(left, 0, width, image.height(), VImage::option()\n        ->set(\"extend\", extendWith)\n        ->set(\"background\", background));\n    } else if (left == 0 && width == image.width()) {\n      // Fast path; no need to adjust the width of the multi-page image\n      std::vector<VImage> pages;\n      pages.reserve(nPages);\n\n      // Rearrange the tall image into a vertical grid\n      image = image.grid(*pageHeight, nPages, 1);\n\n      // Do the embed on the wide image\n      image = image.embed(0, top, image.width(), height, VImage::option()\n        ->set(\"extend\", extendWith)\n        ->set(\"background\", background));\n\n      // Split the wide image into frames\n      for (int i = 0; i < nPages; i++) {\n        pages.push_back(\n          image.extract_area(width * i, 0, width, height));\n      }\n\n      // Reassemble the frames into a tall, thin image\n      VImage assembled = VImage::arrayjoin(pages,\n        VImage::option()->set(\"across\", 1));\n\n      // Update the page height\n      *pageHeight = height;\n\n      return assembled;\n    } else {\n      std::vector<VImage> pages;\n      pages.reserve(nPages);\n\n      // Split the image into frames\n      for (int i = 0; i < nPages; i++) {\n        pages.push_back(\n          image.extract_area(0, *pageHeight * i, image.width(), *pageHeight));\n      }\n\n      // Embed each frame in the target size\n      for (int i = 0; i < nPages; i++) {\n        pages[i] = pages[i].embed(left, top, width, height, VImage::option()\n          ->set(\"extend\", extendWith)\n          ->set(\"background\", background));\n      }\n\n      // Reassemble the frames into a tall, thin image\n      VImage assembled = VImage::arrayjoin(pages,\n        VImage::option()->set(\"across\", 1));\n\n      // Update the page height\n      *pageHeight = height;\n\n      return assembled;\n    }\n  }\n\n  /*\n   * Dilate an image\n   */\n  VImage Dilate(VImage image, int const width) {\n    int const maskWidth = 2 * width + 1;\n    VImage mask = VImage::new_matrix(maskWidth, maskWidth);\n    return image.morph(\n      mask,\n      VIPS_OPERATION_MORPHOLOGY_DILATE).invert();\n  }\n\n  /*\n   * Erode an image\n   */\n  VImage Erode(VImage image, int const width) {\n    int const maskWidth = 2 * width + 1;\n    VImage mask = VImage::new_matrix(maskWidth, maskWidth);\n    return image.morph(\n      mask,\n      VIPS_OPERATION_MORPHOLOGY_ERODE).invert();\n  }\n\n}  // namespace sharp\n"
        }
    ]
}