{
    "sourceFile": "node_modules/sharp/src/common.cc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#include <cstdlib>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <mutex>  // NOLINT(build/c++11)\n\n#include <napi.h>\n#include <vips/vips8>\n\n#include \"common.h\"\n\nusing vips::VImage;\n\nnamespace sharp {\n\n  // Convenience methods to access the attributes of a Napi::Object\n  bool HasAttr(Napi::Object obj, std::string attr) {\n    return obj.Has(attr);\n  }\n  std::string AttrAsStr(Napi::Object obj, std::string attr) {\n    return obj.Get(attr).As<Napi::String>();\n  }\n  std::string AttrAsStr(Napi::Object obj, unsigned int const attr) {\n    return obj.Get(attr).As<Napi::String>();\n  }\n  uint32_t AttrAsUint32(Napi::Object obj, std::string attr) {\n    return obj.Get(attr).As<Napi::Number>().Uint32Value();\n  }\n  int32_t AttrAsInt32(Napi::Object obj, std::string attr) {\n    return obj.Get(attr).As<Napi::Number>().Int32Value();\n  }\n  int32_t AttrAsInt32(Napi::Object obj, unsigned int const attr) {\n    return obj.Get(attr).As<Napi::Number>().Int32Value();\n  }\n  int64_t AttrAsInt64(Napi::Object obj, std::string attr) {\n    return obj.Get(attr).As<Napi::Number>().Int64Value();\n  }\n  double AttrAsDouble(Napi::Object obj, std::string attr) {\n    return obj.Get(attr).As<Napi::Number>().DoubleValue();\n  }\n  double AttrAsDouble(Napi::Object obj, unsigned int const attr) {\n    return obj.Get(attr).As<Napi::Number>().DoubleValue();\n  }\n  bool AttrAsBool(Napi::Object obj, std::string attr) {\n    return obj.Get(attr).As<Napi::Boolean>().Value();\n  }\n  std::vector<double> AttrAsVectorOfDouble(Napi::Object obj, std::string attr) {\n    Napi::Array napiArray = obj.Get(attr).As<Napi::Array>();\n    std::vector<double> vectorOfDouble(napiArray.Length());\n    for (unsigned int i = 0; i < napiArray.Length(); i++) {\n      vectorOfDouble[i] = AttrAsDouble(napiArray, i);\n    }\n    return vectorOfDouble;\n  }\n  std::vector<int32_t> AttrAsInt32Vector(Napi::Object obj, std::string attr) {\n    Napi::Array array = obj.Get(attr).As<Napi::Array>();\n    std::vector<int32_t> vector(array.Length());\n    for (unsigned int i = 0; i < array.Length(); i++) {\n      vector[i] = AttrAsInt32(array, i);\n    }\n    return vector;\n  }\n\n  // Create an InputDescriptor instance from a Napi::Object describing an input image\n  InputDescriptor* CreateInputDescriptor(Napi::Object input) {\n    InputDescriptor *descriptor = new InputDescriptor;\n    if (HasAttr(input, \"file\")) {\n      descriptor->file = AttrAsStr(input, \"file\");\n    } else if (HasAttr(input, \"buffer\")) {\n      Napi::Buffer<char> buffer = input.Get(\"buffer\").As<Napi::Buffer<char>>();\n      descriptor->bufferLength = buffer.Length();\n      descriptor->buffer = buffer.Data();\n      descriptor->isBuffer = true;\n    }\n    descriptor->failOn = AttrAsEnum<VipsFailOn>(input, \"failOn\", VIPS_TYPE_FAIL_ON);\n    // Density for vector-based input\n    if (HasAttr(input, \"density\")) {\n      descriptor->density = AttrAsDouble(input, \"density\");\n    }\n    // Should we ignore any embedded ICC profile\n    if (HasAttr(input, \"ignoreIcc\")) {\n      descriptor->ignoreIcc = AttrAsBool(input, \"ignoreIcc\");\n    }\n    // Raw pixel input\n    if (HasAttr(input, \"rawChannels\")) {\n      descriptor->rawDepth = AttrAsEnum<VipsBandFormat>(input, \"rawDepth\", VIPS_TYPE_BAND_FORMAT);\n      descriptor->rawChannels = AttrAsUint32(input, \"rawChannels\");\n      descriptor->rawWidth = AttrAsUint32(input, \"rawWidth\");\n      descriptor->rawHeight = AttrAsUint32(input, \"rawHeight\");\n      descriptor->rawPremultiplied = AttrAsBool(input, \"rawPremultiplied\");\n    }\n    // Multi-page input (GIF, TIFF, PDF)\n    if (HasAttr(input, \"pages\")) {\n      descriptor->pages = AttrAsInt32(input, \"pages\");\n    }\n    if (HasAttr(input, \"page\")) {\n      descriptor->page = AttrAsUint32(input, \"page\");\n    }\n    // Multi-level input (OpenSlide)\n    if (HasAttr(input, \"level\")) {\n      descriptor->level = AttrAsUint32(input, \"level\");\n    }\n    // subIFD (OME-TIFF)\n    if (HasAttr(input, \"subifd\")) {\n      descriptor->subifd = AttrAsInt32(input, \"subifd\");\n    }\n    // // PDF background color\n    if (HasAttr(input, \"pdfBackground\")) {\n      descriptor->pdfBackground = AttrAsVectorOfDouble(input, \"pdfBackground\");\n    }\n    // Create new image\n    if (HasAttr(input, \"createChannels\")) {\n      descriptor->createChannels = AttrAsUint32(input, \"createChannels\");\n      descriptor->createWidth = AttrAsUint32(input, \"createWidth\");\n      descriptor->createHeight = AttrAsUint32(input, \"createHeight\");\n      if (HasAttr(input, \"createNoiseType\")) {\n        descriptor->createNoiseType = AttrAsStr(input, \"createNoiseType\");\n        descriptor->createNoiseMean = AttrAsDouble(input, \"createNoiseMean\");\n        descriptor->createNoiseSigma = AttrAsDouble(input, \"createNoiseSigma\");\n      } else {\n        descriptor->createBackground = AttrAsVectorOfDouble(input, \"createBackground\");\n      }\n    }\n    // Create new image with text\n    if (HasAttr(input, \"textValue\")) {\n      descriptor->textValue = AttrAsStr(input, \"textValue\");\n      if (HasAttr(input, \"textFont\")) {\n        descriptor->textFont = AttrAsStr(input, \"textFont\");\n      }\n      if (HasAttr(input, \"textFontfile\")) {\n        descriptor->textFontfile = AttrAsStr(input, \"textFontfile\");\n      }\n      if (HasAttr(input, \"textWidth\")) {\n        descriptor->textWidth = AttrAsUint32(input, \"textWidth\");\n      }\n      if (HasAttr(input, \"textHeight\")) {\n        descriptor->textHeight = AttrAsUint32(input, \"textHeight\");\n      }\n      if (HasAttr(input, \"textAlign\")) {\n        descriptor->textAlign = AttrAsEnum<VipsAlign>(input, \"textAlign\", VIPS_TYPE_ALIGN);\n      }\n      if (HasAttr(input, \"textJustify\")) {\n        descriptor->textJustify = AttrAsBool(input, \"textJustify\");\n      }\n      if (HasAttr(input, \"textDpi\")) {\n        descriptor->textDpi = AttrAsUint32(input, \"textDpi\");\n      }\n      if (HasAttr(input, \"textRgba\")) {\n        descriptor->textRgba = AttrAsBool(input, \"textRgba\");\n      }\n      if (HasAttr(input, \"textSpacing\")) {\n        descriptor->textSpacing = AttrAsUint32(input, \"textSpacing\");\n      }\n      if (HasAttr(input, \"textWrap\")) {\n        descriptor->textWrap = AttrAsEnum<VipsTextWrap>(input, \"textWrap\", VIPS_TYPE_TEXT_WRAP);\n      }\n    }\n    // Join images together\n    if (HasAttr(input, \"joinAnimated\")) {\n      descriptor->joinAnimated = AttrAsBool(input, \"joinAnimated\");\n    }\n    if (HasAttr(input, \"joinAcross\")) {\n      descriptor->joinAcross = AttrAsUint32(input, \"joinAcross\");\n    }\n    if (HasAttr(input, \"joinShim\")) {\n      descriptor->joinShim = AttrAsUint32(input, \"joinShim\");\n    }\n    if (HasAttr(input, \"joinBackground\")) {\n      descriptor->joinBackground = AttrAsVectorOfDouble(input, \"joinBackground\");\n    }\n    if (HasAttr(input, \"joinHalign\")) {\n      descriptor->joinHalign = AttrAsEnum<VipsAlign>(input, \"joinHalign\", VIPS_TYPE_ALIGN);\n    }\n    if (HasAttr(input, \"joinValign\")) {\n      descriptor->joinValign = AttrAsEnum<VipsAlign>(input, \"joinValign\", VIPS_TYPE_ALIGN);\n    }\n    // Limit input images to a given number of pixels, where pixels = width * height\n    descriptor->limitInputPixels = static_cast<uint64_t>(AttrAsInt64(input, \"limitInputPixels\"));\n    if (HasAttr(input, \"access\")) {\n      descriptor->access = AttrAsBool(input, \"sequentialRead\") ? VIPS_ACCESS_SEQUENTIAL : VIPS_ACCESS_RANDOM;\n    }\n    // Remove safety features and allow unlimited input\n    descriptor->unlimited = AttrAsBool(input, \"unlimited\");\n    // Use the EXIF orientation to auto orient the image\n    descriptor->autoOrient = AttrAsBool(input, \"autoOrient\");\n    return descriptor;\n  }\n\n  // How many tasks are in the queue?\n  std::atomic<int> counterQueue{0};\n\n  // How many tasks are being processed?\n  std::atomic<int> counterProcess{0};\n\n  // Filename extension checkers\n  static bool EndsWith(std::string const &str, std::string const &end) {\n    return str.length() >= end.length() && 0 == str.compare(str.length() - end.length(), end.length(), end);\n  }\n  bool IsJpeg(std::string const &str) {\n    return EndsWith(str, \".jpg\") || EndsWith(str, \".jpeg\") || EndsWith(str, \".JPG\") || EndsWith(str, \".JPEG\");\n  }\n  bool IsPng(std::string const &str) {\n    return EndsWith(str, \".png\") || EndsWith(str, \".PNG\");\n  }\n  bool IsWebp(std::string const &str) {\n    return EndsWith(str, \".webp\") || EndsWith(str, \".WEBP\");\n  }\n  bool IsGif(std::string const &str) {\n    return EndsWith(str, \".gif\") || EndsWith(str, \".GIF\");\n  }\n  bool IsJp2(std::string const &str) {\n    return EndsWith(str, \".jp2\") || EndsWith(str, \".jpx\") || EndsWith(str, \".j2k\") || EndsWith(str, \".j2c\")\n      || EndsWith(str, \".JP2\") || EndsWith(str, \".JPX\") || EndsWith(str, \".J2K\") || EndsWith(str, \".J2C\");\n  }\n  bool IsTiff(std::string const &str) {\n    return EndsWith(str, \".tif\") || EndsWith(str, \".tiff\") || EndsWith(str, \".TIF\") || EndsWith(str, \".TIFF\");\n  }\n  bool IsHeic(std::string const &str) {\n    return EndsWith(str, \".heic\") || EndsWith(str, \".HEIC\");\n  }\n  bool IsHeif(std::string const &str) {\n    return EndsWith(str, \".heif\") || EndsWith(str, \".HEIF\") || IsHeic(str) || IsAvif(str);\n  }\n  bool IsAvif(std::string const &str) {\n    return EndsWith(str, \".avif\") || EndsWith(str, \".AVIF\");\n  }\n  bool IsJxl(std::string const &str) {\n    return EndsWith(str, \".jxl\") || EndsWith(str, \".JXL\");\n  }\n  bool IsDz(std::string const &str) {\n    return EndsWith(str, \".dzi\") || EndsWith(str, \".DZI\");\n  }\n  bool IsDzZip(std::string const &str) {\n    return EndsWith(str, \".zip\") || EndsWith(str, \".ZIP\") || EndsWith(str, \".szi\") || EndsWith(str, \".SZI\");\n  }\n  bool IsV(std::string const &str) {\n    return EndsWith(str, \".v\") || EndsWith(str, \".V\") || EndsWith(str, \".vips\") || EndsWith(str, \".VIPS\");\n  }\n\n  /*\n    Trim space from end of string.\n  */\n  std::string TrimEnd(std::string const &str) {\n    return str.substr(0, str.find_last_not_of(\" \\n\\r\\f\") + 1);\n  }\n\n  /*\n    Provide a string identifier for the given image type.\n  */\n  std::string ImageTypeId(ImageType const imageType) {\n    std::string id;\n    switch (imageType) {\n      case ImageType::JPEG: id = \"jpeg\"; break;\n      case ImageType::PNG: id = \"png\"; break;\n      case ImageType::WEBP: id = \"webp\"; break;\n      case ImageType::TIFF: id = \"tiff\"; break;\n      case ImageType::GIF: id = \"gif\"; break;\n      case ImageType::JP2: id = \"jp2\"; break;\n      case ImageType::SVG: id = \"svg\"; break;\n      case ImageType::HEIF: id = \"heif\"; break;\n      case ImageType::PDF: id = \"pdf\"; break;\n      case ImageType::MAGICK: id = \"magick\"; break;\n      case ImageType::OPENSLIDE: id = \"openslide\"; break;\n      case ImageType::PPM: id = \"ppm\"; break;\n      case ImageType::FITS: id = \"fits\"; break;\n      case ImageType::EXR: id = \"exr\"; break;\n      case ImageType::JXL: id = \"jxl\"; break;\n      case ImageType::RAD: id = \"rad\"; break;\n      case ImageType::VIPS: id = \"vips\"; break;\n      case ImageType::RAW: id = \"raw\"; break;\n      case ImageType::UNKNOWN: id = \"unknown\"; break;\n      case ImageType::MISSING: id = \"missing\"; break;\n    }\n    return id;\n  }\n\n  /**\n   * Regenerate this table with something like:\n   *\n   * $ vips -l foreign | grep -i load | awk '{ print $2, $1; }'\n   *\n   * Plus a bit of editing.\n   */\n  std::map<std::string, ImageType> loaderToType = {\n    { \"VipsForeignLoadJpegFile\", ImageType::JPEG },\n    { \"VipsForeignLoadJpegBuffer\", ImageType::JPEG },\n    { \"VipsForeignLoadPngFile\", ImageType::PNG },\n    { \"VipsForeignLoadPngBuffer\", ImageType::PNG },\n    { \"VipsForeignLoadWebpFile\", ImageType::WEBP },\n    { \"VipsForeignLoadWebpBuffer\", ImageType::WEBP },\n    { \"VipsForeignLoadTiffFile\", ImageType::TIFF },\n    { \"VipsForeignLoadTiffBuffer\", ImageType::TIFF },\n    { \"VipsForeignLoadGifFile\", ImageType::GIF },\n    { \"VipsForeignLoadGifBuffer\", ImageType::GIF },\n    { \"VipsForeignLoadNsgifFile\", ImageType::GIF },\n    { \"VipsForeignLoadNsgifBuffer\", ImageType::GIF },\n    { \"VipsForeignLoadJp2kBuffer\", ImageType::JP2 },\n    { \"VipsForeignLoadJp2kFile\", ImageType::JP2 },\n    { \"VipsForeignLoadSvgFile\", ImageType::SVG },\n    { \"VipsForeignLoadSvgBuffer\", ImageType::SVG },\n    { \"VipsForeignLoadHeifFile\", ImageType::HEIF },\n    { \"VipsForeignLoadHeifBuffer\", ImageType::HEIF },\n    { \"VipsForeignLoadPdfFile\", ImageType::PDF },\n    { \"VipsForeignLoadPdfBuffer\", ImageType::PDF },\n    { \"VipsForeignLoadMagickFile\", ImageType::MAGICK },\n    { \"VipsForeignLoadMagickBuffer\", ImageType::MAGICK },\n    { \"VipsForeignLoadMagick7File\", ImageType::MAGICK },\n    { \"VipsForeignLoadMagick7Buffer\", ImageType::MAGICK },\n    { \"VipsForeignLoadOpenslideFile\", ImageType::OPENSLIDE },\n    { \"VipsForeignLoadPpmFile\", ImageType::PPM },\n    { \"VipsForeignLoadFitsFile\", ImageType::FITS },\n    { \"VipsForeignLoadOpenexr\", ImageType::EXR },\n    { \"VipsForeignLoadJxlFile\", ImageType::JXL },\n    { \"VipsForeignLoadJxlBuffer\", ImageType::JXL },\n    { \"VipsForeignLoadRadFile\", ImageType::RAD },\n    { \"VipsForeignLoadRadBuffer\", ImageType::RAD },\n    { \"VipsForeignLoadVips\", ImageType::VIPS },\n    { \"VipsForeignLoadVipsFile\", ImageType::VIPS },\n    { \"VipsForeignLoadRaw\", ImageType::RAW }\n  };\n\n  /*\n    Determine image format of a buffer.\n  */\n  ImageType DetermineImageType(void *buffer, size_t const length) {\n    ImageType imageType = ImageType::UNKNOWN;\n    char const *load = vips_foreign_find_load_buffer(buffer, length);\n    if (load != nullptr) {\n      auto it = loaderToType.find(load);\n      if (it != loaderToType.end()) {\n        imageType = it->second;\n      }\n    }\n    return imageType;\n  }\n\n  /*\n    Determine image format, reads the first few bytes of the file\n  */\n  ImageType DetermineImageType(char const *file) {\n    ImageType imageType = ImageType::UNKNOWN;\n    char const *load = vips_foreign_find_load(file);\n    if (load != nullptr) {\n      auto it = loaderToType.find(load);\n      if (it != loaderToType.end()) {\n        imageType = it->second;\n      }\n    } else {\n      if (EndsWith(vips::VError().what(), \" does not exist\\n\")) {\n        imageType = ImageType::MISSING;\n      }\n    }\n    return imageType;\n  }\n\n  /*\n    Does this image type support multiple pages?\n  */\n  bool ImageTypeSupportsPage(ImageType imageType) {\n    return\n      imageType == ImageType::WEBP ||\n      imageType == ImageType::MAGICK ||\n      imageType == ImageType::GIF ||\n      imageType == ImageType::JP2 ||\n      imageType == ImageType::TIFF ||\n      imageType == ImageType::HEIF ||\n      imageType == ImageType::PDF;\n  }\n\n  /*\n    Does this image type support removal of safety limits?\n  */\n  bool ImageTypeSupportsUnlimited(ImageType imageType) {\n    return\n      imageType == ImageType::JPEG ||\n      imageType == ImageType::PNG ||\n      imageType == ImageType::SVG ||\n      imageType == ImageType::HEIF;\n  }\n\n  /*\n    Open an image from the given InputDescriptor (filesystem, compressed buffer, raw pixel data)\n  */\n  std::tuple<VImage, ImageType> OpenInput(InputDescriptor *descriptor) {\n    VImage image;\n    ImageType imageType;\n    if (descriptor->isBuffer) {\n      if (descriptor->rawChannels > 0) {\n        // Raw, uncompressed pixel data\n        bool const is8bit = vips_band_format_is8bit(descriptor->rawDepth);\n        image = VImage::new_from_memory(descriptor->buffer, descriptor->bufferLength,\n          descriptor->rawWidth, descriptor->rawHeight, descriptor->rawChannels, descriptor->rawDepth);\n        if (descriptor->rawChannels < 3) {\n          image.get_image()->Type = is8bit ? VIPS_INTERPRETATION_B_W : VIPS_INTERPRETATION_GREY16;\n        } else {\n          image.get_image()->Type = is8bit ? VIPS_INTERPRETATION_sRGB : VIPS_INTERPRETATION_RGB16;\n        }\n        if (descriptor->rawPremultiplied) {\n          image = image.unpremultiply();\n        }\n        imageType = ImageType::RAW;\n      } else {\n        // Compressed data\n        imageType = DetermineImageType(descriptor->buffer, descriptor->bufferLength);\n        if (imageType != ImageType::UNKNOWN) {\n          try {\n            vips::VOption *option = VImage::option()\n              ->set(\"access\", descriptor->access)\n              ->set(\"fail_on\", descriptor->failOn);\n            if (descriptor->unlimited && ImageTypeSupportsUnlimited(imageType)) {\n              option->set(\"unlimited\", true);\n            }\n            if (imageType == ImageType::SVG || imageType == ImageType::PDF) {\n              option->set(\"dpi\", descriptor->density);\n            }\n            if (imageType == ImageType::MAGICK) {\n              option->set(\"density\", std::to_string(descriptor->density).data());\n            }\n            if (ImageTypeSupportsPage(imageType)) {\n              option->set(\"n\", descriptor->pages);\n              option->set(\"page\", descriptor->page);\n            }\n            if (imageType == ImageType::OPENSLIDE) {\n              option->set(\"level\", descriptor->level);\n            }\n            if (imageType == ImageType::TIFF) {\n              option->set(\"subifd\", descriptor->subifd);\n            }\n            if (imageType == ImageType::PDF) {\n              option->set(\"background\", descriptor->pdfBackground);\n            }\n            image = VImage::new_from_buffer(descriptor->buffer, descriptor->bufferLength, nullptr, option);\n            if (imageType == ImageType::SVG || imageType == ImageType::PDF || imageType == ImageType::MAGICK) {\n              image = SetDensity(image, descriptor->density);\n            }\n          } catch (vips::VError const &err) {\n            throw vips::VError(std::string(\"Input buffer has corrupt header: \") + err.what());\n          }\n        } else {\n          throw vips::VError(\"Input buffer contains unsupported image format\");\n        }\n      }\n    } else {\n      int const channels = descriptor->createChannels;\n      if (channels > 0) {\n        // Create new image\n        if (descriptor->createNoiseType == \"gaussian\") {\n          std::vector<VImage> bands = {};\n          bands.reserve(channels);\n          for (int _band = 0; _band < channels; _band++) {\n            bands.push_back(VImage::gaussnoise(descriptor->createWidth, descriptor->createHeight, VImage::option()\n              ->set(\"mean\", descriptor->createNoiseMean)\n              ->set(\"sigma\", descriptor->createNoiseSigma)));\n          }\n          image = VImage::bandjoin(bands).copy(VImage::option()->set(\"interpretation\",\n            channels < 3 ? VIPS_INTERPRETATION_B_W: VIPS_INTERPRETATION_sRGB));\n        } else {\n          std::vector<double> background = {\n            descriptor->createBackground[0],\n            descriptor->createBackground[1],\n            descriptor->createBackground[2]\n          };\n          if (channels == 4) {\n            background.push_back(descriptor->createBackground[3]);\n          }\n          image = VImage::new_matrix(descriptor->createWidth, descriptor->createHeight)\n            .copy(VImage::option()->set(\"interpretation\",\n              channels < 3 ? VIPS_INTERPRETATION_B_W : VIPS_INTERPRETATION_sRGB))\n            .new_from_image(background);\n        }\n        image = image.cast(VIPS_FORMAT_UCHAR);\n        imageType = ImageType::RAW;\n      } else if (descriptor->textValue.length() > 0) {\n        // Create a new image with text\n        vips::VOption *textOptions = VImage::option()\n          ->set(\"align\", descriptor->textAlign)\n          ->set(\"justify\", descriptor->textJustify)\n          ->set(\"rgba\", descriptor->textRgba)\n          ->set(\"spacing\", descriptor->textSpacing)\n          ->set(\"wrap\", descriptor->textWrap)\n          ->set(\"autofit_dpi\", &descriptor->textAutofitDpi);\n        if (descriptor->textWidth > 0) {\n          textOptions->set(\"width\", descriptor->textWidth);\n        }\n        // Ignore dpi if height is set\n        if (descriptor->textWidth > 0 && descriptor->textHeight > 0) {\n          textOptions->set(\"height\", descriptor->textHeight);\n        } else if (descriptor->textDpi > 0) {\n          textOptions->set(\"dpi\", descriptor->textDpi);\n        }\n        if (descriptor->textFont.length() > 0) {\n          textOptions->set(\"font\", const_cast<char*>(descriptor->textFont.data()));\n        }\n        if (descriptor->textFontfile.length() > 0) {\n          textOptions->set(\"fontfile\", const_cast<char*>(descriptor->textFontfile.data()));\n        }\n        image = VImage::text(const_cast<char *>(descriptor->textValue.data()), textOptions);\n        if (!descriptor->textRgba) {\n          image = image.copy(VImage::option()->set(\"interpretation\", VIPS_INTERPRETATION_B_W));\n        }\n        imageType = ImageType::RAW;\n      } else {\n        // From filesystem\n        imageType = DetermineImageType(descriptor->file.data());\n        if (imageType == ImageType::MISSING) {\n          if (descriptor->file.find(\"<svg\") != std::string::npos) {\n            throw vips::VError(\"Input file is missing, did you mean \"\n              \"sharp(Buffer.from('\" + descriptor->file.substr(0, 8) + \"...')?\");\n          }\n          throw vips::VError(\"Input file is missing: \" + descriptor->file);\n        }\n        if (imageType != ImageType::UNKNOWN) {\n          try {\n            vips::VOption *option = VImage::option()\n              ->set(\"access\", descriptor->access)\n              ->set(\"fail_on\", descriptor->failOn);\n            if (descriptor->unlimited && ImageTypeSupportsUnlimited(imageType)) {\n              option->set(\"unlimited\", true);\n            }\n            if (imageType == ImageType::SVG || imageType == ImageType::PDF) {\n              option->set(\"dpi\", descriptor->density);\n            }\n            if (imageType == ImageType::MAGICK) {\n              option->set(\"density\", std::to_string(descriptor->density).data());\n            }\n            if (ImageTypeSupportsPage(imageType)) {\n              option->set(\"n\", descriptor->pages);\n              option->set(\"page\", descriptor->page);\n            }\n            if (imageType == ImageType::OPENSLIDE) {\n              option->set(\"level\", descriptor->level);\n            }\n            if (imageType == ImageType::TIFF) {\n              option->set(\"subifd\", descriptor->subifd);\n            }\n            if (imageType == ImageType::PDF) {\n              option->set(\"background\", descriptor->pdfBackground);\n            }\n            image = VImage::new_from_file(descriptor->file.data(), option);\n            if (imageType == ImageType::SVG || imageType == ImageType::PDF || imageType == ImageType::MAGICK) {\n              image = SetDensity(image, descriptor->density);\n            }\n          } catch (vips::VError const &err) {\n            throw vips::VError(std::string(\"Input file has corrupt header: \") + err.what());\n          }\n        } else {\n          throw vips::VError(\"Input file contains unsupported image format\");\n        }\n      }\n    }\n\n    // Limit input images to a given number of pixels, where pixels = width * height\n    if (descriptor->limitInputPixels > 0 &&\n      static_cast<uint64_t>(image.width()) * image.height() > descriptor->limitInputPixels) {\n      throw vips::VError(\"Input image exceeds pixel limit\");\n    }\n    return std::make_tuple(image, imageType);\n  }\n\n  /*\n    Does this image have an embedded profile?\n  */\n  bool HasProfile(VImage image) {\n    return image.get_typeof(VIPS_META_ICC_NAME) == VIPS_TYPE_BLOB;\n  }\n\n  /*\n    Get copy of embedded profile.\n  */\n  std::pair<char*, size_t> GetProfile(VImage image) {\n    std::pair<char*, size_t> icc(nullptr, 0);\n    if (HasProfile(image)) {\n      size_t length;\n      const void *data = image.get_blob(VIPS_META_ICC_NAME, &length);\n      icc.first = static_cast<char*>(g_malloc(length));\n      icc.second = length;\n      memcpy(icc.first, data, length);\n    }\n    return icc;\n  }\n\n  /*\n    Set embedded profile.\n  */\n  VImage SetProfile(VImage image, std::pair<char*, size_t> icc) {\n    if (icc.first != nullptr) {\n      image = image.copy();\n      image.set(VIPS_META_ICC_NAME, reinterpret_cast<VipsCallbackFn>(vips_area_free_cb), icc.first, icc.second);\n    }\n    return image;\n  }\n\n  static void* RemoveExifCallback(VipsImage *image, char const *field, GValue *value, void *data) {\n    std::vector<std::string> *fieldNames = static_cast<std::vector<std::string> *>(data);\n    std::string fieldName(field);\n    if (fieldName.substr(0, 8) == (\"exif-ifd\")) {\n      fieldNames->push_back(fieldName);\n    }\n    return nullptr;\n  }\n\n  /*\n    Remove all EXIF-related image fields.\n  */\n  VImage RemoveExif(VImage image) {\n    std::vector<std::string> fieldNames;\n    vips_image_map(image.get_image(), static_cast<VipsImageMapFn>(RemoveExifCallback), &fieldNames);\n    for (const auto& f : fieldNames) {\n      image.remove(f.data());\n    }\n    return image;\n  }\n\n  /*\n    Get EXIF Orientation of image, if any.\n  */\n  int ExifOrientation(VImage image) {\n    int orientation = 0;\n    if (image.get_typeof(VIPS_META_ORIENTATION) != 0) {\n      orientation = image.get_int(VIPS_META_ORIENTATION);\n    }\n    return orientation;\n  }\n\n  /*\n    Set EXIF Orientation of image.\n  */\n  VImage SetExifOrientation(VImage image, int const orientation) {\n    VImage copy = image.copy();\n    copy.set(VIPS_META_ORIENTATION, orientation);\n    return copy;\n  }\n\n  /*\n    Remove EXIF Orientation from image.\n  */\n  VImage RemoveExifOrientation(VImage image) {\n    VImage copy = image.copy();\n    copy.remove(VIPS_META_ORIENTATION);\n    copy.remove(\"exif-ifd0-Orientation\");\n    return copy;\n  }\n\n  /*\n    Set animation properties if necessary.\n  */\n  VImage SetAnimationProperties(VImage image, int nPages, int pageHeight, std::vector<int> delay, int loop) {\n    bool hasDelay = !delay.empty();\n\n    // Avoid a copy if none of the animation properties are needed.\n    if (nPages == 1 && !hasDelay && loop == -1) return image;\n\n    if (delay.size() == 1) {\n      // We have just one delay, repeat that value for all frames.\n      delay.insert(delay.end(), nPages - 1, delay[0]);\n    }\n\n    // Attaching metadata, need to copy the image.\n    VImage copy = image.copy();\n\n    // Only set page-height if we have more than one page, or this could\n    // accidentally turn into an animated image later.\n    if (nPages > 1) copy.set(VIPS_META_PAGE_HEIGHT, pageHeight);\n    if (hasDelay) copy.set(\"delay\", delay);\n    if (loop != -1) copy.set(\"loop\", loop);\n\n    return copy;\n  }\n\n  /*\n    Remove animation properties from image.\n  */\n  VImage RemoveAnimationProperties(VImage image) {\n    VImage copy = image.copy();\n    copy.remove(VIPS_META_PAGE_HEIGHT);\n    copy.remove(\"delay\");\n    copy.remove(\"loop\");\n    return copy;\n  }\n\n  /*\n    Remove GIF palette from image.\n  */\n  VImage RemoveGifPalette(VImage image) {\n    VImage copy = image.copy();\n    copy.remove(\"gif-palette\");\n    return copy;\n  }\n\n  /*\n    Does this image have a non-default density?\n  */\n  bool HasDensity(VImage image) {\n    return image.xres() > 1.0;\n  }\n\n  /*\n    Get pixels/mm resolution as pixels/inch density.\n  */\n  int GetDensity(VImage image) {\n    return static_cast<int>(round(image.xres() * 25.4));\n  }\n\n  /*\n    Set pixels/mm resolution based on a pixels/inch density.\n  */\n  VImage SetDensity(VImage image, const double density) {\n    const double pixelsPerMm = density / 25.4;\n    VImage copy = image.copy();\n    copy.get_image()->Xres = pixelsPerMm;\n    copy.get_image()->Yres = pixelsPerMm;\n    return copy;\n  }\n\n  /*\n    Multi-page images can have a page height. Fetch it, and sanity check it.\n    If page-height is not set, it defaults to the image height\n  */\n  int GetPageHeight(VImage image) {\n    return vips_image_get_page_height(image.get_image());\n  }\n\n  /*\n    Check the proposed format supports the current dimensions.\n  */\n  void AssertImageTypeDimensions(VImage image, ImageType const imageType) {\n    const int height = image.get_typeof(VIPS_META_PAGE_HEIGHT) == G_TYPE_INT\n      ? image.get_int(VIPS_META_PAGE_HEIGHT)\n      : image.height();\n    if (imageType == ImageType::JPEG) {\n      if (image.width() > 65535 || height > 65535) {\n        throw vips::VError(\"Processed image is too large for the JPEG format\");\n      }\n    } else if (imageType == ImageType::WEBP) {\n      if (image.width() > 16383 || height > 16383) {\n        throw vips::VError(\"Processed image is too large for the WebP format\");\n      }\n    } else if (imageType == ImageType::GIF) {\n      if (image.width() > 65535 || height > 65535) {\n        throw vips::VError(\"Processed image is too large for the GIF format\");\n      }\n    } else if (imageType == ImageType::HEIF) {\n      if (image.width() > 16384 || height > 16384) {\n        throw vips::VError(\"Processed image is too large for the HEIF format\");\n      }\n    }\n  }\n\n  /*\n    Called when a Buffer undergoes GC, required to support mixed runtime libraries in Windows\n  */\n  std::function<void(void*, char*)> FreeCallback = [](void*, char* data) {\n    g_free(data);\n  };\n\n  /*\n    Temporary buffer of warnings\n  */\n  std::queue<std::string> vipsWarnings;\n  std::mutex vipsWarningsMutex;\n\n  /*\n    Called with warnings from the glib-registered \"VIPS\" domain\n  */\n  void VipsWarningCallback(char const* log_domain, GLogLevelFlags log_level, char const* message, void* ignore) {\n    std::lock_guard<std::mutex> lock(vipsWarningsMutex);\n    vipsWarnings.emplace(message);\n  }\n\n  /*\n    Pop the oldest warning message from the queue\n  */\n  std::string VipsWarningPop() {\n    std::string warning;\n    std::lock_guard<std::mutex> lock(vipsWarningsMutex);\n    if (!vipsWarnings.empty()) {\n      warning = vipsWarnings.front();\n      vipsWarnings.pop();\n    }\n    return warning;\n  }\n\n  /*\n    Attach an event listener for progress updates, used to detect timeout\n  */\n  void SetTimeout(VImage image, int const seconds) {\n    if (seconds > 0) {\n      VipsImage *im = image.get_image();\n      if (im->progress_signal == NULL) {\n        int *timeout = VIPS_NEW(im, int);\n        *timeout = seconds;\n        g_signal_connect(im, \"eval\", G_CALLBACK(VipsProgressCallBack), timeout);\n        vips_image_set_progress(im, true);\n      }\n    }\n  }\n\n  /*\n    Event listener for progress updates, used to detect timeout\n  */\n  void VipsProgressCallBack(VipsImage *im, VipsProgress *progress, int *timeout) {\n    if (*timeout > 0 && progress->run >= *timeout) {\n      vips_image_set_kill(im, true);\n      vips_error(\"timeout\", \"%d%% complete\", progress->percent);\n      *timeout = 0;\n    }\n  }\n\n  /*\n    Calculate the (left, top) coordinates of the output image\n    within the input image, applying the given gravity during an embed.\n\n    @Azurebyte: We are basically swapping the inWidth and outWidth, inHeight and outHeight from the CalculateCrop function.\n  */\n  std::tuple<int, int> CalculateEmbedPosition(int const inWidth, int const inHeight,\n    int const outWidth, int const outHeight, int const gravity) {\n\n    int left = 0;\n    int top = 0;\n    switch (gravity) {\n      case 1:\n        // North\n        left = (outWidth - inWidth) / 2;\n        break;\n      case 2:\n        // East\n        left = outWidth - inWidth;\n        top = (outHeight - inHeight) / 2;\n        break;\n      case 3:\n        // South\n        left = (outWidth - inWidth) / 2;\n        top = outHeight - inHeight;\n        break;\n      case 4:\n        // West\n        top = (outHeight - inHeight) / 2;\n        break;\n      case 5:\n        // Northeast\n        left = outWidth - inWidth;\n        break;\n      case 6:\n        // Southeast\n        left = outWidth - inWidth;\n        top = outHeight - inHeight;\n        break;\n      case 7:\n        // Southwest\n        top = outHeight - inHeight;\n        break;\n      case 8:\n        // Northwest\n        // Which is the default is 0,0 so we do not assign anything here.\n        break;\n      default:\n        // Centre\n        left = (outWidth - inWidth) / 2;\n        top = (outHeight - inHeight) / 2;\n    }\n    return std::make_tuple(left, top);\n  }\n\n  /*\n    Calculate the (left, top) coordinates of the output image\n    within the input image, applying the given gravity during a crop.\n  */\n  std::tuple<int, int> CalculateCrop(int const inWidth, int const inHeight,\n    int const outWidth, int const outHeight, int const gravity) {\n\n    int left = 0;\n    int top = 0;\n    switch (gravity) {\n      case 1:\n        // North\n        left = (inWidth - outWidth + 1) / 2;\n        break;\n      case 2:\n        // East\n        left = inWidth - outWidth;\n        top = (inHeight - outHeight + 1) / 2;\n        break;\n      case 3:\n        // South\n        left = (inWidth - outWidth + 1) / 2;\n        top = inHeight - outHeight;\n        break;\n      case 4:\n        // West\n        top = (inHeight - outHeight + 1) / 2;\n        break;\n      case 5:\n        // Northeast\n        left = inWidth - outWidth;\n        break;\n      case 6:\n        // Southeast\n        left = inWidth - outWidth;\n        top = inHeight - outHeight;\n        break;\n      case 7:\n        // Southwest\n        top = inHeight - outHeight;\n        break;\n      case 8:\n        // Northwest\n        break;\n      default:\n        // Centre\n        left = (inWidth - outWidth + 1) / 2;\n        top = (inHeight - outHeight + 1) / 2;\n    }\n    return std::make_tuple(left, top);\n  }\n\n  /*\n    Calculate the (left, top) coordinates of the output image\n    within the input image, applying the given x and y offsets.\n  */\n  std::tuple<int, int> CalculateCrop(int const inWidth, int const inHeight,\n    int const outWidth, int const outHeight, int const x, int const y) {\n\n    // default values\n    int left = 0;\n    int top = 0;\n\n    // assign only if valid\n    if (x < (inWidth - outWidth)) {\n      left = x;\n    } else if (x >= (inWidth - outWidth)) {\n      left = inWidth - outWidth;\n    }\n\n    if (y < (inHeight - outHeight)) {\n      top = y;\n    } else if (y >= (inHeight - outHeight)) {\n      top = inHeight - outHeight;\n    }\n\n    return std::make_tuple(left, top);\n  }\n\n  /*\n    Are pixel values in this image 16-bit integer?\n  */\n  bool Is16Bit(VipsInterpretation const interpretation) {\n    return interpretation == VIPS_INTERPRETATION_RGB16 || interpretation == VIPS_INTERPRETATION_GREY16;\n  }\n\n  /*\n    Return the image alpha maximum. Useful for combining alpha bands. scRGB\n    images are 0 - 1 for image data, but the alpha is 0 - 255.\n  */\n  double MaximumImageAlpha(VipsInterpretation const interpretation) {\n    return Is16Bit(interpretation) ? 65535.0 : 255.0;\n  }\n\n  /*\n    Convert RGBA value to another colourspace\n  */\n  std::vector<double> GetRgbaAsColourspace(std::vector<double> const rgba,\n    VipsInterpretation const interpretation, bool premultiply) {\n    int const bands = static_cast<int>(rgba.size());\n    if (bands < 3) {\n      return rgba;\n    }\n    VImage pixel = VImage::new_matrix(1, 1);\n    pixel.set(\"bands\", bands);\n    pixel = pixel\n      .new_from_image(rgba)\n      .colourspace(interpretation, VImage::option()->set(\"source_space\", VIPS_INTERPRETATION_sRGB));\n    if (premultiply) {\n      pixel = pixel.premultiply();\n    }\n    return pixel(0, 0);\n  }\n\n  /*\n    Apply the alpha channel to a given colour\n  */\n  std::tuple<VImage, std::vector<double>> ApplyAlpha(VImage image, std::vector<double> colour, bool premultiply) {\n    // Scale up 8-bit values to match 16-bit input image\n    double const multiplier = sharp::Is16Bit(image.interpretation()) ? 256.0 : 1.0;\n    // Create alphaColour colour\n    std::vector<double> alphaColour;\n    if (image.bands() > 2) {\n      alphaColour = {\n        multiplier * colour[0],\n        multiplier * colour[1],\n        multiplier * colour[2]\n      };\n    } else {\n      // Convert sRGB to greyscale\n      alphaColour = { multiplier * (\n        0.2126 * colour[0] +\n        0.7152 * colour[1] +\n        0.0722 * colour[2])\n      };\n    }\n    // Add alpha channel to alphaColour colour\n    if (colour[3] < 255.0 || image.has_alpha()) {\n      alphaColour.push_back(colour[3] * multiplier);\n    }\n    // Ensure alphaColour colour uses correct colourspace\n    alphaColour = sharp::GetRgbaAsColourspace(alphaColour, image.interpretation(), premultiply);\n    // Add non-transparent alpha channel, if required\n    if (colour[3] < 255.0 && !image.has_alpha()) {\n      image = image.bandjoin(\n        VImage::new_matrix(image.width(), image.height()).new_from_image(255 * multiplier).cast(image.format()));\n    }\n    return std::make_tuple(image, alphaColour);\n  }\n\n  /*\n    Removes alpha channels, if any.\n  */\n  VImage RemoveAlpha(VImage image) {\n    while (image.bands() > 1 && image.has_alpha()) {\n      image = image.extract_band(0, VImage::option()->set(\"n\", image.bands() - 1));\n    }\n    return image;\n  }\n\n  /*\n    Ensures alpha channel, if missing.\n  */\n  VImage EnsureAlpha(VImage image, double const value) {\n    if (!image.has_alpha()) {\n      std::vector<double> alpha;\n      alpha.push_back(value * sharp::MaximumImageAlpha(image.interpretation()));\n      image = image.bandjoin_const(alpha);\n    }\n    return image;\n  }\n\n  std::pair<double, double> ResolveShrink(int width, int height, int targetWidth, int targetHeight,\n    Canvas canvas, bool withoutEnlargement, bool withoutReduction) {\n    double hshrink = 1.0;\n    double vshrink = 1.0;\n\n    if (targetWidth > 0 && targetHeight > 0) {\n      // Fixed width and height\n      hshrink = static_cast<double>(width) / targetWidth;\n      vshrink = static_cast<double>(height) / targetHeight;\n\n      switch (canvas) {\n        case Canvas::CROP:\n        case Canvas::MIN:\n          if (hshrink < vshrink) {\n            vshrink = hshrink;\n          } else {\n            hshrink = vshrink;\n          }\n          break;\n        case Canvas::EMBED:\n        case Canvas::MAX:\n          if (hshrink > vshrink) {\n            vshrink = hshrink;\n          } else {\n            hshrink = vshrink;\n          }\n          break;\n        case Canvas::IGNORE_ASPECT:\n          break;\n      }\n    } else if (targetWidth > 0) {\n      // Fixed width\n      hshrink = static_cast<double>(width) / targetWidth;\n\n      if (canvas != Canvas::IGNORE_ASPECT) {\n        // Auto height\n        vshrink = hshrink;\n      }\n    } else if (targetHeight > 0) {\n      // Fixed height\n      vshrink = static_cast<double>(height) / targetHeight;\n\n      if (canvas != Canvas::IGNORE_ASPECT) {\n        // Auto width\n        hshrink = vshrink;\n      }\n    }\n\n    // We should not reduce or enlarge the output image, if\n    // withoutReduction or withoutEnlargement is specified.\n    if (withoutReduction) {\n      // Equivalent of VIPS_SIZE_UP\n      hshrink = std::min(1.0, hshrink);\n      vshrink = std::min(1.0, vshrink);\n    } else if (withoutEnlargement) {\n      // Equivalent of VIPS_SIZE_DOWN\n      hshrink = std::max(1.0, hshrink);\n      vshrink = std::max(1.0, vshrink);\n    }\n\n    // We don't want to shrink so much that we send an axis to 0\n    hshrink = std::min(hshrink, static_cast<double>(width));\n    vshrink = std::min(vshrink, static_cast<double>(height));\n\n    return std::make_pair(hshrink, vshrink);\n  }\n\n  /*\n    Ensure decoding remains sequential.\n  */\n  VImage StaySequential(VImage image, bool condition) {\n    if (vips_image_is_sequential(image.get_image()) && condition) {\n      image = image.copy_memory().copy();\n      image.remove(VIPS_META_SEQUENTIAL);\n    }\n    return image;\n  }\n}  // namespace sharp\n"
        }
    ]
}