{
    "sourceFile": "node_modules/sharp/src/common.h",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893029138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n#ifndef SRC_COMMON_H_\n#define SRC_COMMON_H_\n\n#include <string>\n#include <tuple>\n#include <vector>\n#include <atomic>\n\n#include <napi.h>\n#include <vips/vips8>\n\n// Verify platform and compiler compatibility\n\n#if (VIPS_MAJOR_VERSION < 8) || \\\n  (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION < 16) || \\\n  (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION == 16 && VIPS_MICRO_VERSION < 1)\n#error \"libvips version 8.16.1+ is required - please see https://sharp.pixelplumbing.com/install\"\n#endif\n\n#if defined(__has_include)\n#if !__has_include(<filesystem>)\n#error \"C++17 compiler required - please see https://sharp.pixelplumbing.com/install\"\n#endif\n#endif\n\nusing vips::VImage;\n\nnamespace sharp {\n\n  struct InputDescriptor {  // NOLINT(runtime/indentation_namespace)\n    std::string name;\n    std::string file;\n    bool autoOrient;\n    char *buffer;\n    VipsFailOn failOn;\n    uint64_t limitInputPixels;\n    bool unlimited;\n    VipsAccess access;\n    size_t bufferLength;\n    bool isBuffer;\n    double density;\n    bool ignoreIcc;\n    VipsBandFormat rawDepth;\n    int rawChannels;\n    int rawWidth;\n    int rawHeight;\n    bool rawPremultiplied;\n    int pages;\n    int page;\n    int level;\n    int subifd;\n    int createChannels;\n    int createWidth;\n    int createHeight;\n    std::vector<double> createBackground;\n    std::string createNoiseType;\n    double createNoiseMean;\n    double createNoiseSigma;\n    std::string textValue;\n    std::string textFont;\n    std::string textFontfile;\n    int textWidth;\n    int textHeight;\n    VipsAlign textAlign;\n    bool textJustify;\n    int textDpi;\n    bool textRgba;\n    int textSpacing;\n    VipsTextWrap textWrap;\n    int textAutofitDpi;\n    bool joinAnimated;\n    int joinAcross;\n    int joinShim;\n    std::vector<double> joinBackground;\n    VipsAlign joinHalign;\n    VipsAlign joinValign;\n    std::vector<double> pdfBackground;\n\n    InputDescriptor():\n      autoOrient(false),\n      buffer(nullptr),\n      failOn(VIPS_FAIL_ON_WARNING),\n      limitInputPixels(0x3FFF * 0x3FFF),\n      unlimited(false),\n      access(VIPS_ACCESS_SEQUENTIAL),\n      bufferLength(0),\n      isBuffer(false),\n      density(72.0),\n      ignoreIcc(false),\n      rawDepth(VIPS_FORMAT_UCHAR),\n      rawChannels(0),\n      rawWidth(0),\n      rawHeight(0),\n      rawPremultiplied(false),\n      pages(1),\n      page(0),\n      level(0),\n      subifd(-1),\n      createChannels(0),\n      createWidth(0),\n      createHeight(0),\n      createBackground{ 0.0, 0.0, 0.0, 255.0 },\n      createNoiseMean(0.0),\n      createNoiseSigma(0.0),\n      textWidth(0),\n      textHeight(0),\n      textAlign(VIPS_ALIGN_LOW),\n      textJustify(false),\n      textDpi(72),\n      textRgba(false),\n      textSpacing(0),\n      textWrap(VIPS_TEXT_WRAP_WORD),\n      textAutofitDpi(0),\n      joinAnimated(false),\n      joinAcross(1),\n      joinShim(0),\n      joinBackground{ 0.0, 0.0, 0.0, 255.0 },\n      joinHalign(VIPS_ALIGN_LOW),\n      joinValign(VIPS_ALIGN_LOW),\n      pdfBackground{ 255.0, 255.0, 255.0, 255.0 } {}\n  };\n\n  // Convenience methods to access the attributes of a Napi::Object\n  bool HasAttr(Napi::Object obj, std::string attr);\n  std::string AttrAsStr(Napi::Object obj, std::string attr);\n  std::string AttrAsStr(Napi::Object obj, unsigned int const attr);\n  uint32_t AttrAsUint32(Napi::Object obj, std::string attr);\n  int32_t AttrAsInt32(Napi::Object obj, std::string attr);\n  int32_t AttrAsInt32(Napi::Object obj, unsigned int const attr);\n  double AttrAsDouble(Napi::Object obj, std::string attr);\n  double AttrAsDouble(Napi::Object obj, unsigned int const attr);\n  bool AttrAsBool(Napi::Object obj, std::string attr);\n  std::vector<double> AttrAsVectorOfDouble(Napi::Object obj, std::string attr);\n  std::vector<int32_t> AttrAsInt32Vector(Napi::Object obj, std::string attr);\n  template <class T> T AttrAsEnum(Napi::Object obj, std::string attr, GType type) {\n    return static_cast<T>(\n      vips_enum_from_nick(nullptr, type, AttrAsStr(obj, attr).data()));\n  }\n\n  // Create an InputDescriptor instance from a Napi::Object describing an input image\n  InputDescriptor* CreateInputDescriptor(Napi::Object input);\n\n  enum class ImageType {\n    JPEG,\n    PNG,\n    WEBP,\n    JP2,\n    TIFF,\n    GIF,\n    SVG,\n    HEIF,\n    PDF,\n    MAGICK,\n    OPENSLIDE,\n    PPM,\n    FITS,\n    EXR,\n    JXL,\n    RAD,\n    VIPS,\n    RAW,\n    UNKNOWN,\n    MISSING\n  };\n\n  enum class Canvas {\n      CROP,\n      EMBED,\n      MAX,\n      MIN,\n      IGNORE_ASPECT\n  };\n\n  // How many tasks are in the queue?\n  extern std::atomic<int> counterQueue;\n\n  // How many tasks are being processed?\n  extern std::atomic<int> counterProcess;\n\n  // Filename extension checkers\n  bool IsJpeg(std::string const &str);\n  bool IsPng(std::string const &str);\n  bool IsWebp(std::string const &str);\n  bool IsJp2(std::string const &str);\n  bool IsGif(std::string const &str);\n  bool IsTiff(std::string const &str);\n  bool IsHeic(std::string const &str);\n  bool IsHeif(std::string const &str);\n  bool IsAvif(std::string const &str);\n  bool IsJxl(std::string const &str);\n  bool IsDz(std::string const &str);\n  bool IsDzZip(std::string const &str);\n  bool IsV(std::string const &str);\n\n  /*\n    Trim space from end of string.\n  */\n  std::string TrimEnd(std::string const &str);\n\n  /*\n    Provide a string identifier for the given image type.\n  */\n  std::string ImageTypeId(ImageType const imageType);\n\n  /*\n    Determine image format of a buffer.\n  */\n  ImageType DetermineImageType(void *buffer, size_t const length);\n\n  /*\n    Determine image format of a file.\n  */\n  ImageType DetermineImageType(char const *file);\n\n  /*\n    Does this image type support multiple pages?\n  */\n  bool ImageTypeSupportsPage(ImageType imageType);\n\n  /*\n    Does this image type support removal of safety limits?\n  */\n  bool ImageTypeSupportsUnlimited(ImageType imageType);\n\n  /*\n    Open an image from the given InputDescriptor (filesystem, compressed buffer, raw pixel data)\n  */\n  std::tuple<VImage, ImageType> OpenInput(InputDescriptor *descriptor);\n\n  /*\n    Does this image have an embedded profile?\n  */\n  bool HasProfile(VImage image);\n\n  /*\n    Get copy of embedded profile.\n  */\n  std::pair<char*, size_t> GetProfile(VImage image);\n\n  /*\n    Set embedded profile.\n  */\n  VImage SetProfile(VImage image, std::pair<char*, size_t> icc);\n\n  /*\n    Remove all EXIF-related image fields.\n  */\n  VImage RemoveExif(VImage image);\n\n  /*\n    Get EXIF Orientation of image, if any.\n  */\n  int ExifOrientation(VImage image);\n\n  /*\n    Set EXIF Orientation of image.\n  */\n  VImage SetExifOrientation(VImage image, int const orientation);\n\n  /*\n    Remove EXIF Orientation from image.\n  */\n  VImage RemoveExifOrientation(VImage image);\n\n  /*\n    Set animation properties if necessary.\n  */\n  VImage SetAnimationProperties(VImage image, int nPages, int pageHeight, std::vector<int> delay, int loop);\n\n  /*\n    Remove animation properties from image.\n  */\n  VImage RemoveAnimationProperties(VImage image);\n\n  /*\n    Remove GIF palette from image.\n  */\n  VImage RemoveGifPalette(VImage image);\n\n  /*\n    Does this image have a non-default density?\n  */\n  bool HasDensity(VImage image);\n\n  /*\n    Get pixels/mm resolution as pixels/inch density.\n  */\n  int GetDensity(VImage image);\n\n  /*\n    Set pixels/mm resolution based on a pixels/inch density.\n  */\n  VImage SetDensity(VImage image, const double density);\n\n  /*\n    Multi-page images can have a page height. Fetch it, and sanity check it.\n    If page-height is not set, it defaults to the image height\n  */\n  int GetPageHeight(VImage image);\n\n  /*\n    Check the proposed format supports the current dimensions.\n  */\n  void AssertImageTypeDimensions(VImage image, ImageType const imageType);\n\n  /*\n    Called when a Buffer undergoes GC, required to support mixed runtime libraries in Windows\n  */\n  extern std::function<void(void*, char*)> FreeCallback;\n\n  /*\n    Called with warnings from the glib-registered \"VIPS\" domain\n  */\n  void VipsWarningCallback(char const* log_domain, GLogLevelFlags log_level, char const* message, void* ignore);\n\n  /*\n    Pop the oldest warning message from the queue\n  */\n  std::string VipsWarningPop();\n\n  /*\n    Attach an event listener for progress updates, used to detect timeout\n  */\n  void SetTimeout(VImage image, int const timeoutSeconds);\n\n  /*\n    Event listener for progress updates, used to detect timeout\n  */\n  void VipsProgressCallBack(VipsImage *image, VipsProgress *progress, int *timeoutSeconds);\n\n  /*\n    Calculate the (left, top) coordinates of the output image\n    within the input image, applying the given gravity during an embed.\n  */\n  std::tuple<int, int> CalculateEmbedPosition(int const inWidth, int const inHeight,\n    int const outWidth, int const outHeight, int const gravity);\n\n  /*\n    Calculate the (left, top) coordinates of the output image\n    within the input image, applying the given gravity.\n  */\n  std::tuple<int, int> CalculateCrop(int const inWidth, int const inHeight,\n    int const outWidth, int const outHeight, int const gravity);\n\n  /*\n    Calculate the (left, top) coordinates of the output image\n    within the input image, applying the given x and y offsets of the output image.\n  */\n  std::tuple<int, int> CalculateCrop(int const inWidth, int const inHeight,\n    int const outWidth, int const outHeight, int const x, int const y);\n\n  /*\n    Are pixel values in this image 16-bit integer?\n  */\n  bool Is16Bit(VipsInterpretation const interpretation);\n\n  /*\n    Return the image alpha maximum. Useful for combining alpha bands. scRGB\n    images are 0 - 1 for image data, but the alpha is 0 - 255.\n  */\n  double MaximumImageAlpha(VipsInterpretation const interpretation);\n\n  /*\n    Convert RGBA value to another colourspace\n  */\n  std::vector<double> GetRgbaAsColourspace(std::vector<double> const rgba,\n    VipsInterpretation const interpretation, bool premultiply);\n\n  /*\n    Apply the alpha channel to a given colour\n   */\n  std::tuple<VImage, std::vector<double>> ApplyAlpha(VImage image, std::vector<double> colour, bool premultiply);\n\n  /*\n    Removes alpha channels, if any.\n  */\n  VImage RemoveAlpha(VImage image);\n\n  /*\n    Ensures alpha channel, if missing.\n  */\n  VImage EnsureAlpha(VImage image, double const value);\n\n  /*\n    Calculate the horizontal and vertical shrink factors, taking the canvas mode into account.\n  */\n  std::pair<double, double> ResolveShrink(int width, int height, int targetWidth, int targetHeight,\n    Canvas canvas, bool withoutEnlargement, bool withoutReduction);\n\n  /*\n    Ensure decoding remains sequential.\n  */\n  VImage StaySequential(VImage image, bool condition = true);\n\n}  // namespace sharp\n\n#endif  // SRC_COMMON_H_\n"
        }
    ]
}