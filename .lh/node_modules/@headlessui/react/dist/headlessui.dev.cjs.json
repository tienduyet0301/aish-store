{
    "sourceFile": "node_modules/@headlessui/react/dist/headlessui.dev.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891766102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Button: () => Button,\n  Checkbox: () => Checkbox,\n  CloseButton: () => CloseButton,\n  Combobox: () => Combobox,\n  ComboboxButton: () => ComboboxButton,\n  ComboboxInput: () => ComboboxInput,\n  ComboboxLabel: () => ComboboxLabel,\n  ComboboxOption: () => ComboboxOption,\n  ComboboxOptions: () => ComboboxOptions,\n  DataInteractive: () => DataInteractive,\n  Description: () => Description,\n  Dialog: () => Dialog,\n  DialogBackdrop: () => DialogBackdrop,\n  DialogDescription: () => DialogDescription,\n  DialogPanel: () => DialogPanel,\n  DialogTitle: () => DialogTitle,\n  Disclosure: () => Disclosure,\n  DisclosureButton: () => DisclosureButton,\n  DisclosurePanel: () => DisclosurePanel,\n  Field: () => Field,\n  Fieldset: () => Fieldset,\n  FocusTrap: () => FocusTrap,\n  FocusTrapFeatures: () => FocusTrapFeatures,\n  Input: () => Input,\n  Label: () => Label,\n  Legend: () => Legend,\n  Listbox: () => Listbox,\n  ListboxButton: () => ListboxButton,\n  ListboxLabel: () => ListboxLabel,\n  ListboxOption: () => ListboxOption,\n  ListboxOptions: () => ListboxOptions,\n  ListboxSelectedOption: () => ListboxSelectedOption,\n  Menu: () => Menu,\n  MenuButton: () => MenuButton,\n  MenuHeading: () => MenuHeading,\n  MenuItem: () => MenuItem,\n  MenuItems: () => MenuItems,\n  MenuSection: () => MenuSection,\n  MenuSeparator: () => MenuSeparator,\n  Popover: () => Popover,\n  PopoverBackdrop: () => PopoverBackdrop,\n  PopoverButton: () => PopoverButton,\n  PopoverGroup: () => PopoverGroup,\n  PopoverOverlay: () => PopoverOverlay,\n  PopoverPanel: () => PopoverPanel,\n  Portal: () => Portal,\n  Radio: () => Radio,\n  RadioGroup: () => RadioGroup,\n  RadioGroupDescription: () => RadioGroupDescription,\n  RadioGroupLabel: () => RadioGroupLabel,\n  RadioGroupOption: () => RadioGroupOption,\n  Select: () => Select,\n  Switch: () => Switch,\n  SwitchDescription: () => SwitchDescription,\n  SwitchGroup: () => SwitchGroup,\n  SwitchLabel: () => SwitchLabel,\n  Tab: () => Tab,\n  TabGroup: () => TabGroup,\n  TabList: () => TabList,\n  TabPanel: () => TabPanel,\n  TabPanels: () => TabPanels,\n  Textarea: () => Textarea,\n  Transition: () => Transition,\n  TransitionChild: () => TransitionChild,\n  useClose: () => useClose\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// ../../node_modules/@react-aria/utils/dist/useLayoutEffect.mjs\nvar import_react = __toESM(require(\"react\"), 1);\nvar $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== \"undefined\" ? (0, import_react.default).useLayoutEffect : () => {\n};\n\n// ../../node_modules/@react-aria/utils/dist/useEffectEvent.mjs\nvar import_react2 = require(\"react\");\nfunction $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n  const ref = (0, import_react2.useRef)(null);\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    ref.current = fn;\n  }, [\n    fn\n  ]);\n  return (0, import_react2.useCallback)((...args) => {\n    const f = ref.current;\n    return f === null || f === void 0 ? void 0 : f(...args);\n  }, []);\n}\n\n// ../../node_modules/@react-aria/utils/dist/domHelpers.mjs\nvar $431fbd86ca7dc216$export$b204af158042fbac = (el) => {\n  var _el_ownerDocument;\n  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n};\nvar $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {\n  if (el && \"window\" in el && el.window === el)\n    return el;\n  const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);\n  return doc.defaultView || window;\n};\n\n// ../../node_modules/@react-aria/utils/dist/platform.mjs\nfunction $c87311424ea30a05$var$testUserAgent(re) {\n  var _window_navigator_userAgentData;\n  if (typeof window === \"undefined\" || window.navigator == null)\n    return false;\n  return ((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n  var _window_navigator_userAgentData;\n  return typeof window !== \"undefined\" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator[\"userAgentData\"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n  return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n  return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\n\n// ../../node_modules/@react-aria/utils/dist/isVirtualEvent.mjs\nfunction $6a7db85432448f7f$export$60278871457622de(event) {\n  if (event.mozInputSource === 0 && event.isTrusted)\n    return true;\n  if ((0, $c87311424ea30a05$export$a11b0059900ceec8)() && event.pointerType)\n    return event.type === \"click\" && event.buttons === 1;\n  return event.detail === 0 && !event.pointerType;\n}\n\n// ../../node_modules/@react-aria/interactions/dist/utils.mjs\nvar import_react3 = require(\"react\");\nvar $8a9cb279dc87e130$export$905e7fc544a71f36 = class {\n  isDefaultPrevented() {\n    return this.nativeEvent.defaultPrevented;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n    this.nativeEvent.preventDefault();\n  }\n  stopPropagation() {\n    this.nativeEvent.stopPropagation();\n    this.isPropagationStopped = () => true;\n  }\n  isPropagationStopped() {\n    return false;\n  }\n  persist() {\n  }\n  constructor(type, nativeEvent) {\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEvent.target;\n    this.currentTarget = nativeEvent.currentTarget;\n    this.relatedTarget = nativeEvent.relatedTarget;\n    this.bubbles = nativeEvent.bubbles;\n    this.cancelable = nativeEvent.cancelable;\n    this.defaultPrevented = nativeEvent.defaultPrevented;\n    this.eventPhase = nativeEvent.eventPhase;\n    this.isTrusted = nativeEvent.isTrusted;\n    this.timeStamp = nativeEvent.timeStamp;\n    this.type = type;\n  }\n};\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n  let stateRef = (0, import_react3.useRef)({\n    isFocused: false,\n    observer: null\n  });\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    const state = stateRef.current;\n    return () => {\n      if (state.observer) {\n        state.observer.disconnect();\n        state.observer = null;\n      }\n    };\n  }, []);\n  let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a52)((e) => {\n    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n  });\n  return (0, import_react3.useCallback)((e) => {\n    if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n      stateRef.current.isFocused = true;\n      let target = e.target;\n      let onBlurHandler = (e2) => {\n        stateRef.current.isFocused = false;\n        if (target.disabled)\n          dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36(\"blur\", e2));\n        if (stateRef.current.observer) {\n          stateRef.current.observer.disconnect();\n          stateRef.current.observer = null;\n        }\n      };\n      target.addEventListener(\"focusout\", onBlurHandler, {\n        once: true\n      });\n      stateRef.current.observer = new MutationObserver(() => {\n        if (stateRef.current.isFocused && target.disabled) {\n          var _stateRef_current_observer;\n          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();\n          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent(\"blur\", {\n            relatedTarget: relatedTargetEl\n          }));\n          target.dispatchEvent(new FocusEvent(\"focusout\", {\n            bubbles: true,\n            relatedTarget: relatedTargetEl\n          }));\n        }\n      });\n      stateRef.current.observer.observe(target, {\n        attributes: true,\n        attributeFilter: [\n          \"disabled\"\n        ]\n      });\n    }\n  }, [\n    dispatchBlur\n  ]);\n}\n\n// ../../node_modules/@react-aria/interactions/dist/useFocus.mjs\nvar import_react4 = require(\"react\");\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;\n  const onBlur = (0, import_react4.useCallback)((e) => {\n    if (e.target === e.currentTarget) {\n      if (onBlurProp)\n        onBlurProp(e);\n      if (onFocusChange)\n        onFocusChange(false);\n      return true;\n    }\n  }, [\n    onBlurProp,\n    onFocusChange\n  ]);\n  const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n  const onFocus = (0, import_react4.useCallback)((e) => {\n    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac)(e.target);\n    if (e.target === e.currentTarget && ownerDocument.activeElement === e.target) {\n      if (onFocusProp)\n        onFocusProp(e);\n      if (onFocusChange)\n        onFocusChange(true);\n      onSyntheticFocus(e);\n    }\n  }, [\n    onFocusChange,\n    onFocusProp,\n    onSyntheticFocus\n  ]);\n  return {\n    focusProps: {\n      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,\n      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0\n    }\n  };\n}\n\n// ../../node_modules/@react-aria/interactions/dist/useFocusVisible.mjs\nvar import_react5 = require(\"react\");\nvar $507fabe10e71c6fb$var$currentModality = null;\nvar $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();\nvar $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();\nvar $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nvar $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\nvar $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n  for (let handler of $507fabe10e71c6fb$var$changeHandlers)\n    handler(modality, e);\n}\nfunction $507fabe10e71c6fb$var$isValidKey(e) {\n  return !(e.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea10)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n  if ($507fabe10e71c6fb$var$isValidKey(e)) {\n    $507fabe10e71c6fb$var$currentModality = \"keyboard\";\n    $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e);\n  }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n  $507fabe10e71c6fb$var$currentModality = \"pointer\";\n  if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e);\n  }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n  if ((0, $6a7db85432448f7f$export$60278871457622de)(e)) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$currentModality = \"virtual\";\n  }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n  if (e.target === window || e.target === document)\n    return;\n  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n    $507fabe10e71c6fb$var$currentModality = \"virtual\";\n    $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e);\n  }\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\nfunction $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {\n  if (typeof window === \"undefined\" || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element)))\n    return;\n  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element);\n  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function() {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    focus.apply(this, arguments);\n  };\n  documentObject.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n  windowObject.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== \"undefined\") {\n    documentObject.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else {\n    documentObject.addEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n  windowObject.addEventListener(\"beforeunload\", () => {\n    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);\n  }, {\n    once: true\n  });\n  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {\n    focus\n  });\n}\nvar $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {\n  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(element);\n  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);\n  if (loadListener)\n    documentObject.removeEventListener(\"DOMContentLoaded\", loadListener);\n  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject))\n    return;\n  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;\n  documentObject.removeEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, true);\n  windowObject.removeEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.removeEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== \"undefined\") {\n    documentObject.removeEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else {\n    documentObject.removeEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);\n};\nfunction $507fabe10e71c6fb$export$2f1888112f558a7d(element) {\n  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac)(element);\n  let loadListener;\n  if (documentObject.readyState !== \"loading\")\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n  else {\n    loadListener = () => {\n      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n    };\n    documentObject.addEventListener(\"DOMContentLoaded\", loadListener);\n  }\n  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);\n}\nif (typeof document !== \"undefined\")\n  $507fabe10e71c6fb$export$2f1888112f558a7d();\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n  return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nvar $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([\n  \"checkbox\",\n  \"radio\",\n  \"range\",\n  \"color\",\n  \"file\",\n  \"image\",\n  \"button\",\n  \"submit\",\n  \"reset\"\n]);\nfunction $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n  var _e_target;\n  const IHTMLInputElement = typeof window !== \"undefined\" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== \"undefined\" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== \"undefined\" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== \"undefined\" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent;\n  isTextInput = isTextInput || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(e === null || e === void 0 ? void 0 : (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.type) || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLTextAreaElement || (e === null || e === void 0 ? void 0 : e.target) instanceof IHTMLElement && (e === null || e === void 0 ? void 0 : e.target.isContentEditable);\n  return !(isTextInput && modality === \"keyboard\" && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  (0, import_react5.useEffect)(() => {\n    let handler = (modality, e) => {\n      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e))\n        return;\n      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n    };\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n  }, deps);\n}\n\n// ../../node_modules/@react-aria/interactions/dist/useFocusWithin.mjs\nvar import_react6 = require(\"react\");\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;\n  let state = (0, import_react6.useRef)({\n    isFocusWithin: false\n  });\n  let onBlur = (0, import_react6.useCallback)((e) => {\n    if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n      state.current.isFocusWithin = false;\n      if (onBlurWithin)\n        onBlurWithin(e);\n      if (onFocusWithinChange)\n        onFocusWithinChange(false);\n    }\n  }, [\n    onBlurWithin,\n    onFocusWithinChange,\n    state\n  ]);\n  let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);\n  let onFocus = (0, import_react6.useCallback)((e) => {\n    if (!state.current.isFocusWithin && document.activeElement === e.target) {\n      if (onFocusWithin)\n        onFocusWithin(e);\n      if (onFocusWithinChange)\n        onFocusWithinChange(true);\n      state.current.isFocusWithin = true;\n      onSyntheticFocus(e);\n    }\n  }, [\n    onFocusWithin,\n    onFocusWithinChange,\n    onSyntheticFocus\n  ]);\n  if (isDisabled)\n    return {\n      focusWithinProps: {\n        // These should not have been null, that would conflict in mergeProps\n        onFocus: void 0,\n        onBlur: void 0\n      }\n    };\n  return {\n    focusWithinProps: {\n      onFocus,\n      onBlur\n    }\n  };\n}\n\n// ../../node_modules/@react-aria/interactions/dist/useHover.mjs\nvar import_react7 = require(\"react\");\nvar $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nvar $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n  setTimeout(() => {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n  if (e.pointerType === \"touch\")\n    $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n  if (typeof document === \"undefined\")\n    return;\n  if (typeof PointerEvent !== \"undefined\")\n    document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n  else\n    document.addEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n  $6179b936705e76d3$var$hoverCount++;\n  return () => {\n    $6179b936705e76d3$var$hoverCount--;\n    if ($6179b936705e76d3$var$hoverCount > 0)\n      return;\n    if (typeof PointerEvent !== \"undefined\")\n      document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else\n      document.removeEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n  };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;\n  let [isHovered, setHovered] = (0, import_react7.useState)(false);\n  let state = (0, import_react7.useRef)({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: \"\",\n    target: null\n  }).current;\n  (0, import_react7.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n  let { hoverProps, triggerHoverEnd } = (0, import_react7.useMemo)(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target))\n        return;\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target;\n      if (onHoverStart)\n        onHoverStart({\n          type: \"hoverstart\",\n          target,\n          pointerType\n        });\n      if (onHoverChange)\n        onHoverChange(true);\n      setHovered(true);\n    };\n    let triggerHoverEnd2 = (event, pointerType) => {\n      state.pointerType = \"\";\n      state.target = null;\n      if (pointerType === \"touch\" || !state.isHovered)\n        return;\n      state.isHovered = false;\n      let target = event.currentTarget;\n      if (onHoverEnd)\n        onHoverEnd({\n          type: \"hoverend\",\n          target,\n          pointerType\n        });\n      if (onHoverChange)\n        onHoverChange(false);\n      setHovered(false);\n    };\n    let hoverProps2 = {};\n    if (typeof PointerEvent !== \"undefined\") {\n      hoverProps2.onPointerEnter = (e) => {\n        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\")\n          return;\n        triggerHoverStart(e, e.pointerType);\n      };\n      hoverProps2.onPointerLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target))\n          triggerHoverEnd2(e, e.pointerType);\n      };\n    } else {\n      hoverProps2.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n      hoverProps2.onMouseEnter = (e) => {\n        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents)\n          triggerHoverStart(e, \"mouse\");\n        state.ignoreEmulatedMouseEvents = false;\n      };\n      hoverProps2.onMouseLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target))\n          triggerHoverEnd2(e, \"mouse\");\n      };\n    }\n    return {\n      hoverProps: hoverProps2,\n      triggerHoverEnd: triggerHoverEnd2\n    };\n  }, [\n    onHoverStart,\n    onHoverChange,\n    onHoverEnd,\n    isDisabled,\n    state\n  ]);\n  (0, import_react7.useEffect)(() => {\n    if (isDisabled)\n      triggerHoverEnd({\n        currentTarget: state.target\n      }, state.pointerType);\n  }, [\n    isDisabled\n  ]);\n  return {\n    hoverProps,\n    isHovered\n  };\n}\n\n// ../../node_modules/@react-aria/focus/dist/useFocusRing.mjs\nvar import_react8 = require(\"react\");\nfunction $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {\n  let { autoFocus = false, isTextInput, within } = props;\n  let state = (0, import_react8.useRef)({\n    isFocused: false,\n    isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()\n  });\n  let [isFocused, setFocused] = (0, import_react8.useState)(false);\n  let [isFocusVisibleState, setFocusVisible] = (0, import_react8.useState)(() => state.current.isFocused && state.current.isFocusVisible);\n  let updateState = (0, import_react8.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);\n  let onFocusChange = (0, import_react8.useCallback)((isFocused2) => {\n    state.current.isFocused = isFocused2;\n    setFocused(isFocused2);\n    updateState();\n  }, [\n    updateState\n  ]);\n  (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible) => {\n    state.current.isFocusVisible = isFocusVisible;\n    updateState();\n  }, [], {\n    isTextInput\n  });\n  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({\n    isDisabled: within,\n    onFocusChange\n  });\n  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({\n    isDisabled: !within,\n    onFocusWithinChange: onFocusChange\n  });\n  return {\n    isFocused,\n    isFocusVisible: isFocusVisibleState,\n    focusProps: within ? focusWithinProps : focusProps\n  };\n}\n\n// src/components/button/button.tsx\nvar import_react16 = require(\"react\");\n\n// src/hooks/use-active-press.tsx\nvar import_react13 = require(\"react\");\n\n// src/utils/env.ts\nvar Env = class {\n  constructor() {\n    __publicField(this, \"current\", this.detect());\n    __publicField(this, \"handoffState\", \"pending\");\n    __publicField(this, \"currentId\", 0);\n  }\n  set(env2) {\n    if (this.current === env2)\n      return;\n    this.handoffState = \"pending\";\n    this.currentId = 0;\n    this.current = env2;\n  }\n  reset() {\n    this.set(this.detect());\n  }\n  nextId() {\n    return ++this.currentId;\n  }\n  get isServer() {\n    return this.current === \"server\";\n  }\n  get isClient() {\n    return this.current === \"client\";\n  }\n  detect() {\n    if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n      return \"server\";\n    }\n    return \"client\";\n  }\n  handoff() {\n    if (this.handoffState === \"pending\") {\n      this.handoffState = \"complete\";\n    }\n  }\n  get isHandoffComplete() {\n    return this.handoffState === \"complete\";\n  }\n};\nvar env = new Env();\n\n// src/utils/owner.ts\nfunction getOwnerDocument(element) {\n  var _a3, _b2;\n  if (env.isServer)\n    return null;\n  if (!element)\n    return document;\n  if (\"ownerDocument\" in element)\n    return element.ownerDocument;\n  if (\"current\" in element)\n    return (_b2 = (_a3 = element.current) == null ? void 0 : _a3.ownerDocument) != null ? _b2 : document;\n  return null;\n}\n\n// src/hooks/use-disposables.ts\nvar import_react9 = require(\"react\");\n\n// src/utils/micro-task.ts\nfunction microTask(cb) {\n  if (typeof queueMicrotask === \"function\") {\n    queueMicrotask(cb);\n  } else {\n    Promise.resolve().then(cb).catch(\n      (e) => setTimeout(() => {\n        throw e;\n      })\n    );\n  }\n}\n\n// src/utils/disposables.ts\nfunction disposables() {\n  let _disposables = [];\n  let api = {\n    addEventListener(element, name, listener, options) {\n      element.addEventListener(name, listener, options);\n      return api.add(() => element.removeEventListener(name, listener, options));\n    },\n    requestAnimationFrame(...args) {\n      let raf = requestAnimationFrame(...args);\n      return api.add(() => cancelAnimationFrame(raf));\n    },\n    nextFrame(...args) {\n      return api.requestAnimationFrame(() => {\n        return api.requestAnimationFrame(...args);\n      });\n    },\n    setTimeout(...args) {\n      let timer = setTimeout(...args);\n      return api.add(() => clearTimeout(timer));\n    },\n    microTask(...args) {\n      let task = { current: true };\n      microTask(() => {\n        if (task.current) {\n          args[0]();\n        }\n      });\n      return api.add(() => {\n        task.current = false;\n      });\n    },\n    style(node, property, value) {\n      let previous = node.style.getPropertyValue(property);\n      Object.assign(node.style, { [property]: value });\n      return this.add(() => {\n        Object.assign(node.style, { [property]: previous });\n      });\n    },\n    group(cb) {\n      let d = disposables();\n      cb(d);\n      return this.add(() => d.dispose());\n    },\n    add(cb) {\n      if (!_disposables.includes(cb)) {\n        _disposables.push(cb);\n      }\n      return () => {\n        let idx = _disposables.indexOf(cb);\n        if (idx >= 0) {\n          for (let dispose of _disposables.splice(idx, 1)) {\n            dispose();\n          }\n        }\n      };\n    },\n    dispose() {\n      for (let dispose of _disposables.splice(0)) {\n        dispose();\n      }\n    }\n  };\n  return api;\n}\n\n// src/hooks/use-disposables.ts\nfunction useDisposables() {\n  let [d] = (0, import_react9.useState)(disposables);\n  (0, import_react9.useEffect)(() => () => d.dispose(), [d]);\n  return d;\n}\n\n// src/hooks/use-event.ts\nvar import_react12 = __toESM(require(\"react\"), 1);\n\n// src/hooks/use-latest-value.ts\nvar import_react11 = require(\"react\");\n\n// src/hooks/use-iso-morphic-effect.ts\nvar import_react10 = require(\"react\");\nvar useIsoMorphicEffect = (effect, deps) => {\n  if (env.isServer) {\n    (0, import_react10.useEffect)(effect, deps);\n  } else {\n    (0, import_react10.useLayoutEffect)(effect, deps);\n  }\n};\n\n// src/hooks/use-latest-value.ts\nfunction useLatestValue(value) {\n  let cache = (0, import_react11.useRef)(value);\n  useIsoMorphicEffect(() => {\n    cache.current = value;\n  }, [value]);\n  return cache;\n}\n\n// src/hooks/use-event.ts\nvar useEvent = (\n  // TODO: Add React.useEvent ?? once the useEvent hook is available\n  function useEvent2(cb) {\n    let cache = useLatestValue(cb);\n    return import_react12.default.useCallback((...args) => cache.current(...args), [cache]);\n  }\n);\n\n// src/hooks/use-active-press.tsx\nfunction pointerRectFromPointerEvent(event) {\n  let offsetX = event.width / 2;\n  let offsetY = event.height / 2;\n  return {\n    top: event.clientY - offsetY,\n    right: event.clientX + offsetX,\n    bottom: event.clientY + offsetY,\n    left: event.clientX - offsetX\n  };\n}\nfunction areRectsOverlapping(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n  if (a.right < b.left || a.left > b.right) {\n    return false;\n  }\n  if (a.bottom < b.top || a.top > b.bottom) {\n    return false;\n  }\n  return true;\n}\nfunction useActivePress({ disabled = false } = {}) {\n  let target = (0, import_react13.useRef)(null);\n  let [pressed, setPressed] = (0, import_react13.useState)(false);\n  let d = useDisposables();\n  let reset = useEvent(() => {\n    target.current = null;\n    setPressed(false);\n    d.dispose();\n  });\n  let handlePointerDown = useEvent((event) => {\n    d.dispose();\n    if (target.current !== null)\n      return;\n    target.current = event.currentTarget;\n    setPressed(true);\n    {\n      let owner = getOwnerDocument(event.currentTarget);\n      d.addEventListener(owner, \"pointerup\", reset, false);\n      d.addEventListener(\n        owner,\n        \"pointermove\",\n        (event2) => {\n          if (target.current) {\n            let pointerRect = pointerRectFromPointerEvent(event2);\n            setPressed(areRectsOverlapping(pointerRect, target.current.getBoundingClientRect()));\n          }\n        },\n        false\n      );\n      d.addEventListener(owner, \"pointercancel\", reset, false);\n    }\n  });\n  return {\n    pressed,\n    pressProps: disabled ? {} : {\n      onPointerDown: handlePointerDown,\n      onPointerUp: reset,\n      onClick: reset\n    }\n  };\n}\n\n// src/internal/disabled.tsx\nvar import_react14 = __toESM(require(\"react\"), 1);\nvar DisabledContext = (0, import_react14.createContext)(void 0);\nfunction useDisabled() {\n  return (0, import_react14.useContext)(DisabledContext);\n}\nfunction DisabledProvider({\n  value,\n  children\n}) {\n  return /* @__PURE__ */ import_react14.default.createElement(DisabledContext.Provider, { value }, children);\n}\n\n// src/utils/render.ts\nvar import_react15 = __toESM(require(\"react\"), 1);\n\n// src/utils/class-names.ts\nfunction classNames(...classes) {\n  return Array.from(\n    new Set(\n      classes.flatMap((value) => {\n        if (typeof value === \"string\") {\n          return value.split(\" \");\n        }\n        return [];\n      })\n    )\n  ).filter(Boolean).join(\" \");\n}\n\n// src/utils/match.ts\nfunction match(value, lookup, ...args) {\n  if (value in lookup) {\n    let returnValue = lookup[value];\n    return typeof returnValue === \"function\" ? returnValue(...args) : returnValue;\n  }\n  let error2 = new Error(\n    `Tried to handle \"${value}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      lookup\n    ).map((key) => `\"${key}\"`).join(\", \")}.`\n  );\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(error2, match);\n  throw error2;\n}\n\n// src/utils/render.ts\nfunction useRender() {\n  let mergeRefs = useMergeRefsFn();\n  return (0, import_react15.useCallback)(\n    (args) => render({ mergeRefs, ...args }),\n    [mergeRefs]\n  );\n}\nfunction render({\n  ourProps,\n  theirProps,\n  slot,\n  defaultTag,\n  features,\n  visible = true,\n  name,\n  mergeRefs\n}) {\n  mergeRefs = mergeRefs != null ? mergeRefs : defaultMergeRefs;\n  let props = mergePropsAdvanced(theirProps, ourProps);\n  if (visible)\n    return _render(props, slot, defaultTag, name, mergeRefs);\n  let featureFlags = features != null ? features : 0 /* None */;\n  if (featureFlags & 2 /* Static */) {\n    let { static: isStatic = false, ...rest } = props;\n    if (isStatic)\n      return _render(rest, slot, defaultTag, name, mergeRefs);\n  }\n  if (featureFlags & 1 /* RenderStrategy */) {\n    let { unmount = true, ...rest } = props;\n    let strategy = unmount ? 0 /* Unmount */ : 1 /* Hidden */;\n    return match(strategy, {\n      [0 /* Unmount */]() {\n        return null;\n      },\n      [1 /* Hidden */]() {\n        return _render(\n          { ...rest, ...{ hidden: true, style: { display: \"none\" } } },\n          slot,\n          defaultTag,\n          name,\n          mergeRefs\n        );\n      }\n    });\n  }\n  return _render(props, slot, defaultTag, name, mergeRefs);\n}\nfunction _render(props, slot = {}, tag, name, mergeRefs) {\n  let {\n    as: Component = tag,\n    children,\n    refName = \"ref\",\n    ...rest\n  } = omit(props, [\"unmount\", \"static\"]);\n  let refRelatedProps = props.ref !== void 0 ? { [refName]: props.ref } : {};\n  let resolvedChildren = typeof children === \"function\" ? children(slot) : children;\n  if (\"className\" in rest && rest.className && typeof rest.className === \"function\") {\n    rest.className = rest.className(slot);\n  }\n  if (rest[\"aria-labelledby\"] && rest[\"aria-labelledby\"] === rest.id) {\n    rest[\"aria-labelledby\"] = void 0;\n  }\n  let dataAttributes = {};\n  if (slot) {\n    let exposeState = false;\n    let states = [];\n    for (let [k, v] of Object.entries(slot)) {\n      if (typeof v === \"boolean\") {\n        exposeState = true;\n      }\n      if (v === true) {\n        states.push(k.replace(/([A-Z])/g, (m) => `-${m.toLowerCase()}`));\n      }\n    }\n    if (exposeState) {\n      dataAttributes[\"data-headlessui-state\"] = states.join(\" \");\n      for (let state of states) {\n        dataAttributes[`data-${state}`] = \"\";\n      }\n    }\n  }\n  if (Component === import_react15.Fragment) {\n    if (Object.keys(compact(rest)).length > 0 || Object.keys(compact(dataAttributes)).length > 0) {\n      if (!(0, import_react15.isValidElement)(resolvedChildren) || Array.isArray(resolvedChildren) && resolvedChildren.length > 1) {\n        if (Object.keys(compact(rest)).length > 0) {\n          throw new Error(\n            [\n              'Passing props on \"Fragment\"!',\n              \"\",\n              `The current component <${name} /> is rendering a \"Fragment\".`,\n              `However we need to passthrough the following props:`,\n              Object.keys(compact(rest)).concat(Object.keys(compact(dataAttributes))).map((line) => `  - ${line}`).join(\"\\n\"),\n              \"\",\n              \"You can apply a few solutions:\",\n              [\n                'Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"Fragment\".',\n                \"Render a single element as the child so that we can forward the props onto that element.\"\n              ].map((line) => `  - ${line}`).join(\"\\n\")\n            ].join(\"\\n\")\n          );\n        }\n      } else {\n        let childProps = resolvedChildren.props;\n        let childPropsClassName = childProps == null ? void 0 : childProps.className;\n        let newClassName = typeof childPropsClassName === \"function\" ? (...args) => classNames(\n          childPropsClassName(...args),\n          rest.className\n        ) : classNames(childPropsClassName, rest.className);\n        let classNameProps = newClassName ? { className: newClassName } : {};\n        let mergedProps = mergePropsAdvanced(\n          resolvedChildren.props,\n          // Filter out undefined values so that they don't override the existing values\n          compact(omit(rest, [\"ref\"]))\n        );\n        for (let key in dataAttributes) {\n          if (key in mergedProps) {\n            delete dataAttributes[key];\n          }\n        }\n        return (0, import_react15.cloneElement)(\n          resolvedChildren,\n          Object.assign(\n            {},\n            mergedProps,\n            dataAttributes,\n            refRelatedProps,\n            { ref: mergeRefs(getElementRef(resolvedChildren), refRelatedProps.ref) },\n            classNameProps\n          )\n        );\n      }\n    }\n  }\n  return (0, import_react15.createElement)(\n    Component,\n    Object.assign(\n      {},\n      omit(rest, [\"ref\"]),\n      Component !== import_react15.Fragment && refRelatedProps,\n      Component !== import_react15.Fragment && dataAttributes\n    ),\n    resolvedChildren\n  );\n}\nfunction useMergeRefsFn() {\n  let currentRefs = (0, import_react15.useRef)([]);\n  let mergedRef = (0, import_react15.useCallback)((value) => {\n    for (let ref of currentRefs.current) {\n      if (ref == null)\n        continue;\n      if (typeof ref === \"function\")\n        ref(value);\n      else\n        ref.current = value;\n    }\n  }, []);\n  return (...refs) => {\n    if (refs.every((ref) => ref == null)) {\n      return void 0;\n    }\n    currentRefs.current = refs;\n    return mergedRef;\n  };\n}\nfunction defaultMergeRefs(...refs) {\n  return refs.every((ref) => ref == null) ? void 0 : (value) => {\n    for (let ref of refs) {\n      if (ref == null)\n        continue;\n      if (typeof ref === \"function\")\n        ref(value);\n      else\n        ref.current = value;\n    }\n  };\n}\nfunction mergePropsAdvanced(...listOfProps) {\n  var _a3;\n  if (listOfProps.length === 0)\n    return {};\n  if (listOfProps.length === 1)\n    return listOfProps[0];\n  let target = {};\n  let eventHandlers = {};\n  for (let props of listOfProps) {\n    for (let prop in props) {\n      if (prop.startsWith(\"on\") && typeof props[prop] === \"function\") {\n        (_a3 = eventHandlers[prop]) != null ? _a3 : eventHandlers[prop] = [];\n        eventHandlers[prop].push(props[prop]);\n      } else {\n        target[prop] = props[prop];\n      }\n    }\n  }\n  if (target.disabled || target[\"aria-disabled\"]) {\n    for (let eventName in eventHandlers) {\n      if (/^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(eventName)) {\n        eventHandlers[eventName] = [(e) => {\n          var _a4;\n          return (_a4 = e == null ? void 0 : e.preventDefault) == null ? void 0 : _a4.call(e);\n        }];\n      }\n    }\n  }\n  for (let eventName in eventHandlers) {\n    Object.assign(target, {\n      [eventName](event, ...args) {\n        let handlers = eventHandlers[eventName];\n        for (let handler of handlers) {\n          if ((event instanceof Event || (event == null ? void 0 : event.nativeEvent) instanceof Event) && event.defaultPrevented) {\n            return;\n          }\n          handler(event, ...args);\n        }\n      }\n    });\n  }\n  return target;\n}\nfunction mergeProps(...listOfProps) {\n  var _a3;\n  if (listOfProps.length === 0)\n    return {};\n  if (listOfProps.length === 1)\n    return listOfProps[0];\n  let target = {};\n  let eventHandlers = {};\n  for (let props of listOfProps) {\n    for (let prop in props) {\n      if (prop.startsWith(\"on\") && typeof props[prop] === \"function\") {\n        (_a3 = eventHandlers[prop]) != null ? _a3 : eventHandlers[prop] = [];\n        eventHandlers[prop].push(props[prop]);\n      } else {\n        target[prop] = props[prop];\n      }\n    }\n  }\n  for (let eventName in eventHandlers) {\n    Object.assign(target, {\n      [eventName](...args) {\n        let handlers = eventHandlers[eventName];\n        for (let handler of handlers) {\n          handler == null ? void 0 : handler(...args);\n        }\n      }\n    });\n  }\n  return target;\n}\nfunction forwardRefWithAs(component) {\n  var _a3;\n  return Object.assign((0, import_react15.forwardRef)(component), {\n    displayName: (_a3 = component.displayName) != null ? _a3 : component.name\n  });\n}\nfunction compact(object) {\n  let clone = Object.assign({}, object);\n  for (let key in clone) {\n    if (clone[key] === void 0)\n      delete clone[key];\n  }\n  return clone;\n}\nfunction omit(object, keysToOmit = []) {\n  let clone = Object.assign({}, object);\n  for (let key of keysToOmit) {\n    if (key in clone)\n      delete clone[key];\n  }\n  return clone;\n}\nfunction getElementRef(element) {\n  return import_react15.default.version.split(\".\")[0] >= \"19\" ? element.props.ref : element.ref;\n}\n\n// src/components/button/button.tsx\nvar DEFAULT_BUTTON_TAG = \"button\";\nfunction ButtonFn(props, ref) {\n  var _a3;\n  let providedDisabled = useDisabled();\n  let { disabled = providedDisabled || false, autoFocus = false, ...theirProps } = props;\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let ourProps = mergeProps(\n    {\n      ref,\n      type: (_a3 = theirProps.type) != null ? _a3 : \"button\",\n      disabled: disabled || void 0,\n      autoFocus\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let slot = (0, import_react16.useMemo)(() => {\n    return { disabled, hover, focus, active, autofocus: autoFocus };\n  }, [disabled, hover, focus, active, autoFocus]);\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG,\n    name: \"Button\"\n  });\n}\nvar Button = forwardRefWithAs(ButtonFn);\n\n// src/components/checkbox/checkbox.tsx\nvar import_react25 = __toESM(require(\"react\"), 1);\n\n// src/hooks/use-controllable.ts\nvar import_react17 = require(\"react\");\nfunction useControllable(controlledValue, onChange, defaultValue) {\n  let [internalValue, setInternalValue] = (0, import_react17.useState)(defaultValue);\n  let isControlled = controlledValue !== void 0;\n  let wasControlled = (0, import_react17.useRef)(isControlled);\n  let didWarnOnUncontrolledToControlled = (0, import_react17.useRef)(false);\n  let didWarnOnControlledToUncontrolled = (0, import_react17.useRef)(false);\n  if (isControlled && !wasControlled.current && !didWarnOnUncontrolledToControlled.current) {\n    didWarnOnUncontrolledToControlled.current = true;\n    wasControlled.current = isControlled;\n    console.error(\n      \"A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.\"\n    );\n  } else if (!isControlled && wasControlled.current && !didWarnOnControlledToUncontrolled.current) {\n    didWarnOnControlledToUncontrolled.current = true;\n    wasControlled.current = isControlled;\n    console.error(\n      \"A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.\"\n    );\n  }\n  return [\n    isControlled ? controlledValue : internalValue,\n    useEvent((value) => {\n      if (isControlled) {\n        return onChange == null ? void 0 : onChange(value);\n      } else {\n        setInternalValue(value);\n        return onChange == null ? void 0 : onChange(value);\n      }\n    })\n  ];\n}\n\n// src/hooks/use-default-value.ts\nvar import_react18 = require(\"react\");\nfunction useDefaultValue(value) {\n  let [defaultValue] = (0, import_react18.useState)(value);\n  return defaultValue;\n}\n\n// src/hooks/use-id.ts\nvar import_react19 = require(\"react\");\n\n// src/internal/form-fields.tsx\nvar import_react20 = __toESM(require(\"react\"), 1);\nvar import_react_dom = require(\"react-dom\");\n\n// src/utils/form.ts\nfunction objectToFormEntries(source = {}, parentKey = null, entries = []) {\n  for (let [key, value] of Object.entries(source)) {\n    append(entries, composeKey(parentKey, key), value);\n  }\n  return entries;\n}\nfunction composeKey(parent, key) {\n  return parent ? parent + \"[\" + key + \"]\" : key;\n}\nfunction append(entries, key, value) {\n  if (Array.isArray(value)) {\n    for (let [subkey, subvalue] of value.entries()) {\n      append(entries, composeKey(key, subkey.toString()), subvalue);\n    }\n  } else if (value instanceof Date) {\n    entries.push([key, value.toISOString()]);\n  } else if (typeof value === \"boolean\") {\n    entries.push([key, value ? \"1\" : \"0\"]);\n  } else if (typeof value === \"string\") {\n    entries.push([key, value]);\n  } else if (typeof value === \"number\") {\n    entries.push([key, `${value}`]);\n  } else if (value === null || value === void 0) {\n    entries.push([key, \"\"]);\n  } else {\n    objectToFormEntries(value, key, entries);\n  }\n}\nfunction attemptSubmit(elementInForm) {\n  var _a3, _b2;\n  let form = (_a3 = elementInForm == null ? void 0 : elementInForm.form) != null ? _a3 : elementInForm.closest(\"form\");\n  if (!form)\n    return;\n  for (let element of form.elements) {\n    if (element === elementInForm)\n      continue;\n    if (element.tagName === \"INPUT\" && element.type === \"submit\" || element.tagName === \"BUTTON\" && element.type === \"submit\" || element.nodeName === \"INPUT\" && element.type === \"image\") {\n      element.click();\n      return;\n    }\n  }\n  (_b2 = form.requestSubmit) == null ? void 0 : _b2.call(form);\n}\n\n// src/internal/hidden.tsx\nvar DEFAULT_VISUALLY_HIDDEN_TAG = \"span\";\nfunction VisuallyHidden(props, ref) {\n  var _a3;\n  let { features = 1 /* None */, ...theirProps } = props;\n  let ourProps = {\n    ref,\n    \"aria-hidden\": (features & 2 /* Focusable */) === 2 /* Focusable */ ? true : (_a3 = theirProps[\"aria-hidden\"]) != null ? _a3 : void 0,\n    hidden: (features & 4 /* Hidden */) === 4 /* Hidden */ ? true : void 0,\n    style: {\n      position: \"fixed\",\n      top: 1,\n      left: 1,\n      width: 1,\n      height: 0,\n      padding: 0,\n      margin: -1,\n      overflow: \"hidden\",\n      clip: \"rect(0, 0, 0, 0)\",\n      whiteSpace: \"nowrap\",\n      borderWidth: \"0\",\n      ...(features & 4 /* Hidden */) === 4 /* Hidden */ && !((features & 2 /* Focusable */) === 2 /* Focusable */) && {\n        display: \"none\"\n      }\n    }\n  };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_VISUALLY_HIDDEN_TAG,\n    name: \"Hidden\"\n  });\n}\nvar Hidden = forwardRefWithAs(VisuallyHidden);\n\n// src/internal/form-fields.tsx\nvar FormFieldsContext = (0, import_react20.createContext)(null);\nfunction FormFieldsProvider(props) {\n  let [target, setTarget] = (0, import_react20.useState)(null);\n  return /* @__PURE__ */ import_react20.default.createElement(FormFieldsContext.Provider, { value: { target } }, props.children, /* @__PURE__ */ import_react20.default.createElement(Hidden, { features: 4 /* Hidden */, ref: setTarget }));\n}\nfunction HoistFormFields({ children }) {\n  let formFieldsContext = (0, import_react20.useContext)(FormFieldsContext);\n  if (!formFieldsContext)\n    return /* @__PURE__ */ import_react20.default.createElement(import_react20.default.Fragment, null, children);\n  let { target } = formFieldsContext;\n  return target ? (0, import_react_dom.createPortal)(/* @__PURE__ */ import_react20.default.createElement(import_react20.default.Fragment, null, children), target) : null;\n}\nfunction FormFields({\n  data,\n  form: formId,\n  disabled,\n  onReset,\n  overrides\n}) {\n  let [form, setForm] = (0, import_react20.useState)(null);\n  let d = useDisposables();\n  (0, import_react20.useEffect)(() => {\n    if (!onReset)\n      return;\n    if (!form)\n      return;\n    return d.addEventListener(form, \"reset\", onReset);\n  }, [form, formId, onReset]);\n  return /* @__PURE__ */ import_react20.default.createElement(HoistFormFields, null, /* @__PURE__ */ import_react20.default.createElement(FormResolver, { setForm, formId }), objectToFormEntries(data).map(([name, value]) => {\n    return /* @__PURE__ */ import_react20.default.createElement(\n      Hidden,\n      {\n        features: 4 /* Hidden */,\n        ...compact({\n          key: name,\n          as: \"input\",\n          type: \"hidden\",\n          hidden: true,\n          readOnly: true,\n          form: formId,\n          disabled,\n          name,\n          value,\n          ...overrides\n        })\n      }\n    );\n  }));\n}\nfunction FormResolver({\n  setForm,\n  formId\n}) {\n  (0, import_react20.useEffect)(() => {\n    if (formId) {\n      let resolvedForm = document.getElementById(formId);\n      if (resolvedForm)\n        setForm(resolvedForm);\n    }\n  }, [setForm, formId]);\n  return formId ? null : /* @__PURE__ */ import_react20.default.createElement(\n    Hidden,\n    {\n      features: 4 /* Hidden */,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: true,\n      readOnly: true,\n      ref: (el) => {\n        if (!el)\n          return;\n        let resolvedForm = el.closest(\"form\");\n        if (resolvedForm)\n          setForm(resolvedForm);\n      }\n    }\n  );\n}\n\n// src/internal/id.tsx\nvar import_react21 = __toESM(require(\"react\"), 1);\nvar IdContext = (0, import_react21.createContext)(void 0);\nfunction useProvidedId() {\n  return (0, import_react21.useContext)(IdContext);\n}\nfunction IdProvider({ id, children }) {\n  return /* @__PURE__ */ import_react21.default.createElement(IdContext.Provider, { value: id }, children);\n}\n\n// src/utils/bugs.ts\nfunction isDisabledReactIssue7711(element) {\n  let parent = element.parentElement;\n  let legend = null;\n  while (parent && !(parent instanceof HTMLFieldSetElement)) {\n    if (parent instanceof HTMLLegendElement)\n      legend = parent;\n    parent = parent.parentElement;\n  }\n  let isParentDisabled = (parent == null ? void 0 : parent.getAttribute(\"disabled\")) === \"\";\n  if (isParentDisabled && isFirstLegend(legend))\n    return false;\n  return isParentDisabled;\n}\nfunction isFirstLegend(element) {\n  if (!element)\n    return false;\n  let previous = element.previousElementSibling;\n  while (previous !== null) {\n    if (previous instanceof HTMLLegendElement)\n      return false;\n    previous = previous.previousElementSibling;\n  }\n  return true;\n}\n\n// src/components/description/description.tsx\nvar import_react23 = __toESM(require(\"react\"), 1);\n\n// src/hooks/use-sync-refs.ts\nvar import_react22 = require(\"react\");\nvar Optional = Symbol();\nfunction optionalRef(cb, isOptional = true) {\n  return Object.assign(cb, { [Optional]: isOptional });\n}\nfunction useSyncRefs(...refs) {\n  let cache = (0, import_react22.useRef)(refs);\n  (0, import_react22.useEffect)(() => {\n    cache.current = refs;\n  }, [refs]);\n  let syncRefs = useEvent((value) => {\n    for (let ref of cache.current) {\n      if (ref == null)\n        continue;\n      if (typeof ref === \"function\")\n        ref(value);\n      else\n        ref.current = value;\n    }\n  });\n  return refs.every(\n    (ref) => ref == null || // @ts-expect-error\n    (ref == null ? void 0 : ref[Optional])\n  ) ? void 0 : syncRefs;\n}\n\n// src/components/description/description.tsx\nvar DescriptionContext = (0, import_react23.createContext)(null);\nDescriptionContext.displayName = \"DescriptionContext\";\nfunction useDescriptionContext() {\n  let context = (0, import_react23.useContext)(DescriptionContext);\n  if (context === null) {\n    let err = new Error(\n      \"You used a <Description /> component, but it is not inside a relevant parent.\"\n    );\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDescriptionContext);\n    throw err;\n  }\n  return context;\n}\nfunction useDescribedBy() {\n  var _a3, _b2;\n  return (_b2 = (_a3 = (0, import_react23.useContext)(DescriptionContext)) == null ? void 0 : _a3.value) != null ? _b2 : void 0;\n}\nfunction useDescriptions() {\n  let [descriptionIds, setDescriptionIds] = (0, import_react23.useState)([]);\n  return [\n    // The actual id's as string or undefined\n    descriptionIds.length > 0 ? descriptionIds.join(\" \") : void 0,\n    // The provider component\n    (0, import_react23.useMemo)(() => {\n      return function DescriptionProvider(props) {\n        let register = useEvent((value) => {\n          setDescriptionIds((existing) => [...existing, value]);\n          return () => {\n            return setDescriptionIds((existing) => {\n              let clone = existing.slice();\n              let idx = clone.indexOf(value);\n              if (idx !== -1)\n                clone.splice(idx, 1);\n              return clone;\n            });\n          };\n        });\n        let contextBag = (0, import_react23.useMemo)(\n          () => ({\n            register,\n            slot: props.slot,\n            name: props.name,\n            props: props.props,\n            value: props.value\n          }),\n          [register, props.slot, props.name, props.props, props.value]\n        );\n        return /* @__PURE__ */ import_react23.default.createElement(DescriptionContext.Provider, { value: contextBag }, props.children);\n      };\n    }, [setDescriptionIds])\n  ];\n}\nvar DEFAULT_DESCRIPTION_TAG = \"p\";\nfunction DescriptionFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedDisabled = useDisabled();\n  let { id = `headlessui-description-${internalId}`, ...theirProps } = props;\n  let context = useDescriptionContext();\n  let descriptionRef = useSyncRefs(ref);\n  useIsoMorphicEffect(() => context.register(id), [id, context.register]);\n  let disabled = providedDisabled || false;\n  let slot = (0, import_react23.useMemo)(() => ({ ...context.slot, disabled }), [context.slot, disabled]);\n  let ourProps = { ref: descriptionRef, ...context.props, id };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_DESCRIPTION_TAG,\n    name: context.name || \"Description\"\n  });\n}\nvar DescriptionRoot = forwardRefWithAs(DescriptionFn);\nvar Description = Object.assign(DescriptionRoot, {\n  //\n});\n\n// src/components/label/label.tsx\nvar import_react24 = __toESM(require(\"react\"), 1);\nvar LabelContext = (0, import_react24.createContext)(null);\nLabelContext.displayName = \"LabelContext\";\nfunction useLabelContext() {\n  let context = (0, import_react24.useContext)(LabelContext);\n  if (context === null) {\n    let err = new Error(\"You used a <Label /> component, but it is not inside a relevant parent.\");\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useLabelContext);\n    throw err;\n  }\n  return context;\n}\nfunction useLabelledBy(alwaysAvailableIds) {\n  var _a3, _b2, _c;\n  let labelIds = (_b2 = (_a3 = (0, import_react24.useContext)(LabelContext)) == null ? void 0 : _a3.value) != null ? _b2 : void 0;\n  if (((_c = alwaysAvailableIds == null ? void 0 : alwaysAvailableIds.length) != null ? _c : 0) > 0) {\n    return [labelIds, ...alwaysAvailableIds].filter(Boolean).join(\" \");\n  }\n  return labelIds;\n}\nfunction useLabels({ inherit = false } = {}) {\n  let parentLabelledBy = useLabelledBy();\n  let [labelIds, setLabelIds] = (0, import_react24.useState)([]);\n  let allLabelIds = inherit ? [parentLabelledBy, ...labelIds].filter(Boolean) : labelIds;\n  return [\n    // The actual id's as string or undefined.\n    allLabelIds.length > 0 ? allLabelIds.join(\" \") : void 0,\n    // The provider component\n    (0, import_react24.useMemo)(() => {\n      return function LabelProvider(props) {\n        let register = useEvent((value) => {\n          setLabelIds((existing) => [...existing, value]);\n          return () => {\n            return setLabelIds((existing) => {\n              let clone = existing.slice();\n              let idx = clone.indexOf(value);\n              if (idx !== -1)\n                clone.splice(idx, 1);\n              return clone;\n            });\n          };\n        });\n        let contextBag = (0, import_react24.useMemo)(\n          () => ({\n            register,\n            slot: props.slot,\n            name: props.name,\n            props: props.props,\n            value: props.value\n          }),\n          [register, props.slot, props.name, props.props, props.value]\n        );\n        return /* @__PURE__ */ import_react24.default.createElement(LabelContext.Provider, { value: contextBag }, props.children);\n      };\n    }, [setLabelIds])\n  ];\n}\nvar DEFAULT_LABEL_TAG = \"label\";\nfunction LabelFn(props, ref) {\n  var _a3;\n  let internalId = (0, import_react19.useId)();\n  let context = useLabelContext();\n  let providedHtmlFor = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = `headlessui-label-${internalId}`,\n    htmlFor = providedHtmlFor != null ? providedHtmlFor : (_a3 = context.props) == null ? void 0 : _a3.htmlFor,\n    passive = false,\n    ...theirProps\n  } = props;\n  let labelRef = useSyncRefs(ref);\n  useIsoMorphicEffect(() => context.register(id), [id, context.register]);\n  let handleClick = useEvent((e) => {\n    let current = e.currentTarget;\n    if (current instanceof HTMLLabelElement) {\n      e.preventDefault();\n    }\n    if (context.props && \"onClick\" in context.props && typeof context.props.onClick === \"function\") {\n      context.props.onClick(e);\n    }\n    if (current instanceof HTMLLabelElement) {\n      let target = document.getElementById(current.htmlFor);\n      if (target) {\n        let actuallyDisabled = target.getAttribute(\"disabled\");\n        if (actuallyDisabled === \"true\" || actuallyDisabled === \"\") {\n          return;\n        }\n        let ariaDisabled = target.getAttribute(\"aria-disabled\");\n        if (ariaDisabled === \"true\" || ariaDisabled === \"\") {\n          return;\n        }\n        if (target instanceof HTMLInputElement && (target.type === \"radio\" || target.type === \"checkbox\") || target.role === \"radio\" || target.role === \"checkbox\" || target.role === \"switch\") {\n          target.click();\n        }\n        target.focus({ preventScroll: true });\n      }\n    }\n  });\n  let disabled = providedDisabled || false;\n  let slot = (0, import_react24.useMemo)(() => ({ ...context.slot, disabled }), [context.slot, disabled]);\n  let ourProps = {\n    ref: labelRef,\n    ...context.props,\n    id,\n    htmlFor,\n    onClick: handleClick\n  };\n  if (passive) {\n    if (\"onClick\" in ourProps) {\n      delete ourProps[\"htmlFor\"];\n      delete ourProps[\"onClick\"];\n    }\n    if (\"onClick\" in theirProps) {\n      delete theirProps[\"onClick\"];\n    }\n  }\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: htmlFor ? DEFAULT_LABEL_TAG : \"div\",\n    name: context.name || \"Label\"\n  });\n}\nvar LabelRoot = forwardRefWithAs(LabelFn);\nvar Label = Object.assign(LabelRoot, {\n  //\n});\n\n// src/components/checkbox/checkbox.tsx\nvar DEFAULT_CHECKBOX_TAG = \"span\";\nfunction CheckboxFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = providedId || `headlessui-checkbox-${internalId}`,\n    disabled = providedDisabled || false,\n    autoFocus = false,\n    checked: controlledChecked,\n    defaultChecked: _defaultChecked,\n    onChange: controlledOnChange,\n    name,\n    value,\n    form,\n    indeterminate = false,\n    tabIndex = 0,\n    ...theirProps\n  } = props;\n  let defaultChecked = useDefaultValue(_defaultChecked);\n  let [checked, onChange] = useControllable(\n    controlledChecked,\n    controlledOnChange,\n    defaultChecked != null ? defaultChecked : false\n  );\n  let labelledBy = useLabelledBy();\n  let describedBy = useDescribedBy();\n  let d = useDisposables();\n  let [changing, setChanging] = (0, import_react25.useState)(false);\n  let toggle = useEvent(() => {\n    setChanging(true);\n    onChange == null ? void 0 : onChange(!checked);\n    d.nextFrame(() => {\n      setChanging(false);\n    });\n  });\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    event.preventDefault();\n    toggle();\n  });\n  let handleKeyUp = useEvent((event) => {\n    if (event.key === \" \" /* Space */) {\n      event.preventDefault();\n      toggle();\n    } else if (event.key === \"Enter\" /* Enter */) {\n      attemptSubmit(event.currentTarget);\n    }\n  });\n  let handleKeyPress = useEvent((event) => event.preventDefault());\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      role: \"checkbox\",\n      \"aria-checked\": indeterminate ? \"mixed\" : checked ? \"true\" : \"false\",\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      \"aria-disabled\": disabled ? true : void 0,\n      indeterminate: indeterminate ? \"true\" : void 0,\n      tabIndex: disabled ? void 0 : tabIndex,\n      onKeyUp: disabled ? void 0 : handleKeyUp,\n      onKeyPress: disabled ? void 0 : handleKeyPress,\n      onClick: disabled ? void 0 : handleClick\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let slot = (0, import_react25.useMemo)(() => {\n    return {\n      checked,\n      disabled,\n      hover,\n      focus,\n      active,\n      indeterminate,\n      changing,\n      autofocus: autoFocus\n    };\n  }, [checked, indeterminate, disabled, hover, focus, active, changing, autoFocus]);\n  let reset = (0, import_react25.useCallback)(() => {\n    if (defaultChecked === void 0)\n      return;\n    return onChange == null ? void 0 : onChange(defaultChecked);\n  }, [onChange, defaultChecked]);\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, name != null && /* @__PURE__ */ import_react25.default.createElement(\n    FormFields,\n    {\n      disabled,\n      data: { [name]: value || \"on\" },\n      overrides: { type: \"checkbox\", checked },\n      form,\n      onReset: reset\n    }\n  ), render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_CHECKBOX_TAG,\n    name: \"Checkbox\"\n  }));\n}\nvar Checkbox = forwardRefWithAs(CheckboxFn);\n\n// src/components/close-button/close-button.tsx\nvar import_react27 = __toESM(require(\"react\"), 1);\n\n// src/internal/close-provider.tsx\nvar import_react26 = __toESM(require(\"react\"), 1);\nvar CloseContext = (0, import_react26.createContext)(() => {\n});\nfunction useClose() {\n  return (0, import_react26.useContext)(CloseContext);\n}\nfunction CloseProvider({ value, children }) {\n  return /* @__PURE__ */ import_react26.default.createElement(CloseContext.Provider, { value }, children);\n}\n\n// src/components/close-button/close-button.tsx\nfunction CloseButtonFn(props, ref) {\n  let close = useClose();\n  return /* @__PURE__ */ import_react27.default.createElement(Button, { ref, ...mergeProps({ onClick: close }, props) });\n}\nvar CloseButton = forwardRefWithAs(CloseButtonFn);\n\n// ../../node_modules/@tanstack/react-virtual/dist/esm/index.js\nvar React11 = __toESM(require(\"react\"), 1);\nvar import_react_dom2 = require(\"react-dom\");\n\n// ../../node_modules/@tanstack/virtual-core/dist/esm/utils.js\nfunction memo(getDeps, fn, opts) {\n  var _a3;\n  let deps = (_a3 = opts.initialDeps) != null ? _a3 : [];\n  let result;\n  function memoizedFunction() {\n    var _a4, _b2, _c, _d;\n    let depTime;\n    if (opts.key && ((_a4 = opts.debug) == null ? void 0 : _a4.call(opts)))\n      depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index3) => deps[index3] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b2 = opts.debug) == null ? void 0 : _b2.call(opts)))\n      resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c\\u23F1 ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nvar approxEqual = (a, b) => Math.abs(a - b) < 1;\nvar debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\n\n// ../../node_modules/@tanstack/virtual-core/dist/esm/index.js\nvar defaultKeyExtractor = (index3) => index3;\nvar defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nvar observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(element.getBoundingClientRect());\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nvar addEventListenerOptions = {\n  passive: true\n};\nvar supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nvar observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset3 = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset3, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset3 = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset3, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nvar measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size3 = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size3;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nvar elementScroll = (offset3, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a3, _b2;\n  const toOffset = offset3 + adjustments;\n  (_b2 = (_a3 = instance.scrollElement) == null ? void 0 : _a3.scrollTo) == null ? void 0 : _b2.call(_a3, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nvar Virtualizer = class {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a3;\n          (_a3 = get()) == null ? void 0 : _a3.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a3;\n          return (_a3 = get()) == null ? void 0 : _a3.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a3;\n          return (_a3 = get()) == null ? void 0 : _a3.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\")\n          delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a3, _b2;\n      (_b2 = (_a3 = this.options).onChange) == null ? void 0 : _b2.call(_a3, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a4;\n      var _a3;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = (_a4 = (_a3 = this.scrollElement) == null ? void 0 : _a3.window) != null ? _a4 : null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset3, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset3 ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset3;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      var _a3;\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = (_a3 = this.scrollRect) != null ? _a3 : this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      var _a3;\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = (_a3 = this.scrollOffset) != null ? _a3 : typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset;\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index3) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index3 - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count2, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count: count2,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count: count2, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min2);\n        for (let i = min2; i < count2; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size3 = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size3;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size: size3,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count2, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count: count2\n        });\n      },\n      {\n        key: \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index3 = this.indexFromElement(node);\n      const item = this.measurementsCache[index3];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index3, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index3, size3) => {\n      var _a3;\n      const item = this.measurementsCache[index3];\n      if (!item) {\n        return;\n      }\n      const itemSize = (_a3 = this.itemSizeCache.get(item.key)) != null ? _a3 : item.size;\n      const delta = size3 - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size3));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset3) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index3) => notUndefined(measurements[index3]).start,\n          offset3\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size3 = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size3 ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size3) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size3;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - size3;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index3, align = \"auto\") => {\n      index3 = Math.max(0, Math.min(index3, this.options.count - 1));\n      const item = this.measurementsCache[index3];\n      if (!item) {\n        return void 0;\n      }\n      const size3 = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size3 - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index3, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index3 = Math.max(0, Math.min(index3, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const offsetAndAlign = this.getOffsetForIndex(index3, initialAlign);\n      if (!offsetAndAlign)\n        return;\n      const [offset3, align] = offsetAndAlign;\n      this._scrollToOffset(offset3, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.elementsCache.has(\n            this.options.getItemKey(index3)\n          );\n          if (elementInDOM) {\n            const result = this.getOffsetForIndex(index3, align);\n            if (!result)\n              return;\n            const [latestOffset] = result;\n            if (!approxEqual(latestOffset, this.getScrollOffset())) {\n              this.scrollToIndex(index3, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index3, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a4;\n      var _a3;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = (_a4 = (_a3 = measurements[measurements.length - 1]) == null ? void 0 : _a3.end) != null ? _a4 : 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset3, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset3, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n};\nvar findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index3) => measurements[index3].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\n\n// ../../node_modules/@tanstack/react-virtual/dist/esm/index.js\nvar useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React11.useLayoutEffect : React11.useEffect;\nfunction useVirtualizerBase(options) {\n  const rerender = React11.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a3;\n      if (sync) {\n        (0, import_react_dom2.flushSync)(rerender);\n      } else {\n        rerender();\n      }\n      (_a3 = options.onChange) == null ? void 0 : _a3.call(options, instance2, sync);\n    }\n  };\n  const [instance] = React11.useState(\n    () => new Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect,\n    observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options\n  });\n}\n\n// src/components/combobox/combobox.tsx\nvar import_react55 = __toESM(require(\"react\"), 1);\nvar import_react_dom7 = require(\"react-dom\");\n\n// src/hooks/use-by-comparator.ts\nvar import_react28 = require(\"react\");\nfunction defaultBy(a, z) {\n  if (a !== null && z !== null && typeof a === \"object\" && typeof z === \"object\" && \"id\" in a && \"id\" in z) {\n    return a.id === z.id;\n  }\n  return a === z;\n}\nfunction useByComparator(by = defaultBy) {\n  return (0, import_react28.useCallback)(\n    (a, z) => {\n      if (typeof by === \"string\") {\n        let property = by;\n        return (a == null ? void 0 : a[property]) === (z == null ? void 0 : z[property]);\n      }\n      return by(a, z);\n    },\n    [by]\n  );\n}\n\n// src/hooks/use-element-size.ts\nvar import_react29 = require(\"react\");\nfunction computeSize(element) {\n  if (element === null)\n    return { width: 0, height: 0 };\n  let { width, height } = element.getBoundingClientRect();\n  return { width, height };\n}\nfunction useElementSize(element, unit = false) {\n  let [identity2, forceRerender] = (0, import_react29.useReducer)(() => ({}), {});\n  let size3 = (0, import_react29.useMemo)(() => computeSize(element), [element, identity2]);\n  useIsoMorphicEffect(() => {\n    if (!element)\n      return;\n    let observer = new ResizeObserver(forceRerender);\n    observer.observe(element);\n    return () => {\n      observer.disconnect();\n    };\n  }, [element]);\n  if (unit) {\n    return {\n      width: `${size3.width}px`,\n      height: `${size3.height}px`\n    };\n  }\n  return size3;\n}\n\n// src/hooks/use-is-top-layer.ts\nvar import_react31 = require(\"react\");\n\n// src/utils/default-map.ts\nvar DefaultMap = class extends Map {\n  constructor(factory) {\n    super();\n    this.factory = factory;\n  }\n  get(key) {\n    let value = super.get(key);\n    if (value === void 0) {\n      value = this.factory(key);\n      this.set(key, value);\n    }\n    return value;\n  }\n};\n\n// src/utils/store.ts\nfunction createStore(initial, actions) {\n  let state = initial();\n  let listeners = /* @__PURE__ */ new Set();\n  return {\n    getSnapshot() {\n      return state;\n    },\n    subscribe(onChange) {\n      listeners.add(onChange);\n      return () => listeners.delete(onChange);\n    },\n    dispatch(key, ...args) {\n      let newState = actions[key].call(state, ...args);\n      if (newState) {\n        state = newState;\n        listeners.forEach((listener) => listener());\n      }\n    }\n  };\n}\n\n// src/hooks/use-store.ts\nvar import_react30 = require(\"react\");\nfunction useStore(store) {\n  return (0, import_react30.useSyncExternalStore)(store.subscribe, store.getSnapshot, store.getSnapshot);\n}\n\n// src/hooks/use-is-top-layer.ts\nvar hierarchyStores = new DefaultMap(\n  () => createStore(() => [], {\n    ADD(id) {\n      if (this.includes(id))\n        return this;\n      return [...this, id];\n    },\n    REMOVE(id) {\n      let idx = this.indexOf(id);\n      if (idx === -1)\n        return this;\n      let copy = this.slice();\n      copy.splice(idx, 1);\n      return copy;\n    }\n  })\n);\nfunction useIsTopLayer(enabled, scope) {\n  let hierarchyStore = hierarchyStores.get(scope);\n  let id = (0, import_react31.useId)();\n  let hierarchy = useStore(hierarchyStore);\n  useIsoMorphicEffect(() => {\n    if (!enabled)\n      return;\n    hierarchyStore.dispatch(\"ADD\", id);\n    return () => hierarchyStore.dispatch(\"REMOVE\", id);\n  }, [hierarchyStore, enabled]);\n  if (!enabled)\n    return false;\n  let idx = hierarchy.indexOf(id);\n  let hierarchyLength = hierarchy.length;\n  if (idx === -1) {\n    idx = hierarchyLength;\n    hierarchyLength += 1;\n  }\n  return idx === hierarchyLength - 1;\n}\n\n// src/hooks/use-inert-others.tsx\nvar originals = /* @__PURE__ */ new Map();\nvar counts = /* @__PURE__ */ new Map();\nfunction markInert(element) {\n  var _a3;\n  let count2 = (_a3 = counts.get(element)) != null ? _a3 : 0;\n  counts.set(element, count2 + 1);\n  if (count2 !== 0)\n    return () => markNotInert(element);\n  originals.set(element, {\n    \"aria-hidden\": element.getAttribute(\"aria-hidden\"),\n    inert: element.inert\n  });\n  element.setAttribute(\"aria-hidden\", \"true\");\n  element.inert = true;\n  return () => markNotInert(element);\n}\nfunction markNotInert(element) {\n  var _a3;\n  let count2 = (_a3 = counts.get(element)) != null ? _a3 : 1;\n  if (count2 === 1)\n    counts.delete(element);\n  else\n    counts.set(element, count2 - 1);\n  if (count2 !== 1)\n    return;\n  let original = originals.get(element);\n  if (!original)\n    return;\n  if (original[\"aria-hidden\"] === null)\n    element.removeAttribute(\"aria-hidden\");\n  else\n    element.setAttribute(\"aria-hidden\", original[\"aria-hidden\"]);\n  element.inert = original.inert;\n  originals.delete(element);\n}\nfunction useInertOthers(enabled, {\n  allowed,\n  disallowed\n} = {}) {\n  let isTopLayer = useIsTopLayer(enabled, \"inert-others\");\n  useIsoMorphicEffect(() => {\n    var _a3, _b2;\n    if (!isTopLayer)\n      return;\n    let d = disposables();\n    for (let element of (_a3 = disallowed == null ? void 0 : disallowed()) != null ? _a3 : []) {\n      if (!element)\n        continue;\n      d.add(markInert(element));\n    }\n    let allowedElements = (_b2 = allowed == null ? void 0 : allowed()) != null ? _b2 : [];\n    for (let element of allowedElements) {\n      if (!element)\n        continue;\n      let ownerDocument = getOwnerDocument(element);\n      if (!ownerDocument)\n        continue;\n      let parent = element.parentElement;\n      while (parent && parent !== ownerDocument.body) {\n        for (let node of parent.children) {\n          if (allowedElements.some((el) => node.contains(el)))\n            continue;\n          d.add(markInert(node));\n        }\n        parent = parent.parentElement;\n      }\n    }\n    return d.dispose;\n  }, [isTopLayer, allowed, disallowed]);\n}\n\n// src/hooks/use-on-disappear.ts\nvar import_react32 = require(\"react\");\nfunction useOnDisappear(enabled, ref, cb) {\n  let listenerRef = useLatestValue((element) => {\n    let rect = element.getBoundingClientRect();\n    if (rect.x === 0 && rect.y === 0 && rect.width === 0 && rect.height === 0) {\n      cb();\n    }\n  });\n  (0, import_react32.useEffect)(() => {\n    if (!enabled)\n      return;\n    let element = ref === null ? null : ref instanceof HTMLElement ? ref : ref.current;\n    if (!element)\n      return;\n    let d = disposables();\n    if (typeof ResizeObserver !== \"undefined\") {\n      let observer = new ResizeObserver(() => listenerRef.current(element));\n      observer.observe(element);\n      d.add(() => observer.disconnect());\n    }\n    if (typeof IntersectionObserver !== \"undefined\") {\n      let observer = new IntersectionObserver(() => listenerRef.current(element));\n      observer.observe(element);\n      d.add(() => observer.disconnect());\n    }\n    return () => d.dispose();\n  }, [ref, listenerRef, enabled]);\n}\n\n// src/hooks/use-outside-click.ts\nvar import_react35 = require(\"react\");\n\n// src/utils/focus-management.ts\nvar focusableSelector = [\n  \"[contentEditable=true]\",\n  \"[tabindex]\",\n  \"a[href]\",\n  \"area[href]\",\n  \"button:not([disabled])\",\n  \"iframe\",\n  \"input:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\"\n].map(\n  false ? (\n    // TODO: Remove this once JSDOM fixes the issue where an element that is\n    // \"hidden\" can be the document.activeElement, because this is not possible\n    // in real browsers.\n    (selector) => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n  ) : (selector) => `${selector}:not([tabindex='-1'])`\n).join(\",\");\nvar autoFocusableSelector = [\n  // In a perfect world this was just `autofocus`, but React doesn't pass `autofocus` to the DOM...\n  \"[data-autofocus]\"\n].map(\n  false ? (\n    // TODO: Remove this once JSDOM fixes the issue where an element that is\n    // \"hidden\" can be the document.activeElement, because this is not possible\n    // in real browsers.\n    (selector) => `${selector}:not([tabindex='-1']):not([style*='display: none'])`\n  ) : (selector) => `${selector}:not([tabindex='-1'])`\n).join(\",\");\nfunction getFocusableElements(container = document.body) {\n  if (container == null)\n    return [];\n  return Array.from(container.querySelectorAll(focusableSelector)).sort(\n    // We want to move `tabIndex={0}` to the end of the list, this is what the browser does as well.\n    (a, z) => Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER))\n  );\n}\nfunction getAutoFocusableElements(container = document.body) {\n  if (container == null)\n    return [];\n  return Array.from(container.querySelectorAll(autoFocusableSelector)).sort(\n    // We want to move `tabIndex={0}` to the end of the list, this is what the browser does as well.\n    (a, z) => Math.sign((a.tabIndex || Number.MAX_SAFE_INTEGER) - (z.tabIndex || Number.MAX_SAFE_INTEGER))\n  );\n}\nfunction isFocusableElement(element, mode = 0 /* Strict */) {\n  var _a3;\n  if (element === ((_a3 = getOwnerDocument(element)) == null ? void 0 : _a3.body))\n    return false;\n  return match(mode, {\n    [0 /* Strict */]() {\n      return element.matches(focusableSelector);\n    },\n    [1 /* Loose */]() {\n      let next = element;\n      while (next !== null) {\n        if (next.matches(focusableSelector))\n          return true;\n        next = next.parentElement;\n      }\n      return false;\n    }\n  });\n}\nfunction restoreFocusIfNecessary(element) {\n  let ownerDocument = getOwnerDocument(element);\n  disposables().nextFrame(() => {\n    if (ownerDocument && !isFocusableElement(ownerDocument.activeElement, 0 /* Strict */)) {\n      focusElement(element);\n    }\n  });\n}\nif (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n  document.addEventListener(\n    \"keydown\",\n    (event) => {\n      if (event.metaKey || event.altKey || event.ctrlKey) {\n        return;\n      }\n      document.documentElement.dataset.headlessuiFocusVisible = \"\";\n    },\n    true\n  );\n  document.addEventListener(\n    \"click\",\n    (event) => {\n      if (event.detail === 1 /* Mouse */) {\n        delete document.documentElement.dataset.headlessuiFocusVisible;\n      } else if (event.detail === 0 /* Keyboard */) {\n        document.documentElement.dataset.headlessuiFocusVisible = \"\";\n      }\n    },\n    true\n  );\n}\nfunction focusElement(element) {\n  element == null ? void 0 : element.focus({ preventScroll: true });\n}\nvar selectableSelector = [\"textarea\", \"input\"].join(\",\");\nfunction isSelectableElement(element) {\n  var _a3, _b2;\n  return (_b2 = (_a3 = element == null ? void 0 : element.matches) == null ? void 0 : _a3.call(element, selectableSelector)) != null ? _b2 : false;\n}\nfunction sortByDomNode(nodes, resolveKey = (i) => i) {\n  return nodes.slice().sort((aItem, zItem) => {\n    let a = resolveKey(aItem);\n    let z = resolveKey(zItem);\n    if (a === null || z === null)\n      return 0;\n    let position = a.compareDocumentPosition(z);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING)\n      return -1;\n    if (position & Node.DOCUMENT_POSITION_PRECEDING)\n      return 1;\n    return 0;\n  });\n}\nfunction focusFrom(current, focus) {\n  return focusIn(getFocusableElements(), focus, { relativeTo: current });\n}\nfunction focusIn(container, focus, {\n  sorted = true,\n  relativeTo = null,\n  skipElements = []\n} = {}) {\n  let ownerDocument = Array.isArray(container) ? container.length > 0 ? container[0].ownerDocument : document : container.ownerDocument;\n  let elements = Array.isArray(container) ? sorted ? sortByDomNode(container) : container : focus & 64 /* AutoFocus */ ? getAutoFocusableElements(container) : getFocusableElements(container);\n  if (skipElements.length > 0 && elements.length > 1) {\n    elements = elements.filter(\n      (element) => !skipElements.some(\n        (skipElement) => skipElement != null && \"current\" in skipElement ? (skipElement == null ? void 0 : skipElement.current) === element : skipElement === element\n        // Handle HTMLElement directly\n      )\n    );\n  }\n  relativeTo = relativeTo != null ? relativeTo : ownerDocument.activeElement;\n  let direction = (() => {\n    if (focus & (1 /* First */ | 4 /* Next */))\n      return 1 /* Next */;\n    if (focus & (2 /* Previous */ | 8 /* Last */))\n      return -1 /* Previous */;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })();\n  let startIndex = (() => {\n    if (focus & 1 /* First */)\n      return 0;\n    if (focus & 2 /* Previous */)\n      return Math.max(0, elements.indexOf(relativeTo)) - 1;\n    if (focus & 4 /* Next */)\n      return Math.max(0, elements.indexOf(relativeTo)) + 1;\n    if (focus & 8 /* Last */)\n      return elements.length - 1;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })();\n  let focusOptions = focus & 32 /* NoScroll */ ? { preventScroll: true } : {};\n  let offset3 = 0;\n  let total = elements.length;\n  let next = void 0;\n  do {\n    if (offset3 >= total || offset3 + total <= 0)\n      return 0 /* Error */;\n    let nextIdx = startIndex + offset3;\n    if (focus & 16 /* WrapAround */) {\n      nextIdx = (nextIdx + total) % total;\n    } else {\n      if (nextIdx < 0)\n        return 3 /* Underflow */;\n      if (nextIdx >= total)\n        return 1 /* Overflow */;\n    }\n    next = elements[nextIdx];\n    next == null ? void 0 : next.focus(focusOptions);\n    offset3 += direction;\n  } while (next !== ownerDocument.activeElement);\n  if (focus & (4 /* Next */ | 2 /* Previous */) && isSelectableElement(next)) {\n    next.select();\n  }\n  return 2 /* Success */;\n}\n\n// src/utils/platform.ts\nfunction isIOS() {\n  return (\n    // Check if it is an iPhone\n    /iPhone/gi.test(window.navigator.platform) || // Check if it is an iPad. iPad reports itself as \"MacIntel\", but we can check if it is a touch\n    // screen. Let's hope that Apple doesn't release a touch screen Mac (or maybe this would then\n    // work as expected 🤔).\n    /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0\n  );\n}\nfunction isAndroid() {\n  return /Android/gi.test(window.navigator.userAgent);\n}\nfunction isMobile() {\n  return isIOS() || isAndroid();\n}\n\n// src/hooks/use-document-event.ts\nvar import_react33 = require(\"react\");\nfunction useDocumentEvent(enabled, type, listener, options) {\n  let listenerRef = useLatestValue(listener);\n  (0, import_react33.useEffect)(() => {\n    if (!enabled)\n      return;\n    function handler(event) {\n      listenerRef.current(event);\n    }\n    document.addEventListener(type, handler, options);\n    return () => document.removeEventListener(type, handler, options);\n  }, [enabled, type, options]);\n}\n\n// src/hooks/use-window-event.ts\nvar import_react34 = require(\"react\");\nfunction useWindowEvent(enabled, type, listener, options) {\n  let listenerRef = useLatestValue(listener);\n  (0, import_react34.useEffect)(() => {\n    if (!enabled)\n      return;\n    function handler(event) {\n      listenerRef.current(event);\n    }\n    window.addEventListener(type, handler, options);\n    return () => window.removeEventListener(type, handler, options);\n  }, [enabled, type, options]);\n}\n\n// src/hooks/use-outside-click.ts\nvar MOVE_THRESHOLD_PX = 30;\nfunction useOutsideClick(enabled, containers, cb) {\n  let isTopLayer = useIsTopLayer(enabled, \"outside-click\");\n  let cbRef = useLatestValue(cb);\n  let handleOutsideClick = (0, import_react35.useCallback)(\n    function handleOutsideClick2(event, resolveTarget) {\n      if (event.defaultPrevented)\n        return;\n      let target = resolveTarget(event);\n      if (target === null) {\n        return;\n      }\n      if (!target.getRootNode().contains(target))\n        return;\n      if (!target.isConnected)\n        return;\n      let _containers = function resolve(containers2) {\n        if (typeof containers2 === \"function\") {\n          return resolve(containers2());\n        }\n        if (Array.isArray(containers2)) {\n          return containers2;\n        }\n        if (containers2 instanceof Set) {\n          return containers2;\n        }\n        return [containers2];\n      }(containers);\n      for (let container of _containers) {\n        if (container === null)\n          continue;\n        if (container.contains(target)) {\n          return;\n        }\n        if (event.composed && event.composedPath().includes(container)) {\n          return;\n        }\n      }\n      if (\n        // This check allows us to know whether or not we clicked on a\n        // \"focusable\" element like a button or an input. This is a backwards\n        // compatibility check so that you can open a <Menu /> and click on\n        // another <Menu /> which should close Menu A and open Menu B. We might\n        // revisit that so that you will require 2 clicks instead.\n        !isFocusableElement(target, 1 /* Loose */) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1}\n        // to make it unfocusable via the keyboard so that tabbing to the next\n        // item from the input doesn't first go to the button.\n        target.tabIndex !== -1\n      ) {\n        event.preventDefault();\n      }\n      return cbRef.current(event, target);\n    },\n    [cbRef, containers]\n  );\n  let initialClickTarget = (0, import_react35.useRef)(null);\n  useDocumentEvent(\n    isTopLayer,\n    \"pointerdown\",\n    (event) => {\n      var _a3, _b2;\n      initialClickTarget.current = ((_b2 = (_a3 = event.composedPath) == null ? void 0 : _a3.call(event)) == null ? void 0 : _b2[0]) || event.target;\n    },\n    true\n  );\n  useDocumentEvent(\n    isTopLayer,\n    \"mousedown\",\n    (event) => {\n      var _a3, _b2;\n      initialClickTarget.current = ((_b2 = (_a3 = event.composedPath) == null ? void 0 : _a3.call(event)) == null ? void 0 : _b2[0]) || event.target;\n    },\n    true\n  );\n  useDocumentEvent(\n    isTopLayer,\n    \"click\",\n    (event) => {\n      if (isMobile()) {\n        return;\n      }\n      if (!initialClickTarget.current) {\n        return;\n      }\n      handleOutsideClick(event, () => {\n        return initialClickTarget.current;\n      });\n      initialClickTarget.current = null;\n    },\n    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`\n    // don't \"cancel\" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`\n    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,\n    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.\n    true\n  );\n  let startPosition = (0, import_react35.useRef)({ x: 0, y: 0 });\n  useDocumentEvent(\n    isTopLayer,\n    \"touchstart\",\n    (event) => {\n      startPosition.current.x = event.touches[0].clientX;\n      startPosition.current.y = event.touches[0].clientY;\n    },\n    true\n  );\n  useDocumentEvent(\n    isTopLayer,\n    \"touchend\",\n    (event) => {\n      let endPosition = { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };\n      if (Math.abs(endPosition.x - startPosition.current.x) >= MOVE_THRESHOLD_PX || Math.abs(endPosition.y - startPosition.current.y) >= MOVE_THRESHOLD_PX) {\n        return;\n      }\n      return handleOutsideClick(event, () => {\n        if (event.target instanceof HTMLElement) {\n          return event.target;\n        }\n        return null;\n      });\n    },\n    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`\n    // don't \"cancel\" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`\n    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,\n    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.\n    true\n  );\n  useWindowEvent(\n    isTopLayer,\n    \"blur\",\n    (event) => {\n      return handleOutsideClick(event, () => {\n        return window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null;\n      });\n    },\n    true\n  );\n}\n\n// src/hooks/use-owner.ts\nvar import_react36 = require(\"react\");\nfunction useOwnerDocument(...args) {\n  return (0, import_react36.useMemo)(() => getOwnerDocument(...args), [...args]);\n}\n\n// src/hooks/use-refocusable-input.ts\nvar import_react38 = require(\"react\");\n\n// src/hooks/use-event-listener.ts\nvar import_react37 = require(\"react\");\nfunction useEventListener(element, type, listener, options) {\n  let listenerRef = useLatestValue(listener);\n  (0, import_react37.useEffect)(() => {\n    element = element != null ? element : window;\n    function handler(event) {\n      listenerRef.current(event);\n    }\n    element.addEventListener(type, handler, options);\n    return () => element.removeEventListener(type, handler, options);\n  }, [element, type, options]);\n}\n\n// src/hooks/use-refocusable-input.ts\nfunction useRefocusableInput(input) {\n  let info = (0, import_react38.useRef)({\n    value: \"\",\n    selectionStart: null,\n    selectionEnd: null\n  });\n  useEventListener(input, \"blur\", (event) => {\n    let target = event.target;\n    if (!(target instanceof HTMLInputElement))\n      return;\n    info.current = {\n      value: target.value,\n      selectionStart: target.selectionStart,\n      selectionEnd: target.selectionEnd\n    };\n  });\n  return useEvent(() => {\n    if (document.activeElement === input)\n      return;\n    if (!(input instanceof HTMLInputElement))\n      return;\n    if (!input.isConnected)\n      return;\n    input.focus({ preventScroll: true });\n    if (input.value !== info.current.value) {\n      input.setSelectionRange(input.value.length, input.value.length);\n    } else {\n      let { selectionStart, selectionEnd } = info.current;\n      if (selectionStart !== null && selectionEnd !== null) {\n        input.setSelectionRange(selectionStart, selectionEnd);\n      }\n    }\n    info.current = { value: \"\", selectionStart: null, selectionEnd: null };\n  });\n}\n\n// src/hooks/use-resolve-button-type.ts\nvar import_react39 = require(\"react\");\nfunction useResolveButtonType(props, element) {\n  return (0, import_react39.useMemo)(() => {\n    var _a3;\n    if (props.type)\n      return props.type;\n    let tag = (_a3 = props.as) != null ? _a3 : \"button\";\n    if (typeof tag === \"string\" && tag.toLowerCase() === \"button\")\n      return \"button\";\n    if ((element == null ? void 0 : element.tagName) === \"BUTTON\" && !element.hasAttribute(\"type\"))\n      return \"button\";\n    return void 0;\n  }, [props.type, props.as, element]);\n}\n\n// src/hooks/document-overflow/adjust-scrollbar-padding.ts\nfunction adjustScrollbarPadding() {\n  let scrollbarWidthBefore;\n  return {\n    before({ doc }) {\n      var _a3;\n      let documentElement = doc.documentElement;\n      let ownerWindow = (_a3 = doc.defaultView) != null ? _a3 : window;\n      scrollbarWidthBefore = Math.max(0, ownerWindow.innerWidth - documentElement.clientWidth);\n    },\n    after({ doc, d }) {\n      let documentElement = doc.documentElement;\n      let scrollbarWidthAfter = Math.max(\n        0,\n        documentElement.clientWidth - documentElement.offsetWidth\n      );\n      let scrollbarWidth = Math.max(0, scrollbarWidthBefore - scrollbarWidthAfter);\n      d.style(documentElement, \"paddingRight\", `${scrollbarWidth}px`);\n    }\n  };\n}\n\n// src/hooks/document-overflow/handle-ios-locking.ts\nfunction handleIOSLocking() {\n  if (!isIOS()) {\n    return {};\n  }\n  return {\n    before({ doc, d, meta }) {\n      function inAllowedContainer(el) {\n        return meta.containers.flatMap((resolve) => resolve()).some((container) => container.contains(el));\n      }\n      d.microTask(() => {\n        var _a3;\n        if (window.getComputedStyle(doc.documentElement).scrollBehavior !== \"auto\") {\n          let _d = disposables();\n          _d.style(doc.documentElement, \"scrollBehavior\", \"auto\");\n          d.add(() => d.microTask(() => _d.dispose()));\n        }\n        let scrollPosition = (_a3 = window.scrollY) != null ? _a3 : window.pageYOffset;\n        let scrollToElement = null;\n        d.addEventListener(\n          doc,\n          \"click\",\n          (e) => {\n            if (!(e.target instanceof HTMLElement)) {\n              return;\n            }\n            try {\n              let anchor = e.target.closest(\"a\");\n              if (!anchor)\n                return;\n              let { hash } = new URL(anchor.href);\n              let el = doc.querySelector(hash);\n              if (el && !inAllowedContainer(el)) {\n                scrollToElement = el;\n              }\n            } catch (err) {\n            }\n          },\n          true\n        );\n        d.addEventListener(doc, \"touchstart\", (e) => {\n          if (e.target instanceof HTMLElement) {\n            if (inAllowedContainer(e.target)) {\n              let rootContainer = e.target;\n              while (rootContainer.parentElement && inAllowedContainer(rootContainer.parentElement)) {\n                rootContainer = rootContainer.parentElement;\n              }\n              d.style(rootContainer, \"overscrollBehavior\", \"contain\");\n            } else {\n              d.style(e.target, \"touchAction\", \"none\");\n            }\n          }\n        });\n        d.addEventListener(\n          doc,\n          \"touchmove\",\n          (e) => {\n            if (e.target instanceof HTMLElement) {\n              if (e.target.tagName === \"INPUT\") {\n                return;\n              }\n              if (inAllowedContainer(e.target)) {\n                let scrollableParent = e.target;\n                while (scrollableParent.parentElement && // Assumption: We are always used in a Headless UI Portal. Once we reach the\n                // portal itself, we can stop crawling up the tree.\n                scrollableParent.dataset.headlessuiPortal !== \"\") {\n                  if (scrollableParent.scrollHeight > scrollableParent.clientHeight || scrollableParent.scrollWidth > scrollableParent.clientWidth) {\n                    break;\n                  }\n                  scrollableParent = scrollableParent.parentElement;\n                }\n                if (scrollableParent.dataset.headlessuiPortal === \"\") {\n                  e.preventDefault();\n                }\n              } else {\n                e.preventDefault();\n              }\n            }\n          },\n          { passive: false }\n        );\n        d.add(() => {\n          var _a4;\n          let newScrollPosition = (_a4 = window.scrollY) != null ? _a4 : window.pageYOffset;\n          if (scrollPosition !== newScrollPosition) {\n            window.scrollTo(0, scrollPosition);\n          }\n          if (scrollToElement && scrollToElement.isConnected) {\n            scrollToElement.scrollIntoView({ block: \"nearest\" });\n            scrollToElement = null;\n          }\n        });\n      });\n    }\n  };\n}\n\n// src/hooks/document-overflow/prevent-scroll.ts\nfunction preventScroll() {\n  return {\n    before({ doc, d }) {\n      d.style(doc.documentElement, \"overflow\", \"hidden\");\n    }\n  };\n}\n\n// src/hooks/document-overflow/overflow-store.ts\nfunction buildMeta(fns) {\n  let tmp = {};\n  for (let fn of fns) {\n    Object.assign(tmp, fn(tmp));\n  }\n  return tmp;\n}\nvar overflows = createStore(() => /* @__PURE__ */ new Map(), {\n  PUSH(doc, meta) {\n    var _a3;\n    let entry = (_a3 = this.get(doc)) != null ? _a3 : {\n      doc,\n      count: 0,\n      d: disposables(),\n      meta: /* @__PURE__ */ new Set()\n    };\n    entry.count++;\n    entry.meta.add(meta);\n    this.set(doc, entry);\n    return this;\n  },\n  POP(doc, meta) {\n    let entry = this.get(doc);\n    if (entry) {\n      entry.count--;\n      entry.meta.delete(meta);\n    }\n    return this;\n  },\n  SCROLL_PREVENT({ doc, d, meta }) {\n    let ctx = {\n      doc,\n      d,\n      meta: buildMeta(meta)\n    };\n    let steps = [\n      handleIOSLocking(),\n      adjustScrollbarPadding(),\n      preventScroll()\n    ];\n    steps.forEach(({ before }) => before == null ? void 0 : before(ctx));\n    steps.forEach(({ after }) => after == null ? void 0 : after(ctx));\n  },\n  SCROLL_ALLOW({ d }) {\n    d.dispose();\n  },\n  TEARDOWN({ doc }) {\n    this.delete(doc);\n  }\n});\noverflows.subscribe(() => {\n  let docs = overflows.getSnapshot();\n  let styles = /* @__PURE__ */ new Map();\n  for (let [doc] of docs) {\n    styles.set(doc, doc.documentElement.style.overflow);\n  }\n  for (let entry of docs.values()) {\n    let isHidden = styles.get(entry.doc) === \"hidden\";\n    let isLocked = entry.count !== 0;\n    let willChange = isLocked && !isHidden || !isLocked && isHidden;\n    if (willChange) {\n      overflows.dispatch(entry.count > 0 ? \"SCROLL_PREVENT\" : \"SCROLL_ALLOW\", entry);\n    }\n    if (entry.count === 0) {\n      overflows.dispatch(\"TEARDOWN\", entry);\n    }\n  }\n});\n\n// src/hooks/document-overflow/use-document-overflow.ts\nfunction useDocumentOverflowLockedEffect(shouldBeLocked, doc, meta = () => ({ containers: [] })) {\n  let store = useStore(overflows);\n  let entry = doc ? store.get(doc) : void 0;\n  let locked = entry ? entry.count > 0 : false;\n  useIsoMorphicEffect(() => {\n    if (!doc || !shouldBeLocked) {\n      return;\n    }\n    overflows.dispatch(\"PUSH\", doc, meta);\n    return () => overflows.dispatch(\"POP\", doc, meta);\n  }, [shouldBeLocked, doc]);\n  return locked;\n}\n\n// src/hooks/use-scroll-lock.ts\nfunction useScrollLock(enabled, ownerDocument, resolveAllowedContainers = () => [document.body]) {\n  let isTopLayer = useIsTopLayer(enabled, \"scroll-lock\");\n  useDocumentOverflowLockedEffect(isTopLayer, ownerDocument, (meta) => {\n    var _a3;\n    return {\n      containers: [...(_a3 = meta.containers) != null ? _a3 : [], resolveAllowedContainers]\n    };\n  });\n}\n\n// src/hooks/use-tracked-pointer.ts\nvar import_react40 = require(\"react\");\nfunction eventToPosition(evt) {\n  return [evt.screenX, evt.screenY];\n}\nfunction useTrackedPointer() {\n  let lastPos = (0, import_react40.useRef)([-1, -1]);\n  return {\n    wasMoved(evt) {\n      if (false) {\n        return true;\n      }\n      let newPos = eventToPosition(evt);\n      if (lastPos.current[0] === newPos[0] && lastPos.current[1] === newPos[1]) {\n        return false;\n      }\n      lastPos.current = newPos;\n      return true;\n    },\n    update(evt) {\n      lastPos.current = eventToPosition(evt);\n    }\n  };\n}\n\n// src/hooks/use-transition.ts\nvar import_react42 = require(\"react\");\n\n// src/hooks/use-flags.ts\nvar import_react41 = require(\"react\");\nfunction useFlags(initialFlags = 0) {\n  let [flags, setFlags] = (0, import_react41.useState)(initialFlags);\n  let setFlag = (0, import_react41.useCallback)((flag) => setFlags(flag), [flags]);\n  let addFlag = (0, import_react41.useCallback)((flag) => setFlags((flags2) => flags2 | flag), [flags]);\n  let hasFlag = (0, import_react41.useCallback)((flag) => (flags & flag) === flag, [flags]);\n  let removeFlag = (0, import_react41.useCallback)((flag) => setFlags((flags2) => flags2 & ~flag), [setFlags]);\n  let toggleFlag = (0, import_react41.useCallback)((flag) => setFlags((flags2) => flags2 ^ flag), [setFlags]);\n  return { flags, setFlag, addFlag, hasFlag, removeFlag, toggleFlag };\n}\n\n// src/hooks/use-transition.ts\nvar _a, _b;\nif (typeof process !== \"undefined\" && typeof globalThis !== \"undefined\" && typeof Element !== \"undefined\" && // Strange string concatenation is on purpose to prevent `esbuild` from\n// replacing `process.env.NODE_ENV` with `production` in the build output,\n// eliminating this whole branch.\n((_a = process == null ? void 0 : process.env) == null ? void 0 : _a[\"NODE_ENV\"]) === \"test\") {\n  if (typeof ((_b = Element == null ? void 0 : Element.prototype) == null ? void 0 : _b.getAnimations) === \"undefined\") {\n    Element.prototype.getAnimations = function getAnimationsPolyfill() {\n      console.warn(\n        [\n          \"Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.\",\n          \"Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.\",\n          \"\",\n          \"Example usage:\",\n          \"```js\",\n          \"import { mockAnimationsApi } from 'jsdom-testing-mocks'\",\n          \"mockAnimationsApi()\",\n          \"```\"\n        ].join(\"\\n\")\n      );\n      return [];\n    };\n  }\n}\nfunction transitionDataAttributes(data) {\n  let attributes = {};\n  for (let key in data) {\n    if (data[key] === true) {\n      attributes[`data-${key}`] = \"\";\n    }\n  }\n  return attributes;\n}\nfunction useTransition(enabled, element, show, events) {\n  let [visible, setVisible] = (0, import_react42.useState)(show);\n  let { hasFlag, addFlag, removeFlag } = useFlags(\n    enabled && visible ? 2 /* Enter */ | 1 /* Closed */ : 0 /* None */\n  );\n  let inFlight = (0, import_react42.useRef)(false);\n  let cancelledRef = (0, import_react42.useRef)(false);\n  let d = useDisposables();\n  useIsoMorphicEffect(() => {\n    var _a3;\n    if (!enabled)\n      return;\n    if (show) {\n      setVisible(true);\n    }\n    if (!element) {\n      if (show) {\n        addFlag(2 /* Enter */ | 1 /* Closed */);\n      }\n      return;\n    }\n    (_a3 = events == null ? void 0 : events.start) == null ? void 0 : _a3.call(events, show);\n    return transition(element, {\n      inFlight,\n      prepare() {\n        if (cancelledRef.current) {\n          cancelledRef.current = false;\n        } else {\n          cancelledRef.current = inFlight.current;\n        }\n        inFlight.current = true;\n        if (cancelledRef.current)\n          return;\n        if (show) {\n          addFlag(2 /* Enter */ | 1 /* Closed */);\n          removeFlag(4 /* Leave */);\n        } else {\n          addFlag(4 /* Leave */);\n          removeFlag(2 /* Enter */);\n        }\n      },\n      run() {\n        if (cancelledRef.current) {\n          if (show) {\n            removeFlag(2 /* Enter */ | 1 /* Closed */);\n            addFlag(4 /* Leave */);\n          } else {\n            removeFlag(4 /* Leave */);\n            addFlag(2 /* Enter */ | 1 /* Closed */);\n          }\n        } else {\n          if (show) {\n            removeFlag(1 /* Closed */);\n          } else {\n            addFlag(1 /* Closed */);\n          }\n        }\n      },\n      done() {\n        var _a4;\n        if (cancelledRef.current) {\n          if (typeof element.getAnimations === \"function\" && element.getAnimations().length > 0) {\n            return;\n          }\n        }\n        inFlight.current = false;\n        removeFlag(2 /* Enter */ | 4 /* Leave */ | 1 /* Closed */);\n        if (!show) {\n          setVisible(false);\n        }\n        (_a4 = events == null ? void 0 : events.end) == null ? void 0 : _a4.call(events, show);\n      }\n    });\n  }, [enabled, show, element, d]);\n  if (!enabled) {\n    return [\n      show,\n      {\n        closed: void 0,\n        enter: void 0,\n        leave: void 0,\n        transition: void 0\n      }\n    ];\n  }\n  return [\n    visible,\n    {\n      closed: hasFlag(1 /* Closed */),\n      enter: hasFlag(2 /* Enter */),\n      leave: hasFlag(4 /* Leave */),\n      transition: hasFlag(2 /* Enter */) || hasFlag(4 /* Leave */)\n    }\n  ];\n}\nfunction transition(node, {\n  prepare,\n  run,\n  done,\n  inFlight\n}) {\n  let d = disposables();\n  prepareTransition(node, {\n    prepare,\n    inFlight\n  });\n  d.nextFrame(() => {\n    run();\n    d.requestAnimationFrame(() => {\n      d.add(waitForTransition(node, done));\n    });\n  });\n  return d.dispose;\n}\nfunction waitForTransition(node, done) {\n  var _a3, _b2;\n  let d = disposables();\n  if (!node)\n    return d.dispose;\n  let cancelled = false;\n  d.add(() => {\n    cancelled = true;\n  });\n  let transitions = (_b2 = (_a3 = node.getAnimations) == null ? void 0 : _a3.call(node).filter((animation) => animation instanceof CSSTransition)) != null ? _b2 : [];\n  if (transitions.length === 0) {\n    done();\n    return d.dispose;\n  }\n  Promise.allSettled(transitions.map((transition2) => transition2.finished)).then(() => {\n    if (!cancelled) {\n      done();\n    }\n  });\n  return d.dispose;\n}\nfunction prepareTransition(node, { inFlight, prepare }) {\n  if (inFlight == null ? void 0 : inFlight.current) {\n    prepare();\n    return;\n  }\n  let previous = node.style.transition;\n  node.style.transition = \"none\";\n  prepare();\n  node.offsetHeight;\n  node.style.transition = previous;\n}\n\n// src/hooks/use-tree-walker.ts\nvar import_react43 = require(\"react\");\nfunction useTreeWalker(enabled, {\n  container,\n  accept,\n  walk\n}) {\n  let acceptRef = (0, import_react43.useRef)(accept);\n  let walkRef = (0, import_react43.useRef)(walk);\n  (0, import_react43.useEffect)(() => {\n    acceptRef.current = accept;\n    walkRef.current = walk;\n  }, [accept, walk]);\n  useIsoMorphicEffect(() => {\n    if (!container)\n      return;\n    if (!enabled)\n      return;\n    let ownerDocument = getOwnerDocument(container);\n    if (!ownerDocument)\n      return;\n    let accept2 = acceptRef.current;\n    let walk2 = walkRef.current;\n    let acceptNode = Object.assign((node) => accept2(node), { acceptNode: accept2 });\n    let walker = ownerDocument.createTreeWalker(\n      container,\n      NodeFilter.SHOW_ELEMENT,\n      acceptNode,\n      // @ts-expect-error This `false` is a simple small fix for older browsers\n      false\n    );\n    while (walker.nextNode())\n      walk2(walker.currentNode);\n  }, [container, enabled, acceptRef, walkRef]);\n}\n\n// src/hooks/use-watch.ts\nvar import_react44 = require(\"react\");\nfunction useWatch(cb, dependencies) {\n  let track = (0, import_react44.useRef)([]);\n  let action = useEvent(cb);\n  (0, import_react44.useEffect)(() => {\n    let oldValues = [...track.current];\n    for (let [idx, value] of dependencies.entries()) {\n      if (track.current[idx] !== value) {\n        let returnValue = action(dependencies, oldValues);\n        track.current = dependencies;\n        return returnValue;\n      }\n    }\n  }, [action, ...dependencies]);\n}\n\n// node_modules/@floating-ui/react/dist/floating-ui.react.mjs\nvar React13 = __toESM(require(\"react\"), 1);\nvar import_react46 = require(\"react\");\n\n// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\n\n// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map((_ref) => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(\" \");\n  }\n  return navigator.userAgent;\n}\n\n// ../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\nvar min = Math.min;\nvar max = Math.max;\nvar round = Math.round;\nvar floor = Math.floor;\nvar createCoords = (v) => ({\n  x: v,\n  y: v\n});\nvar oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nvar oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n  return [\"top\", \"bottom\"].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = [\"left\", \"right\"];\n  const rl = [\"right\", \"left\"];\n  const tb = [\"top\", \"bottom\"];\n  const bt = [\"bottom\", \"top\"];\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      if (rtl)\n        return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case \"left\":\n    case \"right\":\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  if (alignment) {\n    list = list.map((side) => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n// ../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === \"y\";\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nvar computePosition = async (reference, floating, config) => {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));\n  let rects = await platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform2.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform: platform2,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = \"clippingAncestors\",\n    rootBoundary = \"viewport\",\n    elementContext = \"floating\",\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({\n    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === \"floating\" ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));\n  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\nvar flip = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform: platform2,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = \"bestFit\",\n        fallbackAxisSideDirection = \"none\",\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements2 = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows2 = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows2.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides2 = getAlignmentSides(placement, rects, rtl);\n        overflows2.push(overflow[sides2[0]], overflow[sides2[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows: overflows2\n      }];\n      if (!overflows2.every((side2) => side2 <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements2[nextIndex];\n        if (nextPlacement) {\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case \"bestFit\": {\n              var _overflowsData$map$so;\n              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n              if (placement2) {\n                resetPlacement = placement2;\n              }\n              break;\n            }\n            case \"initialPlacement\":\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform: platform2,\n    elements\n  } = state;\n  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === \"y\";\n  const mainAxisMulti = [\"left\", \"top\"].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === \"number\" ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === \"number\") {\n    crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\nvar offset = function(options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: \"offset\",\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\nvar shift = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: (_ref) => {\n            let {\n              x: x2,\n              y: y2\n            } = _ref;\n            return {\n              x: x2,\n              y: y2\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n        const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n        const min2 = mainAxisCoord + overflow[minSide];\n        const max2 = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min2, mainAxisCoord, max2);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n        const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n        const min2 = crossAxisCoord + overflow[minSide];\n        const max2 = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min2, crossAxisCoord, max2);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\nvar size = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"size\",\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform: platform2,\n        elements\n      } = state;\n      const {\n        apply = () => {\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === \"y\";\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === \"top\" || side === \"bottom\") {\n        heightSide = side;\n        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n      } else {\n        widthSide = side;\n        heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform2.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// ../../node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || \"\").toLowerCase();\n  }\n  return \"#document\";\n}\nfunction getWindow2(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow2(value).Node;\n}\nfunction isElement2(value) {\n  return value instanceof Element || value instanceof getWindow2(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle2(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle2(element);\n  return css.transform !== \"none\" || css.perspective !== \"none\" || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\"transform\", \"perspective\", \"filter\"].some((value) => (css.willChange || \"\").includes(value)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((value) => (css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === \"undefined\" || !CSS.supports)\n    return false;\n  return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nfunction getComputedStyle2(element) {\n  return getWindow2(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement2(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow2(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\n// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\nfunction getCssDimensions(element) {\n  const css = getComputedStyle2(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement2(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nvar noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow2(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement2(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow2(domElement);\n    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow2(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle2(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow2(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle2(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow2(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement2(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle2(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle2(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle2(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\"absolute\", \"fixed\"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle2(element).position === \"fixed\") {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const window2 = getWindow2(element);\n  if (!isHTMLElement(element)) {\n    return window2;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle2(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock(element) || window2;\n}\nvar getElementRects = async function(_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...await getDimensionsFn(floating)\n    }\n  };\n};\nfunction isRTL(element) {\n  return getComputedStyle2(element).direction === \"rtl\";\n}\nvar platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement: isElement2,\n  isRTL\n};\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nvar computePosition2 = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\n// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\nvar React12 = __toESM(require(\"react\"), 1);\nvar import_react45 = require(\"react\");\nvar ReactDOM = __toESM(require(\"react-dom\"), 1);\nvar index = typeof document !== \"undefined\" ? import_react45.useLayoutEffect : import_react45.useEffect;\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === \"function\" && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === \"object\") {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length)\n        return false;\n      for (i = length; i-- !== 0; ) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0; ) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0; ) {\n      const key = keys[i];\n      if (key === \"_owner\" && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\nfunction getDPR(element) {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = React12.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React12.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React12.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React12.useState(null);\n  const [_floating, _setFloating] = React12.useState(null);\n  const setReference = React12.useCallback((node) => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React12.useCallback((node) => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React12.useRef(null);\n  const floatingRef = React12.useRef(null);\n  const dataRef = React12.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform2);\n  const update = React12.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {\n      const fullData = {\n        ...data2,\n        isPositioned: true\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData((data2) => ({\n        ...data2,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React12.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl)\n      referenceRef.current = referenceEl;\n    if (floatingEl)\n      floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React12.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React12.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React12.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...getDPR(elements.floating) >= 1.5 && {\n          willChange: \"transform\"\n        }\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React12.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\nvar offset2 = (options, deps) => ({\n  ...offset(options),\n  options: [options, deps]\n});\nvar shift2 = (options, deps) => ({\n  ...shift(options),\n  options: [options, deps]\n});\nvar flip2 = (options, deps) => ({\n  ...flip(options),\n  options: [options, deps]\n});\nvar size2 = (options, deps) => ({\n  ...size(options),\n  options: [options, deps]\n});\n\n// node_modules/@floating-ui/react/dist/floating-ui.react.mjs\nvar import_react_dom5 = require(\"react-dom\");\nvar SafeReact = {\n  ...React13\n};\nvar useInsertionEffect = SafeReact.useInsertionEffect;\nvar useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());\nfunction useEffectEvent(callback) {\n  const ref = React13.useRef(() => {\n    if (true) {\n      throw new Error(\"Cannot call an event handler while rendering.\");\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return React13.useCallback(function() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\nvar ARROW_UP = \"ArrowUp\";\nvar ARROW_DOWN = \"ArrowDown\";\nvar ARROW_LEFT = \"ArrowLeft\";\nvar ARROW_RIGHT = \"ArrowRight\";\nvar index2 = typeof document !== \"undefined\" ? import_react46.useLayoutEffect : import_react46.useEffect;\nvar horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nvar verticalKeys = [ARROW_UP, ARROW_DOWN];\nvar allKeys = [...horizontalKeys, ...verticalKeys];\nvar serverHandoffComplete = false;\nvar count = 0;\nvar genId = () => (\n  // Ensure the id is unique with multiple independent versions of Floating UI\n  // on <React 18\n  \"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++\n);\nfunction useFloatingId() {\n  const [id, setId] = React13.useState(() => serverHandoffComplete ? genId() : void 0);\n  index2(() => {\n    if (id == null) {\n      setId(genId());\n    }\n  }, []);\n  React13.useEffect(() => {\n    serverHandoffComplete = true;\n  }, []);\n  return id;\n}\nvar useReactId = SafeReact.useId;\nvar useId3 = useReactId || useFloatingId;\nvar devMessageSet;\nif (true) {\n  devMessageSet = /* @__PURE__ */ new Set();\n}\nfunction warn() {\n  var _devMessageSet;\n  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n    messages[_key] = arguments[_key];\n  }\n  const message = \"Floating UI: \" + messages.join(\" \");\n  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n    var _devMessageSet2;\n    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n    console.warn(message);\n  }\n}\nfunction error() {\n  var _devMessageSet3;\n  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    messages[_key2] = arguments[_key2];\n  }\n  const message = \"Floating UI: \" + messages.join(\" \");\n  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n    var _devMessageSet4;\n    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n    console.error(message);\n  }\n}\nfunction createPubSub() {\n  const map = /* @__PURE__ */ new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...map.get(event) || [], listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l) => l !== listener)) || []);\n    }\n  };\n}\nvar FloatingNodeContext = /* @__PURE__ */ React13.createContext(null);\nvar FloatingTreeContext = /* @__PURE__ */ React13.createContext(null);\nvar useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React13.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nvar useFloatingTree = () => React13.useContext(FloatingTreeContext);\nfunction useFloatingRootContext(options) {\n  const {\n    open = false,\n    onOpenChange: onOpenChangeProp,\n    elements: elementsProp\n  } = options;\n  const floatingId = useId3();\n  const dataRef = React13.useRef({});\n  const [events] = React13.useState(() => createPubSub());\n  const nested = useFloatingParentNodeId() != null;\n  if (true) {\n    const optionDomReference = elementsProp.reference;\n    if (optionDomReference && !isElement(optionDomReference)) {\n      error(\"Cannot pass a virtual element to the `elements.reference` option,\", \"as it must be a real DOM element. Use `refs.setPositionReference()`\", \"instead.\");\n    }\n  }\n  const [positionReference, setPositionReference] = React13.useState(elementsProp.reference);\n  const onOpenChange = useEffectEvent((open2, event, reason) => {\n    dataRef.current.openEvent = open2 ? event : void 0;\n    events.emit(\"openchange\", {\n      open: open2,\n      event,\n      reason,\n      nested\n    });\n    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);\n  });\n  const refs = React13.useMemo(() => ({\n    setPositionReference\n  }), []);\n  const elements = React13.useMemo(() => ({\n    reference: positionReference || elementsProp.reference || null,\n    floating: elementsProp.floating || null,\n    domReference: elementsProp.reference\n  }), [positionReference, elementsProp.reference, elementsProp.floating]);\n  return React13.useMemo(() => ({\n    dataRef,\n    open,\n    onOpenChange,\n    elements,\n    events,\n    floatingId,\n    refs\n  }), [open, onOpenChange, elements, events, floatingId, refs]);\n}\nfunction useFloating2(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    nodeId\n  } = options;\n  const internalRootContext = useFloatingRootContext({\n    ...options,\n    elements: {\n      reference: null,\n      floating: null,\n      ...options.elements\n    }\n  });\n  const rootContext = options.rootContext || internalRootContext;\n  const computedElements = rootContext.elements;\n  const [_domReference, setDomReference] = React13.useState(null);\n  const [positionReference, _setPositionReference] = React13.useState(null);\n  const optionDomReference = computedElements == null ? void 0 : computedElements.reference;\n  const domReference = optionDomReference || _domReference;\n  const domReferenceRef = React13.useRef(null);\n  const tree = useFloatingTree();\n  index2(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = useFloating({\n    ...options,\n    elements: {\n      ...computedElements,\n      ...positionReference && {\n        reference: positionReference\n      }\n    }\n  });\n  const setPositionReference = React13.useCallback((node) => {\n    const computedPositionReference = isElement(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    _setPositionReference(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = React13.useCallback((node) => {\n    if (isElement(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !isElement(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = React13.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = React13.useMemo(() => ({\n    ...position.elements,\n    domReference\n  }), [position.elements, domReference]);\n  const context = React13.useMemo(() => ({\n    ...position,\n    ...rootContext,\n    refs,\n    elements,\n    nodeId\n  }), [position, refs, elements, nodeId, rootContext]);\n  index2(() => {\n    rootContext.dataRef.current.floatingContext = context;\n    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return React13.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\nvar ACTIVE_KEY = \"active\";\nvar SELECTED_KEY = \"selected\";\nfunction mergeProps2(userProps, propsList, elementKey) {\n  const map = /* @__PURE__ */ new Map();\n  const isItem = elementKey === \"item\";\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...elementKey === \"floating\" && {\n      tabIndex: -1\n    },\n    ...domUserProps,\n    ...propsList.map((value) => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === \"function\") {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach((_ref) => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf(\"on\") === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === \"function\") {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function() {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  const deps = propsList;\n  const getReferenceProps = React13.useCallback(\n    (userProps) => mergeProps2(userProps, propsList, \"reference\"),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps\n  );\n  const getFloatingProps = React13.useCallback(\n    (userProps) => mergeProps2(userProps, propsList, \"floating\"),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps\n  );\n  const getItemProps = React13.useCallback(\n    (userProps) => mergeProps2(userProps, propsList, \"item\"),\n    // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    propsList.map((key) => key == null ? void 0 : key.item)\n  );\n  return React13.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\nvar inner = (props) => ({\n  name: \"inner\",\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index: index3 = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = props;\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index3];\n    if (true) {\n      if (!state.placement.startsWith(\"bottom\")) {\n        warn('`placement` side must be \"bottom\" when using the `inner`', \"middleware.\");\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...await offset2(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n    };\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: \"reference\"\n    });\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        (0, import_react_dom5.flushSync)(() => onFallbackChange(true));\n      } else {\n        (0, import_react_dom5.flushSync)(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = React13.useRef(false);\n  const prevScrollTopRef = React13.useRef(null);\n  const initialOverflowRef = React13.useRef(null);\n  React13.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? \"max\" : \"min\";\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        (0, import_react_dom5.flushSync)(() => {\n          onChange((d) => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test(getUserAgent())) {\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener(\"wheel\", onWheel);\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener(\"wheel\", onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return React13.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              (0, import_react_dom5.flushSync)(() => onChange((d) => d + scrollDiff));\n            }\n          }\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\n\n// src/internal/floating.tsx\nvar React14 = __toESM(require(\"react\"), 1);\nvar import_react48 = require(\"react\");\nvar FloatingContext = (0, import_react48.createContext)({\n  styles: void 0,\n  setReference: () => {\n  },\n  setFloating: () => {\n  },\n  getReferenceProps: () => ({}),\n  getFloatingProps: () => ({}),\n  slot: {}\n});\nFloatingContext.displayName = \"FloatingContext\";\nvar PlacementContext = (0, import_react48.createContext)(null);\nPlacementContext.displayName = \"PlacementContext\";\nfunction useResolvedAnchor(anchor) {\n  return (0, import_react48.useMemo)(() => {\n    if (!anchor)\n      return null;\n    if (typeof anchor === \"string\")\n      return { to: anchor };\n    return anchor;\n  }, [anchor]);\n}\nfunction useFloatingReference() {\n  return (0, import_react48.useContext)(FloatingContext).setReference;\n}\nfunction useFloatingReferenceProps() {\n  return (0, import_react48.useContext)(FloatingContext).getReferenceProps;\n}\nfunction useFloatingPanelProps() {\n  let { getFloatingProps, slot } = (0, import_react48.useContext)(FloatingContext);\n  return (0, import_react48.useCallback)(\n    (...args) => {\n      return Object.assign({}, getFloatingProps(...args), {\n        \"data-anchor\": slot.anchor\n      });\n    },\n    [getFloatingProps, slot]\n  );\n}\nfunction useFloatingPanel(placement = null) {\n  if (placement === false)\n    placement = null;\n  if (typeof placement === \"string\")\n    placement = { to: placement };\n  let updatePlacementConfig = (0, import_react48.useContext)(PlacementContext);\n  let stablePlacement = (0, import_react48.useMemo)(\n    () => placement,\n    [\n      JSON.stringify(placement, (_, v) => {\n        var _a3;\n        return (_a3 = v == null ? void 0 : v.outerHTML) != null ? _a3 : v;\n      })\n    ]\n  );\n  useIsoMorphicEffect(() => {\n    updatePlacementConfig == null ? void 0 : updatePlacementConfig(stablePlacement != null ? stablePlacement : null);\n  }, [updatePlacementConfig, stablePlacement]);\n  let context = (0, import_react48.useContext)(FloatingContext);\n  return (0, import_react48.useMemo)(\n    () => [context.setFloating, placement ? context.styles : {}],\n    [context.setFloating, placement, context.styles]\n  );\n}\nvar MINIMUM_ITEMS_VISIBLE = 4;\nfunction FloatingProvider({\n  children,\n  enabled = true\n}) {\n  let [config, setConfig] = (0, import_react48.useState)(null);\n  let [innerOffset, setInnerOffset] = (0, import_react48.useState)(0);\n  let overflowRef = (0, import_react48.useRef)(null);\n  let [floatingEl, setFloatingElement] = (0, import_react48.useState)(null);\n  useFixScrollingPixel(floatingEl);\n  let isEnabled = enabled && config !== null && floatingEl !== null;\n  let {\n    to: placement = \"bottom\",\n    gap = 0,\n    offset: offset3 = 0,\n    padding = 0,\n    inner: inner2\n  } = useResolvedConfig(config, floatingEl);\n  let [to, align = \"center\"] = placement.split(\" \");\n  useIsoMorphicEffect(() => {\n    if (!isEnabled)\n      return;\n    setInnerOffset(0);\n  }, [isEnabled]);\n  let { refs, floatingStyles, context } = useFloating2({\n    open: isEnabled,\n    placement: to === \"selection\" ? align === \"center\" ? \"bottom\" : `bottom-${align}` : align === \"center\" ? `${to}` : `${to}-${align}`,\n    // This component will be used in combination with a `Portal`, which means the floating\n    // element will be rendered outside of the current DOM tree.\n    strategy: \"absolute\",\n    // We use the panel in a `Dialog` which is making the page inert, therefore no re-positioning is\n    // needed when scrolling changes.\n    transform: false,\n    middleware: [\n      // - The `mainAxis` is set to `gap` which defines the gap between the panel and the\n      //   trigger/reference.\n      // - The `crossAxis` is set to `offset` which nudges the panel from its original position.\n      //\n      // When we are showing the panel on top of the selected item, we don't want a gap between the\n      // reference and the panel, therefore setting the `mainAxis` to `0`.\n      offset2({\n        mainAxis: to === \"selection\" ? 0 : gap,\n        crossAxis: offset3\n      }),\n      // When the panel overflows the viewport, we will try to nudge the panel to the other side to\n      // ensure it's not clipped. We use the `padding` to define the  minimum space between the\n      // panel and the viewport.\n      shift2({ padding }),\n      // The `flip` middleware will swap the `placement` of the panel if there is not enough room.\n      // This is not compatible with the `inner` middleware (which is only enabled when `to` is set\n      // to \"selection\").\n      to !== \"selection\" && flip2({ padding }),\n      // The `inner` middleware will ensure the panel is always fully visible on screen and\n      // positioned on top of the reference and moved to the currently selected item.\n      to === \"selection\" && inner2 ? inner({\n        ...inner2,\n        padding,\n        // For overflow detection\n        overflowRef,\n        offset: innerOffset,\n        minItemsVisible: MINIMUM_ITEMS_VISIBLE,\n        referenceOverflowThreshold: padding,\n        onFallbackChange(fallback) {\n          var _a3, _b2;\n          if (!fallback)\n            return;\n          let parent = context.elements.floating;\n          if (!parent)\n            return;\n          let scrollPaddingBottom = parseFloat(getComputedStyle(parent).scrollPaddingBottom) || 0;\n          let missing = Math.min(MINIMUM_ITEMS_VISIBLE, parent.childElementCount);\n          let elementHeight = 0;\n          let elementAmountVisible = 0;\n          for (let child of (_b2 = (_a3 = context.elements.floating) == null ? void 0 : _a3.childNodes) != null ? _b2 : []) {\n            if (child instanceof HTMLElement) {\n              let childTop = child.offsetTop;\n              let childBottom = childTop + child.clientHeight + scrollPaddingBottom;\n              let parentTop = parent.scrollTop;\n              let parentBottom = parentTop + parent.clientHeight;\n              if (childTop >= parentTop && childBottom <= parentBottom) {\n                missing--;\n              } else {\n                elementAmountVisible = Math.max(\n                  0,\n                  Math.min(childBottom, parentBottom) - Math.max(childTop, parentTop)\n                );\n                elementHeight = child.clientHeight;\n                break;\n              }\n            }\n          }\n          if (missing >= 1) {\n            setInnerOffset((existingOffset) => {\n              let newInnerOffset = elementHeight * missing - // `missing` amount of `elementHeight`\n              elementAmountVisible + // The amount of the last item that is visible\n              scrollPaddingBottom;\n              if (existingOffset >= newInnerOffset) {\n                return existingOffset;\n              }\n              return newInnerOffset;\n            });\n          }\n        }\n      }) : null,\n      // The `size` middleware will ensure the panel is never bigger than the viewport minus the\n      // provided `padding` that we want.\n      size2({\n        padding,\n        apply({ availableWidth, availableHeight, elements }) {\n          Object.assign(elements.floating.style, {\n            overflow: \"auto\",\n            maxWidth: `${availableWidth}px`,\n            maxHeight: `min(var(--anchor-max-height, 100vh), ${availableHeight}px)`\n          });\n        }\n      })\n    ].filter(Boolean),\n    whileElementsMounted: autoUpdate\n  });\n  let [exposedTo = to, exposedAlign = align] = context.placement.split(\"-\");\n  if (to === \"selection\")\n    exposedTo = \"selection\";\n  let data = (0, import_react48.useMemo)(\n    () => ({\n      anchor: [exposedTo, exposedAlign].filter(Boolean).join(\" \")\n    }),\n    [exposedTo, exposedAlign]\n  );\n  let innerOffsetConfig = useInnerOffset(context, {\n    overflowRef,\n    onChange: setInnerOffset\n  });\n  let { getReferenceProps, getFloatingProps } = useInteractions([innerOffsetConfig]);\n  let setFloatingRef = useEvent((el) => {\n    setFloatingElement(el);\n    refs.setFloating(el);\n  });\n  return /* @__PURE__ */ React14.createElement(PlacementContext.Provider, { value: setConfig }, /* @__PURE__ */ React14.createElement(\n    FloatingContext.Provider,\n    {\n      value: {\n        setFloating: setFloatingRef,\n        setReference: refs.setReference,\n        styles: floatingStyles,\n        getReferenceProps,\n        getFloatingProps,\n        slot: data\n      }\n    },\n    children\n  ));\n}\nfunction useFixScrollingPixel(element) {\n  useIsoMorphicEffect(() => {\n    if (!element)\n      return;\n    let observer = new MutationObserver(() => {\n      let maxHeight = window.getComputedStyle(element).maxHeight;\n      let maxHeightFloat = parseFloat(maxHeight);\n      if (isNaN(maxHeightFloat))\n        return;\n      let maxHeightInt = parseInt(maxHeight);\n      if (isNaN(maxHeightInt))\n        return;\n      if (maxHeightFloat !== maxHeightInt) {\n        element.style.maxHeight = `${Math.ceil(maxHeightFloat)}px`;\n      }\n    });\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter: [\"style\"]\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [element]);\n}\nfunction useResolvedConfig(config, element) {\n  var _a3, _b2, _c;\n  let gap = useResolvePxValue((_a3 = config == null ? void 0 : config.gap) != null ? _a3 : \"var(--anchor-gap, 0)\", element);\n  let offset3 = useResolvePxValue((_b2 = config == null ? void 0 : config.offset) != null ? _b2 : \"var(--anchor-offset, 0)\", element);\n  let padding = useResolvePxValue((_c = config == null ? void 0 : config.padding) != null ? _c : \"var(--anchor-padding, 0)\", element);\n  return { ...config, gap, offset: offset3, padding };\n}\nfunction useResolvePxValue(input, element, defaultValue = void 0) {\n  let d = useDisposables();\n  let computeValue = useEvent((value2, element2) => {\n    if (value2 == null)\n      return [defaultValue, null];\n    if (typeof value2 === \"number\")\n      return [value2, null];\n    if (typeof value2 === \"string\") {\n      if (!element2)\n        return [defaultValue, null];\n      let result = resolveCSSVariablePxValue(value2, element2);\n      return [\n        result,\n        (setValue2) => {\n          let variables = resolveVariables(value2);\n          {\n            let history2 = variables.map(\n              (variable) => window.getComputedStyle(element2).getPropertyValue(variable)\n            );\n            d.requestAnimationFrame(function check() {\n              d.nextFrame(check);\n              let changed = false;\n              for (let [idx, variable] of variables.entries()) {\n                let value3 = window.getComputedStyle(element2).getPropertyValue(variable);\n                if (history2[idx] !== value3) {\n                  history2[idx] = value3;\n                  changed = true;\n                  break;\n                }\n              }\n              if (!changed)\n                return;\n              let newResult = resolveCSSVariablePxValue(value2, element2);\n              if (result !== newResult) {\n                setValue2(newResult);\n                result = newResult;\n              }\n            });\n          }\n          return d.dispose;\n        }\n      ];\n    }\n    return [defaultValue, null];\n  });\n  let immediateValue = (0, import_react48.useMemo)(() => computeValue(input, element)[0], [input, element]);\n  let [value = immediateValue, setValue] = (0, import_react48.useState)();\n  useIsoMorphicEffect(() => {\n    let [value2, watcher] = computeValue(input, element);\n    setValue(value2);\n    if (!watcher)\n      return;\n    return watcher(setValue);\n  }, [input, element]);\n  return value;\n}\nfunction resolveVariables(value) {\n  let matches = /var\\((.*)\\)/.exec(value);\n  if (matches) {\n    let idx = matches[1].indexOf(\",\");\n    if (idx === -1) {\n      return [matches[1]];\n    }\n    let variable = matches[1].slice(0, idx).trim();\n    let fallback = matches[1].slice(idx + 1).trim();\n    if (fallback) {\n      return [variable, ...resolveVariables(fallback)];\n    }\n    return [variable];\n  }\n  return [];\n}\nfunction resolveCSSVariablePxValue(input, element) {\n  let tmpEl = document.createElement(\"div\");\n  element.appendChild(tmpEl);\n  tmpEl.style.setProperty(\"margin-top\", \"0px\", \"important\");\n  tmpEl.style.setProperty(\"margin-top\", input, \"important\");\n  let pxValue = parseFloat(window.getComputedStyle(tmpEl).marginTop) || 0;\n  element.removeChild(tmpEl);\n  return pxValue;\n}\n\n// src/internal/frozen.tsx\nvar import_react49 = __toESM(require(\"react\"), 1);\nfunction Frozen({ children, freeze }) {\n  let contents = useFrozenData(freeze, children);\n  return /* @__PURE__ */ import_react49.default.createElement(import_react49.default.Fragment, null, contents);\n}\nfunction useFrozenData(freeze, data) {\n  let [frozenValue, setFrozenValue] = (0, import_react49.useState)(data);\n  if (!freeze && frozenValue !== data) {\n    setFrozenValue(data);\n  }\n  return freeze ? frozenValue : data;\n}\n\n// src/internal/open-closed.tsx\nvar import_react50 = __toESM(require(\"react\"), 1);\nvar Context = (0, import_react50.createContext)(null);\nContext.displayName = \"OpenClosedContext\";\nfunction useOpenClosed() {\n  return (0, import_react50.useContext)(Context);\n}\nfunction OpenClosedProvider({ value, children }) {\n  return /* @__PURE__ */ import_react50.default.createElement(Context.Provider, { value }, children);\n}\nfunction ResetOpenClosedProvider({ children }) {\n  return /* @__PURE__ */ import_react50.default.createElement(Context.Provider, { value: null }, children);\n}\n\n// src/react-glue.tsx\nvar import_with_selector = require(\"use-sync-external-store/with-selector\");\n\n// src/machine.ts\nvar _state, _eventSubscribers, _subscribers;\nvar Machine = class {\n  constructor(initialState) {\n    __privateAdd(this, _state, {});\n    __privateAdd(this, _eventSubscribers, new DefaultMap(\n      () => /* @__PURE__ */ new Set()\n    ));\n    __privateAdd(this, _subscribers, /* @__PURE__ */ new Set());\n    __privateSet(this, _state, initialState);\n  }\n  get state() {\n    return __privateGet(this, _state);\n  }\n  subscribe(selector, callback) {\n    let subscriber = {\n      selector,\n      callback,\n      current: selector(__privateGet(this, _state))\n    };\n    __privateGet(this, _subscribers).add(subscriber);\n    return () => {\n      __privateGet(this, _subscribers).delete(subscriber);\n    };\n  }\n  on(type, callback) {\n    __privateGet(this, _eventSubscribers).get(type).add(callback);\n    return () => {\n      __privateGet(this, _eventSubscribers).get(type).delete(callback);\n    };\n  }\n  send(event) {\n    __privateSet(this, _state, this.reduce(__privateGet(this, _state), event));\n    for (let subscriber of __privateGet(this, _subscribers)) {\n      let slice = subscriber.selector(__privateGet(this, _state));\n      if (shallowEqual(subscriber.current, slice))\n        continue;\n      subscriber.current = slice;\n      subscriber.callback(slice);\n    }\n    for (let callback of __privateGet(this, _eventSubscribers).get(event.type)) {\n      callback(__privateGet(this, _state), event);\n    }\n  }\n};\n_state = new WeakMap();\n_eventSubscribers = new WeakMap();\n_subscribers = new WeakMap();\nfunction shallowEqual(a, b) {\n  if (Object.is(a, b))\n    return true;\n  if (typeof a !== \"object\" || a === null || typeof b !== \"object\" || b === null)\n    return false;\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length)\n      return false;\n    return compareEntries(a[Symbol.iterator](), b[Symbol.iterator]());\n  }\n  if (a instanceof Map && b instanceof Map || a instanceof Set && b instanceof Set) {\n    if (a.size !== b.size)\n      return false;\n    return compareEntries(a.entries(), b.entries());\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return compareEntries(\n      Object.entries(a)[Symbol.iterator](),\n      Object.entries(b)[Symbol.iterator]()\n    );\n  }\n  return false;\n}\nfunction compareEntries(a, b) {\n  do {\n    let aResult = a.next();\n    let bResult = b.next();\n    if (aResult.done && bResult.done)\n      return true;\n    if (aResult.done || bResult.done)\n      return false;\n    if (!Object.is(aResult.value, bResult.value))\n      return false;\n  } while (true);\n}\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== \"[object Object]\") {\n    return false;\n  }\n  let prototype = Object.getPrototypeOf(value);\n  return prototype === null || Object.getPrototypeOf(prototype) === null;\n}\nfunction batch(setup) {\n  let [callback, handle] = setup();\n  let d = disposables();\n  return (...args) => {\n    callback(...args);\n    d.dispose();\n    d.microTask(handle);\n  };\n}\n\n// src/react-glue.tsx\nfunction useSlice(machine, selector, compare = shallowEqual) {\n  return (0, import_with_selector.useSyncExternalStoreWithSelector)(\n    useEvent((onStoreChange) => machine.subscribe(identity, onStoreChange)),\n    useEvent(() => machine.state),\n    useEvent(() => machine.state),\n    useEvent(selector),\n    compare\n  );\n}\nfunction identity(value) {\n  return value;\n}\n\n// src/utils/document-ready.ts\nfunction onDocumentReady(cb) {\n  function check() {\n    if (document.readyState === \"loading\")\n      return;\n    cb();\n    document.removeEventListener(\"DOMContentLoaded\", check);\n  }\n  if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", check);\n    check();\n  }\n}\n\n// src/utils/active-element-history.ts\nvar history = [];\nonDocumentReady(() => {\n  function handle(e) {\n    if (!(e.target instanceof HTMLElement))\n      return;\n    if (e.target === document.body)\n      return;\n    if (history[0] === e.target)\n      return;\n    let focusableElement = e.target;\n    focusableElement = focusableElement.closest(focusableSelector);\n    history.unshift(focusableElement != null ? focusableElement : e.target);\n    history = history.filter((x) => x != null && x.isConnected);\n    history.splice(10);\n  }\n  window.addEventListener(\"click\", handle, { capture: true });\n  window.addEventListener(\"mousedown\", handle, { capture: true });\n  window.addEventListener(\"focus\", handle, { capture: true });\n  document.body.addEventListener(\"click\", handle, { capture: true });\n  document.body.addEventListener(\"mousedown\", handle, { capture: true });\n  document.body.addEventListener(\"focus\", handle, { capture: true });\n});\n\n// src/utils/calculate-active-index.ts\nfunction assertNever(x) {\n  throw new Error(\"Unexpected object: \" + x);\n}\nfunction calculateActiveIndex(action, resolvers) {\n  let items = resolvers.resolveItems();\n  if (items.length <= 0)\n    return null;\n  let currentActiveIndex = resolvers.resolveActiveIndex();\n  let activeIndex = currentActiveIndex != null ? currentActiveIndex : -1;\n  switch (action.focus) {\n    case 0 /* First */: {\n      for (let i = 0; i < items.length; ++i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i;\n        }\n      }\n      return currentActiveIndex;\n    }\n    case 1 /* Previous */: {\n      if (activeIndex === -1)\n        activeIndex = items.length;\n      for (let i = activeIndex - 1; i >= 0; --i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i;\n        }\n      }\n      return currentActiveIndex;\n    }\n    case 2 /* Next */: {\n      for (let i = activeIndex + 1; i < items.length; ++i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i;\n        }\n      }\n      return currentActiveIndex;\n    }\n    case 3 /* Last */: {\n      for (let i = items.length - 1; i >= 0; --i) {\n        if (!resolvers.resolveDisabled(items[i], i, items)) {\n          return i;\n        }\n      }\n      return currentActiveIndex;\n    }\n    case 4 /* Specific */: {\n      for (let i = 0; i < items.length; ++i) {\n        if (resolvers.resolveId(items[i], i, items) === action.id) {\n          return i;\n        }\n      }\n      return currentActiveIndex;\n    }\n    case 5 /* Nothing */:\n      return null;\n    default:\n      assertNever(action);\n  }\n}\n\n// src/components/portal/portal.tsx\nvar import_react53 = __toESM(require(\"react\"), 1);\nvar import_react_dom6 = require(\"react-dom\");\n\n// src/hooks/use-on-unmount.ts\nvar import_react51 = require(\"react\");\nfunction useOnUnmount(cb) {\n  let stableCb = useEvent(cb);\n  let trulyUnmounted = (0, import_react51.useRef)(false);\n  (0, import_react51.useEffect)(() => {\n    trulyUnmounted.current = false;\n    return () => {\n      trulyUnmounted.current = true;\n      microTask(() => {\n        if (!trulyUnmounted.current)\n          return;\n        stableCb();\n      });\n    };\n  }, [stableCb]);\n}\n\n// src/hooks/use-server-handoff-complete.ts\nvar React17 = __toESM(require(\"react\"), 1);\nfunction useIsHydratingInReact18() {\n  let isServer = typeof document === \"undefined\";\n  if (!(\"useSyncExternalStore\" in React17)) {\n    return false;\n  }\n  const useSyncExternalStore2 = ((r) => r.useSyncExternalStore)(React17);\n  let result = useSyncExternalStore2(\n    () => () => {\n    },\n    () => false,\n    () => isServer ? false : true\n  );\n  return result;\n}\nfunction useServerHandoffComplete() {\n  let isHydrating = useIsHydratingInReact18();\n  let [complete, setComplete] = React17.useState(env.isHandoffComplete);\n  if (complete && env.isHandoffComplete === false) {\n    setComplete(false);\n  }\n  React17.useEffect(() => {\n    if (complete === true)\n      return;\n    setComplete(true);\n  }, [complete]);\n  React17.useEffect(() => env.handoff(), []);\n  if (isHydrating) {\n    return false;\n  }\n  return complete;\n}\n\n// src/internal/portal-force-root.tsx\nvar import_react52 = __toESM(require(\"react\"), 1);\nvar ForcePortalRootContext = (0, import_react52.createContext)(false);\nfunction usePortalRoot() {\n  return (0, import_react52.useContext)(ForcePortalRootContext);\n}\nfunction ForcePortalRoot(props) {\n  return /* @__PURE__ */ import_react52.default.createElement(ForcePortalRootContext.Provider, { value: props.force }, props.children);\n}\n\n// src/components/portal/portal.tsx\nfunction usePortalTarget(ownerDocument) {\n  let forceInRoot = usePortalRoot();\n  let groupTarget = (0, import_react53.useContext)(PortalGroupContext);\n  let [target, setTarget] = (0, import_react53.useState)(() => {\n    var _a3;\n    if (!forceInRoot && groupTarget !== null)\n      return (_a3 = groupTarget.current) != null ? _a3 : null;\n    if (env.isServer)\n      return null;\n    let existingRoot = ownerDocument == null ? void 0 : ownerDocument.getElementById(\"headlessui-portal-root\");\n    if (existingRoot)\n      return existingRoot;\n    if (ownerDocument === null)\n      return null;\n    let root = ownerDocument.createElement(\"div\");\n    root.setAttribute(\"id\", \"headlessui-portal-root\");\n    return ownerDocument.body.appendChild(root);\n  });\n  (0, import_react53.useEffect)(() => {\n    if (target === null)\n      return;\n    if (!(ownerDocument == null ? void 0 : ownerDocument.body.contains(target))) {\n      ownerDocument == null ? void 0 : ownerDocument.body.appendChild(target);\n    }\n  }, [target, ownerDocument]);\n  (0, import_react53.useEffect)(() => {\n    if (forceInRoot)\n      return;\n    if (groupTarget === null)\n      return;\n    setTarget(groupTarget.current);\n  }, [groupTarget, setTarget, forceInRoot]);\n  return target;\n}\nvar DEFAULT_PORTAL_TAG = import_react53.Fragment;\nvar InternalPortalFn = forwardRefWithAs(function InternalPortalFn2(props, ref) {\n  let { ownerDocument: incomingOwnerDocument = null, ...theirProps } = props;\n  let internalPortalRootRef = (0, import_react53.useRef)(null);\n  let portalRef = useSyncRefs(\n    optionalRef((ref2) => {\n      internalPortalRootRef.current = ref2;\n    }),\n    ref\n  );\n  let defaultOwnerDocument = useOwnerDocument(internalPortalRootRef);\n  let ownerDocument = incomingOwnerDocument != null ? incomingOwnerDocument : defaultOwnerDocument;\n  let target = usePortalTarget(ownerDocument);\n  let [element] = (0, import_react53.useState)(\n    () => {\n      var _a3;\n      return env.isServer ? null : (_a3 = ownerDocument == null ? void 0 : ownerDocument.createElement(\"div\")) != null ? _a3 : null;\n    }\n  );\n  let parent = (0, import_react53.useContext)(PortalParentContext);\n  let ready = useServerHandoffComplete();\n  useIsoMorphicEffect(() => {\n    if (!target || !element)\n      return;\n    if (!target.contains(element)) {\n      element.setAttribute(\"data-headlessui-portal\", \"\");\n      target.appendChild(element);\n    }\n  }, [target, element]);\n  useIsoMorphicEffect(() => {\n    if (!element)\n      return;\n    if (!parent)\n      return;\n    return parent.register(element);\n  }, [parent, element]);\n  useOnUnmount(() => {\n    var _a3;\n    if (!target || !element)\n      return;\n    if (element instanceof Node && target.contains(element)) {\n      target.removeChild(element);\n    }\n    if (target.childNodes.length <= 0) {\n      (_a3 = target.parentElement) == null ? void 0 : _a3.removeChild(target);\n    }\n  });\n  let render2 = useRender();\n  if (!ready)\n    return null;\n  let ourProps = { ref: portalRef };\n  return !target || !element ? null : (0, import_react_dom6.createPortal)(\n    render2({\n      ourProps,\n      theirProps,\n      slot: {},\n      defaultTag: DEFAULT_PORTAL_TAG,\n      name: \"Portal\"\n    }),\n    element\n  );\n});\nfunction PortalFn(props, ref) {\n  let portalRef = useSyncRefs(ref);\n  let { enabled = true, ownerDocument, ...theirProps } = props;\n  let render2 = useRender();\n  return enabled ? /* @__PURE__ */ import_react53.default.createElement(InternalPortalFn, { ...theirProps, ownerDocument, ref: portalRef }) : render2({\n    ourProps: { ref: portalRef },\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_PORTAL_TAG,\n    name: \"Portal\"\n  });\n}\nvar DEFAULT_GROUP_TAG = import_react53.Fragment;\nvar PortalGroupContext = (0, import_react53.createContext)(null);\nfunction GroupFn(props, ref) {\n  let { target, ...theirProps } = props;\n  let groupRef = useSyncRefs(ref);\n  let ourProps = { ref: groupRef };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react53.default.createElement(PortalGroupContext.Provider, { value: target }, render2({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_GROUP_TAG,\n    name: \"Popover.Group\"\n  }));\n}\nvar PortalParentContext = (0, import_react53.createContext)(null);\nfunction useNestedPortals() {\n  let parent = (0, import_react53.useContext)(PortalParentContext);\n  let portals = (0, import_react53.useRef)([]);\n  let register = useEvent((portal) => {\n    portals.current.push(portal);\n    if (parent)\n      parent.register(portal);\n    return () => unregister(portal);\n  });\n  let unregister = useEvent((portal) => {\n    let idx = portals.current.indexOf(portal);\n    if (idx !== -1)\n      portals.current.splice(idx, 1);\n    if (parent)\n      parent.unregister(portal);\n  });\n  let api = (0, import_react53.useMemo)(\n    () => ({ register, unregister, portals }),\n    [register, unregister, portals]\n  );\n  return [\n    portals,\n    (0, import_react53.useMemo)(() => {\n      return function PortalWrapper({ children }) {\n        return /* @__PURE__ */ import_react53.default.createElement(PortalParentContext.Provider, { value: api }, children);\n      };\n    }, [api])\n  ];\n}\nvar PortalRoot = forwardRefWithAs(PortalFn);\nvar PortalGroup = forwardRefWithAs(GroupFn);\nvar Portal = Object.assign(PortalRoot, {\n  /** @deprecated use `<PortalGroup>` instead of `<Portal.Group>` */\n  Group: PortalGroup\n});\n\n// src/components/combobox/combobox-machine.ts\nfunction adjustOrderedState(state, adjustment = (i) => i) {\n  let currentActiveOption = state.activeOptionIndex !== null ? state.options[state.activeOptionIndex] : null;\n  let list = adjustment(state.options.slice());\n  let sortedOptions = list.length > 0 && list[0].dataRef.current.order !== null ? (\n    // Prefer sorting based on the `order`\n    list.sort((a, z) => a.dataRef.current.order - z.dataRef.current.order)\n  ) : (\n    // Fallback to much slower DOM order\n    sortByDomNode(list, (option) => option.dataRef.current.domRef.current)\n  );\n  let adjustedActiveOptionIndex = currentActiveOption ? sortedOptions.indexOf(currentActiveOption) : null;\n  if (adjustedActiveOptionIndex === -1) {\n    adjustedActiveOptionIndex = null;\n  }\n  return {\n    options: sortedOptions,\n    activeOptionIndex: adjustedActiveOptionIndex\n  };\n}\nvar reducers = {\n  [1 /* CloseCombobox */](state) {\n    var _a3;\n    if ((_a3 = state.dataRef.current) == null ? void 0 : _a3.disabled)\n      return state;\n    if (state.comboboxState === 1 /* Closed */)\n      return state;\n    return {\n      ...state,\n      activeOptionIndex: null,\n      comboboxState: 1 /* Closed */,\n      isTyping: false,\n      // Clear the last known activation trigger\n      // This is because if a user interacts with the combobox using a mouse\n      // resulting in it closing we might incorrectly handle the next interaction\n      // for example, not scrolling to the active option in a virtual list\n      activationTrigger: 2 /* Other */,\n      __demoMode: false\n    };\n  },\n  [0 /* OpenCombobox */](state) {\n    var _a3, _b2;\n    if ((_a3 = state.dataRef.current) == null ? void 0 : _a3.disabled)\n      return state;\n    if (state.comboboxState === 0 /* Open */)\n      return state;\n    if ((_b2 = state.dataRef.current) == null ? void 0 : _b2.value) {\n      let idx = state.dataRef.current.calculateIndex(state.dataRef.current.value);\n      if (idx !== -1) {\n        return {\n          ...state,\n          activeOptionIndex: idx,\n          comboboxState: 0 /* Open */,\n          __demoMode: false\n        };\n      }\n    }\n    return { ...state, comboboxState: 0 /* Open */, __demoMode: false };\n  },\n  [3 /* SetTyping */](state, action) {\n    if (state.isTyping === action.isTyping)\n      return state;\n    return { ...state, isTyping: action.isTyping };\n  },\n  [2 /* GoToOption */](state, action) {\n    var _a3, _b2, _c, _d;\n    if ((_a3 = state.dataRef.current) == null ? void 0 : _a3.disabled)\n      return state;\n    if (state.optionsElement && !((_b2 = state.dataRef.current) == null ? void 0 : _b2.optionsPropsRef.current.static) && state.comboboxState === 1 /* Closed */) {\n      return state;\n    }\n    if (state.virtual) {\n      let { options, disabled } = state.virtual;\n      let activeOptionIndex2 = action.focus === 4 /* Specific */ ? action.idx : calculateActiveIndex(action, {\n        resolveItems: () => options,\n        resolveActiveIndex: () => {\n          var _a4, _b3;\n          return (_b3 = (_a4 = state.activeOptionIndex) != null ? _a4 : options.findIndex((option) => !disabled(option))) != null ? _b3 : null;\n        },\n        resolveDisabled: disabled,\n        resolveId() {\n          throw new Error(\"Function not implemented.\");\n        }\n      });\n      let activationTrigger2 = (_c = action.trigger) != null ? _c : 2 /* Other */;\n      if (state.activeOptionIndex === activeOptionIndex2 && state.activationTrigger === activationTrigger2) {\n        return state;\n      }\n      return {\n        ...state,\n        activeOptionIndex: activeOptionIndex2,\n        activationTrigger: activationTrigger2,\n        isTyping: false,\n        __demoMode: false\n      };\n    }\n    let adjustedState = adjustOrderedState(state);\n    if (adjustedState.activeOptionIndex === null) {\n      let localActiveOptionIndex = adjustedState.options.findIndex(\n        (option) => !option.dataRef.current.disabled\n      );\n      if (localActiveOptionIndex !== -1) {\n        adjustedState.activeOptionIndex = localActiveOptionIndex;\n      }\n    }\n    let activeOptionIndex = action.focus === 4 /* Specific */ ? action.idx : calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.options,\n      resolveActiveIndex: () => adjustedState.activeOptionIndex,\n      resolveId: (item) => item.id,\n      resolveDisabled: (item) => item.dataRef.current.disabled\n    });\n    let activationTrigger = (_d = action.trigger) != null ? _d : 2 /* Other */;\n    if (state.activeOptionIndex === activeOptionIndex && state.activationTrigger === activationTrigger) {\n      return state;\n    }\n    return {\n      ...state,\n      ...adjustedState,\n      isTyping: false,\n      activeOptionIndex,\n      activationTrigger,\n      __demoMode: false\n    };\n  },\n  [4 /* RegisterOption */]: (state, action) => {\n    var _a3, _b2, _c, _d;\n    if ((_a3 = state.dataRef.current) == null ? void 0 : _a3.virtual) {\n      return {\n        ...state,\n        options: [...state.options, action.payload]\n      };\n    }\n    let option = action.payload;\n    let adjustedState = adjustOrderedState(state, (options) => {\n      options.push(option);\n      return options;\n    });\n    if (state.activeOptionIndex === null) {\n      if ((_c = (_b2 = state.dataRef.current).isSelected) == null ? void 0 : _c.call(_b2, action.payload.dataRef.current.value)) {\n        adjustedState.activeOptionIndex = adjustedState.options.indexOf(option);\n      }\n    }\n    let nextState = {\n      ...state,\n      ...adjustedState,\n      activationTrigger: 2 /* Other */\n    };\n    if (((_d = state.dataRef.current) == null ? void 0 : _d.__demoMode) && state.dataRef.current.value === void 0) {\n      nextState.activeOptionIndex = 0;\n    }\n    return nextState;\n  },\n  [5 /* UnregisterOption */]: (state, action) => {\n    var _a3;\n    if ((_a3 = state.dataRef.current) == null ? void 0 : _a3.virtual) {\n      return {\n        ...state,\n        options: state.options.filter((option) => option.id !== action.id)\n      };\n    }\n    let adjustedState = adjustOrderedState(state, (options) => {\n      let idx = options.findIndex((option) => option.id === action.id);\n      if (idx !== -1)\n        options.splice(idx, 1);\n      return options;\n    });\n    return {\n      ...state,\n      ...adjustedState,\n      activationTrigger: 2 /* Other */\n    };\n  },\n  [6 /* DefaultToFirstOption */]: (state, action) => {\n    if (state.defaultToFirstOption === action.value)\n      return state;\n    return {\n      ...state,\n      defaultToFirstOption: action.value\n    };\n  },\n  [7 /* SetActivationTrigger */]: (state, action) => {\n    if (state.activationTrigger === action.trigger) {\n      return state;\n    }\n    return {\n      ...state,\n      activationTrigger: action.trigger\n    };\n  },\n  [8 /* UpdateVirtualConfiguration */]: (state, action) => {\n    var _a3, _b2;\n    if (state.virtual === null) {\n      return {\n        ...state,\n        virtual: { options: action.options, disabled: (_a3 = action.disabled) != null ? _a3 : () => false }\n      };\n    }\n    if (state.virtual.options === action.options && state.virtual.disabled === action.disabled) {\n      return state;\n    }\n    let adjustedActiveOptionIndex = state.activeOptionIndex;\n    if (state.activeOptionIndex !== null) {\n      let idx = action.options.indexOf(state.virtual.options[state.activeOptionIndex]);\n      if (idx !== -1) {\n        adjustedActiveOptionIndex = idx;\n      } else {\n        adjustedActiveOptionIndex = null;\n      }\n    }\n    return {\n      ...state,\n      activeOptionIndex: adjustedActiveOptionIndex,\n      virtual: { options: action.options, disabled: (_b2 = action.disabled) != null ? _b2 : () => false }\n    };\n  },\n  [9 /* SetInputElement */]: (state, action) => {\n    if (state.inputElement === action.element)\n      return state;\n    return { ...state, inputElement: action.element };\n  },\n  [10 /* SetButtonElement */]: (state, action) => {\n    if (state.buttonElement === action.element)\n      return state;\n    return { ...state, buttonElement: action.element };\n  },\n  [11 /* SetOptionsElement */]: (state, action) => {\n    if (state.optionsElement === action.element)\n      return state;\n    return { ...state, optionsElement: action.element };\n  }\n};\nvar ComboboxMachine = class extends Machine {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"actions\", {\n      onChange: (newValue) => {\n        let { onChange, compare, mode, value } = this.state.dataRef.current;\n        return match(mode, {\n          [0 /* Single */]: () => {\n            return onChange == null ? void 0 : onChange(newValue);\n          },\n          [1 /* Multi */]: () => {\n            let copy = value.slice();\n            let idx = copy.findIndex((item) => compare(item, newValue));\n            if (idx === -1) {\n              copy.push(newValue);\n            } else {\n              copy.splice(idx, 1);\n            }\n            return onChange == null ? void 0 : onChange(copy);\n          }\n        });\n      },\n      registerOption: (id, dataRef) => {\n        this.send({ type: 4 /* RegisterOption */, payload: { id, dataRef } });\n        return () => {\n          if (this.state.activeOptionIndex === this.state.dataRef.current.calculateIndex(dataRef.current.value)) {\n            this.send({ type: 6 /* DefaultToFirstOption */, value: true });\n          }\n          this.send({ type: 5 /* UnregisterOption */, id });\n        };\n      },\n      goToOption: (focus, trigger) => {\n        this.send({ type: 6 /* DefaultToFirstOption */, value: false });\n        return this.send({ type: 2 /* GoToOption */, ...focus, trigger });\n      },\n      setIsTyping: (isTyping) => {\n        this.send({ type: 3 /* SetTyping */, isTyping });\n      },\n      closeCombobox: () => {\n        var _a3, _b2;\n        this.send({ type: 1 /* CloseCombobox */ });\n        this.send({ type: 6 /* DefaultToFirstOption */, value: false });\n        (_b2 = (_a3 = this.state.dataRef.current).onClose) == null ? void 0 : _b2.call(_a3);\n      },\n      openCombobox: () => {\n        this.send({ type: 0 /* OpenCombobox */ });\n        this.send({ type: 6 /* DefaultToFirstOption */, value: true });\n      },\n      setActivationTrigger: (trigger) => {\n        this.send({ type: 7 /* SetActivationTrigger */, trigger });\n      },\n      selectActiveOption: () => {\n        let activeOptionIndex = this.selectors.activeOptionIndex(this.state);\n        if (activeOptionIndex === null)\n          return;\n        this.actions.setIsTyping(false);\n        if (this.state.virtual) {\n          this.actions.onChange(this.state.virtual.options[activeOptionIndex]);\n        } else {\n          let { dataRef } = this.state.options[activeOptionIndex];\n          this.actions.onChange(dataRef.current.value);\n        }\n        this.actions.goToOption({ focus: 4 /* Specific */, idx: activeOptionIndex });\n      },\n      setInputElement: (element) => {\n        this.send({ type: 9 /* SetInputElement */, element });\n      },\n      setButtonElement: (element) => {\n        this.send({ type: 10 /* SetButtonElement */, element });\n      },\n      setOptionsElement: (element) => {\n        this.send({ type: 11 /* SetOptionsElement */, element });\n      }\n    });\n    __publicField(this, \"selectors\", {\n      activeDescendantId: (state) => {\n        var _a3, _b2;\n        let activeOptionIndex = this.selectors.activeOptionIndex(state);\n        if (activeOptionIndex === null) {\n          return void 0;\n        }\n        if (!state.virtual) {\n          return (_a3 = state.options[activeOptionIndex]) == null ? void 0 : _a3.id;\n        }\n        return (_b2 = state.options.find((option) => {\n          return !option.dataRef.current.disabled && state.dataRef.current.compare(\n            option.dataRef.current.value,\n            state.virtual.options[activeOptionIndex]\n          );\n        })) == null ? void 0 : _b2.id;\n      },\n      activeOptionIndex: (state) => {\n        if (state.defaultToFirstOption && state.activeOptionIndex === null && (state.virtual ? state.virtual.options.length > 0 : state.options.length > 0)) {\n          if (state.virtual) {\n            let { options, disabled } = state.virtual;\n            let activeOptionIndex2 = options.findIndex((option) => {\n              var _a3;\n              return !((_a3 = disabled == null ? void 0 : disabled(option)) != null ? _a3 : false);\n            });\n            if (activeOptionIndex2 !== -1) {\n              return activeOptionIndex2;\n            }\n          }\n          let activeOptionIndex = state.options.findIndex((option) => {\n            return !option.dataRef.current.disabled;\n          });\n          if (activeOptionIndex !== -1) {\n            return activeOptionIndex;\n          }\n        }\n        return state.activeOptionIndex;\n      },\n      activeOption: (state) => {\n        var _a3, _b2;\n        let activeOptionIndex = this.selectors.activeOptionIndex(state);\n        return activeOptionIndex === null ? null : state.virtual ? state.virtual.options[activeOptionIndex != null ? activeOptionIndex : 0] : (_b2 = (_a3 = state.options[activeOptionIndex]) == null ? void 0 : _a3.dataRef.current.value) != null ? _b2 : null;\n      },\n      isActive: (state, value, id) => {\n        var _a3;\n        let activeOptionIndex = this.selectors.activeOptionIndex(state);\n        if (activeOptionIndex === null)\n          return false;\n        if (state.virtual) {\n          return activeOptionIndex === state.dataRef.current.calculateIndex(value);\n        }\n        return ((_a3 = state.options[activeOptionIndex]) == null ? void 0 : _a3.id) === id;\n      },\n      shouldScrollIntoView: (state, value, id) => {\n        if (state.virtual)\n          return false;\n        if (state.__demoMode)\n          return false;\n        if (state.comboboxState !== 0 /* Open */)\n          return false;\n        if (state.activationTrigger === 0 /* Pointer */)\n          return false;\n        let active = this.selectors.isActive(state, value, id);\n        if (!active)\n          return false;\n        return true;\n      }\n    });\n  }\n  static new({\n    virtual = null,\n    __demoMode = false\n  } = {}) {\n    var _a3;\n    return new ComboboxMachine({\n      // @ts-expect-error TODO: Re-structure such that we don't need to ignore this\n      dataRef: { current: {} },\n      comboboxState: __demoMode ? 0 /* Open */ : 1 /* Closed */,\n      isTyping: false,\n      options: [],\n      // @ts-expect-error TODO: Ensure we use the correct type\n      virtual: virtual ? { options: virtual.options, disabled: (_a3 = virtual.disabled) != null ? _a3 : () => false } : null,\n      activeOptionIndex: null,\n      activationTrigger: 2 /* Other */,\n      inputElement: null,\n      buttonElement: null,\n      optionsElement: null,\n      __demoMode\n    });\n  }\n  reduce(state, action) {\n    return match(action.type, reducers, state, action);\n  }\n};\n\n// src/components/combobox/combobox-machine-glue.tsx\nvar import_react54 = require(\"react\");\nvar ComboboxContext = (0, import_react54.createContext)(null);\nfunction useComboboxMachineContext(component) {\n  let context = (0, import_react54.useContext)(ComboboxContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Combobox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useComboboxMachine);\n    throw err;\n  }\n  return context;\n}\nfunction useComboboxMachine({\n  virtual = null,\n  __demoMode = false\n} = {}) {\n  return (0, import_react54.useMemo)(() => ComboboxMachine.new({ virtual, __demoMode }), []);\n}\n\n// src/components/combobox/combobox.tsx\nvar ComboboxDataContext = (0, import_react55.createContext)(null);\nComboboxDataContext.displayName = \"ComboboxDataContext\";\nfunction useData(component) {\n  let context = (0, import_react55.useContext)(ComboboxDataContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Combobox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useData);\n    throw err;\n  }\n  return context;\n}\nvar VirtualContext = (0, import_react55.createContext)(null);\nfunction VirtualProvider(props) {\n  let machine = useComboboxMachineContext(\"VirtualProvider\");\n  let data = useData(\"VirtualProvider\");\n  let { options } = data.virtual;\n  let optionsElement = useSlice(machine, (state) => state.optionsElement);\n  let [paddingStart, paddingEnd] = (0, import_react55.useMemo)(() => {\n    let el = optionsElement;\n    if (!el)\n      return [0, 0];\n    let styles = window.getComputedStyle(el);\n    return [\n      parseFloat(styles.paddingBlockStart || styles.paddingTop),\n      parseFloat(styles.paddingBlockEnd || styles.paddingBottom)\n    ];\n  }, [optionsElement]);\n  let virtualizer = useVirtualizer({\n    enabled: options.length !== 0,\n    scrollPaddingStart: paddingStart,\n    scrollPaddingEnd: paddingEnd,\n    count: options.length,\n    estimateSize() {\n      return 40;\n    },\n    getScrollElement() {\n      return machine.state.optionsElement;\n    },\n    overscan: 12\n  });\n  let [baseKey, setBaseKey] = (0, import_react55.useState)(0);\n  useIsoMorphicEffect(() => {\n    setBaseKey((v) => v + 1);\n  }, [options]);\n  let items = virtualizer.getVirtualItems();\n  let isPointerActivationTrigger = useSlice(machine, (state) => {\n    return state.activationTrigger === 0 /* Pointer */;\n  });\n  let activeOptionIndex = useSlice(machine, machine.selectors.activeOptionIndex);\n  if (items.length === 0) {\n    return null;\n  }\n  return /* @__PURE__ */ import_react55.default.createElement(VirtualContext.Provider, { value: virtualizer }, /* @__PURE__ */ import_react55.default.createElement(\n    \"div\",\n    {\n      style: {\n        position: \"relative\",\n        width: \"100%\",\n        height: `${virtualizer.getTotalSize()}px`\n      },\n      ref: (el) => {\n        if (!el)\n          return;\n        if (isPointerActivationTrigger)\n          return;\n        if (activeOptionIndex !== null && options.length > activeOptionIndex) {\n          virtualizer.scrollToIndex(activeOptionIndex);\n        }\n      }\n    },\n    items.map((item) => {\n      var _a3;\n      return /* @__PURE__ */ import_react55.default.createElement(import_react55.Fragment, { key: item.key }, import_react55.default.cloneElement(\n        (_a3 = props.children) == null ? void 0 : _a3.call(props, {\n          ...props.slot,\n          option: options[item.index]\n        }),\n        {\n          key: `${baseKey}-${item.key}`,\n          \"data-index\": item.index,\n          \"aria-setsize\": options.length,\n          \"aria-posinset\": item.index + 1,\n          style: {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            transform: `translateY(${item.start}px)`,\n            overflowAnchor: \"none\"\n          }\n        }\n      ));\n    })\n  ));\n}\nvar DEFAULT_COMBOBOX_TAG = import_react55.Fragment;\nfunction ComboboxFn(props, ref) {\n  let providedDisabled = useDisabled();\n  let {\n    value: controlledValue,\n    defaultValue: _defaultValue,\n    onChange: controlledOnChange,\n    form,\n    name,\n    by,\n    invalid = false,\n    disabled = providedDisabled || false,\n    onClose: theirOnClose,\n    __demoMode = false,\n    multiple = false,\n    immediate = false,\n    virtual = null,\n    // Deprecated, but let's pluck it from the props such that it doesn't end up\n    // on the `Fragment`\n    nullable: _nullable,\n    ...theirProps\n  } = props;\n  let defaultValue = useDefaultValue(_defaultValue);\n  let [value = multiple ? [] : void 0, theirOnChange] = useControllable(\n    controlledValue,\n    controlledOnChange,\n    defaultValue\n  );\n  let machine = useComboboxMachine({ virtual, __demoMode });\n  let optionsPropsRef = (0, import_react55.useRef)({ static: false, hold: false });\n  let compare = useByComparator(by);\n  let calculateIndex = useEvent((value2) => {\n    if (virtual) {\n      if (by === null) {\n        return virtual.options.indexOf(value2);\n      } else {\n        return virtual.options.findIndex((other) => compare(other, value2));\n      }\n    } else {\n      return machine.state.options.findIndex((other) => compare(other.dataRef.current.value, value2));\n    }\n  });\n  let isSelected = (0, import_react55.useCallback)(\n    (other) => {\n      return match(data.mode, {\n        [1 /* Multi */]: () => {\n          return value.some((option) => compare(option, other));\n        },\n        [0 /* Single */]: () => compare(value, other)\n      });\n    },\n    [value]\n  );\n  let virtualSlice = useSlice(machine, (state) => state.virtual);\n  let onClose = useEvent(() => theirOnClose == null ? void 0 : theirOnClose());\n  let data = (0, import_react55.useMemo)(\n    () => ({\n      __demoMode,\n      immediate,\n      optionsPropsRef,\n      value,\n      defaultValue,\n      disabled,\n      invalid,\n      mode: multiple ? 1 /* Multi */ : 0 /* Single */,\n      virtual: virtual ? virtualSlice : null,\n      onChange: theirOnChange,\n      isSelected,\n      calculateIndex,\n      compare,\n      onClose\n    }),\n    [\n      value,\n      defaultValue,\n      disabled,\n      invalid,\n      multiple,\n      theirOnChange,\n      isSelected,\n      __demoMode,\n      machine,\n      virtual,\n      virtualSlice,\n      onClose\n    ]\n  );\n  useIsoMorphicEffect(() => {\n    var _a3;\n    if (!virtual)\n      return;\n    machine.send({\n      type: 8 /* UpdateVirtualConfiguration */,\n      options: virtual.options,\n      disabled: (_a3 = virtual.disabled) != null ? _a3 : null\n    });\n  }, [virtual, virtual == null ? void 0 : virtual.options, virtual == null ? void 0 : virtual.disabled]);\n  useIsoMorphicEffect(() => {\n    machine.state.dataRef.current = data;\n  }, [data]);\n  let [comboboxState, buttonElement, inputElement, optionsElement] = useSlice(machine, (state) => [\n    state.comboboxState,\n    state.buttonElement,\n    state.inputElement,\n    state.optionsElement\n  ]);\n  let outsideClickEnabled = comboboxState === 0 /* Open */;\n  useOutsideClick(\n    outsideClickEnabled,\n    [buttonElement, inputElement, optionsElement],\n    () => machine.actions.closeCombobox()\n  );\n  let activeOptionIndex = useSlice(machine, machine.selectors.activeOptionIndex);\n  let activeOption = useSlice(machine, machine.selectors.activeOption);\n  let slot = (0, import_react55.useMemo)(() => {\n    return {\n      open: comboboxState === 0 /* Open */,\n      disabled,\n      invalid,\n      activeIndex: activeOptionIndex,\n      activeOption,\n      value\n    };\n  }, [data, disabled, value, invalid, activeOption, comboboxState]);\n  let [labelledby, LabelProvider] = useLabels();\n  let ourProps = ref === null ? {} : { ref };\n  let reset = (0, import_react55.useCallback)(() => {\n    if (defaultValue === void 0)\n      return;\n    return theirOnChange == null ? void 0 : theirOnChange(defaultValue);\n  }, [theirOnChange, defaultValue]);\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react55.default.createElement(\n    LabelProvider,\n    {\n      value: labelledby,\n      props: {\n        htmlFor: inputElement == null ? void 0 : inputElement.id\n      },\n      slot: {\n        open: comboboxState === 0 /* Open */,\n        disabled\n      }\n    },\n    /* @__PURE__ */ import_react55.default.createElement(FloatingProvider, null, /* @__PURE__ */ import_react55.default.createElement(ComboboxDataContext.Provider, { value: data }, /* @__PURE__ */ import_react55.default.createElement(ComboboxContext.Provider, { value: machine }, /* @__PURE__ */ import_react55.default.createElement(\n      OpenClosedProvider,\n      {\n        value: match(comboboxState, {\n          [0 /* Open */]: 1 /* Open */,\n          [1 /* Closed */]: 2 /* Closed */\n        })\n      },\n      name != null && /* @__PURE__ */ import_react55.default.createElement(\n        FormFields,\n        {\n          disabled,\n          data: value != null ? { [name]: value } : {},\n          form,\n          onReset: reset\n        }\n      ),\n      render2({\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_COMBOBOX_TAG,\n        name: \"Combobox\"\n      })\n    ))))\n  );\n}\nvar DEFAULT_INPUT_TAG = \"input\";\nfunction InputFn(props, ref) {\n  var _a3, _b2;\n  let machine = useComboboxMachineContext(\"Combobox.Input\");\n  let data = useData(\"Combobox.Input\");\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let {\n    id = providedId || `headlessui-combobox-input-${internalId}`,\n    onChange,\n    displayValue,\n    disabled = data.disabled || false,\n    autoFocus = false,\n    // @ts-ignore: We know this MAY NOT exist for a given tag but we only care when it _does_ exist.\n    type = \"text\",\n    ...theirProps\n  } = props;\n  let [inputElement] = useSlice(machine, (state) => [state.inputElement]);\n  let internalInputRef = (0, import_react55.useRef)(null);\n  let inputRef = useSyncRefs(\n    internalInputRef,\n    ref,\n    useFloatingReference(),\n    machine.actions.setInputElement\n  );\n  let ownerDocument = useOwnerDocument(inputElement);\n  let [comboboxState, isTyping] = useSlice(machine, (state) => [\n    state.comboboxState,\n    state.isTyping\n  ]);\n  let d = useDisposables();\n  let clear = useEvent(() => {\n    machine.actions.onChange(null);\n    if (machine.state.optionsElement) {\n      machine.state.optionsElement.scrollTop = 0;\n    }\n    machine.actions.goToOption({ focus: 5 /* Nothing */ });\n  });\n  let currentDisplayValue = (0, import_react55.useMemo)(() => {\n    var _a4;\n    if (typeof displayValue === \"function\" && data.value !== void 0) {\n      return (_a4 = displayValue(data.value)) != null ? _a4 : \"\";\n    } else if (typeof data.value === \"string\") {\n      return data.value;\n    } else {\n      return \"\";\n    }\n  }, [data.value, displayValue]);\n  useWatch(\n    ([currentDisplayValue2, state], [oldCurrentDisplayValue, oldState]) => {\n      if (machine.state.isTyping)\n        return;\n      let input = internalInputRef.current;\n      if (!input)\n        return;\n      if (oldState === 0 /* Open */ && state === 1 /* Closed */) {\n        input.value = currentDisplayValue2;\n      } else if (currentDisplayValue2 !== oldCurrentDisplayValue) {\n        input.value = currentDisplayValue2;\n      }\n      requestAnimationFrame(() => {\n        if (machine.state.isTyping)\n          return;\n        if (!input)\n          return;\n        if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) !== input)\n          return;\n        let { selectionStart, selectionEnd } = input;\n        if (Math.abs((selectionEnd != null ? selectionEnd : 0) - (selectionStart != null ? selectionStart : 0)) !== 0)\n          return;\n        if (selectionStart !== 0)\n          return;\n        input.setSelectionRange(input.value.length, input.value.length);\n      });\n    },\n    [currentDisplayValue, comboboxState, ownerDocument, isTyping]\n  );\n  useWatch(\n    ([newState], [oldState]) => {\n      if (newState === 0 /* Open */ && oldState === 1 /* Closed */) {\n        if (machine.state.isTyping)\n          return;\n        let input = internalInputRef.current;\n        if (!input)\n          return;\n        let currentValue = input.value;\n        let { selectionStart, selectionEnd, selectionDirection } = input;\n        input.value = \"\";\n        input.value = currentValue;\n        if (selectionDirection !== null) {\n          input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);\n        } else {\n          input.setSelectionRange(selectionStart, selectionEnd);\n        }\n      }\n    },\n    [comboboxState]\n  );\n  let isComposing = (0, import_react55.useRef)(false);\n  let handleCompositionStart = useEvent(() => {\n    isComposing.current = true;\n  });\n  let handleCompositionEnd = useEvent(() => {\n    d.nextFrame(() => {\n      isComposing.current = false;\n    });\n  });\n  let handleKeyDown = useEvent((event) => {\n    machine.actions.setIsTyping(true);\n    switch (event.key) {\n      case \"Enter\" /* Enter */:\n        if (machine.state.comboboxState !== 0 /* Open */)\n          return;\n        if (isComposing.current)\n          return;\n        event.preventDefault();\n        event.stopPropagation();\n        if (machine.selectors.activeOptionIndex(machine.state) === null) {\n          machine.actions.closeCombobox();\n          return;\n        }\n        machine.actions.selectActiveOption();\n        if (data.mode === 0 /* Single */) {\n          machine.actions.closeCombobox();\n        }\n        break;\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return match(machine.state.comboboxState, {\n          [0 /* Open */]: () => machine.actions.goToOption({ focus: 2 /* Next */ }),\n          [1 /* Closed */]: () => machine.actions.openCombobox()\n        });\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return match(machine.state.comboboxState, {\n          [0 /* Open */]: () => machine.actions.goToOption({ focus: 1 /* Previous */ }),\n          [1 /* Closed */]: () => {\n            (0, import_react_dom7.flushSync)(() => machine.actions.openCombobox());\n            if (!data.value)\n              machine.actions.goToOption({ focus: 3 /* Last */ });\n          }\n        });\n      case \"Home\" /* Home */:\n        if (event.shiftKey) {\n          break;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 0 /* First */ });\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 0 /* First */ });\n      case \"End\" /* End */:\n        if (event.shiftKey) {\n          break;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 3 /* Last */ });\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 3 /* Last */ });\n      case \"Escape\" /* Escape */:\n        if (machine.state.comboboxState !== 0 /* Open */)\n          return;\n        event.preventDefault();\n        if (machine.state.optionsElement && !data.optionsPropsRef.current.static) {\n          event.stopPropagation();\n        }\n        if (data.mode === 0 /* Single */) {\n          if (data.value === null) {\n            clear();\n          }\n        }\n        return machine.actions.closeCombobox();\n      case \"Tab\" /* Tab */:\n        if (machine.state.comboboxState !== 0 /* Open */)\n          return;\n        if (data.mode === 0 /* Single */ && machine.state.activationTrigger !== 1 /* Focus */) {\n          machine.actions.selectActiveOption();\n        }\n        machine.actions.closeCombobox();\n        break;\n    }\n  });\n  let handleChange = useEvent((event) => {\n    onChange == null ? void 0 : onChange(event);\n    if (data.mode === 0 /* Single */ && event.target.value === \"\") {\n      clear();\n    }\n    machine.actions.openCombobox();\n  });\n  let handleBlur = useEvent((event) => {\n    var _a4, _b3, _c;\n    let relatedTarget = (_a4 = event.relatedTarget) != null ? _a4 : history.find((x) => x !== event.currentTarget);\n    if ((_b3 = machine.state.optionsElement) == null ? void 0 : _b3.contains(relatedTarget))\n      return;\n    if ((_c = machine.state.buttonElement) == null ? void 0 : _c.contains(relatedTarget))\n      return;\n    if (machine.state.comboboxState !== 0 /* Open */)\n      return;\n    event.preventDefault();\n    if (data.mode === 0 /* Single */ && data.value === null) {\n      clear();\n    }\n    return machine.actions.closeCombobox();\n  });\n  let handleFocus = useEvent((event) => {\n    var _a4, _b3, _c;\n    let relatedTarget = (_a4 = event.relatedTarget) != null ? _a4 : history.find((x) => x !== event.currentTarget);\n    if ((_b3 = machine.state.buttonElement) == null ? void 0 : _b3.contains(relatedTarget))\n      return;\n    if ((_c = machine.state.optionsElement) == null ? void 0 : _c.contains(relatedTarget))\n      return;\n    if (data.disabled)\n      return;\n    if (!data.immediate)\n      return;\n    if (machine.state.comboboxState === 0 /* Open */)\n      return;\n    d.microTask(() => {\n      (0, import_react_dom7.flushSync)(() => machine.actions.openCombobox());\n      machine.actions.setActivationTrigger(1 /* Focus */);\n    });\n  });\n  let labelledBy = useLabelledBy();\n  let describedBy = useDescribedBy();\n  let { isFocused: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let optionsElement = useSlice(machine, (state) => state.optionsElement);\n  let slot = (0, import_react55.useMemo)(() => {\n    return {\n      open: comboboxState === 0 /* Open */,\n      disabled,\n      invalid: data.invalid,\n      hover,\n      focus,\n      autofocus: autoFocus\n    };\n  }, [data, hover, focus, autoFocus, disabled, data.invalid]);\n  let ourProps = mergeProps(\n    {\n      ref: inputRef,\n      id,\n      role: \"combobox\",\n      type,\n      \"aria-controls\": optionsElement == null ? void 0 : optionsElement.id,\n      \"aria-expanded\": comboboxState === 0 /* Open */,\n      \"aria-activedescendant\": useSlice(machine, machine.selectors.activeDescendantId),\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      \"aria-autocomplete\": \"list\",\n      defaultValue: (_b2 = (_a3 = props.defaultValue) != null ? _a3 : data.defaultValue !== void 0 ? displayValue == null ? void 0 : displayValue(data.defaultValue) : null) != null ? _b2 : data.defaultValue,\n      disabled: disabled || void 0,\n      autoFocus,\n      onCompositionStart: handleCompositionStart,\n      onCompositionEnd: handleCompositionEnd,\n      onKeyDown: handleKeyDown,\n      onChange: handleChange,\n      onFocus: handleFocus,\n      onBlur: handleBlur\n    },\n    focusProps,\n    hoverProps\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_INPUT_TAG,\n    name: \"Combobox.Input\"\n  });\n}\nvar DEFAULT_BUTTON_TAG2 = \"button\";\nfunction ButtonFn2(props, ref) {\n  let machine = useComboboxMachineContext(\"Combobox.Button\");\n  let data = useData(\"Combobox.Button\");\n  let [localButtonElement, setLocalButtonElement] = (0, import_react55.useState)(null);\n  let buttonRef = useSyncRefs(ref, setLocalButtonElement, machine.actions.setButtonElement);\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-combobox-button-${internalId}`,\n    disabled = data.disabled || false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let inputElement = useSlice(machine, (state) => state.inputElement);\n  let refocusInput = useRefocusableInput(inputElement);\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n      case \"Enter\" /* Enter */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (machine.state.comboboxState === 1 /* Closed */) {\n          (0, import_react_dom7.flushSync)(() => machine.actions.openCombobox());\n        }\n        refocusInput();\n        return;\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (machine.state.comboboxState === 1 /* Closed */) {\n          (0, import_react_dom7.flushSync)(() => machine.actions.openCombobox());\n          if (!machine.state.dataRef.current.value)\n            machine.actions.goToOption({ focus: 0 /* First */ });\n        }\n        refocusInput();\n        return;\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (machine.state.comboboxState === 1 /* Closed */) {\n          (0, import_react_dom7.flushSync)(() => machine.actions.openCombobox());\n          if (!machine.state.dataRef.current.value) {\n            machine.actions.goToOption({ focus: 3 /* Last */ });\n          }\n        }\n        refocusInput();\n        return;\n      case \"Escape\" /* Escape */:\n        if (machine.state.comboboxState !== 0 /* Open */)\n          return;\n        event.preventDefault();\n        if (machine.state.optionsElement && !data.optionsPropsRef.current.static) {\n          event.stopPropagation();\n        }\n        (0, import_react_dom7.flushSync)(() => machine.actions.closeCombobox());\n        refocusInput();\n        return;\n      default:\n        return;\n    }\n  });\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return;\n    if (event.button === 0 /* Left */) {\n      if (machine.state.comboboxState === 0 /* Open */) {\n        machine.actions.closeCombobox();\n      } else {\n        machine.actions.openCombobox();\n      }\n    }\n    refocusInput();\n  });\n  let labelledBy = useLabelledBy([id]);\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let [comboboxState, optionsElement] = useSlice(machine, (state) => [\n    state.comboboxState,\n    state.optionsElement\n  ]);\n  let slot = (0, import_react55.useMemo)(() => {\n    return {\n      open: comboboxState === 0 /* Open */,\n      active: active || comboboxState === 0 /* Open */,\n      disabled,\n      invalid: data.invalid,\n      value: data.value,\n      hover,\n      focus\n    };\n  }, [data, hover, focus, active, disabled, comboboxState]);\n  let ourProps = mergeProps(\n    {\n      ref: buttonRef,\n      id,\n      type: useResolveButtonType(props, localButtonElement),\n      tabIndex: -1,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": optionsElement == null ? void 0 : optionsElement.id,\n      \"aria-expanded\": comboboxState === 0 /* Open */,\n      \"aria-labelledby\": labelledBy,\n      disabled: disabled || void 0,\n      autoFocus,\n      onMouseDown: handleMouseDown,\n      onKeyDown: handleKeyDown\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG2,\n    name: \"Combobox.Button\"\n  });\n}\nvar DEFAULT_OPTIONS_TAG = \"div\";\nvar OptionsRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction OptionsFn(props, ref) {\n  var _a3, _b2, _c;\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-combobox-options-${internalId}`,\n    hold = false,\n    anchor: rawAnchor,\n    portal = false,\n    modal = true,\n    transition: transition2 = false,\n    ...theirProps\n  } = props;\n  let machine = useComboboxMachineContext(\"Combobox.Options\");\n  let data = useData(\"Combobox.Options\");\n  let anchor = useResolvedAnchor(rawAnchor);\n  if (anchor) {\n    portal = true;\n  }\n  let [floatingRef, style] = useFloatingPanel(anchor);\n  let [localOptionsElement, setLocalOptionsElement] = (0, import_react55.useState)(null);\n  let getFloatingPanelProps = useFloatingPanelProps();\n  let optionsRef = useSyncRefs(\n    ref,\n    anchor ? floatingRef : null,\n    machine.actions.setOptionsElement,\n    setLocalOptionsElement\n  );\n  let [comboboxState, inputElement, buttonElement, optionsElement, activationTrigger] = useSlice(\n    machine,\n    (state) => [\n      state.comboboxState,\n      state.inputElement,\n      state.buttonElement,\n      state.optionsElement,\n      state.activationTrigger\n    ]\n  );\n  let portalOwnerDocument = useOwnerDocument(inputElement || buttonElement);\n  let ownerDocument = useOwnerDocument(optionsElement);\n  let usesOpenClosedState = useOpenClosed();\n  let [visible, transitionData] = useTransition(\n    transition2,\n    localOptionsElement,\n    usesOpenClosedState !== null ? (usesOpenClosedState & 1 /* Open */) === 1 /* Open */ : comboboxState === 0 /* Open */\n  );\n  useOnDisappear(visible, inputElement, machine.actions.closeCombobox);\n  let scrollLockEnabled = data.__demoMode ? false : modal && comboboxState === 0 /* Open */;\n  useScrollLock(scrollLockEnabled, ownerDocument);\n  let inertOthersEnabled = data.__demoMode ? false : modal && comboboxState === 0 /* Open */;\n  useInertOthers(inertOthersEnabled, {\n    allowed: (0, import_react55.useCallback)(\n      () => [inputElement, buttonElement, optionsElement],\n      [inputElement, buttonElement, optionsElement]\n    )\n  });\n  useIsoMorphicEffect(() => {\n    var _a4;\n    data.optionsPropsRef.current.static = (_a4 = props.static) != null ? _a4 : false;\n  }, [data.optionsPropsRef, props.static]);\n  useIsoMorphicEffect(() => {\n    data.optionsPropsRef.current.hold = hold;\n  }, [data.optionsPropsRef, hold]);\n  useTreeWalker(comboboxState === 0 /* Open */, {\n    container: optionsElement,\n    accept(node) {\n      if (node.getAttribute(\"role\") === \"option\")\n        return NodeFilter.FILTER_REJECT;\n      if (node.hasAttribute(\"role\"))\n        return NodeFilter.FILTER_SKIP;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n    walk(node) {\n      node.setAttribute(\"role\", \"none\");\n    }\n  });\n  let labelledBy = useLabelledBy([buttonElement == null ? void 0 : buttonElement.id]);\n  let slot = (0, import_react55.useMemo)(() => {\n    return {\n      open: comboboxState === 0 /* Open */,\n      option: void 0\n    };\n  }, [comboboxState]);\n  let handleWheel = useEvent(() => {\n    machine.actions.setActivationTrigger(0 /* Pointer */);\n  });\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n    machine.actions.setActivationTrigger(0 /* Pointer */);\n  });\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    \"aria-labelledby\": labelledBy,\n    role: \"listbox\",\n    \"aria-multiselectable\": data.mode === 1 /* Multi */ ? true : void 0,\n    id,\n    ref: optionsRef,\n    style: {\n      ...theirProps.style,\n      ...style,\n      \"--input-width\": useElementSize(inputElement, true).width,\n      \"--button-width\": useElementSize(buttonElement, true).width\n    },\n    onWheel: activationTrigger === 0 /* Pointer */ ? void 0 : handleWheel,\n    onMouseDown: handleMouseDown,\n    ...transitionDataAttributes(transitionData)\n  });\n  let shouldFreeze = visible && comboboxState === 1 /* Closed */;\n  let options = useFrozenData(shouldFreeze, (_a3 = data.virtual) == null ? void 0 : _a3.options);\n  let frozenValue = useFrozenData(shouldFreeze, data.value);\n  let isSelected = useEvent((compareValue) => data.compare(frozenValue, compareValue));\n  let newDataContextValue = (0, import_react55.useMemo)(() => {\n    if (!data.virtual)\n      return data;\n    if (options === void 0)\n      throw new Error(\"Missing `options` in virtual mode\");\n    return options !== data.virtual.options ? { ...data, virtual: { ...data.virtual, options } } : data;\n  }, [data, options, (_b2 = data.virtual) == null ? void 0 : _b2.options]);\n  if (data.virtual) {\n    Object.assign(theirProps, {\n      children: /* @__PURE__ */ import_react55.default.createElement(ComboboxDataContext.Provider, { value: newDataContextValue }, /* @__PURE__ */ import_react55.default.createElement(VirtualProvider, { slot }, theirProps.children))\n    });\n  }\n  let render2 = useRender();\n  let newData = (0, import_react55.useMemo)(() => {\n    return data.mode === 1 /* Multi */ ? data : { ...data, isSelected };\n  }, [data, isSelected]);\n  return /* @__PURE__ */ import_react55.default.createElement(Portal, { enabled: portal ? props.static || visible : false, ownerDocument: portalOwnerDocument }, /* @__PURE__ */ import_react55.default.createElement(ComboboxDataContext.Provider, { value: newData }, render2({\n    ourProps,\n    theirProps: {\n      ...theirProps,\n      children: /* @__PURE__ */ import_react55.default.createElement(Frozen, { freeze: shouldFreeze }, typeof theirProps.children === \"function\" ? (_c = theirProps.children) == null ? void 0 : _c.call(theirProps, slot) : theirProps.children)\n    },\n    slot,\n    defaultTag: DEFAULT_OPTIONS_TAG,\n    features: OptionsRenderFeatures,\n    visible,\n    name: \"Combobox.Options\"\n  })));\n}\nvar DEFAULT_OPTION_TAG = \"div\";\nfunction OptionFn(props, ref) {\n  var _a3, _b2, _c;\n  let data = useData(\"Combobox.Option\");\n  let machine = useComboboxMachineContext(\"Combobox.Option\");\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-combobox-option-${internalId}`,\n    value,\n    disabled = (_c = (_b2 = (_a3 = data.virtual) == null ? void 0 : _a3.disabled) == null ? void 0 : _b2.call(_a3, value)) != null ? _c : false,\n    order = null,\n    ...theirProps\n  } = props;\n  let [inputElement] = useSlice(machine, (state) => [state.inputElement]);\n  let refocusInput = useRefocusableInput(inputElement);\n  let active = useSlice(\n    machine,\n    (0, import_react55.useCallback)((state) => machine.selectors.isActive(state, value, id), [value, id])\n  );\n  let selected = data.isSelected(value);\n  let internalOptionRef = (0, import_react55.useRef)(null);\n  let bag = useLatestValue({\n    disabled,\n    value,\n    domRef: internalOptionRef,\n    order\n  });\n  let virtualizer = (0, import_react55.useContext)(VirtualContext);\n  let optionRef = useSyncRefs(\n    ref,\n    internalOptionRef,\n    virtualizer ? virtualizer.measureElement : null\n  );\n  let select = useEvent(() => {\n    machine.actions.setIsTyping(false);\n    machine.actions.onChange(value);\n  });\n  useIsoMorphicEffect(() => machine.actions.registerOption(id, bag), [bag, id]);\n  let shouldScrollIntoView = useSlice(\n    machine,\n    (0, import_react55.useCallback)((state) => machine.selectors.shouldScrollIntoView(state, value, id), [value, id])\n  );\n  useIsoMorphicEffect(() => {\n    if (!shouldScrollIntoView)\n      return;\n    return disposables().requestAnimationFrame(() => {\n      var _a4, _b3;\n      (_b3 = (_a4 = internalOptionRef.current) == null ? void 0 : _a4.scrollIntoView) == null ? void 0 : _b3.call(_a4, { block: \"nearest\" });\n    });\n  }, [shouldScrollIntoView, internalOptionRef]);\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n    if (event.button !== 0 /* Left */) {\n      return;\n    }\n    if (disabled)\n      return;\n    select();\n    if (!isMobile()) {\n      requestAnimationFrame(() => refocusInput());\n    }\n    if (data.mode === 0 /* Single */) {\n      machine.actions.closeCombobox();\n    }\n  });\n  let handleFocus = useEvent(() => {\n    if (disabled) {\n      return machine.actions.goToOption({ focus: 5 /* Nothing */ });\n    }\n    let idx = data.calculateIndex(value);\n    machine.actions.goToOption({ focus: 4 /* Specific */, idx });\n  });\n  let pointer = useTrackedPointer();\n  let handleEnter = useEvent((evt) => pointer.update(evt));\n  let handleMove = useEvent((evt) => {\n    if (!pointer.wasMoved(evt))\n      return;\n    if (disabled)\n      return;\n    if (active)\n      return;\n    let idx = data.calculateIndex(value);\n    machine.actions.goToOption({ focus: 4 /* Specific */, idx }, 0 /* Pointer */);\n  });\n  let handleLeave = useEvent((evt) => {\n    if (!pointer.wasMoved(evt))\n      return;\n    if (disabled)\n      return;\n    if (!active)\n      return;\n    if (data.optionsPropsRef.current.hold)\n      return;\n    machine.actions.goToOption({ focus: 5 /* Nothing */ });\n  });\n  let slot = (0, import_react55.useMemo)(() => {\n    return {\n      active,\n      focus: active,\n      selected,\n      disabled\n    };\n  }, [active, selected, disabled]);\n  let ourProps = {\n    id,\n    ref: optionRef,\n    role: \"option\",\n    tabIndex: disabled === true ? void 0 : -1,\n    \"aria-disabled\": disabled === true ? true : void 0,\n    // According to the WAI-ARIA best practices, we should use aria-checked for\n    // multi-select,but Voice-Over disagrees. So we use aria-checked instead for\n    // both single and multi-select.\n    \"aria-selected\": selected,\n    disabled: void 0,\n    // Never forward the `disabled` prop\n    onMouseDown: handleMouseDown,\n    onFocus: handleFocus,\n    onPointerEnter: handleEnter,\n    onMouseEnter: handleEnter,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave\n  };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG,\n    name: \"Combobox.Option\"\n  });\n}\nvar ComboboxRoot = forwardRefWithAs(ComboboxFn);\nvar ComboboxButton = forwardRefWithAs(ButtonFn2);\nvar ComboboxInput = forwardRefWithAs(InputFn);\nvar ComboboxLabel = Label;\nvar ComboboxOptions = forwardRefWithAs(OptionsFn);\nvar ComboboxOption = forwardRefWithAs(OptionFn);\nvar Combobox = Object.assign(ComboboxRoot, {\n  /** @deprecated use `<ComboboxInput>` instead of `<Combobox.Input>` */\n  Input: ComboboxInput,\n  /** @deprecated use `<ComboboxButton>` instead of `<Combobox.Button>` */\n  Button: ComboboxButton,\n  /** @deprecated use `<Label>` instead of `<Combobox.Label>` */\n  Label: ComboboxLabel,\n  /** @deprecated use `<ComboboxOptions>` instead of `<Combobox.Options>` */\n  Options: ComboboxOptions,\n  /** @deprecated use `<ComboboxOption>` instead of `<Combobox.Option>` */\n  Option: ComboboxOption\n});\n\n// src/components/data-interactive/data-interactive.tsx\nvar import_react56 = require(\"react\");\nvar DEFAULT_DATA_INTERACTIVE_TAG = import_react56.Fragment;\nfunction DataInteractiveFn(props, ref) {\n  let { ...theirProps } = props;\n  let disabled = false;\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f();\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let ourProps = mergeProps({ ref }, focusProps, hoverProps, pressProps);\n  let slot = (0, import_react56.useMemo)(\n    () => ({ hover, focus, active }),\n    [hover, focus, active]\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_DATA_INTERACTIVE_TAG,\n    name: \"DataInteractive\"\n  });\n}\nvar DataInteractive = forwardRefWithAs(\n  DataInteractiveFn\n);\n\n// src/components/dialog/dialog.tsx\nvar import_react63 = __toESM(require(\"react\"), 1);\n\n// src/hooks/use-escape.ts\nfunction useEscape(enabled, view = typeof document !== \"undefined\" ? document.defaultView : null, cb) {\n  let isTopLayer = useIsTopLayer(enabled, \"escape\");\n  useEventListener(view, \"keydown\", (event) => {\n    if (!isTopLayer)\n      return;\n    if (event.defaultPrevented)\n      return;\n    if (event.key !== \"Escape\" /* Escape */)\n      return;\n    cb(event);\n  });\n}\n\n// src/hooks/use-is-touch-device.ts\nvar import_react57 = require(\"react\");\nfunction useIsTouchDevice() {\n  var _a3;\n  let [mq] = (0, import_react57.useState)(\n    () => typeof window !== \"undefined\" && typeof window.matchMedia === \"function\" ? window.matchMedia(\"(pointer: coarse)\") : null\n  );\n  let [isTouchDevice, setIsTouchDevice] = (0, import_react57.useState)((_a3 = mq == null ? void 0 : mq.matches) != null ? _a3 : false);\n  useIsoMorphicEffect(() => {\n    if (!mq)\n      return;\n    function handle(event) {\n      setIsTouchDevice(event.matches);\n    }\n    mq.addEventListener(\"change\", handle);\n    return () => mq.removeEventListener(\"change\", handle);\n  }, [mq]);\n  return isTouchDevice;\n}\n\n// src/hooks/use-root-containers.tsx\nvar import_react58 = __toESM(require(\"react\"), 1);\nfunction useRootContainers({\n  defaultContainers = [],\n  portals,\n  // Reference to a node in the \"main\" tree, not in the portalled Dialog tree.\n  mainTreeNode\n} = {}) {\n  let ownerDocument = useOwnerDocument(mainTreeNode);\n  let resolveContainers2 = useEvent(() => {\n    var _a3, _b2;\n    let containers = [];\n    for (let container of defaultContainers) {\n      if (container === null)\n        continue;\n      if (container instanceof HTMLElement) {\n        containers.push(container);\n      } else if (\"current\" in container && container.current instanceof HTMLElement) {\n        containers.push(container.current);\n      }\n    }\n    if (portals == null ? void 0 : portals.current) {\n      for (let portal of portals.current) {\n        containers.push(portal);\n      }\n    }\n    for (let container of (_a3 = ownerDocument == null ? void 0 : ownerDocument.querySelectorAll(\"html > *, body > *\")) != null ? _a3 : []) {\n      if (container === document.body)\n        continue;\n      if (container === document.head)\n        continue;\n      if (!(container instanceof HTMLElement))\n        continue;\n      if (container.id === \"headlessui-portal-root\")\n        continue;\n      if (mainTreeNode) {\n        if (container.contains(mainTreeNode))\n          continue;\n        if (container.contains((_b2 = mainTreeNode == null ? void 0 : mainTreeNode.getRootNode()) == null ? void 0 : _b2.host))\n          continue;\n      }\n      if (containers.some((defaultContainer) => container.contains(defaultContainer)))\n        continue;\n      containers.push(container);\n    }\n    return containers;\n  });\n  return {\n    resolveContainers: resolveContainers2,\n    contains: useEvent(\n      (element) => resolveContainers2().some((container) => container.contains(element))\n    )\n  };\n}\nvar MainTreeContext = (0, import_react58.createContext)(null);\nfunction MainTreeProvider({\n  children,\n  node\n}) {\n  let [mainTreeNode, setMainTreeNode] = (0, import_react58.useState)(null);\n  let resolvedMainTreeNode = useMainTreeNode(node != null ? node : mainTreeNode);\n  return /* @__PURE__ */ import_react58.default.createElement(MainTreeContext.Provider, { value: resolvedMainTreeNode }, children, resolvedMainTreeNode === null && /* @__PURE__ */ import_react58.default.createElement(\n    Hidden,\n    {\n      features: 4 /* Hidden */,\n      ref: (el) => {\n        var _a3, _b2;\n        if (!el)\n          return;\n        for (let container of (_b2 = (_a3 = getOwnerDocument(el)) == null ? void 0 : _a3.querySelectorAll(\"html > *, body > *\")) != null ? _b2 : []) {\n          if (container === document.body)\n            continue;\n          if (container === document.head)\n            continue;\n          if (!(container instanceof HTMLElement))\n            continue;\n          if (container == null ? void 0 : container.contains(el)) {\n            setMainTreeNode(container);\n            break;\n          }\n        }\n      }\n    }\n  ));\n}\nfunction useMainTreeNode(fallbackMainTreeNode = null) {\n  var _a3;\n  return (_a3 = (0, import_react58.useContext)(MainTreeContext)) != null ? _a3 : fallbackMainTreeNode;\n}\n\n// src/components/focus-trap/focus-trap.tsx\nvar import_react61 = __toESM(require(\"react\"), 1);\n\n// src/hooks/use-is-mounted.ts\nvar import_react59 = require(\"react\");\nfunction useIsMounted() {\n  let mounted = (0, import_react59.useRef)(false);\n  useIsoMorphicEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  return mounted;\n}\n\n// src/hooks/use-tab-direction.ts\nvar import_react60 = require(\"react\");\nfunction useTabDirection() {\n  let direction = (0, import_react60.useRef)(0 /* Forwards */);\n  let enabled = true;\n  useWindowEvent(\n    enabled,\n    \"keydown\",\n    (event) => {\n      if (event.key === \"Tab\") {\n        direction.current = event.shiftKey ? 1 /* Backwards */ : 0 /* Forwards */;\n      }\n    },\n    true\n  );\n  return direction;\n}\n\n// src/components/focus-trap/focus-trap.tsx\nfunction resolveContainers(containers) {\n  if (!containers)\n    return /* @__PURE__ */ new Set();\n  if (typeof containers === \"function\")\n    return new Set(containers());\n  let all = /* @__PURE__ */ new Set();\n  for (let container of containers.current) {\n    if (container.current instanceof HTMLElement) {\n      all.add(container.current);\n    }\n  }\n  return all;\n}\nvar DEFAULT_FOCUS_TRAP_TAG = \"div\";\nvar FocusTrapFeatures = /* @__PURE__ */ ((FocusTrapFeatures2) => {\n  FocusTrapFeatures2[FocusTrapFeatures2[\"None\"] = 0] = \"None\";\n  FocusTrapFeatures2[FocusTrapFeatures2[\"InitialFocus\"] = 1] = \"InitialFocus\";\n  FocusTrapFeatures2[FocusTrapFeatures2[\"TabLock\"] = 2] = \"TabLock\";\n  FocusTrapFeatures2[FocusTrapFeatures2[\"FocusLock\"] = 4] = \"FocusLock\";\n  FocusTrapFeatures2[FocusTrapFeatures2[\"RestoreFocus\"] = 8] = \"RestoreFocus\";\n  FocusTrapFeatures2[FocusTrapFeatures2[\"AutoFocus\"] = 16] = \"AutoFocus\";\n  return FocusTrapFeatures2;\n})(FocusTrapFeatures || {});\nfunction FocusTrapFn(props, ref) {\n  let container = (0, import_react61.useRef)(null);\n  let focusTrapRef = useSyncRefs(container, ref);\n  let {\n    initialFocus,\n    initialFocusFallback,\n    containers,\n    features = 1 /* InitialFocus */ | 2 /* TabLock */ | 4 /* FocusLock */ | 8 /* RestoreFocus */,\n    ...theirProps\n  } = props;\n  if (!useServerHandoffComplete()) {\n    features = 0 /* None */;\n  }\n  let ownerDocument = useOwnerDocument(container);\n  useRestoreFocus(features, { ownerDocument });\n  let previousActiveElement = useInitialFocus(features, {\n    ownerDocument,\n    container,\n    initialFocus,\n    initialFocusFallback\n  });\n  useFocusLock(features, { ownerDocument, container, containers, previousActiveElement });\n  let direction = useTabDirection();\n  let handleFocus = useEvent((e) => {\n    let el = container.current;\n    if (!el)\n      return;\n    let wrapper = false ? microTask : (cb) => cb();\n    wrapper(() => {\n      match(direction.current, {\n        [0 /* Forwards */]: () => {\n          focusIn(el, 1 /* First */, {\n            skipElements: [e.relatedTarget, initialFocusFallback]\n          });\n        },\n        [1 /* Backwards */]: () => {\n          focusIn(el, 8 /* Last */, {\n            skipElements: [e.relatedTarget, initialFocusFallback]\n          });\n        }\n      });\n    });\n  });\n  let tabLockEnabled = useIsTopLayer(\n    Boolean(features & 2 /* TabLock */),\n    \"focus-trap#tab-lock\"\n  );\n  let d = useDisposables();\n  let recentlyUsedTabKey = (0, import_react61.useRef)(false);\n  let ourProps = {\n    ref: focusTrapRef,\n    onKeyDown(e) {\n      if (e.key == \"Tab\") {\n        recentlyUsedTabKey.current = true;\n        d.requestAnimationFrame(() => {\n          recentlyUsedTabKey.current = false;\n        });\n      }\n    },\n    onBlur(e) {\n      if (!(features & 4 /* FocusLock */))\n        return;\n      let allContainers = resolveContainers(containers);\n      if (container.current instanceof HTMLElement)\n        allContainers.add(container.current);\n      let relatedTarget = e.relatedTarget;\n      if (!(relatedTarget instanceof HTMLElement))\n        return;\n      if (relatedTarget.dataset.headlessuiFocusGuard === \"true\") {\n        return;\n      }\n      if (!contains2(allContainers, relatedTarget)) {\n        if (recentlyUsedTabKey.current) {\n          focusIn(\n            container.current,\n            match(direction.current, {\n              [0 /* Forwards */]: () => 4 /* Next */,\n              [1 /* Backwards */]: () => 2 /* Previous */\n            }) | 16 /* WrapAround */,\n            { relativeTo: e.target }\n          );\n        } else if (e.target instanceof HTMLElement) {\n          focusElement(e.target);\n        }\n      }\n    }\n  };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react61.default.createElement(import_react61.default.Fragment, null, tabLockEnabled && /* @__PURE__ */ import_react61.default.createElement(\n    Hidden,\n    {\n      as: \"button\",\n      type: \"button\",\n      \"data-headlessui-focus-guard\": true,\n      onFocus: handleFocus,\n      features: 2 /* Focusable */\n    }\n  ), render2({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_FOCUS_TRAP_TAG,\n    name: \"FocusTrap\"\n  }), tabLockEnabled && /* @__PURE__ */ import_react61.default.createElement(\n    Hidden,\n    {\n      as: \"button\",\n      type: \"button\",\n      \"data-headlessui-focus-guard\": true,\n      onFocus: handleFocus,\n      features: 2 /* Focusable */\n    }\n  ));\n}\nvar FocusTrapRoot = forwardRefWithAs(FocusTrapFn);\nvar FocusTrap = Object.assign(FocusTrapRoot, {\n  /** @deprecated use `FocusTrapFeatures` instead of `FocusTrap.features` */\n  features: FocusTrapFeatures\n});\nfunction useRestoreElement(enabled = true) {\n  let localHistory = (0, import_react61.useRef)(history.slice());\n  useWatch(\n    ([newEnabled], [oldEnabled]) => {\n      if (oldEnabled === true && newEnabled === false) {\n        microTask(() => {\n          localHistory.current.splice(0);\n        });\n      }\n      if (oldEnabled === false && newEnabled === true) {\n        localHistory.current = history.slice();\n      }\n    },\n    [enabled, history, localHistory]\n  );\n  return useEvent(() => {\n    var _a3;\n    return (_a3 = localHistory.current.find((x) => x != null && x.isConnected)) != null ? _a3 : null;\n  });\n}\nfunction useRestoreFocus(features, { ownerDocument }) {\n  let enabled = Boolean(features & 8 /* RestoreFocus */);\n  let getRestoreElement = useRestoreElement(enabled);\n  useWatch(() => {\n    if (enabled)\n      return;\n    if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) === (ownerDocument == null ? void 0 : ownerDocument.body)) {\n      focusElement(getRestoreElement());\n    }\n  }, [enabled]);\n  useOnUnmount(() => {\n    if (!enabled)\n      return;\n    focusElement(getRestoreElement());\n  });\n}\nfunction useInitialFocus(features, {\n  ownerDocument,\n  container,\n  initialFocus,\n  initialFocusFallback\n}) {\n  let previousActiveElement = (0, import_react61.useRef)(null);\n  let enabled = useIsTopLayer(\n    Boolean(features & 1 /* InitialFocus */),\n    \"focus-trap#initial-focus\"\n  );\n  let mounted = useIsMounted();\n  useWatch(() => {\n    if (features === 0 /* None */) {\n      return;\n    }\n    if (!enabled) {\n      if (initialFocusFallback == null ? void 0 : initialFocusFallback.current) {\n        focusElement(initialFocusFallback.current);\n      }\n      return;\n    }\n    let containerElement = container.current;\n    if (!containerElement)\n      return;\n    microTask(() => {\n      if (!mounted.current) {\n        return;\n      }\n      let activeElement2 = ownerDocument == null ? void 0 : ownerDocument.activeElement;\n      if (initialFocus == null ? void 0 : initialFocus.current) {\n        if ((initialFocus == null ? void 0 : initialFocus.current) === activeElement2) {\n          previousActiveElement.current = activeElement2;\n          return;\n        }\n      } else if (containerElement.contains(activeElement2)) {\n        previousActiveElement.current = activeElement2;\n        return;\n      }\n      if (initialFocus == null ? void 0 : initialFocus.current) {\n        focusElement(initialFocus.current);\n      } else {\n        if (features & 16 /* AutoFocus */) {\n          if (focusIn(containerElement, 1 /* First */ | 64 /* AutoFocus */) !== 0 /* Error */) {\n            return;\n          }\n        } else if (focusIn(containerElement, 1 /* First */) !== 0 /* Error */) {\n          return;\n        }\n        if (initialFocusFallback == null ? void 0 : initialFocusFallback.current) {\n          focusElement(initialFocusFallback.current);\n          if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) === initialFocusFallback.current) {\n            return;\n          }\n        }\n        console.warn(\"There are no focusable elements inside the <FocusTrap />\");\n      }\n      previousActiveElement.current = ownerDocument == null ? void 0 : ownerDocument.activeElement;\n    });\n  }, [initialFocusFallback, enabled, features]);\n  return previousActiveElement;\n}\nfunction useFocusLock(features, {\n  ownerDocument,\n  container,\n  containers,\n  previousActiveElement\n}) {\n  let mounted = useIsMounted();\n  let enabled = Boolean(features & 4 /* FocusLock */);\n  useEventListener(\n    ownerDocument == null ? void 0 : ownerDocument.defaultView,\n    \"focus\",\n    (event) => {\n      if (!enabled)\n        return;\n      if (!mounted.current)\n        return;\n      let allContainers = resolveContainers(containers);\n      if (container.current instanceof HTMLElement)\n        allContainers.add(container.current);\n      let previous = previousActiveElement.current;\n      if (!previous)\n        return;\n      let toElement = event.target;\n      if (toElement && toElement instanceof HTMLElement) {\n        if (!contains2(allContainers, toElement)) {\n          event.preventDefault();\n          event.stopPropagation();\n          focusElement(previous);\n        } else {\n          previousActiveElement.current = toElement;\n          focusElement(toElement);\n        }\n      } else {\n        focusElement(previousActiveElement.current);\n      }\n    },\n    true\n  );\n}\nfunction contains2(containers, element) {\n  for (let container of containers) {\n    if (container.contains(element))\n      return true;\n  }\n  return false;\n}\n\n// src/components/transition/transition.tsx\nvar import_react62 = __toESM(require(\"react\"), 1);\nfunction shouldForwardRef(props) {\n  var _a3;\n  return (\n    // If we have any of the enter/leave classes\n    Boolean(\n      props.enter || props.enterFrom || props.enterTo || props.leave || props.leaveFrom || props.leaveTo\n    ) || // If the `as` prop is not a Fragment\n    ((_a3 = props.as) != null ? _a3 : DEFAULT_TRANSITION_CHILD_TAG) !== import_react62.Fragment || // If we have a single child, then we can forward the ref directly\n    import_react62.default.Children.count(props.children) === 1\n  );\n}\nvar TransitionContext = (0, import_react62.createContext)(null);\nTransitionContext.displayName = \"TransitionContext\";\nfunction useTransitionContext() {\n  let context = (0, import_react62.useContext)(TransitionContext);\n  if (context === null) {\n    throw new Error(\n      \"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\"\n    );\n  }\n  return context;\n}\nfunction useParentNesting() {\n  let context = (0, import_react62.useContext)(NestingContext);\n  if (context === null) {\n    throw new Error(\n      \"A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.\"\n    );\n  }\n  return context;\n}\nvar NestingContext = (0, import_react62.createContext)(null);\nNestingContext.displayName = \"NestingContext\";\nfunction hasChildren(bag) {\n  if (\"children\" in bag)\n    return hasChildren(bag.children);\n  return bag.current.filter(({ el }) => el.current !== null).filter(({ state }) => state === \"visible\" /* Visible */).length > 0;\n}\nfunction useNesting(done, parent) {\n  let doneRef = useLatestValue(done);\n  let transitionableChildren = (0, import_react62.useRef)([]);\n  let mounted = useIsMounted();\n  let d = useDisposables();\n  let unregister = useEvent((container, strategy = 1 /* Hidden */) => {\n    let idx = transitionableChildren.current.findIndex(({ el }) => el === container);\n    if (idx === -1)\n      return;\n    match(strategy, {\n      [0 /* Unmount */]() {\n        transitionableChildren.current.splice(idx, 1);\n      },\n      [1 /* Hidden */]() {\n        transitionableChildren.current[idx].state = \"hidden\" /* Hidden */;\n      }\n    });\n    d.microTask(() => {\n      var _a3;\n      if (!hasChildren(transitionableChildren) && mounted.current) {\n        (_a3 = doneRef.current) == null ? void 0 : _a3.call(doneRef);\n      }\n    });\n  });\n  let register = useEvent((container) => {\n    let child = transitionableChildren.current.find(({ el }) => el === container);\n    if (!child) {\n      transitionableChildren.current.push({ el: container, state: \"visible\" /* Visible */ });\n    } else if (child.state !== \"visible\" /* Visible */) {\n      child.state = \"visible\" /* Visible */;\n    }\n    return () => unregister(container, 0 /* Unmount */);\n  });\n  let todos = (0, import_react62.useRef)([]);\n  let wait = (0, import_react62.useRef)(Promise.resolve());\n  let chains = (0, import_react62.useRef)({ enter: [], leave: [] });\n  let onStart = useEvent(\n    (container, direction, cb) => {\n      todos.current.splice(0);\n      if (parent) {\n        parent.chains.current[direction] = parent.chains.current[direction].filter(\n          ([containerInParent]) => containerInParent !== container\n        );\n      }\n      parent == null ? void 0 : parent.chains.current[direction].push([\n        container,\n        new Promise((resolve) => {\n          todos.current.push(resolve);\n        })\n      ]);\n      parent == null ? void 0 : parent.chains.current[direction].push([\n        container,\n        new Promise((resolve) => {\n          Promise.all(chains.current[direction].map(([_container, promise]) => promise)).then(\n            () => resolve()\n          );\n        })\n      ]);\n      if (direction === \"enter\") {\n        wait.current = wait.current.then(() => parent == null ? void 0 : parent.wait.current).then(() => cb(direction));\n      } else {\n        cb(direction);\n      }\n    }\n  );\n  let onStop = useEvent(\n    (_container, direction, cb) => {\n      Promise.all(chains.current[direction].splice(0).map(([_container2, promise]) => promise)).then(() => {\n        var _a3;\n        (_a3 = todos.current.shift()) == null ? void 0 : _a3();\n      }).then(() => cb(direction));\n    }\n  );\n  return (0, import_react62.useMemo)(\n    () => ({\n      children: transitionableChildren,\n      register,\n      unregister,\n      onStart,\n      onStop,\n      wait,\n      chains\n    }),\n    [register, unregister, transitionableChildren, onStart, onStop, chains, wait]\n  );\n}\nvar DEFAULT_TRANSITION_CHILD_TAG = import_react62.Fragment;\nvar TransitionChildRenderFeatures = 1 /* RenderStrategy */;\nfunction TransitionChildFn(props, ref) {\n  var _a3, _b2;\n  let {\n    // Whether or not to enable transitions on the current element (by exposing\n    // transition data). When set to false, the `Transition` component still\n    // acts as a transition boundary for `TransitionChild` components.\n    transition: transition2 = true,\n    // Event \"handlers\"\n    beforeEnter,\n    afterEnter,\n    beforeLeave,\n    afterLeave,\n    // Class names\n    enter,\n    enterFrom,\n    enterTo,\n    entered,\n    leave,\n    leaveFrom,\n    leaveTo,\n    ...theirProps\n  } = props;\n  let [localContainerElement, setLocalContainerElement] = (0, import_react62.useState)(null);\n  let container = (0, import_react62.useRef)(null);\n  let requiresRef = shouldForwardRef(props);\n  let transitionRef = useSyncRefs(\n    ...requiresRef ? [container, ref, setLocalContainerElement] : ref === null ? [] : [ref]\n  );\n  let strategy = ((_a3 = theirProps.unmount) != null ? _a3 : true) ? 0 /* Unmount */ : 1 /* Hidden */;\n  let { show, appear, initial } = useTransitionContext();\n  let [treeState, setState] = (0, import_react62.useState)(show ? \"visible\" /* Visible */ : \"hidden\" /* Hidden */);\n  let parentNesting = useParentNesting();\n  let { register, unregister } = parentNesting;\n  useIsoMorphicEffect(() => register(container), [register, container]);\n  useIsoMorphicEffect(() => {\n    if (strategy !== 1 /* Hidden */)\n      return;\n    if (!container.current)\n      return;\n    if (show && treeState !== \"visible\" /* Visible */) {\n      setState(\"visible\" /* Visible */);\n      return;\n    }\n    return match(treeState, {\n      [\"hidden\" /* Hidden */]: () => unregister(container),\n      [\"visible\" /* Visible */]: () => register(container)\n    });\n  }, [treeState, container, register, unregister, show, strategy]);\n  let ready = useServerHandoffComplete();\n  useIsoMorphicEffect(() => {\n    if (!requiresRef)\n      return;\n    if (ready && treeState === \"visible\" /* Visible */ && container.current === null) {\n      throw new Error(\"Did you forget to passthrough the `ref` to the actual DOM node?\");\n    }\n  }, [container, treeState, ready, requiresRef]);\n  let skip = initial && !appear;\n  let immediate = appear && show && initial;\n  let isTransitioning = (0, import_react62.useRef)(false);\n  let nesting = useNesting(() => {\n    if (isTransitioning.current)\n      return;\n    setState(\"hidden\" /* Hidden */);\n    unregister(container);\n  }, parentNesting);\n  let start = useEvent((show2) => {\n    isTransitioning.current = true;\n    let direction = show2 ? \"enter\" : \"leave\";\n    nesting.onStart(container, direction, (direction2) => {\n      if (direction2 === \"enter\")\n        beforeEnter == null ? void 0 : beforeEnter();\n      else if (direction2 === \"leave\")\n        beforeLeave == null ? void 0 : beforeLeave();\n    });\n  });\n  let end = useEvent((show2) => {\n    let direction = show2 ? \"enter\" : \"leave\";\n    isTransitioning.current = false;\n    nesting.onStop(container, direction, (direction2) => {\n      if (direction2 === \"enter\")\n        afterEnter == null ? void 0 : afterEnter();\n      else if (direction2 === \"leave\")\n        afterLeave == null ? void 0 : afterLeave();\n    });\n    if (direction === \"leave\" && !hasChildren(nesting)) {\n      setState(\"hidden\" /* Hidden */);\n      unregister(container);\n    }\n  });\n  (0, import_react62.useEffect)(() => {\n    if (requiresRef && transition2)\n      return;\n    start(show);\n    end(show);\n  }, [show, requiresRef, transition2]);\n  let enabled = (() => {\n    if (!transition2)\n      return false;\n    if (!requiresRef)\n      return false;\n    if (!ready)\n      return false;\n    if (skip)\n      return false;\n    return true;\n  })();\n  let [, transitionData] = useTransition(enabled, localContainerElement, show, { start, end });\n  let ourProps = compact({\n    ref: transitionRef,\n    className: ((_b2 = classNames(\n      // Incoming classes if any\n      // @ts-expect-error: className may not exist because not\n      // all components accept className (but all HTML elements do)\n      theirProps.className,\n      // Apply these classes immediately\n      immediate && enter,\n      immediate && enterFrom,\n      // Map data attributes to `enter`, `enterFrom` and `enterTo` classes\n      transitionData.enter && enter,\n      transitionData.enter && transitionData.closed && enterFrom,\n      transitionData.enter && !transitionData.closed && enterTo,\n      // Map data attributes to `leave`, `leaveFrom` and `leaveTo` classes\n      transitionData.leave && leave,\n      transitionData.leave && !transitionData.closed && leaveFrom,\n      transitionData.leave && transitionData.closed && leaveTo,\n      // Map data attributes to `entered` class (backwards compatibility)\n      !transitionData.transition && show && entered\n    )) == null ? void 0 : _b2.trim()) || void 0,\n    // If `className` is an empty string, we can omit it\n    ...transitionDataAttributes(transitionData)\n  });\n  let openClosedState = 0;\n  if (treeState === \"visible\" /* Visible */)\n    openClosedState |= 1 /* Open */;\n  if (treeState === \"hidden\" /* Hidden */)\n    openClosedState |= 2 /* Closed */;\n  if (show && treeState === \"hidden\" /* Hidden */)\n    openClosedState |= 8 /* Opening */;\n  if (!show && treeState === \"visible\" /* Visible */)\n    openClosedState |= 4 /* Closing */;\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react62.default.createElement(NestingContext.Provider, { value: nesting }, /* @__PURE__ */ import_react62.default.createElement(OpenClosedProvider, { value: openClosedState }, render2({\n    ourProps,\n    theirProps,\n    defaultTag: DEFAULT_TRANSITION_CHILD_TAG,\n    features: TransitionChildRenderFeatures,\n    visible: treeState === \"visible\" /* Visible */,\n    name: \"Transition.Child\"\n  })));\n}\nfunction TransitionRootFn(props, ref) {\n  let { show, appear = false, unmount = true, ...theirProps } = props;\n  let internalTransitionRef = (0, import_react62.useRef)(null);\n  let requiresRef = shouldForwardRef(props);\n  let transitionRef = useSyncRefs(\n    ...requiresRef ? [internalTransitionRef, ref] : ref === null ? [] : [ref]\n  );\n  useServerHandoffComplete();\n  let usesOpenClosedState = useOpenClosed();\n  if (show === void 0 && usesOpenClosedState !== null) {\n    show = (usesOpenClosedState & 1 /* Open */) === 1 /* Open */;\n  }\n  if (show === void 0) {\n    throw new Error(\"A <Transition /> is used but it is missing a `show={true | false}` prop.\");\n  }\n  let [state, setState] = (0, import_react62.useState)(show ? \"visible\" /* Visible */ : \"hidden\" /* Hidden */);\n  let nestingBag = useNesting(() => {\n    if (show)\n      return;\n    setState(\"hidden\" /* Hidden */);\n  });\n  let [initial, setInitial] = (0, import_react62.useState)(true);\n  let changes = (0, import_react62.useRef)([show]);\n  useIsoMorphicEffect(() => {\n    if (initial === false) {\n      return;\n    }\n    if (changes.current[changes.current.length - 1] !== show) {\n      changes.current.push(show);\n      setInitial(false);\n    }\n  }, [changes, show]);\n  let transitionBag = (0, import_react62.useMemo)(\n    () => ({ show, appear, initial }),\n    [show, appear, initial]\n  );\n  useIsoMorphicEffect(() => {\n    if (show) {\n      setState(\"visible\" /* Visible */);\n    } else if (!hasChildren(nestingBag) && internalTransitionRef.current !== null) {\n      setState(\"hidden\" /* Hidden */);\n    }\n  }, [show, nestingBag]);\n  let sharedProps = { unmount };\n  let beforeEnter = useEvent(() => {\n    var _a3;\n    if (initial)\n      setInitial(false);\n    (_a3 = props.beforeEnter) == null ? void 0 : _a3.call(props);\n  });\n  let beforeLeave = useEvent(() => {\n    var _a3;\n    if (initial)\n      setInitial(false);\n    (_a3 = props.beforeLeave) == null ? void 0 : _a3.call(props);\n  });\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react62.default.createElement(NestingContext.Provider, { value: nestingBag }, /* @__PURE__ */ import_react62.default.createElement(TransitionContext.Provider, { value: transitionBag }, render2({\n    ourProps: {\n      ...sharedProps,\n      as: import_react62.Fragment,\n      children: /* @__PURE__ */ import_react62.default.createElement(\n        InternalTransitionChild,\n        {\n          ref: transitionRef,\n          ...sharedProps,\n          ...theirProps,\n          beforeEnter,\n          beforeLeave\n        }\n      )\n    },\n    theirProps: {},\n    defaultTag: import_react62.Fragment,\n    features: TransitionChildRenderFeatures,\n    visible: state === \"visible\" /* Visible */,\n    name: \"Transition\"\n  })));\n}\nfunction ChildFn(props, ref) {\n  let hasTransitionContext = (0, import_react62.useContext)(TransitionContext) !== null;\n  let hasOpenClosedContext = useOpenClosed() !== null;\n  return /* @__PURE__ */ import_react62.default.createElement(import_react62.default.Fragment, null, !hasTransitionContext && hasOpenClosedContext ? /* @__PURE__ */ import_react62.default.createElement(TransitionRoot, { ref, ...props }) : /* @__PURE__ */ import_react62.default.createElement(InternalTransitionChild, { ref, ...props }));\n}\nvar TransitionRoot = forwardRefWithAs(TransitionRootFn);\nvar InternalTransitionChild = forwardRefWithAs(\n  TransitionChildFn\n);\nvar TransitionChild = forwardRefWithAs(ChildFn);\nvar Transition = Object.assign(TransitionRoot, {\n  /** @deprecated use `<TransitionChild>` instead of `<Transition.Child>` */\n  Child: TransitionChild,\n  /** @deprecated use `<Transition>` instead of `<Transition.Root>` */\n  Root: TransitionRoot\n});\n\n// src/components/dialog/dialog.tsx\nvar reducers2 = {\n  [0 /* SetTitleId */](state, action) {\n    if (state.titleId === action.id)\n      return state;\n    return { ...state, titleId: action.id };\n  }\n};\nvar DialogContext = (0, import_react63.createContext)(null);\nDialogContext.displayName = \"DialogContext\";\nfunction useDialogContext(component) {\n  let context = (0, import_react63.useContext)(DialogContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Dialog /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDialogContext);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer(state, action) {\n  return match(action.type, reducers2, state, action);\n}\nvar InternalDialog = forwardRefWithAs(function InternalDialog2(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-dialog-${internalId}`,\n    open,\n    onClose,\n    initialFocus,\n    role = \"dialog\",\n    autoFocus = true,\n    __demoMode = false,\n    unmount = false,\n    ...theirProps\n  } = props;\n  let didWarnOnRole = (0, import_react63.useRef)(false);\n  role = function() {\n    if (role === \"dialog\" || role === \"alertdialog\") {\n      return role;\n    }\n    if (!didWarnOnRole.current) {\n      didWarnOnRole.current = true;\n      console.warn(\n        `Invalid role [${role}] passed to <Dialog />. Only \\`dialog\\` and and \\`alertdialog\\` are supported. Using \\`dialog\\` instead.`\n      );\n    }\n    return \"dialog\";\n  }();\n  let usesOpenClosedState = useOpenClosed();\n  if (open === void 0 && usesOpenClosedState !== null) {\n    open = (usesOpenClosedState & 1 /* Open */) === 1 /* Open */;\n  }\n  let internalDialogRef = (0, import_react63.useRef)(null);\n  let dialogRef = useSyncRefs(internalDialogRef, ref);\n  let ownerDocument = useOwnerDocument(internalDialogRef);\n  let dialogState = open ? 0 /* Open */ : 1 /* Closed */;\n  let [state, dispatch] = (0, import_react63.useReducer)(stateReducer, {\n    titleId: null,\n    descriptionId: null,\n    panelRef: (0, import_react63.createRef)()\n  });\n  let close = useEvent(() => onClose(false));\n  let setTitleId = useEvent((id2) => dispatch({ type: 0 /* SetTitleId */, id: id2 }));\n  let ready = useServerHandoffComplete();\n  let enabled = ready ? dialogState === 0 /* Open */ : false;\n  let [portals, PortalWrapper] = useNestedPortals();\n  let defaultContainer = {\n    get current() {\n      var _a3;\n      return (_a3 = state.panelRef.current) != null ? _a3 : internalDialogRef.current;\n    }\n  };\n  let mainTreeNode = useMainTreeNode();\n  let { resolveContainers: resolveRootContainers } = useRootContainers({\n    mainTreeNode,\n    portals,\n    defaultContainers: [defaultContainer]\n  });\n  let isClosing = usesOpenClosedState !== null ? (usesOpenClosedState & 4 /* Closing */) === 4 /* Closing */ : false;\n  let inertOthersEnabled = __demoMode ? false : isClosing ? false : enabled;\n  useInertOthers(inertOthersEnabled, {\n    allowed: useEvent(() => {\n      var _a3, _b2;\n      return [\n        // Allow the headlessui-portal of the Dialog to be interactive. This\n        // contains the current dialog and the necessary focus guard elements.\n        (_b2 = (_a3 = internalDialogRef.current) == null ? void 0 : _a3.closest(\"[data-headlessui-portal]\")) != null ? _b2 : null\n      ];\n    }),\n    disallowed: useEvent(() => {\n      var _a3;\n      return [\n        // Disallow the \"main\" tree root node\n        (_a3 = mainTreeNode == null ? void 0 : mainTreeNode.closest(\"body > *:not(#headlessui-portal-root)\")) != null ? _a3 : null\n      ];\n    })\n  });\n  useOutsideClick(enabled, resolveRootContainers, (event) => {\n    event.preventDefault();\n    close();\n  });\n  useEscape(enabled, ownerDocument == null ? void 0 : ownerDocument.defaultView, (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    if (document.activeElement && \"blur\" in document.activeElement && typeof document.activeElement.blur === \"function\") {\n      document.activeElement.blur();\n    }\n    close();\n  });\n  let scrollLockEnabled = __demoMode ? false : isClosing ? false : enabled;\n  useScrollLock(scrollLockEnabled, ownerDocument, resolveRootContainers);\n  useOnDisappear(enabled, internalDialogRef, close);\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let contextBag = (0, import_react63.useMemo)(\n    () => [{ dialogState, close, setTitleId, unmount }, state],\n    [dialogState, state, close, setTitleId, unmount]\n  );\n  let slot = (0, import_react63.useMemo)(\n    () => ({ open: dialogState === 0 /* Open */ }),\n    [dialogState]\n  );\n  let ourProps = {\n    ref: dialogRef,\n    id,\n    role,\n    tabIndex: -1,\n    \"aria-modal\": __demoMode ? void 0 : dialogState === 0 /* Open */ ? true : void 0,\n    \"aria-labelledby\": state.titleId,\n    \"aria-describedby\": describedby,\n    unmount\n  };\n  let shouldMoveFocusInside = !useIsTouchDevice();\n  let focusTrapFeatures = 0 /* None */;\n  if (enabled && !__demoMode) {\n    focusTrapFeatures |= 8 /* RestoreFocus */;\n    focusTrapFeatures |= 2 /* TabLock */;\n    if (autoFocus) {\n      focusTrapFeatures |= 16 /* AutoFocus */;\n    }\n    if (shouldMoveFocusInside) {\n      focusTrapFeatures |= 1 /* InitialFocus */;\n    }\n  }\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react63.default.createElement(ResetOpenClosedProvider, null, /* @__PURE__ */ import_react63.default.createElement(ForcePortalRoot, { force: true }, /* @__PURE__ */ import_react63.default.createElement(Portal, null, /* @__PURE__ */ import_react63.default.createElement(DialogContext.Provider, { value: contextBag }, /* @__PURE__ */ import_react63.default.createElement(PortalGroup, { target: internalDialogRef }, /* @__PURE__ */ import_react63.default.createElement(ForcePortalRoot, { force: false }, /* @__PURE__ */ import_react63.default.createElement(DescriptionProvider, { slot }, /* @__PURE__ */ import_react63.default.createElement(PortalWrapper, null, /* @__PURE__ */ import_react63.default.createElement(\n    FocusTrap,\n    {\n      initialFocus,\n      initialFocusFallback: internalDialogRef,\n      containers: resolveRootContainers,\n      features: focusTrapFeatures\n    },\n    /* @__PURE__ */ import_react63.default.createElement(CloseProvider, { value: close }, render2({\n      ourProps,\n      theirProps,\n      slot,\n      defaultTag: DEFAULT_DIALOG_TAG,\n      features: DialogRenderFeatures,\n      visible: dialogState === 0 /* Open */,\n      name: \"Dialog\"\n    }))\n  )))))))));\n});\nvar DEFAULT_DIALOG_TAG = \"div\";\nvar DialogRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction DialogFn(props, ref) {\n  let { transition: transition2 = false, open, ...rest } = props;\n  let usesOpenClosedState = useOpenClosed();\n  let hasOpen = props.hasOwnProperty(\"open\") || usesOpenClosedState !== null;\n  let hasOnClose = props.hasOwnProperty(\"onClose\");\n  if (!hasOpen && !hasOnClose) {\n    throw new Error(\n      `You have to provide an \\`open\\` and an \\`onClose\\` prop to the \\`Dialog\\` component.`\n    );\n  }\n  if (!hasOpen) {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but forgot an \\`open\\` prop.`\n    );\n  }\n  if (!hasOnClose) {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but forgot an \\`onClose\\` prop.`\n    );\n  }\n  if (!usesOpenClosedState && typeof props.open !== \"boolean\") {\n    throw new Error(\n      `You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${props.open}`\n    );\n  }\n  if (typeof props.onClose !== \"function\") {\n    throw new Error(\n      `You provided an \\`onClose\\` prop to the \\`Dialog\\`, but the value is not a function. Received: ${props.onClose}`\n    );\n  }\n  if ((open !== void 0 || transition2) && !rest.static) {\n    return /* @__PURE__ */ import_react63.default.createElement(MainTreeProvider, null, /* @__PURE__ */ import_react63.default.createElement(Transition, { show: open, transition: transition2, unmount: rest.unmount }, /* @__PURE__ */ import_react63.default.createElement(InternalDialog, { ref, ...rest })));\n  }\n  return /* @__PURE__ */ import_react63.default.createElement(MainTreeProvider, null, /* @__PURE__ */ import_react63.default.createElement(InternalDialog, { ref, open, ...rest }));\n}\nvar DEFAULT_PANEL_TAG = \"div\";\nfunction PanelFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let { id = `headlessui-dialog-panel-${internalId}`, transition: transition2 = false, ...theirProps } = props;\n  let [{ dialogState, unmount }, state] = useDialogContext(\"Dialog.Panel\");\n  let panelRef = useSyncRefs(ref, state.panelRef);\n  let slot = (0, import_react63.useMemo)(\n    () => ({ open: dialogState === 0 /* Open */ }),\n    [dialogState]\n  );\n  let handleClick = useEvent((event) => {\n    event.stopPropagation();\n  });\n  let ourProps = {\n    ref: panelRef,\n    id,\n    onClick: handleClick\n  };\n  let Wrapper = transition2 ? TransitionChild : import_react63.Fragment;\n  let wrapperProps = transition2 ? { unmount } : {};\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react63.default.createElement(Wrapper, { ...wrapperProps }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG,\n    name: \"Dialog.Panel\"\n  }));\n}\nvar DEFAULT_BACKDROP_TAG = \"div\";\nfunction BackdropFn(props, ref) {\n  let { transition: transition2 = false, ...theirProps } = props;\n  let [{ dialogState, unmount }] = useDialogContext(\"Dialog.Backdrop\");\n  let slot = (0, import_react63.useMemo)(\n    () => ({ open: dialogState === 0 /* Open */ }),\n    [dialogState]\n  );\n  let ourProps = { ref, \"aria-hidden\": true };\n  let Wrapper = transition2 ? TransitionChild : import_react63.Fragment;\n  let wrapperProps = transition2 ? { unmount } : {};\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react63.default.createElement(Wrapper, { ...wrapperProps }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BACKDROP_TAG,\n    name: \"Dialog.Backdrop\"\n  }));\n}\nvar DEFAULT_TITLE_TAG = \"h2\";\nfunction TitleFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let { id = `headlessui-dialog-title-${internalId}`, ...theirProps } = props;\n  let [{ dialogState, setTitleId }] = useDialogContext(\"Dialog.Title\");\n  let titleRef = useSyncRefs(ref);\n  (0, import_react63.useEffect)(() => {\n    setTitleId(id);\n    return () => setTitleId(null);\n  }, [id, setTitleId]);\n  let slot = (0, import_react63.useMemo)(\n    () => ({ open: dialogState === 0 /* Open */ }),\n    [dialogState]\n  );\n  let ourProps = { ref: titleRef, id };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TITLE_TAG,\n    name: \"Dialog.Title\"\n  });\n}\nvar DialogRoot = forwardRefWithAs(DialogFn);\nvar DialogPanel = forwardRefWithAs(PanelFn);\nvar DialogBackdrop = forwardRefWithAs(BackdropFn);\nvar DialogTitle = forwardRefWithAs(TitleFn);\nvar DialogDescription = Description;\nvar Dialog = Object.assign(DialogRoot, {\n  /** @deprecated use `<DialogPanel>` instead of `<Dialog.Panel>` */\n  Panel: DialogPanel,\n  /** @deprecated use `<DialogTitle>` instead of `<Dialog.Title>` */\n  Title: DialogTitle,\n  /** @deprecated use `<Description>` instead of `<Dialog.Description>` */\n  Description\n});\n\n// src/components/disclosure/disclosure.tsx\nvar import_react65 = __toESM(require(\"react\"), 1);\n\n// src/utils/start-transition.ts\nvar import_react64 = __toESM(require(\"react\"), 1);\nvar _a2;\nvar startTransition = (\n  // Prefer React's `startTransition` if it's available.\n  (_a2 = import_react64.default.startTransition) != null ? _a2 : function startTransition2(cb) {\n    cb();\n  }\n);\n\n// src/components/disclosure/disclosure.tsx\nvar reducers3 = {\n  [0 /* ToggleDisclosure */]: (state) => ({\n    ...state,\n    disclosureState: match(state.disclosureState, {\n      [0 /* Open */]: 1 /* Closed */,\n      [1 /* Closed */]: 0 /* Open */\n    })\n  }),\n  [1 /* CloseDisclosure */]: (state) => {\n    if (state.disclosureState === 1 /* Closed */)\n      return state;\n    return { ...state, disclosureState: 1 /* Closed */ };\n  },\n  [2 /* SetButtonId */](state, action) {\n    if (state.buttonId === action.buttonId)\n      return state;\n    return { ...state, buttonId: action.buttonId };\n  },\n  [3 /* SetPanelId */](state, action) {\n    if (state.panelId === action.panelId)\n      return state;\n    return { ...state, panelId: action.panelId };\n  },\n  [4 /* SetButtonElement */](state, action) {\n    if (state.buttonElement === action.element)\n      return state;\n    return { ...state, buttonElement: action.element };\n  },\n  [5 /* SetPanelElement */](state, action) {\n    if (state.panelElement === action.element)\n      return state;\n    return { ...state, panelElement: action.element };\n  }\n};\nvar DisclosureContext = (0, import_react65.createContext)(null);\nDisclosureContext.displayName = \"DisclosureContext\";\nfunction useDisclosureContext(component) {\n  let context = (0, import_react65.useContext)(DisclosureContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Disclosure /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDisclosureContext);\n    throw err;\n  }\n  return context;\n}\nvar DisclosureAPIContext = (0, import_react65.createContext)(null);\nDisclosureAPIContext.displayName = \"DisclosureAPIContext\";\nfunction useDisclosureAPIContext(component) {\n  let context = (0, import_react65.useContext)(DisclosureAPIContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Disclosure /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useDisclosureAPIContext);\n    throw err;\n  }\n  return context;\n}\nvar DisclosurePanelContext = (0, import_react65.createContext)(null);\nDisclosurePanelContext.displayName = \"DisclosurePanelContext\";\nfunction useDisclosurePanelContext() {\n  return (0, import_react65.useContext)(DisclosurePanelContext);\n}\nfunction stateReducer2(state, action) {\n  return match(action.type, reducers3, state, action);\n}\nvar DEFAULT_DISCLOSURE_TAG = import_react65.Fragment;\nfunction DisclosureFn(props, ref) {\n  let { defaultOpen = false, ...theirProps } = props;\n  let internalDisclosureRef = (0, import_react65.useRef)(null);\n  let disclosureRef = useSyncRefs(\n    ref,\n    optionalRef(\n      (ref2) => {\n        internalDisclosureRef.current = ref2;\n      },\n      props.as === void 0 || // @ts-expect-error The `as` prop _can_ be a Fragment\n      props.as === import_react65.Fragment\n    )\n  );\n  let reducerBag = (0, import_react65.useReducer)(stateReducer2, {\n    disclosureState: defaultOpen ? 0 /* Open */ : 1 /* Closed */,\n    buttonElement: null,\n    panelElement: null,\n    buttonId: null,\n    panelId: null\n  });\n  let [{ disclosureState, buttonId }, dispatch] = reducerBag;\n  let close = useEvent((focusableElement) => {\n    dispatch({ type: 1 /* CloseDisclosure */ });\n    let ownerDocument = getOwnerDocument(internalDisclosureRef);\n    if (!ownerDocument)\n      return;\n    if (!buttonId)\n      return;\n    let restoreElement = (() => {\n      if (!focusableElement)\n        return ownerDocument.getElementById(buttonId);\n      if (focusableElement instanceof HTMLElement)\n        return focusableElement;\n      if (focusableElement.current instanceof HTMLElement)\n        return focusableElement.current;\n      return ownerDocument.getElementById(buttonId);\n    })();\n    restoreElement == null ? void 0 : restoreElement.focus();\n  });\n  let api = (0, import_react65.useMemo)(() => ({ close }), [close]);\n  let slot = (0, import_react65.useMemo)(() => {\n    return {\n      open: disclosureState === 0 /* Open */,\n      close\n    };\n  }, [disclosureState, close]);\n  let ourProps = {\n    ref: disclosureRef\n  };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react65.default.createElement(DisclosureContext.Provider, { value: reducerBag }, /* @__PURE__ */ import_react65.default.createElement(DisclosureAPIContext.Provider, { value: api }, /* @__PURE__ */ import_react65.default.createElement(CloseProvider, { value: close }, /* @__PURE__ */ import_react65.default.createElement(\n    OpenClosedProvider,\n    {\n      value: match(disclosureState, {\n        [0 /* Open */]: 1 /* Open */,\n        [1 /* Closed */]: 2 /* Closed */\n      })\n    },\n    render2({\n      ourProps,\n      theirProps,\n      slot,\n      defaultTag: DEFAULT_DISCLOSURE_TAG,\n      name: \"Disclosure\"\n    })\n  ))));\n}\nvar DEFAULT_BUTTON_TAG3 = \"button\";\nfunction ButtonFn3(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-disclosure-button-${internalId}`,\n    disabled = false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let [state, dispatch] = useDisclosureContext(\"Disclosure.Button\");\n  let panelContext = useDisclosurePanelContext();\n  let isWithinPanel = panelContext === null ? false : panelContext === state.panelId;\n  let internalButtonRef = (0, import_react65.useRef)(null);\n  let buttonRef = useSyncRefs(\n    internalButtonRef,\n    ref,\n    useEvent((element) => {\n      if (isWithinPanel)\n        return;\n      return dispatch({ type: 4 /* SetButtonElement */, element });\n    })\n  );\n  (0, import_react65.useEffect)(() => {\n    if (isWithinPanel)\n      return;\n    dispatch({ type: 2 /* SetButtonId */, buttonId: id });\n    return () => {\n      dispatch({ type: 2 /* SetButtonId */, buttonId: null });\n    };\n  }, [id, dispatch, isWithinPanel]);\n  let handleKeyDown = useEvent((event) => {\n    var _a3;\n    if (isWithinPanel) {\n      if (state.disclosureState === 1 /* Closed */)\n        return;\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          event.stopPropagation();\n          dispatch({ type: 0 /* ToggleDisclosure */ });\n          (_a3 = state.buttonElement) == null ? void 0 : _a3.focus();\n          break;\n      }\n    } else {\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          event.stopPropagation();\n          dispatch({ type: 0 /* ToggleDisclosure */ });\n          break;\n      }\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let handleClick = useEvent((event) => {\n    var _a3;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return;\n    if (disabled)\n      return;\n    if (isWithinPanel) {\n      dispatch({ type: 0 /* ToggleDisclosure */ });\n      (_a3 = state.buttonElement) == null ? void 0 : _a3.focus();\n    } else {\n      dispatch({ type: 0 /* ToggleDisclosure */ });\n    }\n  });\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let slot = (0, import_react65.useMemo)(() => {\n    return {\n      open: state.disclosureState === 0 /* Open */,\n      hover,\n      active,\n      disabled,\n      focus,\n      autofocus: autoFocus\n    };\n  }, [state, hover, active, focus, disabled, autoFocus]);\n  let type = useResolveButtonType(props, state.buttonElement);\n  let ourProps = isWithinPanel ? mergeProps(\n    {\n      ref: buttonRef,\n      type,\n      disabled: disabled || void 0,\n      autoFocus,\n      onKeyDown: handleKeyDown,\n      onClick: handleClick\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  ) : mergeProps(\n    {\n      ref: buttonRef,\n      id,\n      type,\n      \"aria-expanded\": state.disclosureState === 0 /* Open */,\n      \"aria-controls\": state.panelElement ? state.panelId : void 0,\n      disabled: disabled || void 0,\n      autoFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onClick: handleClick\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG3,\n    name: \"Disclosure.Button\"\n  });\n}\nvar DEFAULT_PANEL_TAG2 = \"div\";\nvar PanelRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction PanelFn2(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-disclosure-panel-${internalId}`,\n    transition: transition2 = false,\n    ...theirProps\n  } = props;\n  let [state, dispatch] = useDisclosureContext(\"Disclosure.Panel\");\n  let { close } = useDisclosureAPIContext(\"Disclosure.Panel\");\n  let [localPanelElement, setLocalPanelElement] = (0, import_react65.useState)(null);\n  let panelRef = useSyncRefs(\n    ref,\n    useEvent((element) => {\n      startTransition(() => dispatch({ type: 5 /* SetPanelElement */, element }));\n    }),\n    setLocalPanelElement\n  );\n  (0, import_react65.useEffect)(() => {\n    dispatch({ type: 3 /* SetPanelId */, panelId: id });\n    return () => {\n      dispatch({ type: 3 /* SetPanelId */, panelId: null });\n    };\n  }, [id, dispatch]);\n  let usesOpenClosedState = useOpenClosed();\n  let [visible, transitionData] = useTransition(\n    transition2,\n    localPanelElement,\n    usesOpenClosedState !== null ? (usesOpenClosedState & 1 /* Open */) === 1 /* Open */ : state.disclosureState === 0 /* Open */\n  );\n  let slot = (0, import_react65.useMemo)(() => {\n    return {\n      open: state.disclosureState === 0 /* Open */,\n      close\n    };\n  }, [state.disclosureState, close]);\n  let ourProps = {\n    ref: panelRef,\n    id,\n    ...transitionDataAttributes(transitionData)\n  };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react65.default.createElement(ResetOpenClosedProvider, null, /* @__PURE__ */ import_react65.default.createElement(DisclosurePanelContext.Provider, { value: state.panelId }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG2,\n    features: PanelRenderFeatures,\n    visible,\n    name: \"Disclosure.Panel\"\n  })));\n}\nvar DisclosureRoot = forwardRefWithAs(DisclosureFn);\nvar DisclosureButton = forwardRefWithAs(ButtonFn3);\nvar DisclosurePanel = forwardRefWithAs(PanelFn2);\nvar Disclosure = Object.assign(DisclosureRoot, {\n  /** @deprecated use `<DisclosureButton>` instead of `<Disclosure.Button>` */\n  Button: DisclosureButton,\n  /** @deprecated use `<DisclosurePanel>` instead of `<Disclosure.Panel>` */\n  Panel: DisclosurePanel\n});\n\n// src/components/field/field.tsx\nvar import_react66 = __toESM(require(\"react\"), 1);\nvar DEFAULT_FIELD_TAG = \"div\";\nfunction FieldFn(props, ref) {\n  let inputId = `headlessui-control-${(0, import_react19.useId)()}`;\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedBy, DescriptionProvider] = useDescriptions();\n  let providedDisabled = useDisabled();\n  let { disabled = providedDisabled || false, ...theirProps } = props;\n  let slot = (0, import_react66.useMemo)(() => ({ disabled }), [disabled]);\n  let ourProps = {\n    ref,\n    disabled: disabled || void 0,\n    \"aria-disabled\": disabled || void 0\n  };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react66.default.createElement(DisabledProvider, { value: disabled }, /* @__PURE__ */ import_react66.default.createElement(LabelProvider, { value: labelledby }, /* @__PURE__ */ import_react66.default.createElement(DescriptionProvider, { value: describedBy }, /* @__PURE__ */ import_react66.default.createElement(IdProvider, { id: inputId }, render2({\n    ourProps,\n    theirProps: {\n      ...theirProps,\n      children: /* @__PURE__ */ import_react66.default.createElement(FormFieldsProvider, null, typeof theirProps.children === \"function\" ? theirProps.children(slot) : theirProps.children)\n    },\n    slot,\n    defaultTag: DEFAULT_FIELD_TAG,\n    name: \"Field\"\n  })))));\n}\nvar Field = forwardRefWithAs(FieldFn);\n\n// src/components/fieldset/fieldset.tsx\nvar import_react68 = __toESM(require(\"react\"), 1);\n\n// src/hooks/use-resolved-tag.ts\nvar import_react67 = require(\"react\");\nfunction useResolvedTag(tag) {\n  let tagName = typeof tag === \"string\" ? tag : void 0;\n  let [resolvedTag, setResolvedTag] = (0, import_react67.useState)(tagName);\n  return [\n    // The resolved tag name\n    tagName != null ? tagName : resolvedTag,\n    // This callback should be passed to the `ref` of a component\n    (0, import_react67.useCallback)(\n      (ref) => {\n        if (tagName)\n          return;\n        if (ref instanceof HTMLElement) {\n          setResolvedTag(ref.tagName.toLowerCase());\n        }\n      },\n      [tagName]\n    )\n  ];\n}\n\n// src/components/fieldset/fieldset.tsx\nvar DEFAULT_FIELDSET_TAG = \"fieldset\";\nfunction FieldsetFn(props, ref) {\n  var _a3;\n  let providedDisabled = useDisabled();\n  let { disabled = providedDisabled || false, ...theirProps } = props;\n  let [tag, resolveTag] = useResolvedTag((_a3 = props.as) != null ? _a3 : DEFAULT_FIELDSET_TAG);\n  let fieldsetRef = useSyncRefs(ref, resolveTag);\n  let [labelledBy, LabelProvider] = useLabels();\n  let slot = (0, import_react68.useMemo)(() => ({ disabled }), [disabled]);\n  let ourProps = tag === \"fieldset\" ? {\n    ref: fieldsetRef,\n    \"aria-labelledby\": labelledBy,\n    disabled: disabled || void 0\n  } : {\n    ref: fieldsetRef,\n    role: \"group\",\n    \"aria-labelledby\": labelledBy,\n    \"aria-disabled\": disabled || void 0\n  };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react68.default.createElement(DisabledProvider, { value: disabled }, /* @__PURE__ */ import_react68.default.createElement(LabelProvider, null, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_FIELDSET_TAG,\n    name: \"Fieldset\"\n  })));\n}\nvar Fieldset = forwardRefWithAs(FieldsetFn);\n\n// src/components/input/input.tsx\nvar import_react69 = require(\"react\");\nvar DEFAULT_INPUT_TAG2 = \"input\";\nfunction InputFn2(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = providedId || `headlessui-input-${internalId}`,\n    disabled = providedDisabled || false,\n    autoFocus = false,\n    invalid = false,\n    ...theirProps\n  } = props;\n  let labelledBy = useLabelledBy();\n  let describedBy = useDescribedBy();\n  let { isFocused: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      \"aria-invalid\": invalid ? \"true\" : void 0,\n      disabled: disabled || void 0,\n      autoFocus\n    },\n    focusProps,\n    hoverProps\n  );\n  let slot = (0, import_react69.useMemo)(() => {\n    return { disabled, invalid, hover, focus, autofocus: autoFocus };\n  }, [disabled, invalid, hover, focus, autoFocus]);\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_INPUT_TAG2,\n    name: \"Input\"\n  });\n}\nvar Input = forwardRefWithAs(InputFn2);\n\n// src/components/legend/legend.tsx\nvar import_react70 = __toESM(require(\"react\"), 1);\nfunction LegendFn(props, ref) {\n  return /* @__PURE__ */ import_react70.default.createElement(Label, { as: \"div\", ref, ...props });\n}\nvar Legend = forwardRefWithAs(LegendFn);\n\n// src/components/listbox/listbox.tsx\nvar import_react74 = __toESM(require(\"react\"), 1);\nvar import_react_dom8 = require(\"react-dom\");\n\n// src/hooks/use-did-element-move.ts\nvar import_react71 = require(\"react\");\nfunction useDidElementMove(enabled, element) {\n  let elementPosition = (0, import_react71.useRef)({ left: 0, top: 0 });\n  useIsoMorphicEffect(() => {\n    if (!element)\n      return;\n    let DOMRect = element.getBoundingClientRect();\n    if (DOMRect)\n      elementPosition.current = DOMRect;\n  }, [enabled, element]);\n  if (element == null)\n    return false;\n  if (!enabled)\n    return false;\n  if (element === document.activeElement)\n    return false;\n  let buttonRect = element.getBoundingClientRect();\n  let didElementMove = buttonRect.top !== elementPosition.current.top || buttonRect.left !== elementPosition.current.left;\n  return didElementMove;\n}\n\n// src/hooks/use-text-value.ts\nvar import_react72 = require(\"react\");\n\n// src/utils/get-text-value.ts\nvar emojiRegex = /([\\u2700-\\u27BF]|[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])/g;\nfunction getTextContents(element) {\n  var _a3, _b2;\n  let currentInnerText = (_a3 = element.innerText) != null ? _a3 : \"\";\n  let copy = element.cloneNode(true);\n  if (!(copy instanceof HTMLElement)) {\n    return currentInnerText;\n  }\n  let dropped = false;\n  for (let child of copy.querySelectorAll('[hidden],[aria-hidden],[role=\"img\"]')) {\n    child.remove();\n    dropped = true;\n  }\n  let value = dropped ? (_b2 = copy.innerText) != null ? _b2 : \"\" : currentInnerText;\n  if (emojiRegex.test(value)) {\n    value = value.replace(emojiRegex, \"\");\n  }\n  return value;\n}\nfunction getTextValue(element) {\n  let label = element.getAttribute(\"aria-label\");\n  if (typeof label === \"string\")\n    return label.trim();\n  let labelledby = element.getAttribute(\"aria-labelledby\");\n  if (labelledby) {\n    let labels = labelledby.split(\" \").map((labelledby2) => {\n      let labelEl = document.getElementById(labelledby2);\n      if (labelEl) {\n        let label2 = labelEl.getAttribute(\"aria-label\");\n        if (typeof label2 === \"string\")\n          return label2.trim();\n        return getTextContents(labelEl).trim();\n      }\n      return null;\n    }).filter(Boolean);\n    if (labels.length > 0)\n      return labels.join(\", \");\n  }\n  return getTextContents(element).trim();\n}\n\n// src/hooks/use-text-value.ts\nfunction useTextValue(element) {\n  let cacheKey = (0, import_react72.useRef)(\"\");\n  let cacheValue = (0, import_react72.useRef)(\"\");\n  return useEvent(() => {\n    let el = element.current;\n    if (!el)\n      return \"\";\n    let currentKey = el.innerText;\n    if (cacheKey.current === currentKey) {\n      return cacheValue.current;\n    }\n    let value = getTextValue(el).trim().toLowerCase();\n    cacheKey.current = currentKey;\n    cacheValue.current = value;\n    return value;\n  });\n}\n\n// src/components/listbox/listbox-machine.ts\nfunction adjustOrderedState2(state, adjustment = (i) => i) {\n  let currentActiveOption = state.activeOptionIndex !== null ? state.options[state.activeOptionIndex] : null;\n  let sortedOptions = sortByDomNode(\n    adjustment(state.options.slice()),\n    (option) => option.dataRef.current.domRef.current\n  );\n  let adjustedActiveOptionIndex = currentActiveOption ? sortedOptions.indexOf(currentActiveOption) : null;\n  if (adjustedActiveOptionIndex === -1) {\n    adjustedActiveOptionIndex = null;\n  }\n  return {\n    options: sortedOptions,\n    activeOptionIndex: adjustedActiveOptionIndex\n  };\n}\nvar reducers4 = {\n  [1 /* CloseListbox */](state) {\n    if (state.dataRef.current.disabled)\n      return state;\n    if (state.listboxState === 1 /* Closed */)\n      return state;\n    return {\n      ...state,\n      activeOptionIndex: null,\n      listboxState: 1 /* Closed */,\n      __demoMode: false\n    };\n  },\n  [0 /* OpenListbox */](state) {\n    if (state.dataRef.current.disabled)\n      return state;\n    if (state.listboxState === 0 /* Open */)\n      return state;\n    let activeOptionIndex = state.activeOptionIndex;\n    let { isSelected } = state.dataRef.current;\n    let optionIdx = state.options.findIndex((option) => isSelected(option.dataRef.current.value));\n    if (optionIdx !== -1) {\n      activeOptionIndex = optionIdx;\n    }\n    return { ...state, listboxState: 0 /* Open */, activeOptionIndex, __demoMode: false };\n  },\n  [2 /* GoToOption */](state, action) {\n    var _a3, _b2, _c, _d, _e;\n    if (state.dataRef.current.disabled)\n      return state;\n    if (state.listboxState === 1 /* Closed */)\n      return state;\n    let base = {\n      ...state,\n      searchQuery: \"\",\n      activationTrigger: (_a3 = action.trigger) != null ? _a3 : 1 /* Other */,\n      __demoMode: false\n    };\n    if (action.focus === 5 /* Nothing */) {\n      return {\n        ...base,\n        activeOptionIndex: null\n      };\n    }\n    if (action.focus === 4 /* Specific */) {\n      return {\n        ...base,\n        activeOptionIndex: state.options.findIndex((o) => o.id === action.id)\n      };\n    } else if (action.focus === 1 /* Previous */) {\n      let activeOptionIdx = state.activeOptionIndex;\n      if (activeOptionIdx !== null) {\n        let currentDom = state.options[activeOptionIdx].dataRef.current.domRef;\n        let previousOptionIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.options,\n          resolveActiveIndex: () => state.activeOptionIndex,\n          resolveId: (option) => option.id,\n          resolveDisabled: (option) => option.dataRef.current.disabled\n        });\n        if (previousOptionIndex !== null) {\n          let previousDom = state.options[previousOptionIndex].dataRef.current.domRef;\n          if (\n            // Next to each other\n            ((_b2 = currentDom.current) == null ? void 0 : _b2.previousElementSibling) === previousDom.current || // Or already the first element\n            ((_c = previousDom.current) == null ? void 0 : _c.previousElementSibling) === null\n          ) {\n            return {\n              ...base,\n              activeOptionIndex: previousOptionIndex\n            };\n          }\n        }\n      }\n    } else if (action.focus === 2 /* Next */) {\n      let activeOptionIdx = state.activeOptionIndex;\n      if (activeOptionIdx !== null) {\n        let currentDom = state.options[activeOptionIdx].dataRef.current.domRef;\n        let nextOptionIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.options,\n          resolveActiveIndex: () => state.activeOptionIndex,\n          resolveId: (option) => option.id,\n          resolveDisabled: (option) => option.dataRef.current.disabled\n        });\n        if (nextOptionIndex !== null) {\n          let nextDom = state.options[nextOptionIndex].dataRef.current.domRef;\n          if (\n            // Next to each other\n            ((_d = currentDom.current) == null ? void 0 : _d.nextElementSibling) === nextDom.current || // Or already the last element\n            ((_e = nextDom.current) == null ? void 0 : _e.nextElementSibling) === null\n          ) {\n            return {\n              ...base,\n              activeOptionIndex: nextOptionIndex\n            };\n          }\n        }\n      }\n    }\n    let adjustedState = adjustOrderedState2(state);\n    let activeOptionIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.options,\n      resolveActiveIndex: () => adjustedState.activeOptionIndex,\n      resolveId: (option) => option.id,\n      resolveDisabled: (option) => option.dataRef.current.disabled\n    });\n    return {\n      ...base,\n      ...adjustedState,\n      activeOptionIndex\n    };\n  },\n  [3 /* Search */]: (state, action) => {\n    if (state.dataRef.current.disabled)\n      return state;\n    if (state.listboxState === 1 /* Closed */)\n      return state;\n    let wasAlreadySearching = state.searchQuery !== \"\";\n    let offset3 = wasAlreadySearching ? 0 : 1;\n    let searchQuery = state.searchQuery + action.value.toLowerCase();\n    let reOrderedOptions = state.activeOptionIndex !== null ? state.options.slice(state.activeOptionIndex + offset3).concat(state.options.slice(0, state.activeOptionIndex + offset3)) : state.options;\n    let matchingOption = reOrderedOptions.find(\n      (option) => {\n        var _a3;\n        return !option.dataRef.current.disabled && ((_a3 = option.dataRef.current.textValue) == null ? void 0 : _a3.startsWith(searchQuery));\n      }\n    );\n    let matchIdx = matchingOption ? state.options.indexOf(matchingOption) : -1;\n    if (matchIdx === -1 || matchIdx === state.activeOptionIndex)\n      return { ...state, searchQuery };\n    return {\n      ...state,\n      searchQuery,\n      activeOptionIndex: matchIdx,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [4 /* ClearSearch */](state) {\n    if (state.dataRef.current.disabled)\n      return state;\n    if (state.listboxState === 1 /* Closed */)\n      return state;\n    if (state.searchQuery === \"\")\n      return state;\n    return { ...state, searchQuery: \"\" };\n  },\n  [5 /* RegisterOptions */]: (state, action) => {\n    let options = state.options.concat(action.options);\n    let activeOptionIndex = state.activeOptionIndex;\n    if (state.activeOptionIndex === null) {\n      let { isSelected } = state.dataRef.current;\n      if (isSelected) {\n        let idx = options.findIndex((option) => isSelected == null ? void 0 : isSelected(option.dataRef.current.value));\n        if (idx !== -1)\n          activeOptionIndex = idx;\n      }\n    }\n    return {\n      ...state,\n      options,\n      activeOptionIndex,\n      pendingShouldSort: true\n    };\n  },\n  [6 /* UnregisterOptions */]: (state, action) => {\n    let options = state.options;\n    let idxs = [];\n    let ids = new Set(action.options);\n    for (let [idx, option] of options.entries()) {\n      if (ids.has(option.id)) {\n        idxs.push(idx);\n        ids.delete(option.id);\n        if (ids.size === 0)\n          break;\n      }\n    }\n    if (idxs.length > 0) {\n      options = options.slice();\n      for (let idx of idxs.reverse()) {\n        options.splice(idx, 1);\n      }\n    }\n    return {\n      ...state,\n      options,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [7 /* SetButtonElement */]: (state, action) => {\n    if (state.buttonElement === action.element)\n      return state;\n    return { ...state, buttonElement: action.element };\n  },\n  [8 /* SetOptionsElement */]: (state, action) => {\n    if (state.optionsElement === action.element)\n      return state;\n    return { ...state, optionsElement: action.element };\n  },\n  [9 /* SortOptions */]: (state) => {\n    if (!state.pendingShouldSort)\n      return state;\n    return {\n      ...state,\n      ...adjustOrderedState2(state),\n      pendingShouldSort: false\n    };\n  }\n};\nvar ListboxMachine = class extends Machine {\n  constructor(initialState) {\n    super(initialState);\n    __publicField(this, \"actions\", {\n      onChange: (newValue) => {\n        let { onChange, compare, mode, value } = this.state.dataRef.current;\n        return match(mode, {\n          [0 /* Single */]: () => {\n            return onChange == null ? void 0 : onChange(newValue);\n          },\n          [1 /* Multi */]: () => {\n            let copy = value.slice();\n            let idx = copy.findIndex((item) => compare(item, newValue));\n            if (idx === -1) {\n              copy.push(newValue);\n            } else {\n              copy.splice(idx, 1);\n            }\n            return onChange == null ? void 0 : onChange(copy);\n          }\n        });\n      },\n      registerOption: batch(() => {\n        let options = [];\n        let seen = /* @__PURE__ */ new Set();\n        return [\n          (id, dataRef) => {\n            if (seen.has(dataRef))\n              return;\n            seen.add(dataRef);\n            options.push({ id, dataRef });\n          },\n          () => {\n            seen.clear();\n            return this.send({ type: 5 /* RegisterOptions */, options: options.splice(0) });\n          }\n        ];\n      }),\n      unregisterOption: batch(() => {\n        let options = [];\n        return [\n          (id) => options.push(id),\n          () => {\n            this.send({ type: 6 /* UnregisterOptions */, options: options.splice(0) });\n          }\n        ];\n      }),\n      goToOption: batch(() => {\n        let last = null;\n        return [\n          (focus, trigger) => {\n            last = { type: 2 /* GoToOption */, ...focus, trigger };\n          },\n          () => last && this.send(last)\n        ];\n      }),\n      closeListbox: () => {\n        this.send({ type: 1 /* CloseListbox */ });\n      },\n      openListbox: () => {\n        this.send({ type: 0 /* OpenListbox */ });\n      },\n      selectActiveOption: () => {\n        if (this.state.activeOptionIndex !== null) {\n          let { dataRef, id } = this.state.options[this.state.activeOptionIndex];\n          this.actions.onChange(dataRef.current.value);\n          this.send({ type: 2 /* GoToOption */, focus: 4 /* Specific */, id });\n        }\n      },\n      selectOption: (id) => {\n        let option = this.state.options.find((item) => item.id === id);\n        if (!option)\n          return;\n        this.actions.onChange(option.dataRef.current.value);\n      },\n      search: (value) => {\n        this.send({ type: 3 /* Search */, value });\n      },\n      clearSearch: () => {\n        this.send({ type: 4 /* ClearSearch */ });\n      },\n      setButtonElement: (element) => {\n        this.send({ type: 7 /* SetButtonElement */, element });\n      },\n      setOptionsElement: (element) => {\n        this.send({ type: 8 /* SetOptionsElement */, element });\n      }\n    });\n    __publicField(this, \"selectors\", {\n      activeDescendantId(state) {\n        var _a3;\n        let activeOptionIndex = state.activeOptionIndex;\n        let options = state.options;\n        return activeOptionIndex === null ? void 0 : (_a3 = options[activeOptionIndex]) == null ? void 0 : _a3.id;\n      },\n      isActive(state, id) {\n        var _a3;\n        let activeOptionIndex = state.activeOptionIndex;\n        let options = state.options;\n        return activeOptionIndex !== null ? ((_a3 = options[activeOptionIndex]) == null ? void 0 : _a3.id) === id : false;\n      },\n      shouldScrollIntoView(state, id) {\n        if (state.__demoMode)\n          return false;\n        if (state.listboxState !== 0 /* Open */)\n          return false;\n        if (state.activationTrigger === 0 /* Pointer */)\n          return false;\n        return this.isActive(state, id);\n      }\n    });\n    this.on(5 /* RegisterOptions */, () => {\n      requestAnimationFrame(() => {\n        this.send({ type: 9 /* SortOptions */ });\n      });\n    });\n  }\n  static new({ __demoMode = false } = {}) {\n    return new ListboxMachine({\n      // @ts-expect-error TODO: Re-structure such that we don't need to ignore this\n      dataRef: { current: {} },\n      listboxState: __demoMode ? 0 /* Open */ : 1 /* Closed */,\n      options: [],\n      searchQuery: \"\",\n      activeOptionIndex: null,\n      activationTrigger: 1 /* Other */,\n      buttonElement: null,\n      optionsElement: null,\n      __demoMode\n    });\n  }\n  reduce(state, action) {\n    return match(action.type, reducers4, state, action);\n  }\n};\n\n// src/components/listbox/listbox-machine-glue.tsx\nvar import_react73 = require(\"react\");\nvar ListboxContext = (0, import_react73.createContext)(null);\nfunction useListboxMachineContext(component) {\n  let context = (0, import_react73.useContext)(ListboxContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Listbox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useListboxMachine);\n    throw err;\n  }\n  return context;\n}\nfunction useListboxMachine({ __demoMode = false } = {}) {\n  return (0, import_react73.useMemo)(() => ListboxMachine.new({ __demoMode }), []);\n}\n\n// src/components/listbox/listbox.tsx\nvar ListboxDataContext = (0, import_react74.createContext)(null);\nListboxDataContext.displayName = \"ListboxDataContext\";\nfunction useData2(component) {\n  let context = (0, import_react74.useContext)(ListboxDataContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Listbox /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useData2);\n    throw err;\n  }\n  return context;\n}\nvar DEFAULT_LISTBOX_TAG = import_react74.Fragment;\nfunction ListboxFn(props, ref) {\n  let providedDisabled = useDisabled();\n  let {\n    value: controlledValue,\n    defaultValue: _defaultValue,\n    form,\n    name,\n    onChange: controlledOnChange,\n    by,\n    invalid = false,\n    disabled = providedDisabled || false,\n    horizontal = false,\n    multiple = false,\n    __demoMode = false,\n    ...theirProps\n  } = props;\n  const orientation = horizontal ? \"horizontal\" : \"vertical\";\n  let listboxRef = useSyncRefs(ref);\n  let defaultValue = useDefaultValue(_defaultValue);\n  let [value = multiple ? [] : void 0, theirOnChange] = useControllable(\n    controlledValue,\n    controlledOnChange,\n    defaultValue\n  );\n  let machine = useListboxMachine({ __demoMode });\n  let optionsPropsRef = (0, import_react74.useRef)({ static: false, hold: false });\n  let listRef = (0, import_react74.useRef)(/* @__PURE__ */ new Map());\n  let compare = useByComparator(by);\n  let isSelected = (0, import_react74.useCallback)(\n    (compareValue) => match(data.mode, {\n      [1 /* Multi */]: () => {\n        return value.some((option) => compare(option, compareValue));\n      },\n      [0 /* Single */]: () => {\n        return compare(value, compareValue);\n      }\n    }),\n    [value]\n  );\n  let data = (0, import_react74.useMemo)(\n    () => ({\n      value,\n      disabled,\n      invalid,\n      mode: multiple ? 1 /* Multi */ : 0 /* Single */,\n      orientation,\n      onChange: theirOnChange,\n      compare,\n      isSelected,\n      optionsPropsRef,\n      listRef\n    }),\n    [\n      value,\n      disabled,\n      invalid,\n      multiple,\n      orientation,\n      theirOnChange,\n      compare,\n      isSelected,\n      optionsPropsRef,\n      listRef\n    ]\n  );\n  useIsoMorphicEffect(() => {\n    machine.state.dataRef.current = data;\n  }, [data]);\n  let listboxState = useSlice(machine, (state) => state.listboxState);\n  let outsideClickEnabled = listboxState === 0 /* Open */;\n  let [buttonElement, optionsElement] = useSlice(machine, (state) => [\n    state.buttonElement,\n    state.optionsElement\n  ]);\n  useOutsideClick(outsideClickEnabled, [buttonElement, optionsElement], (event, target) => {\n    machine.send({ type: 1 /* CloseListbox */ });\n    if (!isFocusableElement(target, 1 /* Loose */)) {\n      event.preventDefault();\n      buttonElement == null ? void 0 : buttonElement.focus();\n    }\n  });\n  let slot = (0, import_react74.useMemo)(() => {\n    return {\n      open: listboxState === 0 /* Open */,\n      disabled,\n      invalid,\n      value\n    };\n  }, [listboxState, disabled, invalid, value]);\n  let [labelledby, LabelProvider] = useLabels({ inherit: true });\n  let ourProps = { ref: listboxRef };\n  let reset = (0, import_react74.useCallback)(() => {\n    if (defaultValue === void 0)\n      return;\n    return theirOnChange == null ? void 0 : theirOnChange(defaultValue);\n  }, [theirOnChange, defaultValue]);\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react74.default.createElement(\n    LabelProvider,\n    {\n      value: labelledby,\n      props: { htmlFor: buttonElement == null ? void 0 : buttonElement.id },\n      slot: { open: listboxState === 0 /* Open */, disabled }\n    },\n    /* @__PURE__ */ import_react74.default.createElement(FloatingProvider, null, /* @__PURE__ */ import_react74.default.createElement(ListboxContext.Provider, { value: machine }, /* @__PURE__ */ import_react74.default.createElement(ListboxDataContext.Provider, { value: data }, /* @__PURE__ */ import_react74.default.createElement(\n      OpenClosedProvider,\n      {\n        value: match(listboxState, {\n          [0 /* Open */]: 1 /* Open */,\n          [1 /* Closed */]: 2 /* Closed */\n        })\n      },\n      name != null && value != null && /* @__PURE__ */ import_react74.default.createElement(\n        FormFields,\n        {\n          disabled,\n          data: { [name]: value },\n          form,\n          onReset: reset\n        }\n      ),\n      render2({\n        ourProps,\n        theirProps,\n        slot,\n        defaultTag: DEFAULT_LISTBOX_TAG,\n        name: \"Listbox\"\n      })\n    ))))\n  );\n}\nvar DEFAULT_BUTTON_TAG4 = \"button\";\nfunction ButtonFn4(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let data = useData2(\"Listbox.Button\");\n  let machine = useListboxMachineContext(\"Listbox.Button\");\n  let {\n    id = providedId || `headlessui-listbox-button-${internalId}`,\n    disabled = data.disabled || false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let buttonRef = useSyncRefs(ref, useFloatingReference(), machine.actions.setButtonElement);\n  let getFloatingReferenceProps = useFloatingReferenceProps();\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \"Enter\" /* Enter */:\n        attemptSubmit(event.currentTarget);\n        break;\n      case \" \" /* Space */:\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        (0, import_react_dom8.flushSync)(() => machine.actions.openListbox());\n        if (!data.value)\n          machine.actions.goToOption({ focus: 0 /* First */ });\n        break;\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        (0, import_react_dom8.flushSync)(() => machine.actions.openListbox());\n        if (!data.value)\n          machine.actions.goToOption({ focus: 3 /* Last */ });\n        break;\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let handleMouseDown = useEvent((event) => {\n    var _a3;\n    if (event.button !== 0)\n      return;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (machine.state.listboxState === 0 /* Open */) {\n      (0, import_react_dom8.flushSync)(() => machine.actions.closeListbox());\n      (_a3 = machine.state.buttonElement) == null ? void 0 : _a3.focus({ preventScroll: true });\n    } else {\n      event.preventDefault();\n      machine.actions.openListbox();\n    }\n  });\n  let handleKeyPress = useEvent((event) => event.preventDefault());\n  let labelledBy = useLabelledBy([id]);\n  let describedBy = useDescribedBy();\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let listboxState = useSlice(machine, (state) => state.listboxState);\n  let slot = (0, import_react74.useMemo)(() => {\n    return {\n      open: listboxState === 0 /* Open */,\n      active: active || listboxState === 0 /* Open */,\n      disabled,\n      invalid: data.invalid,\n      value: data.value,\n      hover,\n      focus,\n      autofocus: autoFocus\n    };\n  }, [listboxState, data.value, disabled, hover, focus, active, data.invalid, autoFocus]);\n  let open = useSlice(machine, (state) => state.listboxState === 0 /* Open */);\n  let [buttonElement, optionsElement] = useSlice(machine, (state) => [\n    state.buttonElement,\n    state.optionsElement\n  ]);\n  let ourProps = mergeProps(\n    getFloatingReferenceProps(),\n    {\n      ref: buttonRef,\n      id,\n      type: useResolveButtonType(props, buttonElement),\n      \"aria-haspopup\": \"listbox\",\n      \"aria-controls\": optionsElement == null ? void 0 : optionsElement.id,\n      \"aria-expanded\": open,\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      disabled: disabled || void 0,\n      autoFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onKeyPress: handleKeyPress,\n      onMouseDown: handleMouseDown\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG4,\n    name: \"Listbox.Button\"\n  });\n}\nvar SelectedOptionContext = (0, import_react74.createContext)(false);\nvar DEFAULT_OPTIONS_TAG2 = \"div\";\nvar OptionsRenderFeatures2 = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction OptionsFn2(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-listbox-options-${internalId}`,\n    anchor: rawAnchor,\n    portal = false,\n    modal = true,\n    transition: transition2 = false,\n    ...theirProps\n  } = props;\n  let anchor = useResolvedAnchor(rawAnchor);\n  let [localOptionsElement, setLocalOptionsElement] = (0, import_react74.useState)(null);\n  if (anchor) {\n    portal = true;\n  }\n  let data = useData2(\"Listbox.Options\");\n  let machine = useListboxMachineContext(\"Listbox.Options\");\n  let [listboxState, buttonElement, optionsElement, __demoMode] = useSlice(machine, (state) => [\n    state.listboxState,\n    state.buttonElement,\n    state.optionsElement,\n    state.__demoMode\n  ]);\n  let portalOwnerDocument = useOwnerDocument(buttonElement);\n  let ownerDocument = useOwnerDocument(optionsElement);\n  let usesOpenClosedState = useOpenClosed();\n  let [visible, transitionData] = useTransition(\n    transition2,\n    localOptionsElement,\n    usesOpenClosedState !== null ? (usesOpenClosedState & 1 /* Open */) === 1 /* Open */ : listboxState === 0 /* Open */\n  );\n  useOnDisappear(visible, buttonElement, machine.actions.closeListbox);\n  let scrollLockEnabled = __demoMode ? false : modal && listboxState === 0 /* Open */;\n  useScrollLock(scrollLockEnabled, ownerDocument);\n  let inertOthersEnabled = __demoMode ? false : modal && listboxState === 0 /* Open */;\n  useInertOthers(inertOthersEnabled, {\n    allowed: (0, import_react74.useCallback)(() => [buttonElement, optionsElement], [buttonElement, optionsElement])\n  });\n  let didElementMoveEnabled = listboxState !== 0 /* Open */;\n  let didButtonMove = useDidElementMove(didElementMoveEnabled, buttonElement);\n  let panelEnabled = didButtonMove ? false : visible;\n  let shouldFreeze = visible && listboxState === 1 /* Closed */;\n  let frozenValue = useFrozenData(shouldFreeze, data.value);\n  let isSelected = useEvent((compareValue) => data.compare(frozenValue, compareValue));\n  let selectedOptionIndex = useSlice(machine, (state) => {\n    var _a3;\n    if (anchor == null)\n      return null;\n    if (!((_a3 = anchor == null ? void 0 : anchor.to) == null ? void 0 : _a3.includes(\"selection\")))\n      return null;\n    let idx = state.options.findIndex((option) => isSelected(option.dataRef.current.value));\n    if (idx === -1)\n      idx = 0;\n    return idx;\n  });\n  let anchorOptions = (() => {\n    if (anchor == null)\n      return void 0;\n    if (selectedOptionIndex === null)\n      return { ...anchor, inner: void 0 };\n    let elements = Array.from(data.listRef.current.values());\n    return {\n      ...anchor,\n      inner: {\n        listRef: { current: elements },\n        index: selectedOptionIndex\n      }\n    };\n  })();\n  let [floatingRef, style] = useFloatingPanel(anchorOptions);\n  let getFloatingPanelProps = useFloatingPanelProps();\n  let optionsRef = useSyncRefs(\n    ref,\n    anchor ? floatingRef : null,\n    machine.actions.setOptionsElement,\n    setLocalOptionsElement\n  );\n  let searchDisposables = useDisposables();\n  (0, import_react74.useEffect)(() => {\n    var _a3;\n    let container = optionsElement;\n    if (!container)\n      return;\n    if (listboxState !== 0 /* Open */)\n      return;\n    if (container === ((_a3 = getOwnerDocument(container)) == null ? void 0 : _a3.activeElement))\n      return;\n    container == null ? void 0 : container.focus({ preventScroll: true });\n  }, [listboxState, optionsElement]);\n  let handleKeyDown = useEvent((event) => {\n    var _a3, _b2;\n    searchDisposables.dispose();\n    switch (event.key) {\n      case \" \" /* Space */:\n        if (machine.state.searchQuery !== \"\") {\n          event.preventDefault();\n          event.stopPropagation();\n          return machine.actions.search(event.key);\n        }\n      case \"Enter\" /* Enter */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (machine.state.activeOptionIndex !== null) {\n          let { dataRef } = machine.state.options[machine.state.activeOptionIndex];\n          machine.actions.onChange(dataRef.current.value);\n        }\n        if (data.mode === 0 /* Single */) {\n          (0, import_react_dom8.flushSync)(() => machine.actions.closeListbox());\n          (_a3 = machine.state.buttonElement) == null ? void 0 : _a3.focus({ preventScroll: true });\n        }\n        break;\n      case match(data.orientation, {\n        vertical: \"ArrowDown\" /* ArrowDown */,\n        horizontal: \"ArrowRight\" /* ArrowRight */\n      }):\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 2 /* Next */ });\n      case match(data.orientation, {\n        vertical: \"ArrowUp\" /* ArrowUp */,\n        horizontal: \"ArrowLeft\" /* ArrowLeft */\n      }):\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 1 /* Previous */ });\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 0 /* First */ });\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.actions.goToOption({ focus: 3 /* Last */ });\n      case \"Escape\" /* Escape */:\n        event.preventDefault();\n        event.stopPropagation();\n        (0, import_react_dom8.flushSync)(() => machine.actions.closeListbox());\n        (_b2 = machine.state.buttonElement) == null ? void 0 : _b2.focus({ preventScroll: true });\n        return;\n      case \"Tab\" /* Tab */:\n        event.preventDefault();\n        event.stopPropagation();\n        (0, import_react_dom8.flushSync)(() => machine.actions.closeListbox());\n        focusFrom(\n          machine.state.buttonElement,\n          event.shiftKey ? 2 /* Previous */ : 4 /* Next */\n        );\n        break;\n      default:\n        if (event.key.length === 1) {\n          machine.actions.search(event.key);\n          searchDisposables.setTimeout(() => machine.actions.clearSearch(), 350);\n        }\n        break;\n    }\n  });\n  let labelledby = useSlice(machine, (state) => {\n    var _a3;\n    return (_a3 = state.buttonElement) == null ? void 0 : _a3.id;\n  });\n  let slot = (0, import_react74.useMemo)(() => {\n    return {\n      open: listboxState === 0 /* Open */\n    };\n  }, [listboxState]);\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    id,\n    ref: optionsRef,\n    \"aria-activedescendant\": useSlice(machine, machine.selectors.activeDescendantId),\n    \"aria-multiselectable\": data.mode === 1 /* Multi */ ? true : void 0,\n    \"aria-labelledby\": labelledby,\n    \"aria-orientation\": data.orientation,\n    onKeyDown: handleKeyDown,\n    role: \"listbox\",\n    // When the `Listbox` is closed, it should not be focusable. This allows us\n    // to skip focusing the `ListboxOptions` when pressing the tab key on an\n    // open `Listbox`, and go to the next focusable element.\n    tabIndex: listboxState === 0 /* Open */ ? 0 : void 0,\n    style: {\n      ...theirProps.style,\n      ...style,\n      \"--button-width\": useElementSize(buttonElement, true).width\n    },\n    ...transitionDataAttributes(transitionData)\n  });\n  let render2 = useRender();\n  let newData = (0, import_react74.useMemo)(\n    () => data.mode === 1 /* Multi */ ? data : { ...data, isSelected },\n    [data, isSelected]\n  );\n  return /* @__PURE__ */ import_react74.default.createElement(Portal, { enabled: portal ? props.static || visible : false, ownerDocument: portalOwnerDocument }, /* @__PURE__ */ import_react74.default.createElement(ListboxDataContext.Provider, { value: newData }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTIONS_TAG2,\n    features: OptionsRenderFeatures2,\n    visible: panelEnabled,\n    name: \"Listbox.Options\"\n  })));\n}\nvar DEFAULT_OPTION_TAG2 = \"div\";\nfunction OptionFn2(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-listbox-option-${internalId}`,\n    disabled = false,\n    value,\n    ...theirProps\n  } = props;\n  let usedInSelectedOption = (0, import_react74.useContext)(SelectedOptionContext) === true;\n  let data = useData2(\"Listbox.Option\");\n  let machine = useListboxMachineContext(\"Listbox.Option\");\n  let active = useSlice(machine, (state) => machine.selectors.isActive(state, id));\n  let selected = data.isSelected(value);\n  let internalOptionRef = (0, import_react74.useRef)(null);\n  let getTextValue2 = useTextValue(internalOptionRef);\n  let bag = useLatestValue({\n    disabled,\n    value,\n    domRef: internalOptionRef,\n    get textValue() {\n      return getTextValue2();\n    }\n  });\n  let optionRef = useSyncRefs(ref, internalOptionRef, (el) => {\n    if (!el) {\n      data.listRef.current.delete(id);\n    } else {\n      data.listRef.current.set(id, el);\n    }\n  });\n  let shouldScrollIntoView = useSlice(\n    machine,\n    (state) => machine.selectors.shouldScrollIntoView(state, id)\n  );\n  useIsoMorphicEffect(() => {\n    if (!shouldScrollIntoView)\n      return;\n    return disposables().requestAnimationFrame(() => {\n      var _a3, _b2;\n      (_b2 = (_a3 = internalOptionRef.current) == null ? void 0 : _a3.scrollIntoView) == null ? void 0 : _b2.call(_a3, { block: \"nearest\" });\n    });\n  }, [shouldScrollIntoView, internalOptionRef]);\n  useIsoMorphicEffect(() => {\n    if (usedInSelectedOption)\n      return;\n    machine.actions.registerOption(id, bag);\n    return () => machine.actions.unregisterOption(id);\n  }, [bag, id, usedInSelectedOption]);\n  let handleClick = useEvent((event) => {\n    var _a3;\n    if (disabled)\n      return event.preventDefault();\n    machine.actions.onChange(value);\n    if (data.mode === 0 /* Single */) {\n      (0, import_react_dom8.flushSync)(() => machine.actions.closeListbox());\n      (_a3 = machine.state.buttonElement) == null ? void 0 : _a3.focus({ preventScroll: true });\n    }\n  });\n  let handleFocus = useEvent(() => {\n    if (disabled)\n      return machine.actions.goToOption({ focus: 5 /* Nothing */ });\n    machine.actions.goToOption({ focus: 4 /* Specific */, id });\n  });\n  let pointer = useTrackedPointer();\n  let handleEnter = useEvent((evt) => {\n    pointer.update(evt);\n    if (disabled)\n      return;\n    if (active)\n      return;\n    machine.actions.goToOption({ focus: 4 /* Specific */, id }, 0 /* Pointer */);\n  });\n  let handleMove = useEvent((evt) => {\n    if (!pointer.wasMoved(evt))\n      return;\n    if (disabled)\n      return;\n    if (active)\n      return;\n    machine.actions.goToOption({ focus: 4 /* Specific */, id }, 0 /* Pointer */);\n  });\n  let handleLeave = useEvent((evt) => {\n    if (!pointer.wasMoved(evt))\n      return;\n    if (disabled)\n      return;\n    if (!active)\n      return;\n    machine.actions.goToOption({ focus: 5 /* Nothing */ });\n  });\n  let slot = (0, import_react74.useMemo)(() => {\n    return {\n      active,\n      focus: active,\n      selected,\n      disabled,\n      selectedOption: selected && usedInSelectedOption\n    };\n  }, [active, selected, disabled, usedInSelectedOption]);\n  let ourProps = !usedInSelectedOption ? {\n    id,\n    ref: optionRef,\n    role: \"option\",\n    tabIndex: disabled === true ? void 0 : -1,\n    \"aria-disabled\": disabled === true ? true : void 0,\n    // According to the WAI-ARIA best practices, we should use aria-checked for\n    // multi-select,but Voice-Over disagrees. So we use aria-checked instead for\n    // both single and multi-select.\n    \"aria-selected\": selected,\n    disabled: void 0,\n    // Never forward the `disabled` prop\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerEnter: handleEnter,\n    onMouseEnter: handleEnter,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave\n  } : {};\n  let render2 = useRender();\n  if (!selected && usedInSelectedOption) {\n    return null;\n  }\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG2,\n    name: \"Listbox.Option\"\n  });\n}\nvar DEFAULT_SELECTED_OPTION_TAG = import_react74.Fragment;\nfunction SelectedFn(props, ref) {\n  let { options: children, placeholder, ...theirProps } = props;\n  let selectedRef = useSyncRefs(ref);\n  let ourProps = { ref: selectedRef };\n  let data = useData2(\"ListboxSelectedOption\");\n  let slot = (0, import_react74.useMemo)(() => ({}), []);\n  let shouldShowPlaceholder = data.value === void 0 || data.value === null || data.mode === 1 /* Multi */ && Array.isArray(data.value) && data.value.length === 0;\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react74.default.createElement(SelectedOptionContext.Provider, { value: true }, render2({\n    ourProps,\n    theirProps: {\n      ...theirProps,\n      children: /* @__PURE__ */ import_react74.default.createElement(import_react74.default.Fragment, null, placeholder && shouldShowPlaceholder ? placeholder : children)\n    },\n    slot,\n    defaultTag: DEFAULT_SELECTED_OPTION_TAG,\n    name: \"ListboxSelectedOption\"\n  }));\n}\nvar ListboxRoot = forwardRefWithAs(ListboxFn);\nvar ListboxButton = forwardRefWithAs(ButtonFn4);\nvar ListboxLabel = Label;\nvar ListboxOptions = forwardRefWithAs(OptionsFn2);\nvar ListboxOption = forwardRefWithAs(OptionFn2);\nvar ListboxSelectedOption = forwardRefWithAs(\n  SelectedFn\n);\nvar Listbox = Object.assign(ListboxRoot, {\n  /** @deprecated use `<ListboxButton>` instead of `<Listbox.Button>` */\n  Button: ListboxButton,\n  /** @deprecated use `<Label>` instead of `<Listbox.Label>` */\n  Label: ListboxLabel,\n  /** @deprecated use `<ListboxOptions>` instead of `<Listbox.Options>` */\n  Options: ListboxOptions,\n  /** @deprecated use `<ListboxOption>` instead of `<Listbox.Option>` */\n  Option: ListboxOption,\n  /** @deprecated use `<ListboxSelectedOption>` instead of `<Listbox.SelectedOption>` */\n  SelectedOption: ListboxSelectedOption\n});\n\n// src/components/menu/menu.tsx\nvar import_react76 = __toESM(require(\"react\"), 1);\nvar import_react_dom9 = require(\"react-dom\");\n\n// src/components/menu/menu-machine.ts\nfunction adjustOrderedState3(state, adjustment = (i) => i) {\n  let currentActiveItem = state.activeItemIndex !== null ? state.items[state.activeItemIndex] : null;\n  let sortedItems = sortByDomNode(\n    adjustment(state.items.slice()),\n    (item) => item.dataRef.current.domRef.current\n  );\n  let adjustedActiveItemIndex = currentActiveItem ? sortedItems.indexOf(currentActiveItem) : null;\n  if (adjustedActiveItemIndex === -1) {\n    adjustedActiveItemIndex = null;\n  }\n  return {\n    items: sortedItems,\n    activeItemIndex: adjustedActiveItemIndex\n  };\n}\nvar reducers5 = {\n  [1 /* CloseMenu */](state) {\n    if (state.menuState === 1 /* Closed */)\n      return state;\n    return {\n      ...state,\n      activeItemIndex: null,\n      pendingFocus: { focus: 5 /* Nothing */ },\n      menuState: 1 /* Closed */\n    };\n  },\n  [0 /* OpenMenu */](state, action) {\n    if (state.menuState === 0 /* Open */)\n      return state;\n    return {\n      ...state,\n      /* We can turn off demo mode once we re-open the `Menu` */\n      __demoMode: false,\n      pendingFocus: action.focus,\n      menuState: 0 /* Open */\n    };\n  },\n  [2 /* GoToItem */]: (state, action) => {\n    var _a3, _b2, _c, _d, _e;\n    if (state.menuState === 1 /* Closed */)\n      return state;\n    let base = {\n      ...state,\n      searchQuery: \"\",\n      activationTrigger: (_a3 = action.trigger) != null ? _a3 : 1 /* Other */,\n      __demoMode: false\n    };\n    if (action.focus === 5 /* Nothing */) {\n      return {\n        ...base,\n        activeItemIndex: null\n      };\n    }\n    if (action.focus === 4 /* Specific */) {\n      return {\n        ...base,\n        activeItemIndex: state.items.findIndex((o) => o.id === action.id)\n      };\n    } else if (action.focus === 1 /* Previous */) {\n      let activeItemIdx = state.activeItemIndex;\n      if (activeItemIdx !== null) {\n        let currentDom = state.items[activeItemIdx].dataRef.current.domRef;\n        let previousItemIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.items,\n          resolveActiveIndex: () => state.activeItemIndex,\n          resolveId: (item) => item.id,\n          resolveDisabled: (item) => item.dataRef.current.disabled\n        });\n        if (previousItemIndex !== null) {\n          let previousDom = state.items[previousItemIndex].dataRef.current.domRef;\n          if (\n            // Next to each other\n            ((_b2 = currentDom.current) == null ? void 0 : _b2.previousElementSibling) === previousDom.current || // Or already the first element\n            ((_c = previousDom.current) == null ? void 0 : _c.previousElementSibling) === null\n          ) {\n            return {\n              ...base,\n              activeItemIndex: previousItemIndex\n            };\n          }\n        }\n      }\n    } else if (action.focus === 2 /* Next */) {\n      let activeItemIdx = state.activeItemIndex;\n      if (activeItemIdx !== null) {\n        let currentDom = state.items[activeItemIdx].dataRef.current.domRef;\n        let nextItemIndex = calculateActiveIndex(action, {\n          resolveItems: () => state.items,\n          resolveActiveIndex: () => state.activeItemIndex,\n          resolveId: (item) => item.id,\n          resolveDisabled: (item) => item.dataRef.current.disabled\n        });\n        if (nextItemIndex !== null) {\n          let nextDom = state.items[nextItemIndex].dataRef.current.domRef;\n          if (\n            // Next to each other\n            ((_d = currentDom.current) == null ? void 0 : _d.nextElementSibling) === nextDom.current || // Or already the last element\n            ((_e = nextDom.current) == null ? void 0 : _e.nextElementSibling) === null\n          ) {\n            return {\n              ...base,\n              activeItemIndex: nextItemIndex\n            };\n          }\n        }\n      }\n    }\n    let adjustedState = adjustOrderedState3(state);\n    let activeItemIndex = calculateActiveIndex(action, {\n      resolveItems: () => adjustedState.items,\n      resolveActiveIndex: () => adjustedState.activeItemIndex,\n      resolveId: (item) => item.id,\n      resolveDisabled: (item) => item.dataRef.current.disabled\n    });\n    return {\n      ...base,\n      ...adjustedState,\n      activeItemIndex\n    };\n  },\n  [3 /* Search */]: (state, action) => {\n    let wasAlreadySearching = state.searchQuery !== \"\";\n    let offset3 = wasAlreadySearching ? 0 : 1;\n    let searchQuery = state.searchQuery + action.value.toLowerCase();\n    let reOrderedItems = state.activeItemIndex !== null ? state.items.slice(state.activeItemIndex + offset3).concat(state.items.slice(0, state.activeItemIndex + offset3)) : state.items;\n    let matchingItem = reOrderedItems.find(\n      (item) => {\n        var _a3;\n        return ((_a3 = item.dataRef.current.textValue) == null ? void 0 : _a3.startsWith(searchQuery)) && !item.dataRef.current.disabled;\n      }\n    );\n    let matchIdx = matchingItem ? state.items.indexOf(matchingItem) : -1;\n    if (matchIdx === -1 || matchIdx === state.activeItemIndex)\n      return { ...state, searchQuery };\n    return {\n      ...state,\n      searchQuery,\n      activeItemIndex: matchIdx,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [4 /* ClearSearch */](state) {\n    if (state.searchQuery === \"\")\n      return state;\n    return { ...state, searchQuery: \"\", searchActiveItemIndex: null };\n  },\n  [5 /* RegisterItems */]: (state, action) => {\n    let items = state.items.concat(action.items.map((item) => item));\n    let activeItemIndex = state.activeItemIndex;\n    if (state.pendingFocus.focus !== 5 /* Nothing */) {\n      activeItemIndex = calculateActiveIndex(state.pendingFocus, {\n        resolveItems: () => items,\n        resolveActiveIndex: () => state.activeItemIndex,\n        resolveId: (item) => item.id,\n        resolveDisabled: (item) => item.dataRef.current.disabled\n      });\n    }\n    return {\n      ...state,\n      items,\n      activeItemIndex,\n      pendingFocus: { focus: 5 /* Nothing */ },\n      pendingShouldSort: true\n    };\n  },\n  [6 /* UnregisterItems */]: (state, action) => {\n    let items = state.items;\n    let idxs = [];\n    let ids = new Set(action.items);\n    for (let [idx, item] of items.entries()) {\n      if (ids.has(item.id)) {\n        idxs.push(idx);\n        ids.delete(item.id);\n        if (ids.size === 0)\n          break;\n      }\n    }\n    if (idxs.length > 0) {\n      items = items.slice();\n      for (let idx of idxs.reverse()) {\n        items.splice(idx, 1);\n      }\n    }\n    return {\n      ...state,\n      items,\n      activationTrigger: 1 /* Other */\n    };\n  },\n  [7 /* SetButtonElement */]: (state, action) => {\n    if (state.buttonElement === action.element)\n      return state;\n    return { ...state, buttonElement: action.element };\n  },\n  [8 /* SetItemsElement */]: (state, action) => {\n    if (state.itemsElement === action.element)\n      return state;\n    return { ...state, itemsElement: action.element };\n  },\n  [9 /* SortItems */]: (state) => {\n    if (!state.pendingShouldSort)\n      return state;\n    return {\n      ...state,\n      ...adjustOrderedState3(state),\n      pendingShouldSort: false\n    };\n  }\n};\nvar MenuMachine = class extends Machine {\n  constructor(initialState) {\n    super(initialState);\n    __publicField(this, \"actions\", {\n      // Batched version to register multiple items at the same time\n      registerItem: batch(() => {\n        let items = [];\n        let seen = /* @__PURE__ */ new Set();\n        return [\n          (id, dataRef) => {\n            if (seen.has(dataRef))\n              return;\n            seen.add(dataRef);\n            items.push({ id, dataRef });\n          },\n          () => {\n            seen.clear();\n            return this.send({ type: 5 /* RegisterItems */, items: items.splice(0) });\n          }\n        ];\n      }),\n      unregisterItem: batch(() => {\n        let items = [];\n        return [\n          (id) => items.push(id),\n          () => this.send({ type: 6 /* UnregisterItems */, items: items.splice(0) })\n        ];\n      })\n    });\n    __publicField(this, \"selectors\", {\n      activeDescendantId(state) {\n        var _a3;\n        let activeItemIndex = state.activeItemIndex;\n        let items = state.items;\n        return activeItemIndex === null ? void 0 : (_a3 = items[activeItemIndex]) == null ? void 0 : _a3.id;\n      },\n      isActive(state, id) {\n        var _a3;\n        let activeItemIndex = state.activeItemIndex;\n        let items = state.items;\n        return activeItemIndex !== null ? ((_a3 = items[activeItemIndex]) == null ? void 0 : _a3.id) === id : false;\n      },\n      shouldScrollIntoView(state, id) {\n        if (state.__demoMode)\n          return false;\n        if (state.menuState !== 0 /* Open */)\n          return false;\n        if (state.activationTrigger === 0 /* Pointer */)\n          return false;\n        return this.isActive(state, id);\n      }\n    });\n    this.on(5 /* RegisterItems */, () => {\n      requestAnimationFrame(() => {\n        this.send({ type: 9 /* SortItems */ });\n      });\n    });\n  }\n  static new({ __demoMode = false } = {}) {\n    return new MenuMachine({\n      __demoMode,\n      menuState: __demoMode ? 0 /* Open */ : 1 /* Closed */,\n      buttonElement: null,\n      itemsElement: null,\n      items: [],\n      searchQuery: \"\",\n      activeItemIndex: null,\n      activationTrigger: 1 /* Other */,\n      pendingShouldSort: false,\n      pendingFocus: { focus: 5 /* Nothing */ }\n    });\n  }\n  reduce(state, action) {\n    return match(action.type, reducers5, state, action);\n  }\n};\n\n// src/components/menu/menu-machine-glue.tsx\nvar import_react75 = require(\"react\");\nvar MenuContext = (0, import_react75.createContext)(null);\nfunction useMenuMachineContext(component) {\n  let context = (0, import_react75.useContext)(MenuContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Menu /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useMenuMachine);\n    throw err;\n  }\n  return context;\n}\nfunction useMenuMachine({ __demoMode = false } = {}) {\n  return (0, import_react75.useMemo)(() => MenuMachine.new({ __demoMode }), []);\n}\n\n// src/components/menu/menu.tsx\nvar DEFAULT_MENU_TAG = import_react76.Fragment;\nfunction MenuFn(props, ref) {\n  let { __demoMode = false, ...theirProps } = props;\n  let machine = useMenuMachine({ __demoMode });\n  let [menuState, itemsElement, buttonElement] = useSlice(machine, (state) => [\n    state.menuState,\n    state.itemsElement,\n    state.buttonElement\n  ]);\n  let menuRef = useSyncRefs(ref);\n  let outsideClickEnabled = menuState === 0 /* Open */;\n  useOutsideClick(outsideClickEnabled, [buttonElement, itemsElement], (event, target) => {\n    var _a3;\n    machine.send({ type: 1 /* CloseMenu */ });\n    if (!isFocusableElement(target, 1 /* Loose */)) {\n      event.preventDefault();\n      (_a3 = machine.state.buttonElement) == null ? void 0 : _a3.focus();\n    }\n  });\n  let close = useEvent(() => {\n    machine.send({ type: 1 /* CloseMenu */ });\n  });\n  let slot = (0, import_react76.useMemo)(\n    () => ({ open: menuState === 0 /* Open */, close }),\n    [menuState, close]\n  );\n  let ourProps = { ref: menuRef };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react76.default.createElement(FloatingProvider, null, /* @__PURE__ */ import_react76.default.createElement(MenuContext.Provider, { value: machine }, /* @__PURE__ */ import_react76.default.createElement(\n    OpenClosedProvider,\n    {\n      value: match(menuState, {\n        [0 /* Open */]: 1 /* Open */,\n        [1 /* Closed */]: 2 /* Closed */\n      })\n    },\n    render2({\n      ourProps,\n      theirProps,\n      slot,\n      defaultTag: DEFAULT_MENU_TAG,\n      name: \"Menu\"\n    })\n  )));\n}\nvar DEFAULT_BUTTON_TAG5 = \"button\";\nfunction ButtonFn5(props, ref) {\n  let machine = useMenuMachineContext(\"Menu.Button\");\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-menu-button-${internalId}`,\n    disabled = false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let internalButtonRef = (0, import_react76.useRef)(null);\n  let getFloatingReferenceProps = useFloatingReferenceProps();\n  let buttonRef = useSyncRefs(\n    ref,\n    internalButtonRef,\n    useFloatingReference(),\n    useEvent((element) => machine.send({ type: 7 /* SetButtonElement */, element }))\n  );\n  let handleKeyDown = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n      case \"Enter\" /* Enter */:\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        machine.send({ type: 0 /* OpenMenu */, focus: { focus: 0 /* First */ } });\n        break;\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        machine.send({ type: 0 /* OpenMenu */, focus: { focus: 3 /* Last */ } });\n        break;\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let [menuState, itemsElement] = useSlice(machine, (state) => [\n    state.menuState,\n    state.itemsElement\n  ]);\n  let handleMouseDown = useEvent((event) => {\n    var _a3;\n    if (event.button !== 0)\n      return;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (disabled)\n      return;\n    if (menuState === 0 /* Open */) {\n      (0, import_react_dom9.flushSync)(() => machine.send({ type: 1 /* CloseMenu */ }));\n      (_a3 = internalButtonRef.current) == null ? void 0 : _a3.focus({ preventScroll: true });\n    } else {\n      event.preventDefault();\n      machine.send({\n        type: 0 /* OpenMenu */,\n        focus: { focus: 5 /* Nothing */ },\n        trigger: 0 /* Pointer */\n      });\n    }\n  });\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let slot = (0, import_react76.useMemo)(() => {\n    return {\n      open: menuState === 0 /* Open */,\n      active: active || menuState === 0 /* Open */,\n      disabled,\n      hover,\n      focus,\n      autofocus: autoFocus\n    };\n  }, [menuState, hover, focus, active, disabled, autoFocus]);\n  let ourProps = mergeProps(\n    getFloatingReferenceProps(),\n    {\n      ref: buttonRef,\n      id,\n      type: useResolveButtonType(props, internalButtonRef.current),\n      \"aria-haspopup\": \"menu\",\n      \"aria-controls\": itemsElement == null ? void 0 : itemsElement.id,\n      \"aria-expanded\": menuState === 0 /* Open */,\n      disabled: disabled || void 0,\n      autoFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onMouseDown: handleMouseDown\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG5,\n    name: \"Menu.Button\"\n  });\n}\nvar DEFAULT_ITEMS_TAG = \"div\";\nvar ItemsRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction ItemsFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-menu-items-${internalId}`,\n    anchor: rawAnchor,\n    portal = false,\n    modal = true,\n    transition: transition2 = false,\n    ...theirProps\n  } = props;\n  let anchor = useResolvedAnchor(rawAnchor);\n  let machine = useMenuMachineContext(\"Menu.Items\");\n  let [floatingRef, style] = useFloatingPanel(anchor);\n  let getFloatingPanelProps = useFloatingPanelProps();\n  let [localItemsElement, setLocalItemsElement] = (0, import_react76.useState)(null);\n  let itemsRef = useSyncRefs(\n    ref,\n    anchor ? floatingRef : null,\n    useEvent((element) => machine.send({ type: 8 /* SetItemsElement */, element })),\n    setLocalItemsElement\n  );\n  let [menuState, buttonElement] = useSlice(machine, (state) => [\n    state.menuState,\n    state.buttonElement\n  ]);\n  let portalOwnerDocument = useOwnerDocument(buttonElement);\n  let ownerDocument = useOwnerDocument(localItemsElement);\n  if (anchor) {\n    portal = true;\n  }\n  let usesOpenClosedState = useOpenClosed();\n  let [visible, transitionData] = useTransition(\n    transition2,\n    localItemsElement,\n    usesOpenClosedState !== null ? (usesOpenClosedState & 1 /* Open */) === 1 /* Open */ : menuState === 0 /* Open */\n  );\n  useOnDisappear(visible, buttonElement, () => {\n    machine.send({ type: 1 /* CloseMenu */ });\n  });\n  let __demoMode = useSlice(machine, (state) => state.__demoMode);\n  let scrollLockEnabled = __demoMode ? false : modal && menuState === 0 /* Open */;\n  useScrollLock(scrollLockEnabled, ownerDocument);\n  let inertOthersEnabled = __demoMode ? false : modal && menuState === 0 /* Open */;\n  useInertOthers(inertOthersEnabled, {\n    allowed: (0, import_react76.useCallback)(\n      () => [buttonElement, localItemsElement],\n      [buttonElement, localItemsElement]\n    )\n  });\n  let didButtonMoveEnabled = menuState !== 0 /* Open */;\n  let didButtonMove = useDidElementMove(didButtonMoveEnabled, buttonElement);\n  let panelEnabled = didButtonMove ? false : visible;\n  (0, import_react76.useEffect)(() => {\n    let container = localItemsElement;\n    if (!container)\n      return;\n    if (menuState !== 0 /* Open */)\n      return;\n    if (container === (ownerDocument == null ? void 0 : ownerDocument.activeElement))\n      return;\n    container.focus({ preventScroll: true });\n  }, [menuState, localItemsElement, ownerDocument]);\n  useTreeWalker(menuState === 0 /* Open */, {\n    container: localItemsElement,\n    accept(node) {\n      if (node.getAttribute(\"role\") === \"menuitem\")\n        return NodeFilter.FILTER_REJECT;\n      if (node.hasAttribute(\"role\"))\n        return NodeFilter.FILTER_SKIP;\n      return NodeFilter.FILTER_ACCEPT;\n    },\n    walk(node) {\n      node.setAttribute(\"role\", \"none\");\n    }\n  });\n  let searchDisposables = useDisposables();\n  let handleKeyDown = useEvent((event) => {\n    var _a3, _b2, _c;\n    searchDisposables.dispose();\n    switch (event.key) {\n      case \" \" /* Space */:\n        if (machine.state.searchQuery !== \"\") {\n          event.preventDefault();\n          event.stopPropagation();\n          return machine.send({ type: 3 /* Search */, value: event.key });\n        }\n      case \"Enter\" /* Enter */:\n        event.preventDefault();\n        event.stopPropagation();\n        if (machine.state.activeItemIndex !== null) {\n          let { dataRef } = machine.state.items[machine.state.activeItemIndex];\n          (_b2 = (_a3 = dataRef.current) == null ? void 0 : _a3.domRef.current) == null ? void 0 : _b2.click();\n        }\n        machine.send({ type: 1 /* CloseMenu */ });\n        restoreFocusIfNecessary(machine.state.buttonElement);\n        break;\n      case \"ArrowDown\" /* ArrowDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.send({ type: 2 /* GoToItem */, focus: 2 /* Next */ });\n      case \"ArrowUp\" /* ArrowUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.send({ type: 2 /* GoToItem */, focus: 1 /* Previous */ });\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.send({ type: 2 /* GoToItem */, focus: 0 /* First */ });\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return machine.send({ type: 2 /* GoToItem */, focus: 3 /* Last */ });\n      case \"Escape\" /* Escape */:\n        event.preventDefault();\n        event.stopPropagation();\n        (0, import_react_dom9.flushSync)(() => machine.send({ type: 1 /* CloseMenu */ }));\n        (_c = machine.state.buttonElement) == null ? void 0 : _c.focus({ preventScroll: true });\n        break;\n      case \"Tab\" /* Tab */:\n        event.preventDefault();\n        event.stopPropagation();\n        (0, import_react_dom9.flushSync)(() => machine.send({ type: 1 /* CloseMenu */ }));\n        focusFrom(\n          machine.state.buttonElement,\n          event.shiftKey ? 2 /* Previous */ : 4 /* Next */\n        );\n        break;\n      default:\n        if (event.key.length === 1) {\n          machine.send({ type: 3 /* Search */, value: event.key });\n          searchDisposables.setTimeout(() => machine.send({ type: 4 /* ClearSearch */ }), 350);\n        }\n        break;\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    switch (event.key) {\n      case \" \" /* Space */:\n        event.preventDefault();\n        break;\n    }\n  });\n  let slot = (0, import_react76.useMemo)(() => {\n    return {\n      open: menuState === 0 /* Open */\n    };\n  }, [menuState]);\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    \"aria-activedescendant\": useSlice(machine, machine.selectors.activeDescendantId),\n    \"aria-labelledby\": useSlice(machine, (state) => {\n      var _a3;\n      return (_a3 = state.buttonElement) == null ? void 0 : _a3.id;\n    }),\n    id,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp,\n    role: \"menu\",\n    // When the `Menu` is closed, it should not be focusable. This allows us\n    // to skip focusing the `MenuItems` when pressing the tab key on an\n    // open `Menu`, and go to the next focusable element.\n    tabIndex: menuState === 0 /* Open */ ? 0 : void 0,\n    ref: itemsRef,\n    style: {\n      ...theirProps.style,\n      ...style,\n      \"--button-width\": useElementSize(buttonElement, true).width\n    },\n    ...transitionDataAttributes(transitionData)\n  });\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react76.default.createElement(Portal, { enabled: portal ? props.static || visible : false, ownerDocument: portalOwnerDocument }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_ITEMS_TAG,\n    features: ItemsRenderFeatures,\n    visible: panelEnabled,\n    name: \"Menu.Items\"\n  }));\n}\nvar DEFAULT_ITEM_TAG = import_react76.Fragment;\nfunction ItemFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let { id = `headlessui-menu-item-${internalId}`, disabled = false, ...theirProps } = props;\n  let machine = useMenuMachineContext(\"Menu.Item\");\n  let active = useSlice(machine, (state) => machine.selectors.isActive(state, id));\n  let internalItemRef = (0, import_react76.useRef)(null);\n  let itemRef = useSyncRefs(ref, internalItemRef);\n  let shouldScrollIntoView = useSlice(\n    machine,\n    (state) => machine.selectors.shouldScrollIntoView(state, id)\n  );\n  useIsoMorphicEffect(() => {\n    if (!shouldScrollIntoView)\n      return;\n    return disposables().requestAnimationFrame(() => {\n      var _a3, _b2;\n      (_b2 = (_a3 = internalItemRef.current) == null ? void 0 : _a3.scrollIntoView) == null ? void 0 : _b2.call(_a3, { block: \"nearest\" });\n    });\n  }, [shouldScrollIntoView, internalItemRef]);\n  let getTextValue2 = useTextValue(internalItemRef);\n  let bag = (0, import_react76.useRef)({\n    disabled,\n    domRef: internalItemRef,\n    get textValue() {\n      return getTextValue2();\n    }\n  });\n  useIsoMorphicEffect(() => {\n    bag.current.disabled = disabled;\n  }, [bag, disabled]);\n  useIsoMorphicEffect(() => {\n    machine.actions.registerItem(id, bag);\n    return () => machine.actions.unregisterItem(id);\n  }, [bag, id]);\n  let close = useEvent(() => {\n    machine.send({ type: 1 /* CloseMenu */ });\n  });\n  let handleClick = useEvent((event) => {\n    if (disabled)\n      return event.preventDefault();\n    machine.send({ type: 1 /* CloseMenu */ });\n    restoreFocusIfNecessary(machine.state.buttonElement);\n  });\n  let handleFocus = useEvent(() => {\n    if (disabled)\n      return machine.send({ type: 2 /* GoToItem */, focus: 5 /* Nothing */ });\n    machine.send({ type: 2 /* GoToItem */, focus: 4 /* Specific */, id });\n  });\n  let pointer = useTrackedPointer();\n  let handleEnter = useEvent((evt) => {\n    pointer.update(evt);\n    if (disabled)\n      return;\n    if (active)\n      return;\n    machine.send({\n      type: 2 /* GoToItem */,\n      focus: 4 /* Specific */,\n      id,\n      trigger: 0 /* Pointer */\n    });\n  });\n  let handleMove = useEvent((evt) => {\n    if (!pointer.wasMoved(evt))\n      return;\n    if (disabled)\n      return;\n    if (active)\n      return;\n    machine.send({\n      type: 2 /* GoToItem */,\n      focus: 4 /* Specific */,\n      id,\n      trigger: 0 /* Pointer */\n    });\n  });\n  let handleLeave = useEvent((evt) => {\n    if (!pointer.wasMoved(evt))\n      return;\n    if (disabled)\n      return;\n    if (!active)\n      return;\n    machine.send({ type: 2 /* GoToItem */, focus: 5 /* Nothing */ });\n  });\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let slot = (0, import_react76.useMemo)(\n    () => ({ active, focus: active, disabled, close }),\n    [active, disabled, close]\n  );\n  let ourProps = {\n    id,\n    ref: itemRef,\n    role: \"menuitem\",\n    tabIndex: disabled === true ? void 0 : -1,\n    \"aria-disabled\": disabled === true ? true : void 0,\n    \"aria-labelledby\": labelledby,\n    \"aria-describedby\": describedby,\n    disabled: void 0,\n    // Never forward the `disabled` prop\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onPointerEnter: handleEnter,\n    onMouseEnter: handleEnter,\n    onPointerMove: handleMove,\n    onMouseMove: handleMove,\n    onPointerLeave: handleLeave,\n    onMouseLeave: handleLeave\n  };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react76.default.createElement(LabelProvider, null, /* @__PURE__ */ import_react76.default.createElement(DescriptionProvider, null, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_ITEM_TAG,\n    name: \"Menu.Item\"\n  })));\n}\nvar DEFAULT_SECTION_TAG = \"div\";\nfunction SectionFn(props, ref) {\n  let [labelledby, LabelProvider] = useLabels();\n  let theirProps = props;\n  let ourProps = { ref, \"aria-labelledby\": labelledby, role: \"group\" };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react76.default.createElement(LabelProvider, null, render2({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_SECTION_TAG,\n    name: \"Menu.Section\"\n  }));\n}\nvar DEFAULT_HEADING_TAG = \"header\";\nfunction HeadingFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let { id = `headlessui-menu-heading-${internalId}`, ...theirProps } = props;\n  let context = useLabelContext();\n  useIsoMorphicEffect(() => context.register(id), [id, context.register]);\n  let ourProps = { id, ref, role: \"presentation\", ...context.props };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_HEADING_TAG,\n    name: \"Menu.Heading\"\n  });\n}\nvar DEFAULT_SEPARATOR_TAG = \"div\";\nfunction SeparatorFn(props, ref) {\n  let theirProps = props;\n  let ourProps = { ref, role: \"separator\" };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot: {},\n    defaultTag: DEFAULT_SEPARATOR_TAG,\n    name: \"Menu.Separator\"\n  });\n}\nvar MenuRoot = forwardRefWithAs(MenuFn);\nvar MenuButton = forwardRefWithAs(ButtonFn5);\nvar MenuItems = forwardRefWithAs(ItemsFn);\nvar MenuItem = forwardRefWithAs(ItemFn);\nvar MenuSection = forwardRefWithAs(SectionFn);\nvar MenuHeading = forwardRefWithAs(HeadingFn);\nvar MenuSeparator = forwardRefWithAs(SeparatorFn);\nvar Menu = Object.assign(MenuRoot, {\n  /** @deprecated use `<MenuButton>` instead of `<Menu.Button>` */\n  Button: MenuButton,\n  /** @deprecated use `<MenuItems>` instead of `<Menu.Items>` */\n  Items: MenuItems,\n  /** @deprecated use `<MenuItem>` instead of `<Menu.Item>` */\n  Item: MenuItem,\n  /** @deprecated use `<MenuSection>` instead of `<Menu.Section>` */\n  Section: MenuSection,\n  /** @deprecated use `<MenuHeading>` instead of `<Menu.Heading>` */\n  Heading: MenuHeading,\n  /** @deprecated use `<MenuSeparator>` instead of `<Menu.Separator>` */\n  Separator: MenuSeparator\n});\n\n// src/components/popover/popover.tsx\nvar import_react77 = __toESM(require(\"react\"), 1);\nvar reducers6 = {\n  [0 /* TogglePopover */]: (state) => {\n    return {\n      ...state,\n      popoverState: match(state.popoverState, {\n        [0 /* Open */]: 1 /* Closed */,\n        [1 /* Closed */]: 0 /* Open */\n      }),\n      __demoMode: false\n    };\n  },\n  [1 /* ClosePopover */](state) {\n    if (state.popoverState === 1 /* Closed */)\n      return state;\n    return { ...state, popoverState: 1 /* Closed */, __demoMode: false };\n  },\n  [2 /* SetButton */](state, action) {\n    if (state.button === action.button)\n      return state;\n    return { ...state, button: action.button };\n  },\n  [3 /* SetButtonId */](state, action) {\n    if (state.buttonId === action.buttonId)\n      return state;\n    return { ...state, buttonId: action.buttonId };\n  },\n  [4 /* SetPanel */](state, action) {\n    if (state.panel === action.panel)\n      return state;\n    return { ...state, panel: action.panel };\n  },\n  [5 /* SetPanelId */](state, action) {\n    if (state.panelId === action.panelId)\n      return state;\n    return { ...state, panelId: action.panelId };\n  }\n};\nvar PopoverContext = (0, import_react77.createContext)(null);\nPopoverContext.displayName = \"PopoverContext\";\nfunction usePopoverContext(component) {\n  let context = (0, import_react77.useContext)(PopoverContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Popover /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, usePopoverContext);\n    throw err;\n  }\n  return context;\n}\nvar PopoverAPIContext = (0, import_react77.createContext)(null);\nPopoverAPIContext.displayName = \"PopoverAPIContext\";\nfunction usePopoverAPIContext(component) {\n  let context = (0, import_react77.useContext)(PopoverAPIContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Popover /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, usePopoverAPIContext);\n    throw err;\n  }\n  return context;\n}\nvar PopoverGroupContext = (0, import_react77.createContext)(null);\nPopoverGroupContext.displayName = \"PopoverGroupContext\";\nfunction usePopoverGroupContext() {\n  return (0, import_react77.useContext)(PopoverGroupContext);\n}\nvar PopoverPanelContext = (0, import_react77.createContext)(null);\nPopoverPanelContext.displayName = \"PopoverPanelContext\";\nfunction usePopoverPanelContext() {\n  return (0, import_react77.useContext)(PopoverPanelContext);\n}\nfunction stateReducer3(state, action) {\n  return match(action.type, reducers6, state, action);\n}\nvar DEFAULT_POPOVER_TAG = \"div\";\nfunction PopoverFn(props, ref) {\n  var _a3;\n  let { __demoMode = false, ...theirProps } = props;\n  let internalPopoverRef = (0, import_react77.useRef)(null);\n  let popoverRef = useSyncRefs(\n    ref,\n    optionalRef((ref2) => {\n      internalPopoverRef.current = ref2;\n    })\n  );\n  let buttons = (0, import_react77.useRef)([]);\n  let reducerBag = (0, import_react77.useReducer)(stateReducer3, {\n    __demoMode,\n    popoverState: __demoMode ? 0 /* Open */ : 1 /* Closed */,\n    buttons,\n    button: null,\n    buttonId: null,\n    panel: null,\n    panelId: null,\n    beforePanelSentinel: (0, import_react77.createRef)(),\n    afterPanelSentinel: (0, import_react77.createRef)(),\n    afterButtonSentinel: (0, import_react77.createRef)()\n  });\n  let [\n    {\n      popoverState,\n      button,\n      buttonId,\n      panel,\n      panelId,\n      beforePanelSentinel,\n      afterPanelSentinel,\n      afterButtonSentinel\n    },\n    dispatch\n  ] = reducerBag;\n  let ownerDocument = useOwnerDocument((_a3 = internalPopoverRef.current) != null ? _a3 : button);\n  let isPortalled = (0, import_react77.useMemo)(() => {\n    if (!button)\n      return false;\n    if (!panel)\n      return false;\n    for (let root2 of document.querySelectorAll(\"body > *\")) {\n      if (Number(root2 == null ? void 0 : root2.contains(button)) ^ Number(root2 == null ? void 0 : root2.contains(panel))) {\n        return true;\n      }\n    }\n    let elements = getFocusableElements();\n    let buttonIdx = elements.indexOf(button);\n    let beforeIdx = (buttonIdx + elements.length - 1) % elements.length;\n    let afterIdx = (buttonIdx + 1) % elements.length;\n    let beforeElement = elements[beforeIdx];\n    let afterElement = elements[afterIdx];\n    if (!panel.contains(beforeElement) && !panel.contains(afterElement)) {\n      return true;\n    }\n    return false;\n  }, [button, panel]);\n  let buttonIdRef = useLatestValue(buttonId);\n  let panelIdRef = useLatestValue(panelId);\n  let registerBag = (0, import_react77.useMemo)(\n    () => ({\n      buttonId: buttonIdRef,\n      panelId: panelIdRef,\n      close: () => dispatch({ type: 1 /* ClosePopover */ })\n    }),\n    [buttonIdRef, panelIdRef, dispatch]\n  );\n  let groupContext = usePopoverGroupContext();\n  let registerPopover = groupContext == null ? void 0 : groupContext.registerPopover;\n  let isFocusWithinPopoverGroup = useEvent(() => {\n    var _a4;\n    return (_a4 = groupContext == null ? void 0 : groupContext.isFocusWithinPopoverGroup()) != null ? _a4 : (ownerDocument == null ? void 0 : ownerDocument.activeElement) && ((button == null ? void 0 : button.contains(ownerDocument.activeElement)) || (panel == null ? void 0 : panel.contains(ownerDocument.activeElement)));\n  });\n  (0, import_react77.useEffect)(() => registerPopover == null ? void 0 : registerPopover(registerBag), [registerPopover, registerBag]);\n  let [portals, PortalWrapper] = useNestedPortals();\n  let mainTreeNode = useMainTreeNode(button);\n  let root = useRootContainers({\n    mainTreeNode,\n    portals,\n    defaultContainers: [button, panel]\n  });\n  useEventListener(\n    ownerDocument == null ? void 0 : ownerDocument.defaultView,\n    \"focus\",\n    (event) => {\n      var _a4, _b2, _c, _d, _e, _f;\n      if (event.target === window)\n        return;\n      if (!(event.target instanceof HTMLElement))\n        return;\n      if (popoverState !== 0 /* Open */)\n        return;\n      if (isFocusWithinPopoverGroup())\n        return;\n      if (!button)\n        return;\n      if (!panel)\n        return;\n      if (root.contains(event.target))\n        return;\n      if ((_b2 = (_a4 = beforePanelSentinel.current) == null ? void 0 : _a4.contains) == null ? void 0 : _b2.call(_a4, event.target))\n        return;\n      if ((_d = (_c = afterPanelSentinel.current) == null ? void 0 : _c.contains) == null ? void 0 : _d.call(_c, event.target))\n        return;\n      if ((_f = (_e = afterButtonSentinel.current) == null ? void 0 : _e.contains) == null ? void 0 : _f.call(_e, event.target))\n        return;\n      dispatch({ type: 1 /* ClosePopover */ });\n    },\n    true\n  );\n  let outsideClickEnabled = popoverState === 0 /* Open */;\n  useOutsideClick(outsideClickEnabled, root.resolveContainers, (event, target) => {\n    dispatch({ type: 1 /* ClosePopover */ });\n    if (!isFocusableElement(target, 1 /* Loose */)) {\n      event.preventDefault();\n      button == null ? void 0 : button.focus();\n    }\n  });\n  let close = useEvent(\n    (focusableElement) => {\n      dispatch({ type: 1 /* ClosePopover */ });\n      let restoreElement = (() => {\n        if (!focusableElement)\n          return button;\n        if (focusableElement instanceof HTMLElement)\n          return focusableElement;\n        if (\"current\" in focusableElement && focusableElement.current instanceof HTMLElement)\n          return focusableElement.current;\n        return button;\n      })();\n      restoreElement == null ? void 0 : restoreElement.focus();\n    }\n  );\n  let api = (0, import_react77.useMemo)(\n    () => ({ close, isPortalled }),\n    [close, isPortalled]\n  );\n  let slot = (0, import_react77.useMemo)(\n    () => ({ open: popoverState === 0 /* Open */, close }),\n    [popoverState, close]\n  );\n  let ourProps = { ref: popoverRef };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react77.default.createElement(MainTreeProvider, { node: mainTreeNode }, /* @__PURE__ */ import_react77.default.createElement(FloatingProvider, null, /* @__PURE__ */ import_react77.default.createElement(PopoverPanelContext.Provider, { value: null }, /* @__PURE__ */ import_react77.default.createElement(PopoverContext.Provider, { value: reducerBag }, /* @__PURE__ */ import_react77.default.createElement(PopoverAPIContext.Provider, { value: api }, /* @__PURE__ */ import_react77.default.createElement(CloseProvider, { value: close }, /* @__PURE__ */ import_react77.default.createElement(\n    OpenClosedProvider,\n    {\n      value: match(popoverState, {\n        [0 /* Open */]: 1 /* Open */,\n        [1 /* Closed */]: 2 /* Closed */\n      })\n    },\n    /* @__PURE__ */ import_react77.default.createElement(PortalWrapper, null, render2({\n      ourProps,\n      theirProps,\n      slot,\n      defaultTag: DEFAULT_POPOVER_TAG,\n      name: \"Popover\"\n    }))\n  )))))));\n}\nvar DEFAULT_BUTTON_TAG6 = \"button\";\nfunction ButtonFn6(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-popover-button-${internalId}`,\n    disabled = false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let [state, dispatch] = usePopoverContext(\"Popover.Button\");\n  let { isPortalled } = usePopoverAPIContext(\"Popover.Button\");\n  let internalButtonRef = (0, import_react77.useRef)(null);\n  let sentinelId = `headlessui-focus-sentinel-${(0, import_react19.useId)()}`;\n  let groupContext = usePopoverGroupContext();\n  let closeOthers = groupContext == null ? void 0 : groupContext.closeOthers;\n  let panelContext = usePopoverPanelContext();\n  let isWithinPanel = panelContext !== null;\n  (0, import_react77.useEffect)(() => {\n    if (isWithinPanel)\n      return;\n    dispatch({ type: 3 /* SetButtonId */, buttonId: id });\n    return () => {\n      dispatch({ type: 3 /* SetButtonId */, buttonId: null });\n    };\n  }, [isWithinPanel, id, dispatch]);\n  let [uniqueIdentifier] = (0, import_react77.useState)(() => Symbol());\n  let buttonRef = useSyncRefs(\n    internalButtonRef,\n    ref,\n    useFloatingReference(),\n    useEvent((button) => {\n      if (isWithinPanel)\n        return;\n      if (button) {\n        state.buttons.current.push(uniqueIdentifier);\n      } else {\n        let idx = state.buttons.current.indexOf(uniqueIdentifier);\n        if (idx !== -1)\n          state.buttons.current.splice(idx, 1);\n      }\n      if (state.buttons.current.length > 1) {\n        console.warn(\n          \"You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported.\"\n        );\n      }\n      button && dispatch({ type: 2 /* SetButton */, button });\n    })\n  );\n  let withinPanelButtonRef = useSyncRefs(internalButtonRef, ref);\n  let ownerDocument = useOwnerDocument(internalButtonRef);\n  let handleKeyDown = useEvent((event) => {\n    var _a3, _b2, _c;\n    if (isWithinPanel) {\n      if (state.popoverState === 1 /* Closed */)\n        return;\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          (_b2 = (_a3 = event.target).click) == null ? void 0 : _b2.call(_a3);\n          dispatch({ type: 1 /* ClosePopover */ });\n          (_c = state.button) == null ? void 0 : _c.focus();\n          break;\n      }\n    } else {\n      switch (event.key) {\n        case \" \" /* Space */:\n        case \"Enter\" /* Enter */:\n          event.preventDefault();\n          event.stopPropagation();\n          if (state.popoverState === 1 /* Closed */)\n            closeOthers == null ? void 0 : closeOthers(state.buttonId);\n          dispatch({ type: 0 /* TogglePopover */ });\n          break;\n        case \"Escape\" /* Escape */:\n          if (state.popoverState !== 0 /* Open */)\n            return closeOthers == null ? void 0 : closeOthers(state.buttonId);\n          if (!internalButtonRef.current)\n            return;\n          if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) && !internalButtonRef.current.contains(ownerDocument.activeElement)) {\n            return;\n          }\n          event.preventDefault();\n          event.stopPropagation();\n          dispatch({ type: 1 /* ClosePopover */ });\n          break;\n      }\n    }\n  });\n  let handleKeyUp = useEvent((event) => {\n    if (isWithinPanel)\n      return;\n    if (event.key === \" \" /* Space */) {\n      event.preventDefault();\n    }\n  });\n  let handleClick = useEvent((event) => {\n    var _a3, _b2;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return;\n    if (disabled)\n      return;\n    if (isWithinPanel) {\n      dispatch({ type: 1 /* ClosePopover */ });\n      (_a3 = state.button) == null ? void 0 : _a3.focus();\n    } else {\n      event.preventDefault();\n      event.stopPropagation();\n      if (state.popoverState === 1 /* Closed */)\n        closeOthers == null ? void 0 : closeOthers(state.buttonId);\n      dispatch({ type: 0 /* TogglePopover */ });\n      (_b2 = state.button) == null ? void 0 : _b2.focus();\n    }\n  });\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  });\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let visible = state.popoverState === 0 /* Open */;\n  let slot = (0, import_react77.useMemo)(() => {\n    return {\n      open: visible,\n      active: active || visible,\n      disabled,\n      hover,\n      focus,\n      autofocus: autoFocus\n    };\n  }, [visible, hover, focus, active, disabled, autoFocus]);\n  let type = useResolveButtonType(props, state.button);\n  let ourProps = isWithinPanel ? mergeProps(\n    {\n      ref: withinPanelButtonRef,\n      type,\n      onKeyDown: handleKeyDown,\n      onClick: handleClick,\n      disabled: disabled || void 0,\n      autoFocus\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  ) : mergeProps(\n    {\n      ref: buttonRef,\n      id: state.buttonId,\n      type,\n      \"aria-expanded\": state.popoverState === 0 /* Open */,\n      \"aria-controls\": state.panel ? state.panelId : void 0,\n      disabled: disabled || void 0,\n      autoFocus,\n      onKeyDown: handleKeyDown,\n      onKeyUp: handleKeyUp,\n      onClick: handleClick,\n      onMouseDown: handleMouseDown\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let direction = useTabDirection();\n  let handleFocus = useEvent(() => {\n    let el = state.panel;\n    if (!el)\n      return;\n    function run() {\n      let result = match(direction.current, {\n        [0 /* Forwards */]: () => focusIn(el, 1 /* First */),\n        [1 /* Backwards */]: () => focusIn(el, 8 /* Last */)\n      });\n      if (result === 0 /* Error */) {\n        focusIn(\n          getFocusableElements().filter((el2) => el2.dataset.headlessuiFocusGuard !== \"true\"),\n          match(direction.current, {\n            [0 /* Forwards */]: 4 /* Next */,\n            [1 /* Backwards */]: 2 /* Previous */\n          }),\n          { relativeTo: state.button }\n        );\n      }\n    }\n    if (false) {\n      microTask(run);\n    } else {\n      run();\n    }\n  });\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react77.default.createElement(import_react77.default.Fragment, null, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BUTTON_TAG6,\n    name: \"Popover.Button\"\n  }), visible && !isWithinPanel && isPortalled && /* @__PURE__ */ import_react77.default.createElement(\n    Hidden,\n    {\n      id: sentinelId,\n      ref: state.afterButtonSentinel,\n      features: 2 /* Focusable */,\n      \"data-headlessui-focus-guard\": true,\n      as: \"button\",\n      type: \"button\",\n      onFocus: handleFocus\n    }\n  ));\n}\nvar DEFAULT_BACKDROP_TAG2 = \"div\";\nvar BackdropRenderFeatures = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction BackdropFn2(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-popover-backdrop-${internalId}`,\n    transition: transition2 = false,\n    ...theirProps\n  } = props;\n  let [{ popoverState }, dispatch] = usePopoverContext(\"Popover.Backdrop\");\n  let [localBackdropElement, setLocalBackdropElement] = (0, import_react77.useState)(null);\n  let backdropRef = useSyncRefs(ref, setLocalBackdropElement);\n  let usesOpenClosedState = useOpenClosed();\n  let [visible, transitionData] = useTransition(\n    transition2,\n    localBackdropElement,\n    usesOpenClosedState !== null ? (usesOpenClosedState & 1 /* Open */) === 1 /* Open */ : popoverState === 0 /* Open */\n  );\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    dispatch({ type: 1 /* ClosePopover */ });\n  });\n  let slot = (0, import_react77.useMemo)(() => {\n    return {\n      open: popoverState === 0 /* Open */\n    };\n  }, [popoverState]);\n  let ourProps = {\n    ref: backdropRef,\n    id,\n    \"aria-hidden\": true,\n    onClick: handleClick,\n    ...transitionDataAttributes(transitionData)\n  };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_BACKDROP_TAG2,\n    features: BackdropRenderFeatures,\n    visible,\n    name: \"Popover.Backdrop\"\n  });\n}\nvar DEFAULT_PANEL_TAG3 = \"div\";\nvar PanelRenderFeatures2 = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction PanelFn3(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-popover-panel-${internalId}`,\n    focus = false,\n    anchor: rawAnchor,\n    portal = false,\n    modal = false,\n    transition: transition2 = false,\n    ...theirProps\n  } = props;\n  let [state, dispatch] = usePopoverContext(\"Popover.Panel\");\n  let { close, isPortalled } = usePopoverAPIContext(\"Popover.Panel\");\n  let beforePanelSentinelId = `headlessui-focus-sentinel-before-${internalId}`;\n  let afterPanelSentinelId = `headlessui-focus-sentinel-after-${internalId}`;\n  let internalPanelRef = (0, import_react77.useRef)(null);\n  let anchor = useResolvedAnchor(rawAnchor);\n  let [floatingRef, style] = useFloatingPanel(anchor);\n  let getFloatingPanelProps = useFloatingPanelProps();\n  if (anchor) {\n    portal = true;\n  }\n  let [localPanelElement, setLocalPanelElement] = (0, import_react77.useState)(null);\n  let panelRef = useSyncRefs(\n    internalPanelRef,\n    ref,\n    anchor ? floatingRef : null,\n    useEvent((panel) => dispatch({ type: 4 /* SetPanel */, panel })),\n    setLocalPanelElement\n  );\n  let portalOwnerDocument = useOwnerDocument(state.button);\n  let ownerDocument = useOwnerDocument(internalPanelRef);\n  useIsoMorphicEffect(() => {\n    dispatch({ type: 5 /* SetPanelId */, panelId: id });\n    return () => {\n      dispatch({ type: 5 /* SetPanelId */, panelId: null });\n    };\n  }, [id, dispatch]);\n  let usesOpenClosedState = useOpenClosed();\n  let [visible, transitionData] = useTransition(\n    transition2,\n    localPanelElement,\n    usesOpenClosedState !== null ? (usesOpenClosedState & 1 /* Open */) === 1 /* Open */ : state.popoverState === 0 /* Open */\n  );\n  useOnDisappear(visible, state.button, () => {\n    dispatch({ type: 1 /* ClosePopover */ });\n  });\n  let scrollLockEnabled = state.__demoMode ? false : modal && visible;\n  useScrollLock(scrollLockEnabled, ownerDocument);\n  let handleKeyDown = useEvent((event) => {\n    var _a3;\n    switch (event.key) {\n      case \"Escape\" /* Escape */:\n        if (state.popoverState !== 0 /* Open */)\n          return;\n        if (!internalPanelRef.current)\n          return;\n        if ((ownerDocument == null ? void 0 : ownerDocument.activeElement) && !internalPanelRef.current.contains(ownerDocument.activeElement)) {\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        dispatch({ type: 1 /* ClosePopover */ });\n        (_a3 = state.button) == null ? void 0 : _a3.focus();\n        break;\n    }\n  });\n  (0, import_react77.useEffect)(() => {\n    var _a3;\n    if (props.static)\n      return;\n    if (state.popoverState === 1 /* Closed */ && ((_a3 = props.unmount) != null ? _a3 : true)) {\n      dispatch({ type: 4 /* SetPanel */, panel: null });\n    }\n  }, [state.popoverState, props.unmount, props.static, dispatch]);\n  (0, import_react77.useEffect)(() => {\n    if (state.__demoMode)\n      return;\n    if (!focus)\n      return;\n    if (state.popoverState !== 0 /* Open */)\n      return;\n    if (!internalPanelRef.current)\n      return;\n    let activeElement2 = ownerDocument == null ? void 0 : ownerDocument.activeElement;\n    if (internalPanelRef.current.contains(activeElement2))\n      return;\n    focusIn(internalPanelRef.current, 1 /* First */);\n  }, [state.__demoMode, focus, internalPanelRef.current, state.popoverState]);\n  let slot = (0, import_react77.useMemo)(() => {\n    return {\n      open: state.popoverState === 0 /* Open */,\n      close\n    };\n  }, [state.popoverState, close]);\n  let ourProps = mergeProps(anchor ? getFloatingPanelProps() : {}, {\n    ref: panelRef,\n    id,\n    onKeyDown: handleKeyDown,\n    onBlur: focus && state.popoverState === 0 /* Open */ ? (event) => {\n      var _a3, _b2, _c, _d, _e;\n      let el = event.relatedTarget;\n      if (!el)\n        return;\n      if (!internalPanelRef.current)\n        return;\n      if ((_a3 = internalPanelRef.current) == null ? void 0 : _a3.contains(el))\n        return;\n      dispatch({ type: 1 /* ClosePopover */ });\n      if (((_c = (_b2 = state.beforePanelSentinel.current) == null ? void 0 : _b2.contains) == null ? void 0 : _c.call(_b2, el)) || ((_e = (_d = state.afterPanelSentinel.current) == null ? void 0 : _d.contains) == null ? void 0 : _e.call(_d, el))) {\n        el.focus({ preventScroll: true });\n      }\n    } : void 0,\n    tabIndex: -1,\n    style: {\n      ...theirProps.style,\n      ...style,\n      \"--button-width\": useElementSize(state.button, true).width\n    },\n    ...transitionDataAttributes(transitionData)\n  });\n  let direction = useTabDirection();\n  let handleBeforeFocus = useEvent(() => {\n    let el = internalPanelRef.current;\n    if (!el)\n      return;\n    function run() {\n      match(direction.current, {\n        [0 /* Forwards */]: () => {\n          var _a3;\n          let result = focusIn(el, 1 /* First */);\n          if (result === 0 /* Error */) {\n            (_a3 = state.afterPanelSentinel.current) == null ? void 0 : _a3.focus();\n          }\n        },\n        [1 /* Backwards */]: () => {\n          var _a3;\n          (_a3 = state.button) == null ? void 0 : _a3.focus({ preventScroll: true });\n        }\n      });\n    }\n    if (false) {\n      microTask(run);\n    } else {\n      run();\n    }\n  });\n  let handleAfterFocus = useEvent(() => {\n    let el = internalPanelRef.current;\n    if (!el)\n      return;\n    function run() {\n      match(direction.current, {\n        [0 /* Forwards */]: () => {\n          if (!state.button)\n            return;\n          let elements = getFocusableElements();\n          let idx = elements.indexOf(state.button);\n          let before = elements.slice(0, idx + 1);\n          let after = elements.slice(idx + 1);\n          let combined = [...after, ...before];\n          for (let element of combined.slice()) {\n            if (element.dataset.headlessuiFocusGuard === \"true\" || (localPanelElement == null ? void 0 : localPanelElement.contains(element))) {\n              let idx2 = combined.indexOf(element);\n              if (idx2 !== -1)\n                combined.splice(idx2, 1);\n            }\n          }\n          focusIn(combined, 1 /* First */, { sorted: false });\n        },\n        [1 /* Backwards */]: () => {\n          var _a3;\n          let result = focusIn(el, 2 /* Previous */);\n          if (result === 0 /* Error */) {\n            (_a3 = state.button) == null ? void 0 : _a3.focus();\n          }\n        }\n      });\n    }\n    if (false) {\n      microTask(run);\n    } else {\n      run();\n    }\n  });\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react77.default.createElement(ResetOpenClosedProvider, null, /* @__PURE__ */ import_react77.default.createElement(PopoverPanelContext.Provider, { value: id }, /* @__PURE__ */ import_react77.default.createElement(PopoverAPIContext.Provider, { value: { close, isPortalled } }, /* @__PURE__ */ import_react77.default.createElement(\n    Portal,\n    {\n      enabled: portal ? props.static || visible : false,\n      ownerDocument: portalOwnerDocument\n    },\n    visible && isPortalled && /* @__PURE__ */ import_react77.default.createElement(\n      Hidden,\n      {\n        id: beforePanelSentinelId,\n        ref: state.beforePanelSentinel,\n        features: 2 /* Focusable */,\n        \"data-headlessui-focus-guard\": true,\n        as: \"button\",\n        type: \"button\",\n        onFocus: handleBeforeFocus\n      }\n    ),\n    render2({\n      ourProps,\n      theirProps,\n      slot,\n      defaultTag: DEFAULT_PANEL_TAG3,\n      features: PanelRenderFeatures2,\n      visible,\n      name: \"Popover.Panel\"\n    }),\n    visible && isPortalled && /* @__PURE__ */ import_react77.default.createElement(\n      Hidden,\n      {\n        id: afterPanelSentinelId,\n        ref: state.afterPanelSentinel,\n        features: 2 /* Focusable */,\n        \"data-headlessui-focus-guard\": true,\n        as: \"button\",\n        type: \"button\",\n        onFocus: handleAfterFocus\n      }\n    )\n  ))));\n}\nvar DEFAULT_GROUP_TAG2 = \"div\";\nfunction GroupFn2(props, ref) {\n  let internalGroupRef = (0, import_react77.useRef)(null);\n  let groupRef = useSyncRefs(internalGroupRef, ref);\n  let [popovers, setPopovers] = (0, import_react77.useState)([]);\n  let unregisterPopover = useEvent((registerBag) => {\n    setPopovers((existing) => {\n      let idx = existing.indexOf(registerBag);\n      if (idx !== -1) {\n        let clone = existing.slice();\n        clone.splice(idx, 1);\n        return clone;\n      }\n      return existing;\n    });\n  });\n  let registerPopover = useEvent((registerBag) => {\n    setPopovers((existing) => [...existing, registerBag]);\n    return () => unregisterPopover(registerBag);\n  });\n  let isFocusWithinPopoverGroup = useEvent(() => {\n    var _a3;\n    let ownerDocument = getOwnerDocument(internalGroupRef);\n    if (!ownerDocument)\n      return false;\n    let element = ownerDocument.activeElement;\n    if ((_a3 = internalGroupRef.current) == null ? void 0 : _a3.contains(element))\n      return true;\n    return popovers.some((bag) => {\n      var _a4, _b2;\n      return ((_a4 = ownerDocument.getElementById(bag.buttonId.current)) == null ? void 0 : _a4.contains(element)) || ((_b2 = ownerDocument.getElementById(bag.panelId.current)) == null ? void 0 : _b2.contains(element));\n    });\n  });\n  let closeOthers = useEvent((buttonId) => {\n    for (let popover of popovers) {\n      if (popover.buttonId.current !== buttonId)\n        popover.close();\n    }\n  });\n  let contextBag = (0, import_react77.useMemo)(\n    () => ({\n      registerPopover,\n      unregisterPopover,\n      isFocusWithinPopoverGroup,\n      closeOthers\n    }),\n    [registerPopover, unregisterPopover, isFocusWithinPopoverGroup, closeOthers]\n  );\n  let slot = (0, import_react77.useMemo)(() => ({}), []);\n  let theirProps = props;\n  let ourProps = { ref: groupRef };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react77.default.createElement(MainTreeProvider, null, /* @__PURE__ */ import_react77.default.createElement(PopoverGroupContext.Provider, { value: contextBag }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_GROUP_TAG2,\n    name: \"Popover.Group\"\n  })));\n}\nvar PopoverRoot = forwardRefWithAs(PopoverFn);\nvar PopoverButton = forwardRefWithAs(ButtonFn6);\nvar PopoverOverlay = forwardRefWithAs(BackdropFn2);\nvar PopoverBackdrop = forwardRefWithAs(BackdropFn2);\nvar PopoverPanel = forwardRefWithAs(PanelFn3);\nvar PopoverGroup = forwardRefWithAs(GroupFn2);\nvar Popover = Object.assign(PopoverRoot, {\n  /** @deprecated use `<PopoverButton>` instead of `<Popover.Button>` */\n  Button: PopoverButton,\n  /** @deprecated use `<PopoverBackdrop>` instead of `<Popover.Backdrop>` */\n  Backdrop: PopoverBackdrop,\n  /** @deprecated use `<PopoverOverlay>` instead of `<Popover.Overlay>` */\n  Overlay: PopoverOverlay,\n  /** @deprecated use `<PopoverPanel>` instead of `<Popover.Panel>` */\n  Panel: PopoverPanel,\n  /** @deprecated use `<PopoverGroup>` instead of `<Popover.Group>` */\n  Group: PopoverGroup\n});\n\n// src/components/radio-group/radio-group.tsx\nvar import_react78 = __toESM(require(\"react\"), 1);\nvar reducers7 = {\n  [0 /* RegisterOption */](state, action) {\n    let nextOptions = [\n      ...state.options,\n      { id: action.id, element: action.element, propsRef: action.propsRef }\n    ];\n    return {\n      ...state,\n      options: sortByDomNode(nextOptions, (option) => option.element.current)\n    };\n  },\n  [1 /* UnregisterOption */](state, action) {\n    let options = state.options.slice();\n    let idx = state.options.findIndex((radio) => radio.id === action.id);\n    if (idx === -1)\n      return state;\n    options.splice(idx, 1);\n    return { ...state, options };\n  }\n};\nvar RadioGroupDataContext = (0, import_react78.createContext)(null);\nRadioGroupDataContext.displayName = \"RadioGroupDataContext\";\nfunction useData3(component) {\n  let context = (0, import_react78.useContext)(RadioGroupDataContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <RadioGroup /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useData3);\n    throw err;\n  }\n  return context;\n}\nvar RadioGroupActionsContext = (0, import_react78.createContext)(null);\nRadioGroupActionsContext.displayName = \"RadioGroupActionsContext\";\nfunction useActions(component) {\n  let context = (0, import_react78.useContext)(RadioGroupActionsContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <RadioGroup /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useActions);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer4(state, action) {\n  return match(action.type, reducers7, state, action);\n}\nvar DEFAULT_RADIO_GROUP_TAG = \"div\";\nfunction RadioGroupFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedDisabled = useDisabled();\n  let {\n    id = `headlessui-radiogroup-${internalId}`,\n    value: controlledValue,\n    form,\n    name,\n    onChange: controlledOnChange,\n    by,\n    disabled = providedDisabled || false,\n    defaultValue: _defaultValue,\n    tabIndex = 0,\n    ...theirProps\n  } = props;\n  let compare = useByComparator(by);\n  let [state, dispatch] = (0, import_react78.useReducer)(stateReducer4, { options: [] });\n  let options = state.options;\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let internalRadioGroupRef = (0, import_react78.useRef)(null);\n  let radioGroupRef = useSyncRefs(internalRadioGroupRef, ref);\n  let defaultValue = useDefaultValue(_defaultValue);\n  let [value, onChange] = useControllable(controlledValue, controlledOnChange, defaultValue);\n  let firstOption = (0, import_react78.useMemo)(\n    () => options.find((option) => {\n      if (option.propsRef.current.disabled)\n        return false;\n      return true;\n    }),\n    [options]\n  );\n  let containsCheckedOption = (0, import_react78.useMemo)(\n    () => options.some((option) => compare(option.propsRef.current.value, value)),\n    [options, value]\n  );\n  let triggerChange = useEvent((nextValue) => {\n    var _a3;\n    if (disabled)\n      return false;\n    if (compare(nextValue, value))\n      return false;\n    let nextOption = (_a3 = options.find(\n      (option) => compare(option.propsRef.current.value, nextValue)\n    )) == null ? void 0 : _a3.propsRef.current;\n    if (nextOption == null ? void 0 : nextOption.disabled)\n      return false;\n    onChange == null ? void 0 : onChange(nextValue);\n    return true;\n  });\n  let handleKeyDown = useEvent((event) => {\n    let container = internalRadioGroupRef.current;\n    if (!container)\n      return;\n    let ownerDocument = getOwnerDocument(container);\n    let all = options.filter((option) => option.propsRef.current.disabled === false).map((radio) => radio.element.current);\n    switch (event.key) {\n      case \"Enter\" /* Enter */:\n        attemptSubmit(event.currentTarget);\n        break;\n      case \"ArrowLeft\" /* ArrowLeft */:\n      case \"ArrowUp\" /* ArrowUp */:\n        {\n          event.preventDefault();\n          event.stopPropagation();\n          let result = focusIn(all, 2 /* Previous */ | 16 /* WrapAround */);\n          if (result === 2 /* Success */) {\n            let activeOption = options.find(\n              (option) => option.element.current === (ownerDocument == null ? void 0 : ownerDocument.activeElement)\n            );\n            if (activeOption)\n              triggerChange(activeOption.propsRef.current.value);\n          }\n        }\n        break;\n      case \"ArrowRight\" /* ArrowRight */:\n      case \"ArrowDown\" /* ArrowDown */:\n        {\n          event.preventDefault();\n          event.stopPropagation();\n          let result = focusIn(all, 4 /* Next */ | 16 /* WrapAround */);\n          if (result === 2 /* Success */) {\n            let activeOption = options.find(\n              (option) => option.element.current === (ownerDocument == null ? void 0 : ownerDocument.activeElement)\n            );\n            if (activeOption)\n              triggerChange(activeOption.propsRef.current.value);\n          }\n        }\n        break;\n      case \" \" /* Space */:\n        {\n          event.preventDefault();\n          event.stopPropagation();\n          let activeOption = options.find(\n            (option) => option.element.current === (ownerDocument == null ? void 0 : ownerDocument.activeElement)\n          );\n          if (activeOption)\n            triggerChange(activeOption.propsRef.current.value);\n        }\n        break;\n    }\n  });\n  let registerOption = useEvent((option) => {\n    dispatch({ type: 0 /* RegisterOption */, ...option });\n    return () => dispatch({ type: 1 /* UnregisterOption */, id: option.id });\n  });\n  let radioGroupData = (0, import_react78.useMemo)(\n    () => ({ value, firstOption, containsCheckedOption, disabled, compare, tabIndex, ...state }),\n    [value, firstOption, containsCheckedOption, disabled, compare, tabIndex, state]\n  );\n  let radioGroupActions = (0, import_react78.useMemo)(\n    () => ({ registerOption, change: triggerChange }),\n    [registerOption, triggerChange]\n  );\n  let ourProps = {\n    ref: radioGroupRef,\n    id,\n    role: \"radiogroup\",\n    \"aria-labelledby\": labelledby,\n    \"aria-describedby\": describedby,\n    onKeyDown: handleKeyDown\n  };\n  let slot = (0, import_react78.useMemo)(() => ({ value }), [value]);\n  let reset = (0, import_react78.useCallback)(() => {\n    if (defaultValue === void 0)\n      return;\n    return triggerChange(defaultValue);\n  }, [triggerChange, defaultValue]);\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react78.default.createElement(DescriptionProvider, { name: \"RadioGroup.Description\" }, /* @__PURE__ */ import_react78.default.createElement(LabelProvider, { name: \"RadioGroup.Label\" }, /* @__PURE__ */ import_react78.default.createElement(RadioGroupActionsContext.Provider, { value: radioGroupActions }, /* @__PURE__ */ import_react78.default.createElement(RadioGroupDataContext.Provider, { value: radioGroupData }, name != null && /* @__PURE__ */ import_react78.default.createElement(\n    FormFields,\n    {\n      disabled,\n      data: { [name]: value || \"on\" },\n      overrides: { type: \"radio\", checked: value != null },\n      form,\n      onReset: reset\n    }\n  ), render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_RADIO_GROUP_TAG,\n    name: \"RadioGroup\"\n  })))));\n}\nvar DEFAULT_OPTION_TAG3 = \"div\";\nfunction OptionFn3(props, ref) {\n  var _a3;\n  let data = useData3(\"RadioGroup.Option\");\n  let actions = useActions(\"RadioGroup.Option\");\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-radiogroup-option-${internalId}`,\n    value,\n    disabled = data.disabled || false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let internalOptionRef = (0, import_react78.useRef)(null);\n  let optionRef = useSyncRefs(internalOptionRef, ref);\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let propsRef = useLatestValue({ value, disabled });\n  useIsoMorphicEffect(\n    () => actions.registerOption({ id, element: internalOptionRef, propsRef }),\n    [id, actions, internalOptionRef, propsRef]\n  );\n  let handleClick = useEvent((event) => {\n    var _a4;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (!actions.change(value))\n      return;\n    (_a4 = internalOptionRef.current) == null ? void 0 : _a4.focus();\n  });\n  let isFirstOption = ((_a3 = data.firstOption) == null ? void 0 : _a3.id) === id;\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let checked = data.compare(data.value, value);\n  let ourProps = mergeProps(\n    {\n      ref: optionRef,\n      id,\n      role: \"radio\",\n      \"aria-checked\": checked ? \"true\" : \"false\",\n      \"aria-labelledby\": labelledby,\n      \"aria-describedby\": describedby,\n      \"aria-disabled\": disabled ? true : void 0,\n      tabIndex: (() => {\n        if (disabled)\n          return -1;\n        if (checked)\n          return data.tabIndex;\n        if (!data.containsCheckedOption && isFirstOption)\n          return data.tabIndex;\n        return -1;\n      })(),\n      onClick: disabled ? void 0 : handleClick,\n      autoFocus\n    },\n    focusProps,\n    hoverProps\n  );\n  let slot = (0, import_react78.useMemo)(() => {\n    return {\n      checked,\n      disabled,\n      active: focus,\n      hover,\n      focus,\n      autofocus: autoFocus\n    };\n  }, [checked, disabled, hover, focus, autoFocus]);\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react78.default.createElement(DescriptionProvider, { name: \"RadioGroup.Description\" }, /* @__PURE__ */ import_react78.default.createElement(LabelProvider, { name: \"RadioGroup.Label\" }, render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_OPTION_TAG3,\n    name: \"RadioGroup.Option\"\n  })));\n}\nvar DEFAULT_RADIO_TAG = \"span\";\nfunction RadioFn(props, ref) {\n  var _a3;\n  let data = useData3(\"Radio\");\n  let actions = useActions(\"Radio\");\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = providedId || `headlessui-radio-${internalId}`,\n    value,\n    disabled = data.disabled || providedDisabled || false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let internalRadioRef = (0, import_react78.useRef)(null);\n  let radioRef = useSyncRefs(internalRadioRef, ref);\n  let labelledby = useLabelledBy();\n  let describedby = useDescribedBy();\n  let propsRef = useLatestValue({ value, disabled });\n  useIsoMorphicEffect(\n    () => actions.registerOption({ id, element: internalRadioRef, propsRef }),\n    [id, actions, internalRadioRef, propsRef]\n  );\n  let handleClick = useEvent((event) => {\n    var _a4;\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    if (!actions.change(value))\n      return;\n    (_a4 = internalRadioRef.current) == null ? void 0 : _a4.focus();\n  });\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let isFirstOption = ((_a3 = data.firstOption) == null ? void 0 : _a3.id) === id;\n  let checked = data.compare(data.value, value);\n  let ourProps = mergeProps(\n    {\n      ref: radioRef,\n      id,\n      role: \"radio\",\n      \"aria-checked\": checked ? \"true\" : \"false\",\n      \"aria-labelledby\": labelledby,\n      \"aria-describedby\": describedby,\n      \"aria-disabled\": disabled ? true : void 0,\n      tabIndex: (() => {\n        if (disabled)\n          return -1;\n        if (checked)\n          return data.tabIndex;\n        if (!data.containsCheckedOption && isFirstOption)\n          return data.tabIndex;\n        return -1;\n      })(),\n      autoFocus,\n      onClick: disabled ? void 0 : handleClick\n    },\n    focusProps,\n    hoverProps\n  );\n  let slot = (0, import_react78.useMemo)(() => {\n    return { checked, disabled, hover, focus, autofocus: autoFocus };\n  }, [checked, disabled, hover, focus, autoFocus]);\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_RADIO_TAG,\n    name: \"Radio\"\n  });\n}\nvar RadioGroupRoot = forwardRefWithAs(RadioGroupFn);\nvar RadioGroupOption = forwardRefWithAs(OptionFn3);\nvar Radio = forwardRefWithAs(RadioFn);\nvar RadioGroupLabel = Label;\nvar RadioGroupDescription = Description;\nvar RadioGroup = Object.assign(RadioGroupRoot, {\n  /** @deprecated use `<Radio>` instead of `<RadioGroup.Option>` */\n  Option: RadioGroupOption,\n  /** @deprecated use `<Radio>` instead of `<RadioGroup.Radio>` */\n  Radio,\n  /** @deprecated use `<Label>` instead of `<RadioGroup.Label>` */\n  Label: RadioGroupLabel,\n  /** @deprecated use `<Description>` instead of `<RadioGroup.Description>` */\n  Description: RadioGroupDescription\n});\n\n// src/components/select/select.tsx\nvar import_react79 = require(\"react\");\nvar DEFAULT_SELECT_TAG = \"select\";\nfunction SelectFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = providedId || `headlessui-select-${internalId}`,\n    disabled = providedDisabled || false,\n    invalid = false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let labelledBy = useLabelledBy();\n  let describedBy = useDescribedBy();\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      \"aria-invalid\": invalid ? \"true\" : void 0,\n      disabled: disabled || void 0,\n      autoFocus\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let slot = (0, import_react79.useMemo)(() => {\n    return {\n      disabled,\n      invalid,\n      hover,\n      focus,\n      active,\n      autofocus: autoFocus\n    };\n  }, [disabled, invalid, hover, focus, active, autoFocus]);\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_SELECT_TAG,\n    name: \"Select\"\n  });\n}\nvar Select = forwardRefWithAs(SelectFn);\n\n// src/components/switch/switch.tsx\nvar import_react80 = __toESM(require(\"react\"), 1);\nvar GroupContext = (0, import_react80.createContext)(null);\nGroupContext.displayName = \"GroupContext\";\nvar DEFAULT_GROUP_TAG3 = import_react80.Fragment;\nfunction GroupFn3(props) {\n  var _a3;\n  let [switchElement, setSwitchElement] = (0, import_react80.useState)(null);\n  let [labelledby, LabelProvider] = useLabels();\n  let [describedby, DescriptionProvider] = useDescriptions();\n  let context = (0, import_react80.useMemo)(\n    () => ({ switch: switchElement, setSwitch: setSwitchElement }),\n    [switchElement, setSwitchElement]\n  );\n  let ourProps = {};\n  let theirProps = props;\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react80.default.createElement(DescriptionProvider, { name: \"Switch.Description\", value: describedby }, /* @__PURE__ */ import_react80.default.createElement(\n    LabelProvider,\n    {\n      name: \"Switch.Label\",\n      value: labelledby,\n      props: {\n        htmlFor: (_a3 = context.switch) == null ? void 0 : _a3.id,\n        onClick(event) {\n          if (!switchElement)\n            return;\n          if (event.currentTarget instanceof HTMLLabelElement) {\n            event.preventDefault();\n          }\n          switchElement.click();\n          switchElement.focus({ preventScroll: true });\n        }\n      }\n    },\n    /* @__PURE__ */ import_react80.default.createElement(GroupContext.Provider, { value: context }, render2({\n      ourProps,\n      theirProps,\n      slot: {},\n      defaultTag: DEFAULT_GROUP_TAG3,\n      name: \"Switch.Group\"\n    }))\n  ));\n}\nvar DEFAULT_SWITCH_TAG = \"button\";\nfunction SwitchFn(props, ref) {\n  var _a3;\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = providedId || `headlessui-switch-${internalId}`,\n    disabled = providedDisabled || false,\n    checked: controlledChecked,\n    defaultChecked: _defaultChecked,\n    onChange: controlledOnChange,\n    name,\n    value,\n    form,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let groupContext = (0, import_react80.useContext)(GroupContext);\n  let [switchElement, setSwitchElement] = (0, import_react80.useState)(null);\n  let internalSwitchRef = (0, import_react80.useRef)(null);\n  let switchRef = useSyncRefs(\n    internalSwitchRef,\n    ref,\n    groupContext === null ? null : groupContext.setSwitch,\n    setSwitchElement\n  );\n  let defaultChecked = useDefaultValue(_defaultChecked);\n  let [checked, onChange] = useControllable(\n    controlledChecked,\n    controlledOnChange,\n    defaultChecked != null ? defaultChecked : false\n  );\n  let d = useDisposables();\n  let [changing, setChanging] = (0, import_react80.useState)(false);\n  let toggle = useEvent(() => {\n    setChanging(true);\n    onChange == null ? void 0 : onChange(!checked);\n    d.nextFrame(() => {\n      setChanging(false);\n    });\n  });\n  let handleClick = useEvent((event) => {\n    if (isDisabledReactIssue7711(event.currentTarget))\n      return event.preventDefault();\n    event.preventDefault();\n    toggle();\n  });\n  let handleKeyUp = useEvent((event) => {\n    if (event.key === \" \" /* Space */) {\n      event.preventDefault();\n      toggle();\n    } else if (event.key === \"Enter\" /* Enter */) {\n      attemptSubmit(event.currentTarget);\n    }\n  });\n  let handleKeyPress = useEvent((event) => event.preventDefault());\n  let labelledBy = useLabelledBy();\n  let describedBy = useDescribedBy();\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let slot = (0, import_react80.useMemo)(() => {\n    return {\n      checked,\n      disabled,\n      hover,\n      focus,\n      active,\n      autofocus: autoFocus,\n      changing\n    };\n  }, [checked, hover, focus, active, disabled, changing, autoFocus]);\n  let ourProps = mergeProps(\n    {\n      id,\n      ref: switchRef,\n      role: \"switch\",\n      type: useResolveButtonType(props, switchElement),\n      tabIndex: props.tabIndex === -1 ? 0 : (_a3 = props.tabIndex) != null ? _a3 : 0,\n      \"aria-checked\": checked,\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      disabled: disabled || void 0,\n      autoFocus,\n      onClick: handleClick,\n      onKeyUp: handleKeyUp,\n      onKeyPress: handleKeyPress\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let reset = (0, import_react80.useCallback)(() => {\n    if (defaultChecked === void 0)\n      return;\n    return onChange == null ? void 0 : onChange(defaultChecked);\n  }, [onChange, defaultChecked]);\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react80.default.createElement(import_react80.default.Fragment, null, name != null && /* @__PURE__ */ import_react80.default.createElement(\n    FormFields,\n    {\n      disabled,\n      data: { [name]: value || \"on\" },\n      overrides: { type: \"checkbox\", checked },\n      form,\n      onReset: reset\n    }\n  ), render2({ ourProps, theirProps, slot, defaultTag: DEFAULT_SWITCH_TAG, name: \"Switch\" }));\n}\nvar SwitchRoot = forwardRefWithAs(SwitchFn);\nvar SwitchGroup = GroupFn3;\nvar SwitchLabel = Label;\nvar SwitchDescription = Description;\nvar Switch = Object.assign(SwitchRoot, {\n  /** @deprecated use `<Field>` instead of `<Switch.Group>` */\n  Group: SwitchGroup,\n  /** @deprecated use `<Label>` instead of `<Switch.Label>` */\n  Label: SwitchLabel,\n  /** @deprecated use `<Description>` instead of `<Switch.Description>` */\n  Description: SwitchDescription\n});\n\n// src/components/tabs/tabs.tsx\nvar import_react82 = __toESM(require(\"react\"), 1);\n\n// src/internal/focus-sentinel.tsx\nvar import_react81 = __toESM(require(\"react\"), 1);\nfunction FocusSentinel({ onFocus }) {\n  let [enabled, setEnabled] = (0, import_react81.useState)(true);\n  let mounted = useIsMounted();\n  if (!enabled)\n    return null;\n  return /* @__PURE__ */ import_react81.default.createElement(\n    Hidden,\n    {\n      as: \"button\",\n      type: \"button\",\n      features: 2 /* Focusable */,\n      onFocus: (event) => {\n        event.preventDefault();\n        let frame;\n        let tries = 50;\n        function forwardFocus() {\n          if (tries-- <= 0) {\n            if (frame)\n              cancelAnimationFrame(frame);\n            return;\n          }\n          if (onFocus()) {\n            cancelAnimationFrame(frame);\n            if (!mounted.current)\n              return;\n            setEnabled(false);\n            return;\n          }\n          frame = requestAnimationFrame(forwardFocus);\n        }\n        frame = requestAnimationFrame(forwardFocus);\n      }\n    }\n  );\n}\n\n// src/utils/stable-collection.tsx\nvar React36 = __toESM(require(\"react\"), 1);\nvar StableCollectionContext = React36.createContext(null);\nfunction createCollection() {\n  return {\n    /** @type {Map<string, Map<string, number>>} */\n    groups: /* @__PURE__ */ new Map(),\n    get(group, key) {\n      var _a3;\n      let list = this.groups.get(group);\n      if (!list) {\n        list = /* @__PURE__ */ new Map();\n        this.groups.set(group, list);\n      }\n      let renders = (_a3 = list.get(key)) != null ? _a3 : 0;\n      list.set(key, renders + 1);\n      let index3 = Array.from(list.keys()).indexOf(key);\n      function release() {\n        let renders2 = list.get(key);\n        if (renders2 > 1) {\n          list.set(key, renders2 - 1);\n        } else {\n          list.delete(key);\n        }\n      }\n      return [index3, release];\n    }\n  };\n}\nfunction StableCollection({ children }) {\n  let collection = React36.useRef(createCollection());\n  return /* @__PURE__ */ React36.createElement(StableCollectionContext.Provider, { value: collection }, children);\n}\nfunction useStableCollectionIndex(group) {\n  let collection = React36.useContext(StableCollectionContext);\n  if (!collection)\n    throw new Error(\"You must wrap your component in a <StableCollection>\");\n  let key = React36.useId();\n  let [idx, cleanupIdx] = collection.current.get(group, key);\n  React36.useEffect(() => cleanupIdx, []);\n  return idx;\n}\n\n// src/components/tabs/tabs.tsx\nvar reducers8 = {\n  [0 /* SetSelectedIndex */](state, action) {\n    var _a3;\n    let tabs = sortByDomNode(state.tabs, (tab) => tab.current);\n    let panels = sortByDomNode(state.panels, (panel) => panel.current);\n    let focusableTabs = tabs.filter((tab) => {\n      var _a4;\n      return !((_a4 = tab.current) == null ? void 0 : _a4.hasAttribute(\"disabled\"));\n    });\n    let nextState = { ...state, tabs, panels };\n    if (\n      // Underflow\n      action.index < 0 || // Overflow\n      action.index > tabs.length - 1\n    ) {\n      let direction = match(Math.sign(action.index - state.selectedIndex), {\n        [-1 /* Less */]: () => 1 /* Backwards */,\n        [0 /* Equal */]: () => {\n          return match(Math.sign(action.index), {\n            [-1 /* Less */]: () => 0 /* Forwards */,\n            [0 /* Equal */]: () => 0 /* Forwards */,\n            [1 /* Greater */]: () => 1 /* Backwards */\n          });\n        },\n        [1 /* Greater */]: () => 0 /* Forwards */\n      });\n      if (focusableTabs.length === 0) {\n        return nextState;\n      }\n      let nextSelectedIndex = match(direction, {\n        [0 /* Forwards */]: () => tabs.indexOf(focusableTabs[0]),\n        [1 /* Backwards */]: () => tabs.indexOf(focusableTabs[focusableTabs.length - 1])\n      });\n      return {\n        ...nextState,\n        selectedIndex: nextSelectedIndex === -1 ? state.selectedIndex : nextSelectedIndex\n      };\n    }\n    let before = tabs.slice(0, action.index);\n    let after = tabs.slice(action.index);\n    let next = [...after, ...before].find((tab) => focusableTabs.includes(tab));\n    if (!next)\n      return nextState;\n    let selectedIndex = (_a3 = tabs.indexOf(next)) != null ? _a3 : state.selectedIndex;\n    if (selectedIndex === -1)\n      selectedIndex = state.selectedIndex;\n    return { ...nextState, selectedIndex };\n  },\n  [1 /* RegisterTab */](state, action) {\n    if (state.tabs.includes(action.tab))\n      return state;\n    let activeTab = state.tabs[state.selectedIndex];\n    let adjustedTabs = sortByDomNode([...state.tabs, action.tab], (tab) => tab.current);\n    let selectedIndex = state.selectedIndex;\n    if (!state.info.current.isControlled) {\n      selectedIndex = adjustedTabs.indexOf(activeTab);\n      if (selectedIndex === -1)\n        selectedIndex = state.selectedIndex;\n    }\n    return { ...state, tabs: adjustedTabs, selectedIndex };\n  },\n  [2 /* UnregisterTab */](state, action) {\n    return { ...state, tabs: state.tabs.filter((tab) => tab !== action.tab) };\n  },\n  [3 /* RegisterPanel */](state, action) {\n    if (state.panels.includes(action.panel))\n      return state;\n    return {\n      ...state,\n      panels: sortByDomNode([...state.panels, action.panel], (panel) => panel.current)\n    };\n  },\n  [4 /* UnregisterPanel */](state, action) {\n    return { ...state, panels: state.panels.filter((panel) => panel !== action.panel) };\n  }\n};\nvar TabsDataContext = (0, import_react82.createContext)(null);\nTabsDataContext.displayName = \"TabsDataContext\";\nfunction useData4(component) {\n  let context = (0, import_react82.useContext)(TabsDataContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useData4);\n    throw err;\n  }\n  return context;\n}\nvar TabsActionsContext = (0, import_react82.createContext)(null);\nTabsActionsContext.displayName = \"TabsActionsContext\";\nfunction useActions2(component) {\n  let context = (0, import_react82.useContext)(TabsActionsContext);\n  if (context === null) {\n    let err = new Error(`<${component} /> is missing a parent <Tab.Group /> component.`);\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, useActions2);\n    throw err;\n  }\n  return context;\n}\nfunction stateReducer5(state, action) {\n  return match(action.type, reducers8, state, action);\n}\nvar DEFAULT_TABS_TAG = \"div\";\nfunction GroupFn4(props, ref) {\n  let {\n    defaultIndex = 0,\n    vertical = false,\n    manual = false,\n    onChange,\n    selectedIndex = null,\n    ...theirProps\n  } = props;\n  const orientation = vertical ? \"vertical\" : \"horizontal\";\n  const activation = manual ? \"manual\" : \"auto\";\n  let isControlled = selectedIndex !== null;\n  let info = useLatestValue({ isControlled });\n  let tabsRef = useSyncRefs(ref);\n  let [state, dispatch] = (0, import_react82.useReducer)(stateReducer5, {\n    info,\n    selectedIndex: selectedIndex != null ? selectedIndex : defaultIndex,\n    tabs: [],\n    panels: []\n  });\n  let slot = (0, import_react82.useMemo)(\n    () => ({ selectedIndex: state.selectedIndex }),\n    [state.selectedIndex]\n  );\n  let onChangeRef = useLatestValue(onChange || (() => {\n  }));\n  let stableTabsRef = useLatestValue(state.tabs);\n  let tabsData = (0, import_react82.useMemo)(\n    () => ({ orientation, activation, ...state }),\n    [orientation, activation, state]\n  );\n  let registerTab = useEvent((tab) => {\n    dispatch({ type: 1 /* RegisterTab */, tab });\n    return () => dispatch({ type: 2 /* UnregisterTab */, tab });\n  });\n  let registerPanel = useEvent((panel) => {\n    dispatch({ type: 3 /* RegisterPanel */, panel });\n    return () => dispatch({ type: 4 /* UnregisterPanel */, panel });\n  });\n  let change = useEvent((index3) => {\n    if (realSelectedIndex.current !== index3) {\n      onChangeRef.current(index3);\n    }\n    if (!isControlled) {\n      dispatch({ type: 0 /* SetSelectedIndex */, index: index3 });\n    }\n  });\n  let realSelectedIndex = useLatestValue(isControlled ? props.selectedIndex : state.selectedIndex);\n  let tabsActions = (0, import_react82.useMemo)(() => ({ registerTab, registerPanel, change }), []);\n  useIsoMorphicEffect(() => {\n    dispatch({ type: 0 /* SetSelectedIndex */, index: selectedIndex != null ? selectedIndex : defaultIndex });\n  }, [\n    selectedIndex\n    /* Deliberately skipping defaultIndex */\n  ]);\n  useIsoMorphicEffect(() => {\n    if (realSelectedIndex.current === void 0)\n      return;\n    if (state.tabs.length <= 0)\n      return;\n    let sorted = sortByDomNode(state.tabs, (tab) => tab.current);\n    let didOrderChange = sorted.some((tab, i) => state.tabs[i] !== tab);\n    if (didOrderChange) {\n      change(sorted.indexOf(state.tabs[realSelectedIndex.current]));\n    }\n  });\n  let ourProps = { ref: tabsRef };\n  let render2 = useRender();\n  return /* @__PURE__ */ import_react82.default.createElement(StableCollection, null, /* @__PURE__ */ import_react82.default.createElement(TabsActionsContext.Provider, { value: tabsActions }, /* @__PURE__ */ import_react82.default.createElement(TabsDataContext.Provider, { value: tabsData }, tabsData.tabs.length <= 0 && /* @__PURE__ */ import_react82.default.createElement(\n    FocusSentinel,\n    {\n      onFocus: () => {\n        var _a3, _b2;\n        for (let tab of stableTabsRef.current) {\n          if (((_a3 = tab.current) == null ? void 0 : _a3.tabIndex) === 0) {\n            (_b2 = tab.current) == null ? void 0 : _b2.focus();\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n  ), render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TABS_TAG,\n    name: \"Tabs\"\n  }))));\n}\nvar DEFAULT_LIST_TAG = \"div\";\nfunction ListFn(props, ref) {\n  let { orientation, selectedIndex } = useData4(\"Tab.List\");\n  let listRef = useSyncRefs(ref);\n  let slot = (0, import_react82.useMemo)(() => ({ selectedIndex }), [selectedIndex]);\n  let theirProps = props;\n  let ourProps = {\n    ref: listRef,\n    role: \"tablist\",\n    \"aria-orientation\": orientation\n  };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_LIST_TAG,\n    name: \"Tabs.List\"\n  });\n}\nvar DEFAULT_TAB_TAG = \"button\";\nfunction TabFn(props, ref) {\n  var _a3, _b2;\n  let internalId = (0, import_react19.useId)();\n  let {\n    id = `headlessui-tabs-tab-${internalId}`,\n    disabled = false,\n    autoFocus = false,\n    ...theirProps\n  } = props;\n  let { orientation, activation, selectedIndex, tabs, panels } = useData4(\"Tab\");\n  let actions = useActions2(\"Tab\");\n  let data = useData4(\"Tab\");\n  let [tabElement, setTabElement] = (0, import_react82.useState)(null);\n  let internalTabRef = (0, import_react82.useRef)(null);\n  let tabRef = useSyncRefs(internalTabRef, ref, setTabElement);\n  useIsoMorphicEffect(() => actions.registerTab(internalTabRef), [actions, internalTabRef]);\n  let mySSRIndex = useStableCollectionIndex(\"tabs\");\n  let myIndex = tabs.indexOf(internalTabRef);\n  if (myIndex === -1)\n    myIndex = mySSRIndex;\n  let selected = myIndex === selectedIndex;\n  let activateUsing = useEvent((cb) => {\n    var _a4;\n    let result = cb();\n    if (result === 2 /* Success */ && activation === \"auto\") {\n      let newTab = (_a4 = getOwnerDocument(internalTabRef)) == null ? void 0 : _a4.activeElement;\n      let idx = data.tabs.findIndex((tab) => tab.current === newTab);\n      if (idx !== -1)\n        actions.change(idx);\n    }\n    return result;\n  });\n  let handleKeyDown = useEvent((event) => {\n    let list = tabs.map((tab) => tab.current).filter(Boolean);\n    if (event.key === \" \" /* Space */ || event.key === \"Enter\" /* Enter */) {\n      event.preventDefault();\n      event.stopPropagation();\n      actions.change(myIndex);\n      return;\n    }\n    switch (event.key) {\n      case \"Home\" /* Home */:\n      case \"PageUp\" /* PageUp */:\n        event.preventDefault();\n        event.stopPropagation();\n        return activateUsing(() => focusIn(list, 1 /* First */));\n      case \"End\" /* End */:\n      case \"PageDown\" /* PageDown */:\n        event.preventDefault();\n        event.stopPropagation();\n        return activateUsing(() => focusIn(list, 8 /* Last */));\n    }\n    let result = activateUsing(() => {\n      return match(orientation, {\n        vertical() {\n          if (event.key === \"ArrowUp\" /* ArrowUp */)\n            return focusIn(list, 2 /* Previous */ | 16 /* WrapAround */);\n          if (event.key === \"ArrowDown\" /* ArrowDown */)\n            return focusIn(list, 4 /* Next */ | 16 /* WrapAround */);\n          return 0 /* Error */;\n        },\n        horizontal() {\n          if (event.key === \"ArrowLeft\" /* ArrowLeft */)\n            return focusIn(list, 2 /* Previous */ | 16 /* WrapAround */);\n          if (event.key === \"ArrowRight\" /* ArrowRight */)\n            return focusIn(list, 4 /* Next */ | 16 /* WrapAround */);\n          return 0 /* Error */;\n        }\n      });\n    });\n    if (result === 2 /* Success */) {\n      return event.preventDefault();\n    }\n  });\n  let ready = (0, import_react82.useRef)(false);\n  let handleSelection = useEvent(() => {\n    var _a4;\n    if (ready.current)\n      return;\n    ready.current = true;\n    (_a4 = internalTabRef.current) == null ? void 0 : _a4.focus({ preventScroll: true });\n    actions.change(myIndex);\n    microTask(() => {\n      ready.current = false;\n    });\n  });\n  let handleMouseDown = useEvent((event) => {\n    event.preventDefault();\n  });\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let { pressed: active, pressProps } = useActivePress({ disabled });\n  let slot = (0, import_react82.useMemo)(() => {\n    return {\n      selected,\n      hover,\n      active,\n      focus,\n      autofocus: autoFocus,\n      disabled\n    };\n  }, [selected, hover, focus, active, autoFocus, disabled]);\n  let ourProps = mergeProps(\n    {\n      ref: tabRef,\n      onKeyDown: handleKeyDown,\n      onMouseDown: handleMouseDown,\n      onClick: handleSelection,\n      id,\n      role: \"tab\",\n      type: useResolveButtonType(props, tabElement),\n      \"aria-controls\": (_b2 = (_a3 = panels[myIndex]) == null ? void 0 : _a3.current) == null ? void 0 : _b2.id,\n      \"aria-selected\": selected,\n      tabIndex: selected ? 0 : -1,\n      disabled: disabled || void 0,\n      autoFocus\n    },\n    focusProps,\n    hoverProps,\n    pressProps\n  );\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TAB_TAG,\n    name: \"Tabs.Tab\"\n  });\n}\nvar DEFAULT_PANELS_TAG = \"div\";\nfunction PanelsFn(props, ref) {\n  let { selectedIndex } = useData4(\"Tab.Panels\");\n  let panelsRef = useSyncRefs(ref);\n  let slot = (0, import_react82.useMemo)(() => ({ selectedIndex }), [selectedIndex]);\n  let theirProps = props;\n  let ourProps = { ref: panelsRef };\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANELS_TAG,\n    name: \"Tabs.Panels\"\n  });\n}\nvar DEFAULT_PANEL_TAG4 = \"div\";\nvar PanelRenderFeatures3 = 1 /* RenderStrategy */ | 2 /* Static */;\nfunction PanelFn4(props, ref) {\n  var _a3, _b2, _c, _d;\n  let internalId = (0, import_react19.useId)();\n  let { id = `headlessui-tabs-panel-${internalId}`, tabIndex = 0, ...theirProps } = props;\n  let { selectedIndex, tabs, panels } = useData4(\"Tab.Panel\");\n  let actions = useActions2(\"Tab.Panel\");\n  let internalPanelRef = (0, import_react82.useRef)(null);\n  let panelRef = useSyncRefs(internalPanelRef, ref);\n  useIsoMorphicEffect(() => actions.registerPanel(internalPanelRef), [actions, internalPanelRef]);\n  let mySSRIndex = useStableCollectionIndex(\"panels\");\n  let myIndex = panels.indexOf(internalPanelRef);\n  if (myIndex === -1)\n    myIndex = mySSRIndex;\n  let selected = myIndex === selectedIndex;\n  let { isFocusVisible: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f();\n  let slot = (0, import_react82.useMemo)(() => ({ selected, focus }), [selected, focus]);\n  let ourProps = mergeProps(\n    {\n      ref: panelRef,\n      id,\n      role: \"tabpanel\",\n      \"aria-labelledby\": (_b2 = (_a3 = tabs[myIndex]) == null ? void 0 : _a3.current) == null ? void 0 : _b2.id,\n      tabIndex: selected ? tabIndex : -1\n    },\n    focusProps\n  );\n  let render2 = useRender();\n  if (!selected && ((_c = theirProps.unmount) != null ? _c : true) && !((_d = theirProps.static) != null ? _d : false)) {\n    return /* @__PURE__ */ import_react82.default.createElement(Hidden, { \"aria-hidden\": \"true\", ...ourProps });\n  }\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_PANEL_TAG4,\n    features: PanelRenderFeatures3,\n    visible: selected,\n    name: \"Tabs.Panel\"\n  });\n}\nvar TabRoot = forwardRefWithAs(TabFn);\nvar TabGroup = forwardRefWithAs(GroupFn4);\nvar TabList = forwardRefWithAs(ListFn);\nvar TabPanels = forwardRefWithAs(PanelsFn);\nvar TabPanel = forwardRefWithAs(PanelFn4);\nvar Tab = Object.assign(TabRoot, {\n  /** @deprecated use `<TabGroup>` instead of `<Tab.Group>` */\n  Group: TabGroup,\n  /** @deprecated use `<TabList>` instead of `<Tab.List>` */\n  List: TabList,\n  /** @deprecated use `<TabPanels>` instead of `<Tab.Panels>` */\n  Panels: TabPanels,\n  /** @deprecated use `<TabPanel>` instead of `<Tab.Panel>` */\n  Panel: TabPanel\n});\n\n// src/components/textarea/textarea.tsx\nvar import_react83 = require(\"react\");\nvar DEFAULT_TEXTAREA_TAG = \"textarea\";\nfunction TextareaFn(props, ref) {\n  let internalId = (0, import_react19.useId)();\n  let providedId = useProvidedId();\n  let providedDisabled = useDisabled();\n  let {\n    id = providedId || `headlessui-textarea-${internalId}`,\n    disabled = providedDisabled || false,\n    autoFocus = false,\n    invalid = false,\n    ...theirProps\n  } = props;\n  let labelledBy = useLabelledBy();\n  let describedBy = useDescribedBy();\n  let { isFocused: focus, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus });\n  let { isHovered: hover, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: disabled });\n  let ourProps = mergeProps(\n    {\n      ref,\n      id,\n      \"aria-labelledby\": labelledBy,\n      \"aria-describedby\": describedBy,\n      \"aria-invalid\": invalid ? \"true\" : void 0,\n      disabled: disabled || void 0,\n      autoFocus\n    },\n    focusProps,\n    hoverProps\n  );\n  let slot = (0, import_react83.useMemo)(() => {\n    return { disabled, invalid, hover, focus, autofocus: autoFocus };\n  }, [disabled, invalid, hover, focus, autoFocus]);\n  let render2 = useRender();\n  return render2({\n    ourProps,\n    theirProps,\n    slot,\n    defaultTag: DEFAULT_TEXTAREA_TAG,\n    name: \"Textarea\"\n  });\n}\nvar Textarea = forwardRefWithAs(TextareaFn);\n"
        }
    ]
}