{
    "sourceFile": "node_modules/@headlessui/react/dist/utils/render.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891769943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import React, { type ElementType, type Ref } from 'react';\nimport type { Expand, Props } from '../types.js';\nexport declare enum RenderFeatures {\n    /** No features at all */\n    None = 0,\n    /**\n     * When used, this will allow us to use one of the render strategies.\n     *\n     * **The render strategies are:**\n     *    - **Unmount**   _(Will unmount the component.)_\n     *    - **Hidden**    _(Will hide the component using the [hidden] attribute.)_\n     */\n    RenderStrategy = 1,\n    /**\n     * When used, this will allow the user of our component to be in control. This can be used when\n     * you want to transition based on some state.\n     */\n    Static = 2\n}\nexport declare enum RenderStrategy {\n    Unmount = 0,\n    Hidden = 1\n}\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;\ntype PropsForFeature<TPassedInFeatures extends RenderFeatures, TForFeature extends RenderFeatures, TProps> = TPassedInFeatures extends TForFeature ? TProps : {};\nexport type PropsForFeatures<T extends RenderFeatures> = Expand<UnionToIntersection<PropsForFeature<T, RenderFeatures.Static, {\n    static?: boolean;\n}> | PropsForFeature<T, RenderFeatures.RenderStrategy, {\n    unmount?: boolean;\n}>>>;\nexport declare function useRender(): typeof render;\ndeclare function render<TFeature extends RenderFeatures, TTag extends ElementType, TSlot>({ ourProps, theirProps, slot, defaultTag, features, visible, name, mergeRefs, }: {\n    ourProps: Expand<Props<TTag, TSlot, any> & PropsForFeatures<TFeature>> & {\n        ref?: Ref<HTMLElement | ElementType>;\n    };\n    theirProps: Expand<Props<TTag, TSlot, any>>;\n    slot?: TSlot;\n    defaultTag: ElementType;\n    features?: TFeature;\n    visible?: boolean;\n    name: string;\n    mergeRefs?: ReturnType<typeof useMergeRefsFn>;\n}): ReturnType<typeof _render> | null;\ndeclare function _render<TTag extends ElementType, TSlot>(props: Props<TTag, TSlot> & {\n    ref?: unknown;\n}, slot: TSlot | undefined, tag: ElementType, name: string, mergeRefs: ReturnType<typeof useMergeRefsFn>): React.ReactElement<any, string | React.JSXElementConstructor<any>>;\n/**\n * This is a singleton hook. **You can ONLY call the returned\n * function *once* to produce expected results.** If you need\n * to call `mergeRefs()` multiple times you need to create a\n * separate function for each invocation. This happens as we\n * store the list of `refs` to update and always return the\n * same function that refers to that list of refs.\n *\n * You shouldn't normally read refs during render but this\n * should actually be okay because React itself is calling\n * the `function` that updates these refs and can only do\n * so once the ref that contains the list is updated.\n */\ndeclare function useMergeRefsFn(): (...refs: any[]) => ((value: any) => void) | undefined;\nexport type HasDisplayName = {\n    displayName: string;\n};\nexport type RefProp<T extends Function> = T extends (props: any, ref: Ref<infer RefType>) => any ? {\n    ref?: Ref<RefType>;\n} : never;\nexport declare function mergeProps<T extends Props<any, any>[]>(...listOfProps: T): Props<any, any>;\n/**\n * This is a hack, but basically we want to keep the full 'API' of the component, but we do want to\n * wrap it in a forwardRef so that we _can_ passthrough the ref\n */\nexport declare function forwardRefWithAs<T extends {\n    name: string;\n    displayName?: string;\n}>(component: T): T & {\n    displayName: string;\n};\nexport declare function compact<T extends Record<any, any>>(object: T): {} & T;\nexport {};\n"
        }
    ]
}