{
    "sourceFile": "node_modules/@headlessui/react/dist/utils/focus-management.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891769564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { MutableRefObject } from 'react';\nexport declare let focusableSelector: string;\nexport declare enum Focus {\n    /** Focus the first non-disabled element */\n    First = 1,\n    /** Focus the previous non-disabled element */\n    Previous = 2,\n    /** Focus the next non-disabled element */\n    Next = 4,\n    /** Focus the last non-disabled element */\n    Last = 8,\n    /** Wrap tab around */\n    WrapAround = 16,\n    /** Prevent scrolling the focusable elements into view */\n    NoScroll = 32,\n    /** Focus the first focusable element with the `data-autofocus` attribute. */\n    AutoFocus = 64\n}\nexport declare enum FocusResult {\n    /** Something went wrong while trying to focus. */\n    Error = 0,\n    /** When `Focus.WrapAround` is enabled, going from position `N` to `N+1` where `N` is the last index in the array, then we overflow. */\n    Overflow = 1,\n    /** Focus was successful. */\n    Success = 2,\n    /** When `Focus.WrapAround` is enabled, going from position `N` to `N-1` where `N` is the first index in the array, then we underflow. */\n    Underflow = 3\n}\nexport declare function getFocusableElements(container?: HTMLElement | null): HTMLElement[];\nexport declare function getAutoFocusableElements(container?: HTMLElement | null): HTMLElement[];\nexport declare enum FocusableMode {\n    /** The element itself must be focusable. */\n    Strict = 0,\n    /** The element should be inside of a focusable element. */\n    Loose = 1\n}\nexport declare function isFocusableElement(element: HTMLElement, mode?: FocusableMode): boolean;\nexport declare function restoreFocusIfNecessary(element: HTMLElement | null): void;\nexport declare function focusElement(element: HTMLElement | null): void;\nexport declare function sortByDomNode<T>(nodes: T[], resolveKey?: (item: T) => HTMLElement | null): T[];\nexport declare function focusFrom(current: HTMLElement | null, focus: Focus): FocusResult;\nexport declare function focusIn(container: HTMLElement | HTMLElement[], focus: Focus, { sorted, relativeTo, skipElements, }?: Partial<{\n    sorted: boolean;\n    relativeTo: HTMLElement | null;\n    skipElements: (HTMLElement | MutableRefObject<HTMLElement | null>)[];\n}>): FocusResult;\n"
        }
    ]
}