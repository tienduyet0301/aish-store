{
    "sourceFile": "node_modules/is-callable/test/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892329359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\n/* eslint no-magic-numbers: 1 */\n\nvar test = require('tape');\nvar isCallable = require('../');\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar v = require('es-value-fixtures');\nvar forEach = require('for-each');\nvar inspect = require('object-inspect');\nvar typedArrayNames = require('available-typed-arrays')();\nvar generators = require('make-generator-function')();\nvar arrows = require('make-arrow-function').list();\nvar asyncs = require('make-async-function').list();\nvar weirdlyCommentedArrowFn;\ntry {\n\t/* eslint-disable no-new-func */\n\tweirdlyCommentedArrowFn = Function('return cl/*/**/=>/**/ass - 1;')();\n\t/* eslint-enable no-new-func */\n} catch (e) { /**/ }\n\nvar isIE68 = !(0 in [undefined]);\nvar isFirefox = typeof window !== 'undefined' && ('netscape' in window) && (/ rv:/).test(navigator.userAgent);\nvar fnToStringCoerces;\ntry {\n\tFunction.prototype.toString.call(v.uncoercibleFnObject);\n\tfnToStringCoerces = true;\n} catch (e) {\n\tfnToStringCoerces = false;\n}\n\nvar noop = function () {};\nvar classFake = function classFake() { }; // eslint-disable-line func-name-matching\nvar returnClass = function () { return ' class '; };\nvar return3 = function () { return 3; };\n/* for coverage */\nnoop();\nclassFake();\nreturnClass();\nreturn3();\n/* end for coverage */\n\nvar proxy;\nif (typeof Proxy === 'function') {\n\ttry {\n\t\tproxy = new Proxy(function () {}, {});\n\t\t// for coverage\n\t\tproxy();\n\t\tString(proxy);\n\t} catch (_) {\n\t\t// Older engines throw a `TypeError` when `Function.prototype.toString` is called on a Proxy object.\n\t\tproxy = null;\n\t}\n}\n\nvar invokeFunction = function invokeFunctionString(str) {\n\tvar result;\n\ttry {\n\t\t/* eslint-disable no-new-func */\n\t\tvar fn = Function(str);\n\t\t/* eslint-enable no-new-func */\n\t\tresult = fn();\n\t} catch (e) {}\n\treturn result;\n};\n\nvar classConstructor = invokeFunction('\"use strict\"; return class Foo {}');\nvar hasDetectableClasses = classConstructor && Function.prototype.toString.call(classConstructor) === 'class Foo {}';\n\nvar commentedClass = invokeFunction('\"use strict\"; return class/*kkk*/\\n//blah\\n Bar\\n//blah\\n {}');\nvar commentedClassOneLine = invokeFunction('\"use strict\"; return class/**/A{}');\nvar classAnonymous = invokeFunction('\"use strict\"; return class{}');\nvar classAnonymousCommentedOneLine = invokeFunction('\"use strict\"; return class/*/*/{}');\n\ntest('not callables', function (t) {\n\tt.notOk(isCallable(), 'implicit undefined is not callable');\n\n\tforEach(v.nonFunctions.concat([\n\t\tObject(42),\n\t\tObject('foo'),\n\t\tNaN,\n\t\t[],\n\t\t/a/g,\n\t\tnew RegExp('a', 'g'),\n\t\tnew Date()\n\t]), function (nonFunction) {\n\t\tif (fnToStringCoerces && nonFunction === v.coercibleFnObject) {\n\t\t\tt.comment('FF 3.6 has a Function toString that coerces its receiver, so this test is skipped');\n\t\t\treturn;\n\t\t}\n\t\tif (nonFunction != null) { // eslint-disable-line eqeqeq\n\t\t\tif (isFirefox) {\n\t\t\t// Firefox 3 throws some kind of *object* here instead of a proper error\n\t\t\t\tt['throws'](\n\t\t\t\t\tfunction () { Function.prototype.toString.call(nonFunction); },\n\t\t\t\t\tinspect(nonFunction) + ' can not be used with Function toString'\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tt['throws'](\n\t\t\t\t\tfunction () { Function.prototype.toString.call(nonFunction); },\n\t\t\t\t\tTypeError,\n\t\t\t\t\tinspect(nonFunction) + ' can not be used with Function toString'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tt.equal(isCallable(nonFunction), false, inspect(nonFunction) + ' is not callable');\n\t});\n\n\tt.test('non-function with function in its [[Prototype]] chain', function (st) {\n\t\tvar Foo = function Bar() {};\n\t\tFoo.prototype = noop;\n\t\tst.equal(isCallable(Foo), true, 'sanity check: Foo is callable');\n\t\tst.equal(isCallable(new Foo()), false, 'instance of Foo is not callable');\n\t\tst.end();\n\t});\n\n\tt.end();\n});\n\ntest('@@toStringTag', { skip: !hasToStringTag }, function (t) {\n\tvar fakeFunction = {\n\t\ttoString: function () { return String(return3); },\n\t\tvalueOf: return3\n\t};\n\tfakeFunction[Symbol.toStringTag] = 'Function';\n\tt.equal(String(fakeFunction), String(return3));\n\tt.equal(Number(fakeFunction), return3());\n\tt.notOk(isCallable(fakeFunction), 'fake Function with @@toStringTag \"Function\" is not callable');\n\tt.end();\n});\n\ntest('Functions', function (t) {\n\tt.ok(isCallable(noop), 'function is callable');\n\tt.ok(isCallable(classFake), 'function with name containing \"class\" is callable');\n\tt.ok(isCallable(returnClass), 'function with string \" class \" is callable');\n\tt.ok(isCallable(isCallable), 'isCallable is callable');\n\tt.end();\n});\n\ntest('Typed Arrays', { skip: typedArrayNames.length === 0 }, function (st) {\n\tforEach(typedArrayNames, function (typedArray) {\n\t\tst.ok(isCallable(global[typedArray]), typedArray + ' is callable');\n\t});\n\tst.end();\n});\n\ntest('Generators', { skip: generators.length === 0 }, function (t) {\n\tforEach(generators, function (genFn) {\n\t\tt.ok(isCallable(genFn), 'generator function ' + genFn + ' is callable');\n\t});\n\tt.end();\n});\n\ntest('Arrow functions', { skip: arrows.length === 0 }, function (t) {\n\tforEach(arrows, function (arrowFn) {\n\t\tt.ok(isCallable(arrowFn), 'arrow function ' + arrowFn + ' is callable');\n\t});\n\tt.ok(isCallable(weirdlyCommentedArrowFn), 'weirdly commented arrow functions are callable');\n\tt.end();\n});\n\ntest('\"Class\" constructors', {\n\tskip: !classConstructor || !commentedClass || !commentedClassOneLine || !classAnonymous, todo: !hasDetectableClasses\n}, function (t) {\n\tif (!hasDetectableClasses) {\n\t\tt.comment('WARNING: This engine does not support detectable classes');\n\t}\n\tt.notOk(isCallable(classConstructor), 'class constructors are not callable');\n\tt.notOk(isCallable(commentedClass), 'class constructors with comments in the signature are not callable');\n\tt.notOk(isCallable(commentedClassOneLine), 'one-line class constructors with comments in the signature are not callable');\n\tt.notOk(isCallable(classAnonymous), 'anonymous class constructors are not callable');\n\tt.notOk(isCallable(classAnonymousCommentedOneLine), 'anonymous one-line class constructors with comments in the signature are not callable');\n\tt.end();\n});\n\ntest('`async function`s', { skip: asyncs.length === 0 }, function (t) {\n\tforEach(asyncs, function (asyncFn) {\n\t\tt.ok(isCallable(asyncFn), '`async function` ' + asyncFn + ' is callable');\n\t});\n\tt.end();\n});\n\ntest('proxies of functions', { skip: !proxy }, function (t) {\n\tt.equal(isCallable(proxy), true, 'proxies of functions are callable');\n\tt.end();\n});\n\ntest('throwing functions', function (t) {\n\tt.plan(1);\n\n\tvar thrower = function (a) { return a.b; };\n\tt.ok(isCallable(thrower), 'a function that throws is callable');\n});\n\ntest('DOM', function (t) {\n\t/* eslint-env browser */\n\n\tt.test('document.all', { skip: typeof document !== 'object' }, function (st) {\n\t\tst.notOk(isCallable(document), 'document is not callable');\n\n\t\tvar all = document.all;\n\t\tvar isFF3 = !isIE68 && Object.prototype.toString(all) === Object.prototype.toString.call(document.all); // this test is true in IE 6-8 also\n\t\tvar expected = false;\n\t\tif (!isFF3) {\n\t\t\ttry {\n\t\t\t\texpected = document.all('') == null; // eslint-disable-line eqeqeq\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t\tst.equal(isCallable(document.all), expected, 'document.all is ' + (isFF3 ? 'not ' : '') + 'callable');\n\n\t\tst.end();\n\t});\n\n\tforEach([\n\t\t'HTMLElement',\n\t\t'HTMLAnchorElement'\n\t], function (name) {\n\t\tvar constructor = global[name];\n\n\t\tt.test(name, { skip: !constructor }, function (st) {\n\t\t\tst.match(typeof constructor, /^(?:function|object)$/, name + ' is a function or object');\n\n\t\t\tvar callable = isCallable(constructor);\n\t\t\tst.equal(typeof callable, 'boolean');\n\n\t\t\tif (callable) {\n\t\t\t\tst.doesNotThrow(\n\t\t\t\t\tfunction () { Function.prototype.toString.call(constructor); },\n\t\t\t\t\t'anything this library claims is callable should be accepted by Function toString'\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tst['throws'](\n\t\t\t\t\tfunction () { Function.prototype.toString.call(constructor); },\n\t\t\t\t\tTypeError,\n\t\t\t\t\t'anything this library claims is not callable should not be accepted by Function toString'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tst.end();\n\t\t});\n\t});\n\n\tt.end();\n});\n"
        }
    ]
}