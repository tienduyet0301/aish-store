{
    "sourceFile": "node_modules/flat-cache/src/cache.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892295340,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "const path = require('path');\nconst fs = require('fs');\nconst Keyv = require('keyv');\nconst { writeJSON, tryParse } = require('./utils');\nconst { del } = require('./del');\n\nconst cache = {\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\n   * then the cache module directory `./cache` will be used instead\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   */\n  load: function (docId, cacheDir) {\n    const me = this;\n    me.keyv = new Keyv();\n\n    me.__visited = {};\n    me.__persisted = {};\n\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = tryParse(me._pathToFile, {});\n    }\n  },\n\n  get _persisted() {\n    return this.__persisted;\n  },\n\n  set _persisted(value) {\n    this.__persisted = value;\n  },\n\n  get _visited() {\n    return this.__visited;\n  },\n\n  set _visited(value) {\n    this.__visited = value;\n  },\n\n  /**\n   * Load the cache from the provided file\n   * @method loadFile\n   * @param  {String} pathToFile the path to the file containing the info for the cache\n   */\n  loadFile: function (pathToFile) {\n    const me = this;\n    const dir = path.dirname(pathToFile);\n    const fName = path.basename(pathToFile);\n\n    me.load(fName, dir);\n  },\n\n  /**\n   * Returns the entire persisted object\n   * @method all\n   * @returns {*}\n   */\n  all: function () {\n    return this._persisted;\n  },\n\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n  /**\n   * sets a key to a given value\n   * @method setKey\n   * @param key {string} the key to set\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n  /**\n   * remove a given key from the cache\n   * @method removeKey\n   * @param key {String} the key to remove from the object\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n  /**\n   * Return the value of the provided key\n   * @method getKey\n   * @param key {String} the name of the key to retrieve\n   * @returns {*} the value from the key\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\n   * Remove keys that were not accessed/set since the\n   * last time the `prune` method was called.\n   * @method _prune\n   * @private\n   */\n  _prune: function () {\n    const me = this;\n    const obj = {};\n\n    const keys = Object.keys(me._visited);\n\n    // no keys visited for either get or set value\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\n   * Save the state of the cache identified by the docId to disk\n   * as a JSON structure\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\n   * @method save\n   */\n  save: function (noPrune) {\n    const me = this;\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\n   * remove the file where the cache is persisted\n   * @method removeCacheFile\n   * @return {Boolean} true or false if the file was successfully deleted\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n  /**\n   * Destroy the file cache and cache content.\n   * @method destroy\n   */\n  destroy: function () {\n    const me = this;\n    me._visited = {};\n    me._persisted = {};\n\n    me.removeCacheFile();\n  },\n};\n\nmodule.exports = {\n  /**\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\n   *\n   * @method load\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\n   * cache storage.\n   *\n   * @method create\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param [cacheDir] {String} directory for the cache entry\n   * @returns {cache} cache instance\n   */\n  create: function (docId, cacheDir) {\n    const obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n\n  createFromFile: function (filePath) {\n    const obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n  /**\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\n   *\n   * @method clearCache\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\n   * @param cacheDir {String} the directory where the cache file was written\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearCacheById: function (docId, cacheDir) {\n    const filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n  /**\n   * Remove all cache stored in the cache directory\n   * @method clearAll\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\n   */\n  clearAll: function (cacheDir) {\n    const filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  },\n};\n"
        }
    ]
}