{
    "sourceFile": "node_modules/postcss/lib/node.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892959045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import AtRule = require('./at-rule.js')\n\nimport { AtRuleProps } from './at-rule.js'\nimport Comment, { CommentProps } from './comment.js'\nimport Container, { NewChild } from './container.js'\nimport CssSyntaxError from './css-syntax-error.js'\nimport Declaration, { DeclarationProps } from './declaration.js'\nimport Document from './document.js'\nimport Input from './input.js'\nimport { Stringifier, Syntax } from './postcss.js'\nimport Result from './result.js'\nimport Root from './root.js'\nimport Rule, { RuleProps } from './rule.js'\nimport Warning, { WarningOptions } from './warning.js'\n\ndeclare namespace Node {\n  export type ChildNode = AtRule.default | Comment | Declaration | Rule\n\n  export type AnyNode =\n    | AtRule.default\n    | Comment\n    | Declaration\n    | Document\n    | Root\n    | Rule\n\n  export type ChildProps =\n    | AtRuleProps\n    | CommentProps\n    | DeclarationProps\n    | RuleProps\n\n  export interface Position {\n    /**\n     * Source line in file. In contrast to `offset` it starts from 1.\n     */\n    column: number\n\n    /**\n     * Source column in file.\n     */\n    line: number\n\n    /**\n     * Source offset in file. It starts from 0.\n     */\n    offset: number\n  }\n\n  export interface Range {\n    /**\n     * End position, exclusive.\n     */\n    end: Position\n\n    /**\n     * Start position, inclusive.\n     */\n    start: Position\n  }\n\n  /**\n   * Source represents an interface for the {@link Node.source} property.\n   */\n  export interface Source {\n    /**\n     * The inclusive ending position for the source\n     * code of a node.\n     */\n    end?: Position\n\n    /**\n     * The source file from where a node has originated.\n     */\n    input: Input\n\n    /**\n     * The inclusive starting position for the source\n     * code of a node.\n     */\n    start?: Position\n  }\n\n  /**\n   * Interface represents an interface for an object received\n   * as parameter by Node class constructor.\n   */\n  export interface NodeProps {\n    source?: Source\n  }\n\n  export interface NodeErrorOptions {\n    /**\n     * An ending index inside a node's string that should be highlighted as\n     * source of error.\n     */\n    endIndex?: number\n    /**\n     * An index inside a node's string that should be highlighted as source\n     * of error.\n     */\n    index?: number\n    /**\n     * Plugin name that created this error. PostCSS will set it automatically.\n     */\n    plugin?: string\n    /**\n     * A word inside a node's string, that should be highlighted as source\n     * of error.\n     */\n    word?: string\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  class Node extends Node_ {}\n  export { Node as default }\n}\n\n/**\n * It represents an abstract class that handles common\n * methods for other CSS abstract syntax tree nodes.\n *\n * Any node that represents CSS selector or value should\n * not extend the `Node` class.\n */\ndeclare abstract class Node_ {\n  /**\n   * It represents parent of the current node.\n   *\n   * ```js\n   * root.nodes[0].parent === root //=> true\n   * ```\n   */\n  parent: Container | Document | undefined\n\n  /**\n   * It represents unnecessary whitespace and characters present\n   * in the css source code.\n   *\n   * Information to generate byte-to-byte equal node string as it was\n   * in the origin input.\n   *\n   * The properties of the raws object are decided by parser,\n   * the default parser uses the following properties:\n   *\n   * * `before`: the space symbols before the node. It also stores `*`\n   *   and `_` symbols before the declaration (IE hack).\n   * * `after`: the space symbols after the last child of the node\n   *   to the end of the node.\n   * * `between`: the symbols between the property and value\n   *   for declarations, selector and `{` for rules, or last parameter\n   *   and `{` for at-rules.\n   * * `semicolon`: contains true if the last child has\n   *   an (optional) semicolon.\n   * * `afterName`: the space between the at-rule name and its parameters.\n   * * `left`: the space symbols between `/*` and the comment’s text.\n   * * `right`: the space symbols between the comment’s text\n   *   and <code>*&#47;</code>.\n   * - `important`: the content of the important statement,\n   *   if it is not just `!important`.\n   *\n   * PostCSS filters out the comments inside selectors, declaration values\n   * and at-rule parameters but it stores the origin content in raws.\n   *\n   * ```js\n   * const root = postcss.parse('a {\\n  color:black\\n}')\n   * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n   * ```\n   */\n  raws: any\n\n  /**\n   * It represents information related to origin of a node and is required\n   * for generating source maps.\n   *\n   * The nodes that are created manually using the public APIs\n   * provided by PostCSS will have `source` undefined and\n   * will be absent in the source map.\n   *\n   * For this reason, the plugin developer should consider\n   * duplicating nodes as the duplicate node will have the\n   * same source as the original node by default or assign\n   * source to a node created manually.\n   *\n   * ```js\n   * decl.source.input.from //=> '/home/ai/source.css'\n   * decl.source.start      //=> { line: 10, column: 2 }\n   * decl.source.end        //=> { line: 10, column: 12 }\n   * ```\n   *\n   * ```js\n   * // Incorrect method, source not specified!\n   * const prefixed = postcss.decl({\n   *   prop: '-moz-' + decl.prop,\n   *   value: decl.value\n   * })\n   *\n   * // Correct method, source is inherited when duplicating.\n   * const prefixed = decl.clone({\n   *   prop: '-moz-' + decl.prop\n   * })\n   * ```\n   *\n   * ```js\n   * if (atrule.name === 'add-link') {\n   *   const rule = postcss.rule({\n   *     selector: 'a',\n   *     source: atrule.source\n   *   })\n   *\n   *  atrule.parent.insertBefore(atrule, rule)\n   * }\n   * ```\n   */\n  source?: Node.Source\n\n  /**\n   * It represents type of a node in\n   * an abstract syntax tree.\n   *\n   * A type of node helps in identification of a node\n   * and perform operation based on it's type.\n   *\n   * ```js\n   * const declaration = new Declaration({\n   *   prop: 'color',\n   *   value: 'black'\n   * })\n   *\n   * declaration.type //=> 'decl'\n   * ```\n   */\n  type: string\n\n  constructor(defaults?: object)\n\n  /**\n   * Insert new node after current node to current node’s parent.\n   *\n   * Just alias for `node.parent.insertAfter(node, add)`.\n   *\n   * ```js\n   * decl.after('color: black')\n   * ```\n   *\n   * @param newNode New node.\n   * @return This node for methods chain.\n   */\n  after(\n    newNode: Node | Node.ChildProps | readonly Node[] | string | undefined\n  ): this\n\n  /**\n   * It assigns properties to an existing node instance.\n   *\n   * ```js\n   * decl.assign({ prop: 'word-wrap', value: 'break-word' })\n   * ```\n   *\n   * @param overrides New properties to override the node.\n   *\n   * @return `this` for method chaining.\n   */\n  assign(overrides: object): this\n\n  /**\n   * Insert new node before current node to current node’s parent.\n   *\n   * Just alias for `node.parent.insertBefore(node, add)`.\n   *\n   * ```js\n   * decl.before('content: \"\"')\n   * ```\n   *\n   * @param newNode New node.\n   * @return This node for methods chain.\n   */\n  before(\n    newNode: Node | Node.ChildProps | readonly Node[] | string | undefined\n  ): this\n\n  /**\n   * Clear the code style properties for the node and its children.\n   *\n   * ```js\n   * node.raws.before  //=> ' '\n   * node.cleanRaws()\n   * node.raws.before  //=> undefined\n   * ```\n   *\n   * @param keepBetween Keep the `raws.between` symbols.\n   */\n  cleanRaws(keepBetween?: boolean): void\n\n  /**\n   * It creates clone of an existing node, which includes all the properties\n   * and their values, that includes `raws` but not `type`.\n   *\n   * ```js\n   * decl.raws.before    //=> \"\\n  \"\n   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })\n   * cloned.raws.before  //=> \"\\n  \"\n   * cloned.toString()   //=> -moz-transform: scale(0)\n   * ```\n   *\n   * @param overrides New properties to override in the clone.\n   *\n   * @return Duplicate of the node instance.\n   */\n  clone(overrides?: object): this\n\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * after the current node.\n   *\n   * @param overrides New properties to override in the clone.\n   * @return New node.\n   */\n  cloneAfter(overrides?: object): this\n\n  /**\n   * Shortcut to clone the node and insert the resulting cloned node\n   * before the current node.\n   *\n   * ```js\n   * decl.cloneBefore({ prop: '-moz-' + decl.prop })\n   * ```\n   *\n   * @param overrides Mew properties to override in the clone.\n   *\n   * @return New node\n   */\n  cloneBefore(overrides?: object): this\n\n  /**\n   * It creates an instance of the class `CssSyntaxError` and parameters passed\n   * to this method are assigned to the error instance.\n   *\n   * The error instance will have description for the\n   * error, original position of the node in the\n   * source, showing line and column number.\n   *\n   * If any previous map is present, it would be used\n   * to get original position of the source.\n   *\n   * The Previous Map here is referred to the source map\n   * generated by previous compilation, example: Less,\n   * Stylus and Sass.\n   *\n   * This method returns the error instance instead of\n   * throwing it.\n   *\n   * ```js\n   * if (!variables[name]) {\n   *   throw decl.error(`Unknown variable ${name}`, { word: name })\n   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n   *   //   color: $black\n   *   // a\n   *   //          ^\n   *   //   background: white\n   * }\n   * ```\n   *\n   * @param message Description for the error instance.\n   * @param options Options for the error instance.\n   *\n   * @return Error instance is returned.\n   */\n  error(message: string, options?: Node.NodeErrorOptions): CssSyntaxError\n\n  /**\n   * Returns the next child of the node’s parent.\n   * Returns `undefined` if the current node is the last child.\n   *\n   * ```js\n   * if (comment.text === 'delete next') {\n   *   const next = comment.next()\n   *   if (next) {\n   *     next.remove()\n   *   }\n   * }\n   * ```\n   *\n   * @return Next node.\n   */\n  next(): Node.ChildNode | undefined\n\n  /**\n   * Get the position for a word or an index inside the node.\n   *\n   * @param opts Options.\n   * @return Position.\n   */\n  positionBy(opts?: Pick<WarningOptions, 'index' | 'word'>): Node.Position\n\n  /**\n   * Convert string index to line/column.\n   *\n   * @param index The symbol number in the node’s string.\n   * @return Symbol position in file.\n   */\n  positionInside(index: number): Node.Position\n\n  /**\n   * Returns the previous child of the node’s parent.\n   * Returns `undefined` if the current node is the first child.\n   *\n   * ```js\n   * const annotation = decl.prev()\n   * if (annotation.type === 'comment') {\n   *   readAnnotation(annotation.text)\n   * }\n   * ```\n   *\n   * @return Previous node.\n   */\n  prev(): Node.ChildNode | undefined\n\n  /**\n   * Get the range for a word or start and end index inside the node.\n   * The start index is inclusive; the end index is exclusive.\n   *\n   * @param opts Options.\n   * @return Range.\n   */\n  rangeBy(\n    opts?: Pick<WarningOptions, 'endIndex' | 'index' | 'word'>\n  ): Node.Range\n\n  /**\n   * Returns a `raws` value. If the node is missing\n   * the code style property (because the node was manually built or cloned),\n   * PostCSS will try to autodetect the code style property by looking\n   * at other nodes in the tree.\n   *\n   * ```js\n   * const root = postcss.parse('a { background: white }')\n   * root.nodes[0].append({ prop: 'color', value: 'black' })\n   * root.nodes[0].nodes[1].raws.before   //=> undefined\n   * root.nodes[0].nodes[1].raw('before') //=> ' '\n   * ```\n   *\n   * @param prop        Name of code style property.\n   * @param defaultType Name of default value, it can be missed\n   *                    if the value is the same as prop.\n   * @return {string} Code style value.\n   */\n  raw(prop: string, defaultType?: string): string\n\n  /**\n   * It removes the node from its parent and deletes its parent property.\n   *\n   * ```js\n   * if (decl.prop.match(/^-webkit-/)) {\n   *   decl.remove()\n   * }\n   * ```\n   *\n   * @return `this` for method chaining.\n   */\n  remove(): this\n\n  /**\n   * Inserts node(s) before the current node and removes the current node.\n   *\n   * ```js\n   * AtRule: {\n   *   mixin: atrule => {\n   *     atrule.replaceWith(mixinRules[atrule.params])\n   *   }\n   * }\n   * ```\n   *\n   * @param nodes Mode(s) to replace current one.\n   * @return Current node to methods chain.\n   */\n  replaceWith(...nodes: NewChild[]): this\n\n  /**\n   * Finds the Root instance of the node’s tree.\n   *\n   * ```js\n   * root.nodes[0].nodes[0].root() === root\n   * ```\n   *\n   * @return Root parent.\n   */\n  root(): Root\n\n  /**\n   * Fix circular links on `JSON.stringify()`.\n   *\n   * @return Cleaned object.\n   */\n  toJSON(): object\n\n  /**\n   * It compiles the node to browser readable cascading style sheets string\n   * depending on it's type.\n   *\n   * ```js\n   * new Rule({ selector: 'a' }).toString() //=> \"a {}\"\n   * ```\n   *\n   * @param stringifier A syntax to use in string generation.\n   * @return CSS string of this node.\n   */\n  toString(stringifier?: Stringifier | Syntax): string\n\n  /**\n   * It is a wrapper for {@link Result#warn}, providing convenient\n   * way of generating warnings.\n   *\n   * ```js\n   *   Declaration: {\n   *     bad: (decl, { result }) => {\n   *       decl.warn(result, 'Deprecated property: bad')\n   *     }\n   *   }\n   * ```\n   *\n   * @param result The `Result` instance that will receive the warning.\n   * @param message Description for the warning.\n   * @param options Options for the warning.\n   *\n   * @return `Warning` instance is returned\n   */\n  warn(result: Result, message: string, options?: WarningOptions): Warning\n\n  /**\n   * If this node isn't already dirty, marks it and its ancestors as such. This\n   * indicates to the LazyResult processor that the {@link Root} has been\n   * modified by the current plugin and may need to be processed again by other\n   * plugins.\n   */\n  protected markDirty(): void\n}\n\ndeclare class Node extends Node_ {}\n\nexport = Node\n"
        }
    ]
}