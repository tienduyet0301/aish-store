{
    "sourceFile": "node_modules/goober/README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892319216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "<p align=\"center\">\n  <img src=\"./goober_cover.png\" width=\"500\" alt=\"goober\" />\n</p>\n\n🥜 goober, a less than 1KB css-in-js solution.\n\n[![Backers on Open Collective](https://opencollective.com/goober/backers/badge.svg)](#backers)\n[![Sponsors on Open Collective](https://opencollective.com/goober/sponsors/badge.svg)](#sponsors)\n\n[![version](https://img.shields.io/npm/v/goober)](https://www.npmjs.com/package/goober)\n[![status](https://travis-ci.org/cristianbote/goober.svg?branch=master)](https://travis-ci.org/cristianbote/goober)\n[![gzip size](https://img.badgesize.io/https://unpkg.com/goober@latest/dist/goober.modern.js?compression=gzip)](https://unpkg.com/goober)\n[![downloads](https://img.shields.io/npm/dm/goober)](https://www.npmjs.com/package/goober)\n[![coverage](https://img.shields.io/codecov/c/github/cristianbote/goober.svg?maxAge=2592000)](https://codecov.io/github/cristianbote/goober?branch=master)\n[![Slack](https://img.shields.io/badge/slack-join-orange)](https://join.slack.com/t/gooberdev/shared_invite/enQtOTM5NjUyOTcwNzI1LWUwNzg0NTQwODY1NDJmMzQ2NzdlODI4YTM3NWUwYjlkY2ZkNGVmMTFlNGMwZGUyOWQyZmI4OTYwYmRiMzE0NGQ)\n\n# 🪒 The Great Shave Off Challenge\n\nCan you shave off bytes from goober? Do it and you're gonna get paid! [More info here](https://goober.rocks/the-great-shave-off)\n\n# Motivation\n\nI've always wondered if you could get a working solution for css-in-js with a smaller footprint. While I was working on a side project I wanted to use styled-components, or more accurately the `styled` pattern. Looking at the JavaScript bundle sizes, I quickly realized that I would have to include ~12kB([styled-components](https://github.com/styled-components/styled-components)) or ~11kB([emotion](https://github.com/emotion-js/emotion)) just so I can use the `styled` paradigm. So, I embarked on a mission to create a smaller alternative for these well established APIs.\n\n# Why the peanuts emoji?\n\nIt's a pun on the tagline.\n\n> css-in-js at the cost of peanuts!\n> 🥜goober\n\n# Talks and Podcasts\n\n* [React Round Up](https://reactroundup.com/wrangle-your-css-in-js-for-peanuts-using-goober-ft-cristian-bote-rru-177) 👉 https://reactroundup.com/wrangle-your-css-in-js-for-peanuts-using-goober-ft-cristian-bote-rru-177\n* ReactDay Berlin 2019 👉  https://www.youtube.com/watch?v=k4-AVy3acqk\n* [PodRocket](https://podrocket.logrocket.com/) by [LogRocket](https://logrocket.com/) 👉 https://podrocket.logrocket.com/goober\n* [ngParty](https://www.ngparty.cz/) 👉 https://www.youtube.com/watch?v=XKFvOBDPeB0\n\n# Table of contents\n\n-   [Usage](#usage)\n-   [Examples](#examples)\n-   [Tradeoffs](#comparison-and-tradeoffs)\n-   [SSR](#ssr)\n-   [Benchmarks](#benchmarks)\n    -   [Browser](#browser)\n    -   [SSR](#ssr-1)\n-   [API](#api)\n    -   [styled](#styledtagname-string--function-forwardref-function)\n    -   [setup](#setuppragma-function-prefixer-function-theme-function-forwardprops-function)\n        -   [With prefixer](#with-prefixer)\n        -   [With theme](#with-theme)\n        -   [With forwardProps](#with-forwardProps)\n    -   [css](#csstaggedtemplate)\n    -   [targets](#targets)\n    -   [extractCss](#extractcsstarget)\n    -   [createGlobalStyles](#createglobalstyles)\n    -   [keyframes](#keyframes)\n    -   [shouldForwardProp](#shouldForwardProp)\n-   [Integrations](#integrations)\n    -   [Babel Plugin](#babel-plugin)\n    -   [Babel Macro Plugin](#babel-macro-plugin)\n    -   [Next.js](#nextjs)\n    -   [Gatsby](#gatsby)\n    -   [Preact CLI Plugin](#preact-cli-plugin)\n    -   [CSS Prop](#css-prop)\n-   [Features](#features)\n    -   [Sharing Style](#sharing-style)\n    -   [Autoprefixer](#autoprefixer)\n    -   [TypeScript](#typescript)\n-   [Browser Support](#browser-support)\n-   [Contributing](#contributing)\n\n# Usage\n\nThe API is inspired by emotion `styled` function. Meaning, you call it with your `tagName`, and it returns a vDOM component for that tag. Note, `setup` needs to be ran before the `styled` function is used.\n\n```jsx\nimport { h } from 'preact';\nimport { styled, setup } from 'goober';\n\n// Should be called here, and just once\nsetup(h);\n\nconst Icon = styled('span')`\n    display: flex;\n    flex: 1;\n    color: red;\n`;\n\nconst Button = styled('button')`\n    background: dodgerblue;\n    color: white;\n    border: ${Math.random()}px solid white;\n\n    &:focus,\n    &:hover {\n        padding: 1em;\n    }\n\n    .otherClass {\n        margin: 0;\n    }\n\n    ${Icon} {\n        color: black;\n    }\n`;\n```\n\n# Examples\n\n-   [Vanilla](https://codesandbox.io/s/qlywyp7z4q)\n-   [React](https://codesandbox.io/s/k0mnp40n7v)\n-   [Preact](https://codesandbox.io/s/r15wj2qm7o)\n-   [SSR with Preact](https://codesandbox.io/s/7m9zzl6746)\n-   [Fre](https://codesandbox.io/s/fre-goober-ffqjv)\n\n# Comparison and tradeoffs\n\nIn this section I would like to compare goober, as objectively as I can, with the latest versions of two most well known css-in-js packages: styled-components and emotion.\n\nI've used the following markers to reflect the state of each feature:\n\n-   ✅ Supported\n-   🟡 Partially supported\n-   🛑 Not supported\n\nHere we go:\n\n| Feature name           | Goober  | Styled Components | Emotion |\n| ---------------------- | ------- | ----------------- | ------- |\n| Base bundle size       | 1.25 kB | 12.6 kB           | 7.4 kB  |\n| Framework agnostic     | ✅      | 🛑                | 🛑      |\n| Render with target \\*1 | ✅      | 🛑                | 🛑      |\n| `css` api              | ✅      | ✅                | ✅      |\n| `css` prop             | ✅      | ✅                | ✅      |\n| `styled`               | ✅      | ✅                | ✅      |\n| `styled.<tag>`         | ✅ \\*2  | ✅                | ✅      |\n| default export  | 🛑      | ✅                | ✅      |\n| `as`                   | ✅      | ✅                | ✅      |\n| `.withComponent`       | 🛑      | ✅                | ✅      |\n| `.attrs`               | 🛑      | ✅                | 🛑      |\n| `shouldForwardProp`    | ✅      | ✅                | ✅      |\n| `keyframes`            | ✅      | ✅                | ✅      |\n| Labels                 | 🛑      | 🛑                | ✅      |\n| ClassNames             | 🛑      | 🛑                | ✅      |\n| Global styles          | ✅      | ✅                | ✅      |\n| SSR                    | ✅      | ✅                | ✅      |\n| Theming                | ✅      | ✅                | ✅      |\n| Tagged Templates       | ✅      | ✅                | ✅      |\n| Object styles          | ✅      | ✅                | ✅      |\n| Dynamic styles         | ✅      | ✅                | ✅      |\n\nFootnotes\n\n-   [1] `goober` can render in _any_ dom target. Meaning you can use `goober` to define scoped styles in any context. Really useful for web-components.\n-   [2] Supported only via `babel-plugin-transform-goober`\n\n# SSR\n\nYou can get the critical CSS for SSR via `extractCss`. Take a look at this example: [CodeSandbox: SSR with Preact and goober](https://codesandbox.io/s/7m9zzl6746) and read the full explanation for `extractCSS` and `targets` below.\n\n# Benchmarks\n\nThe results are included inside the build output as well.\n\n## Browser\n\nComing soon!\n\n## SSR\n\nThe benchmark is testing the following scenario:\n\n```jsx\nimport styled from '<packageName>';\n\n// Create the dynamic styled component\nconst Foo = styled('div')((props) => ({\n    opacity: props.counter > 0.5 ? 1 : 0,\n    '@media (min-width: 1px)': {\n        rule: 'all'\n    },\n    '&:hover': {\n        another: 1,\n        display: 'space'\n    }\n}));\n\n// Serialize the component\nrenderToString(<Foo counter={Math.random()} />);\n```\n\nThe results are:\n\n```\ngoober x 200,437 ops/sec ±1.93% (87 runs sampled)\nstyled-components@5.2.1 x 12,650 ops/sec ±9.09% (48 runs sampled)\nemotion@11.0.0 x 104,229 ops/sec ±2.06% (88 runs sampled)\n\nFastest is: goober\n```\n\n# API\n\nAs you can see, goober supports most of the CSS syntax. If you find any issues, please submit a ticket, or open a PR with a fix.\n\n### `styled(tagName: String | Function, forwardRef?: Function)`\n\n-   `@param {String|Function} tagName` The name of the DOM element you'd like the styles to be applied to\n-   `@param {Function} forwardRef` Forward ref function. Usually `React.forwardRef`\n-   `@returns {Function}` Returns the tag template function.\n\n```js\nimport { styled } from 'goober';\n\nconst Btn = styled('button')`\n    border-radius: 4px;\n`;\n```\n\n#### Different ways of customizing the styles\n\n##### Tagged templates functions\n\n```js\nimport { styled } from 'goober';\n\nconst Btn = styled('button')`\n    border-radius: ${(props) => props.size}px;\n`;\n\n<Btn size={20} />;\n```\n\n##### Function that returns a string\n\n```js\nimport { styled } from 'goober';\n\nconst Btn = styled('button')(\n    (props) => `\n  border-radius: ${props.size}px;\n`\n);\n\n<Btn size={20} />;\n```\n\n##### JSON/Object\n\n```js\nimport { styled } from 'goober';\n\nconst Btn = styled('button')((props) => ({\n    borderRadius: props.size + 'px'\n}));\n\n<Btn size={20} />;\n```\n\n##### Arrays\n\n```js\nimport { styled } from 'goober';\n\nconst Btn = styled('button')([\n    { color: 'tomato' },\n    ({ isPrimary }) => ({ background: isPrimary ? 'cyan' : 'gray' })\n]);\n\n<Btn />; // This will render the `Button` with `background: gray;`\n<Btn isPrimary />; // This will render the `Button` with `background: cyan;`\n```\n\n##### Forward ref function\n\nAs goober is JSX library agnostic, you need to pass in the forward ref function for the library you are using. Here's how you do it for React.\n\n```js\nconst Title = styled('h1', React.forwardRef)`\n    font-weight: bold;\n    color: dodgerblue;\n`;\n```\n\n### `setup(pragma: Function, prefixer?: Function, theme?: Function, forwardProps?: Function)`\n\nThe call to `setup()` should occur only once. It should be called in the entry file of your project.\n\nGiven the fact that `react` uses `createElement` for the transformed elements and `preact` uses `h`, `setup` should be called with the proper _pragma_ function. This was added to reduce the bundled size and being able to bundle an esmodule version. At the moment, it's the best tradeoff I can think of.\n\n```js\nimport React from 'react';\nimport { setup } from 'goober';\n\nsetup(React.createElement);\n```\n\n#### With prefixer\n\n```js\nimport React from 'react';\nimport { setup } from 'goober';\n\nconst customPrefixer = (key, value) => `${key}: ${value};\\n`;\n\nsetup(React.createElement, customPrefixer);\n```\n\n#### With theme\n\n```js\nimport React, { createContext, useContext, createElement } from 'react';\nimport { setup, styled } from 'goober';\n\nconst theme = { primary: 'blue' };\nconst ThemeContext = createContext(theme);\nconst useTheme = () => useContext(ThemeContext);\n\nsetup(createElement, undefined, useTheme);\n\nconst ContainerWithTheme = styled('div')`\n    color: ${(props) => props.theme.primary};\n`;\n```\n\n#### With forwardProps\n\nThe `forwardProps` function offers a way to achieve the same `shouldForwardProps` functionality as emotion and styled-components (with transient props) offer. The difference here is that the function receives the whole props and you are in charge of removing the props that should not end up in the DOM.\n\nThis is a super useful functionality when paired with theme object, variants, or any other customisation one might need.\n\n```js\nimport React from 'react';\nimport { setup, styled } from 'goober';\n\nsetup(React.createElement, undefined, undefined, (props) => {\n    for (let prop in props) {\n        // Or any other conditions.\n        // This could also check if this is a dev build and not remove the props\n        if (prop === 'size') {\n            delete props[prop];\n        }\n    }\n});\n```\n\nThe functionality of \"transient props\" (with a \"\\$\" prefix) can be implemented as follows:\n\n```js\nimport React from 'react';\nimport { setup, styled } from 'goober';\n\nsetup(React.createElement, undefined, undefined, (props) => {\n    for (let prop in props) {\n        if (prop[0] === '$') {\n            delete props[prop];\n        }\n    }\n});\n```\n\nAlternatively you can use `goober/should-forward-prop` addon to pass only the filter function and not have to deal with the full `props` object.\n\n```js\nimport React from 'react';\nimport { setup, styled } from 'goober';\nimport { shouldForwardProp } from 'goober/should-forward-prop';\n\nsetup(\n    React.createElement,\n    undefined,\n    undefined,\n    // This package accepts a `filter` function. If you return false that prop\n    // won't be included in the forwarded props.\n    shouldForwardProp((prop) => {\n        return prop !== 'size';\n    })\n);\n```\n\n### `css(taggedTemplate)`\n\n-   `@returns {String}` Returns the className.\n\nTo create a className, you need to call `css` with your style rules in a tagged template.\n\n```js\nimport { css } from \"goober\";\n\nconst BtnClassName = css`\n  border-radius: 4px;\n`;\n\n// vanilla JS\nconst btn = document.querySelector(\"#btn\");\n// BtnClassName === 'g016232'\nbtn.classList.add(BtnClassName);\n\n// JSX\n// BtnClassName === 'g016232'\nconst App => <button className={BtnClassName}>click</button>\n```\n\n#### Different ways of customizing `css`\n\n##### Passing props to `css` tagged templates\n\n```js\nimport { css } from 'goober';\n\n// JSX\nconst CustomButton = (props) => (\n    <button\n        className={css`\n            border-radius: ${props.size}px;\n        `}\n    >\n        click\n    </button>\n);\n```\n\n##### Using `css` with JSON/Object\n\n```js\nimport { css } from 'goober';\nconst BtnClassName = (props) =>\n    css({\n        background: props.color,\n        borderRadius: props.radius + 'px'\n    });\n```\n\n**Notice:** using `css` with object can reduce your bundle size.\n\nWe can also declare styles at the top of the file by wrapping `css` into a function that we call to get the className.\n\n```js\nimport { css } from 'goober';\n\nconst BtnClassName = (props) => css`\n    border-radius: ${props.size}px;\n`;\n\n// vanilla JS\n// BtnClassName({size:20}) -> g016360\nconst btn = document.querySelector('#btn');\nbtn.classList.add(BtnClassName({ size: 20 }));\n\n// JSX\n// BtnClassName({size:20}) -> g016360\nconst App = () => <button className={BtnClassName({ size: 20 })}>click</button>;\n```\n\nThe difference between calling `css` directly and wrapping into a function is the timing of its execution. The former is when the component(file) is imported, the latter is when it is actually rendered.\n\nIf you use `extractCSS` for SSR, you may prefer to use the latter, or the `styled` API to avoid inconsistent results.\n\n### `targets`\n\nBy default, goober will append a style tag to the `<head>` of a document. You might want to target a different node, for instance, when you want to use goober with web components (so you'd want it to append style tags to individual shadowRoots). For this purpose, you can `.bind` a new target to the `styled` and `css` methods:\n\n```js\nimport * as goober from 'goober';\nconst target = document.getElementById('target');\nconst css = goober.css.bind({ target: target });\nconst styled = goober.styled.bind({ target: target });\n```\n\nIf you don't provide a target, goober always defaults to `<head>` and in environments without a DOM (think certain SSR solutions), it will just use a plain string cache to store generated styles which you can extract with `extractCSS`(see below).\n\n### `extractCss(target?)`\n\n-   `@returns {String}`\n\nReturns the `<style>` tag that is rendered in a target and clears the style sheet. Defaults to `<head>`.\n\n```js\nconst { extractCss } = require('goober');\n\n// After your app has rendered, just call it:\nconst styleTag = `<style id=\"_goober\">${extractCss()}</style>`;\n\n// Note: To be able to `hydrate` the styles you should use the proper `id` so `goober` can pick it up and use it as the target from now on\n```\n\n### `createGlobalStyles`\n\nTo define your global styles you need to create a `GlobalStyles` component and use it as part of your tree. The `createGlobalStyles` is available at `goober/global` addon.\n\n```js\nimport { createGlobalStyles } from 'goober/global';\n\nconst GlobalStyles = createGlobalStyles`\n  html,\n  body {\n    background: light;\n  }\n\n  * {\n    box-sizing: border-box;\n  }\n`;\n\nexport default function App() {\n    return (\n        <div id=\"root\">\n            <GlobalStyles />\n            <Navigation>\n            <RestOfYourApp>\n        </div>\n    )\n}\n```\n\n#### How about using `glob` function directly?\n\nBefore the global addon, `goober/global`, there was a method named `glob` that was part of the main package that would do the same thing, more or less. Having only that method to define global styles usually led to missing global styles from the extracted css, since the pattern did not enforce the evaluation of the styles at render time. The `glob` method is still exported from `goober/global`, in case you have a hard dependency on it. It still has the same API:\n\n```js\nimport { glob } from 'goober';\n\nglob`\n  html,\n  body {\n    background: light;\n  }\n\n  * {\n    box-sizing: border-box;\n  }\n`;\n```\n\n### `keyframes`\n\n`keyframes` is a helpful method to define reusable animations that can be decoupled from the main style declaration and shared across components.\n\n```js\nimport { keyframes } from 'goober';\n\nconst rotate = keyframes`\n    from, to {\n        transform: rotate(0deg);\n    }\n\n    50% {\n        transform: rotate(180deg);\n    }\n`;\n\nconst Wicked = styled('div')`\n    background: tomato;\n    color: white;\n    animation: ${rotate} 1s ease-in-out;\n`;\n```\n\n### `shouldForwardProp`\n\nTo implement the `shouldForwardProp` without the need to provide the full loop over `props` you can use the `goober/should-forward-prop` addon.\n\n```js\nimport { h } from 'preact';\nimport { setup } from 'goober';\nimport { shouldForwardProp } from 'goober/should-forward-prop';\n\nsetup(\n    h,\n    undefined,\n    undefined,\n    shouldForwardProp((prop) => {\n        // Do NOT forward props that start with `$` symbol\n        return prop['0'] !== '$';\n    })\n);\n```\n\n# Integrations\n\n## Babel plugin\n\nYou're in love with the `styled.div` syntax? Fear no more! We got you covered with a babel plugin that will take your lovely syntax from `styled.tag` and translate it to goober's `styled(\"tag\")` call.\n\n```sh\nnpm i --save-dev babel-plugin-transform-goober\n# or\nyarn add --dev babel-plugin-transform-goober\n```\n\nVisit the package in here for more info (https://github.com/cristianbote/goober/tree/master/packages/babel-plugin-transform-goober)\n\n## Babel macro plugin\n\nA babel-plugin-macros macro for [🥜goober][goober], rewriting `styled.div` syntax to `styled('div')` calls.\n\n### Usage\n\nOnce you've configured [babel-plugin-macros](https://github.com/kentcdodds/babel-plugin-macros), change your imports from `goober` to `goober/macro`.\n\nNow you can create your components using `styled.*` syntax:.\n\n```js\nimport { styled } from 'goober/macro';\n\nconst Button = styled.button`\n    margin: 0;\n    padding: 1rem;\n    font-size: 1rem;\n    background-color: tomato;\n`;\n```\n\n## [Next.js](https://github.com/vercel/next.js)\n\nWant to use `goober` with Next.js? We've got you covered! Follow the example below or from the main [examples](https://github.com/vercel/next.js/tree/canary/examples/with-goober) directory.\n\n```sh\nnpx create-next-app --example with-goober with-goober-app\n# or\nyarn create next-app --example with-goober with-goober-app\n```\n\n## [Gatsby](https://github.com/gatsbyjs/gatsby)\n\nWant to use `goober` with Gatsby? We've got you covered! We have our own plugin to deal with styling your Gatsby projects.\n\n```sh\nnpm i --save goober gatsby-plugin-goober\n# or\nyarn add goober gatsby-plugin-goober\n```\n\n## Preact CLI plugin\n\nIf you use Goober with Preact CLI, you can use [preact-cli-goober-ssr](https://github.com/gerhardsletten/preact-cli-goober-ssr)\n\n```sh\nnpm i --save-dev preact-cli-goober-ssr\n# or\nyarn add --dev preact-cli-goober-ssr\n\n# preact.config.js\nconst gooberPlugin = require('preact-cli-goober-ssr')\n\nexport default (config, env) => {\n  gooberPlugin(config, env)\n}\n```\n\nWhen you build your Preact application, this will run `extractCss` on your pre-rendered pages and add critical styles for each page.\n\n## CSS Prop\n\nYou can use a custom `css` prop to pass in styles on HTML elements with this Babel plugin.\n\nInstallation:\n\n```sh\nnpm install --save-dev @agney/babel-plugin-goober-css-prop\n```\n\nList the plugin in `.babelrc`:\n\n```\n{\n  \"plugins\": [\n    \"@agney/babel-plugin-goober-css-prop\"\n  ]\n}\n```\n\nUsage:\n\n```javascript\n<main\n    css={`\n        display: flex;\n        min-height: 100vh;\n        justify-content: center;\n        align-items: center;\n    `}\n>\n    <h1 css=\"color: dodgerblue\">Goober</h1>\n</main>\n```\n\n# Features\n\n-   [x] Basic CSS parsing\n-   [x] Nested rules with pseudo selectors\n-   [x] Nested styled components\n-   [x] [Extending Styles](#sharing-style)\n-   [x] Media queries (@media)\n-   [x] Keyframes (@keyframes)\n-   [x] Smart (lazy) client-side hydration\n-   [x] Styling any component\n    -   via `` const Btn = ({className}) => {...}; const TomatoBtn = styled(Btn)`color: tomato;` ``\n-   [x] Vanilla (via `css` function)\n-   [x] `globalStyle` (via `glob`) so one would be able to create global styles\n-   [x] target/extract from elements other than `<head>`\n-   [x] [vendor prefixing](#autoprefixer)\n\n# Sharing style\n\nThere are a couple of ways to effectively share/extend styles across components.\n\n## Extending\n\nYou can extend the desired component that needs to be enriched or overwritten with another set of css rules.\n\n```js\nimport { styled } from 'goober';\n\n// Let's declare a primitive for our styled component\nconst Primitive = styled('span')`\n    margin: 0;\n    padding: 0;\n`;\n\n// Later on we could get the primitive shared styles and also add our owns\nconst Container = styled(Primitive)`\n    padding: 1em;\n`;\n```\n\n## Using `as` prop\n\nAnother helpful way to extend a certain component is with the `as` property. Given our example above we could modify it like:\n\n```jsx\nimport { styled } from 'goober';\n\n// Our primitive element\nconst Primitive = styled('span')`\n    margin: 0;\n    padding: 0;\n`;\n\nconst Container = styled('div')`\n    padding: 1em;\n`;\n\n// At composition/render time\n<Primitive as={'div'} /> // <div class=\"go01234\" />\n\n// Or using the `Container`\n<Primitive as={Container} /> // <div class=\"go01234 go56789\" />\n```\n\n# Autoprefixer\n\nAutoprefixing is a helpful way to make sure the generated css will work seamlessly on the whole spectrum of browsers. With that in mind, the core `goober` package can't hold that logic to determine the autoprefixing needs, so we added a new package that you can choose to address them.\n\n```sh\nnpm install goober\n# or\nyarn add goober\n```\n\nAfter the main package is installed it's time to bootstrap goober with it:\n\n```js\nimport { setup } from 'goober';\nimport { prefix } from 'goober/prefixer';\n\n// Bootstrap goober\nsetup(React.createElement, prefix);\n```\n\nAnd voilà! It is done!\n\n# TypeScript\n\n`goober` comes with type definitions build in, making it easy to get started in TypeScript straight away.\n\n## Prop Types\n\nIf you're using custom props and wish to style based on them, you can do so as follows:\n\n```ts\ninterface Props {\n    size: number;\n}\n\nstyled('div')<Props>`\n    border-radius: ${(props) => props.size}px;\n`;\n\n// This also works!\n\nstyled<Props>('div')`\n    border-radius: ${(props) => props.size}px;\n`;\n```\n\n## Extending Theme\n\nIf you're using a [custom theme](../api/setup.md#with-theme) and want to add types to it, you can create a declaration file at the base of your project.\n\n```ts\n// goober.d.t.s\n\nimport 'goober';\n\ndeclare module 'goober' {\n    export interface DefaultTheme {\n        colors: {\n            primary: string;\n        };\n    }\n}\n```\n\nYou should now have autocompletion for your theme.\n\n```ts\nconst ThemeContainer = styled('div')`\n    background-color: ${(props) => props.theme.colors.primary};\n`;\n```\n\n# Browser support\n\n`goober` supports all major browsers (Chrome, Edge, Firefox, Safari).\n\nTo support IE 11 and older browsers, make sure to use a tool like [Babel](https://babeljs.io/) to transform your code into code that works in the browsers you target.\n\n# Contributing\n\nFeel free to try it out and checkout the examples. If you wanna fix something feel free to open a issue or a PR.\n\n## Backers\n\nThank you to all our backers! 🙏\n<a href=\"https://opencollective.com/goober#backers\" target=\"_blank\"><img src=\"https://opencollective.com/goober/backers.svg?width=890\"></a>\n\n## Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website.\n<a href=\"https://opencollective.com/goober#sponsors\" target=\"_blank\"><img src=\"https://opencollective.com/goober/sponsors.svg?width=890\"></a>\n"
        }
    ]
}