{
    "sourceFile": "node_modules/goober/src/core/parse.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892319827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Parses the object into css, scoped, blocks\n * @param {Object} obj\n * @param {String} selector\n * @param {String} wrapper\n */\nexport let parse = (obj, selector) => {\n    let outer = '';\n    let blocks = '';\n    let current = '';\n\n    for (let key in obj) {\n        let val = obj[key];\n\n        if (key[0] == '@') {\n            // If these are the `@` rule\n            if (key[1] == 'i') {\n                // Handling the `@import`\n                outer = key + ' ' + val + ';';\n            } else if (key[1] == 'f') {\n                // Handling the `@font-face` where the\n                // block doesn't need the brackets wrapped\n                blocks += parse(val, key);\n            } else {\n                // Regular at rule block\n                blocks += key + '{' + parse(val, key[1] == 'k' ? '' : selector) + '}';\n            }\n        } else if (typeof val == 'object') {\n            // Call the parse for this block\n            blocks += parse(\n                val,\n                selector\n                    ? // Go over the selector and replace the matching multiple selectors if any\n                      selector.replace(/([^,])+/g, (sel) => {\n                          // Return the current selector with the key matching multiple selectors if any\n                          return key.replace(/([^,]*:\\S+\\([^)]*\\))|([^,])+/g, (k) => {\n                              // If the current `k`(key) has a nested selector replace it\n                              if (/&/.test(k)) return k.replace(/&/g, sel);\n\n                              // If there's a current selector concat it\n                              return sel ? sel + ' ' + k : k;\n                          });\n                      })\n                    : key\n            );\n        } else if (val != undefined) {\n            // Convert all but CSS variables\n            key = /^--/.test(key) ? key : key.replace(/[A-Z]/g, '-$&').toLowerCase();\n            // Push the line for this property\n            current += parse.p\n                ? // We have a prefixer and we need to run this through that\n                  parse.p(key, val)\n                : // Nope no prefixer just append it\n                  key + ':' + val + ';';\n        }\n    }\n\n    // If we have properties apply standard rule composition\n    return outer + (selector && current ? selector + '{' + current + '}' : current) + blocks;\n};\n"
        }
    ]
}