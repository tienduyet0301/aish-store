{
    "sourceFile": "node_modules/goober/src/styled.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892320421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { css } from './css';\nimport { parse } from './core/parse';\n\nlet h, useTheme, fwdProp;\nfunction setup(pragma, prefix, theme, forwardProps) {\n    // This one needs to stay in here, so we won't have cyclic dependencies\n    parse.p = prefix;\n\n    // These are scope to this context\n    h = pragma;\n    useTheme = theme;\n    fwdProp = forwardProps;\n}\n\n/**\n * styled function\n * @param {string} tag\n * @param {function} forwardRef\n */\nfunction styled(tag, forwardRef) {\n    let _ctx = this || {};\n\n    return function wrapper() {\n        let _args = arguments;\n\n        function Styled(props, ref) {\n            // Grab a shallow copy of the props\n            let _props = Object.assign({}, props);\n\n            // Keep a local reference to the previous className\n            let _previousClassName = _props.className || Styled.className;\n\n            // _ctx.p: is the props sent to the context\n            _ctx.p = Object.assign({ theme: useTheme && useTheme() }, _props);\n\n            // Set a flag if the current components had a previous className\n            // similar to goober. This is the append/prepend flag\n            // The _empty_ space compresses better than `\\s`\n            _ctx.o = / *go\\d+/.test(_previousClassName);\n\n            _props.className =\n                // Define the new className\n                css.apply(_ctx, _args) + (_previousClassName ? ' ' + _previousClassName : '');\n\n            // If the forwardRef fun is defined we have the ref\n            if (forwardRef) {\n                _props.ref = ref;\n            }\n\n            // Assign the _as with the provided `tag` value\n            let _as = tag;\n\n            // If this is a string -- checking that is has a first valid char\n            if (tag[0]) {\n                // Try to assign the _as with the given _as value if any\n                _as = _props.as || tag;\n                // And remove it\n                delete _props.as;\n            }\n\n            // Handle the forward props filter if defined and _as is a string\n            if (fwdProp && _as[0]) {\n                fwdProp(_props);\n            }\n\n            return h(_as, _props);\n        }\n\n        return forwardRef ? forwardRef(Styled) : Styled;\n    };\n}\n\nexport { styled, setup };\n"
        }
    ]
}