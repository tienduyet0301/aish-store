{
    "sourceFile": "node_modules/@humanwhocodes/retry/dist/retrier.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891879694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A utility for retrying failed async method calls.\n */\n\n/* global setTimeout, clearTimeout */\n\n//-----------------------------------------------------------------------------\n// Constants\n//-----------------------------------------------------------------------------\n\nconst MAX_TASK_TIMEOUT = 60000;\nconst MAX_TASK_DELAY = 100;\nconst MAX_CONCURRENCY = 1000;\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Logs a message to the console if the DEBUG environment variable is set.\n * @param {string} message The message to log.\n * @returns {void}\n */\nfunction debug(message) {\n    if (globalThis?.process?.env.DEBUG === \"@hwc/retry\") {\n        console.debug(message);\n    }\n}\n\n/*\n * The following logic has been extracted from graceful-fs.\n *\n * The ISC License\n *\n * Copyright (c) 2011-2023 Isaac Z. Schlueter, Ben Noordhuis, and Contributors\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\n * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * Checks if it is time to retry a task based on the timestamp and last attempt time.\n * @param {RetryTask} task The task to check.\n * @param {number} maxDelay The maximum delay for the queue.\n * @returns {boolean} true if it is time to retry, false otherwise.\n */\nfunction isTimeToRetry(task, maxDelay) {\n    const timeSinceLastAttempt = Date.now() - task.lastAttempt;\n    const timeSinceStart = Math.max(task.lastAttempt - task.timestamp, 1);\n    const desiredDelay = Math.min(timeSinceStart * 1.2, maxDelay);\n\n    return timeSinceLastAttempt >= desiredDelay;\n}\n\n/**\n * Checks if it is time to bail out based on the given timestamp.\n * @param {RetryTask} task The task to check.\n * @param {number} timeout The timeout for the queue.\n * @returns {boolean} true if it is time to bail, false otherwise.\n */\nfunction isTimeToBail(task, timeout) {\n    return task.age > timeout;\n}\n\n/**\n * Creates a new promise with resolve and reject functions.\n * @returns {{promise:Promise<any>, resolve:(value:any) => any, reject: (value:any) => any}} A new promise.\n */\nfunction createPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n\n    let resolve, reject;\n\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n\n    if (resolve === undefined || reject === undefined) {\n        throw new Error(\"Promise executor did not initialize resolve or reject.\");\n    }\n\n    return { promise, resolve, reject };\n}\n\n\n/**\n * A class to represent a task in the retry queue.\n */\nclass RetryTask {\n\n    /**\n     * The unique ID for the task.\n     * @type {string}\n     */\n    id = Math.random().toString(36).slice(2);\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    fn;\n\n    /**\n     * The error that was thrown.\n     * @type {Error}\n     */\n    error;\n    \n    /**\n     * The timestamp of the task.\n     * @type {number}\n     */\n    timestamp = Date.now();\n\n    /**\n     * The timestamp of the last attempt.\n     * @type {number}\n     */\n    lastAttempt = this.timestamp;\n\n    /**\n     * The resolve function for the promise.\n     * @type {Function}\n     */\n    resolve;\n\n    /**\n     * The reject function for the promise.\n     * @type {Function}\n     */\n    reject;\n\n    /**\n     * The AbortSignal to monitor for cancellation.\n     * @type {AbortSignal|undefined}\n     */\n    signal;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} fn The function to call.\n     * @param {Error} error The error that was thrown.\n     * @param {Function} resolve The resolve function for the promise.\n     * @param {Function} reject The reject function for the promise.\n     * @param {AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.\n     */\n    constructor(fn, error, resolve, reject, signal) {\n        this.fn = fn;\n        this.error = error;\n        this.timestamp = Date.now();\n        this.lastAttempt = Date.now();\n        this.resolve = resolve;\n        this.reject = reject;\n        this.signal = signal;\n    }\n    \n    /**\n     * Gets the age of the task.\n     * @returns {number} The age of the task in milliseconds.\n     * @readonly\n     */\n    get age() {\n        return Date.now() - this.timestamp;\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class that manages a queue of retry jobs.\n */\nclass Retrier {\n\n    /**\n     * Represents the queue for processing tasks.\n     * @type {Array<RetryTask>}\n     */\n    #retrying = [];\n\n    /**\n     * Represents the queue for pending tasks.\n     * @type {Array<Function>}\n     */\n    #pending = [];\n\n    /**\n     * The number of tasks currently being processed.\n     * @type {number}\n     */\n    #working = 0;\n\n    /**\n     * The timeout for the queue.\n     * @type {number}\n     */\n    #timeout;\n\n    /**\n     * The maximum delay for the queue.\n     * @type {number}\n     */\n    #maxDelay;\n\n    /**\n     * The setTimeout() timer ID.\n     * @type {NodeJS.Timeout|undefined}\n     */\n    #timerId;\n\n    /**\n     * The function to call.\n     * @type {Function}\n     */\n    #check;\n\n    /**\n     * The maximum number of concurrent tasks.\n     * @type {number}\n     */\n    #concurrency;\n\n    /**\n     * Creates a new instance.\n     * @param {Function} check The function to call.\n     * @param {object} [options] The options for the instance.\n     * @param {number} [options.timeout] The timeout for the queue.\n     * @param {number} [options.maxDelay] The maximum delay for the queue.\n     * @param {number} [options.concurrency] The maximum number of concurrent tasks.\n     */\n    constructor(check, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY, concurrency = MAX_CONCURRENCY } = {}) {\n\n        if (typeof check !== \"function\") {\n            throw new Error(\"Missing function to check errors\");\n        }\n\n        this.#check = check;\n        this.#timeout = timeout;\n        this.#maxDelay = maxDelay;\n        this.#concurrency = concurrency;\n    }\n\n    /**\n     * Gets the number of tasks waiting to be retried.\n     * @returns {number} The number of tasks in the retry queue.\n     */\n    get retrying() {\n        return this.#retrying.length;\n    }\n\n    /**\n     * Gets the number of tasks waiting to be processed in the pending queue.\n     * @returns {number} The number of tasks in the pending queue.\n     */\n    get pending() {\n        return this.#pending.length;\n    }\n\n    /**\n     * Gets the number of tasks currently being processed.\n     * @returns {number} The number of tasks currently being processed.\n     */\n    get working() {\n        return this.#working;\n    }\n\n    /**\n     * Calls the function and retries if it fails.\n     * @param {Function} fn The function to call.\n     * @param {Object} options The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @param {Promise<any>} options.promise The promise to return when the function settles.\n     * @param {Function} options.resolve The resolve function for the promise.\n     * @param {Function} options.reject The reject function for the promise.\n     * @returns {Promise<any>} A promise that resolves when the function is\n     * called successfully.\n     */\n    #call(fn, { signal, promise, resolve, reject }) {\n\n        let result;\n\n        try {\n            result = fn();\n        } catch (/** @type {any} */ error) {\n            reject(new Error(`Synchronous error: ${error.message}`, { cause: error }));\n            return promise;\n        }\n\n        // if the result is not a promise then reject an error\n        if (!result || typeof result.then !== \"function\") {\n            reject(new Error(\"Result is not a promise.\"));\n            return promise;\n        }\n\n        this.#working++;\n        promise.finally(() => {\n            this.#working--;\n            this.#processPending();\n        })\n        // `promise.finally` creates a new promise that may be rejected, so it must be handled.\n            .catch(() => { });\n\n        // call the original function and catch any ENFILE or EMFILE errors\n        Promise.resolve(result)\n            .then(value => {\n                debug(\"Function called successfully without retry.\");\n                resolve(value);\n            })\n            .catch(error => {\n                if (!this.#check(error)) {\n                    reject(error);\n                    return;\n                }\n\n                const task = new RetryTask(fn, error, resolve, reject, signal);\n                \n                debug(`Function failed, queuing for retry with task ${task.id}.`);\n                this.#retrying.push(task);\n\n                signal?.addEventListener(\"abort\", () => {\n                    debug(`Task ${task.id} was aborted due to AbortSignal.`);\n                    reject(signal.reason);\n                });\n\n                this.#processQueue();\n            });\n        \n        return promise;\n    }\n\n    /**\n     * Adds a new retry job to the queue.\n     * @param {Function} fn The function to call.\n     * @param {object} [options] The options for the job.\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\n     * @returns {Promise<any>} A promise that resolves when the queue is\n     *  processed.\n     */\n    retry(fn, { signal } = {}) {\n\n        signal?.throwIfAborted();\n\n        const { promise, resolve, reject } = createPromise();\n\n        this.#pending.push(() => this.#call(fn, { signal, promise, resolve, reject }));\n        this.#processPending();\n        \n        return promise;\n    }\n\n\n    /**\n     * Processes the pending queue and the retry queue.\n     * @returns {void}\n     */\n    #processAll() {\n        if (this.pending) {\n            this.#processPending();\n        }\n\n        if (this.retrying) {\n            this.#processQueue();\n        }\n    }\n\n    /**\n     * Processes the pending queue to see which tasks can be started.\n     * @returns {void}\n     */\n    #processPending() {\n\n        debug(`Processing pending tasks: ${this.pending} pending, ${this.working} working.`);\n\n        const available = this.#concurrency - this.working;\n\n        if (available <= 0) {\n            return;\n        }\n\n        const count = Math.min(this.pending, available);\n\n        for (let i = 0; i < count; i++) {\n            const task = this.#pending.shift();\n            task?.();\n        }\n\n        debug(`Processed pending tasks: ${this.pending} pending, ${this.working} working.`);\n    }\n\n    /**\n     * Processes the queue.\n     * @returns {void}\n     */\n    #processQueue() {\n        // clear any timer because we're going to check right now\n        clearTimeout(this.#timerId);\n        this.#timerId = undefined;\n\n        debug(`Processing retry queue: ${this.retrying} retrying, ${this.working} working.`);\n\n        const processAgain = () => {\n            this.#timerId = setTimeout(() => this.#processAll(), 0);\n        };\n\n        // if there's nothing in the queue, we're done\n        const task = this.#retrying.shift();\n        if (!task) {\n            debug(\"Queue is empty, exiting.\");\n\n            if (this.pending) {\n                processAgain();\n            }\n            return;\n        }\n\n        // if it's time to bail, then bail\n        if (isTimeToBail(task, this.#timeout)) {\n            debug(`Task ${task.id} was abandoned due to timeout.`);\n            task.reject(task.error);\n            processAgain();\n            return;\n        }\n\n        // if it's not time to retry, then wait and try again\n        if (!isTimeToRetry(task, this.#maxDelay)) {\n            debug(`Task ${task.id} is not ready to retry, skipping.`);\n            this.#retrying.push(task);\n            processAgain();\n            return;\n        }\n\n        // otherwise, try again\n        task.lastAttempt = Date.now();\n        \n        // Promise.resolve needed in case it's a thenable but not a Promise\n        Promise.resolve(task.fn())\n            // @ts-ignore because we know it's any\n            .then(result => {\n                debug(`Task ${task.id} succeeded after ${task.age}ms.`);\n                task.resolve(result);\n            })\n\n            // @ts-ignore because we know it's any\n            .catch(error => {\n                if (!this.#check(error)) {\n                    debug(`Task ${task.id} failed with non-retryable error: ${error.message}.`);\n                    task.reject(error);\n                    return;\n                }\n\n                // update the task timestamp and push to back of queue to try again\n                task.lastAttempt = Date.now();\n                this.#retrying.push(task);\n                debug(`Task ${task.id} failed, requeueing to try again.`);\n            })\n            .finally(() => {\n                this.#processAll();\n            });\n    }\n}\n\nexport { Retrier };\n"
        }
    ]
}