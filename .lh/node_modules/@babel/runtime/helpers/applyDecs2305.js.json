{
    "sourceFile": "node_modules/@babel/runtime/helpers/applyDecs2305.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891751628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar checkInRHS = require(\"./checkInRHS.js\");\nvar setFunctionName = require(\"./setFunctionName.js\");\nvar toPropertyKey = require(\"./toPropertyKey.js\");\nfunction applyDecs2305(e, t, r, n, o, a) {\n  function i(e, t, r) {\n    return function (n, o) {\n      return r && r(n), e[t].call(n, o);\n    };\n  }\n  function c(e, t) {\n    for (var r = 0; r < e.length; r++) e[r].call(t);\n    return t;\n  }\n  function s(e, t, r, n) {\n    if (\"function\" != typeof e && (n || void 0 !== e)) throw new TypeError(t + \" must \" + (r || \"be\") + \" a function\" + (n ? \"\" : \" or undefined\"));\n    return e;\n  }\n  function applyDec(e, t, r, n, o, a, c, u, l, f, p, d, h) {\n    function m(e) {\n      if (!h(e)) throw new TypeError(\"Attempted to access private element on non-instance\");\n    }\n    var y,\n      v = t[0],\n      g = t[3],\n      b = !u;\n    if (!b) {\n      r || Array.isArray(v) || (v = [v]);\n      var w = {},\n        S = [],\n        A = 3 === o ? \"get\" : 4 === o || d ? \"set\" : \"value\";\n      f ? (p || d ? w = {\n        get: setFunctionName(function () {\n          return g(this);\n        }, n, \"get\"),\n        set: function set(e) {\n          t[4](this, e);\n        }\n      } : w[A] = g, p || setFunctionName(w[A], n, 2 === o ? \"\" : A)) : p || (w = Object.getOwnPropertyDescriptor(e, n));\n    }\n    for (var P = e, j = v.length - 1; j >= 0; j -= r ? 2 : 1) {\n      var D = v[j],\n        E = r ? v[j - 1] : void 0,\n        I = {},\n        O = {\n          kind: [\"field\", \"accessor\", \"method\", \"getter\", \"setter\", \"class\"][o],\n          name: n,\n          metadata: a,\n          addInitializer: function (e, t) {\n            if (e.v) throw Error(\"attempted to call addInitializer after decoration was finished\");\n            s(t, \"An initializer\", \"be\", !0), c.push(t);\n          }.bind(null, I)\n        };\n      try {\n        if (b) (y = s(D.call(E, P, O), \"class decorators\", \"return\")) && (P = y);else {\n          var k, F;\n          O[\"static\"] = l, O[\"private\"] = f, f ? 2 === o ? k = function k(e) {\n            return m(e), w.value;\n          } : (o < 4 && (k = i(w, \"get\", m)), 3 !== o && (F = i(w, \"set\", m))) : (k = function k(e) {\n            return e[n];\n          }, (o < 2 || 4 === o) && (F = function F(e, t) {\n            e[n] = t;\n          }));\n          var N = O.access = {\n            has: f ? h.bind() : function (e) {\n              return n in e;\n            }\n          };\n          if (k && (N.get = k), F && (N.set = F), P = D.call(E, d ? {\n            get: w.get,\n            set: w.set\n          } : w[A], O), d) {\n            if (\"object\" == _typeof(P) && P) (y = s(P.get, \"accessor.get\")) && (w.get = y), (y = s(P.set, \"accessor.set\")) && (w.set = y), (y = s(P.init, \"accessor.init\")) && S.push(y);else if (void 0 !== P) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n          } else s(P, (p ? \"field\" : \"method\") + \" decorators\", \"return\") && (p ? S.push(P) : w[A] = P);\n        }\n      } finally {\n        I.v = !0;\n      }\n    }\n    return (p || d) && u.push(function (e, t) {\n      for (var r = S.length - 1; r >= 0; r--) t = S[r].call(e, t);\n      return t;\n    }), p || b || (f ? d ? u.push(i(w, \"get\"), i(w, \"set\")) : u.push(2 === o ? w[A] : i.call.bind(w[A])) : Object.defineProperty(e, n, w)), P;\n  }\n  function u(e, t) {\n    return Object.defineProperty(e, Symbol.metadata || Symbol[\"for\"](\"Symbol.metadata\"), {\n      configurable: !0,\n      enumerable: !0,\n      value: t\n    });\n  }\n  if (arguments.length >= 6) var l = a[Symbol.metadata || Symbol[\"for\"](\"Symbol.metadata\")];\n  var f = Object.create(null == l ? null : l),\n    p = function (e, t, r, n) {\n      var o,\n        a,\n        i = [],\n        s = function s(t) {\n          return checkInRHS(t) === e;\n        },\n        u = new Map();\n      function l(e) {\n        e && i.push(c.bind(null, e));\n      }\n      for (var f = 0; f < t.length; f++) {\n        var p = t[f];\n        if (Array.isArray(p)) {\n          var d = p[1],\n            h = p[2],\n            m = p.length > 3,\n            y = 16 & d,\n            v = !!(8 & d),\n            g = 0 == (d &= 7),\n            b = h + \"/\" + v;\n          if (!g && !m) {\n            var w = u.get(b);\n            if (!0 === w || 3 === w && 4 !== d || 4 === w && 3 !== d) throw Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + h);\n            u.set(b, !(d > 2) || d);\n          }\n          applyDec(v ? e : e.prototype, p, y, m ? \"#\" + h : toPropertyKey(h), d, n, v ? a = a || [] : o = o || [], i, v, m, g, 1 === d, v && m ? s : r);\n        }\n      }\n      return l(o), l(a), i;\n    }(e, t, o, f);\n  return r.length || u(e, f), {\n    e: p,\n    get c() {\n      var t = [];\n      return r.length && [u(applyDec(e, [r], n, e.name, 5, f, t), f), c.bind(null, t, e)];\n    }\n  };\n}\nmodule.exports = applyDecs2305, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"
        }
    ]
}