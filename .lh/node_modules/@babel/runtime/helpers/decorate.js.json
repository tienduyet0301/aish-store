{
    "sourceFile": "node_modules/@babel/runtime/helpers/decorate.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891752794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var toArray = require(\"./toArray.js\");\nvar toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _decorate(e, r, t, i) {\n  var o = _getDecoratorsApi();\n  if (i) for (var n = 0; n < i.length; n++) o = i[n](o);\n  var s = r(function (e) {\n      o.initializeInstanceElements(e, a.elements);\n    }, t),\n    a = o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)), e);\n  return o.initializeClassElements(s.F, a.elements), o.runClassFinishers(s.F, a.finishers);\n}\nfunction _getDecoratorsApi() {\n  _getDecoratorsApi = function _getDecoratorsApi() {\n    return e;\n  };\n  var e = {\n    elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n    initializeInstanceElements: function initializeInstanceElements(e, r) {\n      [\"method\", \"field\"].forEach(function (t) {\n        r.forEach(function (r) {\n          r.kind === t && \"own\" === r.placement && this.defineClassElement(e, r);\n        }, this);\n      }, this);\n    },\n    initializeClassElements: function initializeClassElements(e, r) {\n      var t = e.prototype;\n      [\"method\", \"field\"].forEach(function (i) {\n        r.forEach(function (r) {\n          var o = r.placement;\n          if (r.kind === i && (\"static\" === o || \"prototype\" === o)) {\n            var n = \"static\" === o ? e : t;\n            this.defineClassElement(n, r);\n          }\n        }, this);\n      }, this);\n    },\n    defineClassElement: function defineClassElement(e, r) {\n      var t = r.descriptor;\n      if (\"field\" === r.kind) {\n        var i = r.initializer;\n        t = {\n          enumerable: t.enumerable,\n          writable: t.writable,\n          configurable: t.configurable,\n          value: void 0 === i ? void 0 : i.call(e)\n        };\n      }\n      Object.defineProperty(e, r.key, t);\n    },\n    decorateClass: function decorateClass(e, r) {\n      var t = [],\n        i = [],\n        o = {\n          \"static\": [],\n          prototype: [],\n          own: []\n        };\n      if (e.forEach(function (e) {\n        this.addElementPlacement(e, o);\n      }, this), e.forEach(function (e) {\n        if (!_hasDecorators(e)) return t.push(e);\n        var r = this.decorateElement(e, o);\n        t.push(r.element), t.push.apply(t, r.extras), i.push.apply(i, r.finishers);\n      }, this), !r) return {\n        elements: t,\n        finishers: i\n      };\n      var n = this.decorateConstructor(t, r);\n      return i.push.apply(i, n.finishers), n.finishers = i, n;\n    },\n    addElementPlacement: function addElementPlacement(e, r, t) {\n      var i = r[e.placement];\n      if (!t && -1 !== i.indexOf(e.key)) throw new TypeError(\"Duplicated element (\" + e.key + \")\");\n      i.push(e.key);\n    },\n    decorateElement: function decorateElement(e, r) {\n      for (var t = [], i = [], o = e.decorators, n = o.length - 1; n >= 0; n--) {\n        var s = r[e.placement];\n        s.splice(s.indexOf(e.key), 1);\n        var a = this.fromElementDescriptor(e),\n          l = this.toElementFinisherExtras((0, o[n])(a) || a);\n        e = l.element, this.addElementPlacement(e, r), l.finisher && i.push(l.finisher);\n        var c = l.extras;\n        if (c) {\n          for (var p = 0; p < c.length; p++) this.addElementPlacement(c[p], r);\n          t.push.apply(t, c);\n        }\n      }\n      return {\n        element: e,\n        finishers: i,\n        extras: t\n      };\n    },\n    decorateConstructor: function decorateConstructor(e, r) {\n      for (var t = [], i = r.length - 1; i >= 0; i--) {\n        var o = this.fromClassDescriptor(e),\n          n = this.toClassDescriptor((0, r[i])(o) || o);\n        if (void 0 !== n.finisher && t.push(n.finisher), void 0 !== n.elements) {\n          e = n.elements;\n          for (var s = 0; s < e.length - 1; s++) for (var a = s + 1; a < e.length; a++) if (e[s].key === e[a].key && e[s].placement === e[a].placement) throw new TypeError(\"Duplicated element (\" + e[s].key + \")\");\n        }\n      }\n      return {\n        elements: e,\n        finishers: t\n      };\n    },\n    fromElementDescriptor: function fromElementDescriptor(e) {\n      var r = {\n        kind: e.kind,\n        key: e.key,\n        placement: e.placement,\n        descriptor: e.descriptor\n      };\n      return Object.defineProperty(r, Symbol.toStringTag, {\n        value: \"Descriptor\",\n        configurable: !0\n      }), \"field\" === e.kind && (r.initializer = e.initializer), r;\n    },\n    toElementDescriptors: function toElementDescriptors(e) {\n      if (void 0 !== e) return toArray(e).map(function (e) {\n        var r = this.toElementDescriptor(e);\n        return this.disallowProperty(e, \"finisher\", \"An element descriptor\"), this.disallowProperty(e, \"extras\", \"An element descriptor\"), r;\n      }, this);\n    },\n    toElementDescriptor: function toElementDescriptor(e) {\n      var r = e.kind + \"\";\n      if (\"method\" !== r && \"field\" !== r) throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or \"field\", but a decorator created an element descriptor with .kind \"' + r + '\"');\n      var t = toPropertyKey(e.key),\n        i = e.placement + \"\";\n      if (\"static\" !== i && \"prototype\" !== i && \"own\" !== i) throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\", \"prototype\" or \"own\", but a decorator created an element descriptor with .placement \"' + i + '\"');\n      var o = e.descriptor;\n      this.disallowProperty(e, \"elements\", \"An element descriptor\");\n      var n = {\n        kind: r,\n        key: t,\n        placement: i,\n        descriptor: Object.assign({}, o)\n      };\n      return \"field\" !== r ? this.disallowProperty(e, \"initializer\", \"A method descriptor\") : (this.disallowProperty(o, \"get\", \"The property descriptor of a field descriptor\"), this.disallowProperty(o, \"set\", \"The property descriptor of a field descriptor\"), this.disallowProperty(o, \"value\", \"The property descriptor of a field descriptor\"), n.initializer = e.initializer), n;\n    },\n    toElementFinisherExtras: function toElementFinisherExtras(e) {\n      return {\n        element: this.toElementDescriptor(e),\n        finisher: _optionalCallableProperty(e, \"finisher\"),\n        extras: this.toElementDescriptors(e.extras)\n      };\n    },\n    fromClassDescriptor: function fromClassDescriptor(e) {\n      var r = {\n        kind: \"class\",\n        elements: e.map(this.fromElementDescriptor, this)\n      };\n      return Object.defineProperty(r, Symbol.toStringTag, {\n        value: \"Descriptor\",\n        configurable: !0\n      }), r;\n    },\n    toClassDescriptor: function toClassDescriptor(e) {\n      var r = e.kind + \"\";\n      if (\"class\" !== r) throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator created a class descriptor with .kind \"' + r + '\"');\n      this.disallowProperty(e, \"key\", \"A class descriptor\"), this.disallowProperty(e, \"placement\", \"A class descriptor\"), this.disallowProperty(e, \"descriptor\", \"A class descriptor\"), this.disallowProperty(e, \"initializer\", \"A class descriptor\"), this.disallowProperty(e, \"extras\", \"A class descriptor\");\n      var t = _optionalCallableProperty(e, \"finisher\");\n      return {\n        elements: this.toElementDescriptors(e.elements),\n        finisher: t\n      };\n    },\n    runClassFinishers: function runClassFinishers(e, r) {\n      for (var t = 0; t < r.length; t++) {\n        var i = (0, r[t])(e);\n        if (void 0 !== i) {\n          if (\"function\" != typeof i) throw new TypeError(\"Finishers must return a constructor.\");\n          e = i;\n        }\n      }\n      return e;\n    },\n    disallowProperty: function disallowProperty(e, r, t) {\n      if (void 0 !== e[r]) throw new TypeError(t + \" can't have a .\" + r + \" property.\");\n    }\n  };\n  return e;\n}\nfunction _createElementDescriptor(e) {\n  var r,\n    t = toPropertyKey(e.key);\n  \"method\" === e.kind ? r = {\n    value: e.value,\n    writable: !0,\n    configurable: !0,\n    enumerable: !1\n  } : \"get\" === e.kind ? r = {\n    get: e.value,\n    configurable: !0,\n    enumerable: !1\n  } : \"set\" === e.kind ? r = {\n    set: e.value,\n    configurable: !0,\n    enumerable: !1\n  } : \"field\" === e.kind && (r = {\n    configurable: !0,\n    writable: !0,\n    enumerable: !0\n  });\n  var i = {\n    kind: \"field\" === e.kind ? \"field\" : \"method\",\n    key: t,\n    placement: e[\"static\"] ? \"static\" : \"field\" === e.kind ? \"own\" : \"prototype\",\n    descriptor: r\n  };\n  return e.decorators && (i.decorators = e.decorators), \"field\" === e.kind && (i.initializer = e.value), i;\n}\nfunction _coalesceGetterSetter(e, r) {\n  void 0 !== e.descriptor.get ? r.descriptor.get = e.descriptor.get : r.descriptor.set = e.descriptor.set;\n}\nfunction _coalesceClassElements(e) {\n  for (var r = [], isSameElement = function isSameElement(e) {\n      return \"method\" === e.kind && e.key === o.key && e.placement === o.placement;\n    }, t = 0; t < e.length; t++) {\n    var i,\n      o = e[t];\n    if (\"method\" === o.kind && (i = r.find(isSameElement))) {\n      if (_isDataDescriptor(o.descriptor) || _isDataDescriptor(i.descriptor)) {\n        if (_hasDecorators(o) || _hasDecorators(i)) throw new ReferenceError(\"Duplicated methods (\" + o.key + \") can't be decorated.\");\n        i.descriptor = o.descriptor;\n      } else {\n        if (_hasDecorators(o)) {\n          if (_hasDecorators(i)) throw new ReferenceError(\"Decorators can't be placed on different accessors with for the same property (\" + o.key + \").\");\n          i.decorators = o.decorators;\n        }\n        _coalesceGetterSetter(o, i);\n      }\n    } else r.push(o);\n  }\n  return r;\n}\nfunction _hasDecorators(e) {\n  return e.decorators && e.decorators.length;\n}\nfunction _isDataDescriptor(e) {\n  return void 0 !== e && !(void 0 === e.value && void 0 === e.writable);\n}\nfunction _optionalCallableProperty(e, r) {\n  var t = e[r];\n  if (void 0 !== t && \"function\" != typeof t) throw new TypeError(\"Expected '\" + r + \"' to be a function\");\n  return t;\n}\nmodule.exports = _decorate, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"
        }
    ]
}