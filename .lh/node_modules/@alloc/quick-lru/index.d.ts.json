{
    "sourceFile": "node_modules/@alloc/quick-lru/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891751311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "declare namespace QuickLRU {\n\tinterface Options<KeyType, ValueType> {\n\t\t/**\n\t\tThe maximum number of milliseconds an item should remain in the cache.\n\n\t\t@default Infinity\n\n\t\tBy default, `maxAge` will be `Infinity`, which means that items will never expire.\n\t\tLazy expiration upon the next write or read call.\n\n\t\tIndividual expiration of an item can be specified by the `set(key, value, maxAge)` method.\n\t\t*/\n\t\treadonly maxAge?: number;\n\n\t\t/**\n\t\tThe maximum number of items before evicting the least recently used items.\n\t\t*/\n\t\treadonly maxSize: number;\n\n\t\t/**\n\t\tCalled right before an item is evicted from the cache.\n\n\t\tUseful for side effects or for items like object URLs that need explicit cleanup (`revokeObjectURL`).\n\t\t*/\n\t\tonEviction?: (key: KeyType, value: ValueType) => void;\n\t}\n}\n\ndeclare class QuickLRU<KeyType, ValueType>\n\timplements Iterable<[KeyType, ValueType]> {\n\t/**\n\tThe stored item count.\n\t*/\n\treadonly size: number;\n\n\t/**\n\tSimple [\"Least Recently Used\" (LRU) cache](https://en.m.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_.28LRU.29).\n\n\tThe instance is [`iterable`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols) so you can use it directly in a [`forâ€¦of`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of) loop.\n\n\t@example\n\t```\n\timport QuickLRU = require('quick-lru');\n\n\tconst lru = new QuickLRU({maxSize: 1000});\n\n\tlru.set('ðŸ¦„', 'ðŸŒˆ');\n\n\tlru.has('ðŸ¦„');\n\t//=> true\n\n\tlru.get('ðŸ¦„');\n\t//=> 'ðŸŒˆ'\n\t```\n\t*/\n\tconstructor(options: QuickLRU.Options<KeyType, ValueType>);\n\n\t[Symbol.iterator](): IterableIterator<[KeyType, ValueType]>;\n\n\t/**\n\tSet an item. Returns the instance.\n\n\tIndividual expiration of an item can be specified with the `maxAge` option. If not specified, the global `maxAge` value will be used in case it is specified in the constructor, otherwise the item will never expire.\n\n\t@returns The list instance.\n\t*/\n\tset(key: KeyType, value: ValueType, options?: {maxAge?: number}): this;\n\n\t/**\n\tGet an item.\n\n\t@returns The stored item or `undefined`.\n\t*/\n\tget(key: KeyType): ValueType | undefined;\n\n\t/**\n\tCheck if an item exists.\n\t*/\n\thas(key: KeyType): boolean;\n\n\t/**\n\tGet an item without marking it as recently used.\n\n\t@returns The stored item or `undefined`.\n\t*/\n\tpeek(key: KeyType): ValueType | undefined;\n\n\t/**\n\tDelete an item.\n\n\t@returns `true` if the item is removed or `false` if the item doesn't exist.\n\t*/\n\tdelete(key: KeyType): boolean;\n\n\t/**\n\tDelete all items.\n\t*/\n\tclear(): void;\n\n\t/**\n\tUpdate the `maxSize` in-place, discarding items as necessary. Insertion order is mostly preserved, though this is not a strong guarantee.\n\n\tUseful for on-the-fly tuning of cache sizes in live systems.\n\t*/\n\tresize(maxSize: number): void;\n\n\t/**\n\tIterable for all the keys.\n\t*/\n\tkeys(): IterableIterator<KeyType>;\n\n\t/**\n\tIterable for all the values.\n\t*/\n\tvalues(): IterableIterator<ValueType>;\n\n\t/**\n\tIterable for all entries, starting with the oldest (ascending in recency).\n\t*/\n\tentriesAscending(): IterableIterator<[KeyType, ValueType]>;\n\n\t/**\n\tIterable for all entries, starting with the newest (descending in recency).\n\t*/\n\tentriesDescending(): IterableIterator<[KeyType, ValueType]>;\n}\n\nexport = QuickLRU;\n"
        }
    ]
}