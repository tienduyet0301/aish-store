{
    "sourceFile": "node_modules/typed-array-byte-length/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893068797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar callBind = require('call-bind');\nvar forEach = require('for-each');\nvar gOPD = require('gopd');\nvar hasProto = require('has-proto')();\nvar isTypedArray = require('is-typed-array');\n\nvar typedArrays = require('available-typed-arrays')();\n\n/** @typedef {import('possible-typed-array-names')[number]} TypedArrayName */\n/** @typedef {(value: import('.').TypedArray) => number} Getter */\n\n/** @type {Partial<Record<TypedArrayName, Getter> & { __proto__: null }>} */\nvar getters = {\n\t__proto__: null\n};\n\nvar oDP = Object.defineProperty;\nif (gOPD) {\n\t/** @type {Getter} */\n\tvar getByteLength = function (x) {\n\t\treturn x.byteLength;\n\t};\n\tforEach(typedArrays, function (typedArray) {\n\t\t// In Safari 7, Typed Array constructors are typeof object\n\t\tif (typeof global[typedArray] === 'function' || typeof global[typedArray] === 'object') {\n\t\t\tvar TA = global[typedArray];\n\t\t\t/** @type {import('.').TypedArray} */\n\t\t\tvar Proto = TA.prototype;\n\t\t\t// @ts-expect-error TS doesn't narrow properly inside callbacks\n\t\t\tvar descriptor = gOPD(Proto, 'byteLength');\n\t\t\tif (!descriptor && hasProto) {\n\t\t\t\t// @ts-expect-error hush, TS, every object has a dunder proto\n\t\t\t\tvar superProto = Proto.__proto__; // eslint-disable-line no-proto\n\t\t\t\t// @ts-expect-error TS doesn't narrow properly inside callbacks\n\t\t\t\tdescriptor = gOPD(superProto, 'byteLength');\n\t\t\t}\n\t\t\t// Opera 12.16 has a magic byteLength data property on instances AND on Proto\n\t\t\tif (descriptor && descriptor.get) {\n\t\t\t\tgetters[typedArray] = callBind(descriptor.get);\n\t\t\t} else if (oDP) {\n\t\t\t\t// this is likely an engine where instances have a magic byteLength data property\n\t\t\t\tvar arr = new global[typedArray](2);\n\t\t\t\t// @ts-expect-error TS doesn't narrow properly inside callbacks\n\t\t\t\tdescriptor = gOPD(arr, 'byteLength');\n\t\t\t\tif (descriptor && descriptor.configurable) {\n\t\t\t\t\toDP(arr, 'length', { value: 3 });\n\t\t\t\t}\n\t\t\t\tif (arr.length === 2) {\n\t\t\t\t\tgetters[typedArray] = getByteLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\n/** @type {Getter} */\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\t/** @type {number} */ var foundByteLength;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {Record<TypedArrayName, Getter>} */ (getters),\n\t\t/** @type {(getter: Getter) => void} */ function (getter) {\n\t\t\tif (typeof foundByteLength !== 'number') {\n\t\t\t\ttry {\n\t\t\t\t\tvar byteLength = getter(value);\n\t\t\t\t\tif (typeof byteLength === 'number') {\n\t\t\t\t\t\tfoundByteLength = byteLength;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t}\n\t);\n\t// @ts-expect-error TS can't guarantee the callback is invoked sync\n\treturn foundByteLength;\n};\n\n/** @type {import('.')} */\nmodule.exports = function typedArrayByteLength(value) {\n\tif (!isTypedArray(value)) {\n\t\treturn false;\n\t}\n\treturn tryTypedArrays(value);\n};\n"
        }
    ]
}