{
    "sourceFile": "node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892614214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = void 0;\nconst net = require(\"net\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst deps_1 = require(\"../deps\");\nconst error_1 = require(\"../error\");\nconst mongo_client_1 = require(\"../mongo_client\");\nconst utils_1 = require(\"../utils\");\nconst client_encryption_1 = require(\"./client_encryption\");\nconst cryptoCallbacks = require(\"./crypto_callbacks\");\nconst errors_1 = require(\"./errors\");\nconst mongocryptd_manager_1 = require(\"./mongocryptd_manager\");\nconst providers_1 = require(\"./providers\");\nconst state_machine_1 = require(\"./state_machine\");\n/** @public */\nexports.AutoEncryptionLoggerLevel = Object.freeze({\n    FatalError: 0,\n    Error: 1,\n    Warning: 2,\n    Info: 3,\n    Trace: 4\n});\n/**\n * @internal An internal class to be used by the driver for auto encryption\n * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n */\nclass AutoEncrypter {\n    /** @internal */\n    static getMongoCrypt() {\n        const encryption = (0, deps_1.getMongoDBClientEncryption)();\n        if ('kModuleError' in encryption) {\n            throw encryption.kModuleError;\n        }\n        return encryption.MongoCrypt;\n    }\n    /**\n     * Create an AutoEncrypter\n     *\n     * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n     *\n     * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n     * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n     * Schemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\n     * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n     *\n     * @example <caption>Create an AutoEncrypter that makes use of mongocryptd</caption>\n     * ```ts\n     * // Enabling autoEncryption via a MongoClient using mongocryptd\n     * const { MongoClient } = require('mongodb');\n     * const client = new MongoClient(URL, {\n     *   autoEncryption: {\n     *     kmsProviders: {\n     *       aws: {\n     *         accessKeyId: AWS_ACCESS_KEY,\n     *         secretAccessKey: AWS_SECRET_KEY\n     *       }\n     *     }\n     *   }\n     * });\n     * ```\n     *\n     * await client.connect();\n     * // From here on, the client will be encrypting / decrypting automatically\n     * @example <caption>Create an AutoEncrypter that makes use of libmongocrypt's CSFLE shared library</caption>\n     * ```ts\n     * // Enabling autoEncryption via a MongoClient using CSFLE shared library\n     * const { MongoClient } = require('mongodb');\n     * const client = new MongoClient(URL, {\n     *   autoEncryption: {\n     *     kmsProviders: {\n     *       aws: {}\n     *     },\n     *     extraOptions: {\n     *       cryptSharedLibPath: '/path/to/local/crypt/shared/lib',\n     *       cryptSharedLibRequired: true\n     *     }\n     *   }\n     * });\n     * ```\n     *\n     * await client.connect();\n     * // From here on, the client will be encrypting / decrypting automatically\n     */\n    constructor(client, options) {\n        /**\n         * Used by devtools to enable decorating decryption results.\n         *\n         * When set and enabled, `decrypt` will automatically recursively\n         * traverse a decrypted document and if a field has been decrypted,\n         * it will mark it as decrypted.  Compass uses this to determine which\n         * fields were decrypted.\n         */\n        this[_a] = false;\n        this._client = client;\n        this._bypassEncryption = options.bypassAutoEncryption === true;\n        this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n        this._keyVaultClient = options.keyVaultClient || client;\n        this._metaDataClient = options.metadataClient || client;\n        this._proxyOptions = options.proxyOptions || {};\n        this._tlsOptions = options.tlsOptions || {};\n        this._kmsProviders = options.kmsProviders || {};\n        this._credentialProviders = options.credentialProviders;\n        if (options.credentialProviders?.aws && !(0, providers_1.isEmptyCredentials)('aws', this._kmsProviders)) {\n            throw new errors_1.MongoCryptInvalidArgumentError('Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching');\n        }\n        const mongoCryptOptions = {\n            enableMultipleCollinfo: true,\n            cryptoCallbacks\n        };\n        if (options.schemaMap) {\n            mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)\n                ? options.schemaMap\n                : (0, bson_1.serialize)(options.schemaMap);\n        }\n        if (options.encryptedFieldsMap) {\n            mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap)\n                ? options.encryptedFieldsMap\n                : (0, bson_1.serialize)(options.encryptedFieldsMap);\n        }\n        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders)\n            ? (0, bson_1.serialize)(this._kmsProviders)\n            : this._kmsProviders;\n        if (options.options?.logger) {\n            mongoCryptOptions.logger = options.options.logger;\n        }\n        if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {\n            mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;\n        }\n        if (options.bypassQueryAnalysis) {\n            mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;\n        }\n        this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;\n        if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {\n            // Only for driver testing\n            mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;\n        }\n        else if (!this._bypassMongocryptdAndCryptShared) {\n            mongoCryptOptions.cryptSharedLibSearchPaths = ['$SYSTEM'];\n        }\n        const MongoCrypt = AutoEncrypter.getMongoCrypt();\n        this._mongocrypt = new MongoCrypt(mongoCryptOptions);\n        this._contextCounter = 0;\n        if (options.extraOptions &&\n            options.extraOptions.cryptSharedLibRequired &&\n            !this.cryptSharedLibVersionInfo) {\n            throw new errors_1.MongoCryptInvalidArgumentError('`cryptSharedLibRequired` set but no crypt_shared library loaded');\n        }\n        // Only instantiate mongocryptd manager/client once we know for sure\n        // that we are not using the CSFLE shared library.\n        if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {\n            this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);\n            const clientOptions = {\n                serverSelectionTimeoutMS: 10000\n            };\n            if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== 'string') &&\n                !net.getDefaultAutoSelectFamily) {\n                // Only set family if autoSelectFamily options are not supported.\n                clientOptions.family = 4;\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore: TS complains as this always returns true on versions where it is present.\n            if (net.getDefaultAutoSelectFamily) {\n                // AutoEncrypter is made inside of MongoClient constructor while options are being parsed,\n                // we do not have access to the options that are in progress.\n                // TODO(NODE-6449): AutoEncrypter does not use client options for autoSelectFamily\n                Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.s?.options ?? {}));\n            }\n            this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);\n        }\n    }\n    /**\n     * Initializes the auto encrypter by spawning a mongocryptd and connecting to it.\n     *\n     * This function is a no-op when bypassSpawn is set or the crypt shared library is used.\n     */\n    async init() {\n        if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {\n            return;\n        }\n        if (!this._mongocryptdManager) {\n            throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.');\n        }\n        if (!this._mongocryptdClient) {\n            throw new error_1.MongoRuntimeError('Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.');\n        }\n        if (!this._mongocryptdManager.bypassSpawn) {\n            await this._mongocryptdManager.spawn();\n        }\n        try {\n            const client = await this._mongocryptdClient.connect();\n            return client;\n        }\n        catch (error) {\n            throw new error_1.MongoRuntimeError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn', { cause: error });\n        }\n    }\n    /**\n     * Cleans up the `_mongocryptdClient`, if present.\n     */\n    async teardown(force) {\n        await this._mongocryptdClient?.close(force);\n    }\n    /**\n     * Encrypt a command for a given namespace.\n     */\n    async encrypt(ns, cmd, options = {}) {\n        options.signal?.throwIfAborted();\n        if (this._bypassEncryption) {\n            // If `bypassAutoEncryption` has been specified, don't encrypt\n            return cmd;\n        }\n        const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);\n        const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);\n        context.id = this._contextCounter++;\n        context.ns = ns;\n        context.document = cmd;\n        const stateMachine = new state_machine_1.StateMachine({\n            promoteValues: false,\n            promoteLongs: false,\n            proxyOptions: this._proxyOptions,\n            tlsOptions: this._tlsOptions,\n            socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)\n        });\n        return (0, bson_1.deserialize)(await stateMachine.execute(this, context, options), {\n            promoteValues: false,\n            promoteLongs: false\n        });\n    }\n    /**\n     * Decrypt a command response\n     */\n    async decrypt(response, options = {}) {\n        options.signal?.throwIfAborted();\n        const context = this._mongocrypt.makeDecryptionContext(response);\n        context.id = this._contextCounter++;\n        const stateMachine = new state_machine_1.StateMachine({\n            ...options,\n            proxyOptions: this._proxyOptions,\n            tlsOptions: this._tlsOptions,\n            socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)\n        });\n        return await stateMachine.execute(this, context, options);\n    }\n    /**\n     * Ask the user for KMS credentials.\n     *\n     * This returns anything that looks like the kmsProviders original input\n     * option. It can be empty, and any provider specified here will override\n     * the original ones.\n     */\n    async askForKMSCredentials() {\n        return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);\n    }\n    /**\n     * Return the current libmongocrypt's CSFLE shared library version\n     * as `{ version: bigint, versionStr: string }`, or `null` if no CSFLE\n     * shared library was loaded.\n     */\n    get cryptSharedLibVersionInfo() {\n        return this._mongocrypt.cryptSharedLibVersionInfo;\n    }\n    static get libmongocryptVersion() {\n        return AutoEncrypter.getMongoCrypt().libmongocryptVersion;\n    }\n}\nexports.AutoEncrypter = AutoEncrypter;\n_a = constants_1.kDecorateResult;\n//# sourceMappingURL=auto_encrypter.js.map"
        }
    ]
}