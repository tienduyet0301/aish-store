{
    "sourceFile": "node_modules/mongodb/lib/client-side-encryption/state_machine.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892615269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StateMachine = void 0;\nconst fs = require(\"fs/promises\");\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst bson_1 = require(\"../bson\");\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\nconst deps_1 = require(\"../deps\");\nconst error_1 = require(\"../error\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst client_encryption_1 = require(\"./client_encryption\");\nconst errors_1 = require(\"./errors\");\nlet socks = null;\nfunction loadSocks() {\n    if (socks == null) {\n        const socksImport = (0, deps_1.getSocks)();\n        if ('kModuleError' in socksImport) {\n            throw socksImport.kModuleError;\n        }\n        socks = socksImport;\n    }\n    return socks;\n}\n// libmongocrypt states\nconst MONGOCRYPT_CTX_ERROR = 0;\nconst MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;\nconst MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;\nconst MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;\nconst MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;\nconst MONGOCRYPT_CTX_NEED_KMS = 4;\nconst MONGOCRYPT_CTX_READY = 5;\nconst MONGOCRYPT_CTX_DONE = 6;\nconst HTTPS_PORT = 443;\nconst stateToString = new Map([\n    [MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'],\n    [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'],\n    [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'],\n    [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'],\n    [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, 'MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS'],\n    [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'],\n    [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'],\n    [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']\n]);\nconst INSECURE_TLS_OPTIONS = [\n    'tlsInsecure',\n    'tlsAllowInvalidCertificates',\n    'tlsAllowInvalidHostnames',\n    // These options are disallowed by the spec, so we explicitly filter them out if provided, even\n    // though the StateMachine does not declare support for these options.\n    'tlsDisableOCSPEndpointCheck',\n    'tlsDisableCertificateRevocationCheck'\n];\n/**\n * Helper function for logging. Enabled by setting the environment flag MONGODB_CRYPT_DEBUG.\n * @param msg - Anything you want to be logged.\n */\nfunction debug(msg) {\n    if (process.env.MONGODB_CRYPT_DEBUG) {\n        // eslint-disable-next-line no-console\n        console.error(msg);\n    }\n}\n/**\n * This is kind of a hack.  For `rewrapManyDataKey`, we have tests that\n * guarantee that when there are no matching keys, `rewrapManyDataKey` returns\n * nothing.  We also have tests for auto encryption that guarantee for `encrypt`\n * we return an error when there are no matching keys.  This error is generated in\n * subsequent iterations of the state machine.\n * Some apis (`encrypt`) throw if there are no filter matches and others (`rewrapManyDataKey`)\n * do not.  We set the result manually here, and let the state machine continue.  `libmongocrypt`\n * will inform us if we need to error by setting the state to `MONGOCRYPT_CTX_ERROR` but\n * otherwise we'll return `{ v: [] }`.\n */\nlet EMPTY_V;\n/**\n * @internal\n * An internal class that executes across a MongoCryptContext until either\n * a finishing state or an error is reached. Do not instantiate directly.\n */\n// TODO(DRIVERS-2671): clarify CSOT behavior for FLE APIs\nclass StateMachine {\n    constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {\n        this.options = options;\n        this.bsonOptions = bsonOptions;\n    }\n    /**\n     * Executes the state machine according to the specification\n     */\n    async execute(executor, context, options) {\n        const keyVaultNamespace = executor._keyVaultNamespace;\n        const keyVaultClient = executor._keyVaultClient;\n        const metaDataClient = executor._metaDataClient;\n        const mongocryptdClient = executor._mongocryptdClient;\n        const mongocryptdManager = executor._mongocryptdManager;\n        let result = null;\n        // Typescript treats getters just like properties: Once you've tested it for equality\n        // it cannot change. Which is exactly the opposite of what we use state and status for.\n        // Every call to at least `addMongoOperationResponse` and `finalize` can change the state.\n        // These wrappers let us write code more naturally and not add compiler exceptions\n        // to conditions checks inside the state machine.\n        const getStatus = () => context.status;\n        const getState = () => context.state;\n        while (getState() !== MONGOCRYPT_CTX_DONE && getState() !== MONGOCRYPT_CTX_ERROR) {\n            options.signal?.throwIfAborted();\n            debug(`[context#${context.id}] ${stateToString.get(getState()) || getState()}`);\n            switch (getState()) {\n                case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {\n                    const filter = (0, bson_1.deserialize)(context.nextMongoOperation());\n                    if (!metaDataClient) {\n                        throw new errors_1.MongoCryptError('unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined');\n                    }\n                    const collInfoCursor = this.fetchCollectionInfo(metaDataClient, context.ns, filter, options);\n                    for await (const collInfo of collInfoCursor) {\n                        context.addMongoOperationResponse((0, bson_1.serialize)(collInfo));\n                        if (getState() === MONGOCRYPT_CTX_ERROR)\n                            break;\n                    }\n                    if (getState() === MONGOCRYPT_CTX_ERROR)\n                        break;\n                    context.finishMongoOperation();\n                    break;\n                }\n                case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {\n                    const command = context.nextMongoOperation();\n                    if (getState() === MONGOCRYPT_CTX_ERROR)\n                        break;\n                    if (!mongocryptdClient) {\n                        throw new errors_1.MongoCryptError('unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined');\n                    }\n                    // When we are using the shared library, we don't have a mongocryptd manager.\n                    const markedCommand = mongocryptdManager\n                        ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command, options))\n                        : await this.markCommand(mongocryptdClient, context.ns, command, options);\n                    context.addMongoOperationResponse(markedCommand);\n                    context.finishMongoOperation();\n                    break;\n                }\n                case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {\n                    const filter = context.nextMongoOperation();\n                    const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, options);\n                    if (keys.length === 0) {\n                        // See docs on EMPTY_V\n                        result = EMPTY_V ??= (0, bson_1.serialize)({ v: [] });\n                    }\n                    for await (const key of keys) {\n                        context.addMongoOperationResponse((0, bson_1.serialize)(key));\n                    }\n                    context.finishMongoOperation();\n                    break;\n                }\n                case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {\n                    const kmsProviders = await executor.askForKMSCredentials();\n                    context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));\n                    break;\n                }\n                case MONGOCRYPT_CTX_NEED_KMS: {\n                    await Promise.all(this.requests(context, options));\n                    context.finishKMSRequests();\n                    break;\n                }\n                case MONGOCRYPT_CTX_READY: {\n                    const finalizedContext = context.finalize();\n                    if (getState() === MONGOCRYPT_CTX_ERROR) {\n                        const message = getStatus().message || 'Finalization error';\n                        throw new errors_1.MongoCryptError(message);\n                    }\n                    result = finalizedContext;\n                    break;\n                }\n                default:\n                    throw new errors_1.MongoCryptError(`Unknown state: ${getState()}`);\n            }\n        }\n        if (getState() === MONGOCRYPT_CTX_ERROR || result == null) {\n            const message = getStatus().message;\n            if (!message) {\n                debug(`unidentifiable error in MongoCrypt - received an error status from \\`libmongocrypt\\` but received no error message.`);\n            }\n            throw new errors_1.MongoCryptError(message ??\n                'unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.');\n        }\n        return result;\n    }\n    /**\n     * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.\n     * @param kmsContext - A C++ KMS context returned from the bindings\n     * @returns A promise that resolves when the KMS reply has be fully parsed\n     */\n    async kmsRequest(request, options) {\n        const parsedUrl = request.endpoint.split(':');\n        const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;\n        const socketOptions = {\n            host: parsedUrl[0],\n            servername: parsedUrl[0],\n            port,\n            ...(0, client_encryption_1.autoSelectSocketOptions)(this.options.socketOptions || {})\n        };\n        const message = request.message;\n        const buffer = new utils_1.BufferPool();\n        let netSocket;\n        let socket;\n        function destroySockets() {\n            for (const sock of [socket, netSocket]) {\n                if (sock) {\n                    sock.destroy();\n                }\n            }\n        }\n        function onerror(cause) {\n            return new errors_1.MongoCryptError('KMS request failed', { cause });\n        }\n        function onclose() {\n            return new errors_1.MongoCryptError('KMS request closed');\n        }\n        const tlsOptions = this.options.tlsOptions;\n        if (tlsOptions) {\n            const kmsProvider = request.kmsProvider;\n            const providerTlsOptions = tlsOptions[kmsProvider];\n            if (providerTlsOptions) {\n                const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);\n                if (error) {\n                    throw error;\n                }\n                try {\n                    await this.setTlsOptions(providerTlsOptions, socketOptions);\n                }\n                catch (err) {\n                    throw onerror(err);\n                }\n            }\n        }\n        let abortListener;\n        try {\n            if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {\n                netSocket = new net.Socket();\n                const { promise: willConnect, reject: rejectOnNetSocketError, resolve: resolveOnNetSocketConnect } = (0, utils_1.promiseWithResolvers)();\n                netSocket\n                    .once('error', err => rejectOnNetSocketError(onerror(err)))\n                    .once('close', () => rejectOnNetSocketError(onclose()))\n                    .once('connect', () => resolveOnNetSocketConnect());\n                const netSocketOptions = {\n                    ...socketOptions,\n                    host: this.options.proxyOptions.proxyHost,\n                    port: this.options.proxyOptions.proxyPort || 1080\n                };\n                netSocket.connect(netSocketOptions);\n                await willConnect;\n                try {\n                    socks ??= loadSocks();\n                    socketOptions.socket = (await socks.SocksClient.createConnection({\n                        existing_socket: netSocket,\n                        command: 'connect',\n                        destination: { host: socketOptions.host, port: socketOptions.port },\n                        proxy: {\n                            // host and port are ignored because we pass existing_socket\n                            host: 'iLoveJavaScript',\n                            port: 0,\n                            type: 5,\n                            userId: this.options.proxyOptions.proxyUsername,\n                            password: this.options.proxyOptions.proxyPassword\n                        }\n                    })).socket;\n                }\n                catch (err) {\n                    throw onerror(err);\n                }\n            }\n            socket = tls.connect(socketOptions, () => {\n                socket.write(message);\n            });\n            const { promise: willResolveKmsRequest, reject: rejectOnTlsSocketError, resolve } = (0, utils_1.promiseWithResolvers)();\n            abortListener = (0, utils_1.addAbortListener)(options?.signal, function () {\n                destroySockets();\n                rejectOnTlsSocketError(this.reason);\n            });\n            socket\n                .once('error', err => rejectOnTlsSocketError(onerror(err)))\n                .once('close', () => rejectOnTlsSocketError(onclose()))\n                .on('data', data => {\n                buffer.append(data);\n                while (request.bytesNeeded > 0 && buffer.length) {\n                    const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);\n                    request.addResponse(buffer.read(bytesNeeded));\n                }\n                if (request.bytesNeeded <= 0) {\n                    resolve();\n                }\n            });\n            await (options?.timeoutContext?.csotEnabled()\n                ? Promise.all([\n                    willResolveKmsRequest,\n                    timeout_1.Timeout.expires(options.timeoutContext?.remainingTimeMS)\n                ])\n                : willResolveKmsRequest);\n        }\n        catch (error) {\n            if (error instanceof timeout_1.TimeoutError)\n                throw new error_1.MongoOperationTimeoutError('KMS request timed out');\n            throw error;\n        }\n        finally {\n            // There's no need for any more activity on this socket at this point.\n            destroySockets();\n            abortListener?.[utils_1.kDispose]();\n        }\n    }\n    *requests(context, options) {\n        for (let request = context.nextKMSRequest(); request != null; request = context.nextKMSRequest()) {\n            yield this.kmsRequest(request, options);\n        }\n    }\n    /**\n     * Validates the provided TLS options are secure.\n     *\n     * @param kmsProvider - The KMS provider name.\n     * @param tlsOptions - The client TLS options for the provider.\n     *\n     * @returns An error if any option is invalid.\n     */\n    validateTlsOptions(kmsProvider, tlsOptions) {\n        const tlsOptionNames = Object.keys(tlsOptions);\n        for (const option of INSECURE_TLS_OPTIONS) {\n            if (tlsOptionNames.includes(option)) {\n                return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);\n            }\n        }\n    }\n    /**\n     * Sets only the valid secure TLS options.\n     *\n     * @param tlsOptions - The client TLS options for the provider.\n     * @param options - The existing connection options.\n     */\n    async setTlsOptions(tlsOptions, options) {\n        if (tlsOptions.tlsCertificateKeyFile) {\n            const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);\n            options.cert = options.key = cert;\n        }\n        if (tlsOptions.tlsCAFile) {\n            options.ca = await fs.readFile(tlsOptions.tlsCAFile);\n        }\n        if (tlsOptions.tlsCertificateKeyFilePassword) {\n            options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;\n        }\n    }\n    /**\n     * Fetches collection info for a provided namespace, when libmongocrypt\n     * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is\n     * used to inform libmongocrypt of the schema associated with this\n     * namespace. Exposed for testing purposes. Do not directly invoke.\n     *\n     * @param client - A MongoClient connected to the topology\n     * @param ns - The namespace to list collections from\n     * @param filter - A filter for the listCollections command\n     * @param callback - Invoked with the info of the requested collection, or with an error\n     */\n    fetchCollectionInfo(client, ns, filter, options) {\n        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);\n        const cursor = client.db(db).listCollections(filter, {\n            promoteLongs: false,\n            promoteValues: false,\n            timeoutContext: options?.timeoutContext && new abstract_cursor_1.CursorTimeoutContext(options?.timeoutContext, Symbol()),\n            signal: options?.signal,\n            nameOnly: false\n        });\n        return cursor;\n    }\n    /**\n     * Calls to the mongocryptd to provide markings for a command.\n     * Exposed for testing purposes. Do not directly invoke.\n     * @param client - A MongoClient connected to a mongocryptd\n     * @param ns - The namespace (database.collection) the command is being executed on\n     * @param command - The command to execute.\n     * @param callback - Invoked with the serialized and marked bson command, or with an error\n     */\n    async markCommand(client, ns, command, options) {\n        const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);\n        const bsonOptions = { promoteLongs: false, promoteValues: false };\n        const rawCommand = (0, bson_1.deserialize)(command, bsonOptions);\n        const commandOptions = {\n            timeoutMS: undefined,\n            signal: undefined\n        };\n        if (options?.timeoutContext?.csotEnabled()) {\n            commandOptions.timeoutMS = options.timeoutContext.remainingTimeMS;\n        }\n        if (options?.signal) {\n            commandOptions.signal = options.signal;\n        }\n        const response = await client.db(db).command(rawCommand, {\n            ...bsonOptions,\n            ...commandOptions\n        });\n        return (0, bson_1.serialize)(response, this.bsonOptions);\n    }\n    /**\n     * Requests keys from the keyVault collection on the topology.\n     * Exposed for testing purposes. Do not directly invoke.\n     * @param client - A MongoClient connected to the topology\n     * @param keyVaultNamespace - The namespace (database.collection) of the keyVault Collection\n     * @param filter - The filter for the find query against the keyVault Collection\n     * @param callback - Invoked with the found keys, or with an error\n     */\n    fetchKeys(client, keyVaultNamespace, filter, options) {\n        const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);\n        const commandOptions = {\n            timeoutContext: undefined,\n            signal: undefined\n        };\n        if (options?.timeoutContext != null) {\n            commandOptions.timeoutContext = new abstract_cursor_1.CursorTimeoutContext(options.timeoutContext, Symbol());\n        }\n        if (options?.signal != null) {\n            commandOptions.signal = options.signal;\n        }\n        return client\n            .db(dbName)\n            .collection(collectionName, { readConcern: { level: 'majority' } })\n            .find((0, bson_1.deserialize)(filter), commandOptions)\n            .toArray();\n    }\n}\nexports.StateMachine = StateMachine;\n//# sourceMappingURL=state_machine.js.map"
        }
    ]
}