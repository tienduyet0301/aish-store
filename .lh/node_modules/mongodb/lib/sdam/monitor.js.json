{
    "sourceFile": "node_modules/mongodb/lib/sdam/monitor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892630739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = void 0;\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst connect_1 = require(\"../cmap/connect\");\nconst client_metadata_1 = require(\"../cmap/handshake/client_metadata\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_logger_1 = require(\"../mongo_logger\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst utils_1 = require(\"../utils\");\nconst common_1 = require(\"./common\");\nconst events_1 = require(\"./events\");\nconst server_1 = require(\"./server\");\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = (0, utils_1.makeStateMachine)({\n    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],\n    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],\n    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],\n    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);\nfunction isInCloseState(monitor) {\n    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;\n}\n/** @public */\nexports.ServerMonitoringMode = Object.freeze({\n    auto: 'auto',\n    poll: 'poll',\n    stream: 'stream'\n});\n/** @internal */\nclass Monitor extends mongo_types_1.TypedEventEmitter {\n    constructor(server, options) {\n        super();\n        /** @internal */\n        this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;\n        this.on('error', utils_1.noop);\n        this.server = server;\n        this.connection = null;\n        this.cancellationToken = new mongo_types_1.CancellationToken();\n        this.cancellationToken.setMaxListeners(Infinity);\n        this.monitorId = undefined;\n        this.s = {\n            state: common_1.STATE_CLOSED\n        };\n        this.address = server.description.address;\n        this.options = Object.freeze({\n            connectTimeoutMS: options.connectTimeoutMS ?? 10000,\n            heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 10000,\n            minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,\n            serverMonitoringMode: options.serverMonitoringMode\n        });\n        this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;\n        this.mongoLogger = this.server.topology.client?.mongoLogger;\n        this.rttSampler = new RTTSampler(10);\n        const cancellationToken = this.cancellationToken;\n        // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n        const connectOptions = {\n            id: '<monitor>',\n            generation: server.pool.generation,\n            cancellationToken,\n            hostAddress: server.description.hostAddress,\n            ...options,\n            // force BSON serialization options\n            raw: false,\n            useBigInt64: false,\n            promoteLongs: true,\n            promoteValues: true,\n            promoteBuffers: true\n        };\n        // ensure no authentication is used for monitoring\n        delete connectOptions.credentials;\n        if (connectOptions.autoEncrypter) {\n            delete connectOptions.autoEncrypter;\n        }\n        this.connectOptions = Object.freeze(connectOptions);\n    }\n    connect() {\n        if (this.s.state !== common_1.STATE_CLOSED) {\n            return;\n        }\n        // start\n        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n        this.monitorId = new MonitorInterval(monitorServer(this), {\n            heartbeatFrequencyMS: heartbeatFrequencyMS,\n            minHeartbeatFrequencyMS: minHeartbeatFrequencyMS,\n            immediate: true\n        });\n    }\n    requestCheck() {\n        if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n            return;\n        }\n        this.monitorId?.wake();\n    }\n    reset() {\n        const topologyVersion = this.server.description.topologyVersion;\n        if (isInCloseState(this) || topologyVersion == null) {\n            return;\n        }\n        stateTransition(this, common_1.STATE_CLOSING);\n        resetMonitorState(this);\n        // restart monitor\n        stateTransition(this, STATE_IDLE);\n        // restart monitoring\n        const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n        const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n        this.monitorId = new MonitorInterval(monitorServer(this), {\n            heartbeatFrequencyMS: heartbeatFrequencyMS,\n            minHeartbeatFrequencyMS: minHeartbeatFrequencyMS\n        });\n    }\n    close() {\n        if (isInCloseState(this)) {\n            return;\n        }\n        stateTransition(this, common_1.STATE_CLOSING);\n        resetMonitorState(this);\n        // close monitor\n        this.emit('close');\n        stateTransition(this, common_1.STATE_CLOSED);\n    }\n    get roundTripTime() {\n        return this.rttSampler.average();\n    }\n    get minRoundTripTime() {\n        return this.rttSampler.min();\n    }\n    get latestRtt() {\n        return this.rttSampler.last;\n    }\n    addRttSample(rtt) {\n        this.rttSampler.addSample(rtt);\n    }\n    clearRttSamples() {\n        this.rttSampler.clear();\n    }\n}\nexports.Monitor = Monitor;\nfunction resetMonitorState(monitor) {\n    monitor.monitorId?.stop();\n    monitor.monitorId = undefined;\n    monitor.rttPinger?.close();\n    monitor.rttPinger = undefined;\n    monitor.cancellationToken.emit('cancel');\n    monitor.connection?.destroy();\n    monitor.connection = null;\n    monitor.clearRttSamples();\n}\nfunction useStreamingProtocol(monitor, topologyVersion) {\n    // If we have no topology version we always poll no matter\n    // what the user provided, since the server does not support\n    // the streaming protocol.\n    if (topologyVersion == null)\n        return false;\n    const serverMonitoringMode = monitor.options.serverMonitoringMode;\n    if (serverMonitoringMode === exports.ServerMonitoringMode.poll)\n        return false;\n    if (serverMonitoringMode === exports.ServerMonitoringMode.stream)\n        return true;\n    // If we are in auto mode, we need to figure out if we're in a FaaS\n    // environment or not and choose the appropriate mode.\n    if (monitor.isRunningInFaasEnv)\n        return false;\n    return true;\n}\nfunction checkServer(monitor, callback) {\n    let start;\n    let awaited;\n    const topologyVersion = monitor.server.description.topologyVersion;\n    const isAwaitable = useStreamingProtocol(monitor, topologyVersion);\n    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));\n    function onHeartbeatFailed(err) {\n        monitor.connection?.destroy();\n        monitor.connection = null;\n        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));\n        const error = !(err instanceof error_1.MongoError)\n            ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err })\n            : err;\n        error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);\n        if (error instanceof error_1.MongoNetworkTimeoutError) {\n            error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);\n        }\n        monitor.emit('resetServer', error);\n        callback(err);\n    }\n    function onHeartbeatSucceeded(hello) {\n        if (!('isWritablePrimary' in hello)) {\n            // Provide hello-style response document.\n            hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];\n        }\n        // NOTE: here we use the latestRtt as this measurement corresponds with the value\n        // obtained for this successful heartbeat, if there is no latestRtt, then we calculate the\n        // duration\n        const duration = isAwaitable && monitor.rttPinger\n            ? (monitor.rttPinger.latestRtt ?? (0, utils_1.calculateDurationInMs)(start))\n            : (0, utils_1.calculateDurationInMs)(start);\n        monitor.addRttSample(duration);\n        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));\n        if (isAwaitable) {\n            // If we are using the streaming protocol then we immediately issue another 'started'\n            // event, otherwise the \"check\" is complete and return to the main monitor loop\n            monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));\n            // We have not actually sent an outgoing handshake, but when we get the next response we\n            // want the duration to reflect the time since we last heard from the server\n            start = (0, utils_1.now)();\n        }\n        else {\n            monitor.rttPinger?.close();\n            monitor.rttPinger = undefined;\n            callback(undefined, hello);\n        }\n    }\n    const { connection } = monitor;\n    if (connection && !connection.closed) {\n        const { serverApi, helloOk } = connection;\n        const connectTimeoutMS = monitor.options.connectTimeoutMS;\n        const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n        const cmd = {\n            [serverApi?.version || helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n            ...(isAwaitable && topologyVersion\n                ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n                : {})\n        };\n        const options = isAwaitable\n            ? {\n                socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,\n                exhaustAllowed: true\n            }\n            : { socketTimeoutMS: connectTimeoutMS };\n        if (isAwaitable && monitor.rttPinger == null) {\n            monitor.rttPinger = new RTTPinger(monitor);\n        }\n        // Record new start time before sending handshake\n        start = (0, utils_1.now)();\n        if (isAwaitable) {\n            awaited = true;\n            return connection.exhaustCommand((0, utils_1.ns)('admin.$cmd'), cmd, options, (error, hello) => {\n                if (error)\n                    return onHeartbeatFailed(error);\n                return onHeartbeatSucceeded(hello);\n            });\n        }\n        awaited = false;\n        connection\n            .command((0, utils_1.ns)('admin.$cmd'), cmd, options)\n            .then(onHeartbeatSucceeded, onHeartbeatFailed);\n        return;\n    }\n    // connecting does an implicit `hello`\n    (async () => {\n        const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);\n        const connection = (0, connect_1.makeConnection)(monitor.connectOptions, socket);\n        // The start time is after socket creation but before the handshake\n        start = (0, utils_1.now)();\n        try {\n            await (0, connect_1.performInitialHandshake)(connection, monitor.connectOptions);\n            return connection;\n        }\n        catch (error) {\n            connection.destroy();\n            throw error;\n        }\n    })().then(connection => {\n        if (isInCloseState(monitor)) {\n            connection.destroy();\n            return;\n        }\n        const duration = (0, utils_1.calculateDurationInMs)(start);\n        monitor.addRttSample(duration);\n        monitor.connection = connection;\n        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, connection.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection.hello, useStreamingProtocol(monitor, connection.hello?.topologyVersion)));\n        callback(undefined, connection.hello);\n    }, error => {\n        monitor.connection = null;\n        awaited = false;\n        onHeartbeatFailed(error);\n    });\n}\nfunction monitorServer(monitor) {\n    return (callback) => {\n        if (monitor.s.state === STATE_MONITORING) {\n            process.nextTick(callback);\n            return;\n        }\n        stateTransition(monitor, STATE_MONITORING);\n        function done() {\n            if (!isInCloseState(monitor)) {\n                stateTransition(monitor, STATE_IDLE);\n            }\n            callback();\n        }\n        checkServer(monitor, (err, hello) => {\n            if (err) {\n                // otherwise an error occurred on initial discovery, also bail\n                if (monitor.server.description.type === common_1.ServerType.Unknown) {\n                    return done();\n                }\n            }\n            // if the check indicates streaming is supported, immediately reschedule monitoring\n            if (useStreamingProtocol(monitor, hello?.topologyVersion)) {\n                (0, timers_1.setTimeout)(() => {\n                    if (!isInCloseState(monitor)) {\n                        monitor.monitorId?.wake();\n                    }\n                }, 0);\n            }\n            done();\n        });\n    };\n}\nfunction makeTopologyVersion(tv) {\n    return {\n        processId: tv.processId,\n        // tests mock counter as just number, but in a real situation counter should always be a Long\n        // TODO(NODE-2674): Preserve int64 sent from MongoDB\n        counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)\n    };\n}\n/** @internal */\nclass RTTPinger {\n    constructor(monitor) {\n        this.connection = undefined;\n        this.cancellationToken = monitor.cancellationToken;\n        this.closed = false;\n        this.monitor = monitor;\n        this.latestRtt = monitor.latestRtt ?? undefined;\n        const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n        this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);\n    }\n    get roundTripTime() {\n        return this.monitor.roundTripTime;\n    }\n    get minRoundTripTime() {\n        return this.monitor.minRoundTripTime;\n    }\n    close() {\n        this.closed = true;\n        (0, timers_1.clearTimeout)(this.monitorId);\n        this.connection?.destroy();\n        this.connection = undefined;\n    }\n    measureAndReschedule(start, conn) {\n        if (this.closed) {\n            conn?.destroy();\n            return;\n        }\n        if (this.connection == null) {\n            this.connection = conn;\n        }\n        this.latestRtt = (0, utils_1.calculateDurationInMs)(start);\n        this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);\n    }\n    measureRoundTripTime() {\n        const start = (0, utils_1.now)();\n        if (this.closed) {\n            return;\n        }\n        const connection = this.connection;\n        if (connection == null) {\n            (0, connect_1.connect)(this.monitor.connectOptions).then(connection => {\n                this.measureAndReschedule(start, connection);\n            }, () => {\n                this.connection = undefined;\n            });\n            return;\n        }\n        const commandName = connection.serverApi?.version || connection.helloOk ? 'hello' : constants_1.LEGACY_HELLO_COMMAND;\n        connection.command((0, utils_1.ns)('admin.$cmd'), { [commandName]: 1 }, undefined).then(() => this.measureAndReschedule(start), () => {\n            this.connection?.destroy();\n            this.connection = undefined;\n            return;\n        });\n    }\n}\nexports.RTTPinger = RTTPinger;\n/**\n * @internal\n */\nclass MonitorInterval {\n    constructor(fn, options = {}) {\n        this.isExpeditedCallToFnScheduled = false;\n        this.stopped = false;\n        this.isExecutionInProgress = false;\n        this.hasExecutedOnce = false;\n        this._executeAndReschedule = () => {\n            if (this.stopped)\n                return;\n            if (this.timerId) {\n                (0, timers_1.clearTimeout)(this.timerId);\n            }\n            this.isExpeditedCallToFnScheduled = false;\n            this.isExecutionInProgress = true;\n            this.fn(() => {\n                this.lastExecutionEnded = (0, utils_1.now)();\n                this.isExecutionInProgress = false;\n                this._reschedule(this.heartbeatFrequencyMS);\n            });\n        };\n        this.fn = fn;\n        this.lastExecutionEnded = -Infinity;\n        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;\n        this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;\n        if (options.immediate) {\n            this._executeAndReschedule();\n        }\n        else {\n            this._reschedule(undefined);\n        }\n    }\n    wake() {\n        const currentTime = (0, utils_1.now)();\n        const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n        // TODO(NODE-4674): Add error handling and logging to the monitor\n        if (timeSinceLastCall < 0) {\n            return this._executeAndReschedule();\n        }\n        if (this.isExecutionInProgress) {\n            return;\n        }\n        // debounce multiple calls to wake within the `minInterval`\n        if (this.isExpeditedCallToFnScheduled) {\n            return;\n        }\n        // reschedule a call as soon as possible, ensuring the call never happens\n        // faster than the `minInterval`\n        if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {\n            this.isExpeditedCallToFnScheduled = true;\n            this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);\n            return;\n        }\n        this._executeAndReschedule();\n    }\n    stop() {\n        this.stopped = true;\n        if (this.timerId) {\n            (0, timers_1.clearTimeout)(this.timerId);\n            this.timerId = undefined;\n        }\n        this.lastExecutionEnded = -Infinity;\n        this.isExpeditedCallToFnScheduled = false;\n    }\n    toString() {\n        return JSON.stringify(this);\n    }\n    toJSON() {\n        const currentTime = (0, utils_1.now)();\n        const timeSinceLastCall = currentTime - this.lastExecutionEnded;\n        return {\n            timerId: this.timerId != null ? 'set' : 'cleared',\n            lastCallTime: this.lastExecutionEnded,\n            isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,\n            stopped: this.stopped,\n            heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n            minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,\n            currentTime,\n            timeSinceLastCall\n        };\n    }\n    _reschedule(ms) {\n        if (this.stopped)\n            return;\n        if (this.timerId) {\n            (0, timers_1.clearTimeout)(this.timerId);\n        }\n        this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);\n    }\n}\nexports.MonitorInterval = MonitorInterval;\n/** @internal\n * This class implements the RTT sampling logic specified for [CSOT](https://github.com/mongodb/specifications/blob/bbb335e60cd7ea1e0f7cd9a9443cb95fc9d3b64d/source/client-side-operations-timeout/client-side-operations-timeout.md#drivers-use-minimum-rtt-to-short-circuit-operations)\n *\n * This is implemented as a [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) keeping\n * the most recent `windowSize` samples\n * */\nclass RTTSampler {\n    constructor(windowSize = 10) {\n        this.rttSamples = new Float64Array(windowSize);\n        this.length = 0;\n        this.writeIndex = 0;\n    }\n    /**\n     * Adds an rtt sample to the end of the circular buffer\n     * When `windowSize` samples have been collected, `addSample` overwrites the least recently added\n     * sample\n     */\n    addSample(sample) {\n        this.rttSamples[this.writeIndex++] = sample;\n        if (this.length < this.rttSamples.length) {\n            this.length++;\n        }\n        this.writeIndex %= this.rttSamples.length;\n    }\n    /**\n     * When \\< 2 samples have been collected, returns 0\n     * Otherwise computes the minimum value samples contained in the buffer\n     */\n    min() {\n        if (this.length < 2)\n            return 0;\n        let min = this.rttSamples[0];\n        for (let i = 1; i < this.length; i++) {\n            if (this.rttSamples[i] < min)\n                min = this.rttSamples[i];\n        }\n        return min;\n    }\n    /**\n     * Returns mean of samples contained in the buffer\n     */\n    average() {\n        if (this.length === 0)\n            return 0;\n        let sum = 0;\n        for (let i = 0; i < this.length; i++) {\n            sum += this.rttSamples[i];\n        }\n        return sum / this.length;\n    }\n    /**\n     * Returns most recently inserted element in the buffer\n     * Returns null if the buffer is empty\n     * */\n    get last() {\n        if (this.length === 0)\n            return null;\n        return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];\n    }\n    /**\n     * Clear the buffer\n     * NOTE: this does not overwrite the data held in the internal array, just the pointers into\n     * this array\n     */\n    clear() {\n        this.length = 0;\n        this.writeIndex = 0;\n    }\n}\nexports.RTTSampler = RTTSampler;\n//# sourceMappingURL=monitor.js.map"
        }
    ]
}