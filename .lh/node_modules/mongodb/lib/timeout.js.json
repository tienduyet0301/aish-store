{
    "sourceFile": "node_modules/mongodb/lib/timeout.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892631640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LegacyTimeoutContext = exports.CSOTTimeoutContext = exports.TimeoutContext = exports.Timeout = exports.TimeoutError = void 0;\nconst timers_1 = require(\"timers\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\n/** @internal */\nclass TimeoutError extends Error {\n    get name() {\n        return 'TimeoutError';\n    }\n    constructor(message, options) {\n        super(message, options);\n        this.duration = options.duration;\n    }\n    static is(error) {\n        return (error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError');\n    }\n}\nexports.TimeoutError = TimeoutError;\n/**\n * @internal\n * This class is an abstraction over timeouts\n * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve\n * if interacted with exclusively through its public API\n * */\nclass Timeout extends Promise {\n    get remainingTime() {\n        if (this.timedOut)\n            return 0;\n        if (this.duration === 0)\n            return Infinity;\n        return this.start + this.duration - Math.trunc(performance.now());\n    }\n    get timeElapsed() {\n        return Math.trunc(performance.now()) - this.start;\n    }\n    /** Create a new timeout that expires in `duration` ms */\n    constructor(executor = () => null, options) {\n        const duration = options?.duration ?? 0;\n        const unref = !!options?.unref;\n        const rejection = options?.rejection;\n        if (duration < 0) {\n            throw new error_1.MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');\n        }\n        let reject;\n        super((_, promiseReject) => {\n            reject = promiseReject;\n            executor(utils_1.noop, promiseReject);\n        });\n        this.ended = null;\n        this.timedOut = false;\n        this.cleared = false;\n        this.duration = duration;\n        this.start = Math.trunc(performance.now());\n        if (rejection == null && this.duration > 0) {\n            this.id = (0, timers_1.setTimeout)(() => {\n                this.ended = Math.trunc(performance.now());\n                this.timedOut = true;\n                reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));\n            }, this.duration);\n            if (typeof this.id.unref === 'function' && unref) {\n                // Ensure we do not keep the Node.js event loop running\n                this.id.unref();\n            }\n        }\n        else if (rejection != null) {\n            this.ended = Math.trunc(performance.now());\n            this.timedOut = true;\n            reject(rejection);\n        }\n    }\n    /**\n     * Clears the underlying timeout. This method is idempotent\n     */\n    clear() {\n        (0, timers_1.clearTimeout)(this.id);\n        this.id = undefined;\n        this.timedOut = false;\n        this.cleared = true;\n    }\n    throwIfExpired() {\n        if (this.timedOut) {\n            // This method is invoked when someone wants to throw immediately instead of await the result of this promise\n            // Since they won't be handling the rejection from the promise (because we're about to throw here)\n            // attach handling to prevent this from bubbling up to Node.js\n            this.then(undefined, utils_1.squashError);\n            throw new TimeoutError('Timed out', { duration: this.duration });\n        }\n    }\n    static expires(duration, unref) {\n        return new Timeout(undefined, { duration, unref });\n    }\n    static reject(rejection) {\n        return new Timeout(undefined, { duration: 0, unref: true, rejection });\n    }\n}\nexports.Timeout = Timeout;\nfunction isLegacyTimeoutContextOptions(v) {\n    return (v != null &&\n        typeof v === 'object' &&\n        'serverSelectionTimeoutMS' in v &&\n        typeof v.serverSelectionTimeoutMS === 'number' &&\n        'waitQueueTimeoutMS' in v &&\n        typeof v.waitQueueTimeoutMS === 'number');\n}\nfunction isCSOTTimeoutContextOptions(v) {\n    return (v != null &&\n        typeof v === 'object' &&\n        'serverSelectionTimeoutMS' in v &&\n        typeof v.serverSelectionTimeoutMS === 'number' &&\n        'timeoutMS' in v &&\n        typeof v.timeoutMS === 'number');\n}\n/** @internal */\nclass TimeoutContext {\n    static create(options) {\n        if (options.session?.timeoutContext != null)\n            return options.session?.timeoutContext;\n        if (isCSOTTimeoutContextOptions(options))\n            return new CSOTTimeoutContext(options);\n        else if (isLegacyTimeoutContextOptions(options))\n            return new LegacyTimeoutContext(options);\n        else\n            throw new error_1.MongoRuntimeError('Unrecognized options');\n    }\n}\nexports.TimeoutContext = TimeoutContext;\n/** @internal */\nclass CSOTTimeoutContext extends TimeoutContext {\n    constructor(options) {\n        super();\n        this.minRoundTripTime = 0;\n        this.start = Math.trunc(performance.now());\n        this.timeoutMS = options.timeoutMS;\n        this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n        this.socketTimeoutMS = options.socketTimeoutMS;\n        this.clearServerSelectionTimeout = false;\n    }\n    get maxTimeMS() {\n        return this.remainingTimeMS - this.minRoundTripTime;\n    }\n    get remainingTimeMS() {\n        const timePassed = Math.trunc(performance.now()) - this.start;\n        return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;\n    }\n    csotEnabled() {\n        return true;\n    }\n    get serverSelectionTimeout() {\n        // check for undefined\n        if (typeof this._serverSelectionTimeout !== 'object' || this._serverSelectionTimeout?.cleared) {\n            const { remainingTimeMS, serverSelectionTimeoutMS } = this;\n            if (remainingTimeMS <= 0)\n                return Timeout.reject(new error_1.MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`));\n            const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 &&\n                (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;\n            if (usingServerSelectionTimeoutMS) {\n                this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);\n            }\n            else {\n                if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {\n                    this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);\n                }\n                else {\n                    this._serverSelectionTimeout = null;\n                }\n            }\n        }\n        return this._serverSelectionTimeout;\n    }\n    get connectionCheckoutTimeout() {\n        if (typeof this._connectionCheckoutTimeout !== 'object' ||\n            this._connectionCheckoutTimeout?.cleared) {\n            if (typeof this._serverSelectionTimeout === 'object') {\n                // null or Timeout\n                this._connectionCheckoutTimeout = this._serverSelectionTimeout;\n            }\n            else {\n                throw new error_1.MongoRuntimeError('Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira');\n            }\n        }\n        return this._connectionCheckoutTimeout;\n    }\n    get timeoutForSocketWrite() {\n        const { remainingTimeMS } = this;\n        if (!Number.isFinite(remainingTimeMS))\n            return null;\n        if (remainingTimeMS > 0)\n            return Timeout.expires(remainingTimeMS);\n        return Timeout.reject(new error_1.MongoOperationTimeoutError('Timed out before socket write'));\n    }\n    get timeoutForSocketRead() {\n        const { remainingTimeMS } = this;\n        if (!Number.isFinite(remainingTimeMS))\n            return null;\n        if (remainingTimeMS > 0)\n            return Timeout.expires(remainingTimeMS);\n        return Timeout.reject(new error_1.MongoOperationTimeoutError('Timed out before socket read'));\n    }\n    refresh() {\n        this.start = Math.trunc(performance.now());\n        this.minRoundTripTime = 0;\n        this._serverSelectionTimeout?.clear();\n        this._connectionCheckoutTimeout?.clear();\n    }\n    clear() {\n        this._serverSelectionTimeout?.clear();\n        this._connectionCheckoutTimeout?.clear();\n    }\n    /**\n     * @internal\n     * Throws a MongoOperationTimeoutError if the context has expired.\n     * If the context has not expired, returns the `remainingTimeMS`\n     **/\n    getRemainingTimeMSOrThrow(message) {\n        const { remainingTimeMS } = this;\n        if (remainingTimeMS <= 0)\n            throw new error_1.MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);\n        return remainingTimeMS;\n    }\n    /**\n     * @internal\n     * This method is intended to be used in situations where concurrent operation are on the same deadline, but cannot share a single `TimeoutContext` instance.\n     * Returns a new instance of `CSOTTimeoutContext` constructed with identical options, but setting the `start` property to `this.start`.\n     */\n    clone() {\n        const timeoutContext = new CSOTTimeoutContext({\n            timeoutMS: this.timeoutMS,\n            serverSelectionTimeoutMS: this.serverSelectionTimeoutMS\n        });\n        timeoutContext.start = this.start;\n        return timeoutContext;\n    }\n    refreshed() {\n        return new CSOTTimeoutContext(this);\n    }\n    addMaxTimeMSToCommand(command, options) {\n        if (options.omitMaxTimeMS)\n            return;\n        const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;\n        if (maxTimeMS > 0 && Number.isFinite(maxTimeMS))\n            command.maxTimeMS = maxTimeMS;\n    }\n    getSocketTimeoutMS() {\n        return 0;\n    }\n}\nexports.CSOTTimeoutContext = CSOTTimeoutContext;\n/** @internal */\nclass LegacyTimeoutContext extends TimeoutContext {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.clearServerSelectionTimeout = true;\n    }\n    csotEnabled() {\n        return false;\n    }\n    get serverSelectionTimeout() {\n        if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)\n            return Timeout.expires(this.options.serverSelectionTimeoutMS);\n        return null;\n    }\n    get connectionCheckoutTimeout() {\n        if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)\n            return Timeout.expires(this.options.waitQueueTimeoutMS);\n        return null;\n    }\n    get timeoutForSocketWrite() {\n        return null;\n    }\n    get timeoutForSocketRead() {\n        return null;\n    }\n    refresh() {\n        return;\n    }\n    clear() {\n        return;\n    }\n    get maxTimeMS() {\n        return null;\n    }\n    refreshed() {\n        return new LegacyTimeoutContext(this.options);\n    }\n    addMaxTimeMSToCommand(_command, _options) {\n        // No max timeMS is added to commands in legacy timeout mode.\n    }\n    getSocketTimeoutMS() {\n        return this.options.socketTimeoutMS;\n    }\n}\nexports.LegacyTimeoutContext = LegacyTimeoutContext;\n//# sourceMappingURL=timeout.js.map"
        }
    ]
}