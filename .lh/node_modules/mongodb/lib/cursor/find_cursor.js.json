{
    "sourceFile": "node_modules/mongodb/lib/cursor/find_cursor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892619456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FindCursor = exports.FLAGS = void 0;\nconst responses_1 = require(\"../cmap/wire_protocol/responses\");\nconst error_1 = require(\"../error\");\nconst explain_1 = require(\"../explain\");\nconst count_1 = require(\"../operations/count\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst find_1 = require(\"../operations/find\");\nconst sort_1 = require(\"../sort\");\nconst utils_1 = require(\"../utils\");\n/** @public Flags allowed for cursor */\nexports.FLAGS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'exhaust',\n    'partial'\n];\n/** @public */\nclass FindCursor extends explain_1.ExplainableCursor {\n    /** @internal */\n    constructor(client, namespace, filter = {}, options = {}) {\n        super(client, namespace, options);\n        /** @internal */\n        this.numReturned = 0;\n        this.cursorFilter = filter;\n        this.findOptions = options;\n        if (options.sort != null) {\n            this.findOptions.sort = (0, sort_1.formatSort)(options.sort);\n        }\n    }\n    clone() {\n        const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);\n        delete clonedOptions.session;\n        return new FindCursor(this.client, this.namespace, this.cursorFilter, {\n            ...clonedOptions\n        });\n    }\n    map(transform) {\n        return super.map(transform);\n    }\n    /** @internal */\n    async _initialize(session) {\n        const options = {\n            ...this.findOptions, // NOTE: order matters here, we may need to refine this\n            ...this.cursorOptions,\n            session,\n            signal: this.signal\n        };\n        if (options.explain) {\n            try {\n                (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));\n            }\n            catch {\n                throw new error_1.MongoAPIError('timeoutMS cannot be used with explain when explain is specified in findOptions');\n            }\n        }\n        const findOperation = new find_1.FindOperation(this.namespace, this.cursorFilter, options);\n        const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation, this.timeoutContext);\n        // the response is not a cursor when `explain` is enabled\n        this.numReturned = response.batchSize;\n        return { server: findOperation.server, session, response };\n    }\n    /** @internal */\n    async getMore(batchSize) {\n        const numReturned = this.numReturned;\n        if (numReturned) {\n            // TODO(DRIVERS-1448): Remove logic to enforce `limit` in the driver\n            const limit = this.findOptions.limit;\n            batchSize =\n                limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;\n            if (batchSize <= 0) {\n                try {\n                    await this.close();\n                }\n                catch (error) {\n                    (0, utils_1.squashError)(error);\n                    // this is an optimization for the special case of a limit for a find command to avoid an\n                    // extra getMore when the limit has been reached and the limit is a multiple of the batchSize.\n                    // This is a consequence of the new query engine in 5.0 having no knowledge of the limit as it\n                    // produces results for the find command.  Once a batch is filled up, it is returned and only\n                    // on the subsequent getMore will the query framework consider the limit, determine the cursor\n                    // is exhausted and return a cursorId of zero.\n                    // instead, if we determine there are no more documents to request from the server, we preemptively\n                    // close the cursor\n                }\n                return responses_1.CursorResponse.emptyGetMore;\n            }\n        }\n        const response = await super.getMore(batchSize);\n        // TODO: wrap this in some logic to prevent it from happening if we don't need this support\n        this.numReturned = this.numReturned + response.batchSize;\n        return response;\n    }\n    /**\n     * Get the count of documents for this cursor\n     * @deprecated Use `collection.estimatedDocumentCount` or `collection.countDocuments` instead\n     */\n    async count(options) {\n        (0, utils_1.emitWarningOnce)('cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ');\n        if (typeof options === 'boolean') {\n            throw new error_1.MongoInvalidArgumentError('Invalid first parameter to count');\n        }\n        return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {\n            ...this.findOptions, // NOTE: order matters here, we may need to refine this\n            ...this.cursorOptions,\n            ...options\n        }));\n    }\n    async explain(verbosity, options) {\n        const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);\n        return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {\n            ...this.findOptions, // NOTE: order matters here, we may need to refine this\n            ...this.cursorOptions,\n            ...timeout,\n            explain: explain ?? true\n        }))).shift(this.deserializationOptions);\n    }\n    /** Set the cursor query */\n    filter(filter) {\n        this.throwIfInitialized();\n        this.cursorFilter = filter;\n        return this;\n    }\n    /**\n     * Set the cursor hint\n     *\n     * @param hint - If specified, then the query system will only consider plans using the hinted index.\n     */\n    hint(hint) {\n        this.throwIfInitialized();\n        this.findOptions.hint = hint;\n        return this;\n    }\n    /**\n     * Set the cursor min\n     *\n     * @param min - Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.\n     */\n    min(min) {\n        this.throwIfInitialized();\n        this.findOptions.min = min;\n        return this;\n    }\n    /**\n     * Set the cursor max\n     *\n     * @param max - Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.\n     */\n    max(max) {\n        this.throwIfInitialized();\n        this.findOptions.max = max;\n        return this;\n    }\n    /**\n     * Set the cursor returnKey.\n     * If set to true, modifies the cursor to only return the index field or fields for the results of the query, rather than documents.\n     * If set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields.\n     *\n     * @param value - the returnKey value.\n     */\n    returnKey(value) {\n        this.throwIfInitialized();\n        this.findOptions.returnKey = value;\n        return this;\n    }\n    /**\n     * Modifies the output of a query by adding a field $recordId to matching documents. $recordId is the internal key which uniquely identifies a document in a collection.\n     *\n     * @param value - The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.\n     */\n    showRecordId(value) {\n        this.throwIfInitialized();\n        this.findOptions.showRecordId = value;\n        return this;\n    }\n    /**\n     * Add a query modifier to the cursor query\n     *\n     * @param name - The query modifier (must start with $, such as $orderby etc)\n     * @param value - The modifier value.\n     */\n    addQueryModifier(name, value) {\n        this.throwIfInitialized();\n        if (name[0] !== '$') {\n            throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);\n        }\n        // Strip of the $\n        const field = name.substr(1);\n        // NOTE: consider some TS magic for this\n        switch (field) {\n            case 'comment':\n                this.findOptions.comment = value;\n                break;\n            case 'explain':\n                this.findOptions.explain = value;\n                break;\n            case 'hint':\n                this.findOptions.hint = value;\n                break;\n            case 'max':\n                this.findOptions.max = value;\n                break;\n            case 'maxTimeMS':\n                this.findOptions.maxTimeMS = value;\n                break;\n            case 'min':\n                this.findOptions.min = value;\n                break;\n            case 'orderby':\n                this.findOptions.sort = (0, sort_1.formatSort)(value);\n                break;\n            case 'query':\n                this.cursorFilter = value;\n                break;\n            case 'returnKey':\n                this.findOptions.returnKey = value;\n                break;\n            case 'showDiskLoc':\n                this.findOptions.showRecordId = value;\n                break;\n            default:\n                throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);\n        }\n        return this;\n    }\n    /**\n     * Add a comment to the cursor query allowing for tracking the comment in the log.\n     *\n     * @param value - The comment attached to this query.\n     */\n    comment(value) {\n        this.throwIfInitialized();\n        this.findOptions.comment = value;\n        return this;\n    }\n    /**\n     * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)\n     *\n     * @param value - Number of milliseconds to wait before aborting the tailed query.\n     */\n    maxAwaitTimeMS(value) {\n        this.throwIfInitialized();\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Argument for maxAwaitTimeMS must be a number');\n        }\n        this.findOptions.maxAwaitTimeMS = value;\n        return this;\n    }\n    /**\n     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n     *\n     * @param value - Number of milliseconds to wait before aborting the query.\n     */\n    maxTimeMS(value) {\n        this.throwIfInitialized();\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n        }\n        this.findOptions.maxTimeMS = value;\n        return this;\n    }\n    /**\n     * Add a project stage to the aggregation pipeline\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * By default chaining a projection to your cursor changes the returned type to the generic\n     * {@link Document} type.\n     * You should specify a parameterized type to have assertions on your final results.\n     *\n     * @example\n     * ```typescript\n     * // Best way\n     * const docs: FindCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * // Flexible way\n     * const docs: FindCursor<Document> = cursor.project({ _id: 0, a: true });\n     * ```\n     *\n     * @remarks\n     *\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling project,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: FindCursor<{ a: number; b: string }> = coll.find();\n     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n     *\n     * // or always use chaining and save the final cursor\n     *\n     * const cursor = coll.find().project<{ a: string }>({\n     *   _id: 0,\n     *   a: { $convert: { input: '$a', to: 'string' }\n     * }});\n     * ```\n     */\n    project(value) {\n        this.throwIfInitialized();\n        this.findOptions.projection = value;\n        return this;\n    }\n    /**\n     * Sets the sort order of the cursor query.\n     *\n     * @param sort - The key or keys set for the sort.\n     * @param direction - The direction of the sorting (1 or -1).\n     */\n    sort(sort, direction) {\n        this.throwIfInitialized();\n        if (this.findOptions.tailable) {\n            throw new error_1.MongoTailableCursorError('Tailable cursor does not support sorting');\n        }\n        this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);\n        return this;\n    }\n    /**\n     * Allows disk use for blocking sort operations exceeding 100MB memory. (MongoDB 3.2 or higher)\n     *\n     * @remarks\n     * {@link https://www.mongodb.com/docs/manual/reference/command/find/#find-cmd-allowdiskuse | find command allowDiskUse documentation}\n     */\n    allowDiskUse(allow = true) {\n        this.throwIfInitialized();\n        if (!this.findOptions.sort) {\n            throw new error_1.MongoInvalidArgumentError('Option \"allowDiskUse\" requires a sort specification');\n        }\n        // As of 6.0 the default is true. This allows users to get back to the old behavior.\n        if (!allow) {\n            this.findOptions.allowDiskUse = false;\n            return this;\n        }\n        this.findOptions.allowDiskUse = true;\n        return this;\n    }\n    /**\n     * Set the collation options for the cursor.\n     *\n     * @param value - The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n     */\n    collation(value) {\n        this.throwIfInitialized();\n        this.findOptions.collation = value;\n        return this;\n    }\n    /**\n     * Set the limit for the cursor.\n     *\n     * @param value - The limit for the cursor query.\n     */\n    limit(value) {\n        this.throwIfInitialized();\n        if (this.findOptions.tailable) {\n            throw new error_1.MongoTailableCursorError('Tailable cursor does not support limit');\n        }\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Operation \"limit\" requires an integer');\n        }\n        this.findOptions.limit = value;\n        return this;\n    }\n    /**\n     * Set the skip for the cursor.\n     *\n     * @param value - The skip for the cursor query.\n     */\n    skip(value) {\n        this.throwIfInitialized();\n        if (this.findOptions.tailable) {\n            throw new error_1.MongoTailableCursorError('Tailable cursor does not support skip');\n        }\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Operation \"skip\" requires an integer');\n        }\n        this.findOptions.skip = value;\n        return this;\n    }\n}\nexports.FindCursor = FindCursor;\n//# sourceMappingURL=find_cursor.js.map"
        }
    ]
}