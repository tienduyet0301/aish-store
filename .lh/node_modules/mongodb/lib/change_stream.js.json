{
    "sourceFile": "node_modules/mongodb/lib/change_stream.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892613814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ChangeStream = void 0;\nconst collection_1 = require(\"./collection\");\nconst constants_1 = require(\"./constants\");\nconst abstract_cursor_1 = require(\"./cursor/abstract_cursor\");\nconst change_stream_cursor_1 = require(\"./cursor/change_stream_cursor\");\nconst db_1 = require(\"./db\");\nconst error_1 = require(\"./error\");\nconst mongo_client_1 = require(\"./mongo_client\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst resource_management_1 = require(\"./resource_management\");\nconst timeout_1 = require(\"./timeout\");\nconst utils_1 = require(\"./utils\");\nconst CHANGE_STREAM_OPTIONS = [\n    'resumeAfter',\n    'startAfter',\n    'startAtOperationTime',\n    'fullDocument',\n    'fullDocumentBeforeChange',\n    'showExpandedEvents'\n];\nconst CHANGE_DOMAIN_TYPES = {\n    COLLECTION: Symbol('Collection'),\n    DATABASE: Symbol('Database'),\n    CLUSTER: Symbol('Cluster')\n};\nconst CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];\nconst NO_RESUME_TOKEN_ERROR = 'A change stream document has been received that lacks a resume token (_id).';\nconst CHANGESTREAM_CLOSED_ERROR = 'ChangeStream is closed';\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @public\n */\nclass ChangeStream extends mongo_types_1.TypedEventEmitter {\n    /** @internal */\n    async asyncDispose() {\n        await this.close();\n    }\n    /**\n     * @internal\n     *\n     * @param parent - The parent object that created this change stream\n     * @param pipeline - An array of {@link https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n     */\n    constructor(parent, pipeline = [], options = {}) {\n        super();\n        this.pipeline = pipeline;\n        this.options = { ...options };\n        let serverSelectionTimeoutMS;\n        delete this.options.writeConcern;\n        if (parent instanceof collection_1.Collection) {\n            this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n            serverSelectionTimeoutMS = parent.s.db.client.options.serverSelectionTimeoutMS;\n        }\n        else if (parent instanceof db_1.Db) {\n            this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n            serverSelectionTimeoutMS = parent.client.options.serverSelectionTimeoutMS;\n        }\n        else if (parent instanceof mongo_client_1.MongoClient) {\n            this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n            serverSelectionTimeoutMS = parent.options.serverSelectionTimeoutMS;\n        }\n        else {\n            throw new error_1.MongoChangeStreamError('Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient');\n        }\n        this.contextOwner = Symbol();\n        this.parent = parent;\n        this.namespace = parent.s.namespace;\n        if (!this.options.readPreference && parent.readPreference) {\n            this.options.readPreference = parent.readPreference;\n        }\n        // Create contained Change Stream cursor\n        this.cursor = this._createChangeStreamCursor(options);\n        this.isClosed = false;\n        this.mode = false;\n        // Listen for any `change` listeners being added to ChangeStream\n        this.on('newListener', eventName => {\n            if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n                this._streamEvents(this.cursor);\n            }\n        });\n        this.on('removeListener', eventName => {\n            if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n                this.cursorStream?.removeAllListeners('data');\n            }\n        });\n        if (this.options.timeoutMS != null) {\n            this.timeoutContext = new timeout_1.CSOTTimeoutContext({\n                timeoutMS: this.options.timeoutMS,\n                serverSelectionTimeoutMS\n            });\n        }\n    }\n    /** The cached resume token that is used to resume after the most recently returned change. */\n    get resumeToken() {\n        return this.cursor?.resumeToken;\n    }\n    /** Check if there is any document still available in the Change Stream */\n    async hasNext() {\n        this._setIsIterator();\n        // Change streams must resume indefinitely while each resume event succeeds.\n        // This loop continues until either a change event is received or until a resume attempt\n        // fails.\n        this.timeoutContext?.refresh();\n        try {\n            while (true) {\n                try {\n                    const hasNext = await this.cursor.hasNext();\n                    return hasNext;\n                }\n                catch (error) {\n                    try {\n                        await this._processErrorIteratorMode(error, this.cursor.id != null);\n                    }\n                    catch (error) {\n                        if (error instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {\n                            throw error;\n                        }\n                        try {\n                            await this.close();\n                        }\n                        catch (error) {\n                            (0, utils_1.squashError)(error);\n                        }\n                        throw error;\n                    }\n                }\n            }\n        }\n        finally {\n            this.timeoutContext?.clear();\n        }\n    }\n    /** Get the next available document from the Change Stream. */\n    async next() {\n        this._setIsIterator();\n        // Change streams must resume indefinitely while each resume event succeeds.\n        // This loop continues until either a change event is received or until a resume attempt\n        // fails.\n        this.timeoutContext?.refresh();\n        try {\n            while (true) {\n                try {\n                    const change = await this.cursor.next();\n                    const processedChange = this._processChange(change ?? null);\n                    return processedChange;\n                }\n                catch (error) {\n                    try {\n                        await this._processErrorIteratorMode(error, this.cursor.id != null);\n                    }\n                    catch (error) {\n                        if (error instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {\n                            throw error;\n                        }\n                        try {\n                            await this.close();\n                        }\n                        catch (error) {\n                            (0, utils_1.squashError)(error);\n                        }\n                        throw error;\n                    }\n                }\n            }\n        }\n        finally {\n            this.timeoutContext?.clear();\n        }\n    }\n    /**\n     * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned\n     */\n    async tryNext() {\n        this._setIsIterator();\n        // Change streams must resume indefinitely while each resume event succeeds.\n        // This loop continues until either a change event is received or until a resume attempt\n        // fails.\n        this.timeoutContext?.refresh();\n        try {\n            while (true) {\n                try {\n                    const change = await this.cursor.tryNext();\n                    return change ?? null;\n                }\n                catch (error) {\n                    try {\n                        await this._processErrorIteratorMode(error, this.cursor.id != null);\n                    }\n                    catch (error) {\n                        if (error instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null)\n                            throw error;\n                        try {\n                            await this.close();\n                        }\n                        catch (error) {\n                            (0, utils_1.squashError)(error);\n                        }\n                        throw error;\n                    }\n                }\n            }\n        }\n        finally {\n            this.timeoutContext?.clear();\n        }\n    }\n    async *[Symbol.asyncIterator]() {\n        if (this.closed) {\n            return;\n        }\n        try {\n            // Change streams run indefinitely as long as errors are resumable\n            // So the only loop breaking condition is if `next()` throws\n            while (true) {\n                yield await this.next();\n            }\n        }\n        finally {\n            try {\n                await this.close();\n            }\n            catch (error) {\n                (0, utils_1.squashError)(error);\n            }\n        }\n    }\n    /** Is the cursor closed */\n    get closed() {\n        return this.isClosed || this.cursor.closed;\n    }\n    /**\n     * Frees the internal resources used by the change stream.\n     */\n    async close() {\n        this.timeoutContext?.clear();\n        this.timeoutContext = undefined;\n        this.isClosed = true;\n        const cursor = this.cursor;\n        try {\n            await cursor.close();\n        }\n        finally {\n            this._endStream();\n        }\n    }\n    /**\n     * Return a modified Readable stream including a possible transform method.\n     *\n     * NOTE: When using a Stream to process change stream events, the stream will\n     * NOT automatically resume in the case a resumable error is encountered.\n     *\n     * @throws MongoChangeStreamError if the underlying cursor or the change stream is closed\n     */\n    stream(options) {\n        if (this.closed) {\n            throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);\n        }\n        this.streamOptions = options;\n        return this.cursor.stream(options);\n    }\n    /** @internal */\n    _setIsEmitter() {\n        if (this.mode === 'iterator') {\n            // TODO(NODE-3485): Replace with MongoChangeStreamModeError\n            throw new error_1.MongoAPIError('ChangeStream cannot be used as an EventEmitter after being used as an iterator');\n        }\n        this.mode = 'emitter';\n    }\n    /** @internal */\n    _setIsIterator() {\n        if (this.mode === 'emitter') {\n            // TODO(NODE-3485): Replace with MongoChangeStreamModeError\n            throw new error_1.MongoAPIError('ChangeStream cannot be used as an iterator after being used as an EventEmitter');\n        }\n        this.mode = 'iterator';\n    }\n    /**\n     * Create a new change stream cursor based on self's configuration\n     * @internal\n     */\n    _createChangeStreamCursor(options) {\n        const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);\n        if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n            changeStreamStageOptions.allChangesForCluster = true;\n        }\n        const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];\n        const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER\n            ? this.parent\n            : this.type === CHANGE_DOMAIN_TYPES.DATABASE\n                ? this.parent.client\n                : this.type === CHANGE_DOMAIN_TYPES.COLLECTION\n                    ? this.parent.client\n                    : null;\n        if (client == null) {\n            // This should never happen because of the assertion in the constructor\n            throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);\n        }\n        const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, {\n            ...options,\n            timeoutContext: this.timeoutContext\n                ? new abstract_cursor_1.CursorTimeoutContext(this.timeoutContext, this.contextOwner)\n                : undefined\n        });\n        for (const event of CHANGE_STREAM_EVENTS) {\n            changeStreamCursor.on(event, e => this.emit(event, e));\n        }\n        if (this.listenerCount(ChangeStream.CHANGE) > 0) {\n            this._streamEvents(changeStreamCursor);\n        }\n        return changeStreamCursor;\n    }\n    /** @internal */\n    _closeEmitterModeWithError(error) {\n        this.emit(ChangeStream.ERROR, error);\n        this.close().then(undefined, utils_1.squashError);\n    }\n    /** @internal */\n    _streamEvents(cursor) {\n        this._setIsEmitter();\n        const stream = this.cursorStream ?? cursor.stream();\n        this.cursorStream = stream;\n        stream.on('data', change => {\n            try {\n                const processedChange = this._processChange(change);\n                this.emit(ChangeStream.CHANGE, processedChange);\n            }\n            catch (error) {\n                this.emit(ChangeStream.ERROR, error);\n            }\n            this.timeoutContext?.refresh();\n        });\n        stream.on('error', error => this._processErrorStreamMode(error, this.cursor.id != null));\n    }\n    /** @internal */\n    _endStream() {\n        this.cursorStream?.removeAllListeners('data');\n        this.cursorStream?.removeAllListeners('close');\n        this.cursorStream?.removeAllListeners('end');\n        this.cursorStream?.destroy();\n        this.cursorStream = undefined;\n    }\n    /** @internal */\n    _processChange(change) {\n        if (this.isClosed) {\n            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n            throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);\n        }\n        // a null change means the cursor has been notified, implicitly closing the change stream\n        if (change == null) {\n            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n            throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);\n        }\n        if (change && !change._id) {\n            throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);\n        }\n        // cache the resume token\n        this.cursor.cacheResumeToken(change._id);\n        // wipe the startAtOperationTime if there was one so that there won't be a conflict\n        // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n        this.options.startAtOperationTime = undefined;\n        return change;\n    }\n    /** @internal */\n    _processErrorStreamMode(changeStreamError, cursorInitialized) {\n        // If the change stream has been closed explicitly, do not process error.\n        if (this.isClosed)\n            return;\n        if (cursorInitialized &&\n            ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) ||\n                changeStreamError instanceof error_1.MongoOperationTimeoutError)) {\n            this._endStream();\n            this.cursor\n                .close()\n                .then(() => this._resume(changeStreamError), e => {\n                (0, utils_1.squashError)(e);\n                return this._resume(changeStreamError);\n            })\n                .then(() => {\n                if (changeStreamError instanceof error_1.MongoOperationTimeoutError)\n                    this.emit(ChangeStream.ERROR, changeStreamError);\n            }, () => this._closeEmitterModeWithError(changeStreamError));\n        }\n        else {\n            this._closeEmitterModeWithError(changeStreamError);\n        }\n    }\n    /** @internal */\n    async _processErrorIteratorMode(changeStreamError, cursorInitialized) {\n        if (this.isClosed) {\n            // TODO(NODE-3485): Replace with MongoChangeStreamClosedError\n            throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);\n        }\n        if (cursorInitialized &&\n            ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) ||\n                changeStreamError instanceof error_1.MongoOperationTimeoutError)) {\n            try {\n                await this.cursor.close();\n            }\n            catch (error) {\n                (0, utils_1.squashError)(error);\n            }\n            await this._resume(changeStreamError);\n            if (changeStreamError instanceof error_1.MongoOperationTimeoutError)\n                throw changeStreamError;\n        }\n        else {\n            try {\n                await this.close();\n            }\n            catch (error) {\n                (0, utils_1.squashError)(error);\n            }\n            throw changeStreamError;\n        }\n    }\n    async _resume(changeStreamError) {\n        this.timeoutContext?.refresh();\n        const topology = (0, utils_1.getTopology)(this.parent);\n        try {\n            await topology.selectServer(this.cursor.readPreference, {\n                operationName: 'reconnect topology in change stream',\n                timeoutContext: this.timeoutContext\n            });\n            this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);\n        }\n        catch {\n            // if the topology can't reconnect, close the stream\n            await this.close();\n            throw changeStreamError;\n        }\n    }\n}\nexports.ChangeStream = ChangeStream;\n/** @event */\nChangeStream.RESPONSE = constants_1.RESPONSE;\n/** @event */\nChangeStream.MORE = constants_1.MORE;\n/** @event */\nChangeStream.INIT = constants_1.INIT;\n/** @event */\nChangeStream.CLOSE = constants_1.CLOSE;\n/**\n * Fired for each new matching change in the specified namespace. Attaching a `change`\n * event listener to a Change Stream will switch the stream into flowing mode. Data will\n * then be passed as soon as it is available.\n * @event\n */\nChangeStream.CHANGE = constants_1.CHANGE;\n/** @event */\nChangeStream.END = constants_1.END;\n/** @event */\nChangeStream.ERROR = constants_1.ERROR;\n/**\n * Emitted each time the change stream stores a new resume token.\n * @event\n */\nChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;\n(0, resource_management_1.configureResourceManagement)(ChangeStream.prototype);\n//# sourceMappingURL=change_stream.js.map"
        }
    ]
}