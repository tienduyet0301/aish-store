{
    "sourceFile": "node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892622700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = void 0;\nexports.buildOperation = buildOperation;\nconst bson_1 = require(\"../../bson\");\nconst commands_1 = require(\"../../cmap/commands\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\n/**\n * The bytes overhead for the extra fields added post command generation.\n */\nconst MESSAGE_OVERHEAD_BYTES = 1000;\n/** @internal */\nclass ClientBulkWriteCommandBuilder {\n    /**\n     * Create the command builder.\n     * @param models - The client write models.\n     */\n    constructor(models, options, pkFactory) {\n        this.models = models;\n        this.options = options;\n        this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;\n        this.currentModelIndex = 0;\n        this.previousModelIndex = 0;\n        this.lastOperations = [];\n        this.isBatchRetryable = true;\n    }\n    /**\n     * Gets the errorsOnly value for the command, which is the inverse of the\n     * user provided verboseResults option. Defaults to true.\n     */\n    get errorsOnly() {\n        if ('verboseResults' in this.options) {\n            return !this.options.verboseResults;\n        }\n        return true;\n    }\n    /**\n     * Determines if there is another batch to process.\n     * @returns True if not all batches have been built.\n     */\n    hasNextBatch() {\n        return this.currentModelIndex < this.models.length;\n    }\n    /**\n     * When we need to retry a command we need to set the current\n     * model index back to its previous value.\n     */\n    resetBatch() {\n        this.currentModelIndex = this.previousModelIndex;\n        return true;\n    }\n    /**\n     * Build a single batch of a client bulk write command.\n     * @param maxMessageSizeBytes - The max message size in bytes.\n     * @param maxWriteBatchSize - The max write batch size.\n     * @returns The client bulk write command.\n     */\n    buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {\n        // We start by assuming the batch has no multi-updates, so it is retryable\n        // until we find them.\n        this.isBatchRetryable = true;\n        let commandLength = 0;\n        let currentNamespaceIndex = 0;\n        const command = this.baseCommand();\n        const namespaces = new Map();\n        // In the case of retries we need to mark where we started this batch.\n        this.previousModelIndex = this.currentModelIndex;\n        while (this.currentModelIndex < this.models.length) {\n            const model = this.models[this.currentModelIndex];\n            const ns = model.namespace;\n            const nsIndex = namespaces.get(ns);\n            // Multi updates are not retryable.\n            if (model.name === 'deleteMany' || model.name === 'updateMany') {\n                this.isBatchRetryable = false;\n            }\n            if (nsIndex != null) {\n                // Build the operation and serialize it to get the bytes buffer.\n                const operation = buildOperation(model, nsIndex, this.pkFactory);\n                let operationBuffer;\n                try {\n                    operationBuffer = bson_1.BSON.serialize(operation);\n                }\n                catch (cause) {\n                    throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });\n                }\n                validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n                // Check if the operation buffer can fit in the command. If it can,\n                // then add the operation to the document sequence and increment the\n                // current length as long as the ops don't exceed the maxWriteBatchSize.\n                if (commandLength + operationBuffer.length < maxMessageSizeBytes &&\n                    command.ops.documents.length < maxWriteBatchSize) {\n                    // Pushing to the ops document sequence returns the total byte length of the document sequence.\n                    commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);\n                    // Increment the builder's current model index.\n                    this.currentModelIndex++;\n                }\n                else {\n                    // The operation cannot fit in the current command and will need to\n                    // go in the next batch. Exit the loop.\n                    break;\n                }\n            }\n            else {\n                // The namespace is not already in the nsInfo so we will set it in the map, and\n                // construct our nsInfo and ops documents and buffers.\n                namespaces.set(ns, currentNamespaceIndex);\n                const nsInfo = { ns: ns };\n                const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory);\n                let nsInfoBuffer;\n                let operationBuffer;\n                try {\n                    nsInfoBuffer = bson_1.BSON.serialize(nsInfo);\n                    operationBuffer = bson_1.BSON.serialize(operation);\n                }\n                catch (cause) {\n                    throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });\n                }\n                validateBufferSize('nsInfo', nsInfoBuffer, maxBsonObjectSize);\n                validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n                // Check if the operation and nsInfo buffers can fit in the command. If they\n                // can, then add the operation and nsInfo to their respective document\n                // sequences and increment the current length as long as the ops don't exceed\n                // the maxWriteBatchSize.\n                if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes &&\n                    command.ops.documents.length < maxWriteBatchSize) {\n                    // Pushing to the ops document sequence returns the total byte length of the document sequence.\n                    commandLength =\n                        MESSAGE_OVERHEAD_BYTES +\n                            command.nsInfo.push(nsInfo, nsInfoBuffer) +\n                            command.ops.push(operation, operationBuffer);\n                    // We've added a new namespace, increment the namespace index.\n                    currentNamespaceIndex++;\n                    // Increment the builder's current model index.\n                    this.currentModelIndex++;\n                }\n                else {\n                    // The operation cannot fit in the current command and will need to\n                    // go in the next batch. Exit the loop.\n                    break;\n                }\n            }\n        }\n        // Set the last operations and return the command.\n        this.lastOperations = command.ops.documents;\n        return command;\n    }\n    baseCommand() {\n        const command = {\n            bulkWrite: 1,\n            errorsOnly: this.errorsOnly,\n            ordered: this.options.ordered ?? true,\n            ops: new commands_1.DocumentSequence('ops'),\n            nsInfo: new commands_1.DocumentSequence('nsInfo')\n        };\n        // Add bypassDocumentValidation if it was present in the options.\n        if (this.options.bypassDocumentValidation != null) {\n            command.bypassDocumentValidation = this.options.bypassDocumentValidation;\n        }\n        // Add let if it was present in the options.\n        if (this.options.let) {\n            command.let = this.options.let;\n        }\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (this.options.comment !== undefined) {\n            command.comment = this.options.comment;\n        }\n        return command;\n    }\n}\nexports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;\nfunction validateBufferSize(name, buffer, maxBsonObjectSize) {\n    if (buffer.length > maxBsonObjectSize) {\n        throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);\n    }\n}\n/**\n * Build the insert one operation.\n * @param model - The insert one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildInsertOneOperation = (model, index, pkFactory) => {\n    const document = {\n        insert: index,\n        document: model.document\n    };\n    document.document._id = model.document._id ?? pkFactory.createPk();\n    return document;\n};\nexports.buildInsertOneOperation = buildInsertOneOperation;\n/**\n * Build the delete one operation.\n * @param model - The insert many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildDeleteOneOperation = (model, index) => {\n    return createDeleteOperation(model, index, false);\n};\nexports.buildDeleteOneOperation = buildDeleteOneOperation;\n/**\n * Build the delete many operation.\n * @param model - The delete many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildDeleteManyOperation = (model, index) => {\n    return createDeleteOperation(model, index, true);\n};\nexports.buildDeleteManyOperation = buildDeleteManyOperation;\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createDeleteOperation(model, index, multi) {\n    const document = {\n        delete: index,\n        multi: multi,\n        filter: model.filter\n    };\n    if (model.hint) {\n        document.hint = model.hint;\n    }\n    if (model.collation) {\n        document.collation = model.collation;\n    }\n    return document;\n}\n/**\n * Build the update one operation.\n * @param model - The update one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildUpdateOneOperation = (model, index) => {\n    return createUpdateOperation(model, index, false);\n};\nexports.buildUpdateOneOperation = buildUpdateOneOperation;\n/**\n * Build the update many operation.\n * @param model - The update many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildUpdateManyOperation = (model, index) => {\n    return createUpdateOperation(model, index, true);\n};\nexports.buildUpdateManyOperation = buildUpdateManyOperation;\n/**\n * Validate the update document.\n * @param update - The update document.\n */\nfunction validateUpdate(update) {\n    if (!(0, utils_1.hasAtomicOperators)(update)) {\n        throw new error_1.MongoAPIError('Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.');\n    }\n}\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createUpdateOperation(model, index, multi) {\n    // Update documents provided in UpdateOne and UpdateMany write models are\n    // required only to contain atomic modifiers (i.e. keys that start with \"$\").\n    // Drivers MUST throw an error if an update document is empty or if the\n    // document's first key does not start with \"$\".\n    validateUpdate(model.update);\n    const document = {\n        update: index,\n        multi: multi,\n        filter: model.filter,\n        updateMods: model.update\n    };\n    if (model.hint) {\n        document.hint = model.hint;\n    }\n    if (model.upsert) {\n        document.upsert = model.upsert;\n    }\n    if (model.arrayFilters) {\n        document.arrayFilters = model.arrayFilters;\n    }\n    if (model.collation) {\n        document.collation = model.collation;\n    }\n    return document;\n}\n/**\n * Build the replace one operation.\n * @param model - The replace one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildReplaceOneOperation = (model, index) => {\n    if ((0, utils_1.hasAtomicOperators)(model.replacement)) {\n        throw new error_1.MongoAPIError('Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.');\n    }\n    const document = {\n        update: index,\n        multi: false,\n        filter: model.filter,\n        updateMods: model.replacement\n    };\n    if (model.hint) {\n        document.hint = model.hint;\n    }\n    if (model.upsert) {\n        document.upsert = model.upsert;\n    }\n    if (model.collation) {\n        document.collation = model.collation;\n    }\n    return document;\n};\nexports.buildReplaceOneOperation = buildReplaceOneOperation;\n/** @internal */\nfunction buildOperation(model, index, pkFactory) {\n    switch (model.name) {\n        case 'insertOne':\n            return (0, exports.buildInsertOneOperation)(model, index, pkFactory);\n        case 'deleteOne':\n            return (0, exports.buildDeleteOneOperation)(model, index);\n        case 'deleteMany':\n            return (0, exports.buildDeleteManyOperation)(model, index);\n        case 'updateOne':\n            return (0, exports.buildUpdateOneOperation)(model, index);\n        case 'updateMany':\n            return (0, exports.buildUpdateManyOperation)(model, index);\n        case 'replaceOne':\n            return (0, exports.buildReplaceOneOperation)(model, index);\n    }\n}\n//# sourceMappingURL=command_builder.js.map"
        }
    ]
}