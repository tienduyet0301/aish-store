{
    "sourceFile": "node_modules/mongodb/lib/operations/find_and_modify.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892624744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.FindAndModifyOperation = exports.ReturnDocument = void 0;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst sort_1 = require(\"../sort\");\nconst utils_1 = require(\"../utils\");\nconst command_1 = require(\"./command\");\nconst operation_1 = require(\"./operation\");\n/** @public */\nexports.ReturnDocument = Object.freeze({\n    BEFORE: 'before',\n    AFTER: 'after'\n});\nfunction configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {\n    cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;\n    cmdBase.upsert = options.upsert === true;\n    if (options.bypassDocumentValidation === true) {\n        cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n    return cmdBase;\n}\n/** @internal */\nclass FindAndModifyOperation extends command_1.CommandOperation {\n    constructor(collection, query, options) {\n        super(collection, options);\n        this.options = options ?? {};\n        this.cmdBase = {\n            remove: false,\n            new: false,\n            upsert: false\n        };\n        options.includeResultMetadata ??= false;\n        const sort = (0, sort_1.formatSort)(options.sort);\n        if (sort) {\n            this.cmdBase.sort = sort;\n        }\n        if (options.projection) {\n            this.cmdBase.fields = options.projection;\n        }\n        if (options.maxTimeMS) {\n            this.cmdBase.maxTimeMS = options.maxTimeMS;\n        }\n        // Decorate the findAndModify command with the write Concern\n        if (options.writeConcern) {\n            this.cmdBase.writeConcern = options.writeConcern;\n        }\n        if (options.let) {\n            this.cmdBase.let = options.let;\n        }\n        // we check for undefined specifically here to allow falsy values\n        // eslint-disable-next-line no-restricted-syntax\n        if (options.comment !== undefined) {\n            this.cmdBase.comment = options.comment;\n        }\n        // force primary read preference\n        this.readPreference = read_preference_1.ReadPreference.primary;\n        this.collection = collection;\n        this.query = query;\n    }\n    get commandName() {\n        return 'findAndModify';\n    }\n    async execute(server, session, timeoutContext) {\n        const coll = this.collection;\n        const query = this.query;\n        const options = { ...this.options, ...this.bsonOptions };\n        // Create findAndModify command object\n        const cmd = {\n            findAndModify: coll.collectionName,\n            query: query,\n            ...this.cmdBase\n        };\n        (0, utils_1.decorateWithCollation)(cmd, coll, options);\n        if (options.hint) {\n            // TODO: once this method becomes a CommandOperation we will have the server\n            // in place to check.\n            const unacknowledgedWrite = this.writeConcern?.w === 0;\n            if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {\n                throw new error_1.MongoCompatibilityError('The current topology does not support a hint on findAndModify commands');\n            }\n            cmd.hint = options.hint;\n        }\n        // Execute the command\n        const result = await super.executeCommand(server, session, cmd, timeoutContext);\n        return options.includeResultMetadata ? result : (result.value ?? null);\n    }\n}\nexports.FindAndModifyOperation = FindAndModifyOperation;\n/** @internal */\nclass FindOneAndDeleteOperation extends FindAndModifyOperation {\n    constructor(collection, filter, options) {\n        // Basic validation\n        if (filter == null || typeof filter !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"filter\" must be an object');\n        }\n        super(collection, filter, options);\n        this.cmdBase.remove = true;\n    }\n}\nexports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;\n/** @internal */\nclass FindOneAndReplaceOperation extends FindAndModifyOperation {\n    constructor(collection, filter, replacement, options) {\n        if (filter == null || typeof filter !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"filter\" must be an object');\n        }\n        if (replacement == null || typeof replacement !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"replacement\" must be an object');\n        }\n        if ((0, utils_1.hasAtomicOperators)(replacement)) {\n            throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');\n        }\n        super(collection, filter, options);\n        this.cmdBase.update = replacement;\n        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n    }\n}\nexports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;\n/** @internal */\nclass FindOneAndUpdateOperation extends FindAndModifyOperation {\n    constructor(collection, filter, update, options) {\n        if (filter == null || typeof filter !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"filter\" must be an object');\n        }\n        if (update == null || typeof update !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"update\" must be an object');\n        }\n        if (!(0, utils_1.hasAtomicOperators)(update)) {\n            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n        }\n        super(collection, filter, options);\n        this.cmdBase.update = update;\n        configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n        if (options.arrayFilters) {\n            this.cmdBase.arrayFilters = options.arrayFilters;\n        }\n    }\n}\nexports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;\n(0, operation_1.defineAspects)(FindAndModifyOperation, [\n    operation_1.Aspect.WRITE_OPERATION,\n    operation_1.Aspect.RETRYABLE,\n    operation_1.Aspect.EXPLAINABLE\n]);\n//# sourceMappingURL=find_and_modify.js.map"
        }
    ]
}