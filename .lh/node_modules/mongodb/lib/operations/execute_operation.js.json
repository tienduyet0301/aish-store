{
    "sourceFile": "node_modules/mongodb/lib/operations/execute_operation.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892624429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executeOperation = executeOperation;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nasync function executeOperation(client, operation, timeoutContext) {\n    if (!(operation instanceof operation_1.AbstractOperation)) {\n        // TODO(NODE-3483): Extend MongoRuntimeError\n        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n    }\n    const topology = client.topology == null\n        ? await (0, utils_1.abortable)(autoConnect(client), operation.options)\n        : client.topology;\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session = operation.session;\n    let owner;\n    if (session == null) {\n        owner = Symbol();\n        session = client.startSession({ owner, explicit: false });\n    }\n    else if (session.hasEnded) {\n        throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n    }\n    else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n    }\n    else if (session.client !== client) {\n        throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n    }\n    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n    const inTransaction = !!session?.inTransaction();\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    if (inTransaction &&\n        !readPreference.equals(read_preference_1.ReadPreference.primary) &&\n        (hasReadAspect || operation.commandName === 'runCommand')) {\n        throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n    }\n    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n        session.unpin();\n    }\n    timeoutContext ??= timeout_1.TimeoutContext.create({\n        session,\n        serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,\n        waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,\n        timeoutMS: operation.options.timeoutMS\n    });\n    try {\n        return await tryOperation(operation, {\n            topology,\n            timeoutContext,\n            session,\n            readPreference\n        });\n    }\n    finally {\n        if (session?.owner != null && session.owner === owner) {\n            await session.endSession();\n        }\n    }\n}\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client) {\n    if (client.topology == null) {\n        if (client.s.hasBeenClosed) {\n            throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n        }\n        client.s.options.__skipPingOnConnect = true;\n        try {\n            await client.connect();\n            if (client.topology == null) {\n                throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n            }\n            return client.topology;\n        }\n        finally {\n            delete client.s.options.__skipPingOnConnect;\n        }\n    }\n    return client.topology;\n}\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation(operation, { topology, timeoutContext, session, readPreference }) {\n    let selector;\n    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n        // GetMore and KillCursor operations must always select the same server, but run through\n        // server selection to potentially force monitor checks if the server is\n        // in an unknown state.\n        selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n    }\n    else if (operation.trySecondaryWrite) {\n        // If operation should try to write to secondary use the custom server selector\n        // otherwise provide the read preference.\n        selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n    }\n    else {\n        selector = readPreference;\n    }\n    let server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        timeoutContext,\n        signal: operation.options.signal\n    });\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const inTransaction = session?.inTransaction() ?? false;\n    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n    const willRetryWrite = topology.s.options.retryWrites &&\n        !inTransaction &&\n        (0, utils_1.supportsRetryableWrites)(server) &&\n        operation.canRetryWrite;\n    const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) &&\n        session != null &&\n        ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));\n    if (hasWriteAspect && willRetryWrite && session != null) {\n        operation.options.willRetryWrite = true;\n        session.incrementTransactionNumber();\n    }\n    const maxTries = willRetry ? (timeoutContext.csotEnabled() ? Infinity : 2) : 1;\n    let previousOperationError;\n    let previousServer;\n    for (let tries = 0; tries < maxTries; tries++) {\n        if (previousOperationError) {\n            if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n                throw new error_1.MongoServerError({\n                    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                    originalError: previousOperationError\n                });\n            }\n            if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n                throw previousOperationError;\n            }\n            if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError))\n                throw previousOperationError;\n            if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError))\n                throw previousOperationError;\n            if (previousOperationError instanceof error_1.MongoNetworkError &&\n                operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) &&\n                session != null &&\n                session.isPinned &&\n                !session.inTransaction()) {\n                session.unpin({ force: true, forceClear: true });\n            }\n            server = await topology.selectServer(selector, {\n                session,\n                operationName: operation.commandName,\n                previousServer,\n                signal: operation.options.signal\n            });\n            if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {\n                throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n            }\n        }\n        try {\n            // If tries > 0 and we are command batching we need to reset the batch.\n            if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {\n                operation.resetBatch();\n            }\n            return await operation.execute(server, session, timeoutContext);\n        }\n        catch (operationError) {\n            if (!(operationError instanceof error_1.MongoError))\n                throw operationError;\n            if (previousOperationError != null &&\n                operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n                throw previousOperationError;\n            }\n            previousServer = server.description;\n            previousOperationError = operationError;\n            // Reset timeouts\n            timeoutContext.clear();\n        }\n    }\n    throw (previousOperationError ??\n        new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.'));\n}\n//# sourceMappingURL=execute_operation.js.map"
        }
    ]
}