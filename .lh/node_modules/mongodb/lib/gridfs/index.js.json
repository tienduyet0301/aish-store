{
    "sourceFile": "node_modules/mongodb/lib/gridfs/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892621290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridFSBucket = void 0;\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"../write_concern\");\nconst download_1 = require(\"./download\");\nconst upload_1 = require(\"./upload\");\nconst DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n    bucketName: 'fs',\n    chunkSizeBytes: 255 * 1024\n};\n/**\n * Constructor for a streaming GridFS interface\n * @public\n */\nclass GridFSBucket extends mongo_types_1.TypedEventEmitter {\n    constructor(db, options) {\n        super();\n        this.on('error', utils_1.noop);\n        this.setMaxListeners(0);\n        const privateOptions = (0, utils_1.resolveOptions)(db, {\n            ...DEFAULT_GRIDFS_BUCKET_OPTIONS,\n            ...options,\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n        });\n        this.s = {\n            db,\n            options: privateOptions,\n            _chunksCollection: db.collection(privateOptions.bucketName + '.chunks'),\n            _filesCollection: db.collection(privateOptions.bucketName + '.files'),\n            checkedIndexes: false,\n            calledOpenUploadStream: false\n        };\n    }\n    /**\n     * Returns a writable stream (GridFSBucketWriteStream) for writing\n     * buffers to GridFS. The stream's 'id' property contains the resulting\n     * file's id.\n     *\n     * @param filename - The value of the 'filename' key in the files doc\n     * @param options - Optional settings.\n     */\n    openUploadStream(filename, options) {\n        return new upload_1.GridFSBucketWriteStream(this, filename, {\n            timeoutMS: this.s.options.timeoutMS,\n            ...options\n        });\n    }\n    /**\n     * Returns a writable stream (GridFSBucketWriteStream) for writing\n     * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n     * file's id.\n     */\n    openUploadStreamWithId(id, filename, options) {\n        return new upload_1.GridFSBucketWriteStream(this, filename, {\n            timeoutMS: this.s.options.timeoutMS,\n            ...options,\n            id\n        });\n    }\n    /** Returns a readable stream (GridFSBucketReadStream) for streaming file data from GridFS. */\n    openDownloadStream(id, options) {\n        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, { timeoutMS: this.s.options.timeoutMS, ...options });\n    }\n    /**\n     * Deletes a file with the given id\n     *\n     * @param id - The id of the file doc\n     */\n    async delete(id, options) {\n        const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);\n        let timeoutContext = undefined;\n        if (timeoutMS) {\n            timeoutContext = new timeout_1.CSOTTimeoutContext({\n                timeoutMS,\n                serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS\n            });\n        }\n        const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id }, { timeoutMS: timeoutContext?.remainingTimeMS });\n        const remainingTimeMS = timeoutContext?.remainingTimeMS;\n        if (remainingTimeMS != null && remainingTimeMS <= 0)\n            throw new error_1.MongoOperationTimeoutError(`Timed out after ${timeoutMS}ms`);\n        // Delete orphaned chunks before returning FileNotFound\n        await this.s._chunksCollection.deleteMany({ files_id: id }, { timeoutMS: remainingTimeMS });\n        if (deletedCount === 0) {\n            // TODO(NODE-3483): Replace with more appropriate error\n            // Consider creating new error MongoGridFSFileNotFoundError\n            throw new error_1.MongoRuntimeError(`File not found for id ${id}`);\n        }\n    }\n    /** Convenience wrapper around find on the files collection */\n    find(filter = {}, options = {}) {\n        return this.s._filesCollection.find(filter, options);\n    }\n    /**\n     * Returns a readable stream (GridFSBucketReadStream) for streaming the\n     * file with the given name from GridFS. If there are multiple files with\n     * the same name, this will stream the most recent file with the given name\n     * (as determined by the `uploadDate` field). You can set the `revision`\n     * option to change this behavior.\n     */\n    openDownloadStreamByName(filename, options) {\n        let sort = { uploadDate: -1 };\n        let skip = undefined;\n        if (options && options.revision != null) {\n            if (options.revision >= 0) {\n                sort = { uploadDate: 1 };\n                skip = options.revision;\n            }\n            else {\n                skip = -options.revision - 1;\n            }\n        }\n        return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { timeoutMS: this.s.options.timeoutMS, ...options, sort, skip });\n    }\n    /**\n     * Renames the file with the given _id to the given string\n     *\n     * @param id - the id of the file to rename\n     * @param filename - new name for the file\n     */\n    async rename(id, filename, options) {\n        const filter = { _id: id };\n        const update = { $set: { filename } };\n        const { matchedCount } = await this.s._filesCollection.updateOne(filter, update, options);\n        if (matchedCount === 0) {\n            throw new error_1.MongoRuntimeError(`File with id ${id} not found`);\n        }\n    }\n    /** Removes this bucket's files collection, followed by its chunks collection. */\n    async drop(options) {\n        const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);\n        let timeoutContext = undefined;\n        if (timeoutMS) {\n            timeoutContext = new timeout_1.CSOTTimeoutContext({\n                timeoutMS,\n                serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS\n            });\n        }\n        if (timeoutContext) {\n            await this.s._filesCollection.drop({ timeoutMS: timeoutContext.remainingTimeMS });\n            const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(`Timed out after ${timeoutMS}ms`);\n            await this.s._chunksCollection.drop({ timeoutMS: remainingTimeMS });\n        }\n        else {\n            await this.s._filesCollection.drop();\n            await this.s._chunksCollection.drop();\n        }\n    }\n}\nexports.GridFSBucket = GridFSBucket;\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n * @event\n */\nGridFSBucket.INDEX = 'index';\n//# sourceMappingURL=index.js.map"
        }
    ]
}