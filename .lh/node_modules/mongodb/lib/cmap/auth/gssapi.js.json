{
    "sourceFile": "node_modules/mongodb/lib/cmap/auth/gssapi.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892615719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\nexports.resolveCname = resolveCname;\nconst dns = require(\"dns\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\n/** @public */\nexports.GSSAPICanonicalizationValue = Object.freeze({\n    on: true,\n    off: false,\n    none: 'none',\n    forward: 'forward',\n    forwardAndReverse: 'forwardAndReverse'\n});\nasync function externalCommand(connection, command) {\n    const response = await connection.command((0, utils_1.ns)('$external.$cmd'), command);\n    return response;\n}\nlet krb;\nclass GSSAPI extends auth_provider_1.AuthProvider {\n    async auth(authContext) {\n        const { connection, credentials } = authContext;\n        if (credentials == null) {\n            throw new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n        }\n        const { username } = credentials;\n        const client = await makeKerberosClient(authContext);\n        const payload = await client.step('');\n        const saslStartResponse = await externalCommand(connection, saslStart(payload));\n        const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n        const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));\n        const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n        await externalCommand(connection, {\n            saslContinue: 1,\n            conversationId: saslContinueResponse.conversationId,\n            payload: finalizePayload\n        });\n    }\n}\nexports.GSSAPI = GSSAPI;\nasync function makeKerberosClient(authContext) {\n    const { hostAddress } = authContext.options;\n    const { credentials } = authContext;\n    if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n        throw new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.');\n    }\n    loadKrb();\n    if ('kModuleError' in krb) {\n        throw krb['kModuleError'];\n    }\n    const { initializeClient } = krb;\n    const { username, password } = credentials;\n    const mechanismProperties = credentials.mechanismProperties;\n    const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n    const initOptions = {};\n    if (password != null) {\n        // TODO(NODE-5139): These do not match the typescript options in initializeClient\n        Object.assign(initOptions, { user: username, password: password });\n    }\n    const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n    let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n    if ('SERVICE_REALM' in mechanismProperties) {\n        spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n    }\n    return await initializeClient(spn, initOptions);\n}\nfunction saslStart(payload) {\n    return {\n        saslStart: 1,\n        mechanism: 'GSSAPI',\n        payload,\n        autoAuthorize: 1\n    };\n}\nfunction saslContinue(payload, conversationId) {\n    return {\n        saslContinue: 1,\n        conversationId,\n        payload\n    };\n}\nasync function negotiate(client, retries, payload) {\n    try {\n        const response = await client.step(payload);\n        return response || '';\n    }\n    catch (error) {\n        if (retries === 0) {\n            // Retries exhausted, raise error\n            throw error;\n        }\n        // Adjust number of retries and call step again\n        return await negotiate(client, retries - 1, payload);\n    }\n}\nasync function finalize(client, user, payload) {\n    // GSS Client Unwrap\n    const response = await client.unwrap(payload);\n    return await client.wrap(response || '', { user });\n}\nasync function performGSSAPICanonicalizeHostName(host, mechanismProperties) {\n    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n        return host;\n    }\n    // If forward and reverse or true\n    if (mode === exports.GSSAPICanonicalizationValue.on ||\n        mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n        // Perform the lookup of the ip address.\n        const { address } = await dns.promises.lookup(host);\n        try {\n            // Perform a reverse ptr lookup on the ip address.\n            const results = await dns.promises.resolvePtr(address);\n            // If the ptr did not error but had no results, return the host.\n            return results.length > 0 ? results[0] : host;\n        }\n        catch {\n            // This can error as ptr records may not exist for all ips. In this case\n            // fallback to a cname lookup as dns.lookup() does not return the\n            // cname.\n            return await resolveCname(host);\n        }\n    }\n    else {\n        // The case for forward is just to resolve the cname as dns.lookup()\n        // will not return it.\n        return await resolveCname(host);\n    }\n}\nasync function resolveCname(host) {\n    // Attempt to resolve the host name\n    try {\n        const results = await dns.promises.resolveCname(host);\n        // Get the first resolved host id\n        return results.length > 0 ? results[0] : host;\n    }\n    catch {\n        return host;\n    }\n}\n/**\n * Load the Kerberos library.\n */\nfunction loadKrb() {\n    if (!krb) {\n        krb = (0, deps_1.getKerberos)();\n    }\n}\n//# sourceMappingURL=gssapi.js.map"
        }
    ]
}