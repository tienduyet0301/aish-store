{
    "sourceFile": "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/machine_workflow.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892616539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MachineWorkflow = void 0;\nconst promises_1 = require(\"timers/promises\");\nconst utils_1 = require(\"../../../utils\");\nconst command_builders_1 = require(\"./command_builders\");\n/** The time to throttle callback calls. */\nconst THROTTLE_MS = 100;\n/**\n * Common behaviour for OIDC machine workflows.\n * @internal\n */\nclass MachineWorkflow {\n    /**\n     * Instantiate the machine workflow.\n     */\n    constructor(cache) {\n        this.cache = cache;\n        this.callback = this.withLock(this.getToken.bind(this));\n        this.lastExecutionTime = Date.now() - THROTTLE_MS;\n    }\n    /**\n     * Execute the workflow. Gets the token from the subclass implementation.\n     */\n    async execute(connection, credentials) {\n        const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n        const command = (0, command_builders_1.finishCommandDocument)(token);\n        await connection.command((0, utils_1.ns)(credentials.source), command, undefined);\n    }\n    /**\n     * Reauthenticate on a machine workflow just grabs the token again since the server\n     * has said the current access token is invalid or expired.\n     */\n    async reauthenticate(connection, credentials) {\n        if (this.cache.hasAccessToken) {\n            // Reauthentication implies the token has expired.\n            if (connection.accessToken === this.cache.getAccessToken()) {\n                // If connection's access token is the same as the cache's, remove\n                // the token from the cache and connection.\n                this.cache.removeAccessToken();\n                delete connection.accessToken;\n            }\n            else {\n                // If the connection's access token is different from the cache's, set\n                // the cache's token on the connection and do not remove from the\n                // cache.\n                connection.accessToken = this.cache.getAccessToken();\n            }\n        }\n        await this.execute(connection, credentials);\n    }\n    /**\n     * Get the document to add for speculative authentication.\n     */\n    async speculativeAuth(connection, credentials) {\n        // The spec states only cached access tokens can use speculative auth.\n        if (!this.cache.hasAccessToken) {\n            return {};\n        }\n        const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n        const document = (0, command_builders_1.finishCommandDocument)(token);\n        document.db = credentials.source;\n        return { speculativeAuthenticate: document };\n    }\n    /**\n     * Get the token from the cache or environment.\n     */\n    async getTokenFromCacheOrEnv(connection, credentials) {\n        if (this.cache.hasAccessToken) {\n            const token = this.cache.getAccessToken();\n            // New connections won't have an access token so ensure we set here.\n            if (!connection.accessToken) {\n                connection.accessToken = token;\n            }\n            return token;\n        }\n        else {\n            const token = await this.callback(credentials);\n            this.cache.put({ accessToken: token.access_token, expiresInSeconds: token.expires_in });\n            // Put the access token on the connection as well.\n            connection.accessToken = token.access_token;\n            return token.access_token;\n        }\n    }\n    /**\n     * Ensure the callback is only executed one at a time, and throttled to\n     * only once per 100ms.\n     */\n    withLock(callback) {\n        let lock = Promise.resolve();\n        return async (credentials) => {\n            // We do this to ensure that we would never return the result of the\n            // previous lock, only the current callback's value would get returned.\n            await lock;\n            lock = lock\n                .catch(() => null)\n                .then(async () => {\n                const difference = Date.now() - this.lastExecutionTime;\n                if (difference <= THROTTLE_MS) {\n                    await (0, promises_1.setTimeout)(THROTTLE_MS - difference);\n                }\n                this.lastExecutionTime = Date.now();\n                return await callback(credentials);\n            });\n            return await lock;\n        };\n    }\n}\nexports.MachineWorkflow = MachineWorkflow;\n//# sourceMappingURL=machine_workflow.js.map"
        }
    ]
}