{
    "sourceFile": "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892616063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallbackWorkflow = exports.AUTOMATED_TIMEOUT_MS = exports.HUMAN_TIMEOUT_MS = void 0;\nconst promises_1 = require(\"timers/promises\");\nconst error_1 = require(\"../../../error\");\nconst utils_1 = require(\"../../../utils\");\nconst command_builders_1 = require(\"./command_builders\");\n/** 5 minutes in milliseconds */\nexports.HUMAN_TIMEOUT_MS = 300000;\n/** 1 minute in milliseconds */\nexports.AUTOMATED_TIMEOUT_MS = 60000;\n/** Properties allowed on results of callbacks. */\nconst RESULT_PROPERTIES = ['accessToken', 'expiresInSeconds', 'refreshToken'];\n/** Error message when the callback result is invalid. */\nconst CALLBACK_RESULT_ERROR = 'User provided OIDC callbacks must return a valid object with an accessToken.';\n/** The time to throttle callback calls. */\nconst THROTTLE_MS = 100;\n/**\n * OIDC implementation of a callback based workflow.\n * @internal\n */\nclass CallbackWorkflow {\n    /**\n     * Instantiate the callback workflow.\n     */\n    constructor(cache, callback) {\n        this.cache = cache;\n        this.callback = this.withLock(callback);\n        this.lastExecutionTime = Date.now() - THROTTLE_MS;\n    }\n    /**\n     * Get the document to add for speculative authentication. This also needs\n     * to add a db field from the credentials source.\n     */\n    async speculativeAuth(connection, credentials) {\n        // Check if the Client Cache has an access token.\n        // If it does, cache the access token in the Connection Cache and send a JwtStepRequest\n        // with the cached access token in the speculative authentication SASL payload.\n        if (this.cache.hasAccessToken) {\n            const accessToken = this.cache.getAccessToken();\n            connection.accessToken = accessToken;\n            const document = (0, command_builders_1.finishCommandDocument)(accessToken);\n            document.db = credentials.source;\n            return { speculativeAuthenticate: document };\n        }\n        return {};\n    }\n    /**\n     * Reauthenticate the callback workflow. For this we invalidated the access token\n     * in the cache and run the authentication steps again. No initial handshake needs\n     * to be sent.\n     */\n    async reauthenticate(connection, credentials) {\n        if (this.cache.hasAccessToken) {\n            // Reauthentication implies the token has expired.\n            if (connection.accessToken === this.cache.getAccessToken()) {\n                // If connection's access token is the same as the cache's, remove\n                // the token from the cache and connection.\n                this.cache.removeAccessToken();\n                delete connection.accessToken;\n            }\n            else {\n                // If the connection's access token is different from the cache's, set\n                // the cache's token on the connection and do not remove from the\n                // cache.\n                connection.accessToken = this.cache.getAccessToken();\n            }\n        }\n        await this.execute(connection, credentials);\n    }\n    /**\n     * Starts the callback authentication process. If there is a speculative\n     * authentication document from the initial handshake, then we will use that\n     * value to get the issuer, otherwise we will send the saslStart command.\n     */\n    async startAuthentication(connection, credentials, response) {\n        let result;\n        if (response?.speculativeAuthenticate) {\n            result = response.speculativeAuthenticate;\n        }\n        else {\n            result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), undefined);\n        }\n        return result;\n    }\n    /**\n     * Finishes the callback authentication process.\n     */\n    async finishAuthentication(connection, credentials, token, conversationId) {\n        await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), undefined);\n    }\n    /**\n     * Executes the callback and validates the output.\n     */\n    async executeAndValidateCallback(params) {\n        const result = await this.callback(params);\n        // Validate that the result returned by the callback is acceptable. If it is not\n        // we must clear the token result from the cache.\n        if (isCallbackResultInvalid(result)) {\n            throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);\n        }\n        return result;\n    }\n    /**\n     * Ensure the callback is only executed one at a time and throttles the calls\n     * to every 100ms.\n     */\n    withLock(callback) {\n        let lock = Promise.resolve();\n        return async (params) => {\n            // We do this to ensure that we would never return the result of the\n            // previous lock, only the current callback's value would get returned.\n            await lock;\n            lock = lock\n                .catch(() => null)\n                .then(async () => {\n                const difference = Date.now() - this.lastExecutionTime;\n                if (difference <= THROTTLE_MS) {\n                    await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });\n                }\n                this.lastExecutionTime = Date.now();\n                return await callback(params);\n            });\n            return await lock;\n        };\n    }\n}\nexports.CallbackWorkflow = CallbackWorkflow;\n/**\n * Determines if a result returned from a request or refresh callback\n * function is invalid. This means the result is nullish, doesn't contain\n * the accessToken required field, and does not contain extra fields.\n */\nfunction isCallbackResultInvalid(tokenResult) {\n    if (tokenResult == null || typeof tokenResult !== 'object')\n        return true;\n    if (!('accessToken' in tokenResult))\n        return true;\n    return !Object.getOwnPropertyNames(tokenResult).every(prop => RESULT_PROPERTIES.includes(prop));\n}\n//# sourceMappingURL=callback_workflow.js.map"
        }
    ]
}