{
    "sourceFile": "node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892616343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HumanCallbackWorkflow = void 0;\nconst bson_1 = require(\"../../../bson\");\nconst error_1 = require(\"../../../error\");\nconst timeout_1 = require(\"../../../timeout\");\nconst mongodb_oidc_1 = require(\"../mongodb_oidc\");\nconst callback_workflow_1 = require(\"./callback_workflow\");\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nclass HumanCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {\n    /**\n     * Instantiate the human callback workflow.\n     */\n    constructor(cache, callback) {\n        super(cache, callback);\n    }\n    /**\n     * Execute the OIDC human callback workflow.\n     */\n    async execute(connection, credentials) {\n        // Check if the Client Cache has an access token.\n        // If it does, cache the access token in the Connection Cache and perform a One-Step SASL conversation\n        // using the access token. If the server returns an Authentication error (18),\n        // invalidate the access token token from the Client Cache, clear the Connection Cache,\n        // and restart the authentication flow. Raise any other errors to the user. On success, exit the algorithm.\n        if (this.cache.hasAccessToken) {\n            const token = this.cache.getAccessToken();\n            connection.accessToken = token;\n            try {\n                return await this.finishAuthentication(connection, credentials, token);\n            }\n            catch (error) {\n                if (error instanceof error_1.MongoError &&\n                    error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {\n                    this.cache.removeAccessToken();\n                    delete connection.accessToken;\n                    return await this.execute(connection, credentials);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        // Check if the Client Cache has a refresh token.\n        // If it does, call the OIDC Human Callback with the cached refresh token and IdpInfo to get a\n        // new access token. Cache the new access token in the Client Cache and Connection Cache.\n        // Perform a One-Step SASL conversation using the new access token. If the the server returns\n        // an Authentication error (18), clear the refresh token, invalidate the access token from the\n        // Client Cache, clear the Connection Cache, and restart the authentication flow. Raise any other\n        // errors to the user. On success, exit the algorithm.\n        if (this.cache.hasRefreshToken) {\n            const refreshToken = this.cache.getRefreshToken();\n            const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);\n            this.cache.put(result);\n            connection.accessToken = result.accessToken;\n            try {\n                return await this.finishAuthentication(connection, credentials, result.accessToken);\n            }\n            catch (error) {\n                if (error instanceof error_1.MongoError &&\n                    error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {\n                    this.cache.removeRefreshToken();\n                    delete connection.accessToken;\n                    return await this.execute(connection, credentials);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        // Start a new Two-Step SASL conversation.\n        // Run a PrincipalStepRequest to get the IdpInfo.\n        // Call the OIDC Human Callback with the new IdpInfo to get a new access token and optional refresh\n        // token. Drivers MUST NOT pass a cached refresh token to the callback when performing\n        // a new Two-Step conversation. Cache the new IdpInfo and refresh token in the Client Cache and the\n        // new access token in the Client Cache and Connection Cache.\n        // Attempt to authenticate using a JwtStepRequest with the new access token. Raise any errors to the user.\n        const startResponse = await this.startAuthentication(connection, credentials);\n        const conversationId = startResponse.conversationId;\n        const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);\n        const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);\n        this.cache.put(callbackResponse, idpInfo);\n        connection.accessToken = callbackResponse.accessToken;\n        return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);\n    }\n    /**\n     * Fetches an access token using the callback.\n     */\n    async fetchAccessToken(idpInfo, credentials, refreshToken) {\n        const controller = new AbortController();\n        const params = {\n            timeoutContext: controller.signal,\n            version: mongodb_oidc_1.OIDC_VERSION,\n            idpInfo: idpInfo\n        };\n        if (credentials.username) {\n            params.username = credentials.username;\n        }\n        if (refreshToken) {\n            params.refreshToken = refreshToken;\n        }\n        const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);\n        try {\n            return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n        }\n        catch (error) {\n            if (timeout_1.TimeoutError.is(error)) {\n                controller.abort();\n                throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);\n            }\n            throw error;\n        }\n        finally {\n            timeout.clear();\n        }\n    }\n}\nexports.HumanCallbackWorkflow = HumanCallbackWorkflow;\n//# sourceMappingURL=human_callback_workflow.js.map"
        }
    ]
}