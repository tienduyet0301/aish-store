{
    "sourceFile": "node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892618551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OnDemandDocument = void 0;\nconst bson_1 = require(\"../../../bson\");\n/** @internal */\nclass OnDemandDocument {\n    constructor(\n    /** BSON bytes, this document begins at offset */\n    bson, \n    /** The start of the document */\n    offset = 0, \n    /** If this is an embedded document, indicates if this was a BSON array */\n    isArray = false, \n    /** If elements was already calculated */\n    elements) {\n        this.bson = bson;\n        this.offset = offset;\n        this.isArray = isArray;\n        /**\n         * Maps JS strings to elements and jsValues for speeding up subsequent lookups.\n         * - If `false` then name does not exist in the BSON document\n         * - If `CachedBSONElement` instance name exists\n         * - If `cache[name].value == null` jsValue has not yet been parsed\n         *   - Null/Undefined values do not get cached because they are zero-length values.\n         */\n        this.cache = Object.create(null);\n        /** Caches the index of elements that have been named */\n        this.indexFound = Object.create(null);\n        this.elements = elements ?? (0, bson_1.parseToElementsToArray)(this.bson, offset);\n    }\n    /** Only supports basic latin strings */\n    isElementName(name, element) {\n        const nameLength = element[2 /* BSONElementOffset.nameLength */];\n        const nameOffset = element[1 /* BSONElementOffset.nameOffset */];\n        if (name.length !== nameLength)\n            return false;\n        const nameEnd = nameOffset + nameLength;\n        for (let byteIndex = nameOffset, charIndex = 0; charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {\n            if (this.bson[byteIndex] !== name.charCodeAt(charIndex))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Seeks into the elements array for an element matching the given name.\n     *\n     * @remarks\n     * Caching:\n     * - Caches the existence of a property making subsequent look ups for non-existent properties return immediately\n     * - Caches names mapped to elements to avoid reiterating the array and comparing the name again\n     * - Caches the index at which an element has been found to prevent rechecking against elements already determined to belong to another name\n     *\n     * @param name - a basic latin string name of a BSON element\n     * @returns\n     */\n    getElement(name) {\n        const cachedElement = this.cache[name];\n        if (cachedElement === false)\n            return null;\n        if (cachedElement != null) {\n            return cachedElement;\n        }\n        if (typeof name === 'number') {\n            if (this.isArray) {\n                if (name < this.elements.length) {\n                    const element = this.elements[name];\n                    const cachedElement = { element, value: undefined };\n                    this.cache[name] = cachedElement;\n                    this.indexFound[name] = true;\n                    return cachedElement;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        for (let index = 0; index < this.elements.length; index++) {\n            const element = this.elements[index];\n            // skip this element if it has already been associated with a name\n            if (!(index in this.indexFound) && this.isElementName(name, element)) {\n                const cachedElement = { element, value: undefined };\n                this.cache[name] = cachedElement;\n                this.indexFound[index] = true;\n                return cachedElement;\n            }\n        }\n        this.cache[name] = false;\n        return null;\n    }\n    toJSValue(element, as) {\n        const type = element[0 /* BSONElementOffset.type */];\n        const offset = element[3 /* BSONElementOffset.offset */];\n        const length = element[4 /* BSONElementOffset.length */];\n        if (as !== type) {\n            return null;\n        }\n        switch (as) {\n            case bson_1.BSONType.null:\n            case bson_1.BSONType.undefined:\n                return null;\n            case bson_1.BSONType.double:\n                return (0, bson_1.getFloat64LE)(this.bson, offset);\n            case bson_1.BSONType.int:\n                return (0, bson_1.getInt32LE)(this.bson, offset);\n            case bson_1.BSONType.long:\n                return (0, bson_1.getBigInt64LE)(this.bson, offset);\n            case bson_1.BSONType.bool:\n                return Boolean(this.bson[offset]);\n            case bson_1.BSONType.objectId:\n                return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));\n            case bson_1.BSONType.timestamp:\n                return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));\n            case bson_1.BSONType.string:\n                return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);\n            case bson_1.BSONType.binData: {\n                const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);\n                const subType = this.bson[offset + 4];\n                if (subType === 2) {\n                    const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);\n                    if (subType2BinarySize < 0)\n                        throw new bson_1.BSONError('Negative binary type element size found for subtype 0x02');\n                    if (subType2BinarySize > totalBinarySize - 4)\n                        throw new bson_1.BSONError('Binary type with subtype 0x02 contains too long binary size');\n                    if (subType2BinarySize < totalBinarySize - 4)\n                        throw new bson_1.BSONError('Binary type with subtype 0x02 contains too short binary size');\n                    return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);\n                }\n                return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);\n            }\n            case bson_1.BSONType.date:\n                // Pretend this is correct.\n                return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));\n            case bson_1.BSONType.object:\n                return new OnDemandDocument(this.bson, offset);\n            case bson_1.BSONType.array:\n                return new OnDemandDocument(this.bson, offset, true);\n            default:\n                throw new bson_1.BSONError(`Unsupported BSON type: ${as}`);\n        }\n    }\n    /**\n     * Returns the number of elements in this BSON document\n     */\n    size() {\n        return this.elements.length;\n    }\n    /**\n     * Checks for the existence of an element by name.\n     *\n     * @remarks\n     * Uses `getElement` with the expectation that will populate caches such that a `has` call\n     * followed by a `getElement` call will not repeat the cost paid by the first look up.\n     *\n     * @param name - element name\n     */\n    has(name) {\n        const cachedElement = this.cache[name];\n        if (cachedElement === false)\n            return false;\n        if (cachedElement != null)\n            return true;\n        return this.getElement(name) != null;\n    }\n    get(name, as, required) {\n        const element = this.getElement(name);\n        if (element == null) {\n            if (required === true) {\n                throw new bson_1.BSONError(`BSON element \"${name}\" is missing`);\n            }\n            else {\n                return null;\n            }\n        }\n        if (element.value == null) {\n            const value = this.toJSValue(element.element, as);\n            if (value == null) {\n                if (required === true) {\n                    throw new bson_1.BSONError(`BSON element \"${name}\" is missing`);\n                }\n                else {\n                    return null;\n                }\n            }\n            // It is important to never store null\n            element.value = value;\n        }\n        return element.value;\n    }\n    getNumber(name, required) {\n        const maybeBool = this.get(name, bson_1.BSONType.bool);\n        const bool = maybeBool == null ? null : maybeBool ? 1 : 0;\n        const maybeLong = this.get(name, bson_1.BSONType.long);\n        const long = maybeLong == null ? null : Number(maybeLong);\n        const result = bool ?? long ?? this.get(name, bson_1.BSONType.int) ?? this.get(name, bson_1.BSONType.double);\n        if (required === true && result == null) {\n            throw new bson_1.BSONError(`BSON element \"${name}\" is missing`);\n        }\n        return result;\n    }\n    /**\n     * Deserialize this object, DOES NOT cache result so avoid multiple invocations\n     * @param options - BSON deserialization options\n     */\n    toObject(options) {\n        return (0, bson_1.deserialize)(this.bson, {\n            ...options,\n            index: this.offset,\n            allowObjectSmallerThanBufferSize: true\n        });\n    }\n    /** Returns this document's bytes only */\n    toBytes() {\n        const size = (0, bson_1.getInt32LE)(this.bson, this.offset);\n        return this.bson.subarray(this.offset, this.offset + size);\n    }\n}\nexports.OnDemandDocument = OnDemandDocument;\n//# sourceMappingURL=document.js.map"
        }
    ]
}