{
    "sourceFile": "node_modules/mongodb/lib/cmap/wire_protocol/responses.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892618632,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClientBulkWriteCursorResponse = exports.ExplainedCursorResponse = exports.CursorResponse = exports.MongoDBResponse = void 0;\nexports.isErrorResponse = isErrorResponse;\nconst bson_1 = require(\"../../bson\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst document_1 = require(\"./on_demand/document\");\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nfunction isErrorResponse(bson, elements) {\n    for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n        const element = elements[eIdx];\n        if (element[2 /* BSONElementOffset.nameLength */] === 2) {\n            const nameOffset = element[1 /* BSONElementOffset.nameOffset */];\n            // 111 == \"o\", 107 == \"k\"\n            if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n                const valueOffset = element[3 /* BSONElementOffset.offset */];\n                const valueLength = element[4 /* BSONElementOffset.length */];\n                // If any byte in the length of the ok number (works for any type) is non zero,\n                // then it is considered \"ok: 1\"\n                for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n                    if (bson[i] !== 0x00)\n                        return false;\n                }\n                return true;\n            }\n        }\n    }\n    return true;\n}\n/** @internal */\nclass MongoDBResponse extends document_1.OnDemandDocument {\n    get(name, as, required) {\n        try {\n            return super.get(name, as, required);\n        }\n        catch (cause) {\n            throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });\n        }\n    }\n    static is(value) {\n        return value instanceof MongoDBResponse;\n    }\n    static make(bson) {\n        const elements = (0, bson_1.parseToElementsToArray)(bson, 0);\n        const isError = isErrorResponse(bson, elements);\n        return isError\n            ? new MongoDBResponse(bson, 0, false, elements)\n            : new this(bson, 0, false, elements);\n    }\n    /**\n     * Returns true iff:\n     * - ok is 0 and the top-level code === 50\n     * - ok is 1 and the writeErrors array contains a code === 50\n     * - ok is 1 and the writeConcern object contains a code === 50\n     */\n    get isMaxTimeExpiredError() {\n        // {ok: 0, code: 50 ... }\n        const isTopLevel = this.ok === 0 && this.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n        if (isTopLevel)\n            return true;\n        if (this.ok === 0)\n            return false;\n        // {ok: 1, writeConcernError: {code: 50 ... }}\n        const isWriteConcern = this.get('writeConcernError', bson_1.BSONType.object)?.getNumber('code') ===\n            error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n        if (isWriteConcern)\n            return true;\n        const writeErrors = this.get('writeErrors', bson_1.BSONType.array);\n        if (writeErrors?.size()) {\n            for (let i = 0; i < writeErrors.size(); i++) {\n                const isWriteError = writeErrors.get(i, bson_1.BSONType.object)?.getNumber('code') ===\n                    error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n                // {ok: 1, writeErrors: [{code: 50 ... }]}\n                if (isWriteError)\n                    return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n     * contents of the document.\n     */\n    get recoveryToken() {\n        return (this.get('recoveryToken', bson_1.BSONType.object)?.toObject({\n            promoteValues: false,\n            promoteLongs: false,\n            promoteBuffers: false,\n            validation: { utf8: true }\n        }) ?? null);\n    }\n    /**\n     * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n     * For the distinct command the server adds a top-level atClusterTime field to the response.\n     * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n     */\n    get atClusterTime() {\n        return (this.get('cursor', bson_1.BSONType.object)?.get('atClusterTime', bson_1.BSONType.timestamp) ??\n            this.get('atClusterTime', bson_1.BSONType.timestamp));\n    }\n    get operationTime() {\n        return this.get('operationTime', bson_1.BSONType.timestamp);\n    }\n    /** Normalizes whatever BSON value is \"ok\" to a JS number 1 or 0. */\n    get ok() {\n        return this.getNumber('ok') ? 1 : 0;\n    }\n    get $err() {\n        return this.get('$err', bson_1.BSONType.string);\n    }\n    get errmsg() {\n        return this.get('errmsg', bson_1.BSONType.string);\n    }\n    get code() {\n        return this.getNumber('code');\n    }\n    get $clusterTime() {\n        if (!('clusterTime' in this)) {\n            const clusterTimeDoc = this.get('$clusterTime', bson_1.BSONType.object);\n            if (clusterTimeDoc == null) {\n                this.clusterTime = null;\n                return null;\n            }\n            const clusterTime = clusterTimeDoc.get('clusterTime', bson_1.BSONType.timestamp, true);\n            const signature = clusterTimeDoc.get('signature', bson_1.BSONType.object)?.toObject();\n            // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n            this.clusterTime = { clusterTime, signature };\n        }\n        return this.clusterTime ?? null;\n    }\n    toObject(options) {\n        const exactBSONOptions = {\n            ...(0, bson_1.pluckBSONSerializeOptions)(options ?? {}),\n            validation: (0, bson_1.parseUtf8ValidationOption)(options)\n        };\n        return super.toObject(exactBSONOptions);\n    }\n}\nexports.MongoDBResponse = MongoDBResponse;\n// {ok:1}\nMongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\n/** @internal */\nclass CursorResponse extends MongoDBResponse {\n    constructor() {\n        super(...arguments);\n        this._batch = null;\n        this.iterated = 0;\n        this._encryptedBatch = null;\n    }\n    /**\n     * This supports a feature of the FindCursor.\n     * It is an optimization to avoid an extra getMore when the limit has been reached\n     */\n    static get emptyGetMore() {\n        return new CursorResponse((0, bson_1.serialize)({ ok: 1, cursor: { id: 0n, nextBatch: [] } }));\n    }\n    static is(value) {\n        return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n    }\n    get cursor() {\n        return this.get('cursor', bson_1.BSONType.object, true);\n    }\n    get id() {\n        try {\n            return bson_1.Long.fromBigInt(this.cursor.get('id', bson_1.BSONType.long, true));\n        }\n        catch (cause) {\n            throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });\n        }\n    }\n    get ns() {\n        const namespace = this.cursor.get('ns', bson_1.BSONType.string);\n        if (namespace != null)\n            return (0, utils_1.ns)(namespace);\n        return null;\n    }\n    get length() {\n        return Math.max(this.batchSize - this.iterated, 0);\n    }\n    get encryptedBatch() {\n        if (this.encryptedResponse == null)\n            return null;\n        if (this._encryptedBatch != null)\n            return this._encryptedBatch;\n        const cursor = this.encryptedResponse?.get('cursor', bson_1.BSONType.object);\n        if (cursor?.has('firstBatch'))\n            this._encryptedBatch = cursor.get('firstBatch', bson_1.BSONType.array, true);\n        else if (cursor?.has('nextBatch'))\n            this._encryptedBatch = cursor.get('nextBatch', bson_1.BSONType.array, true);\n        else\n            throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n        return this._encryptedBatch;\n    }\n    get batch() {\n        if (this._batch != null)\n            return this._batch;\n        const cursor = this.cursor;\n        if (cursor.has('firstBatch'))\n            this._batch = cursor.get('firstBatch', bson_1.BSONType.array, true);\n        else if (cursor.has('nextBatch'))\n            this._batch = cursor.get('nextBatch', bson_1.BSONType.array, true);\n        else\n            throw new error_1.MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n        return this._batch;\n    }\n    get batchSize() {\n        return this.batch?.size();\n    }\n    get postBatchResumeToken() {\n        return (this.cursor.get('postBatchResumeToken', bson_1.BSONType.object)?.toObject({\n            promoteValues: false,\n            promoteLongs: false,\n            promoteBuffers: false,\n            validation: { utf8: true }\n        }) ?? null);\n    }\n    shift(options) {\n        if (this.iterated >= this.batchSize) {\n            return null;\n        }\n        const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;\n        const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;\n        this.iterated += 1;\n        if (options?.raw) {\n            return result.toBytes();\n        }\n        else {\n            const object = result.toObject(options);\n            if (encryptedResult) {\n                (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options), true);\n            }\n            return object;\n        }\n    }\n    clear() {\n        this.iterated = this.batchSize;\n    }\n}\nexports.CursorResponse = CursorResponse;\n/**\n * Explain responses have nothing to do with cursor responses\n * This class serves to temporarily avoid refactoring how cursors handle\n * explain responses which is to detect that the response is not cursor-like and return the explain\n * result as the \"first and only\" document in the \"batch\" and end the \"cursor\"\n */\nclass ExplainedCursorResponse extends CursorResponse {\n    constructor() {\n        super(...arguments);\n        this.isExplain = true;\n        this._length = 1;\n    }\n    get id() {\n        return bson_1.Long.fromBigInt(0n);\n    }\n    get batchSize() {\n        return 0;\n    }\n    get ns() {\n        return null;\n    }\n    get length() {\n        return this._length;\n    }\n    shift(options) {\n        if (this._length === 0)\n            return null;\n        this._length -= 1;\n        return this.toObject(options);\n    }\n}\nexports.ExplainedCursorResponse = ExplainedCursorResponse;\n/**\n * Client bulk writes have some extra metadata at the top level that needs to be\n * included in the result returned to the user.\n */\nclass ClientBulkWriteCursorResponse extends CursorResponse {\n    get insertedCount() {\n        return this.get('nInserted', bson_1.BSONType.int, true);\n    }\n    get upsertedCount() {\n        return this.get('nUpserted', bson_1.BSONType.int, true);\n    }\n    get matchedCount() {\n        return this.get('nMatched', bson_1.BSONType.int, true);\n    }\n    get modifiedCount() {\n        return this.get('nModified', bson_1.BSONType.int, true);\n    }\n    get deletedCount() {\n        return this.get('nDeleted', bson_1.BSONType.int, true);\n    }\n    get writeConcernError() {\n        return this.get('writeConcernError', bson_1.BSONType.object, false);\n    }\n}\nexports.ClientBulkWriteCursorResponse = ClientBulkWriteCursorResponse;\n//# sourceMappingURL=responses.js.map"
        }
    ]
}