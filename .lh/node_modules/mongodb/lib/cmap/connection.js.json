{
    "sourceFile": "node_modules/mongodb/lib/cmap/connection.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892617722,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoConnection = exports.SizedMessageTransform = exports.Connection = void 0;\nexports.hasSessionSupport = hasSessionSupport;\nconst stream_1 = require(\"stream\");\nconst timers_1 = require(\"timers\");\nconst bson_1 = require(\"../bson\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_logger_1 = require(\"../mongo_logger\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst read_preference_1 = require(\"../read_preference\");\nconst common_1 = require(\"../sdam/common\");\nconst sessions_1 = require(\"../sessions\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst commands_1 = require(\"./commands\");\nconst stream_description_1 = require(\"./stream_description\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst on_data_1 = require(\"./wire_protocol/on_data\");\nconst responses_1 = require(\"./wire_protocol/responses\");\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nfunction hasSessionSupport(conn) {\n    const description = conn.description;\n    return description.logicalSessionTimeoutMinutes != null;\n}\nfunction streamIdentifier(stream, options) {\n    if (options.proxyHost) {\n        // If proxy options are specified, the properties of `stream` itself\n        // will not accurately reflect what endpoint this is connected to.\n        return options.hostAddress.toString();\n    }\n    const { remoteAddress, remotePort } = stream;\n    if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n        return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n    }\n    return (0, utils_1.uuidV4)().toString('hex');\n}\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n    constructor(stream, options) {\n        super();\n        this.lastHelloMS = -1;\n        this.helloOk = false;\n        this.delayedTimeoutId = null;\n        /** Indicates that the connection (including underlying TCP socket) has been closed. */\n        this.closed = false;\n        this.clusterTime = null;\n        this.error = null;\n        this.dataEvents = null;\n        this.on('error', utils_1.noop);\n        this.socket = stream;\n        this.id = options.id;\n        this.address = streamIdentifier(stream, options);\n        this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n        this.monitorCommands = options.monitorCommands;\n        this.serverApi = options.serverApi;\n        this.mongoLogger = options.mongoLogger;\n        this.established = false;\n        this.description = new stream_description_1.StreamDescription(this.address, options);\n        this.generation = options.generation;\n        this.lastUseTime = (0, utils_1.now)();\n        this.messageStream = this.socket\n            .on('error', this.onError.bind(this))\n            .pipe(new SizedMessageTransform({ connection: this }))\n            .on('error', this.onError.bind(this));\n        this.socket.on('close', this.onClose.bind(this));\n        this.socket.on('timeout', this.onTimeout.bind(this));\n        this.messageStream.pause();\n    }\n    get hello() {\n        return this.description.hello;\n    }\n    // the `connect` method stores the result of the handshake hello on the connection\n    set hello(response) {\n        this.description.receiveResponse(response);\n        Object.freeze(this.description);\n    }\n    get serviceId() {\n        return this.hello?.serviceId;\n    }\n    get loadBalanced() {\n        return this.description.loadBalanced;\n    }\n    get idleTime() {\n        return (0, utils_1.calculateDurationInMs)(this.lastUseTime);\n    }\n    get hasSessionSupport() {\n        return this.description.logicalSessionTimeoutMinutes != null;\n    }\n    get supportsOpMsg() {\n        return (this.description != null &&\n            (0, utils_1.maxWireVersion)(this) >= 6 &&\n            !this.description.__nodejs_mock_server__);\n    }\n    get shouldEmitAndLogCommand() {\n        return ((this.monitorCommands ||\n            (this.established &&\n                !this.authContext?.reauthenticating &&\n                this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG))) ??\n            false);\n    }\n    markAvailable() {\n        this.lastUseTime = (0, utils_1.now)();\n    }\n    onError(error) {\n        this.cleanup(error);\n    }\n    onClose() {\n        const message = `connection ${this.id} to ${this.address} closed`;\n        this.cleanup(new error_1.MongoNetworkError(message));\n    }\n    onTimeout() {\n        this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {\n            const message = `connection ${this.id} to ${this.address} timed out`;\n            const beforeHandshake = this.hello == null;\n            this.cleanup(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));\n        }, 1).unref(); // No need for this timer to hold the event loop open\n    }\n    destroy() {\n        if (this.closed) {\n            return;\n        }\n        // load balanced mode requires that these listeners remain on the connection\n        // after cleanup on timeouts, errors or close so we remove them before calling\n        // cleanup.\n        this.removeAllListeners(Connection.PINNED);\n        this.removeAllListeners(Connection.UNPINNED);\n        const message = `connection ${this.id} to ${this.address} closed`;\n        this.cleanup(new error_1.MongoNetworkError(message));\n    }\n    /**\n     * A method that cleans up the connection.  When `force` is true, this method\n     * forcibly destroys the socket.\n     *\n     * If an error is provided, any in-flight operations will be closed with the error.\n     *\n     * This method does nothing if the connection is already closed.\n     */\n    cleanup(error) {\n        if (this.closed) {\n            return;\n        }\n        this.socket.destroy();\n        this.error = error;\n        this.dataEvents?.throw(error).then(undefined, utils_1.squashError);\n        this.closed = true;\n        this.emit(Connection.CLOSE);\n    }\n    prepareCommand(db, command, options) {\n        let cmd = { ...command };\n        const readPreference = (0, shared_1.getReadPreference)(options);\n        const session = options?.session;\n        let clusterTime = this.clusterTime;\n        if (this.serverApi) {\n            const { version, strict, deprecationErrors } = this.serverApi;\n            cmd.apiVersion = version;\n            if (strict != null)\n                cmd.apiStrict = strict;\n            if (deprecationErrors != null)\n                cmd.apiDeprecationErrors = deprecationErrors;\n        }\n        if (this.hasSessionSupport && session) {\n            if (session.clusterTime &&\n                clusterTime &&\n                session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n                clusterTime = session.clusterTime;\n            }\n            const sessionError = (0, sessions_1.applySession)(session, cmd, options);\n            if (sessionError)\n                throw sessionError;\n        }\n        else if (session?.explicit) {\n            throw new error_1.MongoCompatibilityError('Current topology does not support sessions');\n        }\n        // if we have a known cluster time, gossip it\n        if (clusterTime) {\n            cmd.$clusterTime = clusterTime;\n        }\n        // For standalone, drivers MUST NOT set $readPreference.\n        if (this.description.type !== common_1.ServerType.Standalone) {\n            if (!(0, shared_1.isSharded)(this) &&\n                !this.description.loadBalanced &&\n                this.supportsOpMsg &&\n                options.directConnection === true &&\n                readPreference?.mode === 'primary') {\n                // For mongos and load balancers with 'primary' mode, drivers MUST NOT set $readPreference.\n                // For all other types with a direct connection, if the read preference is 'primary'\n                // (driver sets 'primary' as default if no read preference is configured),\n                // the $readPreference MUST be set to 'primaryPreferred'\n                // to ensure that any server type can handle the request.\n                cmd.$readPreference = read_preference_1.ReadPreference.primaryPreferred.toJSON();\n            }\n            else if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference?.mode !== 'primary') {\n                // When sending a read operation via OP_QUERY and the $readPreference modifier,\n                // the query MUST be provided using the $query modifier.\n                cmd = {\n                    $query: cmd,\n                    $readPreference: readPreference.toJSON()\n                };\n            }\n            else if (readPreference?.mode !== 'primary') {\n                // For mode 'primary', drivers MUST NOT set $readPreference.\n                // For all other read preference modes (i.e. 'secondary', 'primaryPreferred', ...),\n                // drivers MUST set $readPreference\n                cmd.$readPreference = readPreference.toJSON();\n            }\n        }\n        const commandOptions = {\n            numberToSkip: 0,\n            numberToReturn: -1,\n            checkKeys: false,\n            // This value is not overridable\n            secondaryOk: readPreference.secondaryOk(),\n            ...options\n        };\n        options.timeoutContext?.addMaxTimeMSToCommand(cmd, options);\n        const message = this.supportsOpMsg\n            ? new commands_1.OpMsgRequest(db, cmd, commandOptions)\n            : new commands_1.OpQueryRequest(db, cmd, commandOptions);\n        return message;\n    }\n    async *sendWire(message, options, responseType) {\n        this.throwIfAborted();\n        const timeout = options.socketTimeoutMS ??\n            options?.timeoutContext?.getSocketTimeoutMS() ??\n            this.socketTimeoutMS;\n        this.socket.setTimeout(timeout);\n        try {\n            await this.writeCommand(message, {\n                agreedCompressor: this.description.compressor ?? 'none',\n                zlibCompressionLevel: this.description.zlibCompressionLevel,\n                timeoutContext: options.timeoutContext,\n                signal: options.signal\n            });\n            if (options.noResponse || message.moreToCome) {\n                yield responses_1.MongoDBResponse.empty;\n                return;\n            }\n            this.throwIfAborted();\n            if (options.timeoutContext?.csotEnabled() &&\n                options.timeoutContext.minRoundTripTime != null &&\n                options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {\n                throw new error_1.MongoOperationTimeoutError('Server roundtrip time is greater than the time remaining');\n            }\n            for await (const response of this.readMany(options)) {\n                this.socket.setTimeout(0);\n                const bson = response.parse();\n                const document = (responseType ?? responses_1.MongoDBResponse).make(bson);\n                yield document;\n                this.throwIfAborted();\n                this.socket.setTimeout(timeout);\n            }\n        }\n        finally {\n            this.socket.setTimeout(0);\n        }\n    }\n    async *sendCommand(ns, command, options, responseType) {\n        options?.signal?.throwIfAborted();\n        const message = this.prepareCommand(ns.db, command, options);\n        let started = 0;\n        if (this.shouldEmitAndLogCommand) {\n            started = (0, utils_1.now)();\n            this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));\n        }\n        // If `documentsReturnedIn` not set or raw is not enabled, use input bson options\n        // Otherwise, support raw flag. Raw only works for cursors that hardcode firstBatch/nextBatch fields\n        const bsonOptions = options.documentsReturnedIn == null || !options.raw\n            ? options\n            : {\n                ...options,\n                raw: false,\n                fieldsAsRaw: { [options.documentsReturnedIn]: true }\n            };\n        /** MongoDBResponse instance or subclass */\n        let document = undefined;\n        /** Cached result of a toObject call */\n        let object = undefined;\n        try {\n            this.throwIfAborted();\n            for await (document of this.sendWire(message, options, responseType)) {\n                object = undefined;\n                if (options.session != null) {\n                    (0, sessions_1.updateSessionFromResponse)(options.session, document);\n                }\n                if (document.$clusterTime) {\n                    this.clusterTime = document.$clusterTime;\n                    this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n                }\n                if (document.ok === 0) {\n                    if (options.timeoutContext?.csotEnabled() && document.isMaxTimeExpiredError) {\n                        throw new error_1.MongoOperationTimeoutError('Server reported a timeout error', {\n                            cause: new error_1.MongoServerError((object ??= document.toObject(bsonOptions)))\n                        });\n                    }\n                    throw new error_1.MongoServerError((object ??= document.toObject(bsonOptions)));\n                }\n                if (this.shouldEmitAndLogCommand) {\n                    this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse\n                        ? undefined\n                        : message.moreToCome\n                            ? { ok: 1 }\n                            : (object ??= document.toObject(bsonOptions)), started, this.description.serverConnectionId));\n                }\n                if (responseType == null) {\n                    yield (object ??= document.toObject(bsonOptions));\n                }\n                else {\n                    yield document;\n                }\n                this.throwIfAborted();\n            }\n        }\n        catch (error) {\n            if (this.shouldEmitAndLogCommand) {\n                this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error, started, this.description.serverConnectionId));\n            }\n            throw error;\n        }\n    }\n    async command(ns, command, options = {}, responseType) {\n        this.throwIfAborted();\n        options.signal?.throwIfAborted();\n        for await (const document of this.sendCommand(ns, command, options, responseType)) {\n            if (options.timeoutContext?.csotEnabled()) {\n                if (responses_1.MongoDBResponse.is(document)) {\n                    if (document.isMaxTimeExpiredError) {\n                        throw new error_1.MongoOperationTimeoutError('Server reported a timeout error', {\n                            cause: new error_1.MongoServerError(document.toObject())\n                        });\n                    }\n                }\n                else {\n                    if ((Array.isArray(document?.writeErrors) &&\n                        document.writeErrors.some(error => error?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired)) ||\n                        document?.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) {\n                        throw new error_1.MongoOperationTimeoutError('Server reported a timeout error', {\n                            cause: new error_1.MongoServerError(document)\n                        });\n                    }\n                }\n            }\n            return document;\n        }\n        throw new error_1.MongoUnexpectedServerResponseError('Unable to get response from server');\n    }\n    exhaustCommand(ns, command, options, replyListener) {\n        const exhaustLoop = async () => {\n            this.throwIfAborted();\n            for await (const reply of this.sendCommand(ns, command, options)) {\n                replyListener(undefined, reply);\n                this.throwIfAborted();\n            }\n            throw new error_1.MongoUnexpectedServerResponseError('Server ended moreToCome unexpectedly');\n        };\n        exhaustLoop().then(undefined, replyListener);\n    }\n    throwIfAborted() {\n        if (this.error)\n            throw this.error;\n    }\n    /**\n     * @internal\n     *\n     * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method\n     * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).\n     */\n    async writeCommand(command, options) {\n        const finalCommand = options.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command)\n            ? command\n            : new commands_1.OpCompressedRequest(command, {\n                agreedCompressor: options.agreedCompressor ?? 'none',\n                zlibCompressionLevel: options.zlibCompressionLevel ?? 0\n            });\n        const buffer = Buffer.concat(await finalCommand.toBin());\n        if (options.timeoutContext?.csotEnabled()) {\n            if (options.timeoutContext.minRoundTripTime != null &&\n                options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {\n                throw new error_1.MongoOperationTimeoutError('Server roundtrip time is greater than the time remaining');\n            }\n        }\n        if (this.socket.write(buffer))\n            return;\n        const drainEvent = (0, utils_1.once)(this.socket, 'drain', options);\n        const timeout = options?.timeoutContext?.timeoutForSocketWrite;\n        const drained = timeout ? Promise.race([drainEvent, timeout]) : drainEvent;\n        try {\n            return await drained;\n        }\n        catch (writeError) {\n            if (timeout_1.TimeoutError.is(writeError)) {\n                const timeoutError = new error_1.MongoOperationTimeoutError('Timed out at socket write');\n                this.onError(timeoutError);\n                throw timeoutError;\n            }\n            else if (writeError === options.signal?.reason) {\n                this.onError(writeError);\n            }\n            throw writeError;\n        }\n        finally {\n            timeout?.clear();\n        }\n    }\n    /**\n     * @internal\n     *\n     * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function\n     * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request\n     * by calling `return` on the generator.\n     *\n     * Note that `for-await` loops call `return` automatically when the loop is exited.\n     */\n    async *readMany(options) {\n        try {\n            this.dataEvents = (0, on_data_1.onData)(this.messageStream, options);\n            this.messageStream.resume();\n            for await (const message of this.dataEvents) {\n                const response = await (0, compression_1.decompressResponse)(message);\n                yield response;\n                if (!response.moreToCome) {\n                    return;\n                }\n            }\n        }\n        catch (readError) {\n            if (timeout_1.TimeoutError.is(readError)) {\n                const timeoutError = new error_1.MongoOperationTimeoutError(`Timed out during socket read (${readError.duration}ms)`);\n                this.dataEvents = null;\n                this.onError(timeoutError);\n                throw timeoutError;\n            }\n            else if (readError === options.signal?.reason) {\n                this.onError(readError);\n            }\n            throw readError;\n        }\n        finally {\n            this.dataEvents = null;\n            this.messageStream.pause();\n            this.throwIfAborted();\n        }\n    }\n}\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\nclass SizedMessageTransform extends stream_1.Transform {\n    constructor({ connection }) {\n        super({ writableObjectMode: false, readableObjectMode: true });\n        this.bufferPool = new utils_1.BufferPool();\n        this.connection = connection;\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.connection.delayedTimeoutId != null) {\n            (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);\n            this.connection.delayedTimeoutId = null;\n        }\n        this.bufferPool.append(chunk);\n        while (this.bufferPool.length) {\n            // While there are any bytes in the buffer\n            // Try to fetch a size from the top 4 bytes\n            const sizeOfMessage = this.bufferPool.getInt32();\n            if (sizeOfMessage == null) {\n                // Not even an int32 worth of data. Stop the loop, we need more chunks.\n                break;\n            }\n            if (sizeOfMessage < 0) {\n                // The size in the message has a negative value, this is probably corruption, throw:\n                return callback(new error_1.MongoParseError(`Message size cannot be negative: ${sizeOfMessage}`));\n            }\n            if (sizeOfMessage > this.bufferPool.length) {\n                // We do not have enough bytes to make a sizeOfMessage chunk\n                break;\n            }\n            // Add a message to the stream\n            const message = this.bufferPool.read(sizeOfMessage);\n            if (!this.push(message)) {\n                // We only subscribe to data events so we should never get backpressure\n                // if we do, we do not have the handling for it.\n                return callback(new error_1.MongoRuntimeError(`SizedMessageTransform does not support backpressure`));\n            }\n        }\n        callback();\n    }\n}\nexports.SizedMessageTransform = SizedMessageTransform;\n/** @internal */\nclass CryptoConnection extends Connection {\n    constructor(stream, options) {\n        super(stream, options);\n        this.autoEncrypter = options.autoEncrypter;\n    }\n    async command(ns, cmd, options, responseType) {\n        const { autoEncrypter } = this;\n        if (!autoEncrypter) {\n            // TODO(NODE-6065): throw a MongoRuntimeError in Node V7\n            // @ts-expect-error No cause provided because there is no underlying error.\n            throw new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption', {\n                dependencyName: 'n/a'\n            });\n        }\n        const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n        if (serverWireVersion === 0) {\n            // This means the initial handshake hasn't happened yet\n            return await super.command(ns, cmd, options, responseType);\n        }\n        if (serverWireVersion < 8) {\n            throw new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2');\n        }\n        // Save sort or indexKeys based on the command being run\n        // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n        // and then deserializes the encrypted result, the protocol level components\n        // of the command (ex. sort) are then converted to JS objects potentially losing\n        // import key order information. These fields are never encrypted so we can save the values\n        // from before the encryption and replace them after encryption has been performed\n        const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;\n        const indexKeys = cmd.createIndexes\n            ? cmd.indexes.map((index) => index.key)\n            : null;\n        const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);\n        // Replace the saved values\n        if (sort != null && (cmd.find || cmd.findAndModify)) {\n            encrypted.sort = sort;\n        }\n        if (indexKeys != null && cmd.createIndexes) {\n            for (const [offset, index] of indexKeys.entries()) {\n                // @ts-expect-error `encrypted` is a generic \"command\", but we've narrowed for only `createIndexes` commands here\n                encrypted.indexes[offset].key = index;\n            }\n        }\n        const encryptedResponse = await super.command(ns, encrypted, options, \n        // Eventually we want to require `responseType` which means we would satisfy `T` as the return type.\n        // In the meantime, we want encryptedResponse to always be _at least_ a MongoDBResponse if not a more specific subclass\n        // So that we can ensure we have access to the on-demand APIs for decorate response\n        responseType ?? responses_1.MongoDBResponse);\n        const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options);\n        const decryptedResponse = responseType?.make(result) ?? (0, bson_1.deserialize)(result, options);\n        if (autoEncrypter[constants_1.kDecorateResult]) {\n            if (responseType == null) {\n                (0, utils_1.decorateDecryptionResult)(decryptedResponse, encryptedResponse.toObject(), true);\n            }\n            else if (decryptedResponse instanceof responses_1.CursorResponse) {\n                decryptedResponse.encryptedResponse = encryptedResponse;\n            }\n        }\n        return decryptedResponse;\n    }\n}\nexports.CryptoConnection = CryptoConnection;\n//# sourceMappingURL=connection.js.map"
        }
    ]
}