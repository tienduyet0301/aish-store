{
    "sourceFile": "node_modules/mongodb/lib/cmap/connection_pool.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892617837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectionPool = exports.PoolState = void 0;\nconst timers_1 = require(\"timers\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\nconst connect_1 = require(\"./connect\");\nconst connection_1 = require(\"./connection\");\nconst connection_pool_events_1 = require(\"./connection_pool_events\");\nconst errors_1 = require(\"./errors\");\nconst metrics_1 = require(\"./metrics\");\n/** @internal */\nexports.PoolState = Object.freeze({\n    paused: 'paused',\n    ready: 'ready',\n    closed: 'closed'\n});\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n * @internal\n */\nclass ConnectionPool extends mongo_types_1.TypedEventEmitter {\n    constructor(server, options) {\n        super();\n        this.on('error', utils_1.noop);\n        this.options = Object.freeze({\n            connectionType: connection_1.Connection,\n            ...options,\n            maxPoolSize: options.maxPoolSize ?? 100,\n            minPoolSize: options.minPoolSize ?? 0,\n            maxConnecting: options.maxConnecting ?? 2,\n            maxIdleTimeMS: options.maxIdleTimeMS ?? 0,\n            waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,\n            minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,\n            autoEncrypter: options.autoEncrypter\n        });\n        if (this.options.minPoolSize > this.options.maxPoolSize) {\n            throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');\n        }\n        this.poolState = exports.PoolState.paused;\n        this.server = server;\n        this.connections = new utils_1.List();\n        this.pending = 0;\n        this.checkedOut = new Set();\n        this.minPoolSizeTimer = undefined;\n        this.generation = 0;\n        this.serviceGenerations = new Map();\n        this.connectionCounter = (0, utils_1.makeCounter)(1);\n        this.cancellationToken = new mongo_types_1.CancellationToken();\n        this.cancellationToken.setMaxListeners(Infinity);\n        this.waitQueue = new utils_1.List();\n        this.metrics = new metrics_1.ConnectionPoolMetrics();\n        this.processingWaitQueue = false;\n        this.mongoLogger = this.server.topology.client?.mongoLogger;\n        this.component = 'connection';\n        process.nextTick(() => {\n            this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));\n        });\n    }\n    /** The address of the endpoint the pool is connected to */\n    get address() {\n        return this.options.hostAddress.toString();\n    }\n    /**\n     * Check if the pool has been closed\n     *\n     * TODO(NODE-3263): We can remove this property once shell no longer needs it\n     */\n    get closed() {\n        return this.poolState === exports.PoolState.closed;\n    }\n    /** An integer expressing how many total connections (available + pending + in use) the pool currently has */\n    get totalConnectionCount() {\n        return (this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount);\n    }\n    /** An integer expressing how many connections are currently available in the pool. */\n    get availableConnectionCount() {\n        return this.connections.length;\n    }\n    get pendingConnectionCount() {\n        return this.pending;\n    }\n    get currentCheckedOutCount() {\n        return this.checkedOut.size;\n    }\n    get waitQueueSize() {\n        return this.waitQueue.length;\n    }\n    get loadBalanced() {\n        return this.options.loadBalanced;\n    }\n    get serverError() {\n        return this.server.description.error;\n    }\n    /**\n     * This is exposed ONLY for use in mongosh, to enable\n     * killing all connections if a user quits the shell with\n     * operations in progress.\n     *\n     * This property may be removed as a part of NODE-3263.\n     */\n    get checkedOutConnections() {\n        return this.checkedOut;\n    }\n    /**\n     * Get the metrics information for the pool when a wait queue timeout occurs.\n     */\n    waitQueueErrorMetrics() {\n        return this.metrics.info(this.options.maxPoolSize);\n    }\n    /**\n     * Set the pool state to \"ready\"\n     */\n    ready() {\n        if (this.poolState !== exports.PoolState.paused) {\n            return;\n        }\n        this.poolState = exports.PoolState.ready;\n        this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));\n        (0, timers_1.clearTimeout)(this.minPoolSizeTimer);\n        this.ensureMinPoolSize();\n    }\n    /**\n     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n     * explicitly destroyed by the new owner.\n     */\n    async checkOut(options) {\n        const checkoutTime = (0, utils_1.now)();\n        this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));\n        const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();\n        const timeout = options.timeoutContext.connectionCheckoutTimeout;\n        const waitQueueMember = {\n            resolve,\n            reject,\n            cancelled: false,\n            checkoutTime\n        };\n        const abortListener = (0, utils_1.addAbortListener)(options.signal, function () {\n            waitQueueMember.cancelled = true;\n            reject(this.reason);\n        });\n        this.waitQueue.push(waitQueueMember);\n        process.nextTick(() => this.processWaitQueue());\n        try {\n            timeout?.throwIfExpired();\n            return await (timeout ? Promise.race([promise, timeout]) : promise);\n        }\n        catch (error) {\n            if (timeout_1.TimeoutError.is(error)) {\n                timeout?.clear();\n                waitQueueMember.cancelled = true;\n                this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'timeout', waitQueueMember.checkoutTime));\n                const timeoutError = new errors_1.WaitQueueTimeoutError(this.loadBalanced\n                    ? this.waitQueueErrorMetrics()\n                    : 'Timed out while checking out a connection from connection pool', this.address);\n                if (options.timeoutContext.csotEnabled()) {\n                    throw new error_1.MongoOperationTimeoutError('Timed out during connection checkout', {\n                        cause: timeoutError\n                    });\n                }\n                throw timeoutError;\n            }\n            throw error;\n        }\n        finally {\n            abortListener?.[utils_1.kDispose]();\n            timeout?.clear();\n        }\n    }\n    /**\n     * Check a connection into the pool.\n     *\n     * @param connection - The connection to check in\n     */\n    checkIn(connection) {\n        if (!this.checkedOut.has(connection)) {\n            return;\n        }\n        const poolClosed = this.closed;\n        const stale = this.connectionIsStale(connection);\n        const willDestroy = !!(poolClosed || stale || connection.closed);\n        if (!willDestroy) {\n            connection.markAvailable();\n            this.connections.unshift(connection);\n        }\n        this.checkedOut.delete(connection);\n        this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));\n        if (willDestroy) {\n            const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n            this.destroyConnection(connection, reason);\n        }\n        process.nextTick(() => this.processWaitQueue());\n    }\n    /**\n     * Clear the pool\n     *\n     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n     * previous generation will eventually be pruned during subsequent checkouts.\n     */\n    clear(options = {}) {\n        if (this.closed) {\n            return;\n        }\n        // handle load balanced case\n        if (this.loadBalanced) {\n            const { serviceId } = options;\n            if (!serviceId) {\n                throw new error_1.MongoRuntimeError('ConnectionPool.clear() called in load balanced mode with no serviceId.');\n            }\n            const sid = serviceId.toHexString();\n            const generation = this.serviceGenerations.get(sid);\n            // Only need to worry if the generation exists, since it should\n            // always be there but typescript needs the check.\n            if (generation == null) {\n                throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');\n            }\n            else {\n                // Increment the generation for the service id.\n                this.serviceGenerations.set(sid, generation + 1);\n            }\n            this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));\n            return;\n        }\n        // handle non load-balanced case\n        const interruptInUseConnections = options.interruptInUseConnections ?? false;\n        const oldGeneration = this.generation;\n        this.generation += 1;\n        const alreadyPaused = this.poolState === exports.PoolState.paused;\n        this.poolState = exports.PoolState.paused;\n        this.clearMinPoolSizeTimer();\n        if (!alreadyPaused) {\n            this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {\n                interruptInUseConnections\n            }));\n        }\n        if (interruptInUseConnections) {\n            process.nextTick(() => this.interruptInUseConnections(oldGeneration));\n        }\n        this.processWaitQueue();\n    }\n    /**\n     * Closes all stale in-use connections in the pool with a resumable PoolClearedOnNetworkError.\n     *\n     * Only connections where `connection.generation <= minGeneration` are killed.\n     */\n    interruptInUseConnections(minGeneration) {\n        for (const connection of this.checkedOut) {\n            if (connection.generation <= minGeneration) {\n                connection.onError(new errors_1.PoolClearedOnNetworkError(this));\n                this.checkIn(connection);\n            }\n        }\n    }\n    /** Close the pool */\n    close() {\n        if (this.closed) {\n            return;\n        }\n        // immediately cancel any in-flight connections\n        this.cancellationToken.emit('cancel');\n        // end the connection counter\n        if (typeof this.connectionCounter.return === 'function') {\n            this.connectionCounter.return(undefined);\n        }\n        this.poolState = exports.PoolState.closed;\n        this.clearMinPoolSizeTimer();\n        this.processWaitQueue();\n        for (const conn of this.connections) {\n            this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, 'poolClosed'));\n            conn.destroy();\n        }\n        this.connections.clear();\n        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));\n    }\n    /**\n     * @internal\n     * Reauthenticate a connection\n     */\n    async reauthenticate(connection) {\n        const authContext = connection.authContext;\n        if (!authContext) {\n            throw new error_1.MongoRuntimeError('No auth context found on connection.');\n        }\n        const credentials = authContext.credentials;\n        if (!credentials) {\n            throw new error_1.MongoMissingCredentialsError('Connection is missing credentials when asked to reauthenticate');\n        }\n        const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);\n        const provider = this.server.topology.client.s.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);\n        if (!provider) {\n            throw new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`);\n        }\n        await provider.reauth(authContext);\n        return;\n    }\n    /** Clear the min pool size timer */\n    clearMinPoolSizeTimer() {\n        const minPoolSizeTimer = this.minPoolSizeTimer;\n        if (minPoolSizeTimer) {\n            (0, timers_1.clearTimeout)(minPoolSizeTimer);\n        }\n    }\n    destroyConnection(connection, reason) {\n        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));\n        // destroy the connection\n        connection.destroy();\n    }\n    connectionIsStale(connection) {\n        const serviceId = connection.serviceId;\n        if (this.loadBalanced && serviceId) {\n            const sid = serviceId.toHexString();\n            const generation = this.serviceGenerations.get(sid);\n            return connection.generation !== generation;\n        }\n        return connection.generation !== this.generation;\n    }\n    connectionIsIdle(connection) {\n        return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);\n    }\n    /**\n     * Destroys a connection if the connection is perished.\n     *\n     * @returns `true` if the connection was destroyed, `false` otherwise.\n     */\n    destroyConnectionIfPerished(connection) {\n        const isStale = this.connectionIsStale(connection);\n        const isIdle = this.connectionIsIdle(connection);\n        if (!isStale && !isIdle && !connection.closed) {\n            return false;\n        }\n        const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n        this.destroyConnection(connection, reason);\n        return true;\n    }\n    createConnection(callback) {\n        const connectOptions = {\n            ...this.options,\n            id: this.connectionCounter.next().value,\n            generation: this.generation,\n            cancellationToken: this.cancellationToken,\n            mongoLogger: this.mongoLogger,\n            authProviders: this.server.topology.client.s.authProviders\n        };\n        this.pending++;\n        // This is our version of a \"virtual\" no-I/O connection as the spec requires\n        const connectionCreatedTime = (0, utils_1.now)();\n        this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));\n        (0, connect_1.connect)(connectOptions).then(connection => {\n            // The pool might have closed since we started trying to create a connection\n            if (this.poolState !== exports.PoolState.ready) {\n                this.pending--;\n                connection.destroy();\n                callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));\n                return;\n            }\n            // forward all events from the connection to the pool\n            for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {\n                connection.on(event, (e) => this.emit(event, e));\n            }\n            if (this.loadBalanced) {\n                connection.on(connection_1.Connection.PINNED, pinType => this.metrics.markPinned(pinType));\n                connection.on(connection_1.Connection.UNPINNED, pinType => this.metrics.markUnpinned(pinType));\n                const serviceId = connection.serviceId;\n                if (serviceId) {\n                    let generation;\n                    const sid = serviceId.toHexString();\n                    if ((generation = this.serviceGenerations.get(sid))) {\n                        connection.generation = generation;\n                    }\n                    else {\n                        this.serviceGenerations.set(sid, 0);\n                        connection.generation = 0;\n                    }\n                }\n            }\n            connection.markAvailable();\n            this.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection, connectionCreatedTime));\n            this.pending--;\n            callback(undefined, connection);\n        }, error => {\n            this.pending--;\n            this.server.handleError(error);\n            this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: undefined }, 'error', \n            // TODO(NODE-5192): Remove this cast\n            error));\n            if (error instanceof error_1.MongoNetworkError || error instanceof error_1.MongoServerError) {\n                error.connectionGeneration = connectOptions.generation;\n            }\n            callback(error ?? new error_1.MongoRuntimeError('Connection creation failed without error'));\n        });\n    }\n    ensureMinPoolSize() {\n        const minPoolSize = this.options.minPoolSize;\n        if (this.poolState !== exports.PoolState.ready || minPoolSize === 0) {\n            return;\n        }\n        this.connections.prune(connection => this.destroyConnectionIfPerished(connection));\n        if (this.totalConnectionCount < minPoolSize &&\n            this.pendingConnectionCount < this.options.maxConnecting) {\n            // NOTE: ensureMinPoolSize should not try to get all the pending\n            // connection permits because that potentially delays the availability of\n            // the connection to a checkout request\n            this.createConnection((err, connection) => {\n                if (!err && connection) {\n                    this.connections.push(connection);\n                    process.nextTick(() => this.processWaitQueue());\n                }\n                if (this.poolState === exports.PoolState.ready) {\n                    (0, timers_1.clearTimeout)(this.minPoolSizeTimer);\n                    this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);\n                }\n            });\n        }\n        else {\n            (0, timers_1.clearTimeout)(this.minPoolSizeTimer);\n            this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);\n        }\n    }\n    processWaitQueue() {\n        if (this.processingWaitQueue) {\n            return;\n        }\n        this.processingWaitQueue = true;\n        while (this.waitQueueSize) {\n            const waitQueueMember = this.waitQueue.first();\n            if (!waitQueueMember) {\n                this.waitQueue.shift();\n                continue;\n            }\n            if (waitQueueMember.cancelled) {\n                this.waitQueue.shift();\n                continue;\n            }\n            if (this.poolState !== exports.PoolState.ready) {\n                const reason = this.closed ? 'poolClosed' : 'connectionError';\n                const error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);\n                this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error));\n                this.waitQueue.shift();\n                waitQueueMember.reject(error);\n                continue;\n            }\n            if (!this.availableConnectionCount) {\n                break;\n            }\n            const connection = this.connections.shift();\n            if (!connection) {\n                break;\n            }\n            if (!this.destroyConnectionIfPerished(connection)) {\n                this.checkedOut.add(connection);\n                this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));\n                this.waitQueue.shift();\n                waitQueueMember.resolve(connection);\n            }\n        }\n        const { maxPoolSize, maxConnecting } = this.options;\n        while (this.waitQueueSize > 0 &&\n            this.pendingConnectionCount < maxConnecting &&\n            (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {\n            const waitQueueMember = this.waitQueue.shift();\n            if (!waitQueueMember || waitQueueMember.cancelled) {\n                continue;\n            }\n            this.createConnection((err, connection) => {\n                if (waitQueueMember.cancelled) {\n                    if (!err && connection) {\n                        this.connections.push(connection);\n                    }\n                }\n                else {\n                    if (err) {\n                        this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, \n                        // TODO(NODE-5192): Remove this cast\n                        new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'connectionError', waitQueueMember.checkoutTime, err));\n                        waitQueueMember.reject(err);\n                    }\n                    else if (connection) {\n                        this.checkedOut.add(connection);\n                        this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));\n                        waitQueueMember.resolve(connection);\n                    }\n                }\n                process.nextTick(() => this.processWaitQueue());\n            });\n        }\n        this.processingWaitQueue = false;\n    }\n}\nexports.ConnectionPool = ConnectionPool;\n/**\n * Emitted when the connection pool is created.\n * @event\n */\nConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;\n/**\n * Emitted once when the connection pool is closed\n * @event\n */\nConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;\n/**\n * Emitted each time the connection pool is cleared and it's generation incremented\n * @event\n */\nConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;\n/**\n * Emitted each time the connection pool is marked ready\n * @event\n */\nConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;\n/**\n * Emitted when a connection is created.\n * @event\n */\nConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;\n/**\n * Emitted when a connection becomes established, and is ready to use\n * @event\n */\nConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;\n/**\n * Emitted when a connection is closed\n * @event\n */\nConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;\n/**\n * Emitted when an attempt to check out a connection begins\n * @event\n */\nConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;\n/**\n * Emitted when an attempt to check out a connection fails\n * @event\n */\nConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;\n/**\n * Emitted each time a connection is successfully checked out of the connection pool\n * @event\n */\nConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;\n/**\n * Emitted each time a connection is successfully checked into the connection pool\n * @event\n */\nConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;\n//# sourceMappingURL=connection_pool.js.map"
        }
    ]
}