{
    "sourceFile": "node_modules/mongodb/src/cursor/run_command_cursor.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892634928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { BSONSerializeOptions, Document } from '../bson';\nimport { CursorResponse } from '../cmap/wire_protocol/responses';\nimport type { Db } from '../db';\nimport { MongoAPIError } from '../error';\nimport { executeOperation } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { RunCommandOperation } from '../operations/run_command';\nimport type { ReadConcernLike } from '../read_concern';\nimport type { ReadPreferenceLike } from '../read_preference';\nimport type { ClientSession } from '../sessions';\nimport { ns } from '../utils';\nimport {\n  AbstractCursor,\n  type CursorTimeoutMode,\n  type InitialCursorResponse\n} from './abstract_cursor';\n\n/** @public */\nexport type RunCursorCommandOptions = {\n  readPreference?: ReadPreferenceLike;\n  session?: ClientSession;\n  /**\n   * @experimental\n   * Specifies the time an operation will run until it throws a timeout error. Note that if\n   * `maxTimeMS` is provided in the command in addition to setting `timeoutMS` in the options, then\n   * the original value of `maxTimeMS` will be overwritten.\n   */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n  tailable?: boolean;\n  awaitData?: boolean;\n} & BSONSerializeOptions;\n\n/** @public */\nexport class RunCommandCursor extends AbstractCursor {\n  public readonly command: Readonly<Record<string, any>>;\n  public readonly getMoreOptions: {\n    comment?: any;\n    maxAwaitTimeMS?: number;\n    batchSize?: number;\n  } = {};\n\n  /**\n   * Controls the `getMore.comment` field\n   * @param comment - any BSON value\n   */\n  public setComment(comment: any): this {\n    this.getMoreOptions.comment = comment;\n    return this;\n  }\n\n  /**\n   * Controls the `getMore.maxTimeMS` field. Only valid when cursor is tailable await\n   * @param maxTimeMS - the number of milliseconds to wait for new data\n   */\n  public setMaxTimeMS(maxTimeMS: number): this {\n    this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;\n    return this;\n  }\n\n  /**\n   * Controls the `getMore.batchSize` field\n   * @param batchSize - the number documents to return in the `nextBatch`\n   */\n  public setBatchSize(batchSize: number): this {\n    this.getMoreOptions.batchSize = batchSize;\n    return this;\n  }\n\n  /** Unsupported for RunCommandCursor */\n  public override clone(): never {\n    throw new MongoAPIError('Clone not supported, create a new cursor with db.runCursorCommand');\n  }\n\n  /** Unsupported for RunCommandCursor: readConcern must be configured directly on command document */\n  public override withReadConcern(_: ReadConcernLike): never {\n    throw new MongoAPIError(\n      'RunCommandCursor does not support readConcern it must be attached to the command being run'\n    );\n  }\n\n  /** Unsupported for RunCommandCursor: various cursor flags must be configured directly on command document */\n  public override addCursorFlag(_: string, __: boolean): never {\n    throw new MongoAPIError(\n      'RunCommandCursor does not support cursor flags, they must be attached to the command being run'\n    );\n  }\n\n  /**\n   * Unsupported for RunCommandCursor: maxTimeMS must be configured directly on command document\n   */\n  public override maxTimeMS(_: number): never {\n    throw new MongoAPIError(\n      'maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()'\n    );\n  }\n\n  /** Unsupported for RunCommandCursor: batchSize must be configured directly on command document */\n  public override batchSize(_: number): never {\n    throw new MongoAPIError(\n      'batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()'\n    );\n  }\n\n  /** @internal */\n  private db: Db;\n\n  /** @internal */\n  constructor(db: Db, command: Document, options: RunCursorCommandOptions = {}) {\n    super(db.client, ns(db.namespace), options);\n    this.db = db;\n    this.command = Object.freeze({ ...command });\n  }\n\n  /** @internal */\n  protected async _initialize(session: ClientSession): Promise<InitialCursorResponse> {\n    const operation = new RunCommandOperation<CursorResponse>(this.db, this.command, {\n      ...this.cursorOptions,\n      session: session,\n      readPreference: this.cursorOptions.readPreference,\n      responseType: CursorResponse\n    });\n\n    const response = await executeOperation(this.client, operation, this.timeoutContext);\n\n    return {\n      server: operation.server,\n      session,\n      response\n    };\n  }\n\n  /** @internal */\n  override async getMore(_batchSize: number): Promise<CursorResponse> {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const getMoreOperation = new GetMoreOperation(this.namespace, this.id!, this.server!, {\n      ...this.cursorOptions,\n      session: this.session,\n      ...this.getMoreOptions\n    });\n\n    return await executeOperation(this.client, getMoreOperation, this.timeoutContext);\n  }\n}\n"
        }
    ]
}