{
    "sourceFile": "node_modules/mongodb/src/timeout.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892637190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { clearTimeout, setTimeout } from 'timers';\n\nimport { type Document } from './bson';\nimport { MongoInvalidArgumentError, MongoOperationTimeoutError, MongoRuntimeError } from './error';\nimport { type ClientSession } from './sessions';\nimport { csotMin, noop, squashError } from './utils';\n\n/** @internal */\nexport class TimeoutError extends Error {\n  duration: number;\n  override get name(): 'TimeoutError' {\n    return 'TimeoutError';\n  }\n\n  constructor(message: string, options: { cause?: Error; duration: number }) {\n    super(message, options);\n    this.duration = options.duration;\n  }\n\n  static is(error: unknown): error is TimeoutError {\n    return (\n      error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError'\n    );\n  }\n}\n\ntype Executor = ConstructorParameters<typeof Promise<never>>[0];\ntype Reject = Parameters<ConstructorParameters<typeof Promise<never>>[0]>[1];\n/**\n * @internal\n * This class is an abstraction over timeouts\n * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve\n * if interacted with exclusively through its public API\n * */\nexport class Timeout extends Promise<never> {\n  private id?: NodeJS.Timeout;\n\n  public readonly start: number;\n  public ended: number | null = null;\n  public duration: number;\n  private timedOut = false;\n  public cleared = false;\n\n  get remainingTime(): number {\n    if (this.timedOut) return 0;\n    if (this.duration === 0) return Infinity;\n    return this.start + this.duration - Math.trunc(performance.now());\n  }\n\n  get timeElapsed(): number {\n    return Math.trunc(performance.now()) - this.start;\n  }\n\n  /** Create a new timeout that expires in `duration` ms */\n  private constructor(\n    executor: Executor = () => null,\n    options?: { duration: number; unref?: true; rejection?: Error }\n  ) {\n    const duration = options?.duration ?? 0;\n    const unref = !!options?.unref;\n    const rejection = options?.rejection;\n\n    if (duration < 0) {\n      throw new MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');\n    }\n\n    let reject!: Reject;\n    super((_, promiseReject) => {\n      reject = promiseReject;\n\n      executor(noop, promiseReject);\n    });\n\n    this.duration = duration;\n    this.start = Math.trunc(performance.now());\n\n    if (rejection == null && this.duration > 0) {\n      this.id = setTimeout(() => {\n        this.ended = Math.trunc(performance.now());\n        this.timedOut = true;\n        reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));\n      }, this.duration);\n      if (typeof this.id.unref === 'function' && unref) {\n        // Ensure we do not keep the Node.js event loop running\n        this.id.unref();\n      }\n    } else if (rejection != null) {\n      this.ended = Math.trunc(performance.now());\n      this.timedOut = true;\n      reject(rejection);\n    }\n  }\n\n  /**\n   * Clears the underlying timeout. This method is idempotent\n   */\n  clear(): void {\n    clearTimeout(this.id);\n    this.id = undefined;\n    this.timedOut = false;\n    this.cleared = true;\n  }\n\n  throwIfExpired(): void {\n    if (this.timedOut) {\n      // This method is invoked when someone wants to throw immediately instead of await the result of this promise\n      // Since they won't be handling the rejection from the promise (because we're about to throw here)\n      // attach handling to prevent this from bubbling up to Node.js\n      this.then(undefined, squashError);\n      throw new TimeoutError('Timed out', { duration: this.duration });\n    }\n  }\n\n  public static expires(duration: number, unref?: true): Timeout {\n    return new Timeout(undefined, { duration, unref });\n  }\n\n  static override reject(rejection?: Error): Timeout {\n    return new Timeout(undefined, { duration: 0, unref: true, rejection });\n  }\n}\n\n/** @internal */\nexport type TimeoutContextOptions = (LegacyTimeoutContextOptions | CSOTTimeoutContextOptions) & {\n  session?: ClientSession;\n};\n\n/** @internal */\nexport type LegacyTimeoutContextOptions = {\n  serverSelectionTimeoutMS: number;\n  waitQueueTimeoutMS: number;\n  socketTimeoutMS?: number;\n};\n\n/** @internal */\nexport type CSOTTimeoutContextOptions = {\n  timeoutMS: number;\n  serverSelectionTimeoutMS: number;\n  socketTimeoutMS?: number;\n};\n\nfunction isLegacyTimeoutContextOptions(v: unknown): v is LegacyTimeoutContextOptions {\n  return (\n    v != null &&\n    typeof v === 'object' &&\n    'serverSelectionTimeoutMS' in v &&\n    typeof v.serverSelectionTimeoutMS === 'number' &&\n    'waitQueueTimeoutMS' in v &&\n    typeof v.waitQueueTimeoutMS === 'number'\n  );\n}\n\nfunction isCSOTTimeoutContextOptions(v: unknown): v is CSOTTimeoutContextOptions {\n  return (\n    v != null &&\n    typeof v === 'object' &&\n    'serverSelectionTimeoutMS' in v &&\n    typeof v.serverSelectionTimeoutMS === 'number' &&\n    'timeoutMS' in v &&\n    typeof v.timeoutMS === 'number'\n  );\n}\n\n/** @internal */\nexport abstract class TimeoutContext {\n  static create(options: TimeoutContextOptions): TimeoutContext {\n    if (options.session?.timeoutContext != null) return options.session?.timeoutContext;\n    if (isCSOTTimeoutContextOptions(options)) return new CSOTTimeoutContext(options);\n    else if (isLegacyTimeoutContextOptions(options)) return new LegacyTimeoutContext(options);\n    else throw new MongoRuntimeError('Unrecognized options');\n  }\n\n  abstract get maxTimeMS(): number | null;\n\n  abstract get serverSelectionTimeout(): Timeout | null;\n\n  abstract get connectionCheckoutTimeout(): Timeout | null;\n\n  abstract get clearServerSelectionTimeout(): boolean;\n\n  abstract get timeoutForSocketWrite(): Timeout | null;\n\n  abstract get timeoutForSocketRead(): Timeout | null;\n\n  abstract csotEnabled(): this is CSOTTimeoutContext;\n\n  abstract refresh(): void;\n\n  abstract clear(): void;\n\n  /** Returns a new instance of the TimeoutContext, with all timeouts refreshed and restarted. */\n  abstract refreshed(): TimeoutContext;\n\n  abstract addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void;\n\n  abstract getSocketTimeoutMS(): number | undefined;\n}\n\n/** @internal */\nexport class CSOTTimeoutContext extends TimeoutContext {\n  timeoutMS: number;\n  serverSelectionTimeoutMS: number;\n  socketTimeoutMS?: number;\n\n  clearServerSelectionTimeout: boolean;\n\n  private _serverSelectionTimeout?: Timeout | null;\n  private _connectionCheckoutTimeout?: Timeout | null;\n  public minRoundTripTime = 0;\n  public start: number;\n\n  constructor(options: CSOTTimeoutContextOptions) {\n    super();\n    this.start = Math.trunc(performance.now());\n\n    this.timeoutMS = options.timeoutMS;\n\n    this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n\n    this.socketTimeoutMS = options.socketTimeoutMS;\n\n    this.clearServerSelectionTimeout = false;\n  }\n\n  get maxTimeMS(): number {\n    return this.remainingTimeMS - this.minRoundTripTime;\n  }\n\n  get remainingTimeMS() {\n    const timePassed = Math.trunc(performance.now()) - this.start;\n    return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;\n  }\n\n  csotEnabled(): this is CSOTTimeoutContext {\n    return true;\n  }\n\n  get serverSelectionTimeout(): Timeout | null {\n    // check for undefined\n    if (typeof this._serverSelectionTimeout !== 'object' || this._serverSelectionTimeout?.cleared) {\n      const { remainingTimeMS, serverSelectionTimeoutMS } = this;\n      if (remainingTimeMS <= 0)\n        return Timeout.reject(\n          new MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`)\n        );\n      const usingServerSelectionTimeoutMS =\n        serverSelectionTimeoutMS !== 0 &&\n        csotMin(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;\n      if (usingServerSelectionTimeoutMS) {\n        this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);\n      } else {\n        if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {\n          this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);\n        } else {\n          this._serverSelectionTimeout = null;\n        }\n      }\n    }\n\n    return this._serverSelectionTimeout;\n  }\n\n  get connectionCheckoutTimeout(): Timeout | null {\n    if (\n      typeof this._connectionCheckoutTimeout !== 'object' ||\n      this._connectionCheckoutTimeout?.cleared\n    ) {\n      if (typeof this._serverSelectionTimeout === 'object') {\n        // null or Timeout\n        this._connectionCheckoutTimeout = this._serverSelectionTimeout;\n      } else {\n        throw new MongoRuntimeError(\n          'Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira'\n        );\n      }\n    }\n    return this._connectionCheckoutTimeout;\n  }\n\n  get timeoutForSocketWrite(): Timeout | null {\n    const { remainingTimeMS } = this;\n    if (!Number.isFinite(remainingTimeMS)) return null;\n    if (remainingTimeMS > 0) return Timeout.expires(remainingTimeMS);\n    return Timeout.reject(new MongoOperationTimeoutError('Timed out before socket write'));\n  }\n\n  get timeoutForSocketRead(): Timeout | null {\n    const { remainingTimeMS } = this;\n    if (!Number.isFinite(remainingTimeMS)) return null;\n    if (remainingTimeMS > 0) return Timeout.expires(remainingTimeMS);\n    return Timeout.reject(new MongoOperationTimeoutError('Timed out before socket read'));\n  }\n\n  refresh(): void {\n    this.start = Math.trunc(performance.now());\n    this.minRoundTripTime = 0;\n    this._serverSelectionTimeout?.clear();\n    this._connectionCheckoutTimeout?.clear();\n  }\n\n  clear(): void {\n    this._serverSelectionTimeout?.clear();\n    this._connectionCheckoutTimeout?.clear();\n  }\n\n  /**\n   * @internal\n   * Throws a MongoOperationTimeoutError if the context has expired.\n   * If the context has not expired, returns the `remainingTimeMS`\n   **/\n  getRemainingTimeMSOrThrow(message?: string): number {\n    const { remainingTimeMS } = this;\n    if (remainingTimeMS <= 0)\n      throw new MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);\n    return remainingTimeMS;\n  }\n\n  /**\n   * @internal\n   * This method is intended to be used in situations where concurrent operation are on the same deadline, but cannot share a single `TimeoutContext` instance.\n   * Returns a new instance of `CSOTTimeoutContext` constructed with identical options, but setting the `start` property to `this.start`.\n   */\n  clone(): CSOTTimeoutContext {\n    const timeoutContext = new CSOTTimeoutContext({\n      timeoutMS: this.timeoutMS,\n      serverSelectionTimeoutMS: this.serverSelectionTimeoutMS\n    });\n    timeoutContext.start = this.start;\n    return timeoutContext;\n  }\n\n  override refreshed(): CSOTTimeoutContext {\n    return new CSOTTimeoutContext(this);\n  }\n\n  override addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void {\n    if (options.omitMaxTimeMS) return;\n    const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;\n    if (maxTimeMS > 0 && Number.isFinite(maxTimeMS)) command.maxTimeMS = maxTimeMS;\n  }\n\n  override getSocketTimeoutMS(): number | undefined {\n    return 0;\n  }\n}\n\n/** @internal */\nexport class LegacyTimeoutContext extends TimeoutContext {\n  options: LegacyTimeoutContextOptions;\n  clearServerSelectionTimeout: boolean;\n\n  constructor(options: LegacyTimeoutContextOptions) {\n    super();\n    this.options = options;\n    this.clearServerSelectionTimeout = true;\n  }\n\n  csotEnabled(): this is CSOTTimeoutContext {\n    return false;\n  }\n\n  get serverSelectionTimeout(): Timeout | null {\n    if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)\n      return Timeout.expires(this.options.serverSelectionTimeoutMS);\n    return null;\n  }\n\n  get connectionCheckoutTimeout(): Timeout | null {\n    if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)\n      return Timeout.expires(this.options.waitQueueTimeoutMS);\n    return null;\n  }\n\n  get timeoutForSocketWrite(): Timeout | null {\n    return null;\n  }\n\n  get timeoutForSocketRead(): Timeout | null {\n    return null;\n  }\n\n  refresh(): void {\n    return;\n  }\n\n  clear(): void {\n    return;\n  }\n\n  get maxTimeMS() {\n    return null;\n  }\n\n  override refreshed(): LegacyTimeoutContext {\n    return new LegacyTimeoutContext(this.options);\n  }\n\n  override addMaxTimeMSToCommand(_command: Document, _options: { omitMaxTimeMS?: boolean }): void {\n    // No max timeMS is added to commands in legacy timeout mode.\n  }\n\n  override getSocketTimeoutMS(): number | undefined {\n    return this.options.socketTimeoutMS;\n  }\n}\n"
        }
    ]
}