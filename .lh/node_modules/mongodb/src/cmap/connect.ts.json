{
    "sourceFile": "node_modules/mongodb/src/cmap/connect.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892634048,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { Socket, SocketConnectOpts } from 'net';\nimport * as net from 'net';\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\nimport * as tls from 'tls';\n\nimport type { Document } from '../bson';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport { getSocks, type SocksLib } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoError,\n  MongoErrorLabel,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  needsRetryableWriteLabel\n} from '../error';\nimport { HostAddress, ns, promiseWithResolvers } from '../utils';\nimport { AuthContext } from './auth/auth_provider';\nimport { AuthMechanism } from './auth/providers';\nimport {\n  type CommandOptions,\n  Connection,\n  type ConnectionOptions,\n  CryptoConnection\n} from './connection';\nimport {\n  MAX_SUPPORTED_SERVER_VERSION,\n  MAX_SUPPORTED_WIRE_VERSION,\n  MIN_SUPPORTED_SERVER_VERSION,\n  MIN_SUPPORTED_WIRE_VERSION\n} from './wire_protocol/constants';\n\n/** @public */\nexport type Stream = Socket | TLSSocket;\n\nexport async function connect(options: ConnectionOptions): Promise<Connection> {\n  let connection: Connection | null = null;\n  try {\n    const socket = await makeSocket(options);\n    connection = makeConnection(options, socket);\n    await performInitialHandshake(connection, options);\n    return connection;\n  } catch (error) {\n    connection?.destroy();\n    throw error;\n  }\n}\n\nexport function makeConnection(options: ConnectionOptions, socket: Stream): Connection {\n  let ConnectionType = options.connectionType ?? Connection;\n  if (options.autoEncrypter) {\n    ConnectionType = CryptoConnection;\n  }\n\n  return new ConnectionType(socket, options);\n}\n\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\n  const maxWireVersion = Number(hello.maxWireVersion);\n  const minWireVersion = Number(hello.minWireVersion);\n  const serverVersionHighEnough =\n    !Number.isNaN(maxWireVersion) && maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    !Number.isNaN(minWireVersion) && minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\n      hello.minWireVersion\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\n    JSON.stringify(hello.maxWireVersion) ?? 0\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoCompatibilityError(message);\n}\n\nexport async function performInitialHandshake(\n  conn: Connection,\n  options: ConnectionOptions\n): Promise<void> {\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\n      !options.authProviders.getOrCreateProvider(\n        credentials.mechanism,\n        credentials.mechanismProperties\n      )\n    ) {\n      throw new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  conn.authContext = authContext;\n\n  const handshakeDoc = await prepareHandshakeDocument(authContext);\n\n  // @ts-expect-error: TODO(NODE-5141): The options need to be filtered properly, Connection options differ from Command options\n  const handshakeOptions: CommandOptions = { ...options, raw: false };\n  if (typeof options.connectTimeoutMS === 'number') {\n    // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n    handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n  }\n\n  const start = new Date().getTime();\n\n  const response = await executeHandshake(handshakeDoc, handshakeOptions);\n\n  if (!('isWritablePrimary' in response)) {\n    // Provide hello-style response document.\n    response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\n  }\n\n  if (response.helloOk) {\n    conn.helloOk = true;\n  }\n\n  const supportedServerErr = checkSupportedServer(response, options);\n  if (supportedServerErr) {\n    throw supportedServerErr;\n  }\n\n  if (options.loadBalanced) {\n    if (!response.serviceId) {\n      throw new MongoCompatibilityError(\n        'Driver attempted to initialize in load balancing mode, ' +\n          'but the server does not support this mode.'\n      );\n    }\n  }\n\n  // NOTE: This is metadata attached to the connection while porting away from\n  //       handshake being done in the `Server` class. Likely, it should be\n  //       relocated, or at very least restructured.\n  conn.hello = response;\n  conn.lastHelloMS = new Date().getTime() - start;\n\n  if (!response.arbiterOnly && credentials) {\n    // store the response on auth context\n    authContext.response = response;\n\n    const resolvedCredentials = credentials.resolveAuthMechanism(response);\n    const provider = options.authProviders.getOrCreateProvider(\n      resolvedCredentials.mechanism,\n      resolvedCredentials.mechanismProperties\n    );\n    if (!provider) {\n      throw new MongoInvalidArgumentError(\n        `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\n      );\n    }\n\n    try {\n      await provider.auth(authContext);\n    } catch (error) {\n      if (error instanceof MongoError) {\n        error.addErrorLabel(MongoErrorLabel.HandshakeError);\n        if (needsRetryableWriteLabel(error, response.maxWireVersion, conn.description.type)) {\n          error.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n        }\n      }\n      throw error;\n    }\n  }\n\n  // Connection establishment is socket creation (tcp handshake, tls handshake, MongoDB handshake (saslStart, saslContinue))\n  // Once connection is established, command logging can log events (if enabled)\n  conn.established = true;\n\n  async function executeHandshake(handshakeDoc: Document, handshakeOptions: CommandOptions) {\n    try {\n      const handshakeResponse = await conn.command(\n        ns('admin.$cmd'),\n        handshakeDoc,\n        handshakeOptions\n      );\n      return handshakeResponse;\n    } catch (error) {\n      if (error instanceof MongoError) {\n        error.addErrorLabel(MongoErrorLabel.HandshakeError);\n      }\n      throw error;\n    }\n  }\n}\n\n/**\n * HandshakeDocument used during authentication.\n * @internal\n */\nexport interface HandshakeDocument extends Document {\n  /**\n   * @deprecated Use hello instead\n   */\n  ismaster?: boolean;\n  hello?: boolean;\n  helloOk?: boolean;\n  client: Document;\n  compression: string[];\n  saslSupportedMechs?: string;\n  loadBalanced?: boolean;\n}\n\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nexport async function prepareHandshakeDocument(\n  authContext: AuthContext\n): Promise<HandshakeDocument> {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const { serverApi } = authContext.connection;\n  const clientMetadata: Document = await options.extendedMetadata;\n\n  const handshakeDoc: HandshakeDocument = {\n    [serverApi?.version || options.loadBalanced === true ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: clientMetadata,\n    compression: compressors\n  };\n\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n\n      const provider = authContext.options.authProviders.getOrCreateProvider(\n        AuthMechanism.MONGODB_SCRAM_SHA256,\n        credentials.mechanismProperties\n      );\n      if (!provider) {\n        // This auth mechanism is always present.\n        throw new MongoInvalidArgumentError(\n          `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\n        );\n      }\n      return await provider.prepare(handshakeDoc, authContext);\n    }\n    const provider = authContext.options.authProviders.getOrCreateProvider(\n      credentials.mechanism,\n      credentials.mechanismProperties\n    );\n    if (!provider) {\n      throw new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);\n    }\n    return await provider.prepare(handshakeDoc, authContext);\n  }\n  return handshakeDoc;\n}\n\n/** @public */\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\n  'allowPartialTrustChain',\n  'ALPNProtocols',\n  'ca',\n  'cert',\n  'checkServerIdentity',\n  'ciphers',\n  'crl',\n  'ecdhCurve',\n  'key',\n  'minDHSize',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureContext',\n  'secureProtocol',\n  'servername',\n  'session'\n] as const;\n\n/** @public */\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\n  'autoSelectFamily',\n  'autoSelectFamilyAttemptTimeout',\n  'family',\n  'hints',\n  'localAddress',\n  'localPort',\n  'lookup'\n] as const;\n\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\n\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result as net.IpcNetConnectOpts;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result as net.TcpNetConnectOpts;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\n\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\n  const result: TLSConnectionOpts = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nexport async function makeSocket(options: MakeConnectionOptions): Promise<Stream> {\n  const useTLS = options.tls ?? false;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const existingSocket = options.existingSocket;\n\n  let socket: Stream;\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return await makeSocks5Connection({\n      ...options,\n      connectTimeoutMS // Should always be present for Socks5\n    });\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(true, 300000);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n\n  let cancellationHandler: ((err: Error) => void) | null = null;\n\n  const { promise: connectedSocket, resolve, reject } = promiseWithResolvers<Stream>();\n  if (existingSocket) {\n    resolve(socket);\n  } else {\n    const start = performance.now();\n    const connectEvent = useTLS ? 'secureConnect' : 'connect';\n    socket\n      .once(connectEvent, () => resolve(socket))\n      .once('error', cause =>\n        reject(new MongoNetworkError(MongoError.buildErrorMessage(cause), { cause }))\n      )\n      .once('timeout', () => {\n        reject(\n          new MongoNetworkTimeoutError(\n            `Socket '${connectEvent}' timed out after ${(performance.now() - start) | 0}ms (connectTimeoutMS: ${connectTimeoutMS})`\n          )\n        );\n      })\n      .once('close', () =>\n        reject(\n          new MongoNetworkError(\n            `Socket closed after ${(performance.now() - start) | 0} during connection establishment`\n          )\n        )\n      );\n\n    if (options.cancellationToken != null) {\n      cancellationHandler = () =>\n        reject(\n          new MongoNetworkError(\n            `Socket connection establishment was cancelled after ${(performance.now() - start) | 0}`\n          )\n        );\n      options.cancellationToken.once('cancel', cancellationHandler);\n    }\n  }\n\n  try {\n    socket = await connectedSocket;\n    return socket;\n  } catch (error) {\n    socket.destroy();\n    throw error;\n  } finally {\n    socket.setTimeout(0);\n    if (cancellationHandler != null) {\n      options.cancellationToken?.removeListener('cancel', cancellationHandler);\n    }\n  }\n}\n\nlet socks: SocksLib | null = null;\nfunction loadSocks() {\n  if (socks == null) {\n    const socksImport = getSocks();\n    if ('kModuleError' in socksImport) {\n      throw socksImport.kModuleError;\n    }\n    socks = socksImport;\n  }\n  return socks;\n}\n\nasync function makeSocks5Connection(options: MakeConnectionOptions): Promise<Stream> {\n  const hostAddress = HostAddress.fromHostPort(\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\n    options.proxyPort ?? 1080\n  );\n\n  // First, connect to the proxy server itself:\n  const rawSocket = await makeSocket({\n    ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  });\n\n  const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\n  if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n    throw new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts');\n  }\n\n  socks ??= loadSocks();\n\n  let existingSocket: Stream;\n\n  try {\n    // Then, establish the Socks5 proxy connection:\n    const connection = await socks.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    });\n    existingSocket = connection.socket;\n  } catch (cause) {\n    throw new MongoNetworkError(MongoError.buildErrorMessage(cause), { cause });\n  }\n\n  // Finally, now treat the resulting duplex stream as the\n  // socket over which we send and receive wire protocol messages:\n  return await makeSocket({ ...options, existingSocket, proxyHost: undefined });\n}\n"
        }
    ]
}