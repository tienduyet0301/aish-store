{
    "sourceFile": "node_modules/mongodb/src/cmap/auth/gssapi.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892633325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as dns from 'dns';\n\nimport { getKerberos, type Kerberos, type KerberosClient } from '../../deps';\nimport { MongoInvalidArgumentError, MongoMissingCredentialsError } from '../../error';\nimport { ns } from '../../utils';\nimport type { Connection } from '../connection';\nimport { type AuthContext, AuthProvider } from './auth_provider';\n\n/** @public */\nexport const GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n} as const);\n\n/** @public */\nexport type GSSAPICanonicalizationValue =\n  (typeof GSSAPICanonicalizationValue)[keyof typeof GSSAPICanonicalizationValue];\n\ntype MechanismProperties = {\n  CANONICALIZE_HOST_NAME?: GSSAPICanonicalizationValue;\n  SERVICE_HOST?: string;\n  SERVICE_NAME?: string;\n  SERVICE_REALM?: string;\n};\n\nasync function externalCommand(\n  connection: Connection,\n  command: ReturnType<typeof saslStart> | ReturnType<typeof saslContinue>\n): Promise<{ payload: string; conversationId: number }> {\n  const response = await connection.command(ns('$external.$cmd'), command);\n  return response as { payload: string; conversationId: number };\n}\n\nlet krb: Kerberos;\n\nexport class GSSAPI extends AuthProvider {\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection, credentials } = authContext;\n    if (credentials == null) {\n      throw new MongoMissingCredentialsError('Credentials required for GSSAPI authentication');\n    }\n\n    const { username } = credentials;\n\n    const client = await makeKerberosClient(authContext);\n\n    const payload = await client.step('');\n\n    const saslStartResponse = await externalCommand(connection, saslStart(payload));\n\n    const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);\n\n    const saslContinueResponse = await externalCommand(\n      connection,\n      saslContinue(negotiatedPayload, saslStartResponse.conversationId)\n    );\n\n    const finalizePayload = await finalize(client, username, saslContinueResponse.payload);\n\n    await externalCommand(connection, {\n      saslContinue: 1,\n      conversationId: saslContinueResponse.conversationId,\n      payload: finalizePayload\n    });\n  }\n}\n\nasync function makeKerberosClient(authContext: AuthContext): Promise<KerberosClient> {\n  const { hostAddress } = authContext.options;\n  const { credentials } = authContext;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    throw new MongoInvalidArgumentError(\n      'Connection must have host and port and credentials defined.'\n    );\n  }\n\n  loadKrb();\n  if ('kModuleError' in krb) {\n    throw krb['kModuleError'];\n  }\n  const { initializeClient } = krb;\n\n  const { username, password } = credentials;\n  const mechanismProperties = credentials.mechanismProperties as MechanismProperties;\n\n  const serviceName = mechanismProperties.SERVICE_NAME ?? 'mongodb';\n\n  const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);\n\n  const initOptions = {};\n  if (password != null) {\n    // TODO(NODE-5139): These do not match the typescript options in initializeClient\n    Object.assign(initOptions, { user: username, password: password });\n  }\n\n  const spnHost = mechanismProperties.SERVICE_HOST ?? host;\n  let spn = `${serviceName}${process.platform === 'win32' ? '/' : '@'}${spnHost}`;\n  if ('SERVICE_REALM' in mechanismProperties) {\n    spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;\n  }\n\n  return await initializeClient(spn, initOptions);\n}\n\nfunction saslStart(payload: string) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload,\n    autoAuthorize: 1\n  } as const;\n}\n\nfunction saslContinue(payload: string, conversationId: number) {\n  return {\n    saslContinue: 1,\n    conversationId,\n    payload\n  } as const;\n}\n\nasync function negotiate(\n  client: KerberosClient,\n  retries: number,\n  payload: string\n): Promise<string> {\n  try {\n    const response = await client.step(payload);\n    return response || '';\n  } catch (error) {\n    if (retries === 0) {\n      // Retries exhausted, raise error\n      throw error;\n    }\n    // Adjust number of retries and call step again\n    return await negotiate(client, retries - 1, payload);\n  }\n}\n\nasync function finalize(client: KerberosClient, user: string, payload: string): Promise<string> {\n  // GSS Client Unwrap\n  const response = await client.unwrap(payload);\n  return await client.wrap(response || '', { user });\n}\n\nexport async function performGSSAPICanonicalizeHostName(\n  host: string,\n  mechanismProperties: MechanismProperties\n): Promise<string> {\n  const mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === GSSAPICanonicalizationValue.none) {\n    return host;\n  }\n\n  // If forward and reverse or true\n  if (\n    mode === GSSAPICanonicalizationValue.on ||\n    mode === GSSAPICanonicalizationValue.forwardAndReverse\n  ) {\n    // Perform the lookup of the ip address.\n    const { address } = await dns.promises.lookup(host);\n\n    try {\n      // Perform a reverse ptr lookup on the ip address.\n      const results = await dns.promises.resolvePtr(address);\n      // If the ptr did not error but had no results, return the host.\n      return results.length > 0 ? results[0] : host;\n    } catch {\n      // This can error as ptr records may not exist for all ips. In this case\n      // fallback to a cname lookup as dns.lookup() does not return the\n      // cname.\n      return await resolveCname(host);\n    }\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    return await resolveCname(host);\n  }\n}\n\nexport async function resolveCname(host: string): Promise<string> {\n  // Attempt to resolve the host name\n  try {\n    const results = await dns.promises.resolveCname(host);\n    // Get the first resolved host id\n    return results.length > 0 ? results[0] : host;\n  } catch {\n    return host;\n  }\n}\n\n/**\n * Load the Kerberos library.\n */\nfunction loadKrb() {\n  if (!krb) {\n    krb = getKerberos();\n  }\n}\n"
        }
    ]
}