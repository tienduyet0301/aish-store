{
    "sourceFile": "node_modules/mongodb/src/cmap/auth/mongodb_oidc/human_callback_workflow.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892633583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { BSON } from '../../../bson';\nimport { MONGODB_ERROR_CODES, MongoError, MongoOIDCError } from '../../../error';\nimport { Timeout, TimeoutError } from '../../../timeout';\nimport { type Connection } from '../../connection';\nimport { type MongoCredentials } from '../mongo_credentials';\nimport {\n  type IdPInfo,\n  OIDC_VERSION,\n  type OIDCCallbackFunction,\n  type OIDCCallbackParams,\n  type OIDCResponse\n} from '../mongodb_oidc';\nimport { CallbackWorkflow, HUMAN_TIMEOUT_MS } from './callback_workflow';\nimport { type TokenCache } from './token_cache';\n\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nexport class HumanCallbackWorkflow extends CallbackWorkflow {\n  /**\n   * Instantiate the human callback workflow.\n   */\n  constructor(cache: TokenCache, callback: OIDCCallbackFunction) {\n    super(cache, callback);\n  }\n\n  /**\n   * Execute the OIDC human callback workflow.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    // Check if the Client Cache has an access token.\n    // If it does, cache the access token in the Connection Cache and perform a One-Step SASL conversation\n    // using the access token. If the server returns an Authentication error (18),\n    // invalidate the access token token from the Client Cache, clear the Connection Cache,\n    // and restart the authentication flow. Raise any other errors to the user. On success, exit the algorithm.\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      connection.accessToken = token;\n      try {\n        return await this.finishAuthentication(connection, credentials, token);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeAccessToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    // Check if the Client Cache has a refresh token.\n    // If it does, call the OIDC Human Callback with the cached refresh token and IdpInfo to get a\n    // new access token. Cache the new access token in the Client Cache and Connection Cache.\n    // Perform a One-Step SASL conversation using the new access token. If the the server returns\n    // an Authentication error (18), clear the refresh token, invalidate the access token from the\n    // Client Cache, clear the Connection Cache, and restart the authentication flow. Raise any other\n    // errors to the user. On success, exit the algorithm.\n    if (this.cache.hasRefreshToken) {\n      const refreshToken = this.cache.getRefreshToken();\n      const result = await this.fetchAccessToken(\n        this.cache.getIdpInfo(),\n        credentials,\n        refreshToken\n      );\n      this.cache.put(result);\n      connection.accessToken = result.accessToken;\n      try {\n        return await this.finishAuthentication(connection, credentials, result.accessToken);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeRefreshToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    // Start a new Two-Step SASL conversation.\n    // Run a PrincipalStepRequest to get the IdpInfo.\n    // Call the OIDC Human Callback with the new IdpInfo to get a new access token and optional refresh\n    // token. Drivers MUST NOT pass a cached refresh token to the callback when performing\n    // a new Two-Step conversation. Cache the new IdpInfo and refresh token in the Client Cache and the\n    // new access token in the Client Cache and Connection Cache.\n    // Attempt to authenticate using a JwtStepRequest with the new access token. Raise any errors to the user.\n    const startResponse = await this.startAuthentication(connection, credentials);\n    const conversationId = startResponse.conversationId;\n    const idpInfo = BSON.deserialize(startResponse.payload.buffer) as IdPInfo;\n    const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);\n    this.cache.put(callbackResponse, idpInfo);\n    connection.accessToken = callbackResponse.accessToken;\n    return await this.finishAuthentication(\n      connection,\n      credentials,\n      callbackResponse.accessToken,\n      conversationId\n    );\n  }\n\n  /**\n   * Fetches an access token using the callback.\n   */\n  private async fetchAccessToken(\n    idpInfo: IdPInfo,\n    credentials: MongoCredentials,\n    refreshToken?: string\n  ): Promise<OIDCResponse> {\n    const controller = new AbortController();\n    const params: OIDCCallbackParams = {\n      timeoutContext: controller.signal,\n      version: OIDC_VERSION,\n      idpInfo: idpInfo\n    };\n    if (credentials.username) {\n      params.username = credentials.username;\n    }\n    if (refreshToken) {\n      params.refreshToken = refreshToken;\n    }\n    const timeout = Timeout.expires(HUMAN_TIMEOUT_MS);\n    try {\n      return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        controller.abort();\n        throw new MongoOIDCError(`OIDC callback timed out after ${HUMAN_TIMEOUT_MS}ms.`);\n      }\n      throw error;\n    } finally {\n      timeout.clear();\n    }\n  }\n}\n"
        }
    ]
}