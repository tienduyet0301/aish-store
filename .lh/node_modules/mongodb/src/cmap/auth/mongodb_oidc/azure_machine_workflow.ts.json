{
    "sourceFile": "node_modules/mongodb/src/cmap/auth/mongodb_oidc/azure_machine_workflow.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892633439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { addAzureParams, AZURE_BASE_URL } from '../../../client-side-encryption/providers/azure';\nimport { MongoAzureError } from '../../../error';\nimport { get } from '../../../utils';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport { type AccessToken, MachineWorkflow } from './machine_workflow';\nimport { type TokenCache } from './token_cache';\n\n/** Azure request headers. */\nconst AZURE_HEADERS = Object.freeze({ Metadata: 'true', Accept: 'application/json' });\n\n/** Invalid endpoint result error. */\nconst ENDPOINT_RESULT_ERROR =\n  'Azure endpoint did not return a value with only access_token and expires_in properties';\n\n/** Error for when the token audience is missing in the environment. */\nconst TOKEN_RESOURCE_MISSING_ERROR =\n  'TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.';\n\n/**\n * Device workflow implementation for Azure.\n *\n * @internal\n */\nexport class AzureMachineWorkflow extends MachineWorkflow {\n  /**\n   * Instantiate the machine workflow.\n   */\n  constructor(cache: TokenCache) {\n    super(cache);\n  }\n\n  /**\n   * Get the token from the environment.\n   */\n  async getToken(credentials?: MongoCredentials): Promise<AccessToken> {\n    const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;\n    const username = credentials?.username;\n    if (!tokenAudience) {\n      throw new MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);\n    }\n    const response = await getAzureTokenData(tokenAudience, username);\n    if (!isEndpointResultValid(response)) {\n      throw new MongoAzureError(ENDPOINT_RESULT_ERROR);\n    }\n    return response;\n  }\n}\n\n/**\n * Hit the Azure endpoint to get the token data.\n */\nasync function getAzureTokenData(tokenAudience: string, username?: string): Promise<AccessToken> {\n  const url = new URL(AZURE_BASE_URL);\n  addAzureParams(url, tokenAudience, username);\n  const response = await get(url, {\n    headers: AZURE_HEADERS\n  });\n  if (response.status !== 200) {\n    throw new MongoAzureError(\n      `Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`\n    );\n  }\n  const result = JSON.parse(response.body);\n  return {\n    access_token: result.access_token,\n    expires_in: Number(result.expires_in)\n  };\n}\n\n/**\n * Determines if a result returned from the endpoint is valid.\n * This means the result is not nullish, contains the access_token required field\n * and the expires_in required field.\n */\nfunction isEndpointResultValid(\n  token: unknown\n): token is { access_token: unknown; expires_in: unknown } {\n  if (token == null || typeof token !== 'object') return false;\n  return (\n    'access_token' in token &&\n    typeof token.access_token === 'string' &&\n    'expires_in' in token &&\n    typeof token.expires_in === 'number'\n  );\n}\n"
        }
    ]
}