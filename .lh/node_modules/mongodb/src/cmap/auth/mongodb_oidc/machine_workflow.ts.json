{
    "sourceFile": "node_modules/mongodb/src/cmap/auth/mongodb_oidc/machine_workflow.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892633670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { setTimeout } from 'timers/promises';\n\nimport { type Document } from '../../../bson';\nimport { ns } from '../../../utils';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type { Workflow } from '../mongodb_oidc';\nimport { finishCommandDocument } from './command_builders';\nimport { type TokenCache } from './token_cache';\n\n/** The time to throttle callback calls. */\nconst THROTTLE_MS = 100;\n\n/**\n * The access token format.\n * @internal\n */\nexport interface AccessToken {\n  access_token: string;\n  expires_in?: number;\n}\n\n/** @internal */\nexport type OIDCTokenFunction = (credentials: MongoCredentials) => Promise<AccessToken>;\n\n/**\n * Common behaviour for OIDC machine workflows.\n * @internal\n */\nexport abstract class MachineWorkflow implements Workflow {\n  cache: TokenCache;\n  callback: OIDCTokenFunction;\n  lastExecutionTime: number;\n\n  /**\n   * Instantiate the machine workflow.\n   */\n  constructor(cache: TokenCache) {\n    this.cache = cache;\n    this.callback = this.withLock(this.getToken.bind(this));\n    this.lastExecutionTime = Date.now() - THROTTLE_MS;\n  }\n\n  /**\n   * Execute the workflow. Gets the token from the subclass implementation.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n    const command = finishCommandDocument(token);\n    await connection.command(ns(credentials.source), command, undefined);\n  }\n\n  /**\n   * Reauthenticate on a machine workflow just grabs the token again since the server\n   * has said the current access token is invalid or expired.\n   */\n  async reauthenticate(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    if (this.cache.hasAccessToken) {\n      // Reauthentication implies the token has expired.\n      if (connection.accessToken === this.cache.getAccessToken()) {\n        // If connection's access token is the same as the cache's, remove\n        // the token from the cache and connection.\n        this.cache.removeAccessToken();\n        delete connection.accessToken;\n      } else {\n        // If the connection's access token is different from the cache's, set\n        // the cache's token on the connection and do not remove from the\n        // cache.\n        connection.accessToken = this.cache.getAccessToken();\n      }\n    }\n    await this.execute(connection, credentials);\n  }\n\n  /**\n   * Get the document to add for speculative authentication.\n   */\n  async speculativeAuth(connection: Connection, credentials: MongoCredentials): Promise<Document> {\n    // The spec states only cached access tokens can use speculative auth.\n    if (!this.cache.hasAccessToken) {\n      return {};\n    }\n    const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n    const document = finishCommandDocument(token);\n    document.db = credentials.source;\n    return { speculativeAuthenticate: document };\n  }\n\n  /**\n   * Get the token from the cache or environment.\n   */\n  private async getTokenFromCacheOrEnv(\n    connection: Connection,\n    credentials: MongoCredentials\n  ): Promise<string> {\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      // New connections won't have an access token so ensure we set here.\n      if (!connection.accessToken) {\n        connection.accessToken = token;\n      }\n      return token;\n    } else {\n      const token = await this.callback(credentials);\n      this.cache.put({ accessToken: token.access_token, expiresInSeconds: token.expires_in });\n      // Put the access token on the connection as well.\n      connection.accessToken = token.access_token;\n      return token.access_token;\n    }\n  }\n\n  /**\n   * Ensure the callback is only executed one at a time, and throttled to\n   * only once per 100ms.\n   */\n  private withLock(callback: OIDCTokenFunction): OIDCTokenFunction {\n    let lock: Promise<any> = Promise.resolve();\n    return async (credentials: MongoCredentials): Promise<AccessToken> => {\n      // We do this to ensure that we would never return the result of the\n      // previous lock, only the current callback's value would get returned.\n      await lock;\n      lock = lock\n\n        .catch(() => null)\n\n        .then(async () => {\n          const difference = Date.now() - this.lastExecutionTime;\n          if (difference <= THROTTLE_MS) {\n            await setTimeout(THROTTLE_MS - difference);\n          }\n          this.lastExecutionTime = Date.now();\n          return await callback(credentials);\n        });\n      return await lock;\n    };\n  }\n\n  /**\n   * Get the token from the environment or endpoint.\n   */\n  abstract getToken(credentials: MongoCredentials): Promise<AccessToken>;\n}\n"
        }
    ]
}