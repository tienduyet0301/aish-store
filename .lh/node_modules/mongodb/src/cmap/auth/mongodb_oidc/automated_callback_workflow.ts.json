{
    "sourceFile": "node_modules/mongodb/src/cmap/auth/mongodb_oidc/automated_callback_workflow.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892633409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { MONGODB_ERROR_CODES, MongoError, MongoOIDCError } from '../../../error';\nimport { Timeout, TimeoutError } from '../../../timeout';\nimport { type Connection } from '../../connection';\nimport { type MongoCredentials } from '../mongo_credentials';\nimport {\n  OIDC_VERSION,\n  type OIDCCallbackFunction,\n  type OIDCCallbackParams,\n  type OIDCResponse\n} from '../mongodb_oidc';\nimport { AUTOMATED_TIMEOUT_MS, CallbackWorkflow } from './callback_workflow';\nimport { type TokenCache } from './token_cache';\n\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nexport class AutomatedCallbackWorkflow extends CallbackWorkflow {\n  /**\n   * Instantiate the human callback workflow.\n   */\n  constructor(cache: TokenCache, callback: OIDCCallbackFunction) {\n    super(cache, callback);\n  }\n\n  /**\n   * Execute the OIDC callback workflow.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    // If there is a cached access token, try to authenticate with it. If\n    // authentication fails with an Authentication error (18),\n    // invalidate the access token, fetch a new access token, and try\n    // to authenticate again.\n    // If the server fails for any other reason, do not clear the cache.\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      try {\n        return await this.finishAuthentication(connection, credentials, token);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeAccessToken();\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    const response = await this.fetchAccessToken(credentials);\n    this.cache.put(response);\n    connection.accessToken = response.accessToken;\n    await this.finishAuthentication(connection, credentials, response.accessToken);\n  }\n\n  /**\n   * Fetches the access token using the callback.\n   */\n  protected async fetchAccessToken(credentials: MongoCredentials): Promise<OIDCResponse> {\n    const controller = new AbortController();\n    const params: OIDCCallbackParams = {\n      timeoutContext: controller.signal,\n      version: OIDC_VERSION\n    };\n    if (credentials.username) {\n      params.username = credentials.username;\n    }\n    const timeout = Timeout.expires(AUTOMATED_TIMEOUT_MS);\n    try {\n      return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        controller.abort();\n        throw new MongoOIDCError(`OIDC callback timed out after ${AUTOMATED_TIMEOUT_MS}ms.`);\n      }\n      throw error;\n    } finally {\n      timeout.clear();\n    }\n  }\n}\n"
        }
    ]
}