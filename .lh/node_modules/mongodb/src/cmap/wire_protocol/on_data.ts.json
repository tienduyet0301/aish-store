{
    "sourceFile": "node_modules/mongodb/src/cmap/wire_protocol/on_data.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892634358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { type EventEmitter } from 'events';\n\nimport { type Abortable } from '../../mongo_types';\nimport { type TimeoutContext } from '../../timeout';\nimport { addAbortListener, kDispose, List, promiseWithResolvers } from '../../utils';\n\n/**\n * @internal\n * An object holding references to a promise's resolve and reject functions.\n */\ntype PendingPromises = Omit<\n  ReturnType<typeof promiseWithResolvers<IteratorResult<Buffer>>>,\n  'promise'\n>;\n\n/**\n * onData is adapted from Node.js' events.on helper\n * https://nodejs.org/api/events.html#eventsonemitter-eventname-options\n *\n * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.\n * It will reject upon an error event.\n */\nexport function onData(\n  emitter: EventEmitter,\n  { timeoutContext, signal }: { timeoutContext?: TimeoutContext } & Abortable\n) {\n  signal?.throwIfAborted();\n\n  // Setup pending events and pending promise lists\n  /**\n   * When the caller has not yet called .next(), we store the\n   * value from the event in this list. Next time they call .next()\n   * we pull the first value out of this list and resolve a promise with it.\n   */\n  const unconsumedEvents = new List<Buffer>();\n  /**\n   * When there has not yet been an event, a new promise will be created\n   * and implicitly stored in this list. When an event occurs we take the first\n   * promise in this list and resolve it.\n   */\n  const unconsumedPromises = new List<PendingPromises>();\n\n  /**\n   * Stored an error created by an error event.\n   * This error will turn into a rejection for the subsequent .next() call\n   */\n  let error: Error | null = null;\n\n  /** Set to true only after event listeners have been removed. */\n  let finished = false;\n\n  const iterator: AsyncGenerator<Buffer> = {\n    next() {\n      // First, we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value != null) {\n        return Promise.resolve({ value, done: false });\n      }\n\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error != null) {\n        const p = Promise.reject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n\n      // Wait until an event happens\n      const { promise, resolve, reject } = promiseWithResolvers<IteratorResult<Buffer>>();\n      unconsumedPromises.push({ resolve, reject });\n      return promise;\n    },\n\n    return() {\n      return closeHandler();\n    },\n\n    throw(err: Error) {\n      errorHandler(err);\n      return Promise.resolve({ value: undefined, done: true });\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n\n  // Adding event handlers\n  emitter.on('data', eventHandler);\n  emitter.on('error', errorHandler);\n  const abortListener = addAbortListener(signal, function () {\n    errorHandler(this.reason);\n  });\n\n  const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;\n  timeoutForSocketRead?.throwIfExpired();\n  timeoutForSocketRead?.then(undefined, errorHandler);\n\n  return iterator;\n\n  function eventHandler(value: Buffer) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.resolve({ value, done: false });\n    else unconsumedEvents.push(value);\n  }\n\n  function errorHandler(err: Error) {\n    const promise = unconsumedPromises.shift();\n\n    if (promise != null) promise.reject(err);\n    else error = err;\n    void closeHandler();\n  }\n\n  function closeHandler() {\n    // Adding event handlers\n    emitter.off('data', eventHandler);\n    emitter.off('error', errorHandler);\n    abortListener?.[kDispose]();\n    finished = true;\n    timeoutForSocketRead?.clear();\n    const doneResult = { value: undefined, done: finished } as const;\n\n    for (const promise of unconsumedPromises) {\n      promise.resolve(doneResult);\n    }\n\n    return Promise.resolve(doneResult);\n  }\n}\n"
        }
    ]
}