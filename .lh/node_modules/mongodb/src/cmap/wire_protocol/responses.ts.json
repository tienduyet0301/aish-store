{
    "sourceFile": "node_modules/mongodb/src/cmap/wire_protocol/responses.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892634439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import {\n  type BSONElement,\n  type BSONSerializeOptions,\n  BSONType,\n  type DeserializeOptions,\n  type Document,\n  Long,\n  parseToElementsToArray,\n  parseUtf8ValidationOption,\n  pluckBSONSerializeOptions,\n  serialize,\n  type Timestamp\n} from '../../bson';\nimport { MONGODB_ERROR_CODES, MongoUnexpectedServerResponseError } from '../../error';\nimport { type ClusterTime } from '../../sdam/common';\nimport { decorateDecryptionResult, ns } from '../../utils';\nimport {\n  type JSTypeOf,\n  OnDemandDocument,\n  type OnDemandDocumentDeserializeOptions\n} from './on_demand/document';\n\n// eslint-disable-next-line no-restricted-syntax\nconst enum BSONElementOffset {\n  type = 0,\n  nameOffset = 1,\n  nameLength = 2,\n  offset = 3,\n  length = 4\n}\n/**\n * Accepts a BSON payload and checks for na \"ok: 0\" element.\n * This utility is intended to prevent calling response class constructors\n * that expect the result to be a success and demand certain properties to exist.\n *\n * For example, a cursor response always expects a cursor embedded document.\n * In order to write the class such that the properties reflect that assertion (non-null)\n * we cannot invoke the subclass constructor if the BSON represents an error.\n *\n * @param bytes - BSON document returned from the server\n */\nexport function isErrorResponse(bson: Uint8Array, elements: BSONElement[]): boolean {\n  for (let eIdx = 0; eIdx < elements.length; eIdx++) {\n    const element = elements[eIdx];\n\n    if (element[BSONElementOffset.nameLength] === 2) {\n      const nameOffset = element[BSONElementOffset.nameOffset];\n\n      // 111 == \"o\", 107 == \"k\"\n      if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {\n        const valueOffset = element[BSONElementOffset.offset];\n        const valueLength = element[BSONElementOffset.length];\n\n        // If any byte in the length of the ok number (works for any type) is non zero,\n        // then it is considered \"ok: 1\"\n        for (let i = valueOffset; i < valueOffset + valueLength; i++) {\n          if (bson[i] !== 0x00) return false;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return true;\n}\n\n/** @internal */\nexport type MongoDBResponseConstructor = {\n  new (bson: Uint8Array, offset?: number, isArray?: boolean): MongoDBResponse;\n  make(bson: Uint8Array): MongoDBResponse;\n};\n\n/** @internal */\nexport class MongoDBResponse extends OnDemandDocument {\n  // Wrap error thrown from BSON\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: false | undefined\n  ): JSTypeOf[T] | null;\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required: true\n  ): JSTypeOf[T];\n  public override get<const T extends keyof JSTypeOf>(\n    name: string | number,\n    as: T,\n    required?: boolean | undefined\n  ): JSTypeOf[T] | null {\n    try {\n      return super.get(name, as, required);\n    } catch (cause) {\n      throw new MongoUnexpectedServerResponseError(cause.message, { cause });\n    }\n  }\n\n  static is(value: unknown): value is MongoDBResponse {\n    return value instanceof MongoDBResponse;\n  }\n\n  static make(bson: Uint8Array) {\n    const elements = parseToElementsToArray(bson, 0);\n    const isError = isErrorResponse(bson, elements);\n    return isError\n      ? new MongoDBResponse(bson, 0, false, elements)\n      : new this(bson, 0, false, elements);\n  }\n\n  // {ok:1}\n  static empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));\n\n  /**\n   * Returns true iff:\n   * - ok is 0 and the top-level code === 50\n   * - ok is 1 and the writeErrors array contains a code === 50\n   * - ok is 1 and the writeConcern object contains a code === 50\n   */\n  get isMaxTimeExpiredError() {\n    // {ok: 0, code: 50 ... }\n    const isTopLevel = this.ok === 0 && this.code === MONGODB_ERROR_CODES.MaxTimeMSExpired;\n    if (isTopLevel) return true;\n\n    if (this.ok === 0) return false;\n\n    // {ok: 1, writeConcernError: {code: 50 ... }}\n    const isWriteConcern =\n      this.get('writeConcernError', BSONType.object)?.getNumber('code') ===\n      MONGODB_ERROR_CODES.MaxTimeMSExpired;\n    if (isWriteConcern) return true;\n\n    const writeErrors = this.get('writeErrors', BSONType.array);\n    if (writeErrors?.size()) {\n      for (let i = 0; i < writeErrors.size(); i++) {\n        const isWriteError =\n          writeErrors.get(i, BSONType.object)?.getNumber('code') ===\n          MONGODB_ERROR_CODES.MaxTimeMSExpired;\n\n        // {ok: 1, writeErrors: [{code: 50 ... }]}\n        if (isWriteError) return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Drivers can safely assume that the `recoveryToken` field is always a BSON document but drivers MUST NOT modify the\n   * contents of the document.\n   */\n  get recoveryToken(): Document | null {\n    return (\n      this.get('recoveryToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false,\n        validation: { utf8: true }\n      }) ?? null\n    );\n  }\n\n  /**\n   * The server creates a cursor in response to a snapshot find/aggregate command and reports atClusterTime within the cursor field in the response.\n   * For the distinct command the server adds a top-level atClusterTime field to the response.\n   * The atClusterTime field represents the timestamp of the read and is guaranteed to be majority committed.\n   */\n  public get atClusterTime(): Timestamp | null {\n    return (\n      this.get('cursor', BSONType.object)?.get('atClusterTime', BSONType.timestamp) ??\n      this.get('atClusterTime', BSONType.timestamp)\n    );\n  }\n\n  public get operationTime(): Timestamp | null {\n    return this.get('operationTime', BSONType.timestamp);\n  }\n\n  /** Normalizes whatever BSON value is \"ok\" to a JS number 1 or 0. */\n  public get ok(): 0 | 1 {\n    return this.getNumber('ok') ? 1 : 0;\n  }\n\n  public get $err(): string | null {\n    return this.get('$err', BSONType.string);\n  }\n\n  public get errmsg(): string | null {\n    return this.get('errmsg', BSONType.string);\n  }\n\n  public get code(): number | null {\n    return this.getNumber('code');\n  }\n\n  private clusterTime?: ClusterTime | null;\n  public get $clusterTime(): ClusterTime | null {\n    if (!('clusterTime' in this)) {\n      const clusterTimeDoc = this.get('$clusterTime', BSONType.object);\n      if (clusterTimeDoc == null) {\n        this.clusterTime = null;\n        return null;\n      }\n      const clusterTime = clusterTimeDoc.get('clusterTime', BSONType.timestamp, true);\n      const signature = clusterTimeDoc.get('signature', BSONType.object)?.toObject();\n      // @ts-expect-error: `signature` is incorrectly typed. It is public API.\n      this.clusterTime = { clusterTime, signature };\n    }\n    return this.clusterTime ?? null;\n  }\n\n  public override toObject(options?: BSONSerializeOptions): Record<string, any> {\n    const exactBSONOptions = {\n      ...pluckBSONSerializeOptions(options ?? {}),\n      validation: parseUtf8ValidationOption(options)\n    };\n    return super.toObject(exactBSONOptions);\n  }\n}\n\n/** @internal */\nexport class CursorResponse extends MongoDBResponse {\n  /**\n   * Devtools need to know which keys were encrypted before the driver automatically decrypted them.\n   * If decorating is enabled (`Symbol.for('@@mdb.decorateDecryptionResult')`), this field will be set,\n   * storing the original encrypted response from the server, so that we can build an object that has\n   * the list of BSON keys that were encrypted stored at a well known symbol: `Symbol.for('@@mdb.decryptedKeys')`.\n   */\n  encryptedResponse?: MongoDBResponse;\n  /**\n   * This supports a feature of the FindCursor.\n   * It is an optimization to avoid an extra getMore when the limit has been reached\n   */\n  static get emptyGetMore(): CursorResponse {\n    return new CursorResponse(serialize({ ok: 1, cursor: { id: 0n, nextBatch: [] } }));\n  }\n\n  static override is(value: unknown): value is CursorResponse {\n    return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;\n  }\n\n  private _batch: OnDemandDocument | null = null;\n  private iterated = 0;\n\n  get cursor() {\n    return this.get('cursor', BSONType.object, true);\n  }\n\n  public get id(): Long {\n    try {\n      return Long.fromBigInt(this.cursor.get('id', BSONType.long, true));\n    } catch (cause) {\n      throw new MongoUnexpectedServerResponseError(cause.message, { cause });\n    }\n  }\n\n  public get ns() {\n    const namespace = this.cursor.get('ns', BSONType.string);\n    if (namespace != null) return ns(namespace);\n    return null;\n  }\n\n  public get length() {\n    return Math.max(this.batchSize - this.iterated, 0);\n  }\n\n  private _encryptedBatch: OnDemandDocument | null = null;\n  get encryptedBatch() {\n    if (this.encryptedResponse == null) return null;\n    if (this._encryptedBatch != null) return this._encryptedBatch;\n\n    const cursor = this.encryptedResponse?.get('cursor', BSONType.object);\n    if (cursor?.has('firstBatch'))\n      this._encryptedBatch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor?.has('nextBatch'))\n      this._encryptedBatch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n\n    return this._encryptedBatch;\n  }\n\n  private get batch() {\n    if (this._batch != null) return this._batch;\n    const cursor = this.cursor;\n    if (cursor.has('firstBatch')) this._batch = cursor.get('firstBatch', BSONType.array, true);\n    else if (cursor.has('nextBatch')) this._batch = cursor.get('nextBatch', BSONType.array, true);\n    else throw new MongoUnexpectedServerResponseError('Cursor document did not contain a batch');\n    return this._batch;\n  }\n\n  public get batchSize() {\n    return this.batch?.size();\n  }\n\n  public get postBatchResumeToken() {\n    return (\n      this.cursor.get('postBatchResumeToken', BSONType.object)?.toObject({\n        promoteValues: false,\n        promoteLongs: false,\n        promoteBuffers: false,\n        validation: { utf8: true }\n      }) ?? null\n    );\n  }\n\n  public shift(options: OnDemandDocumentDeserializeOptions): any {\n    if (this.iterated >= this.batchSize) {\n      return null;\n    }\n\n    const result = this.batch.get(this.iterated, BSONType.object, true) ?? null;\n    const encryptedResult = this.encryptedBatch?.get(this.iterated, BSONType.object, true) ?? null;\n\n    this.iterated += 1;\n\n    if (options?.raw) {\n      return result.toBytes();\n    } else {\n      const object = result.toObject(options);\n      if (encryptedResult) {\n        decorateDecryptionResult(object, encryptedResult.toObject(options), true);\n      }\n      return object;\n    }\n  }\n\n  public clear() {\n    this.iterated = this.batchSize;\n  }\n}\n\n/**\n * Explain responses have nothing to do with cursor responses\n * This class serves to temporarily avoid refactoring how cursors handle\n * explain responses which is to detect that the response is not cursor-like and return the explain\n * result as the \"first and only\" document in the \"batch\" and end the \"cursor\"\n */\nexport class ExplainedCursorResponse extends CursorResponse {\n  isExplain = true;\n\n  override get id(): Long {\n    return Long.fromBigInt(0n);\n  }\n\n  override get batchSize() {\n    return 0;\n  }\n\n  override get ns() {\n    return null;\n  }\n\n  _length = 1;\n  override get length(): number {\n    return this._length;\n  }\n\n  override shift(options?: DeserializeOptions) {\n    if (this._length === 0) return null;\n    this._length -= 1;\n    return this.toObject(options);\n  }\n}\n\n/**\n * Client bulk writes have some extra metadata at the top level that needs to be\n * included in the result returned to the user.\n */\nexport class ClientBulkWriteCursorResponse extends CursorResponse {\n  get insertedCount() {\n    return this.get('nInserted', BSONType.int, true);\n  }\n\n  get upsertedCount() {\n    return this.get('nUpserted', BSONType.int, true);\n  }\n\n  get matchedCount() {\n    return this.get('nMatched', BSONType.int, true);\n  }\n\n  get modifiedCount() {\n    return this.get('nModified', BSONType.int, true);\n  }\n\n  get deletedCount() {\n    return this.get('nDeleted', BSONType.int, true);\n  }\n\n  get writeConcernError() {\n    return this.get('writeConcernError', BSONType.object, false);\n  }\n}\n"
        }
    ]
}