{
    "sourceFile": "node_modules/mongodb/src/utils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892637250,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as crypto from 'crypto';\nimport type { SrvRecord } from 'dns';\nimport { type EventEmitter } from 'events';\nimport { promises as fs } from 'fs';\nimport * as http from 'http';\nimport { clearTimeout, setTimeout } from 'timers';\nimport * as url from 'url';\nimport { URL } from 'url';\nimport { promisify } from 'util';\n\nimport { deserialize, type Document, ObjectId, resolveBSONOptions } from './bson';\nimport type { Connection } from './cmap/connection';\nimport { MAX_SUPPORTED_WIRE_VERSION } from './cmap/wire_protocol/constants';\nimport type { Collection } from './collection';\nimport { kDecoratedKeys, LEGACY_HELLO_COMMAND } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport type { FindCursor } from './cursor/find_cursor';\nimport type { Db } from './db';\nimport {\n  type AnyError,\n  MongoAPIError,\n  MongoCompatibilityError,\n  MongoInvalidArgumentError,\n  MongoNetworkTimeoutError,\n  MongoNotConnectedError,\n  MongoParseError,\n  MongoRuntimeError\n} from './error';\nimport type { MongoClient } from './mongo_client';\nimport { type Abortable } from './mongo_types';\nimport type { CommandOperationOptions, OperationParent } from './operations/command';\nimport type { Hint, OperationOptions } from './operations/operation';\nimport { ReadConcern } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { ServerType } from './sdam/common';\nimport type { Server } from './sdam/server';\nimport type { Topology } from './sdam/topology';\nimport type { ClientSession } from './sessions';\nimport { type TimeoutContextOptions } from './timeout';\nimport { WriteConcern } from './write_concern';\n\n/**\n * MongoDB Driver style callback\n * @public\n */\nexport type Callback<T = any> = (error?: AnyError, result?: T) => void;\n\nexport type AnyOptions = Document;\n\nexport const ByteUtils = {\n  toLocalBufferType(this: void, buffer: Buffer | Uint8Array): Buffer {\n    return Buffer.isBuffer(buffer)\n      ? buffer\n      : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  },\n\n  equals(this: void, seqA: Uint8Array, seqB: Uint8Array) {\n    return ByteUtils.toLocalBufferType(seqA).equals(seqB);\n  },\n\n  compare(this: void, seqA: Uint8Array, seqB: Uint8Array) {\n    return ByteUtils.toLocalBufferType(seqA).compare(seqB);\n  },\n\n  toBase64(this: void, uint8array: Uint8Array) {\n    return ByteUtils.toLocalBufferType(uint8array).toString('base64');\n  }\n};\n\n/**\n * Returns true if value is a Uint8Array or a Buffer\n * @param value - any value that may be a Uint8Array\n */\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    Symbol.toStringTag in value &&\n    value[Symbol.toStringTag] === 'Uint8Array'\n  );\n}\n\n/**\n * Determines if a connection's address matches a user provided list\n * of domain wildcards.\n */\nexport function hostMatchesWildcards(host: string, wildcards: string[]): boolean {\n  for (const wildcard of wildcards) {\n    if (\n      host === wildcard ||\n      (wildcard.startsWith('*.') && host?.endsWith(wildcard.substring(2, wildcard.length))) ||\n      (wildcard.startsWith('*/') && host?.endsWith(wildcard.substring(2, wildcard.length)))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nexport function normalizeHintField(hint?: Hint): Hint | undefined {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {} as Document;\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nconst TO_STRING = (object: unknown) => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n\nexport function isObject(arg: unknown): arg is object {\n  return '[object Object]' === TO_STRING(arg);\n}\n\n/** @internal */\nexport function mergeOptions<T, S>(target: T, source: S): T & S {\n  return { ...target, ...source };\n}\n\n/** @internal */\nexport function filterOptions(options: AnyOptions, names: ReadonlyArray<string>): AnyOptions {\n  const filterOptions: AnyOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  }\n\n  // Filtered options\n  return filterOptions;\n}\n\ninterface HasRetryableWrites {\n  retryWrites?: boolean;\n}\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nexport function applyRetryableWrites<T extends HasRetryableWrites>(target: T, db?: Db): T {\n  if (db && db.s.options?.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The resolution type of the possible promise\n * @param value - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nexport function isPromiseLike<T = unknown>(value?: unknown): value is PromiseLike<T> {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    'then' in value &&\n    typeof value.then === 'function'\n  );\n}\n\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nexport function decorateWithCollation(\n  command: Document,\n  target: MongoClient | Db | Collection,\n  options: AnyOptions\n): void {\n  const capabilities = getTopology(target).capabilities;\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nexport function decorateWithReadConcern(\n  command: Document,\n  coll: { s: { readConcern?: ReadConcern } },\n  options?: OperationOptions\n): void {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  const readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\n/**\n * @internal\n */\nexport type TopologyProvider =\n  | MongoClient\n  | ClientSession\n  | FindCursor\n  | AbstractCursor\n  | Collection<any>\n  | Db;\n\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\nexport function getTopology(provider: TopologyProvider): Topology {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('client' in provider && provider.client.topology) {\n    return provider.client.topology;\n  }\n\n  throw new MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\n/** @internal */\nexport function ns(ns: string): MongoDBNamespace {\n  return MongoDBNamespace.fromString(ns);\n}\n\n/** @public */\nexport class MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(\n    public db: string,\n    public collection?: string\n  ) {\n    this.collection = collection === '' ? undefined : collection;\n  }\n\n  toString(): string {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection: string): MongoDBCollectionNamespace {\n    return new MongoDBCollectionNamespace(this.db, collection);\n  }\n\n  static fromString(namespace?: string): MongoDBNamespace {\n    if (typeof namespace !== 'string' || namespace === '') {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collectionParts] = namespace.split('.');\n    const collection = collectionParts.join('.');\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n  }\n}\n\n/**\n * @public\n *\n * A class representing a collection's namespace.  This class enforces (through Typescript) that\n * the `collection` portion of the namespace is defined and should only be\n * used in scenarios where this can be guaranteed.\n */\nexport class MongoDBCollectionNamespace extends MongoDBNamespace {\n  constructor(\n    db: string,\n    override collection: string\n  ) {\n    super(db, collection);\n  }\n\n  static override fromString(namespace?: string): MongoDBCollectionNamespace {\n    return super.fromString(namespace) as MongoDBCollectionNamespace;\n  }\n}\n\n/** @internal */\nexport function* makeCounter(seed = 0): Generator<number> {\n  let count = seed;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nexport function uuidV4(): Buffer {\n  const result = crypto.randomBytes(16);\n  result[6] = (result[6] & 0x0f) | 0x40;\n  result[8] = (result[8] & 0x3f) | 0x80;\n  return result;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nexport function maxWireVersion(topologyOrServer?: Connection | Topology | Server): number {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced || topologyOrServer.serverApi?.version) {\n      // Since we do not have a monitor in the load balanced mode,\n      // we assume the load-balanced server is always pointed at the latest mongodb version.\n      // There is a risk that for on-prem deployments\n      // that don't upgrade immediately that this could alert to the\n      // application that a feature is available that is actually not.\n      // We also return the max supported wire version for serverAPI.\n      return MAX_SUPPORTED_WIRE_VERSION;\n    }\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (\n      topologyOrServer.description &&\n      'maxWireVersion' in topologyOrServer.description &&\n      topologyOrServer.description.maxWireVersion != null\n    ) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\n/** @internal */\nexport function arrayStrictEqual(arr: unknown[], arr2: unknown[]): boolean {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\n/** @internal */\nexport function errorStrictEqual(lhs?: AnyError | null, rhs?: AnyError | null): boolean {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\ninterface StateTable {\n  [key: string]: string[];\n}\ninterface ObjectWithState {\n  s: { state: string };\n  emit(event: 'stateChanged', state: string, newState: string): void;\n}\ninterface StateTransitionFunction {\n  (target: ObjectWithState, newState: string): void;\n}\n\n/** @public */\nexport type EventEmitterWithState = {\n  /** @internal */\n  stateChanged(previous: string, current: string): void;\n};\n\n/** @internal */\nexport function makeStateMachine(stateTable: StateTable): StateTransitionFunction {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new MongoRuntimeError(\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\n      );\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\n/** @internal */\nexport function now(): number {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\n/** @internal */\nexport function calculateDurationInMs(started: number | undefined): number {\n  if (typeof started !== 'number') {\n    return -1;\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/** @internal */\nexport function hasAtomicOperators(doc: Document | Document[]): boolean {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexport function resolveTimeoutOptions<T extends Partial<TimeoutContextOptions>>(\n  client: MongoClient,\n  options: T\n): T &\n  Pick<\n    MongoClient['s']['options'],\n    'timeoutMS' | 'serverSelectionTimeoutMS' | 'waitQueueTimeoutMS' | 'socketTimeoutMS'\n  > {\n  const { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS } =\n    client.s.options;\n  return { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS, ...options };\n}\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n *\n * @param parent - An optional owning class of the operation being run. ex. Db/Collection/MongoClient.\n * @param options - The options passed to the operation method.\n *\n * @internal\n */\nexport function resolveOptions<T extends CommandOperationOptions>(\n  parent: OperationParent | undefined,\n  options?: T\n): T {\n  const result: T = Object.assign({}, options, resolveBSONOptions(options, parent));\n\n  const timeoutMS = options?.timeoutMS ?? parent?.timeoutMS;\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\n  const session = options?.session;\n\n  if (!session?.inTransaction()) {\n    const readConcern = ReadConcern.fromOptions(options) ?? parent?.readConcern;\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    let writeConcern = WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n    if (writeConcern) {\n      if (timeoutMS != null) {\n        writeConcern = WriteConcern.fromOptions({\n          writeConcern: {\n            ...writeConcern,\n            wtimeout: undefined,\n            wtimeoutMS: undefined\n          }\n        });\n      }\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  result.timeoutMS = timeoutMS;\n\n  const readPreference = ReadPreference.fromOptions(options) ?? parent?.readPreference;\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  const isConvenientTransaction = session?.explicit && session?.timeoutContext != null;\n  if (isConvenientTransaction && options?.timeoutMS != null) {\n    throw new MongoInvalidArgumentError(\n      'An operation cannot be given a timeoutMS setting when inside a withTransaction call that has a timeoutMS setting'\n    );\n  }\n\n  return result;\n}\n\nexport function isSuperset(set: Set<any> | any[], subset: Set<any> | any[]): boolean {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks if the document is a Hello request\n * @internal\n */\nexport function isHello(doc: Document): boolean {\n  return doc[LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\n/** Returns the items that are uniquely in setA */\nexport function setDifference<T>(setA: Iterable<T>, setB: Iterable<T>): Set<T> {\n  const difference = new Set<T>(setA);\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n  return difference;\n}\n\nconst HAS_OWN = (object: unknown, prop: string) =>\n  Object.prototype.hasOwnProperty.call(object, prop);\n\nexport function isRecord<T extends readonly string[]>(\n  value: unknown,\n  requiredKeys: T\n): value is Record<T[number], any>;\nexport function isRecord(value: unknown): value is Record<string, any>;\nexport function isRecord(\n  value: unknown,\n  requiredKeys: string[] | undefined = undefined\n): value is Record<string, any> {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = (value as any).constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n\n    // Check to see if some method exists from the Object exists\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value as Record<string, any>);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\ntype ListNode<T> = {\n  value: T;\n  next: ListNode<T> | HeadNode<T>;\n  prev: ListNode<T> | HeadNode<T>;\n};\n\ntype HeadNode<T> = {\n  value: null;\n  next: ListNode<T>;\n  prev: ListNode<T>;\n};\n\n/**\n * When a list is empty the head is a reference with pointers to itself\n * So this type represents that self referential state\n */\ntype EmptyNode = {\n  value: null;\n  next: EmptyNode;\n  prev: EmptyNode;\n};\n\n/**\n * A sequential list of items in a circularly linked list\n * @remarks\n * The head node is special, it is always defined and has a value of null.\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\n * @internal\n */\nexport class List<T = unknown> {\n  private readonly head: HeadNode<T> | EmptyNode;\n  private count: number;\n\n  get length() {\n    return this.count;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'List' as const;\n  }\n\n  constructor() {\n    this.count = 0;\n\n    // this is carefully crafted:\n    // declaring a complete and consistently key ordered\n    // object is beneficial to the runtime optimizations\n    this.head = {\n      next: null,\n      prev: null,\n      value: null\n    } as unknown as EmptyNode;\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n\n  toArray() {\n    return Array.from(this);\n  }\n\n  toString() {\n    return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\n  }\n\n  *[Symbol.iterator](): Generator<T, void, void> {\n    for (const node of this.nodes()) {\n      yield node.value;\n    }\n  }\n\n  private *nodes(): Generator<ListNode<T>, void, void> {\n    let ptr: HeadNode<T> | ListNode<T> | EmptyNode = this.head.next;\n    while (ptr !== this.head) {\n      // Save next before yielding so that we make removing within iteration safe\n      const { next } = ptr as ListNode<T>;\n      yield ptr as ListNode<T>;\n      ptr = next;\n    }\n  }\n\n  /** Insert at end of list */\n  push(value: T) {\n    this.count += 1;\n    const newNode: ListNode<T> = {\n      next: this.head as HeadNode<T>,\n      prev: this.head.prev as ListNode<T>,\n      value\n    };\n    this.head.prev.next = newNode;\n    this.head.prev = newNode;\n  }\n\n  /** Inserts every item inside an iterable instead of the iterable itself */\n  pushMany(iterable: Iterable<T>) {\n    for (const value of iterable) {\n      this.push(value);\n    }\n  }\n\n  /** Insert at front of list */\n  unshift(value: T) {\n    this.count += 1;\n    const newNode: ListNode<T> = {\n      next: this.head.next as ListNode<T>,\n      prev: this.head as HeadNode<T>,\n      value\n    };\n    this.head.next.prev = newNode;\n    this.head.next = newNode;\n  }\n\n  private remove(node: ListNode<T> | EmptyNode): T | null {\n    if (node === this.head || this.length === 0) {\n      return null;\n    }\n\n    this.count -= 1;\n\n    const prevNode = node.prev;\n    const nextNode = node.next;\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n\n    return node.value;\n  }\n\n  /** Removes the first node at the front of the list */\n  shift(): T | null {\n    return this.remove(this.head.next);\n  }\n\n  /** Removes the last node at the end of the list */\n  pop(): T | null {\n    return this.remove(this.head.prev);\n  }\n\n  /** Iterates through the list and removes nodes where filter returns true */\n  prune(filter: (value: T) => boolean) {\n    for (const node of this.nodes()) {\n      if (filter(node.value)) {\n        this.remove(node);\n      }\n    }\n  }\n\n  clear() {\n    this.count = 0;\n    this.head.next = this.head as EmptyNode;\n    this.head.prev = this.head as EmptyNode;\n  }\n\n  /** Returns the first item in the list, does not remove */\n  first(): T | null {\n    // If the list is empty, value will be the head's null\n    return this.head.next.value;\n  }\n\n  /** Returns the last item in the list, does not remove */\n  last(): T | null {\n    // If the list is empty, value will be the head's null\n    return this.head.prev.value;\n  }\n}\n\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nexport class BufferPool {\n  private buffers: List<Buffer>;\n  private totalByteLength: number;\n\n  constructor() {\n    this.buffers = new List();\n    this.totalByteLength = 0;\n  }\n\n  get length(): number {\n    return this.totalByteLength;\n  }\n\n  /** Adds a buffer to the internal buffer pool list */\n  append(buffer: Buffer): void {\n    this.buffers.push(buffer);\n    this.totalByteLength += buffer.length;\n  }\n\n  /**\n   * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\n   * otherwise return null. Size can be negative, caller should error check.\n   */\n  getInt32(): number | null {\n    if (this.totalByteLength < 4) {\n      return null;\n    }\n    const firstBuffer = this.buffers.first();\n    if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n      return firstBuffer.readInt32LE(0);\n    }\n\n    // Unlikely case: an int32 is split across buffers.\n    // Use read and put the returned buffer back on top\n    const top4Bytes = this.read(4);\n    const value = top4Bytes.readInt32LE(0);\n\n    // Put it back.\n    this.totalByteLength += 4;\n    this.buffers.unshift(top4Bytes);\n\n    return value;\n  }\n\n  /** Reads the requested number of bytes, optionally consuming them */\n  read(size: number): Buffer {\n    if (typeof size !== 'number' || size < 0) {\n      throw new MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    // oversized request returns empty buffer\n    if (size > this.totalByteLength) {\n      return Buffer.alloc(0);\n    }\n\n    // We know we have enough, we just don't know how it is spread across chunks\n    // TODO(NODE-4732): alloc API should change based on raw option\n    const result = Buffer.allocUnsafe(size);\n\n    for (let bytesRead = 0; bytesRead < size; ) {\n      const buffer = this.buffers.shift();\n      if (buffer == null) {\n        break;\n      }\n      const bytesRemaining = size - bytesRead;\n      const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n      const bytes = buffer.subarray(0, bytesReadable);\n\n      result.set(bytes, bytesRead);\n\n      bytesRead += bytesReadable;\n      this.totalByteLength -= bytesReadable;\n      if (bytesReadable < buffer.byteLength) {\n        this.buffers.unshift(buffer.subarray(bytesReadable));\n      }\n    }\n\n    return result;\n  }\n}\n\n/** @public */\nexport class HostAddress {\n  host: string | undefined = undefined;\n  port: number | undefined = undefined;\n  socketPath: string | undefined = undefined;\n  isIPv6 = false;\n\n  constructor(hostString: string) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    if (escapedHost.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(escapedHost);\n      return;\n    }\n\n    const urlString = `iLoveJS://${escapedHost}`;\n    let url;\n    try {\n      url = new URL(urlString);\n    } catch (urlError) {\n      const runtimeError = new MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\n      runtimeError.cause = urlError;\n      throw runtimeError;\n    }\n\n    const hostname = url.hostname;\n    const port = url.port;\n\n    let normalized = decodeURIComponent(hostname).toLowerCase();\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\n      this.isIPv6 = true;\n      normalized = normalized.substring(1, hostname.length - 1);\n    }\n\n    this.host = normalized.toLowerCase();\n\n    if (typeof port === 'number') {\n      this.port = port;\n    } else if (typeof port === 'string' && port !== '') {\n      this.port = Number.parseInt(port, 10);\n    } else {\n      this.port = 27017;\n    }\n\n    if (this.port === 0) {\n      throw new MongoParseError('Invalid port (zero) with hostname');\n    }\n    Object.freeze(this);\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\n    return this.inspect();\n  }\n\n  inspect(): string {\n    return `new HostAddress('${this.toString()}')`;\n  }\n\n  toString(): string {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6) {\n        return `[${this.host}]:${this.port}`;\n      }\n      return `${this.host}:${this.port}`;\n    }\n    return `${this.socketPath}`;\n  }\n\n  static fromString(this: void, s: string): HostAddress {\n    return new HostAddress(s);\n  }\n\n  static fromHostPort(host: string, port: number): HostAddress {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n\n  static fromSrvRecord({ name, port }: SrvRecord): HostAddress {\n    return HostAddress.fromHostPort(name, port);\n  }\n\n  toHostPort(): { host: string; port: number } {\n    if (this.socketPath) {\n      return { host: this.socketPath, port: 0 };\n    }\n\n    const host = this.host ?? '';\n    const port = this.port ?? 0;\n    return { host, port };\n  }\n}\n\nexport const DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk(): ObjectId {\n    return new ObjectId();\n  }\n};\n\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```ts\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexport const MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n\n/** @internal */\nexport function emitWarning(message: string): void {\n  return process.emitWarning(message, { code: MONGODB_WARNING_CODE } as any);\n}\n\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nexport function emitWarningOnce(message: string): void {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nexport function enumToString(en: Record<string, unknown>): string {\n  return Object.values(en).join(', ');\n}\n\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nexport function supportsRetryableWrites(server?: Server): boolean {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\nexport function shuffle<T>(sequence: Iterable<T>, limit = 0): Array<T> {\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1;\n\n    // And swap it with the current element\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\n/**\n * TODO(NODE-4936): read concern eligibility for commands should be codified in command construction\n * @internal\n * @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.md#read-concern\n */\nexport function commandSupportsReadConcern(command: Document): boolean {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Compare objectIds. `null` is always less\n * - `+1 = oid1 is greater than oid2`\n * - `-1 = oid1 is less than oid2`\n * - `+0 = oid1 is equal oid2`\n */\nexport function compareObjectId(oid1?: ObjectId | null, oid2?: ObjectId | null): 0 | 1 | -1 {\n  if (oid1 == null && oid2 == null) {\n    return 0;\n  }\n\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  return ByteUtils.compare(oid1.id, oid2.id);\n}\n\nexport function parseInteger(value: unknown): number | null {\n  if (typeof value === 'number') return Math.trunc(value);\n  const parsedValue = Number.parseInt(String(value), 10);\n\n  return Number.isNaN(parsedValue) ? null : parsedValue;\n}\n\nexport function parseUnsignedInteger(value: unknown): number | null {\n  const parsedInt = parseInteger(value);\n\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\n\n/**\n * This function throws a MongoAPIError in the event that either of the following is true:\n * * If the provided address domain does not match the provided parent domain\n * * If the parent domain contains less than three `.` separated parts and the provided address does not contain at least one more domain level than its parent\n *\n * If a DNS server were to become compromised SRV records would still need to\n * advertise addresses that are under the same domain as the srvHost.\n *\n * @param address - The address to check against a domain\n * @param srvHost - The domain to check the provided address against\n * @returns void\n */\nexport function checkParentDomainMatch(address: string, srvHost: string): void {\n  // Remove trailing dot if exists on either the resolved address or the srv hostname\n  const normalizedAddress = address.endsWith('.') ? address.slice(0, address.length - 1) : address;\n  const normalizedSrvHost = srvHost.endsWith('.') ? srvHost.slice(0, srvHost.length - 1) : srvHost;\n\n  const allCharacterBeforeFirstDot = /^.*?\\./;\n  const srvIsLessThanThreeParts = normalizedSrvHost.split('.').length < 3;\n  // Remove all characters before first dot\n  // Add leading dot back to string so\n  //   an srvHostDomain = '.trusted.site'\n  //   will not satisfy an addressDomain that endsWith '.fake-trusted.site'\n  const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, '')}`;\n  let srvHostDomain = srvIsLessThanThreeParts\n    ? normalizedSrvHost\n    : `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, '')}`;\n\n  if (!srvHostDomain.startsWith('.')) {\n    srvHostDomain = '.' + srvHostDomain;\n  }\n  if (\n    srvIsLessThanThreeParts &&\n    normalizedAddress.split('.').length <= normalizedSrvHost.split('.').length\n  ) {\n    throw new MongoAPIError(\n      'Server record does not have at least one more domain level than parent URI'\n    );\n  }\n  if (!addressDomain.endsWith(srvHostDomain)) {\n    throw new MongoAPIError('Server record does not share hostname with parent URI');\n  }\n}\n\ninterface RequestOptions {\n  json?: boolean;\n  method?: string;\n  timeout?: number;\n  headers?: http.OutgoingHttpHeaders;\n}\n\n/**\n * Perform a get request that returns status and body.\n * @internal\n */\nexport function get(\n  url: URL | string,\n  options: http.RequestOptions = {}\n): Promise<{ body: string; status: number | undefined }> {\n  return new Promise((resolve, reject) => {\n    /* eslint-disable prefer-const */\n    let timeoutId: NodeJS.Timeout;\n    const request = http\n      .get(url, options, response => {\n        response.setEncoding('utf8');\n        let body = '';\n        response.on('data', chunk => (body += chunk));\n        response.on('end', () => {\n          clearTimeout(timeoutId);\n          resolve({ status: response.statusCode, body });\n        });\n      })\n      .on('error', error => {\n        clearTimeout(timeoutId);\n        reject(error);\n      })\n      .end();\n    timeoutId = setTimeout(() => {\n      request.destroy(new MongoNetworkTimeoutError(`request timed out after 10 seconds`));\n    }, 10000);\n  });\n}\n\nexport async function request(uri: string): Promise<Record<string, any>>;\nexport async function request(\n  uri: string,\n  options?: { json?: true } & RequestOptions\n): Promise<Record<string, any>>;\nexport async function request(\n  uri: string,\n  options?: { json: false } & RequestOptions\n): Promise<string>;\nexport async function request(\n  uri: string,\n  options: RequestOptions = {}\n): Promise<string | Record<string, any>> {\n  return await new Promise<string | Record<string, any>>((resolve, reject) => {\n    const requestOptions = {\n      method: 'GET',\n      timeout: 10000,\n      json: true,\n      ...url.parse(uri),\n      ...options\n    };\n\n    const req = http.request(requestOptions, res => {\n      res.setEncoding('utf8');\n\n      let data = '';\n      res.on('data', d => {\n        data += d;\n      });\n\n      res.once('end', () => {\n        if (options.json === false) {\n          resolve(data);\n          return;\n        }\n\n        try {\n          const parsed = JSON.parse(data);\n          resolve(parsed);\n        } catch {\n          // TODO(NODE-3483)\n          reject(new MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\n        }\n      });\n    });\n\n    req.once('timeout', () =>\n      req.destroy(\n        new MongoNetworkTimeoutError(\n          `Network request to ${uri} timed out after ${options.timeout} ms`\n        )\n      )\n    );\n    req.once('error', error => reject(error));\n    req.end();\n  });\n}\n\n/** @internal */\nexport const DOCUMENT_DB_CHECK = /(\\.docdb\\.amazonaws\\.com$)|(\\.docdb-elastic\\.amazonaws\\.com$)/;\n/** @internal */\nexport const COSMOS_DB_CHECK = /\\.cosmos\\.azure\\.com$/;\n\n/** @internal */\nexport const DOCUMENT_DB_MSG =\n  'You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb';\n/** @internal */\nexport const COSMOS_DB_MSG =\n  'You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb';\n\n/** @internal */\nexport function isHostMatch(match: RegExp, host?: string): boolean {\n  return host && match.test(host.toLowerCase()) ? true : false;\n}\n\nexport function promiseWithResolvers<T>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (error: Error) => void;\n} {\n  let resolve!: (value: T) => void;\n  let reject!: (error: Error) => void;\n  const promise = new Promise<T>(function withResolversExecutor(promiseResolve, promiseReject) {\n    resolve = promiseResolve;\n    reject = promiseReject;\n  });\n  return { promise, resolve, reject } as const;\n}\n\n/**\n * A noop function intended for use in preventing unhandled rejections.\n *\n * @example\n * ```js\n * const promise = myAsyncTask();\n * // eslint-disable-next-line github/no-then\n * promise.then(undefined, squashError);\n * ```\n */\nexport function squashError(_error: unknown) {\n  return;\n}\n\nexport const randomBytes = promisify(crypto.randomBytes);\n\n/**\n * Replicates the events.once helper.\n *\n * Removes unused signal logic and It **only** supports 0 or 1 argument events.\n *\n * @param ee - An event emitter that may emit `ev`\n * @param name - An event name to wait for\n */\nexport async function once<T>(ee: EventEmitter, name: string, options?: Abortable): Promise<T> {\n  options?.signal?.throwIfAborted();\n\n  const { promise, resolve, reject } = promiseWithResolvers<T>();\n  const onEvent = (data: T) => resolve(data);\n  const onError = (error: Error) => reject(error);\n  const abortListener = addAbortListener(options?.signal, function () {\n    reject(this.reason);\n  });\n\n  ee.once(name, onEvent).once('error', onError);\n\n  try {\n    return await promise;\n  } finally {\n    ee.off(name, onEvent);\n    ee.off('error', onError);\n    abortListener?.[kDispose]();\n  }\n}\n\nexport function maybeAddIdToDocuments(\n  coll: Collection,\n  docs: Document[],\n  options: { forceServerObjectId?: boolean }\n): Document[];\nexport function maybeAddIdToDocuments(\n  coll: Collection,\n  docs: Document,\n  options: { forceServerObjectId?: boolean }\n): Document;\nexport function maybeAddIdToDocuments(\n  coll: Collection,\n  docOrDocs: Document[] | Document,\n  options: { forceServerObjectId?: boolean }\n): Document[] | Document {\n  const forceServerObjectId =\n    typeof options.forceServerObjectId === 'boolean'\n      ? options.forceServerObjectId\n      : coll.s.db.options?.forceServerObjectId;\n\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docOrDocs;\n  }\n\n  const transform = (doc: Document): Document => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  };\n  return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);\n}\n\nexport async function fileIsAccessible(fileName: string, mode?: number) {\n  try {\n    await fs.access(fileName, mode);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function csotMin(duration1: number, duration2: number): number {\n  if (duration1 === 0) return duration2;\n  if (duration2 === 0) return duration1;\n  return Math.min(duration1, duration2);\n}\n\nexport function noop() {\n  return;\n}\n\n/**\n * Recurse through the (identically-shaped) `decrypted` and `original`\n * objects and attach a `decryptedKeys` property on each sub-object that\n * contained encrypted fields. Because we only call this on BSON responses,\n * we do not need to worry about circular references.\n *\n * @internal\n */\nexport function decorateDecryptionResult(\n  decrypted: Document & { [kDecoratedKeys]?: Array<string> },\n  original: Document,\n  isTopLevelDecorateCall = true\n): void {\n  if (isTopLevelDecorateCall) {\n    // The original value could have been either a JS object or a BSON buffer\n    if (Buffer.isBuffer(original)) {\n      original = deserialize(original);\n    }\n    if (Buffer.isBuffer(decrypted)) {\n      throw new MongoRuntimeError('Expected result of decryption to be deserialized BSON object');\n    }\n  }\n\n  if (!decrypted || typeof decrypted !== 'object') return;\n  for (const k of Object.keys(decrypted)) {\n    const originalValue = original[k];\n\n    // An object was decrypted by libmongocrypt if and only if it was\n    // a BSON Binary object with subtype 6.\n    if (originalValue && originalValue._bsontype === 'Binary' && originalValue.sub_type === 6) {\n      if (!decrypted[kDecoratedKeys]) {\n        Object.defineProperty(decrypted, kDecoratedKeys, {\n          value: [],\n          configurable: true,\n          enumerable: false,\n          writable: false\n        });\n      }\n      // this is defined in the preceding if-statement\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      decrypted[kDecoratedKeys]!.push(k);\n      // Do not recurse into this decrypted value. It could be a sub-document/array,\n      // in which case there is no original value associated with its subfields.\n      continue;\n    }\n\n    decorateDecryptionResult(decrypted[k], originalValue, false);\n  }\n}\n\n/** @internal */\nexport const kDispose: unique symbol = (Symbol.dispose as any) ?? Symbol('dispose');\n\n/** @internal */\nexport interface Disposable {\n  [kDispose](): void;\n}\n\n/**\n * A utility that helps with writing listener code idiomatically\n *\n * @example\n * ```js\n * using listener = addAbortListener(signal, function () {\n *   console.log('aborted', this.reason);\n * });\n * ```\n *\n * @param signal - if exists adds an abort listener\n * @param listener - the listener to be added to signal\n * @returns A disposable that will remove the abort listener\n */\nexport function addAbortListener(\n  signal: AbortSignal | undefined | null,\n  listener: (this: AbortSignal, event: Event) => void\n): Disposable | undefined {\n  if (signal == null) return;\n  signal.addEventListener('abort', listener, { once: true });\n  return { [kDispose]: () => signal.removeEventListener('abort', listener) };\n}\n\n/**\n * Takes a promise and races it with a promise wrapping the abort event of the optionally provided signal.\n * The given promise is _always_ ordered before the signal's abort promise.\n * When given an already rejected promise and an already aborted signal, the promise's rejection takes precedence.\n *\n * Any asynchronous processing in `promise` will continue even after the abort signal has fired,\n * but control will be returned to the caller\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\n *\n * @param promise - A promise to discard if the signal aborts\n * @param options - An options object carrying an optional signal\n */\nexport async function abortable<T>(\n  promise: Promise<T>,\n  { signal }: { signal?: AbortSignal }\n): Promise<T> {\n  if (signal == null) {\n    return await promise;\n  }\n\n  const { promise: aborted, reject } = promiseWithResolvers<never>();\n\n  const abortListener = signal.aborted\n    ? reject(signal.reason)\n    : addAbortListener(signal, function () {\n        reject(this.reason);\n      });\n\n  try {\n    return await Promise.race([promise, aborted]);\n  } finally {\n    abortListener?.[kDispose]();\n  }\n}\n"
        }
    ]
}