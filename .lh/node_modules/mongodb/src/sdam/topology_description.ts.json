{
    "sourceFile": "node_modules/mongodb/src/sdam/topology_description.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892637109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { EJSON, type ObjectId } from '../bson';\nimport * as WIRE_CONSTANTS from '../cmap/wire_protocol/constants';\nimport { type MongoError, MongoRuntimeError, MongoStalePrimaryError } from '../error';\nimport { compareObjectId, shuffle } from '../utils';\nimport { ServerType, TopologyType } from './common';\nimport { ServerDescription } from './server_description';\nimport type { SrvPollingEvent } from './srv_polling';\n\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\nconst MONGOS_OR_UNKNOWN = new Set<ServerType>([ServerType.Mongos, ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set<ServerType>([ServerType.Mongos, ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set<ServerType>([\n  ServerType.RSSecondary,\n  ServerType.RSArbiter,\n  ServerType.RSOther\n]);\n\n/** @public */\nexport interface TopologyDescriptionOptions {\n  heartbeatFrequencyMS?: number;\n  localThresholdMS?: number;\n}\n\n/**\n * Representation of a deployment of servers\n * @public\n */\nexport class TopologyDescription {\n  type: TopologyType;\n  setName: string | null;\n  maxSetVersion: number | null;\n  maxElectionId: ObjectId | null;\n  servers: Map<string, ServerDescription>;\n  stale: boolean;\n  compatible: boolean;\n  compatibilityError?: string;\n  logicalSessionTimeoutMinutes: number | null;\n  heartbeatFrequencyMS: number;\n  localThresholdMS: number;\n  commonWireVersion: number;\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(\n    topologyType: TopologyType,\n    serverDescriptions: Map<string, ServerDescription> | null = null,\n    setName: string | null = null,\n    maxSetVersion: number | null = null,\n    maxElectionId: ObjectId | null = null,\n    commonWireVersion: number | null = null,\n    options: TopologyDescriptionOptions | null = null\n  ) {\n    options = options ?? {};\n\n    this.type = topologyType ?? TopologyType.Unknown;\n    this.servers = serverDescriptions ?? new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;\n    this.localThresholdMS = options.localThresholdMS ?? 15;\n    this.setName = setName ?? null;\n    this.maxElectionId = maxElectionId ?? null;\n    this.maxSetVersion = maxSetVersion ?? null;\n    this.commonWireVersion = commonWireVersion ?? 0;\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (\n        serverDescription.type === ServerType.Unknown ||\n        serverDescription.type === ServerType.LoadBalancer\n      ) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from a hello response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  updateFromSrvPollingEvent(ev: SrvPollingEvent, srvMaxHosts = 0): TopologyDescription {\n    /** The SRV addresses defines the set of addresses we should be using */\n    const incomingHostnames = ev.hostnames();\n    const currentHostnames = new Set(this.servers.keys());\n\n    const hostnamesToAdd = new Set<string>(incomingHostnames);\n    const hostnamesToRemove = new Set<string>();\n    for (const hostname of currentHostnames) {\n      // filter hostnamesToAdd (made from incomingHostnames) down to what is *not* present in currentHostnames\n      hostnamesToAdd.delete(hostname);\n      if (!incomingHostnames.has(hostname)) {\n        // If the SRV Records no longer include this hostname\n        // we have to stop using it\n        hostnamesToRemove.add(hostname);\n      }\n    }\n\n    if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {\n      // No new hosts to add and none to remove\n      return this;\n    }\n\n    const serverDescriptions = new Map(this.servers);\n    for (const removedHost of hostnamesToRemove) {\n      serverDescriptions.delete(removedHost);\n    }\n\n    if (hostnamesToAdd.size > 0) {\n      if (srvMaxHosts === 0) {\n        // Add all!\n        for (const hostToAdd of hostnamesToAdd) {\n          serverDescriptions.set(hostToAdd, new ServerDescription(hostToAdd));\n        }\n      } else if (serverDescriptions.size < srvMaxHosts) {\n        // Add only the amount needed to get us back to srvMaxHosts\n        const selectedHosts = shuffle(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);\n        for (const selectedHostToAdd of selectedHosts) {\n          serverDescriptions.set(selectedHostToAdd, new ServerDescription(selectedHostToAdd));\n        }\n      }\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n  update(serverDescription: ServerDescription): TopologyDescription {\n    const address = serverDescription.address;\n\n    // potentially mutated values\n    let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    if (\n      typeof serverDescription.setName === 'string' &&\n      typeof setName === 'string' &&\n      serverDescription.setName !== setName\n    ) {\n      if (topologyType === TopologyType.Single) {\n        // \"Single\" Topology with setName mismatch is direct connection usage, mark unknown do not remove\n        serverDescription = new ServerDescription(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          serverDescription,\n          setName\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  get error(): MongoError | null {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(\n      (sd: ServerDescription) => sd.error\n    );\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return null;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers(): boolean {\n    return Array.from(this.servers.values()).some(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    );\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers(): boolean {\n    return Array.from(this.servers.values()).some((sd: ServerDescription) => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n  hasServer(address: string): boolean {\n    return this.servers.has(address);\n  }\n\n  /**\n   * Returns a JSON-serializable representation of the TopologyDescription.  This is primarily\n   * intended for use with JSON.stringify().\n   *\n   * This method will not throw.\n   */\n  toJSON() {\n    return EJSON.serialize(this);\n  }\n}\n\nfunction topologyTypeForServerType(serverType: ServerType): TopologyType {\n  switch (serverType) {\n    case ServerType.Standalone:\n      return TopologyType.Single;\n    case ServerType.Mongos:\n      return TopologyType.Sharded;\n    case ServerType.RSPrimary:\n      return TopologyType.ReplicaSetWithPrimary;\n    case ServerType.RSOther:\n    case ServerType.RSSecondary:\n      return TopologyType.ReplicaSetNoPrimary;\n    default:\n      return TopologyType.Unknown;\n  }\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null,\n  maxSetVersion: number | null = null,\n  maxElectionId: ObjectId | null = null\n): [TopologyType, string | null, number | null, ObjectId | null] {\n  const setVersionElectionIdMismatch = (\n    serverDescription: ServerDescription,\n    maxSetVersion: number | null,\n    maxElectionId: ObjectId | null\n  ) => {\n    return (\n      `primary marked stale due to electionId/setVersion mismatch:` +\n      ` server setVersion: ${serverDescription.setVersion},` +\n      ` server electionId: ${serverDescription.electionId},` +\n      ` topology setVersion: ${maxSetVersion},` +\n      ` topology electionId: ${maxElectionId}`\n    );\n  };\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  if (serverDescription.maxWireVersion >= 17) {\n    const electionIdComparison = compareObjectId(maxElectionId, serverDescription.electionId);\n    const maxElectionIdIsEqual = electionIdComparison === 0;\n    const maxElectionIdIsLess = electionIdComparison === -1;\n    const maxSetVersionIsLessOrEqual =\n      (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);\n\n    if (maxElectionIdIsLess || (maxElectionIdIsEqual && maxSetVersionIsLessOrEqual)) {\n      // The reported electionId was greater\n      // or the electionId was equal and reported setVersion was greater\n      // Always update both values, they are a tuple\n      maxElectionId = serverDescription.electionId;\n      maxSetVersion = serverDescription.setVersion;\n    } else {\n      // Stale primary\n      // replace serverDescription with a default ServerDescription of type \"Unknown\"\n      serverDescriptions.set(\n        serverDescription.address,\n        new ServerDescription(serverDescription.address, undefined, {\n          error: new MongoStalePrimaryError(\n            setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId)\n          )\n        })\n      );\n\n      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n  } else {\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n      if (maxSetVersion && maxElectionId) {\n        if (\n          maxSetVersion > serverDescription.setVersion ||\n          compareObjectId(maxElectionId, electionId) > 0\n        ) {\n          // this primary is stale, we must remove it\n          serverDescriptions.set(\n            serverDescription.address,\n            new ServerDescription(serverDescription.address, undefined, {\n              error: new MongoStalePrimaryError(\n                setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId)\n              )\n            })\n          );\n\n          return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n        }\n      }\n\n      maxElectionId = serverDescription.electionId;\n    }\n\n    if (\n      serverDescription.setVersion != null &&\n      (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n    ) {\n      maxSetVersion = serverDescription.setVersion;\n    }\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(\n        address,\n        new ServerDescription(server.address, undefined, {\n          error: new MongoStalePrimaryError(\n            'primary marked stale due to discovery of newer primary'\n          )\n        })\n      );\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter((addr: string) => responseAddresses.indexOf(addr) === -1)\n    .forEach((address: string) => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): TopologyType {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName: string | null = null\n): [TopologyType, string | null] {\n  const topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName ?? serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions: Map<string, ServerDescription>): TopologyType {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n"
        }
    ]
}