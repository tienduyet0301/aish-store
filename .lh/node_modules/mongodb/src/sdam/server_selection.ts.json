{
    "sourceFile": "node_modules/mongodb/src/sdam/server_selection.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892636870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\nimport { ReadPreference } from '../read_preference';\nimport { ServerType, TopologyType } from './common';\nimport type { ServerDescription, TagSet } from './server_description';\nimport type { TopologyDescription } from './topology_description';\n\n// max staleness constants\nconst IDLE_WRITE_PERIOD = 10000;\nconst SMALLEST_MAX_STALENESS_SECONDS = 90;\n\n//  Minimum version to try writes on secondaries.\nexport const MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n\n/** @internal */\nexport type ServerSelector = (\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[],\n  deprioritized?: ServerDescription[]\n) => ServerDescription[];\n\n/**\n * Returns a server selector that selects for writable servers\n */\nexport function writableServerSelector(): ServerSelector {\n  return function writableServer(\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] {\n    return latencyWindowReducer(\n      topologyDescription,\n      servers.filter((s: ServerDescription) => s.isWritable)\n    );\n  };\n}\n\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nexport function sameServerSelector(description?: ServerDescription): ServerSelector {\n  return function sameServerSelector(\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[]\n  ): ServerDescription[] {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(sd => {\n      return sd.address === description.address && sd.type !== ServerType.Unknown;\n    });\n  };\n}\n\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nexport function secondaryWritableServerSelector(\n  wireVersion?: number,\n  readPreference?: ReadPreference\n): ServerSelector {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (\n    !readPreference ||\n    !wireVersion ||\n    (wireVersion && wireVersion < MIN_SECONDARY_WRITE_WIRE_VERSION)\n  ) {\n    return readPreferenceServerSelector(ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\n\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here:\n *\n * @see https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.md\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(\n  readPreference: ReadPreference,\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n\n  const maxStaleness = readPreference.maxStalenessSeconds;\n  const maxStalenessVariance =\n    (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${maxStalenessVariance} seconds`\n    );\n  }\n\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new MongoInvalidArgumentError(\n      `Option \"maxStalenessSeconds\" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`\n    );\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetWithPrimary) {\n    const primary: ServerDescription = Array.from(topologyDescription.servers.values()).filter(\n      primaryFilter\n    )[0];\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        server.lastUpdateTime -\n        server.lastWriteDate -\n        (primary.lastUpdateTime - primary.lastWriteDate) +\n        topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  if (topologyDescription.type === TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n\n    const sMax = servers.reduce((max: ServerDescription, s: ServerDescription) =>\n      s.lastWriteDate > max.lastWriteDate ? s : max\n    );\n\n    return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n      const stalenessMS =\n        sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n\n      const staleness = stalenessMS / 1000;\n      const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n\n      return result;\n    }, []);\n  }\n\n  return servers;\n}\n\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet: TagSet, serverTags: TagSet) {\n  const keys = Object.keys(tagSet);\n  const serverTagKeys = Object.keys(serverTags);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(\n  readPreference: ReadPreference,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  if (\n    readPreference.tags == null ||\n    (Array.isArray(readPreference.tags) && readPreference.tags.length === 0)\n  ) {\n    return servers;\n  }\n\n  for (let i = 0; i < readPreference.tags.length; ++i) {\n    const tagSet = readPreference.tags[i];\n    const serversMatchingTagset = servers.reduce(\n      (matched: ServerDescription[], server: ServerDescription) => {\n        if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n        return matched;\n      },\n      []\n    );\n\n    if (serversMatchingTagset.length) {\n      return serversMatchingTagset;\n    }\n  }\n\n  return [];\n}\n\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n *\n * @see https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.md\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(\n  topologyDescription: TopologyDescription,\n  servers: ServerDescription[]\n): ServerDescription[] {\n  const low = servers.reduce(\n    (min: number, server: ServerDescription) => Math.min(server.roundTripTime, min),\n    Infinity\n  );\n\n  const high = low + topologyDescription.localThresholdMS;\n  return servers.reduce((result: ServerDescription[], server: ServerDescription) => {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n\n// filters\nfunction primaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSPrimary;\n}\n\nfunction secondaryFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary;\n}\n\nfunction nearestFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.RSSecondary || server.type === ServerType.RSPrimary;\n}\n\nfunction knownFilter(server: ServerDescription): boolean {\n  return server.type !== ServerType.Unknown;\n}\n\nfunction loadBalancerFilter(server: ServerDescription): boolean {\n  return server.type === ServerType.LoadBalancer;\n}\n\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nexport function readPreferenceServerSelector(readPreference: ReadPreference): ServerSelector {\n  if (!readPreference.isValid()) {\n    throw new MongoInvalidArgumentError('Invalid read preference specified');\n  }\n\n  return function readPreferenceServers(\n    topologyDescription: TopologyDescription,\n    servers: ServerDescription[],\n    deprioritized: ServerDescription[] = []\n  ): ServerDescription[] {\n    const commonWireVersion = topologyDescription.commonWireVersion;\n    if (\n      commonWireVersion &&\n      readPreference.minWireVersion &&\n      readPreference.minWireVersion > commonWireVersion\n    ) {\n      throw new MongoCompatibilityError(\n        `Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`\n      );\n    }\n\n    if (topologyDescription.type === TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n\n    if (topologyDescription.type === TopologyType.Unknown) {\n      return [];\n    }\n\n    if (topologyDescription.type === TopologyType.Single) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n\n    if (topologyDescription.type === TopologyType.Sharded) {\n      const filtered = servers.filter(server => {\n        return !deprioritized.includes(server);\n      });\n      const selectable = filtered.length > 0 ? filtered : deprioritized;\n      return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));\n    }\n\n    const mode = readPreference.mode;\n    if (mode === ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n\n    if (mode === ReadPreference.PRIMARY_PREFERRED) {\n      const result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n\n    const filter = mode === ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    const selectedServers = latencyWindowReducer(\n      topologyDescription,\n      tagSetReducer(\n        readPreference,\n        maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))\n      )\n    );\n\n    if (mode === ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n\n    return selectedServers;\n  };\n}\n"
        }
    ]
}