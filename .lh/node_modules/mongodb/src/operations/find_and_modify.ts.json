{
    "sourceFile": "node_modules/mongodb/src/operations/find_and_modify.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892635808,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport { MongoCompatibilityError, MongoInvalidArgumentError } from '../error';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { formatSort, type Sort, type SortForCmd } from '../sort';\nimport { type TimeoutContext } from '../timeout';\nimport { decorateWithCollation, hasAtomicOperators, maxWireVersion } from '../utils';\nimport { type WriteConcern, type WriteConcernSettings } from '../write_concern';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport const ReturnDocument = Object.freeze({\n  BEFORE: 'before',\n  AFTER: 'after'\n} as const);\n\n/** @public */\nexport type ReturnDocument = (typeof ReturnDocument)[keyof typeof ReturnDocument];\n\n/** @public */\nexport interface FindOneAndDeleteOptions extends CommandOperationOptions {\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @public */\nexport interface FindOneAndReplaceOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document;\n  /** When set to 'after', returns the updated document rather than the original. The default is 'before'.  */\n  returnDocument?: ReturnDocument;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Upsert the document if it does not exist. */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @public */\nexport interface FindOneAndUpdateOptions extends CommandOperationOptions {\n  /** Optional list of array filters referenced in filtered positional operators */\n  arrayFilters?: Document[];\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** An optional hint for query optimization. See the {@link https://www.mongodb.com/docs/manual/reference/command/update/#update-command-hint|update command} reference for more information.*/\n  hint?: Document;\n  /** Limits the fields to return for all matching documents. */\n  projection?: Document;\n  /** When set to 'after', returns the updated document rather than the original. The default is 'before'.  */\n  returnDocument?: ReturnDocument;\n  /** Determines which document the operation modifies if the query selects multiple documents. */\n  sort?: Sort;\n  /** Upsert the document if it does not exist. */\n  upsert?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Return the ModifyResult instead of the modified document. Defaults to false\n   */\n  includeResultMetadata?: boolean;\n}\n\n/** @internal */\ninterface FindAndModifyCmdBase {\n  remove: boolean;\n  new: boolean;\n  upsert: boolean;\n  update?: Document;\n  sort?: SortForCmd;\n  fields?: Document;\n  bypassDocumentValidation?: boolean;\n  arrayFilters?: Document[];\n  maxTimeMS?: number;\n  let?: Document;\n  writeConcern?: WriteConcern | WriteConcernSettings;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n}\n\nfunction configureFindAndModifyCmdBaseUpdateOpts(\n  cmdBase: FindAndModifyCmdBase,\n  options: FindOneAndReplaceOptions | FindOneAndUpdateOptions\n): FindAndModifyCmdBase {\n  cmdBase.new = options.returnDocument === ReturnDocument.AFTER;\n  cmdBase.upsert = options.upsert === true;\n\n  if (options.bypassDocumentValidation === true) {\n    cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n  return cmdBase;\n}\n\n/** @internal */\nexport class FindAndModifyOperation extends CommandOperation<Document> {\n  override options: FindOneAndReplaceOptions | FindOneAndUpdateOptions | FindOneAndDeleteOptions;\n  cmdBase: FindAndModifyCmdBase;\n  collection: Collection;\n  query: Document;\n  doc?: Document;\n\n  constructor(\n    collection: Collection,\n    query: Document,\n    options: FindOneAndReplaceOptions | FindOneAndUpdateOptions | FindOneAndDeleteOptions\n  ) {\n    super(collection, options);\n    this.options = options ?? {};\n    this.cmdBase = {\n      remove: false,\n      new: false,\n      upsert: false\n    };\n\n    options.includeResultMetadata ??= false;\n\n    const sort = formatSort(options.sort);\n    if (sort) {\n      this.cmdBase.sort = sort;\n    }\n\n    if (options.projection) {\n      this.cmdBase.fields = options.projection;\n    }\n\n    if (options.maxTimeMS) {\n      this.cmdBase.maxTimeMS = options.maxTimeMS;\n    }\n\n    // Decorate the findAndModify command with the write Concern\n    if (options.writeConcern) {\n      this.cmdBase.writeConcern = options.writeConcern;\n    }\n\n    if (options.let) {\n      this.cmdBase.let = options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cmdBase.comment = options.comment;\n    }\n\n    // force primary read preference\n    this.readPreference = ReadPreference.primary;\n\n    this.collection = collection;\n    this.query = query;\n  }\n\n  override get commandName() {\n    return 'findAndModify' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const coll = this.collection;\n    const query = this.query;\n    const options = { ...this.options, ...this.bsonOptions };\n\n    // Create findAndModify command object\n    const cmd: Document = {\n      findAndModify: coll.collectionName,\n      query: query,\n      ...this.cmdBase\n    };\n\n    decorateWithCollation(cmd, coll, options);\n\n    if (options.hint) {\n      // TODO: once this method becomes a CommandOperation we will have the server\n      // in place to check.\n      const unacknowledgedWrite = this.writeConcern?.w === 0;\n      if (unacknowledgedWrite || maxWireVersion(server) < 8) {\n        throw new MongoCompatibilityError(\n          'The current topology does not support a hint on findAndModify commands'\n        );\n      }\n\n      cmd.hint = options.hint;\n    }\n\n    // Execute the command\n    const result = await super.executeCommand(server, session, cmd, timeoutContext);\n    return options.includeResultMetadata ? result : (result.value ?? null);\n  }\n}\n\n/** @internal */\nexport class FindOneAndDeleteOperation extends FindAndModifyOperation {\n  constructor(collection: Collection, filter: Document, options: FindOneAndDeleteOptions) {\n    // Basic validation\n    if (filter == null || typeof filter !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n\n    super(collection, filter, options);\n    this.cmdBase.remove = true;\n  }\n}\n\n/** @internal */\nexport class FindOneAndReplaceOperation extends FindAndModifyOperation {\n  constructor(\n    collection: Collection,\n    filter: Document,\n    replacement: Document,\n    options: FindOneAndReplaceOptions\n  ) {\n    if (filter == null || typeof filter !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n\n    if (replacement == null || typeof replacement !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"replacement\" must be an object');\n    }\n\n    if (hasAtomicOperators(replacement)) {\n      throw new MongoInvalidArgumentError('Replacement document must not contain atomic operators');\n    }\n\n    super(collection, filter, options);\n    this.cmdBase.update = replacement;\n    configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n  }\n}\n\n/** @internal */\nexport class FindOneAndUpdateOperation extends FindAndModifyOperation {\n  constructor(\n    collection: Collection,\n    filter: Document,\n    update: Document,\n    options: FindOneAndUpdateOptions\n  ) {\n    if (filter == null || typeof filter !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"filter\" must be an object');\n    }\n\n    if (update == null || typeof update !== 'object') {\n      throw new MongoInvalidArgumentError('Argument \"update\" must be an object');\n    }\n\n    if (!hasAtomicOperators(update)) {\n      throw new MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n\n    super(collection, filter, options);\n    this.cmdBase.update = update;\n    configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);\n\n    if (options.arrayFilters) {\n      this.cmdBase.arrayFilters = options.arrayFilters;\n    }\n  }\n}\n\ndefineAspects(FindAndModifyOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.EXPLAINABLE\n]);\n"
        }
    ]
}