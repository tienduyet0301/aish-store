{
    "sourceFile": "node_modules/mongodb/src/operations/client_bulk_write/client_bulk_write.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892635389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { MongoClientBulkWriteExecutionError, ServerType } from '../../beta';\nimport { ClientBulkWriteCursorResponse } from '../../cmap/wire_protocol/responses';\nimport type { Server } from '../../sdam/server';\nimport type { ClientSession } from '../../sessions';\nimport { type TimeoutContext } from '../../timeout';\nimport { MongoDBNamespace } from '../../utils';\nimport { CommandOperation } from '../command';\nimport { Aspect, defineAspects } from '../operation';\nimport { type ClientBulkWriteCommandBuilder } from './command_builder';\nimport { type ClientBulkWriteOptions } from './common';\n\n/**\n * Executes a single client bulk write operation within a potential batch.\n * @internal\n */\nexport class ClientBulkWriteOperation extends CommandOperation<ClientBulkWriteCursorResponse> {\n  commandBuilder: ClientBulkWriteCommandBuilder;\n  override options: ClientBulkWriteOptions;\n\n  override get commandName() {\n    return 'bulkWrite' as const;\n  }\n\n  constructor(commandBuilder: ClientBulkWriteCommandBuilder, options: ClientBulkWriteOptions) {\n    super(undefined, options);\n    this.commandBuilder = commandBuilder;\n    this.options = options;\n    this.ns = new MongoDBNamespace('admin', '$cmd');\n  }\n\n  override resetBatch(): boolean {\n    return this.commandBuilder.resetBatch();\n  }\n\n  override get canRetryWrite(): boolean {\n    return this.commandBuilder.isBatchRetryable;\n  }\n\n  /**\n   * Execute the command. Superclass will handle write concern, etc.\n   * @param server - The server.\n   * @param session - The session.\n   * @returns The response.\n   */\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<ClientBulkWriteCursorResponse> {\n    let command;\n\n    if (server.description.type === ServerType.LoadBalancer) {\n      if (session) {\n        let connection;\n        if (!session.pinnedConnection) {\n          // Checkout a connection to build the command.\n          connection = await server.pool.checkOut({ timeoutContext });\n          // Pin the connection to the session so it get used to execute the command and we do not\n          // perform a double check-in/check-out.\n          session.pin(connection);\n        } else {\n          connection = session.pinnedConnection;\n        }\n        command = this.commandBuilder.buildBatch(\n          connection.hello?.maxMessageSizeBytes,\n          connection.hello?.maxWriteBatchSize,\n          connection.hello?.maxBsonObjectSize\n        );\n      } else {\n        throw new MongoClientBulkWriteExecutionError(\n          'Session provided to the client bulk write operation must be present.'\n        );\n      }\n    } else {\n      // At this point we have a server and the auto connect code has already\n      // run in executeOperation, so the server description will be populated.\n      // We can use that to build the command.\n      if (\n        !server.description.maxWriteBatchSize ||\n        !server.description.maxMessageSizeBytes ||\n        !server.description.maxBsonObjectSize\n      ) {\n        throw new MongoClientBulkWriteExecutionError(\n          'In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.'\n        );\n      }\n      command = this.commandBuilder.buildBatch(\n        server.description.maxMessageSizeBytes,\n        server.description.maxWriteBatchSize,\n        server.description.maxBsonObjectSize\n      );\n    }\n\n    // Check after the batch is built if we cannot retry it and override the option.\n    if (!this.canRetryWrite) {\n      this.options.willRetryWrite = false;\n    }\n    return await super.executeCommand(\n      server,\n      session,\n      command,\n      timeoutContext,\n      ClientBulkWriteCursorResponse\n    );\n  }\n}\n\n// Skipping the collation as it goes on the individual ops.\ndefineAspects(ClientBulkWriteOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.SKIP_COLLATION,\n  Aspect.CURSOR_CREATING,\n  Aspect.RETRYABLE,\n  Aspect.COMMAND_BATCHING\n]);\n"
        }
    ]
}