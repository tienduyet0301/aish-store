{
    "sourceFile": "node_modules/mongodb/src/operations/client_bulk_write/results_merger.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892635488,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { MongoWriteConcernError } from '../..';\nimport { type Document } from '../../bson';\nimport { type ClientBulkWriteCursor } from '../../cursor/client_bulk_write_cursor';\nimport { MongoClientBulkWriteError } from '../../error';\nimport {\n  type ClientBulkWriteError,\n  type ClientBulkWriteOptions,\n  type ClientBulkWriteResult,\n  type ClientDeleteResult,\n  type ClientInsertOneResult,\n  type ClientUpdateResult\n} from './common';\n\n/**\n * Unacknowledged bulk writes are always the same.\n */\nconst UNACKNOWLEDGED = {\n  acknowledged: false,\n  insertedCount: 0,\n  upsertedCount: 0,\n  matchedCount: 0,\n  modifiedCount: 0,\n  deletedCount: 0,\n  insertResults: undefined,\n  updateResults: undefined,\n  deleteResults: undefined\n};\n\ninterface ClientBulkWriteResultAccumulation {\n  /**\n   * Whether the bulk write was acknowledged.\n   */\n  acknowledged: boolean;\n  /**\n   * The total number of documents inserted across all insert operations.\n   */\n  insertedCount: number;\n  /**\n   * The total number of documents upserted across all update operations.\n   */\n  upsertedCount: number;\n  /**\n   * The total number of documents matched across all update operations.\n   */\n  matchedCount: number;\n  /**\n   * The total number of documents modified across all update operations.\n   */\n  modifiedCount: number;\n  /**\n   * The total number of documents deleted across all delete operations.\n   */\n  deletedCount: number;\n  /**\n   * The results of each individual insert operation that was successfully performed.\n   */\n  insertResults?: Map<number, ClientInsertOneResult>;\n  /**\n   * The results of each individual update operation that was successfully performed.\n   */\n  updateResults?: Map<number, ClientUpdateResult>;\n  /**\n   * The results of each individual delete operation that was successfully performed.\n   */\n  deleteResults?: Map<number, ClientDeleteResult>;\n}\n\n/**\n * Merges client bulk write cursor responses together into a single result.\n * @internal\n */\nexport class ClientBulkWriteResultsMerger {\n  private result: ClientBulkWriteResultAccumulation;\n  private options: ClientBulkWriteOptions;\n  private currentBatchOffset: number;\n  writeConcernErrors: Document[];\n  writeErrors: Map<number, ClientBulkWriteError>;\n\n  /**\n   * @returns The standard unacknowledged bulk write result.\n   */\n  static unacknowledged(): ClientBulkWriteResult {\n    return UNACKNOWLEDGED;\n  }\n\n  /**\n   * Instantiate the merger.\n   * @param options - The options.\n   */\n  constructor(options: ClientBulkWriteOptions) {\n    this.options = options;\n    this.currentBatchOffset = 0;\n    this.writeConcernErrors = [];\n    this.writeErrors = new Map();\n    this.result = {\n      acknowledged: true,\n      insertedCount: 0,\n      upsertedCount: 0,\n      matchedCount: 0,\n      modifiedCount: 0,\n      deletedCount: 0,\n      insertResults: undefined,\n      updateResults: undefined,\n      deleteResults: undefined\n    };\n\n    if (options.verboseResults) {\n      this.result.insertResults = new Map<number, ClientInsertOneResult>();\n      this.result.updateResults = new Map<number, ClientUpdateResult>();\n      this.result.deleteResults = new Map<number, ClientDeleteResult>();\n    }\n  }\n\n  /**\n   * Get the bulk write result object.\n   */\n  get bulkWriteResult(): ClientBulkWriteResult {\n    return {\n      acknowledged: this.result.acknowledged,\n      insertedCount: this.result.insertedCount,\n      upsertedCount: this.result.upsertedCount,\n      matchedCount: this.result.matchedCount,\n      modifiedCount: this.result.modifiedCount,\n      deletedCount: this.result.deletedCount,\n      insertResults: this.result.insertResults,\n      updateResults: this.result.updateResults,\n      deleteResults: this.result.deleteResults\n    };\n  }\n\n  /**\n   * Merge the results in the cursor to the existing result.\n   * @param currentBatchOffset - The offset index to the original models.\n   * @param response - The cursor response.\n   * @param documents - The documents in the cursor.\n   * @returns The current result.\n   */\n  async merge(cursor: ClientBulkWriteCursor): Promise<ClientBulkWriteResult> {\n    let writeConcernErrorResult;\n    try {\n      for await (const document of cursor) {\n        // Only add to maps if ok: 1\n        if (document.ok === 1) {\n          if (this.options.verboseResults) {\n            this.processDocument(cursor, document);\n          }\n        } else {\n          // If an individual write error is encountered during an ordered bulk write, drivers MUST\n          // record the error in writeErrors and immediately throw the exception. Otherwise, drivers\n          // MUST continue to iterate the results cursor and execute any further bulkWrite batches.\n          if (this.options.ordered) {\n            const error = new MongoClientBulkWriteError({\n              message: 'Mongo client ordered bulk write encountered a write error.'\n            });\n            error.writeErrors.set(document.idx + this.currentBatchOffset, {\n              code: document.code,\n              message: document.errmsg\n            });\n            error.partialResult = this.result;\n            throw error;\n          } else {\n            this.writeErrors.set(document.idx + this.currentBatchOffset, {\n              code: document.code,\n              message: document.errmsg\n            });\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof MongoWriteConcernError) {\n        const result = error.result;\n        writeConcernErrorResult = {\n          insertedCount: result.nInserted,\n          upsertedCount: result.nUpserted,\n          matchedCount: result.nMatched,\n          modifiedCount: result.nModified,\n          deletedCount: result.nDeleted,\n          writeConcernError: result.writeConcernError\n        };\n        if (this.options.verboseResults && result.cursor.firstBatch) {\n          for (const document of result.cursor.firstBatch) {\n            if (document.ok === 1) {\n              this.processDocument(cursor, document);\n            }\n          }\n        }\n      } else {\n        throw error;\n      }\n    } finally {\n      // Update the counts from the cursor response.\n      if (cursor.response) {\n        const response = cursor.response;\n        this.incrementCounts(response);\n      }\n\n      // Increment the batch offset.\n      this.currentBatchOffset += cursor.operations.length;\n    }\n\n    // If we have write concern errors ensure they are added.\n    if (writeConcernErrorResult) {\n      const writeConcernError = writeConcernErrorResult.writeConcernError as Document;\n      this.incrementCounts(writeConcernErrorResult);\n      this.writeConcernErrors.push({\n        code: writeConcernError.code,\n        message: writeConcernError.errmsg\n      });\n    }\n\n    return this.result;\n  }\n\n  /**\n   * Process an individual document in the results.\n   * @param cursor - The cursor.\n   * @param document - The document to process.\n   */\n  private processDocument(cursor: ClientBulkWriteCursor, document: Document) {\n    // Get the corresponding operation from the command.\n    const operation = cursor.operations[document.idx];\n    // Handle insert results.\n    if ('insert' in operation) {\n      this.result.insertResults?.set(document.idx + this.currentBatchOffset, {\n        insertedId: operation.document._id\n      });\n    }\n    // Handle update results.\n    if ('update' in operation) {\n      const result: ClientUpdateResult = {\n        matchedCount: document.n,\n        modifiedCount: document.nModified ?? 0,\n        // Check if the bulk did actually upsert.\n        didUpsert: document.upserted != null\n      };\n      if (document.upserted) {\n        result.upsertedId = document.upserted._id;\n      }\n      this.result.updateResults?.set(document.idx + this.currentBatchOffset, result);\n    }\n    // Handle delete results.\n    if ('delete' in operation) {\n      this.result.deleteResults?.set(document.idx + this.currentBatchOffset, {\n        deletedCount: document.n\n      });\n    }\n  }\n\n  /**\n   * Increment the result counts.\n   * @param document - The document with the results.\n   */\n  private incrementCounts(document: Document) {\n    this.result.insertedCount += document.insertedCount;\n    this.result.upsertedCount += document.upsertedCount;\n    this.result.matchedCount += document.matchedCount;\n    this.result.modifiedCount += document.modifiedCount;\n    this.result.deletedCount += document.deletedCount;\n  }\n}\n"
        }
    ]
}