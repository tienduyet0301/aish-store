{
    "sourceFile": "node_modules/mongodb/src/operations/client_bulk_write/common.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892635442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { type Document } from '../../bson';\nimport type { Filter, OptionalId, UpdateFilter, WithoutId } from '../../mongo_types';\nimport type { CollationOptions, CommandOperationOptions } from '../../operations/command';\nimport type { Hint } from '../../operations/operation';\n\n/** @public */\nexport interface ClientBulkWriteOptions extends CommandOperationOptions {\n  /**\n   * If true, when an insert fails, don't execute the remaining writes.\n   * If false, continue with remaining inserts when one fails.\n   * @defaultValue `true` - inserts are ordered by default\n   */\n  ordered?: boolean;\n  /**\n   * Allow driver to bypass schema validation.\n   * @defaultValue `false` - documents will be validated by default\n   **/\n  bypassDocumentValidation?: boolean;\n  /** Map of parameter names and values that can be accessed using $$var (requires MongoDB 5.0). */\n  let?: Document;\n  /**\n   * Whether detailed results for each successful operation should be included in the returned\n   * BulkWriteResult.\n   */\n  verboseResults?: boolean;\n}\n\n/** @public */\nexport interface ClientWriteModel {\n  /**\n   * The namespace for the write.\n   *\n   * A namespace is a combination of the database name and the name of the collection: `<database-name>.<collection>`.\n   * All documents belong to a namespace.\n   *\n   * @see https://www.mongodb.com/docs/manual/reference/limits/#std-label-faq-dev-namespace\n   */\n  namespace: string;\n}\n\n/** @public */\nexport interface ClientInsertOneModel<TSchema> extends ClientWriteModel {\n  name: 'insertOne';\n  /** The document to insert. */\n  document: OptionalId<TSchema>;\n}\n\n/** @public */\nexport interface ClientDeleteOneModel<TSchema> extends ClientWriteModel {\n  name: 'deleteOne';\n  /**\n   * The filter used to determine if a document should be deleted.\n   * For a deleteOne operation, the first match is removed.\n   */\n  filter: Filter<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n}\n\n/** @public */\nexport interface ClientDeleteManyModel<TSchema> extends ClientWriteModel {\n  name: 'deleteMany';\n  /**\n   * The filter used to determine if a document should be deleted.\n   * For a deleteMany operation, all matches are removed.\n   */\n  filter: Filter<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n}\n\n/** @public */\nexport interface ClientReplaceOneModel<TSchema> extends ClientWriteModel {\n  name: 'replaceOne';\n  /**\n   * The filter used to determine if a document should be replaced.\n   * For a replaceOne operation, the first match is replaced.\n   */\n  filter: Filter<TSchema>;\n  /** The document with which to replace the matched document. */\n  replacement: WithoutId<TSchema>;\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\nexport interface ClientUpdateOneModel<TSchema> extends ClientWriteModel {\n  name: 'updateOne';\n  /**\n   * The filter used to determine if a document should be updated.\n   * For an updateOne operation, the first match is updated.\n   */\n  filter: Filter<TSchema>;\n  /**\n   * The modifications to apply. The value can be either:\n   * UpdateFilter<Document> - A document that contains update operator expressions,\n   * Document[] - an aggregation pipeline.\n   */\n  update: UpdateFilter<TSchema> | Document[];\n  /** A set of filters specifying to which array elements an update should apply. */\n  arrayFilters?: Document[];\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/** @public */\nexport interface ClientUpdateManyModel<TSchema> extends ClientWriteModel {\n  name: 'updateMany';\n  /**\n   * The filter used to determine if a document should be updated.\n   * For an updateMany operation, all matches are updated.\n   */\n  filter: Filter<TSchema>;\n  /**\n   * The modifications to apply. The value can be either:\n   * UpdateFilter<Document> - A document that contains update operator expressions,\n   * Document[] - an aggregation pipeline.\n   */\n  update: UpdateFilter<TSchema> | Document[];\n  /** A set of filters specifying to which array elements an update should apply. */\n  arrayFilters?: Document[];\n  /** Specifies a collation. */\n  collation?: CollationOptions;\n  /** The index to use. If specified, then the query system will only consider plans using the hinted index. */\n  hint?: Hint;\n  /** When true, creates a new document if no document matches the query. */\n  upsert?: boolean;\n}\n\n/**\n * Used to represent any of the client bulk write models that can be passed as an array\n * to MongoClient#bulkWrite.\n * @public\n */\nexport type AnyClientBulkWriteModel<TSchema extends Document> =\n  | ClientInsertOneModel<TSchema>\n  | ClientReplaceOneModel<TSchema>\n  | ClientUpdateOneModel<TSchema>\n  | ClientUpdateManyModel<TSchema>\n  | ClientDeleteOneModel<TSchema>\n  | ClientDeleteManyModel<TSchema>;\n\n/**\n * A mapping of namespace strings to collections schemas.\n * @public\n *\n * @example\n * ```ts\n * type MongoDBSchemas = {\n *   'db.books': Book;\n *   'db.authors': Author;\n * }\n *\n * const model: ClientBulkWriteModel<MongoDBSchemas> = {\n *   namespace: 'db.books'\n *   name: 'insertOne',\n *   document: { title: 'Practical MongoDB Aggregations', authorName: 3 } // error `authorName` cannot be number\n * };\n * ```\n *\n * The type of the `namespace` field narrows other parts of the BulkWriteModel to use the correct schema for type assertions.\n *\n */\nexport type ClientBulkWriteModel<\n  SchemaMap extends Record<string, Document> = Record<string, Document>\n> = {\n  [Namespace in keyof SchemaMap]: AnyClientBulkWriteModel<SchemaMap[Namespace]> & {\n    namespace: Namespace;\n  };\n}[keyof SchemaMap];\n\n/** @public */\nexport interface ClientBulkWriteResult {\n  /**\n   * Whether the bulk write was acknowledged.\n   */\n  readonly acknowledged: boolean;\n  /**\n   * The total number of documents inserted across all insert operations.\n   */\n  readonly insertedCount: number;\n  /**\n   * The total number of documents upserted across all update operations.\n   */\n  readonly upsertedCount: number;\n  /**\n   * The total number of documents matched across all update operations.\n   */\n  readonly matchedCount: number;\n  /**\n   * The total number of documents modified across all update operations.\n   */\n  readonly modifiedCount: number;\n  /**\n   * The total number of documents deleted across all delete operations.\n   */\n  readonly deletedCount: number;\n  /**\n   * The results of each individual insert operation that was successfully performed.\n   */\n  readonly insertResults?: ReadonlyMap<number, ClientInsertOneResult>;\n  /**\n   * The results of each individual update operation that was successfully performed.\n   */\n  readonly updateResults?: ReadonlyMap<number, ClientUpdateResult>;\n  /**\n   * The results of each individual delete operation that was successfully performed.\n   */\n  readonly deleteResults?: ReadonlyMap<number, ClientDeleteResult>;\n}\n\n/** @public */\nexport interface ClientBulkWriteError {\n  code: number;\n  message: string;\n}\n\n/** @public */\nexport interface ClientInsertOneResult {\n  /**\n   * The _id of the inserted document.\n   */\n  insertedId: any;\n}\n\n/** @public */\nexport interface ClientUpdateResult {\n  /**\n   * The number of documents that matched the filter.\n   */\n  matchedCount: number;\n\n  /**\n   * The number of documents that were modified.\n   */\n  modifiedCount: number;\n\n  /**\n   * The _id field of the upserted document if an upsert occurred.\n   *\n   * It MUST be possible to discern between a BSON Null upserted ID value and this field being\n   * unset. If necessary, drivers MAY add a didUpsert boolean field to differentiate between\n   * these two cases.\n   */\n  upsertedId?: any;\n\n  /**\n   * Determines if the upsert did include an _id, which includes the case of the _id being null.\n   */\n  didUpsert: boolean;\n}\n\n/** @public */\nexport interface ClientDeleteResult {\n  /**\n   * The number of documents that were deleted.\n   */\n  deletedCount: number;\n}\n"
        }
    ]
}