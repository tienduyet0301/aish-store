{
    "sourceFile": "node_modules/mongodb/src/operations/collections.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892635512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { Collection } from '../collection';\nimport type { Db } from '../db';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { AbstractOperation, type OperationOptions } from './operation';\n\nexport interface CollectionsOptions extends OperationOptions {\n  nameOnly?: boolean;\n}\n\n/** @internal */\nexport class CollectionsOperation extends AbstractOperation<Collection[]> {\n  override options: CollectionsOptions;\n  db: Db;\n\n  constructor(db: Db, options: CollectionsOptions) {\n    super(options);\n    this.options = options;\n    this.db = db;\n  }\n\n  override get commandName() {\n    return 'listCollections' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<Collection[]> {\n    // Let's get the collection names\n    const documents = await this.db\n      .listCollections(\n        {},\n        { ...this.options, nameOnly: true, readPreference: this.readPreference, session }\n      )\n      .toArray();\n    const collections: Collection[] = [];\n    for (const { name } of documents) {\n      if (!name.includes('$')) {\n        // Filter collections removing any illegal ones\n        collections.push(new Collection(this.db, name, this.db.s.options));\n      }\n    }\n    // Return the collection objects\n    return collections;\n  }\n}\n"
        }
    ]
}