{
    "sourceFile": "node_modules/mongodb/src/operations/insert.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892635889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { Document } from '../bson';\nimport type { BulkWriteOptions } from '../bulk/common';\nimport type { Collection } from '../collection';\nimport { MongoInvalidArgumentError, MongoServerError } from '../error';\nimport type { InferIdType } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type TimeoutContext } from '../timeout';\nimport { maybeAddIdToDocuments, type MongoDBNamespace } from '../utils';\nimport { WriteConcern } from '../write_concern';\nimport { BulkWriteOperation } from './bulk_write';\nimport { CommandOperation, type CommandOperationOptions } from './command';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\n/** @internal */\nexport class InsertOperation extends CommandOperation<Document> {\n  override options: BulkWriteOptions;\n  documents: Document[];\n\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\n    super(undefined, options);\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  override get commandName() {\n    return 'insert' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<Document> {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    return await super.executeCommand(server, session, command, timeoutContext);\n  }\n}\n\n/** @public */\nexport interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\n\n/** @public */\nexport interface InsertOneResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\n\nexport class InsertOneOperation extends InsertOperation {\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\n    super(collection.s.namespace, maybeAddIdToDocuments(collection, [doc], options), options);\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<InsertOneResult> {\n    const res = await super.execute(server, session, timeoutContext);\n    if (res.code) throw new MongoServerError(res);\n    if (res.writeErrors) {\n      // This should be a WriteError but we can't change it now because of error hierarchy\n      throw new MongoServerError(res.writeErrors[0]);\n    }\n\n    return {\n      acknowledged: this.writeConcern?.w !== 0,\n      insertedId: this.documents[0]._id\n    };\n  }\n}\n\n/** @public */\nexport interface InsertManyResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: { [key: number]: InferIdType<TSchema> };\n}\n\n/** @internal */\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\n  override options: BulkWriteOptions;\n  collection: Collection;\n  docs: ReadonlyArray<Document>;\n\n  constructor(collection: Collection, docs: ReadonlyArray<Document>, options: BulkWriteOptions) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  override get commandName() {\n    return 'insert' as const;\n  }\n\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined,\n    timeoutContext: TimeoutContext\n  ): Promise<InsertManyResult> {\n    const coll = this.collection;\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n    const writeConcern = WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new BulkWriteOperation(\n      coll,\n      this.docs.map(document => ({\n        insertOne: { document }\n      })),\n      options\n    );\n\n    try {\n      const res = await bulkWriteOperation.execute(server, session, timeoutContext);\n      return {\n        acknowledged: writeConcern?.w !== 0,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      };\n    } catch (err) {\n      if (err && err.message === 'Operation must be an object with an operation key') {\n        throw new MongoInvalidArgumentError(\n          'Collection.insertMany() cannot be called with an array that has null/undefined values'\n        );\n      }\n      throw err;\n    }\n  }\n}\n\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\n"
        }
    ]
}