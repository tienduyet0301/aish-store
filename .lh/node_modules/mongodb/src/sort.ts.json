{
    "sourceFile": "node_modules/mongodb/src/sort.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892637168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { MongoInvalidArgumentError } from './error';\n\n/** @public */\nexport type SortDirection =\n  | 1\n  | -1\n  | 'asc'\n  | 'desc'\n  | 'ascending'\n  | 'descending'\n  | { $meta: string };\n\n/** @public */\nexport type Sort =\n  | string\n  | Exclude<SortDirection, { $meta: string }>\n  | string[]\n  | { [key: string]: SortDirection }\n  | Map<string, SortDirection>\n  | [string, SortDirection][]\n  | [string, SortDirection];\n\n/** Below stricter types were created for sort that correspond with type that the cmd takes  */\n\n/** @internal */\nexport type SortDirectionForCmd = 1 | -1 | { $meta: string };\n\n/** @internal */\nexport type SortForCmd = Map<string, SortDirectionForCmd>;\n\n/** @internal */\ntype SortPairForCmd = [string, SortDirectionForCmd];\n\n/** @internal */\nfunction prepareDirection(direction: any = 1): SortDirectionForCmd {\n  const value = `${direction}`.toLowerCase();\n  if (isMeta(direction)) return direction;\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n  }\n}\n\n/** @internal */\nfunction isMeta(t: SortDirection): t is { $meta: string } {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n\n/** @internal */\nfunction isPair(t: Sort): t is [string, SortDirection] {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  return false;\n}\n\nfunction isDeep(t: Sort): t is [string, SortDirection][] {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\n\nfunction isMap(t: Sort): t is Map<string, SortDirection> {\n  return t instanceof Map && t.size > 0;\n}\n\n/** @internal */\nfunction pairToMap(v: [string, SortDirection]): SortForCmd {\n  return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n\n/** @internal */\nfunction deepToMap(t: [string, SortDirection][]): SortForCmd {\n  const sortEntries: SortPairForCmd[] = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction stringsToMap(t: string[]): SortForCmd {\n  const sortEntries: SortPairForCmd[] = t.map(key => [`${key}`, 1]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction objectToMap(t: { [key: string]: SortDirection }): SortForCmd {\n  const sortEntries: SortPairForCmd[] = Object.entries(t).map(([k, v]) => [\n    `${k}`,\n    prepareDirection(v)\n  ]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction mapToMap(t: Map<string, SortDirection>): SortForCmd {\n  const sortEntries: SortPairForCmd[] = Array.from(t).map(([k, v]) => [\n    `${k}`,\n    prepareDirection(v)\n  ]);\n  return new Map(sortEntries);\n}\n\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\nexport function formatSort(\n  sort: Sort | undefined,\n  direction?: SortDirection\n): SortForCmd | undefined {\n  if (sort == null) return undefined;\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);\n  if (typeof sort !== 'object') {\n    throw new MongoInvalidArgumentError(\n      `Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`\n    );\n  }\n  if (!Array.isArray(sort)) {\n    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;\n  }\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort);\n  if (isPair(sort)) return pairToMap(sort);\n  return stringsToMap(sort);\n}\n"
        }
    ]
}