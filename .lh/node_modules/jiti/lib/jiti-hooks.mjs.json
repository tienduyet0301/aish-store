{
    "sourceFile": "node_modules/jiti/lib/jiti-hooks.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892355657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { dirname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { existsSync } from \"node:fs\";\nimport { readFile } from \"node:fs/promises\";\nimport { isBuiltin } from \"node:module\";\nimport { createJiti } from \"./jiti.mjs\";\n\nlet jiti;\n\n// https://nodejs.org/api/module.html#initialize\nexport async function initialize() {\n  jiti = createJiti();\n}\n\n// https://nodejs.org/api/module.html#resolvespecifier-context-nextresolve\nexport async function resolve(specifier, context, nextResolve) {\n  if (_shouldSkip(specifier)) {\n    return nextResolve(specifier, context);\n  }\n  const resolvedPath = jiti.esmResolve(specifier, {\n    parentURL: context?.parentURL,\n    conditions: context?.conditions,\n  });\n  return {\n    url: resolvedPath,\n    shortCircuit: true,\n  };\n}\n\n// https://nodejs.org/api/module.html#loadurl-context-nextload\nexport async function load(url, context, nextLoad) {\n  if (_shouldSkip(url)) {\n    return nextLoad(url, context);\n  }\n\n  const filename = fileURLToPath(url);\n\n  if (url.endsWith(\".js\")) {\n    const pkg = await _findClosestPackageJson(dirname(filename));\n    if (pkg && pkg.type === \"module\") {\n      return nextLoad(url, context);\n    }\n  }\n\n  const rawSource = await readFile(filename, \"utf8\");\n\n  if (url.endsWith(\".json\")) {\n    return {\n      source: `export default ${rawSource}`,\n      format: \"module\",\n      shortCircuit: true,\n    };\n  }\n\n  const transpiledSource = jiti.transform({\n    source: rawSource,\n    filename: filename,\n    ts: url.endsWith(\"ts\"),\n    retainLines: true,\n    async: true,\n    jsx: jiti.options.jsx,\n  });\n\n  if (url.endsWith(\".js\") && !transpiledSource.includes(\"jitiImport\")) {\n    return {\n      source: transpiledSource,\n      format: \"commonjs\",\n      shortCircuit: true,\n    };\n  }\n\n  return {\n    source: _wrapSource(transpiledSource, filename),\n    format: \"module\",\n    shortCircuit: true,\n  };\n}\n\nfunction _wrapSource(source, filename) {\n  const _jitiPath = new URL(\"jiti.mjs\", import.meta.url).href;\n  return /*js*/ `import { createJiti as __createJiti__ } from ${JSON.stringify(_jitiPath)};async function _module(exports, require, module, __filename, __dirname, jitiImport) { ${source}\\n};\n// GENERATED BY JITI ESM LOADER\nconst filename = ${JSON.stringify(filename)};\nconst dirname = ${JSON.stringify(dirname(filename))};\nconst jiti = __createJiti__(filename);\nconst module = { exports: Object.create(null) };\nawait _module(module.exports, jiti, module, filename, dirname, jiti.import);\nif (module.exports && module.exports.__JITI_ERROR__) {\n  const { filename, line, column, code, message } =\n  module.exports.__JITI_ERROR__;\n  const loc = [filename, line, column].join(':');\n  const err = new Error(code + \": \" + message + \" \" + loc);\n  Error.captureStackTrace(err, _module);\n  throw err;\n}\nexport default module.exports;\n  `;\n}\n\nfunction _shouldSkip(url) {\n  return (\n    !jiti ||\n    url.endsWith(\".mjs\") ||\n    url.endsWith(\".cjs\") ||\n    (!url.startsWith(\"./\") && !url.startsWith(\"file://\")) ||\n    isBuiltin(url)\n  );\n}\n\nasync function _findClosestPackageJson(dir) {\n  if (dir === \"/\") return null;\n  const packageJsonPath = join(dir, \"package.json\");\n  if (existsSync(packageJsonPath)) {\n    return JSON.parse(await readFile(packageJsonPath, \"utf8\"));\n  }\n  return _findClosestPackageJson(dirname(dir));\n}\n"
        }
    ]
}