{
    "sourceFile": "node_modules/fast-glob/out/utils/pattern.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892291470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n/**\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\n * The latter is due to the presence of the device path at the beginning of the UNC path.\n */\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\nfunction isStaticPattern(pattern, options = {}) {\n    return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n    /**\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n     * An empty string cannot be a dynamic pattern.\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n     */\n    if (pattern === '') {\n        return false;\n    }\n    /**\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n     * filepath directly (without read directory).\n     */\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n    }\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n    }\n    return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n    const openingBraceIndex = pattern.indexOf('{');\n    if (openingBraceIndex === -1) {\n        return false;\n    }\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n    if (closingBraceIndex === -1) {\n        return false;\n    }\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n    return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n    return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern, { flipBackslashes: false });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n    return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n    const basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n    return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n    }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n    const patterns = micromatch.braces(pattern, { expand: true, nodupes: true });\n    /**\n     * Sort the patterns by length so that the same depth patterns are processed side by side.\n     * `a/{b,}/{c,}/*` â€“ `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`\n     */\n    patterns.sort((a, b) => a.length - b.length);\n    /**\n     * Micromatch can return an empty string in the case of patterns like `{a,}`.\n     */\n    return patterns.filter((pattern) => pattern !== '');\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\n    /**\n     * The scan method returns an empty array in some cases.\n     * See micromatch/picomatch#58 for more details.\n     */\n    if (parts.length === 0) {\n        parts = [pattern];\n    }\n    /**\n     * The scan method does not return an empty part for the pattern with a forward slash.\n     * This is another part of micromatch/picomatch#58.\n     */\n    if (parts[0].startsWith('/')) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift('');\n    }\n    return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map((pattern) => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n    return patternsRe.some((patternRe) => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n/**\n * This package only works with forward slashes as a path separator.\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\n */\nfunction removeDuplicateSlashes(pattern) {\n    return pattern.replace(DOUBLE_SLASH_RE, '/');\n}\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\n"
        }
    ]
}