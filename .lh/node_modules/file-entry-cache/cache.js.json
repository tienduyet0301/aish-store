{
    "sourceFile": "node_modules/file-entry-cache/cache.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892294356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var path = require('path');\nvar crypto = require('crypto');\n\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n    var flatCache = require('flat-cache');\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys();\n      // remove not found entries\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n\n    removeNotFoundFiles();\n\n    return {\n      /**\n       * the flat cache storage used to persist the metadata of the `files\n       * @type {Object}\n       */\n      cache: cache,\n\n      /**\n       * Given a buffer, calculate md5 hash of its content.\n       * @method getHash\n       * @param  {Buffer} buffer   buffer to calculate hash on\n       * @return {String}          content hash digest\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n\n      /**\n       * Return whether or not a file has changed since last time reconcile was called.\n       * @method hasFileChanged\n       * @param  {String}  file  the filepath to check\n       * @return {Boolean}       wheter or not the file has changed\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n\n      /**\n       * given an array of file paths it return and object with three arrays:\n       *  - changedFiles: Files that changed since previous run\n       *  - notChangedFiles: Files that haven't change\n       *  - notFoundFiles: Files that were not found, probably deleted\n       *\n       * @param  {Array} files the files to analyze and compare to the previous seen files\n       * @return {[type]}       [description]\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: [],\n        };\n\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n\n      getFileDescriptor: function (file) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return { key: file, notFound: true, err: ex };\n        }\n\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if (!meta) {\n          meta = { size: cSize, mtime: cTime };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = (normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta,\n        });\n\n        return nEntry;\n      },\n\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n\n        var contentBuffer;\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n\n        if (!meta) {\n          meta = { hash: hash };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = (normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta,\n        });\n\n        return nEntry;\n      },\n\n      /**\n       * Return the list o the files that changed compared\n       * against the ones stored in the cache\n       *\n       * @method getUpdated\n       * @param files {Array} the array of files to compare against the ones in the cache\n       * @returns {Array}\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n\n        return me\n          .normalizeEntries(files)\n          .filter(function (entry) {\n            return entry.changed;\n          })\n          .map(function (entry) {\n            return entry.key;\n          });\n      },\n\n      /**\n       * return the list of files\n       * @method normalizeEntries\n       * @param files\n       * @returns {*}\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        });\n\n        //normalizeEntries = nEntries;\n        return nEntries;\n      },\n\n      /**\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\n       * modified the next time the process is run\n       *\n       * @method removeEntry\n       * @param entryName\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n\n      /**\n       * Delete the cache file from the disk\n       * @method deleteCacheFile\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\n       * remove the cache from the file and clear the memory cache\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, { hash: hash });\n        delete meta.size;\n        delete meta.mtime;\n        return meta;\n      },\n\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime(),\n        });\n        delete meta.hash;\n        return meta;\n      },\n\n      /**\n       * Sync the files and persist them to the cache\n       * @method reconcile\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n\n        if (keys.length === 0) {\n          return;\n        }\n\n        var me = this;\n\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n\n          try {\n            var meta = useChecksum\n              ? me._getMetaForFileUsingCheckSum(cacheEntry)\n              : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n\n        cache.save(noPrune);\n      },\n    };\n  },\n};\n"
        }
    ]
}