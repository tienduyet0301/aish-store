{
    "sourceFile": "node_modules/eslint-module-utils/moduleVisitor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892248028,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nexports.__esModule = true;\n\n/** @typedef {import('estree').Node} Node */\n/** @typedef {{ arguments: import('estree').CallExpression['arguments'], callee: Node }} Call */\n/** @typedef {import('estree').ImportDeclaration | import('estree').ExportNamedDeclaration | import('estree').ExportAllDeclaration} Declaration */\n\n/**\n * Returns an object of node visitors that will call\n * 'visitor' with every discovered module path.\n *\n * @type {(import('./moduleVisitor').default)}\n */\nexports.default = function visitModules(visitor, options) {\n  const ignore = options && options.ignore;\n  const amd = !!(options && options.amd);\n  const commonjs = !!(options && options.commonjs);\n  // if esmodule is not explicitly disabled, it is assumed to be enabled\n  const esmodule = !!Object.assign({ esmodule: true }, options).esmodule;\n\n  const ignoreRegExps = ignore == null ? [] : ignore.map((p) => new RegExp(p));\n\n  /** @type {(source: undefined | null | import('estree').Literal, importer: Parameters<typeof visitor>[1]) => void} */\n  function checkSourceValue(source, importer) {\n    if (source == null) { return; } //?\n\n    // handle ignore\n    if (ignoreRegExps.some((re) => re.test(String(source.value)))) { return; }\n\n    // fire visitor\n    visitor(source, importer);\n  }\n\n  // for import-y declarations\n  /** @type {(node: Declaration) => void} */\n  function checkSource(node) {\n    checkSourceValue(node.source, node);\n  }\n\n  // for esmodule dynamic `import()` calls\n  /** @type {(node: import('estree').ImportExpression | import('estree').CallExpression) => void} */\n  function checkImportCall(node) {\n    /** @type {import('estree').Expression | import('estree').Literal | import('estree').CallExpression['arguments'][0]} */\n    let modulePath;\n    // refs https://github.com/estree/estree/blob/HEAD/es2020.md#importexpression\n    if (node.type === 'ImportExpression') {\n      modulePath = node.source;\n    } else if (node.type === 'CallExpression') {\n      // @ts-expect-error this structure is from an older version of eslint\n      if (node.callee.type !== 'Import') { return; }\n      if (node.arguments.length !== 1) { return; }\n\n      modulePath = node.arguments[0];\n    } else {\n      throw new TypeError('this should be unreachable');\n    }\n\n    if (modulePath.type !== 'Literal') { return; }\n    if (typeof modulePath.value !== 'string') { return; }\n\n    checkSourceValue(modulePath, node);\n  }\n\n  // for CommonJS `require` calls\n  // adapted from @mctep: https://git.io/v4rAu\n  /** @type {(call: Call) => void} */\n  function checkCommon(call) {\n    if (call.callee.type !== 'Identifier') { return; }\n    if (call.callee.name !== 'require') { return; }\n    if (call.arguments.length !== 1) { return; }\n\n    const modulePath = call.arguments[0];\n    if (modulePath.type !== 'Literal') { return; }\n    if (typeof modulePath.value !== 'string') { return; }\n\n    checkSourceValue(modulePath, call);\n  }\n\n  /** @type {(call: Call) => void} */\n  function checkAMD(call) {\n    if (call.callee.type !== 'Identifier') { return; }\n    if (call.callee.name !== 'require' && call.callee.name !== 'define') { return; }\n    if (call.arguments.length !== 2) { return; }\n\n    const modules = call.arguments[0];\n    if (modules.type !== 'ArrayExpression') { return; }\n\n    for (const element of modules.elements) {\n      if (!element) { continue; }\n      if (element.type !== 'Literal') { continue; }\n      if (typeof element.value !== 'string') { continue; }\n\n      if (\n        element.value === 'require'\n        || element.value === 'exports'\n      ) {\n        continue; // magic modules: https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#magic-modules\n      }\n\n      checkSourceValue(element, element);\n    }\n  }\n\n  const visitors = {};\n  if (esmodule) {\n    Object.assign(visitors, {\n      ImportDeclaration: checkSource,\n      ExportNamedDeclaration: checkSource,\n      ExportAllDeclaration: checkSource,\n      CallExpression: checkImportCall,\n      ImportExpression: checkImportCall,\n    });\n  }\n\n  if (commonjs || amd) {\n    const currentCallExpression = visitors.CallExpression;\n    visitors.CallExpression = /** @type {(call: Call) => void} */ function (call) {\n      if (currentCallExpression) { currentCallExpression(call); }\n      if (commonjs) { checkCommon(call); }\n      if (amd) { checkAMD(call); }\n    };\n  }\n\n  return visitors;\n};\n\n/**\n * make an options schema for the module visitor, optionally adding extra fields.\n * @type {import('./moduleVisitor').makeOptionsSchema}\n */\nfunction makeOptionsSchema(additionalProperties) {\n  /** @type {import('./moduleVisitor').Schema} */\n  const base =  {\n    type: 'object',\n    properties: {\n      commonjs: { type: 'boolean' },\n      amd: { type: 'boolean' },\n      esmodule: { type: 'boolean' },\n      ignore: {\n        type: 'array',\n        minItems: 1,\n        items: { type: 'string' },\n        uniqueItems: true,\n      },\n    },\n    additionalProperties: false,\n  };\n\n  if (additionalProperties) {\n    for (const key in additionalProperties) {\n      // @ts-expect-error TS always has trouble with arbitrary object assignment/mutation\n      base.properties[key] = additionalProperties[key];\n    }\n  }\n\n  return base;\n}\nexports.makeOptionsSchema = makeOptionsSchema;\n\n/**\n * json schema object for options parameter. can be used to build rule options schema object.\n */\nexports.optionsSchema = makeOptionsSchema();\n"
        }
    ]
}