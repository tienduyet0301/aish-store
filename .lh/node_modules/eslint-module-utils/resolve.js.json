{
    "sourceFile": "node_modules/eslint-module-utils/resolve.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892249014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nexports.__esModule = true;\n\nconst fs = require('fs');\nconst Module = require('module');\nconst path = require('path');\nconst { getPhysicalFilename } = require('./contextCompat');\n\nconst hashObject = require('./hash').hashObject;\nconst ModuleCache = require('./ModuleCache').default;\nconst pkgDir = require('./pkgDir').default;\n\nconst CASE_SENSITIVE_FS = !fs.existsSync(path.join(__dirname.toUpperCase(), 'reSOLVE.js'));\nexports.CASE_SENSITIVE_FS = CASE_SENSITIVE_FS;\n\nconst ERROR_NAME = 'EslintPluginImportResolveError';\n\nconst fileExistsCache = new ModuleCache();\n\n// Polyfill Node's `Module.createRequireFromPath` if not present (added in Node v10.12.0)\n// Use `Module.createRequire` if available (added in Node v12.2.0)\nconst createRequire = Module.createRequire\n  // @ts-expect-error this only exists in older node\n  || Module.createRequireFromPath\n  || /** @type {(filename: string) => unknown} */ function (filename) {\n    const mod = new Module(filename, void null);\n    mod.filename = filename;\n    // @ts-expect-error _nodeModulePaths is undocumented\n    mod.paths = Module._nodeModulePaths(path.dirname(filename));\n\n    // @ts-expect-error _compile is undocumented\n    mod._compile(`module.exports = require;`, filename);\n\n    return mod.exports;\n  };\n\n/** @type {(resolver: object) => resolver is import('./resolve').Resolver} */\nfunction isResolverValid(resolver) {\n  if ('interfaceVersion' in resolver && resolver.interfaceVersion === 2) {\n    return 'resolve' in resolver && !!resolver.resolve && typeof resolver.resolve === 'function';\n  }\n  return 'resolveImport' in resolver && !!resolver.resolveImport && typeof resolver.resolveImport === 'function';\n}\n\n/** @type {<T extends string>(target: T, sourceFile?: string | null | undefined) => undefined | ReturnType<typeof require>} */\nfunction tryRequire(target, sourceFile) {\n  let resolved;\n  try {\n    // Check if the target exists\n    if (sourceFile != null) {\n      try {\n        resolved = createRequire(path.resolve(sourceFile)).resolve(target);\n      } catch (e) {\n        resolved = require.resolve(target);\n      }\n    } else {\n      resolved = require.resolve(target);\n    }\n  } catch (e) {\n    // If the target does not exist then just return undefined\n    return undefined;\n  }\n\n  // If the target exists then return the loaded module\n  return require(resolved);\n}\n\n/** @type {<T extends Map<string, unknown>>(resolvers: string[] | string | { [k: string]: string }, map: T) => T} */\nfunction resolverReducer(resolvers, map) {\n  if (Array.isArray(resolvers)) {\n    resolvers.forEach((r) => resolverReducer(r, map));\n    return map;\n  }\n\n  if (typeof resolvers === 'string') {\n    map.set(resolvers, null);\n    return map;\n  }\n\n  if (typeof resolvers === 'object') {\n    for (const key in resolvers) {\n      map.set(key, resolvers[key]);\n    }\n    return map;\n  }\n\n  const err = new Error('invalid resolver config');\n  err.name = ERROR_NAME;\n  throw err;\n}\n\n/** @type {(sourceFile: string) => string} */\nfunction getBaseDir(sourceFile) {\n  return pkgDir(sourceFile) || process.cwd();\n}\n\n/** @type {(name: string, sourceFile: string) => import('./resolve').Resolver} */\nfunction requireResolver(name, sourceFile) {\n  // Try to resolve package with conventional name\n  const resolver = tryRequire(`eslint-import-resolver-${name}`, sourceFile)\n    || tryRequire(name, sourceFile)\n    || tryRequire(path.resolve(getBaseDir(sourceFile), name));\n\n  if (!resolver) {\n    const err = new Error(`unable to load resolver \"${name}\".`);\n    err.name = ERROR_NAME;\n    throw err;\n  }\n  if (!isResolverValid(resolver)) {\n    const err = new Error(`${name} with invalid interface loaded as resolver`);\n    err.name = ERROR_NAME;\n    throw err;\n  }\n\n  return resolver;\n}\n\n// https://stackoverflow.com/a/27382838\n/** @type {import('./resolve').fileExistsWithCaseSync} */\nexports.fileExistsWithCaseSync = function fileExistsWithCaseSync(filepath, cacheSettings, strict) {\n  // don't care if the FS is case-sensitive\n  if (CASE_SENSITIVE_FS) { return true; }\n\n  // null means it resolved to a builtin\n  if (filepath === null) { return true; }\n  if (filepath.toLowerCase() === process.cwd().toLowerCase() && !strict) { return true; }\n  const parsedPath = path.parse(filepath);\n  const dir = parsedPath.dir;\n\n  let result = fileExistsCache.get(filepath, cacheSettings);\n  if (result != null) { return result; }\n\n  // base case\n  if (dir === '' || parsedPath.root === filepath) {\n    result = true;\n  } else {\n    const filenames = fs.readdirSync(dir);\n    if (filenames.indexOf(parsedPath.base) === -1) {\n      result = false;\n    } else {\n      result = fileExistsWithCaseSync(dir, cacheSettings, strict);\n    }\n  }\n  fileExistsCache.set(filepath, result);\n  return result;\n};\n\n/** @type {import('./types').ESLintSettings | null} */\nlet prevSettings = null;\nlet memoizedHash = '';\n/** @type {(modulePath: string, sourceFile: string, settings: import('./types').ESLintSettings) => import('./resolve').ResolvedResult} */\nfunction fullResolve(modulePath, sourceFile, settings) {\n  // check if this is a bonus core module\n  const coreSet = new Set(settings['import/core-modules']);\n  if (coreSet.has(modulePath)) { return { found: true, path: null }; }\n\n  const sourceDir = path.dirname(sourceFile);\n\n  if (prevSettings !== settings) {\n    memoizedHash = hashObject(settings).digest('hex');\n    prevSettings = settings;\n  }\n\n  const cacheKey = sourceDir + memoizedHash + modulePath;\n\n  const cacheSettings = ModuleCache.getSettings(settings);\n\n  const cachedPath = fileExistsCache.get(cacheKey, cacheSettings);\n  if (cachedPath !== undefined) { return { found: true, path: cachedPath }; }\n\n  /** @type {(resolvedPath: string | null) => void} */\n  function cache(resolvedPath) {\n    fileExistsCache.set(cacheKey, resolvedPath);\n  }\n\n  /** @type {(resolver: import('./resolve').Resolver, config: unknown) => import('./resolve').ResolvedResult} */\n  function withResolver(resolver, config) {\n    if (resolver.interfaceVersion === 2) {\n      return resolver.resolve(modulePath, sourceFile, config);\n    }\n\n    try {\n      const resolved = resolver.resolveImport(modulePath, sourceFile, config);\n      if (resolved === undefined) { return { found: false }; }\n      return { found: true, path: resolved };\n    } catch (err) {\n      return { found: false };\n    }\n  }\n\n  const configResolvers = settings['import/resolver']\n    || { node: settings['import/resolve'] }; // backward compatibility\n\n  const resolvers = resolverReducer(configResolvers, new Map());\n\n  for (const pair of resolvers) {\n    const name = pair[0];\n    const config = pair[1];\n    const resolver = requireResolver(name, sourceFile);\n    const resolved = withResolver(resolver, config);\n\n    if (!resolved.found) { continue; }\n\n    // else, counts\n    cache(resolved.path);\n    return resolved;\n  }\n\n  // failed\n  // cache(undefined)\n  return { found: false };\n}\n\n/** @type {import('./resolve').relative} */\nfunction relative(modulePath, sourceFile, settings) {\n  return fullResolve(modulePath, sourceFile, settings).path;\n}\nexports.relative = relative;\n\n/** @type {Set<import('eslint').Rule.RuleContext>} */\nconst erroredContexts = new Set();\n\n/**\n * Given\n * @param p - module path\n * @param context - ESLint context\n * @return - the full module filesystem path; null if package is core; undefined if not found\n * @type {import('./resolve').default}\n */\nfunction resolve(p, context) {\n  try {\n    return relative(p, getPhysicalFilename(context), context.settings);\n  } catch (err) {\n    if (!erroredContexts.has(context)) {\n      // The `err.stack` string starts with `err.name` followed by colon and `err.message`.\n      // We're filtering out the default `err.name` because it adds little value to the message.\n      // @ts-expect-error this might be an Error\n      let errMessage = err.message;\n      // @ts-expect-error this might be an Error\n      if (err.name !== ERROR_NAME && err.stack) {\n        // @ts-expect-error this might be an Error\n        errMessage = err.stack.replace(/^Error: /, '');\n      }\n      context.report({\n        message: `Resolve error: ${errMessage}`,\n        loc: { line: 1, column: 0 },\n      });\n      erroredContexts.add(context);\n    }\n  }\n}\nresolve.relative = relative;\nexports.default = resolve;\n"
        }
    ]
}