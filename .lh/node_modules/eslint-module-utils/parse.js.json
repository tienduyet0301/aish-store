{
    "sourceFile": "node_modules/eslint-module-utils/parse.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892248625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nexports.__esModule = true;\n\n/** @typedef {`.${string}`} Extension  */\n/** @typedef {NonNullable<import('eslint').Rule.RuleContext['settings']> & { 'import/extensions'?: Extension[], 'import/parsers'?: { [k: string]: Extension[] }, 'import/cache'?: { lifetime: number | 'âˆž' | 'Infinity' } }} ESLintSettings */\n\nconst moduleRequire = require('./module-require').default;\nconst extname = require('path').extname;\nconst fs = require('fs');\n\nconst log = require('debug')('eslint-plugin-import:parse');\n\n/** @type {(parserPath: NonNullable<import('eslint').Rule.RuleContext['parserPath']>) => unknown} */\nfunction getBabelEslintVisitorKeys(parserPath) {\n  if (parserPath.endsWith('index.js')) {\n    const hypotheticalLocation = parserPath.replace('index.js', 'visitor-keys.js');\n    if (fs.existsSync(hypotheticalLocation)) {\n      const keys = moduleRequire(hypotheticalLocation);\n      return keys.default || keys;\n    }\n  }\n  return null;\n}\n\n/** @type {(parserPath: import('eslint').Rule.RuleContext['parserPath'], parserInstance: { VisitorKeys: unknown }, parsedResult?: { visitorKeys?: unknown }) => unknown} */\nfunction keysFromParser(parserPath, parserInstance, parsedResult) {\n  // Exposed by @typescript-eslint/parser and @babel/eslint-parser\n  if (parsedResult && parsedResult.visitorKeys) {\n    return parsedResult.visitorKeys;\n  }\n  // The old babel parser doesn't have a `parseForESLint` eslint function, so we don't end\n  // up with a `parsedResult` here.  It also doesn't expose the visitor keys on the parser itself,\n  // so we have to try and infer the visitor-keys module from the parserPath.\n  // This is NOT supported in flat config!\n  if (typeof parserPath === 'string' && (/.*babel-eslint.*/).test(parserPath)) {\n    return getBabelEslintVisitorKeys(parserPath);\n  }\n  // The espree parser doesn't have the `parseForESLint` function, so we don't end up with a\n  // `parsedResult` here, but it does expose the visitor keys on the parser instance that we can use.\n  if (parserInstance && parserInstance.VisitorKeys) {\n    return parserInstance.VisitorKeys;\n  }\n  return null;\n}\n\n// this exists to smooth over the unintentional breaking change in v2.7.\n// TODO, semver-major: avoid mutating `ast` and return a plain object instead.\n/** @type {<T extends import('eslint').AST.Program>(ast: T, visitorKeys: unknown) => T} */\nfunction makeParseReturn(ast, visitorKeys) {\n  if (ast) {\n    // @ts-expect-error see TODO\n    ast.visitorKeys = visitorKeys;\n    // @ts-expect-error see TODO\n    ast.ast = ast;\n  }\n  return ast;\n}\n\n/** @type {(text: string) => string} */\nfunction stripUnicodeBOM(text) {\n  return text.charCodeAt(0) === 0xFEFF ? text.slice(1) : text;\n}\n\n/** @type {(text: string) => string} */\nfunction transformHashbang(text) {\n  return text.replace(/^#!([^\\r\\n]+)/u, (_, captured) => `//${captured}`);\n}\n\n/** @type {(path: string, context: import('eslint').Rule.RuleContext & { settings?: ESLintSettings }) => import('eslint').Rule.RuleContext['parserPath']} */\nfunction getParserPath(path, context) {\n  const parsers = context.settings['import/parsers'];\n  if (parsers != null) {\n    // eslint-disable-next-line no-extra-parens\n    const extension = /** @type {Extension} */ (extname(path));\n    for (const parserPath in parsers) {\n      if (parsers[parserPath].indexOf(extension) > -1) {\n        // use this alternate parser\n        log('using alt parser:', parserPath);\n        return parserPath;\n      }\n    }\n  }\n  // default to use ESLint parser\n  return context.parserPath;\n}\n\n/** @type {(path: string, context: import('eslint').Rule.RuleContext) => string | null | (import('eslint').Linter.ParserModule)} */\nfunction getParser(path, context) {\n  const parserPath = getParserPath(path, context);\n  if (parserPath) {\n    return parserPath;\n  }\n  if (\n    !!context.languageOptions\n    && !!context.languageOptions.parser\n    && typeof context.languageOptions.parser !== 'string'\n    && (\n      // @ts-expect-error TODO: figure out a better type\n      typeof context.languageOptions.parser.parse === 'function'\n      // @ts-expect-error TODO: figure out a better type\n      || typeof context.languageOptions.parser.parseForESLint === 'function'\n    )\n  ) {\n    return context.languageOptions.parser;\n  }\n\n  return null;\n}\n\n/** @type {import('./parse').default} */\nexports.default = function parse(path, content, context) {\n  if (context == null) { throw new Error('need context to parse properly'); }\n\n  // ESLint in \"flat\" mode only sets context.languageOptions.parserOptions\n  const languageOptions = context.languageOptions;\n  let parserOptions = languageOptions && languageOptions.parserOptions || context.parserOptions;\n  const parserOrPath = getParser(path, context);\n\n  if (!parserOrPath) { throw new Error('parserPath or languageOptions.parser is required!'); }\n\n  // hack: espree blows up with frozen options\n  parserOptions = Object.assign({}, parserOptions);\n  parserOptions.ecmaFeatures = Object.assign({}, parserOptions.ecmaFeatures);\n\n  // always include comments and tokens (for doc parsing)\n  parserOptions.comment = true;\n  parserOptions.attachComment = true;  // keeping this for backward-compat with  older parsers\n  parserOptions.tokens = true;\n\n  // attach node locations\n  parserOptions.loc = true;\n  parserOptions.range = true;\n\n  // provide the `filePath` like eslint itself does, in `parserOptions`\n  // https://github.com/eslint/eslint/blob/3ec436ee/lib/linter.js#L637\n  parserOptions.filePath = path;\n\n  // @typescript-eslint/parser will parse the entire project with typechecking if you provide\n  // \"project\" or \"projects\" in parserOptions. Removing these options means the parser will\n  // only parse one file in isolate mode, which is much, much faster.\n  // https://github.com/import-js/eslint-plugin-import/issues/1408#issuecomment-509298962\n  delete parserOptions.EXPERIMENTAL_useProjectService;\n  delete parserOptions.projectService;\n  delete parserOptions.project;\n  delete parserOptions.projects;\n\n  // If this is a flat config, we need to add ecmaVersion and sourceType (if present) from languageOptions\n  if (languageOptions && languageOptions.ecmaVersion) {\n    parserOptions.ecmaVersion = languageOptions.ecmaVersion;\n  }\n  if (languageOptions && languageOptions.sourceType) {\n    // @ts-expect-error languageOptions is from the flatConfig Linter type in 8.57 while parserOptions is not.\n    // Non-flat config parserOptions.sourceType doesn't have \"commonjs\" in the type.  Once upgraded to v9 types,\n    // they'll be the same and this expect-error should be removed.\n    parserOptions.sourceType = languageOptions.sourceType;\n  }\n\n  // require the parser relative to the main module (i.e., ESLint)\n  const parser = typeof parserOrPath === 'string' ? moduleRequire(parserOrPath) : parserOrPath;\n\n  // replicate bom strip and hashbang transform of ESLint\n  // https://github.com/eslint/eslint/blob/b93af98b3c417225a027cabc964c38e779adb945/lib/linter/linter.js#L779\n  content = transformHashbang(stripUnicodeBOM(String(content)));\n\n  if (typeof parser.parseForESLint === 'function') {\n    let ast;\n    try {\n      const parserRaw = parser.parseForESLint(content, parserOptions);\n      ast = parserRaw.ast;\n      // @ts-expect-error TODO: FIXME\n      return makeParseReturn(ast, keysFromParser(parserOrPath, parser, parserRaw));\n    } catch (e) {\n      console.warn();\n      console.warn('Error while parsing ' + parserOptions.filePath);\n      // @ts-expect-error e is almost certainly an Error here\n      console.warn('Line ' + e.lineNumber + ', column ' + e.column + ': ' + e.message);\n    }\n    if (!ast || typeof ast !== 'object') {\n      console.warn(\n        // Can only be invalid for custom parser per imports/parser\n        '`parseForESLint` from parser `' + (typeof parserOrPath === 'string' ? parserOrPath : 'context.languageOptions.parser') + '` is invalid and will just be ignored'\n      );\n    } else {\n      // @ts-expect-error TODO: FIXME\n      return makeParseReturn(ast, keysFromParser(parserOrPath, parser, undefined));\n    }\n  }\n\n  const ast = parser.parse(content, parserOptions);\n  // @ts-expect-error TODO: FIXME\n  return makeParseReturn(ast, keysFromParser(parserOrPath, parser, undefined));\n};\n"
        }
    ]
}