{
    "sourceFile": "node_modules/optionator/lib/help.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892952224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Generated by LiveScript 1.6.0\n(function(){\n  var ref$, id, find, sort, min, max, map, unlines, nameToRaw, dasherize, naturalJoin, wordWrap, wordwrap, getPreText, setHelpStyleDefaults, generateHelpForOption, generateHelp;\n  ref$ = require('prelude-ls'), id = ref$.id, find = ref$.find, sort = ref$.sort, min = ref$.min, max = ref$.max, map = ref$.map, unlines = ref$.unlines;\n  ref$ = require('./util'), nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  wordWrap = require('word-wrap');\n  wordwrap = function(a, b){\n    var ref$, indent, width;\n    ref$ = b === undefined\n      ? ['', a - 1]\n      : [repeatString$(' ', a), b - a - 1], indent = ref$[0], width = ref$[1];\n    return function(text){\n      return wordWrap(text, {\n        indent: indent,\n        width: width,\n        trim: true\n      });\n    };\n  };\n  getPreText = function(option, arg$, maxWidth){\n    var mainName, shortNames, ref$, longNames, type, description, aliasSeparator, typeSeparator, initialIndent, names, namesString, namesStringLen, typeSeparatorString, typeSeparatorStringLen, wrap;\n    mainName = option.option, shortNames = (ref$ = option.shortNames) != null\n      ? ref$\n      : [], longNames = (ref$ = option.longNames) != null\n      ? ref$\n      : [], type = option.type, description = option.description;\n    aliasSeparator = arg$.aliasSeparator, typeSeparator = arg$.typeSeparator, initialIndent = arg$.initialIndent;\n    if (option.negateName) {\n      mainName = \"no-\" + mainName;\n      if (longNames) {\n        longNames = map(function(it){\n          return \"no-\" + it;\n        }, longNames);\n      }\n    }\n    names = mainName.length === 1\n      ? [mainName].concat(shortNames, longNames)\n      : shortNames.concat([mainName], longNames);\n    namesString = map(nameToRaw, names).join(aliasSeparator);\n    namesStringLen = namesString.length;\n    typeSeparatorString = mainName === 'NUM' ? '::' : typeSeparator;\n    typeSeparatorStringLen = typeSeparatorString.length;\n    if (maxWidth != null && !option.boolean && initialIndent + namesStringLen + typeSeparatorStringLen + type.length > maxWidth) {\n      wrap = wordwrap(initialIndent + namesStringLen + typeSeparatorStringLen, maxWidth);\n      return namesString + \"\" + typeSeparatorString + wrap(type).replace(/^\\s+/, '');\n    } else {\n      return namesString + \"\" + (option.boolean\n        ? ''\n        : typeSeparatorString + \"\" + type);\n    }\n  };\n  setHelpStyleDefaults = function(helpStyle){\n    helpStyle.aliasSeparator == null && (helpStyle.aliasSeparator = ', ');\n    helpStyle.typeSeparator == null && (helpStyle.typeSeparator = ' ');\n    helpStyle.descriptionSeparator == null && (helpStyle.descriptionSeparator = '  ');\n    helpStyle.initialIndent == null && (helpStyle.initialIndent = 2);\n    helpStyle.secondaryIndent == null && (helpStyle.secondaryIndent = 4);\n    helpStyle.maxPadFactor == null && (helpStyle.maxPadFactor = 1.5);\n  };\n  generateHelpForOption = function(getOption, arg$){\n    var stdout, helpStyle, ref$;\n    stdout = arg$.stdout, helpStyle = (ref$ = arg$.helpStyle) != null\n      ? ref$\n      : {};\n    setHelpStyleDefaults(helpStyle);\n    return function(optionName){\n      var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString, exampleString, examples, seperator;\n      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;\n      wrap = maxWidth ? wordwrap(maxWidth) : id;\n      try {\n        option = getOption(dasherize(optionName));\n      } catch (e$) {\n        e = e$;\n        return e.message;\n      }\n      pre = getPreText(option, helpStyle);\n      defaultString = option['default'] && !option.negateName ? \"\\ndefault: \" + option['default'] : '';\n      restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks like an option.' : '';\n      description = option.longDescription || option.description && sentencize(option.description);\n      fullDescription = description && restPositionalString\n        ? description + \" \" + restPositionalString\n        : (that = description || restPositionalString) ? that : '';\n      preDescription = 'description:';\n      descriptionString = !fullDescription\n        ? ''\n        : maxWidth && fullDescription.length - 1 - preDescription.length > maxWidth\n          ? \"\\n\" + preDescription + \"\\n\" + wrap(fullDescription)\n          : \"\\n\" + preDescription + \" \" + fullDescription;\n      exampleString = (that = option.example) ? (examples = [].concat(that), examples.length > 1\n        ? \"\\nexamples:\\n\" + unlines(examples)\n        : \"\\nexample: \" + examples[0]) : '';\n      seperator = defaultString || descriptionString || exampleString ? \"\\n\" + repeatString$('=', pre.length) : '';\n      return pre + \"\" + seperator + defaultString + descriptionString + exampleString;\n    };\n  };\n  generateHelp = function(arg$){\n    var options, prepend, append, helpStyle, ref$, stdout, aliasSeparator, typeSeparator, descriptionSeparator, maxPadFactor, initialIndent, secondaryIndent;\n    options = arg$.options, prepend = arg$.prepend, append = arg$.append, helpStyle = (ref$ = arg$.helpStyle) != null\n      ? ref$\n      : {}, stdout = arg$.stdout;\n    setHelpStyleDefaults(helpStyle);\n    aliasSeparator = helpStyle.aliasSeparator, typeSeparator = helpStyle.typeSeparator, descriptionSeparator = helpStyle.descriptionSeparator, maxPadFactor = helpStyle.maxPadFactor, initialIndent = helpStyle.initialIndent, secondaryIndent = helpStyle.secondaryIndent;\n    return function(arg$){\n      var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre, descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen, totalLen, initialSpace, wrapAllFull, i, wrap;\n      ref$ = arg$ != null\n        ? arg$\n        : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;\n      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;\n      output = [];\n      out = function(it){\n        return output.push(it != null ? it : '');\n      };\n      if (prepend) {\n        out(interpolate ? interp(prepend, interpolate) : prepend);\n        out();\n      }\n      data = [];\n      optionCount = 0;\n      totalPreLen = 0;\n      preLens = [];\n      for (i$ = 0, len$ = (ref$ = options).length; i$ < len$; ++i$) {\n        item = ref$[i$];\n        if (showHidden || !item.hidden) {\n          if (that = item.heading) {\n            data.push({\n              type: 'heading',\n              value: that\n            });\n          } else {\n            pre = getPreText(item, helpStyle, maxWidth);\n            descParts = [];\n            if ((that = item.description) != null) {\n              descParts.push(that);\n            }\n            if (that = item['enum']) {\n              descParts.push(\"either: \" + naturalJoin(that));\n            }\n            if (item['default'] && !item.negateName) {\n              descParts.push(\"default: \" + item['default']);\n            }\n            desc = descParts.join(' - ');\n            data.push({\n              type: 'option',\n              pre: pre,\n              desc: desc,\n              descLen: desc.length\n            });\n            preLen = pre.length;\n            optionCount++;\n            totalPreLen += preLen;\n            preLens.push(preLen);\n          }\n        }\n      }\n      sortedPreLens = sort(preLens);\n      maxPreLen = sortedPreLens[sortedPreLens.length - 1];\n      preLenMean = initialIndent + totalPreLen / optionCount;\n      x = optionCount > 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;\n      for (i$ = sortedPreLens.length - 1; i$ >= 0; --i$) {\n        preLen = sortedPreLens[i$];\n        if (preLen <= x) {\n          padAmount = preLen;\n          break;\n        }\n      }\n      descSepLen = descriptionSeparator.length;\n      if (maxWidth != null) {\n        fullWrapCount = 0;\n        partialWrapCount = 0;\n        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {\n          item = data[i$];\n          if (item.type === 'option') {\n            pre = item.pre, desc = item.desc, descLen = item.descLen;\n            if (descLen === 0) {\n              item.wrap = 'none';\n            } else {\n              preLen = max(padAmount, pre.length) + initialIndent + descSepLen;\n              totalLen = preLen + descLen;\n              if (totalLen > maxWidth) {\n                if (descLen / 2.5 > maxWidth - preLen) {\n                  fullWrapCount++;\n                  item.wrap = 'full';\n                } else {\n                  partialWrapCount++;\n                  item.wrap = 'partial';\n                }\n              } else {\n                item.wrap = 'none';\n              }\n            }\n          }\n        }\n      }\n      initialSpace = repeatString$(' ', initialIndent);\n      wrapAllFull = optionCount > 1 && fullWrapCount + partialWrapCount * 0.5 > optionCount * 0.5;\n      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {\n        i = i$;\n        item = data[i$];\n        if (item.type === 'heading') {\n          if (i !== 0) {\n            out();\n          }\n          out(item.value + \":\");\n        } else {\n          pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;\n          if (maxWidth != null) {\n            if (wrapAllFull || wrap === 'full') {\n              wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);\n              out(initialSpace + \"\" + pre + \"\\n\" + wrap(desc));\n              continue;\n            } else if (wrap === 'partial') {\n              wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);\n              out(initialSpace + \"\" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\\s+/, ''));\n              continue;\n            }\n          }\n          if (descLen === 0) {\n            out(initialSpace + \"\" + pre);\n          } else {\n            out(initialSpace + \"\" + pad(pre, padAmount) + descriptionSeparator + desc);\n          }\n        }\n      }\n      if (append) {\n        out();\n        out(interpolate ? interp(append, interpolate) : append);\n      }\n      return unlines(output);\n    };\n  };\n  function pad(str, num){\n    var len, padAmount;\n    len = str.length;\n    padAmount = num - len;\n    return str + \"\" + repeatString$(' ', padAmount > 0 ? padAmount : 0);\n  }\n  function sentencize(str){\n    var first, rest, period;\n    first = str.charAt(0).toUpperCase();\n    rest = str.slice(1);\n    period = /[\\.!\\?]$/.test(str) ? '' : '.';\n    return first + \"\" + rest + period;\n  }\n  function interp(string, object){\n    return string.replace(/{{([a-zA-Z$_][a-zA-Z$_0-9]*)}}/g, function(arg$, key){\n      var ref$;\n      return (ref$ = object[key]) != null\n        ? ref$\n        : \"{{\" + key + \"}}\";\n    });\n  }\n  module.exports = {\n    generateHelp: generateHelp,\n    generateHelpForOption: generateHelpForOption\n  };\n  function repeatString$(str, n){\n    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n    return r;\n  }\n}).call(this);\n"
        }
    ]
}