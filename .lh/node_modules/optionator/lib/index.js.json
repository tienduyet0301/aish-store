{
    "sourceFile": "node_modules/optionator/lib/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892952274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Generated by LiveScript 1.6.0\n(function(){\n  var VERSION, ref$, id, map, compact, any, groupBy, partition, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, naturalJoin, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};\n  VERSION = '0.9.4';\n  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, partition = ref$.partition, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;\n  deepIs = require('deep-is');\n  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;\n  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;\n  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;\n  parseLevn = require('levn').parsedTypeParse;\n  camelizeKeys = function(obj){\n    var key, value, resultObj$ = {};\n    for (key in obj) {\n      value = obj[key];\n      resultObj$[camelize(key)] = value;\n    }\n    return resultObj$;\n  };\n  parseString = function(string){\n    var assignOpt, regex, replaceRegex, result;\n    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';\n    regex = RegExp('(?:' + assignOpt + ')?(?:\\'(?:\\\\\\\\\\'|[^\\'])+\\'|\"(?:\\\\\\\\\"|[^\"])+\")|[^\\'\"\\\\s]+', 'g');\n    replaceRegex = RegExp('^(' + assignOpt + ')?[\\'\"]([\\\\s\\\\S]*)[\\'\"]$');\n    result = map(function(it){\n      return it.replace(replaceRegex, '$1$2');\n    }, string.match(regex) || []);\n    return result;\n  };\n  main = function(libOptions){\n    var opts, defaults, required, traverse, getOption, parse;\n    opts = {};\n    defaults = {};\n    required = [];\n    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {\n      libOptions.stdout = process.stdout;\n    }\n    libOptions.positionalAnywhere == null && (libOptions.positionalAnywhere = true);\n    libOptions.typeAliases == null && (libOptions.typeAliases = {});\n    libOptions.defaults == null && (libOptions.defaults = {});\n    if (libOptions.concatRepeatedArrays != null) {\n      libOptions.defaults.concatRepeatedArrays = libOptions.concatRepeatedArrays;\n    }\n    if (libOptions.mergeRepeatedObjects != null) {\n      libOptions.defaults.mergeRepeatedObjects = libOptions.mergeRepeatedObjects;\n    }\n    traverse = function(options){\n      var i$, len$, option, name, k, ref$, v, type, that, e, parsedPossibilities, parsedType, j$, len1$, possibility, rawDependsType, dependsOpts, dependsType, cra, alias, shortNames, longNames;\n      if (toString$.call(options).slice(8, -1) !== 'Array') {\n        throw new Error('No options defined.');\n      }\n      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {\n        option = options[i$];\n        if (option.heading == null) {\n          name = option.option;\n          if (opts[name] != null) {\n            throw new Error(\"Option '\" + name + \"' already defined.\");\n          }\n          for (k in ref$ = libOptions.defaults) {\n            v = ref$[k];\n            option[k] == null && (option[k] = v);\n          }\n          if (option.type === 'Boolean') {\n            option.boolean == null && (option.boolean = true);\n          }\n          if (option.parsedType == null) {\n            if (!option.type) {\n              throw new Error(\"No type defined for option '\" + name + \"'.\");\n            }\n            try {\n              type = (that = libOptions.typeAliases[option.type]) != null\n                ? that\n                : option.type;\n              option.parsedType = parseType(type);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['default']) {\n            try {\n              defaults[name] = parseLevn(option.parsedType, option['default']);\n            } catch (e$) {\n              e = e$;\n              throw new Error(\"Option '\" + name + \"': Error parsing default value '\" + option['default'] + \"' for type '\" + option.type + \"': \" + e.message);\n            }\n          }\n          if (option['enum'] && !option.parsedPossiblities) {\n            parsedPossibilities = [];\n            parsedType = option.parsedType;\n            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {\n              possibility = ref$[j$];\n              try {\n                parsedPossibilities.push(parseLevn(parsedType, possibility));\n              } catch (e$) {\n                e = e$;\n                throw new Error(\"Option '\" + name + \"': Error parsing enum value '\" + possibility + \"' for type '\" + option.type + \"': \" + e.message);\n              }\n            }\n            option.parsedPossibilities = parsedPossibilities;\n          }\n          if (that = option.dependsOn) {\n            if (that.length) {\n              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);\n              dependsType = rawDependsType.toLowerCase();\n              if (dependsOpts.length) {\n                if (dependsType === 'and' || dependsType === 'or') {\n                  option.dependsOn = [dependsType].concat(arrayFrom$(dependsOpts));\n                } else {\n                  throw new Error(\"Option '\" + name + \"': If you have more than one dependency, you must specify either 'and' or 'or'\");\n                }\n              } else {\n                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {\n                  option.dependsOn = null;\n                } else {\n                  option.dependsOn = ['and', rawDependsType];\n                }\n              }\n            } else {\n              option.dependsOn = null;\n            }\n          }\n          if (option.required) {\n            required.push(name);\n          }\n          opts[name] = option;\n          if (option.concatRepeatedArrays != null) {\n            cra = option.concatRepeatedArrays;\n            if ('Boolean' === toString$.call(cra).slice(8, -1)) {\n              option.concatRepeatedArrays = [cra, {}];\n            } else if (cra.length === 1) {\n              option.concatRepeatedArrays = [cra[0], {}];\n            } else if (cra.length !== 2) {\n              throw new Error(\"Invalid setting for concatRepeatedArrays\");\n            }\n          }\n          if (option.alias || option.aliases) {\n            if (name === 'NUM') {\n              throw new Error(\"-NUM option can't have aliases.\");\n            }\n            if (option.alias) {\n              option.aliases == null && (option.aliases = [].concat(option.alias));\n            }\n            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {\n              alias = ref$[j$];\n              if (opts[alias] != null) {\n                throw new Error(\"Option '\" + alias + \"' already defined.\");\n              }\n              opts[alias] = option;\n            }\n            ref$ = partition(fn$, option.aliases), shortNames = ref$[0], longNames = ref$[1];\n            option.shortNames == null && (option.shortNames = shortNames);\n            option.longNames == null && (option.longNames = longNames);\n          }\n          if ((!option.aliases || option.shortNames.length === 0) && option.type === 'Boolean' && option['default'] === 'true') {\n            option.negateName = true;\n          }\n        }\n      }\n      function fn$(it){\n        return it.length === 1;\n      }\n    };\n    traverse(libOptions.options);\n    getOption = function(name){\n      var opt, possiblyMeant;\n      opt = opts[name];\n      if (opt == null) {\n        possiblyMeant = closestString(keys(opts), name);\n        throw new Error(\"Invalid option '\" + nameToRaw(name) + \"'\" + (possiblyMeant ? \" - perhaps you meant '\" + nameToRaw(possiblyMeant) + \"'?\" : '.'));\n      }\n      return opt;\n    };\n    parse = function(input, arg$){\n      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, checkProp, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, valPrime, negated, noedName;\n      slice = (arg$ != null\n        ? arg$\n        : {}).slice;\n      obj = {};\n      positional = [];\n      restPositional = false;\n      overrideRequired = false;\n      prop = null;\n      setValue = function(name, value){\n        var opt, val, cra, e, currentType;\n        opt = getOption(name);\n        if (opt.boolean) {\n          val = value;\n        } else {\n          try {\n            cra = opt.concatRepeatedArrays;\n            if (cra != null && cra[0] && cra[1].oneValuePerFlag && opt.parsedType.length === 1 && opt.parsedType[0].structure === 'array') {\n              val = [parseLevn(opt.parsedType[0].of, value)];\n            } else {\n              val = parseLevn(opt.parsedType, value);\n            }\n          } catch (e$) {\n            e = e$;\n            throw new Error(\"Invalid value for option '\" + name + \"' - expected type \" + opt.type + \", received value: \" + value + \".\");\n          }\n          if (opt['enum'] && !any(function(it){\n            return deepIs(it, val);\n          }, opt.parsedPossibilities)) {\n            throw new Error(\"Option \" + name + \": '\" + val + \"' not one of \" + naturalJoin(opt['enum']) + \".\");\n          }\n        }\n        currentType = toString$.call(obj[name]).slice(8, -1);\n        if (obj[name] != null) {\n          if (opt.concatRepeatedArrays != null && opt.concatRepeatedArrays[0] && currentType === 'Array') {\n            obj[name] = obj[name].concat(val);\n          } else if (opt.mergeRepeatedObjects && currentType === 'Object') {\n            import$(obj[name], val);\n          } else {\n            obj[name] = val;\n          }\n        } else {\n          obj[name] = val;\n        }\n        if (opt.restPositional) {\n          restPositional = true;\n        }\n        if (opt.overrideRequired) {\n          overrideRequired = true;\n        }\n      };\n      setDefaults = function(){\n        var name, ref$, value;\n        for (name in ref$ = defaults) {\n          value = ref$[name];\n          if (obj[name] == null) {\n            obj[name] = value;\n          }\n        }\n      };\n      checkRequired = function(){\n        var i$, ref$, len$, name;\n        if (overrideRequired) {\n          return;\n        }\n        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {\n          name = ref$[i$];\n          if (!obj[name]) {\n            throw new Error(\"Option \" + nameToRaw(name) + \" is required.\");\n          }\n        }\n      };\n      mutuallyExclusiveError = function(first, second){\n        throw new Error(\"The options \" + nameToRaw(first) + \" and \" + nameToRaw(second) + \" are mutually exclusive - you cannot use them at the same time.\");\n      };\n      checkMutuallyExclusive = function(){\n        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;\n        rules = libOptions.mutuallyExclusive;\n        if (!rules) {\n          return;\n        }\n        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {\n          rule = rules[i$];\n          present = null;\n          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {\n            element = rule[j$];\n            if (toString$.call(element).slice(8, -1) === 'Array') {\n              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {\n                opt = element[k$];\n                if (opt in obj) {\n                  if (present != null) {\n                    mutuallyExclusiveError(present, opt);\n                  } else {\n                    present = opt;\n                    break;\n                  }\n                }\n              }\n            } else {\n              if (element in obj) {\n                if (present != null) {\n                  mutuallyExclusiveError(present, element);\n                } else {\n                  present = element;\n                }\n              }\n            }\n          }\n        }\n      };\n      checkDependency = function(option){\n        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;\n        dependsOn = option.dependsOn;\n        if (!dependsOn || option.dependenciesMet) {\n          return true;\n        }\n        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);\n        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {\n          targetOptionName = targetOptionNames[i$];\n          targetOption = obj[targetOptionName];\n          if (targetOption && checkDependency(targetOption)) {\n            if (type === 'or') {\n              return true;\n            }\n          } else if (type === 'and') {\n            throw new Error(\"The option '\" + option.option + \"' did not have its dependencies met.\");\n          }\n        }\n        if (type === 'and') {\n          return true;\n        } else {\n          throw new Error(\"The option '\" + option.option + \"' did not meet any of its dependencies.\");\n        }\n      };\n      checkDependencies = function(){\n        var name;\n        for (name in obj) {\n          checkDependency(opts[name]);\n        }\n      };\n      checkProp = function(){\n        if (prop) {\n          throw new Error(\"Value for '\" + prop + \"' of type '\" + getOption(prop).type + \"' required.\");\n        }\n      };\n      switch (toString$.call(input).slice(8, -1)) {\n      case 'String':\n        args = parseString(input.slice(slice != null ? slice : 0));\n        break;\n      case 'Array':\n        args = input.slice(slice != null ? slice : 2);\n        break;\n      case 'Object':\n        obj = {};\n        for (key in input) {\n          value = input[key];\n          if (key !== '_') {\n            option = getOption(dasherize(key));\n            if (parsedTypeCheck(option.parsedType, value)) {\n              obj[option.option] = value;\n            } else {\n              throw new Error(\"Option '\" + option.option + \"': Invalid type for '\" + value + \"' - expected type '\" + option.type + \"'.\");\n            }\n          }\n        }\n        checkMutuallyExclusive();\n        checkDependencies();\n        setDefaults();\n        checkRequired();\n        return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;\n      default:\n        throw new Error(\"Invalid argument to 'parse': \" + input + \".\");\n      }\n      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {\n        arg = args[i$];\n        if (arg === '--') {\n          restPositional = true;\n        } else if (restPositional) {\n          positional.push(arg);\n        } else {\n          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {\n            result = that;\n            checkProp();\n            short = result[1].length === 1;\n            argName = result[2];\n            usingAssign = result[3] != null;\n            val = result[4];\n            if (usingAssign && val == null) {\n              throw new Error(\"No value for '\" + argName + \"' specified.\");\n            }\n            if (short) {\n              flags = chars(argName);\n              len = flags.length;\n              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {\n                i = j$;\n                flag = flags[j$];\n                opt = getOption(flag);\n                name = opt.option;\n                if (restPositional) {\n                  positional.push(flag);\n                } else if (i === len - 1) {\n                  if (usingAssign) {\n                    valPrime = opt.boolean ? parseLevn([{\n                      type: 'Boolean'\n                    }], val) : val;\n                    setValue(name, valPrime);\n                  } else if (opt.boolean) {\n                    setValue(name, true);\n                  } else {\n                    prop = name;\n                  }\n                } else if (opt.boolean) {\n                  setValue(name, true);\n                } else {\n                  throw new Error(\"Can't set argument '\" + flag + \"' when not last flag in a group of short flags.\");\n                }\n              }\n            } else {\n              negated = false;\n              if (that = argName.match(/^no-(.+)$/)) {\n                negated = true;\n                noedName = that[1];\n                opt = getOption(noedName);\n              } else {\n                opt = getOption(argName);\n              }\n              name = opt.option;\n              if (opt.boolean) {\n                valPrime = usingAssign ? parseLevn([{\n                  type: 'Boolean'\n                }], val) : true;\n                if (negated) {\n                  setValue(name, !valPrime);\n                } else {\n                  setValue(name, valPrime);\n                }\n              } else {\n                if (negated) {\n                  throw new Error(\"Only use 'no-' prefix for Boolean options, not with '\" + noedName + \"'.\");\n                }\n                if (usingAssign) {\n                  setValue(name, val);\n                } else {\n                  prop = name;\n                }\n              }\n            }\n          } else if (that = arg.match(/^-([0-9]+(?:\\.[0-9]+)?)$/)) {\n            opt = opts.NUM;\n            if (!opt) {\n              throw new Error('No -NUM option defined.');\n            }\n            setValue(opt.option, that[1]);\n          } else {\n            if (prop) {\n              setValue(prop, arg);\n              prop = null;\n            } else {\n              positional.push(arg);\n              if (!libOptions.positionalAnywhere) {\n                restPositional = true;\n              }\n            }\n          }\n        }\n      }\n      checkProp();\n      checkMutuallyExclusive();\n      checkDependencies();\n      setDefaults();\n      checkRequired();\n      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;\n    };\n    return {\n      parse: parse,\n      parseArgv: function(it){\n        return parse(it, {\n          slice: 2\n        });\n      },\n      generateHelp: generateHelp(libOptions),\n      generateHelpForOption: generateHelpForOption(getOption, libOptions)\n    };\n  };\n  main.VERSION = VERSION;\n  module.exports = main;\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n}).call(this);\n"
        }
    ]
}