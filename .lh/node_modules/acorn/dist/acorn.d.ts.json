{
    "sourceFile": "node_modules/acorn/dist/acorn.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892011729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "export interface Node {\n  start: number\n  end: number\n  type: string\n  range?: [number, number]\n  loc?: SourceLocation | null\n}\n\nexport interface SourceLocation {\n  source?: string | null\n  start: Position\n  end: Position\n}\n\nexport interface Position {\n  /** 1-based */\n  line: number\n  /** 0-based */\n  column: number\n}\n\nexport interface Identifier extends Node {\n  type: \"Identifier\"\n  name: string\n}\n\nexport interface Literal extends Node {\n  type: \"Literal\"\n  value?: string | boolean | null | number | RegExp | bigint\n  raw?: string\n  regex?: {\n    pattern: string\n    flags: string\n  }\n  bigint?: string\n}\n\nexport interface Program extends Node {\n  type: \"Program\"\n  body: Array<Statement | ModuleDeclaration>\n  sourceType: \"script\" | \"module\"\n}\n\nexport interface Function extends Node {\n  id?: Identifier | null\n  params: Array<Pattern>\n  body: BlockStatement | Expression\n  generator: boolean\n  expression: boolean\n  async: boolean\n}\n\nexport interface ExpressionStatement extends Node {\n  type: \"ExpressionStatement\"\n  expression: Expression | Literal\n  directive?: string\n}\n\nexport interface BlockStatement extends Node {\n  type: \"BlockStatement\"\n  body: Array<Statement>\n}\n\nexport interface EmptyStatement extends Node {\n  type: \"EmptyStatement\"\n}\n\nexport interface DebuggerStatement extends Node {\n  type: \"DebuggerStatement\"\n}\n\nexport interface WithStatement extends Node {\n  type: \"WithStatement\"\n  object: Expression\n  body: Statement\n}\n\nexport interface ReturnStatement extends Node {\n  type: \"ReturnStatement\"\n  argument?: Expression | null\n}\n\nexport interface LabeledStatement extends Node {\n  type: \"LabeledStatement\"\n  label: Identifier\n  body: Statement\n}\n\nexport interface BreakStatement extends Node {\n  type: \"BreakStatement\"\n  label?: Identifier | null\n}\n\nexport interface ContinueStatement extends Node {\n  type: \"ContinueStatement\"\n  label?: Identifier | null\n}\n\nexport interface IfStatement extends Node {\n  type: \"IfStatement\"\n  test: Expression\n  consequent: Statement\n  alternate?: Statement | null\n}\n\nexport interface SwitchStatement extends Node {\n  type: \"SwitchStatement\"\n  discriminant: Expression\n  cases: Array<SwitchCase>\n}\n\nexport interface SwitchCase extends Node {\n  type: \"SwitchCase\"\n  test?: Expression | null\n  consequent: Array<Statement>\n}\n\nexport interface ThrowStatement extends Node {\n  type: \"ThrowStatement\"\n  argument: Expression\n}\n\nexport interface TryStatement extends Node {\n  type: \"TryStatement\"\n  block: BlockStatement\n  handler?: CatchClause | null\n  finalizer?: BlockStatement | null\n}\n\nexport interface CatchClause extends Node {\n  type: \"CatchClause\"\n  param?: Pattern | null\n  body: BlockStatement\n}\n\nexport interface WhileStatement extends Node {\n  type: \"WhileStatement\"\n  test: Expression\n  body: Statement\n}\n\nexport interface DoWhileStatement extends Node {\n  type: \"DoWhileStatement\"\n  body: Statement\n  test: Expression\n}\n\nexport interface ForStatement extends Node {\n  type: \"ForStatement\"\n  init?: VariableDeclaration | Expression | null\n  test?: Expression | null\n  update?: Expression | null\n  body: Statement\n}\n\nexport interface ForInStatement extends Node {\n  type: \"ForInStatement\"\n  left: VariableDeclaration | Pattern\n  right: Expression\n  body: Statement\n}\n\nexport interface FunctionDeclaration extends Function {\n  type: \"FunctionDeclaration\"\n  id: Identifier\n  body: BlockStatement\n}\n\nexport interface VariableDeclaration extends Node {\n  type: \"VariableDeclaration\"\n  declarations: Array<VariableDeclarator>\n  kind: \"var\" | \"let\" | \"const\"\n}\n\nexport interface VariableDeclarator extends Node {\n  type: \"VariableDeclarator\"\n  id: Pattern\n  init?: Expression | null\n}\n\nexport interface ThisExpression extends Node {\n  type: \"ThisExpression\"\n}\n\nexport interface ArrayExpression extends Node {\n  type: \"ArrayExpression\"\n  elements: Array<Expression | SpreadElement | null>\n}\n\nexport interface ObjectExpression extends Node {\n  type: \"ObjectExpression\"\n  properties: Array<Property | SpreadElement>\n}\n\nexport interface Property extends Node {\n  type: \"Property\"\n  key: Expression\n  value: Expression\n  kind: \"init\" | \"get\" | \"set\"\n  method: boolean\n  shorthand: boolean\n  computed: boolean\n}\n\nexport interface FunctionExpression extends Function {\n  type: \"FunctionExpression\"\n  body: BlockStatement\n}\n\nexport interface UnaryExpression extends Node {\n  type: \"UnaryExpression\"\n  operator: UnaryOperator\n  prefix: boolean\n  argument: Expression\n}\n\nexport type UnaryOperator = \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\"\n\nexport interface UpdateExpression extends Node {\n  type: \"UpdateExpression\"\n  operator: UpdateOperator\n  argument: Expression\n  prefix: boolean\n}\n\nexport type UpdateOperator = \"++\" | \"--\"\n\nexport interface BinaryExpression extends Node {\n  type: \"BinaryExpression\"\n  operator: BinaryOperator\n  left: Expression | PrivateIdentifier\n  right: Expression\n}\n\nexport type BinaryOperator = \"==\" | \"!=\" | \"===\" | \"!==\" | \"<\" | \"<=\" | \">\" | \">=\" | \"<<\" | \">>\" | \">>>\" | \"+\" | \"-\" | \"*\" | \"/\" | \"%\" | \"|\" | \"^\" | \"&\" | \"in\" | \"instanceof\" | \"**\"\n\nexport interface AssignmentExpression extends Node {\n  type: \"AssignmentExpression\"\n  operator: AssignmentOperator\n  left: Pattern\n  right: Expression\n}\n\nexport type AssignmentOperator = \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"<<=\" | \">>=\" | \">>>=\" | \"|=\" | \"^=\" | \"&=\" | \"**=\" | \"||=\" | \"&&=\" | \"??=\"\n\nexport interface LogicalExpression extends Node {\n  type: \"LogicalExpression\"\n  operator: LogicalOperator\n  left: Expression\n  right: Expression\n}\n\nexport type LogicalOperator = \"||\" | \"&&\" | \"??\"\n\nexport interface MemberExpression extends Node {\n  type: \"MemberExpression\"\n  object: Expression | Super\n  property: Expression | PrivateIdentifier\n  computed: boolean\n  optional: boolean\n}\n\nexport interface ConditionalExpression extends Node {\n  type: \"ConditionalExpression\"\n  test: Expression\n  alternate: Expression\n  consequent: Expression\n}\n\nexport interface CallExpression extends Node {\n  type: \"CallExpression\"\n  callee: Expression | Super\n  arguments: Array<Expression | SpreadElement>\n  optional: boolean\n}\n\nexport interface NewExpression extends Node {\n  type: \"NewExpression\"\n  callee: Expression\n  arguments: Array<Expression | SpreadElement>\n}\n\nexport interface SequenceExpression extends Node {\n  type: \"SequenceExpression\"\n  expressions: Array<Expression>\n}\n\nexport interface ForOfStatement extends Node {\n  type: \"ForOfStatement\"\n  left: VariableDeclaration | Pattern\n  right: Expression\n  body: Statement\n  await: boolean\n}\n\nexport interface Super extends Node {\n  type: \"Super\"\n}\n\nexport interface SpreadElement extends Node {\n  type: \"SpreadElement\"\n  argument: Expression\n}\n\nexport interface ArrowFunctionExpression extends Function {\n  type: \"ArrowFunctionExpression\"\n}\n\nexport interface YieldExpression extends Node {\n  type: \"YieldExpression\"\n  argument?: Expression | null\n  delegate: boolean\n}\n\nexport interface TemplateLiteral extends Node {\n  type: \"TemplateLiteral\"\n  quasis: Array<TemplateElement>\n  expressions: Array<Expression>\n}\n\nexport interface TaggedTemplateExpression extends Node {\n  type: \"TaggedTemplateExpression\"\n  tag: Expression\n  quasi: TemplateLiteral\n}\n\nexport interface TemplateElement extends Node {\n  type: \"TemplateElement\"\n  tail: boolean\n  value: {\n    cooked?: string | null\n    raw: string\n  }\n}\n\nexport interface AssignmentProperty extends Node {\n  type: \"Property\"\n  key: Expression\n  value: Pattern\n  kind: \"init\"\n  method: false\n  shorthand: boolean\n  computed: boolean\n}\n\nexport interface ObjectPattern extends Node {\n  type: \"ObjectPattern\"\n  properties: Array<AssignmentProperty | RestElement>\n}\n\nexport interface ArrayPattern extends Node {\n  type: \"ArrayPattern\"\n  elements: Array<Pattern | null>\n}\n\nexport interface RestElement extends Node {\n  type: \"RestElement\"\n  argument: Pattern\n}\n\nexport interface AssignmentPattern extends Node {\n  type: \"AssignmentPattern\"\n  left: Pattern\n  right: Expression\n}\n\nexport interface Class extends Node {\n  id?: Identifier | null\n  superClass?: Expression | null\n  body: ClassBody\n}\n\nexport interface ClassBody extends Node {\n  type: \"ClassBody\"\n  body: Array<MethodDefinition | PropertyDefinition | StaticBlock>\n}\n\nexport interface MethodDefinition extends Node {\n  type: \"MethodDefinition\"\n  key: Expression | PrivateIdentifier\n  value: FunctionExpression\n  kind: \"constructor\" | \"method\" | \"get\" | \"set\"\n  computed: boolean\n  static: boolean\n}\n\nexport interface ClassDeclaration extends Class {\n  type: \"ClassDeclaration\"\n  id: Identifier\n}\n\nexport interface ClassExpression extends Class {\n  type: \"ClassExpression\"\n}\n\nexport interface MetaProperty extends Node {\n  type: \"MetaProperty\"\n  meta: Identifier\n  property: Identifier\n}\n\nexport interface ImportDeclaration extends Node {\n  type: \"ImportDeclaration\"\n  specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>\n  source: Literal\n  attributes: Array<ImportAttribute>\n}\n\nexport interface ImportSpecifier extends Node {\n  type: \"ImportSpecifier\"\n  imported: Identifier | Literal\n  local: Identifier\n}\n\nexport interface ImportDefaultSpecifier extends Node {\n  type: \"ImportDefaultSpecifier\"\n  local: Identifier\n}\n\nexport interface ImportNamespaceSpecifier extends Node {\n  type: \"ImportNamespaceSpecifier\"\n  local: Identifier\n}\n\nexport interface ImportAttribute extends Node {\n  type: \"ImportAttribute\"\n  key: Identifier | Literal\n  value: Literal\n}\n\nexport interface ExportNamedDeclaration extends Node {\n  type: \"ExportNamedDeclaration\"\n  declaration?: Declaration | null\n  specifiers: Array<ExportSpecifier>\n  source?: Literal | null\n  attributes: Array<ImportAttribute>\n}\n\nexport interface ExportSpecifier extends Node {\n  type: \"ExportSpecifier\"\n  exported: Identifier | Literal\n  local: Identifier | Literal\n}\n\nexport interface AnonymousFunctionDeclaration extends Function {\n  type: \"FunctionDeclaration\"\n  id: null\n  body: BlockStatement\n}\n\nexport interface AnonymousClassDeclaration extends Class {\n  type: \"ClassDeclaration\"\n  id: null\n}\n\nexport interface ExportDefaultDeclaration extends Node {\n  type: \"ExportDefaultDeclaration\"\n  declaration: AnonymousFunctionDeclaration | FunctionDeclaration | AnonymousClassDeclaration | ClassDeclaration | Expression\n}\n\nexport interface ExportAllDeclaration extends Node {\n  type: \"ExportAllDeclaration\"\n  source: Literal\n  exported?: Identifier | Literal | null\n  attributes: Array<ImportAttribute>\n}\n\nexport interface AwaitExpression extends Node {\n  type: \"AwaitExpression\"\n  argument: Expression\n}\n\nexport interface ChainExpression extends Node {\n  type: \"ChainExpression\"\n  expression: MemberExpression | CallExpression\n}\n\nexport interface ImportExpression extends Node {\n  type: \"ImportExpression\"\n  source: Expression\n  options: Expression | null\n}\n\nexport interface ParenthesizedExpression extends Node {\n  type: \"ParenthesizedExpression\"\n  expression: Expression\n}\n\nexport interface PropertyDefinition extends Node {\n  type: \"PropertyDefinition\"\n  key: Expression | PrivateIdentifier\n  value?: Expression | null\n  computed: boolean\n  static: boolean\n}\n\nexport interface PrivateIdentifier extends Node {\n  type: \"PrivateIdentifier\"\n  name: string\n}\n\nexport interface StaticBlock extends Node {\n  type: \"StaticBlock\"\n  body: Array<Statement>\n}\n\nexport type Statement = \n| ExpressionStatement\n| BlockStatement\n| EmptyStatement\n| DebuggerStatement\n| WithStatement\n| ReturnStatement\n| LabeledStatement\n| BreakStatement\n| ContinueStatement\n| IfStatement\n| SwitchStatement\n| ThrowStatement\n| TryStatement\n| WhileStatement\n| DoWhileStatement\n| ForStatement\n| ForInStatement\n| ForOfStatement\n| Declaration\n\nexport type Declaration = \n| FunctionDeclaration\n| VariableDeclaration\n| ClassDeclaration\n\nexport type Expression = \n| Identifier\n| Literal\n| ThisExpression\n| ArrayExpression\n| ObjectExpression\n| FunctionExpression\n| UnaryExpression\n| UpdateExpression\n| BinaryExpression\n| AssignmentExpression\n| LogicalExpression\n| MemberExpression\n| ConditionalExpression\n| CallExpression\n| NewExpression\n| SequenceExpression\n| ArrowFunctionExpression\n| YieldExpression\n| TemplateLiteral\n| TaggedTemplateExpression\n| ClassExpression\n| MetaProperty\n| AwaitExpression\n| ChainExpression\n| ImportExpression\n| ParenthesizedExpression\n\nexport type Pattern = \n| Identifier\n| MemberExpression\n| ObjectPattern\n| ArrayPattern\n| RestElement\n| AssignmentPattern\n\nexport type ModuleDeclaration = \n| ImportDeclaration\n| ExportNamedDeclaration\n| ExportDefaultDeclaration\n| ExportAllDeclaration\n\nexport type AnyNode = Statement | Expression | Declaration | ModuleDeclaration | Literal | Program | SwitchCase | CatchClause | Property | Super | SpreadElement | TemplateElement | AssignmentProperty | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | MetaProperty | ImportAttribute | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier | AnonymousFunctionDeclaration | AnonymousClassDeclaration | PropertyDefinition | PrivateIdentifier | StaticBlock | VariableDeclarator\n\nexport function parse(input: string, options: Options): Program\n\nexport function parseExpressionAt(input: string, pos: number, options: Options): Expression\n\nexport function tokenizer(input: string, options: Options): {\n  getToken(): Token\n  [Symbol.iterator](): Iterator<Token>\n}\n\nexport type ecmaVersion = 3 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 | 2023 | 2024 | 2025 | \"latest\"\n\nexport interface Options {\n  /**\n   * `ecmaVersion` indicates the ECMAScript version to parse. Can be a\n   * number, either in year (`2022`) or plain version number (`6`) form,\n   * or `\"latest\"` (the latest the library supports). This influences\n   * support for strict mode, the set of reserved words, and support for\n   * new syntax features.\n   */\n  ecmaVersion: ecmaVersion\n\n  /**\n   * `sourceType` indicates the mode the code should be parsed in.\n   * Can be either `\"script\"` or `\"module\"`. This influences global\n   * strict mode and parsing of `import` and `export` declarations.\n   */\n  sourceType?: \"script\" | \"module\"\n\n  /**\n   * a callback that will be called when a semicolon is automatically inserted.\n   * @param lastTokEnd the position of the comma as an offset\n   * @param lastTokEndLoc location if {@link locations} is enabled\n   */\n  onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) => void\n\n  /**\n   * similar to `onInsertedSemicolon`, but for trailing commas\n   * @param lastTokEnd the position of the comma as an offset\n   * @param lastTokEndLoc location if `locations` is enabled\n   */\n  onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) => void\n\n  /**\n   * By default, reserved words are only enforced if ecmaVersion >= 5.\n   * Set `allowReserved` to a boolean value to explicitly turn this on\n   * an off. When this option has the value \"never\", reserved words\n   * and keywords can also not be used as property names.\n   */\n  allowReserved?: boolean | \"never\"\n\n  /** \n   * When enabled, a return at the top level is not considered an error.\n   */\n  allowReturnOutsideFunction?: boolean\n\n  /**\n   * When enabled, import/export statements are not constrained to\n   * appearing at the top of the program, and an import.meta expression\n   * in a script isn't considered an error.\n   */\n  allowImportExportEverywhere?: boolean\n\n  /**\n   * By default, `await` identifiers are allowed to appear at the top-level scope only if {@link ecmaVersion} >= 2022.\n   * When enabled, await identifiers are allowed to appear at the top-level scope,\n   * but they are still not allowed in non-async functions.\n   */\n  allowAwaitOutsideFunction?: boolean\n\n  /**\n   * When enabled, super identifiers are not constrained to\n   * appearing in methods and do not raise an error when they appear elsewhere.\n   */\n  allowSuperOutsideMethod?: boolean\n\n  /**\n   * When enabled, hashbang directive in the beginning of file is\n   * allowed and treated as a line comment. Enabled by default when\n   * {@link ecmaVersion} >= 2023.\n   */\n  allowHashBang?: boolean\n\n  /**\n   * By default, the parser will verify that private properties are\n   * only used in places where they are valid and have been declared.\n   * Set this to false to turn such checks off.\n   */\n  checkPrivateFields?: boolean\n\n  /**\n   * When `locations` is on, `loc` properties holding objects with\n   * `start` and `end` properties as {@link Position} objects will be attached to the\n   * nodes.\n   */\n  locations?: boolean\n\n  /**\n   * a callback that will cause Acorn to call that export function with object in the same\n   * format as tokens returned from `tokenizer().getToken()`. Note\n   * that you are not allowed to call the parser from the\n   * callback—that will corrupt its internal state.\n   */\n  onToken?: ((token: Token) => void) | Token[]\n\n\n  /**\n   * This takes a export function or an array.\n   * \n   * When a export function is passed, Acorn will call that export function with `(block, text, start,\n   * end)` parameters whenever a comment is skipped. `block` is a\n   * boolean indicating whether this is a block (`/* *\\/`) comment,\n   * `text` is the content of the comment, and `start` and `end` are\n   * character offsets that denote the start and end of the comment.\n   * When the {@link locations} option is on, two more parameters are\n   * passed, the full locations of {@link Position} export type of the start and\n   * end of the comments.\n   * \n   * When a array is passed, each found comment of {@link Comment} export type is pushed to the array.\n   * \n   * Note that you are not allowed to call the\n   * parser from the callback—that will corrupt its internal state.\n   */\n  onComment?: ((\n    isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,\n    endLoc?: Position\n  ) => void) | Comment[]\n\n  /**\n   * Nodes have their start and end characters offsets recorded in\n   * `start` and `end` properties (directly on the node, rather than\n   * the `loc` object, which holds line/column data. To also add a\n   * [semi-standardized][range] `range` property holding a `[start,\n   * end]` array with the same numbers, set the `ranges` option to\n   * `true`.\n   */\n  ranges?: boolean\n\n  /**\n   * It is possible to parse multiple files into a single AST by\n   * passing the tree produced by parsing the first file as\n   * `program` option in subsequent parses. This will add the\n   * toplevel forms of the parsed file to the `Program` (top) node\n   * of an existing parse tree.\n   */\n  program?: Node\n\n  /**\n   * When {@link locations} is on, you can pass this to record the source\n   * file in every node's `loc` object.\n   */\n  sourceFile?: string\n\n  /**\n   * This value, if given, is stored in every node, whether {@link locations} is on or off.\n   */\n  directSourceFile?: string\n\n  /**\n   * When enabled, parenthesized expressions are represented by\n   * (non-standard) ParenthesizedExpression nodes\n   */\n  preserveParens?: boolean\n}\n  \nexport class Parser {\n  options: Options\n  input: string\n  \n  protected constructor(options: Options, input: string, startPos?: number)\n  parse(): Program\n  \n  static parse(input: string, options: Options): Program\n  static parseExpressionAt(input: string, pos: number, options: Options): Expression\n  static tokenizer(input: string, options: Options): {\n    getToken(): Token\n    [Symbol.iterator](): Iterator<Token>\n  }\n  static extend(...plugins: ((BaseParser: typeof Parser) => typeof Parser)[]): typeof Parser\n}\n\nexport const defaultOptions: Options\n\nexport function getLineInfo(input: string, offset: number): Position\n\nexport class TokenType {\n  label: string\n  keyword: string | undefined\n}\n\nexport const tokTypes: {\n  num: TokenType\n  regexp: TokenType\n  string: TokenType\n  name: TokenType\n  privateId: TokenType\n  eof: TokenType\n\n  bracketL: TokenType\n  bracketR: TokenType\n  braceL: TokenType\n  braceR: TokenType\n  parenL: TokenType\n  parenR: TokenType\n  comma: TokenType\n  semi: TokenType\n  colon: TokenType\n  dot: TokenType\n  question: TokenType\n  questionDot: TokenType\n  arrow: TokenType\n  template: TokenType\n  invalidTemplate: TokenType\n  ellipsis: TokenType\n  backQuote: TokenType\n  dollarBraceL: TokenType\n\n  eq: TokenType\n  assign: TokenType\n  incDec: TokenType\n  prefix: TokenType\n  logicalOR: TokenType\n  logicalAND: TokenType\n  bitwiseOR: TokenType\n  bitwiseXOR: TokenType\n  bitwiseAND: TokenType\n  equality: TokenType\n  relational: TokenType\n  bitShift: TokenType\n  plusMin: TokenType\n  modulo: TokenType\n  star: TokenType\n  slash: TokenType\n  starstar: TokenType\n  coalesce: TokenType\n\n  _break: TokenType\n  _case: TokenType\n  _catch: TokenType\n  _continue: TokenType\n  _debugger: TokenType\n  _default: TokenType\n  _do: TokenType\n  _else: TokenType\n  _finally: TokenType\n  _for: TokenType\n  _function: TokenType\n  _if: TokenType\n  _return: TokenType\n  _switch: TokenType\n  _throw: TokenType\n  _try: TokenType\n  _var: TokenType\n  _const: TokenType\n  _while: TokenType\n  _with: TokenType\n  _new: TokenType\n  _this: TokenType\n  _super: TokenType\n  _class: TokenType\n  _extends: TokenType\n  _export: TokenType\n  _import: TokenType\n  _null: TokenType\n  _true: TokenType\n  _false: TokenType\n  _in: TokenType\n  _instanceof: TokenType\n  _typeof: TokenType\n  _void: TokenType\n  _delete: TokenType\n}\n\nexport interface Comment {\n  type: \"Line\" | \"Block\"\n  value: string\n  start: number\n  end: number\n  loc?: SourceLocation\n  range?: [number, number]\n}\n\nexport class Token {\n  type: TokenType\n  start: number\n  end: number\n  loc?: SourceLocation\n  range?: [number, number]\n}\n\nexport const version: string\n"
        }
    ]
}