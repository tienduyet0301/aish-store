{
    "sourceFile": "node_modules/graphemer/README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892322205,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "# Graphemer: Unicode Character Splitter 🪓\n\n## Introduction\n\nThis library continues the work of [Grapheme Splitter](https://github.com/orling/grapheme-splitter) and supports the following unicode versions:\n\n- Unicode 15 and below `[v1.4.0]`\n- Unicode 14 and below `[v1.3.0]`\n- Unicode 13 and below `[v1.1.0]`\n- Unicode 11 and below `[v1.0.0]` (Unicode 10 supported by `grapheme-splitter`)\n\nIn JavaScript there is not always a one-to-one relationship between string characters and what a user would call a separate visual \"letter\". Some symbols are represented by several characters. This can cause issues when splitting strings and inadvertently cutting a multi-char letter in half, or when you need the actual number of letters in a string.\n\nFor example, emoji characters like \"🌷\",\"🎁\",\"💩\",\"😜\" and \"👍\" are represented by two JavaScript characters each (high surrogate and low surrogate). That is,\n\n```javascript\n'🌷'.length == 2;\n```\n\nThe combined emoji are even longer:\n\n```javascript\n'🏳️‍🌈'.length == 6;\n```\n\nWhat's more, some languages often include combining marks - characters that are used to modify the letters before them. Common examples are the German letter ü and the Spanish letter ñ. Sometimes they can be represented alternatively both as a single character and as a letter + combining mark, with both forms equally valid:\n\n```javascript\nvar two = 'ñ'; // unnormalized two-char n+◌̃, i.e. \"\\u006E\\u0303\";\nvar one = 'ñ'; // normalized single-char, i.e. \"\\u00F1\"\n\nconsole.log(one != two); // prints 'true'\n```\n\nUnicode normalization, as performed by the popular punycode.js library or ECMAScript 6's String.normalize, can **sometimes** fix those differences and turn two-char sequences into single characters. But it is **not** enough in all cases. Some languages like Hindi make extensive use of combining marks on their letters, that have no dedicated single-codepoint Unicode sequences, due to the sheer number of possible combinations.\nFor example, the Hindi word \"अनुच्छेद\" is comprised of 5 letters and 3 combining marks:\n\nअ + न + ु + च + ् + छ + े + द\n\nwhich is in fact just 5 user-perceived letters:\n\nअ + नु + च् + छे + द\n\nand which Unicode normalization would not combine properly.\nThere are also the unusual letter+combining mark combinations which have no dedicated Unicode codepoint. The string Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘ obviously has 5 separate letters, but is in fact comprised of 58 JavaScript characters, most of which are combining marks.\n\nEnter the `graphemer` library. It can be used to properly split JavaScript strings into what a human user would call separate letters (or \"extended grapheme clusters\" in Unicode terminology), no matter what their internal representation is. It is an implementation on the [Default Grapheme Cluster Boundary](http://unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table) of [UAX #29](http://www.unicode.org/reports/tr29/).\n\n## Installation\n\nInstall `graphemer` using the NPM command below:\n\n```\n$ npm i graphemer\n```\n\n## Usage\n\nIf you're using [Typescript](https://www.typescriptlang.org/) or a compiler like [Babel](https://babeljs.io/) (or something like Create React App) things are pretty simple; just import, initialize and use!\n\n```javascript\nimport Graphemer from 'graphemer';\n\nconst splitter = new Graphemer();\n\n// split the string to an array of grapheme clusters (one string each)\nconst graphemes = splitter.splitGraphemes(string);\n\n// iterate the string to an iterable iterator of grapheme clusters (one string each)\nconst graphemeIterator = splitter.iterateGraphemes(string);\n\n// or do this if you just need their number\nconst graphemeCount = splitter.countGraphemes(string);\n```\n\nIf you're using vanilla Node you can use the `require()` method.\n\n```javascript\nconst Graphemer = require('graphemer').default;\n\nconst splitter = new Graphemer();\n\nconst graphemes = splitter.splitGraphemes(string);\n```\n\n## Examples\n\n```javascript\nimport Graphemer from 'graphemer';\n\nconst splitter = new Graphemer();\n\n// plain latin alphabet - nothing spectacular\nsplitter.splitGraphemes('abcd'); // returns [\"a\", \"b\", \"c\", \"d\"]\n\n// two-char emojis and six-char combined emoji\nsplitter.splitGraphemes('🌷🎁💩😜👍🏳️‍🌈'); // returns [\"🌷\",\"🎁\",\"💩\",\"😜\",\"👍\",\"🏳️‍🌈\"]\n\n// diacritics as combining marks, 10 JavaScript chars\nsplitter.splitGraphemes('Ĺo͂řȩm̅'); // returns [\"Ĺ\",\"o͂\",\"ř\",\"ȩ\",\"m̅\"]\n\n// individual Korean characters (Jamo), 4 JavaScript chars\nsplitter.splitGraphemes('뎌쉐'); // returns [\"뎌\",\"쉐\"]\n\n// Hindi text with combining marks, 8 JavaScript chars\nsplitter.splitGraphemes('अनुच्छेद'); // returns [\"अ\",\"नु\",\"च्\",\"छे\",\"द\"]\n\n// demonic multiple combining marks, 75 JavaScript chars\nsplitter.splitGraphemes('Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞'); // returns [\"Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍\",\"A̴̵̜̰͔ͫ͗͢\",\"L̠ͨͧͩ͘\",\"G̴̻͈͍͔̹̑͗̎̅͛́\",\"Ǫ̵̹̻̝̳͂̌̌͘\",\"!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞\"]\n```\n\n## TypeScript\n\nGraphemer is built with TypeScript and, of course, includes type declarations.\n\n```javascript\nimport Graphemer from 'graphemer';\n\nconst splitter = new Graphemer();\n\nconst split: string[] = splitter.splitGraphemes('Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞');\n```\n\n## Contributing\n\nSee [Contribution Guide](./CONTRIBUTING.md).\n\n## Acknowledgements\n\nThis library is a fork of the incredible work done by Orlin Georgiev and Huáng Jùnliàng at https://github.com/orling/grapheme-splitter.\n\nThe original library was heavily influenced by Devon Govett's excellent [grapheme-breaker](https://github.com/devongovett/grapheme-breaker) CoffeeScript library.\n"
        }
    ]
}