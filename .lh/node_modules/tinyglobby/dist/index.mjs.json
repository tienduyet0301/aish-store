{
    "sourceFile": "node_modules/tinyglobby/dist/index.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893052429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// src/index.ts\nimport path, { posix } from \"path\";\nimport { fdir } from \"fdir\";\nimport picomatch2 from \"picomatch\";\n\n// src/utils.ts\nimport picomatch from \"picomatch\";\nvar ONLY_PARENT_DIRECTORIES = /^(\\/?\\.\\.)+$/;\nfunction getPartialMatcher(patterns, options) {\n  const patternsCount = patterns.length;\n  const patternsParts = Array(patternsCount);\n  const regexes = Array(patternsCount);\n  for (let i = 0; i < patternsCount; i++) {\n    const parts = splitPattern(patterns[i]);\n    patternsParts[i] = parts;\n    const partsCount = parts.length;\n    const partRegexes = Array(partsCount);\n    for (let j = 0; j < partsCount; j++) {\n      partRegexes[j] = picomatch.makeRe(parts[j], options);\n    }\n    regexes[i] = partRegexes;\n  }\n  return (input) => {\n    const inputParts = input.split(\"/\");\n    if (inputParts[0] === \"..\" && ONLY_PARENT_DIRECTORIES.test(input)) {\n      return true;\n    }\n    for (let i = 0; i < patterns.length; i++) {\n      const patternParts = patternsParts[i];\n      const regex = regexes[i];\n      const inputPatternCount = inputParts.length;\n      const minParts = Math.min(inputPatternCount, patternParts.length);\n      let j = 0;\n      while (j < minParts) {\n        const part = patternParts[j];\n        if (part.includes(\"/\")) {\n          return true;\n        }\n        const match = regex[j].test(inputParts[j]);\n        if (!match) {\n          break;\n        }\n        if (part === \"**\") {\n          return true;\n        }\n        j++;\n      }\n      if (j === inputPatternCount) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\nvar splitPatternOptions = { parts: true };\nfunction splitPattern(path2) {\n  var _a;\n  const result = picomatch.scan(path2, splitPatternOptions);\n  return ((_a = result.parts) == null ? void 0 : _a.length) ? result.parts : [path2];\n}\nvar isWin = process.platform === \"win32\";\nvar ESCAPED_WIN32_BACKSLASHES = /\\\\(?![()[\\]{}!+@])/g;\nfunction convertPosixPathToPattern(path2) {\n  return escapePosixPath(path2);\n}\nfunction convertWin32PathToPattern(path2) {\n  return escapeWin32Path(path2).replace(ESCAPED_WIN32_BACKSLASHES, \"/\");\n}\nvar convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;\nvar POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}*?|]|^!|[!+@](?=\\()|\\\\(?![()[\\]{}!*+?@|]))/g;\nvar WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}]|^!|[!+@](?=\\())/g;\nvar escapePosixPath = (path2) => path2.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nvar escapeWin32Path = (path2) => path2.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nvar escapePath = isWin ? escapeWin32Path : escapePosixPath;\nfunction isDynamicPattern(pattern, options) {\n  if ((options == null ? void 0 : options.caseSensitiveMatch) === false) {\n    return true;\n  }\n  const scan = picomatch.scan(pattern);\n  return scan.isGlob || scan.negated;\n}\nfunction log(...tasks) {\n  console.log(`[tinyglobby ${(/* @__PURE__ */ new Date()).toLocaleTimeString(\"es\")}]`, ...tasks);\n}\n\n// src/index.ts\nvar PARENT_DIRECTORY = /^(\\/?\\.\\.)+/;\nvar ESCAPING_BACKSLASHES = /\\\\(?=[()[\\]{}!*+?@|])/g;\nvar BACKSLASHES = /\\\\/g;\nfunction normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {\n  var _a;\n  let result = pattern;\n  if (pattern.endsWith(\"/\")) {\n    result = pattern.slice(0, -1);\n  }\n  if (!result.endsWith(\"*\") && expandDirectories) {\n    result += \"/**\";\n  }\n  if (path.isAbsolute(result.replace(ESCAPING_BACKSLASHES, \"\"))) {\n    result = posix.relative(escapePath(cwd), result);\n  } else {\n    result = posix.normalize(result);\n  }\n  const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);\n  if (parentDirectoryMatch == null ? void 0 : parentDirectoryMatch[0]) {\n    const potentialRoot = posix.join(cwd, parentDirectoryMatch[0]);\n    if (props.root.length > potentialRoot.length) {\n      props.root = potentialRoot;\n      props.depthOffset = -(parentDirectoryMatch[0].length + 1) / 3;\n    }\n  } else if (!isIgnore && props.depthOffset >= 0) {\n    const parts = splitPattern(result);\n    (_a = props.commonPath) != null ? _a : props.commonPath = parts;\n    const newCommonPath = [];\n    const length = Math.min(props.commonPath.length, parts.length);\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === \"**\" && !parts[i + 1]) {\n        newCommonPath.pop();\n        break;\n      }\n      if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) {\n        break;\n      }\n      newCommonPath.push(part);\n    }\n    props.depthOffset = newCommonPath.length;\n    props.commonPath = newCommonPath;\n    props.root = newCommonPath.length > 0 ? `${cwd}/${newCommonPath.join(\"/\")}` : cwd;\n  }\n  return result;\n}\nfunction processPatterns({ patterns, ignore = [], expandDirectories = true }, cwd, props) {\n  if (typeof patterns === \"string\") {\n    patterns = [patterns];\n  } else if (!patterns) {\n    patterns = [\"**/*\"];\n  }\n  if (typeof ignore === \"string\") {\n    ignore = [ignore];\n  }\n  const matchPatterns = [];\n  const ignorePatterns = [];\n  for (const pattern of ignore) {\n    if (!pattern) {\n      continue;\n    }\n    if (pattern[0] !== \"!\" || pattern[1] === \"(\") {\n      ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));\n    }\n  }\n  for (const pattern of patterns) {\n    if (!pattern) {\n      continue;\n    }\n    if (pattern[0] !== \"!\" || pattern[1] === \"(\") {\n      matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));\n    } else if (pattern[1] !== \"!\" || pattern[2] === \"(\") {\n      ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));\n    }\n  }\n  return { match: matchPatterns, ignore: ignorePatterns };\n}\nfunction getRelativePath(path2, cwd, root) {\n  return posix.relative(cwd, `${root}/${path2}`) || \".\";\n}\nfunction processPath(path2, cwd, root, isDirectory, absolute) {\n  const relativePath = absolute ? path2.slice(root.length + 1) || \".\" : path2;\n  if (root === cwd) {\n    return isDirectory && relativePath !== \".\" ? relativePath.slice(0, -1) : relativePath;\n  }\n  return getRelativePath(relativePath, cwd, root);\n}\nfunction formatPaths(paths, cwd, root) {\n  for (let i = paths.length - 1; i >= 0; i--) {\n    const path2 = paths[i];\n    paths[i] = getRelativePath(path2, cwd, root) + (!path2 || path2.endsWith(\"/\") ? \"/\" : \"\");\n  }\n  return paths;\n}\nfunction crawl(options, cwd, sync) {\n  if (process.env.TINYGLOBBY_DEBUG) {\n    options.debug = true;\n  }\n  if (options.debug) {\n    log(\"globbing with options:\", options, \"cwd:\", cwd);\n  }\n  if (Array.isArray(options.patterns) && options.patterns.length === 0) {\n    return sync ? [] : Promise.resolve([]);\n  }\n  const props = {\n    root: cwd,\n    commonPath: null,\n    depthOffset: 0\n  };\n  const processed = processPatterns(options, cwd, props);\n  const nocase = options.caseSensitiveMatch === false;\n  if (options.debug) {\n    log(\"internal processing patterns:\", processed);\n  }\n  const matcher = picomatch2(processed.match, {\n    dot: options.dot,\n    nocase,\n    ignore: processed.ignore\n  });\n  const ignore = picomatch2(processed.ignore, {\n    dot: options.dot,\n    nocase\n  });\n  const partialMatcher = getPartialMatcher(processed.match, {\n    dot: options.dot,\n    nocase\n  });\n  const fdirOptions = {\n    // use relative paths in the matcher\n    filters: [\n      options.debug ? (p, isDirectory) => {\n        const path2 = processPath(p, cwd, props.root, isDirectory, options.absolute);\n        const matches = matcher(path2);\n        if (matches) {\n          log(`matched ${path2}`);\n        }\n        return matches;\n      } : (p, isDirectory) => matcher(processPath(p, cwd, props.root, isDirectory, options.absolute))\n    ],\n    exclude: options.debug ? (_, p) => {\n      const relativePath = processPath(p, cwd, props.root, true, true);\n      const skipped = relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n      if (skipped) {\n        log(`skipped ${p}`);\n      } else {\n        log(`crawling ${p}`);\n      }\n      return skipped;\n    } : (_, p) => {\n      const relativePath = processPath(p, cwd, props.root, true, true);\n      return relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n    },\n    pathSeparator: \"/\",\n    relativePaths: true,\n    resolveSymlinks: true\n  };\n  if (options.deep) {\n    fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);\n  }\n  if (options.absolute) {\n    fdirOptions.relativePaths = false;\n    fdirOptions.resolvePaths = true;\n    fdirOptions.includeBasePath = true;\n  }\n  if (options.followSymbolicLinks === false) {\n    fdirOptions.resolveSymlinks = false;\n    fdirOptions.excludeSymlinks = true;\n  }\n  if (options.onlyDirectories) {\n    fdirOptions.excludeFiles = true;\n    fdirOptions.includeDirs = true;\n  } else if (options.onlyFiles === false) {\n    fdirOptions.includeDirs = true;\n  }\n  props.root = props.root.replace(BACKSLASHES, \"\");\n  const root = props.root;\n  if (options.debug) {\n    log(\"internal properties:\", props);\n  }\n  const api = new fdir(fdirOptions).crawl(root);\n  if (cwd === root || options.absolute) {\n    return sync ? api.sync() : api.withPromise();\n  }\n  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then((paths) => formatPaths(paths, cwd, root));\n}\nasync function glob(patternsOrOptions, options) {\n  if (patternsOrOptions && (options == null ? void 0 : options.patterns)) {\n    throw new Error(\"Cannot pass patterns as both an argument and an option\");\n  }\n  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n  return crawl(opts, cwd, false);\n}\nfunction globSync(patternsOrOptions, options) {\n  if (patternsOrOptions && (options == null ? void 0 : options.patterns)) {\n    throw new Error(\"Cannot pass patterns as both an argument and an option\");\n  }\n  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? { ...options, patterns: patternsOrOptions } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n  return crawl(opts, cwd, true);\n}\nexport {\n  convertPathToPattern,\n  escapePath,\n  glob,\n  globSync,\n  isDynamicPattern\n};\n"
        }
    ]
}