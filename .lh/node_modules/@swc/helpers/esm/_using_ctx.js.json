{
    "sourceFile": "node_modules/@swc/helpers/esm/_using_ctx.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891942237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "function _using_ctx() {\n    var _disposeSuppressedError = typeof SuppressedError === \"function\"\n            // eslint-disable-next-line no-undef\n            ? SuppressedError\n            : (function(error, suppressed) {\n                var err = new Error();\n                err.name = \"SuppressedError\";\n                err.suppressed = suppressed;\n                err.error = error;\n                return err;\n            }),\n        empty = {},\n        stack = [];\n    function using(isAwait, value) {\n        if (value != null) {\n            if (Object(value) !== value) {\n                throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n            }\n            // core-js-pure uses Symbol.for for polyfilling well-known symbols\n            if (isAwait) {\n                var dispose = value[Symbol.asyncDispose || Symbol.for(\"Symbol.asyncDispose\")];\n            }\n            if (dispose == null) {\n                dispose = value[Symbol.dispose || Symbol.for(\"Symbol.dispose\")];\n            }\n            if (typeof dispose !== \"function\") {\n                throw new TypeError(`Property [Symbol.dispose] is not a function.`);\n            }\n            stack.push({ v: value, d: dispose, a: isAwait });\n        } else if (isAwait) {\n            // provide the nullish `value` as `d` for minification gain\n            stack.push({ d: value, a: isAwait });\n        }\n        return value;\n    }\n    return {\n        // error\n        e: empty,\n        // using\n        u: using.bind(null, false),\n        // await using\n        a: using.bind(null, true),\n        // dispose\n        d: function() {\n            var error = this.e;\n\n            function next() {\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                while ((resource = stack.pop())) {\n                    try {\n                        var resource, disposalResult = resource.d && resource.d.call(resource.v);\n                        if (resource.a) {\n                            return Promise.resolve(disposalResult).then(next, err);\n                        }\n                    } catch (e) {\n                        return err(e);\n                    }\n                }\n                if (error !== empty) throw error;\n            }\n\n            function err(e) {\n                error = error !== empty ? new _disposeSuppressedError(error, e) : e;\n\n                return next();\n            }\n\n            return next();\n        }\n    };\n}\n\nexport { _using_ctx as _ };\n"
        }
    ]
}