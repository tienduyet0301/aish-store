{
    "sourceFile": "node_modules/@swc/helpers/scripts/ast_grep.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891942435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { parseFiles } from \"@ast-grep/napi\";\nimport MagicString from \"magic-string\";\nimport { chalk, fs, path } from \"zx\";\nimport { errors } from \"./errors.js\";\nimport { root } from \"./utils.js\";\n\n/**\n * @typedef {import(\"@ast-grep/napi\").SgNode} SgNode\n */\n\nexport function ast_grep() {\n    const task_queue = [];\n\n    const task = parseFiles([root(\"esm\")], (err, tree) => {\n        const filename = path.basename(tree.filename(), \".js\");\n        if (filename === \"index\") {\n            return;\n        }\n\n        const source = new MagicString(tree.root().text());\n        source.prepend(`\"use strict\";\\n\\n`);\n\n        if (filename.startsWith(\"_ts\")) {\n            const match = tree.root().find(`export { $NAME as _ } from \"tslib\"`);\n            if (match) {\n                const name = match.getMatch(\"NAME\").text();\n\n                const range = match.range();\n\n                source.update(\n                    range.start.index,\n                    range.end.index,\n                    `exports._ = require(\"tslib\").${name};`,\n                );\n                task_queue.push(\n                    fs.writeFile(root(\"cjs\", `${filename}.cjs`), source.toString(), {\n                        encoding: \"utf-8\",\n                    }),\n                );\n            } else {\n                report_noexport(tree.filename());\n            }\n            return;\n        }\n\n        // rewrite export named function\n        const match = tree.root().find({\n            rule: {\n                kind: \"export_statement\",\n                pattern: \"export { $FUNC as _ }\",\n            },\n        });\n\n        if (match) {\n            const func = match.getMatch(\"FUNC\");\n            const func_name = func.text();\n            if (func_name !== filename) {\n                report_export_mismatch(tree.filename(), match);\n            }\n\n            const range = match.range();\n            source.update(\n                range.start.index,\n                range.end.index,\n                `exports._ = ${func_name};`,\n            );\n\n            // since we match the { export x as _ } pattern,\n            // we need to find the assignment expression from the root\n            tree\n                .root()\n                .findAll({\n                    rule: {\n                        pattern: func_name,\n                        kind: \"identifier\",\n                        inside: { kind: \"assignment_expression\", field: \"left\" },\n                    },\n                })\n                .forEach((match) => {\n                    const range = match.range();\n\n                    source.prependLeft(range.start.index, `exports._ = `);\n                });\n        } else {\n            report_noexport(tree.filename(tree.filename()));\n        }\n\n        // rewrite import\n        tree\n            .root()\n            .findAll({ rule: { pattern: `import { _ as $BINDING } from \"$SOURCE\"` } })\n            .forEach((match) => {\n                const import_binding = match.getMatch(\"BINDING\").text();\n                const import_source = match.getMatch(\"SOURCE\").text();\n\n                const import_basename = path.basename(import_source, \".js\");\n\n                if (import_binding !== import_basename) {\n                    report_import_mismatch(tree.filename(), match);\n                }\n\n                const range = match.range();\n\n                source.update(\n                    range.start.index,\n                    range.end.index,\n                    `var ${import_binding} = require(\"./${import_binding}.cjs\");`,\n                );\n\n                tree\n                    .root()\n                    .findAll({\n                        rule: {\n                            pattern: import_binding,\n                            kind: \"identifier\",\n                            inside: {\n                                not: {\n                                    kind: \"import_specifier\",\n                                },\n                            },\n                        },\n                    })\n                    .forEach((match) => {\n                        const range = match.range();\n                        const ref_name = match.text();\n\n                        source.update(\n                            range.start.index,\n                            range.end.index,\n                            `${ref_name}._`,\n                        );\n                    });\n            });\n\n        task_queue.push(\n            fs.writeFile(root(\"cjs\", `${filename}.cjs`), source.toString(), {\n                encoding: \"utf-8\",\n            }),\n        );\n    });\n\n    task_queue.push(task);\n\n    return task_queue;\n}\n\n/**\n * @param {string} filename\n * @param {SgNode} match\n */\nfunction report_export_mismatch(filename, match) {\n    const func = match.getMatch(\"FUNC\");\n    const func_range = func.range();\n\n    const text = match.text().split(\"\\n\");\n    const offset = func_range.start.line - match.range().start.line;\n\n    text.splice(\n        offset + 1,\n        text.length,\n        chalk.red(\n            [\n                \" \".repeat(func_range.start.column),\n                \"^\".repeat(func_range.end.column - func_range.start.column),\n            ]\n                .join(\"\"),\n        ),\n    );\n\n    errors.push(\n        [\n            `${chalk.bold.red(\"error\")}: mismatch exported function name.`,\n            \"\",\n            `${chalk.blue(\"-->\")} ${filename}:${func_range.start.line + 1}:${func_range.start.column + 1}`,\n            \"\",\n            ...text,\n            \"\",\n            `${\n                chalk.bold(\n                    \"note:\",\n                )\n            } The exported name should be the same as the filename.`,\n            \"\",\n        ]\n            .join(\"\\n\"),\n    );\n}\n\n/**\n * @param {string} filename\n * @param {SgNode} match\n */\nfunction report_import_mismatch(filename, match) {\n    const binding_range = match.getMatch(\"BINDING\").range();\n    const source_range = match.getMatch(\"SOURCE\").range();\n\n    errors.push(\n        [\n            `${chalk.bold.red(\"error\")}: mismatch imported binding name.`,\n            \"\",\n            `${chalk.blue(\"-->\")} ${filename}:${match.range().start.line + 1}`,\n            \"\",\n            match.text(),\n            [\n                \" \".repeat(binding_range.start.column),\n                chalk.red(\"^\".repeat(binding_range.end.column - binding_range.start.column)),\n                \" \".repeat(source_range.start.column - binding_range.end.column),\n                chalk.blue(\"-\".repeat(source_range.end.column - source_range.start.column)),\n            ]\n                .join(\"\"),\n            `${\n                chalk.bold(\n                    \"note:\",\n                )\n            } The imported binding name should be the same as the import source basename.`,\n            \"\",\n        ]\n            .join(\"\\n\"),\n    );\n}\n\n/**\n * @param {string} filename\n */\nfunction report_noexport(filename) {\n    errors.push(\n        [`${chalk.bold.red(\"error\")}: exported name not found`, `${chalk.blue(\"-->\")} ${filename}`].join(\"\\n\"),\n    );\n}\n"
        }
    ]
}