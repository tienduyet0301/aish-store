{
    "sourceFile": "node_modules/@swc/helpers/cjs/_apply_decs_2203_r.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891934819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\n/* @minVersion 7.20.0 */\n\n/**\n  Enums are used in this file, but not assigned to vars to avoid non-hoistable values\n\n  CONSTRUCTOR = 0;\n  PUBLIC = 1;\n  PRIVATE = 2;\n\n  FIELD = 0;\n  ACCESSOR = 1;\n  METHOD = 2;\n  GETTER = 3;\n  SETTER = 4;\n\n  STATIC = 5;\n\n  CLASS = 10; // only used in assertValidReturnValue\n*/\n\nfunction _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {\n    function createAddInitializerMethod(initializers, decoratorFinishedRef) {\n        return function addInitializer(initializer) {\n            assertNotFinished(decoratorFinishedRef, \"addInitializer\");\n            assertCallable(initializer, \"An initializer\");\n            initializers.push(initializer);\n        };\n    }\n\n    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {\n        var kindStr;\n\n        switch (kind) {\n            case 1 /* ACCESSOR */:\n                kindStr = \"accessor\";\n                break;\n            case 2 /* METHOD */:\n                kindStr = \"method\";\n                break;\n            case 3 /* GETTER */:\n                kindStr = \"getter\";\n                break;\n            case 4 /* SETTER */:\n                kindStr = \"setter\";\n                break;\n            default:\n                kindStr = \"field\";\n        }\n\n        var ctx = { kind: kindStr, name: isPrivate ? \"#\" + name : name, static: isStatic, private: isPrivate, metadata: metadata };\n\n        var decoratorFinishedRef = { v: false };\n\n        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);\n\n        var get, set;\n        if (kind === 0 /* FIELD */) {\n            if (isPrivate) {\n                get = desc.get;\n                set = desc.set;\n            } else {\n                get = function() {\n                    return this[name];\n                };\n                set = function(v) {\n                    this[name] = v;\n                };\n            }\n        } else if (kind === 2 /* METHOD */) {\n            get = function() {\n                return desc.value;\n            };\n        } else {\n            // replace with values that will go through the final getter and setter\n            if (kind === 1 /* ACCESSOR */ || kind === 3 /* GETTER */) {\n                get = function() {\n                    return desc.get.call(this);\n                };\n            }\n\n            if (kind === 1 /* ACCESSOR */ || kind === 4 /* SETTER */) {\n                set = function(v) {\n                    desc.set.call(this, v);\n                };\n            }\n        }\n        ctx.access = get && set ? { get: get, set: set } : get ? { get: get } : { set: set };\n\n        try {\n            return dec(value, ctx);\n        } finally {\n            decoratorFinishedRef.v = true;\n        }\n    }\n\n    function assertNotFinished(decoratorFinishedRef, fnName) {\n        if (decoratorFinishedRef.v) {\n            throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n        }\n    }\n\n    function assertCallable(fn, hint) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(hint + \" must be a function\");\n        }\n    }\n\n    function assertValidReturnValue(kind, value) {\n        var type = typeof value;\n\n        if (kind === 1 /* ACCESSOR */) {\n            if (type !== \"object\" || value === null) {\n                throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n            }\n            if (value.get !== undefined) {\n                assertCallable(value.get, \"accessor.get\");\n            }\n            if (value.set !== undefined) {\n                assertCallable(value.set, \"accessor.set\");\n            }\n            if (value.init !== undefined) {\n                assertCallable(value.init, \"accessor.init\");\n            }\n        } else if (type !== \"function\") {\n            var hint;\n            if (kind === 0 /* FIELD */) {\n                hint = \"field\";\n            } else if (kind === 10 /* CLASS */) {\n                hint = \"class\";\n            } else {\n                hint = \"method\";\n            }\n            throw new TypeError(hint + \" decorators must return a function or void 0\");\n        }\n    }\n\n    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {\n        var decs = decInfo[0];\n\n        var desc, init, value;\n\n        if (isPrivate) {\n            if (kind === 0 /* FIELD */ || kind === 1 /* ACCESSOR */) {\n                desc = { get: decInfo[3], set: decInfo[4] };\n            } else if (kind === 3 /* GETTER */) {\n                desc = { get: decInfo[3] };\n            } else if (kind === 4 /* SETTER */) {\n                desc = { set: decInfo[3] };\n            } else {\n                desc = { value: decInfo[3] };\n            }\n        } else if (kind !== 0 /* FIELD */) {\n            desc = Object.getOwnPropertyDescriptor(base, name);\n        }\n\n        if (kind === 1 /* ACCESSOR */) {\n            value = { get: desc.get, set: desc.set };\n        } else if (kind === 2 /* METHOD */) {\n            value = desc.value;\n        } else if (kind === 3 /* GETTER */) {\n            value = desc.get;\n        } else if (kind === 4 /* SETTER */) {\n            value = desc.set;\n        }\n\n        var newValue, get, set;\n\n        if (typeof decs === \"function\") {\n            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);\n\n            if (newValue !== void 0) {\n                assertValidReturnValue(kind, newValue);\n\n                if (kind === 0 /* FIELD */) {\n                    init = newValue;\n                } else if (kind === 1 /* ACCESSOR */) {\n                    init = newValue.init;\n                    get = newValue.get || value.get;\n                    set = newValue.set || value.set;\n\n                    value = { get: get, set: set };\n                } else {\n                    value = newValue;\n                }\n            }\n        } else {\n            for (var i = decs.length - 1; i >= 0; i--) {\n                var dec = decs[i];\n\n                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);\n\n                if (newValue !== void 0) {\n                    assertValidReturnValue(kind, newValue);\n                    var newInit;\n\n                    if (kind === 0 /* FIELD */) {\n                        newInit = newValue;\n                    } else if (kind === 1 /* ACCESSOR */) {\n                        newInit = newValue.init;\n                        get = newValue.get || value.get;\n                        set = newValue.set || value.set;\n\n                        value = { get: get, set: set };\n                    } else {\n                        value = newValue;\n                    }\n\n                    if (newInit !== void 0) {\n                        if (init === void 0) {\n                            init = newInit;\n                        } else if (typeof init === \"function\") {\n                            init = [init, newInit];\n                        } else {\n                            init.push(newInit);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (kind === 0 /* FIELD */ || kind === 1 /* ACCESSOR */) {\n            if (init === void 0) {\n                // If the initializer was void 0, sub in a dummy initializer\n                init = function(instance, init) {\n                    return init;\n                };\n            } else if (typeof init !== \"function\") {\n                var ownInitializers = init;\n\n                init = function(instance, init) {\n                    var value = init;\n\n                    for (var i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);\n\n                    return value;\n                };\n            } else {\n                var originalInitializer = init;\n\n                init = function(instance, init) {\n                    return originalInitializer.call(instance, init);\n                };\n            }\n\n            ret.push(init);\n        }\n\n        if (kind !== 0 /* FIELD */) {\n            if (kind === 1 /* ACCESSOR */) {\n                desc.get = value.get;\n                desc.set = value.set;\n            } else if (kind === 2 /* METHOD */) {\n                desc.value = value;\n            } else if (kind === 3 /* GETTER */) {\n                desc.get = value;\n            } else if (kind === 4 /* SETTER */) {\n                desc.set = value;\n            }\n\n            if (isPrivate) {\n                if (kind === 1 /* ACCESSOR */) {\n                    ret.push(function(instance, args) {\n                        return value.get.call(instance, args);\n                    });\n                    ret.push(function(instance, args) {\n                        return value.set.call(instance, args);\n                    });\n                } else if (kind === 2 /* METHOD */) {\n                    ret.push(value);\n                } else {\n                    ret.push(function(instance, args) {\n                        return value.call(instance, args);\n                    });\n                }\n            } else {\n                Object.defineProperty(base, name, desc);\n            }\n        }\n    }\n\n    function applyMemberDecs(Class, decInfos, metadata) {\n        var ret = [];\n        var protoInitializers;\n        var staticInitializers;\n\n        var existingProtoNonFields = new Map();\n        var existingStaticNonFields = new Map();\n\n        for (var i = 0; i < decInfos.length; i++) {\n            var decInfo = decInfos[i];\n\n            // skip computed property names\n            if (!Array.isArray(decInfo)) continue;\n\n            var kind = decInfo[1];\n            var name = decInfo[2];\n            var isPrivate = decInfo.length > 3;\n\n            var isStatic = kind >= 5; /* STATIC */\n            var base;\n            var initializers;\n\n            if (isStatic) {\n                base = Class;\n                kind = kind - 5 /* STATIC */;\n                // initialize staticInitializers when we see a non-field static member\n                staticInitializers = staticInitializers || [];\n                initializers = staticInitializers;\n            } else {\n                base = Class.prototype;\n                // initialize protoInitializers when we see a non-field member\n                protoInitializers = protoInitializers || [];\n                initializers = protoInitializers;\n            }\n\n            if (kind !== 0 /* FIELD */ && !isPrivate) {\n                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;\n\n                var existingKind = existingNonFields.get(name) || 0;\n\n                if (existingKind === true || (existingKind === 3 /* GETTER */ && kind !== 4) /* SETTER */ || (existingKind === 4 /* SETTER */ && kind !== 3) /* GETTER */) {\n                    throw new Error(\n                        \"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \"\n                            + name\n                    );\n                } else if (!existingKind && kind > 2 /* METHOD */) {\n                    existingNonFields.set(name, kind);\n                } else {\n                    existingNonFields.set(name, true);\n                }\n            }\n\n            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);\n        }\n\n        pushInitializers(ret, protoInitializers);\n        pushInitializers(ret, staticInitializers);\n        return ret;\n    }\n\n    function pushInitializers(ret, initializers) {\n        if (initializers) {\n            ret.push(function(instance) {\n                for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n                return instance;\n            });\n        }\n    }\n\n    function applyClassDecs(targetClass, classDecs, metadata) {\n        if (classDecs.length > 0) {\n            var initializers = [];\n            var newClass = targetClass;\n            var name = targetClass.name;\n\n            for (var i = classDecs.length - 1; i >= 0; i--) {\n                var decoratorFinishedRef = { v: false };\n\n                try {\n                    var nextNewClass = classDecs[i](newClass, { kind: \"class\", name: name, addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef), metadata });\n                } finally {\n                    decoratorFinishedRef.v = true;\n                }\n\n                if (nextNewClass !== undefined) {\n                    assertValidReturnValue(10, /* CLASS */ nextNewClass);\n                    newClass = nextNewClass;\n                }\n            }\n\n            return [defineMetadata(newClass, metadata), function() {\n                for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n            }];\n        }\n        // The transformer will not emit assignment when there are no class decorators,\n        // so we don't have to return an empty array here.\n    }\n\n    function defineMetadata(Class, metadata) {\n        return Object.defineProperty(Class, Symbol.metadata || Symbol.for(\"Symbol.metadata\"), { configurable: true, enumerable: true, value: metadata });\n    }\n\n    /**\n    Basic usage:\n\n    applyDecs(\n      Class,\n      [\n        // member decorators\n        [\n          dec,                // dec or array of decs\n          0,                  // kind of value being decorated\n          'prop',             // name of public prop on class containing the value being decorated,\n          '#p',               // the name of the private property (if is private, void 0 otherwise),\n        ]\n      ],\n      [\n        // class decorators\n        dec1, dec2\n      ]\n    )\n    ```\n\n    Fully transpiled example:\n\n    ```js\n    @dec\n    class Class {\n      @dec\n      a = 123;\n\n      @dec\n      #a = 123;\n\n      @dec\n      @dec2\n      accessor b = 123;\n\n      @dec\n      accessor #b = 123;\n\n      @dec\n      c() { console.log('c'); }\n\n      @dec\n      #c() { console.log('privC'); }\n\n      @dec\n      get d() { console.log('d'); }\n\n      @dec\n      get #d() { console.log('privD'); }\n\n      @dec\n      set e(v) { console.log('e'); }\n\n      @dec\n      set #e(v) { console.log('privE'); }\n    }\n\n\n    // becomes\n    let initializeInstance;\n    let initializeClass;\n\n    let initA;\n    let initPrivA;\n\n    let initB;\n    let initPrivB, getPrivB, setPrivB;\n\n    let privC;\n    let privD;\n    let privE;\n\n    let Class;\n    class _Class {\n      static {\n        let ret = applyDecs(\n          this,\n          [\n            [dec, 0, 'a'],\n            [dec, 0, 'a', (i) => i.#a, (i, v) => i.#a = v],\n            [[dec, dec2], 1, 'b'],\n            [dec, 1, 'b', (i) => i.#privBData, (i, v) => i.#privBData = v],\n            [dec, 2, 'c'],\n            [dec, 2, 'c', () => console.log('privC')],\n            [dec, 3, 'd'],\n            [dec, 3, 'd', () => console.log('privD')],\n            [dec, 4, 'e'],\n            [dec, 4, 'e', () => console.log('privE')],\n          ],\n          [\n            dec\n          ]\n        )\n\n        initA = ret[0];\n\n        initPrivA = ret[1];\n\n        initB = ret[2];\n\n        initPrivB = ret[3];\n        getPrivB = ret[4];\n        setPrivB = ret[5];\n\n        privC = ret[6];\n\n        privD = ret[7];\n\n        privE = ret[8];\n\n        initializeInstance = ret[9];\n\n        Class = ret[10]\n\n        initializeClass = ret[11];\n      }\n\n      a = (initializeInstance(this), initA(this, 123));\n\n      #a = initPrivA(this, 123);\n\n      #bData = initB(this, 123);\n      get b() { return this.#bData }\n      set b(v) { this.#bData = v }\n\n      #privBData = initPrivB(this, 123);\n      get #b() { return getPrivB(this); }\n      set #b(v) { setPrivB(this, v); }\n\n      c() { console.log('c'); }\n\n      #c(...args) { return privC(this, ...args) }\n\n      get d() { console.log('d'); }\n\n      get #d() { return privD(this); }\n\n      set e(v) { console.log('e'); }\n\n      set #e(v) { privE(this, v); }\n    }\n\n    initializeClass(Class);\n   */\n\n    exports._ = _apply_decs_2203_r = function(targetClass, memberDecs, classDecs, parentClass) {\n        if (parentClass !== void 0) {\n            var parentMetadata = parentClass[Symbol.metadata || Symbol.for(\"Symbol.metadata\")];\n        }\n        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);\n        var e = applyMemberDecs(targetClass, memberDecs, metadata);\n        if (!classDecs.length) defineMetadata(targetClass, metadata);\n        return {\n            e: e,\n            // Lazily apply class decorations so that member init locals can be properly bound.\n            get c() {\n                return applyClassDecs(targetClass, classDecs, metadata);\n            }\n        };\n    };\n\n    return _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass);\n}\n\nexports._ = _apply_decs_2203_r;\n"
        }
    ]
}