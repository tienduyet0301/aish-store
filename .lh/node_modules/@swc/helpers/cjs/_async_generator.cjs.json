{
    "sourceFile": "node_modules/@swc/helpers/cjs/_async_generator.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891935105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\nvar _await_value = require(\"./_await_value.cjs\");\n\nfunction _async_generator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n        return new Promise(function(resolve, reject) {\n            var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null };\n            if (back) back = back.next = request;\n            else {\n                front = back = request;\n                resume(key, arg);\n            }\n        });\n    }\n\n    function resume(key, arg) {\n        try {\n            var result = gen[key](arg);\n            var value = result.value;\n            var wrappedAwait = value instanceof _await_value._;\n            Promise.resolve(wrappedAwait ? value.wrapped : value).then(function(arg) {\n                if (wrappedAwait) {\n                    resume(\"next\", arg);\n\n                    return;\n                }\n                settle(result.done ? \"return\" : \"normal\", arg);\n            }, function(err) {\n                resume(\"throw\", err);\n            });\n        } catch (err) {\n            settle(\"throw\", err);\n        }\n    }\n\n    function settle(type, value) {\n        switch (type) {\n            case \"return\":\n                front.resolve({ value: value, done: true });\n                break;\n            case \"throw\":\n                front.reject(value);\n                break;\n            default:\n                front.resolve({ value: value, done: false });\n                break;\n        }\n        front = front.next;\n        if (front) resume(front.key, front.arg);\n        else back = null;\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") this.return = undefined;\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    _async_generator.prototype[Symbol.asyncIterator] = function() {\n        return this;\n    };\n}\n\n_async_generator.prototype.next = function(arg) {\n    return this._invoke(\"next\", arg);\n};\n\n_async_generator.prototype.throw = function(arg) {\n    return this._invoke(\"throw\", arg);\n};\n\n_async_generator.prototype.return = function(arg) {\n    return this._invoke(\"return\", arg);\n};\nexports._ = _async_generator;\n"
        }
    ]
}