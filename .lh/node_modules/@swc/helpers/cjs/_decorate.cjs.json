{
    "sourceFile": "node_modules/@swc/helpers/cjs/_decorate.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891936681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\nvar _to_array = require(\"./_to_array.cjs\");\nvar _to_property_key = require(\"./_to_property_key.cjs\");\nvar _type_of = require(\"./_type_of.cjs\");\n\nfunction _decorate(decorators, factory, superClass) {\n    var r = factory(function initialize(O) {\n        _initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = _decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);\n    _initializeClassElements(r.F, decorated.elements);\n\n    return _runClassFinishers(r.F, decorated.finishers);\n}\n\nfunction _createElementDescriptor(def) {\n    var key = _to_property_key._(def.key);\n    var descriptor;\n\n    if (def.kind === \"method\") {\n        descriptor = { value: def.value, writable: true, configurable: true, enumerable: false };\n        Object.defineProperty(def.value, \"name\", { value: _type_of._(key) === \"symbol\" ? \"\" : key, configurable: true });\n    } else if (def.kind === \"get\") descriptor = { get: def.value, configurable: true, enumerable: false };\n    else if (def.kind === \"set\") descriptor = { set: def.value, configurable: true, enumerable: false };\n    else if (def.kind === \"field\") descriptor = { configurable: true, writable: true, enumerable: true };\n\n    var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor };\n\n    if (def.decorators) element.decorators = def.decorators;\n\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n}\nfunction _coalesceGetterSetter(element, other) {\n    if (element.descriptor.get !== undefined) other.descriptor.get = element.descriptor.get;\n    else other.descriptor.set = element.descriptor.set;\n}\nfunction _coalesceClassElements(elements) {\n    var newElements = [];\n    var isSameElement = function isSameElement(other) {\n        return other.kind === \"method\" && other.key === element.key && other.placement === element.placement;\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n        var other;\n\n        if (element.kind === \"method\" && (other = newElements.find(isSameElement))) {\n            if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n                if (_hasDecorators(element) || _hasDecorators(other)) {\n                    throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\");\n                }\n                other.descriptor = element.descriptor;\n            } else {\n                if (_hasDecorators(element)) {\n                    if (_hasDecorators(other)) {\n                        throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\");\n                    }\n                    other.decorators = element.decorators;\n                }\n                _coalesceGetterSetter(element, other);\n            }\n        } else {\n            newElements.push(element);\n        }\n    }\n\n    return newElements;\n}\nfunction _hasDecorators(element) {\n    return element.decorators && element.decorators.length;\n}\nfunction _isDataDescriptor(desc) {\n    return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n}\nfunction _initializeClassElements(F, elements) {\n    var proto = F.prototype;\n    [\"method\", \"field\"].forEach(function(kind) {\n        elements.forEach(function(element) {\n            var placement = element.placement;\n            if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) {\n                var receiver = placement === \"static\" ? F : proto;\n                _defineClassElement(receiver, element);\n            }\n        });\n    });\n}\nfunction _initializeInstanceElements(O, elements) {\n    [\"method\", \"field\"].forEach(function(kind) {\n        elements.forEach(function(element) {\n            if (element.kind === kind && element.placement === \"own\") _defineClassElement(O, element);\n        });\n    });\n}\nfunction _defineClassElement(receiver, element) {\n    var descriptor = element.descriptor;\n    if (element.kind === \"field\") {\n        var initializer = element.initializer;\n        descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) };\n    }\n    Object.defineProperty(receiver, element.key, descriptor);\n}\nfunction _decorateClass(elements, decorators) {\n    var newElements = [];\n    var finishers = [];\n    var placements = { static: [], prototype: [], own: [] };\n    elements.forEach(function(element) {\n        _addElementPlacement(element, placements);\n    });\n    elements.forEach(function(element) {\n        if (!_hasDecorators(element)) return newElements.push(element);\n        var elementFinishersExtras = _decorateElement(element, placements);\n        newElements.push(elementFinishersExtras.element);\n        newElements.push.apply(newElements, elementFinishersExtras.extras);\n        finishers.push.apply(finishers, elementFinishersExtras.finishers);\n    });\n    if (!decorators) return { elements: newElements, finishers: finishers };\n    var result = _decorateConstructor(newElements, decorators);\n    finishers.push.apply(finishers, result.finishers);\n    result.finishers = finishers;\n\n    return result;\n}\nfunction _addElementPlacement(element, placements, silent) {\n    var keys = placements[element.placement];\n    if (!silent && keys.indexOf(element.key) !== -1) throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n    keys.push(element.key);\n}\nfunction _decorateElement(element, placements) {\n    var extras = [];\n    var finishers = [];\n    for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n        var keys = placements[element.placement];\n        keys.splice(keys.indexOf(element.key), 1);\n        var elementObject = _fromElementDescriptor(element);\n        var elementFinisherExtras = _toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);\n        element = elementFinisherExtras.element;\n        _addElementPlacement(element, placements);\n        if (elementFinisherExtras.finisher) finishers.push(elementFinisherExtras.finisher);\n        var newExtras = elementFinisherExtras.extras;\n        if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) _addElementPlacement(newExtras[j], placements);\n            extras.push.apply(extras, newExtras);\n        }\n    }\n\n    return { element: element, finishers: finishers, extras: extras };\n}\nfunction _decorateConstructor(elements, decorators) {\n    var finishers = [];\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var obj = _fromClassDescriptor(elements);\n        var elementsAndFinisher = _toClassDescriptor((0, decorators[i])(obj) || obj);\n        if (elementsAndFinisher.finisher !== undefined) finishers.push(elementsAndFinisher.finisher);\n        if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n            for (var j = 0; j < elements.length - 1; j++) {\n                for (var k = j + 1; k < elements.length; k++) {\n                    if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {\n                        throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\");\n                    }\n                }\n            }\n        }\n    }\n\n    return { elements: elements, finishers: finishers };\n}\nfunction _fromElementDescriptor(element) {\n    var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor };\n    var desc = { value: \"Descriptor\", configurable: true };\n    Object.defineProperty(obj, Symbol.toStringTag, desc);\n    if (element.kind === \"field\") obj.initializer = element.initializer;\n\n    return obj;\n}\nfunction _toElementDescriptors(elementObjects) {\n    if (elementObjects === undefined) return;\n\n    return _to_array._(elementObjects).map(function(elementObject) {\n        var element = _toElementDescriptor(elementObject);\n        _disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n        _disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n\n        return element;\n    });\n}\nfunction _toElementDescriptor(elementObject) {\n    var kind = String(elementObject.kind);\n    if (kind !== \"method\" && kind !== \"field\") {\n        throw new TypeError(\"An element descriptor's .kind property must be either \\\"method\\\" or\" + \" \\\"field\\\", but a decorator created an element descriptor with\" + \" .kind \\\"\" + kind + \"\\\"\");\n    }\n    var key = _to_property_key._(elementObject.key);\n    var placement = String(elementObject.placement);\n    if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") {\n        throw new TypeError(\n            \"An element descriptor's .placement property must be one of \\\"static\\\",\"\n                + \" \\\"prototype\\\" or \\\"own\\\", but a decorator created an element descriptor\"\n                + \" with .placement \\\"\"\n                + placement\n                + \"\\\"\"\n        );\n    }\n    var descriptor = elementObject.descriptor;\n    _disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n    var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) };\n    if (kind !== \"field\") _disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n    else {\n        _disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\");\n        _disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\");\n        _disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\");\n        element.initializer = elementObject.initializer;\n    }\n\n    return element;\n}\nfunction _toElementFinisherExtras(elementObject) {\n    var element = _toElementDescriptor(elementObject);\n    var finisher = _optionalCallableProperty(elementObject, \"finisher\");\n    var extras = _toElementDescriptors(elementObject.extras);\n\n    return { element: element, finisher: finisher, extras: extras };\n}\nfunction _fromClassDescriptor(elements) {\n    var obj = { kind: \"class\", elements: elements.map(_fromElementDescriptor) };\n    var desc = { value: \"Descriptor\", configurable: true };\n    Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n    return obj;\n}\nfunction _toClassDescriptor(obj) {\n    var kind = String(obj.kind);\n    if (kind !== \"class\") {\n        throw new TypeError(\"A class descriptor's .kind property must be \\\"class\\\", but a decorator\" + \" created a class descriptor with .kind \\\"\" + kind + \"\\\"\");\n    }\n    _disallowProperty(obj, \"key\", \"A class descriptor\");\n    _disallowProperty(obj, \"placement\", \"A class descriptor\");\n    _disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n    _disallowProperty(obj, \"initializer\", \"A class descriptor\");\n    _disallowProperty(obj, \"extras\", \"A class descriptor\");\n    var finisher = _optionalCallableProperty(obj, \"finisher\");\n    var elements = _toElementDescriptors(obj.elements);\n\n    return { elements: elements, finisher: finisher };\n}\nfunction _disallowProperty(obj, name, objectType) {\n    if (obj[name] !== undefined) throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n}\nfunction _optionalCallableProperty(obj, name) {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n        throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n\n    return value;\n}\nfunction _runClassFinishers(constructor, finishers) {\n    for (var i = 0; i < finishers.length; i++) {\n        var newConstructor = (0, finishers[i])(constructor);\n        if (newConstructor !== undefined) {\n            if (typeof newConstructor !== \"function\") throw new TypeError(\"Finishers must return a constructor.\");\n            constructor = newConstructor;\n        }\n    }\n\n    return constructor;\n}\nexports._ = _decorate;\n"
        }
    ]
}