{
    "sourceFile": "node_modules/motion-utils/dist/motion-utils.dev.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892646749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MotionUtils = {}));\n})(this, (function (exports) { 'use strict';\n\n    function addUniqueItem(arr, item) {\n        if (arr.indexOf(item) === -1)\n            arr.push(item);\n    }\n    function removeItem(arr, item) {\n        const index = arr.indexOf(item);\n        if (index > -1)\n            arr.splice(index, 1);\n    }\n    // Adapted from array-move\n    function moveItem([...arr], fromIndex, toIndex) {\n        const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n        if (startIndex >= 0 && startIndex < arr.length) {\n            const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n            const [item] = arr.splice(fromIndex, 1);\n            arr.splice(endIndex, 0, item);\n        }\n        return arr;\n    }\n\n    const clamp = (min, max, v) => {\n        if (v > max)\n            return max;\n        if (v < min)\n            return min;\n        return v;\n    };\n\n    exports.warning = () => { };\n    exports.invariant = () => { };\n    {\n        exports.warning = (check, message) => {\n            if (!check && typeof console !== \"undefined\") {\n                console.warn(message);\n            }\n        };\n        exports.invariant = (check, message) => {\n            if (!check) {\n                throw new Error(message);\n            }\n        };\n    }\n\n    const MotionGlobalConfig = {};\n\n    /**\n     * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n     */\n    const isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\n    /**\n     * Check if the value is a zero value string like \"0px\" or \"0%\"\n     */\n    const isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\n    /*#__NO_SIDE_EFFECTS__*/\n    function memo(callback) {\n        let result;\n        return () => {\n            if (result === undefined)\n                result = callback();\n            return result;\n        };\n    }\n\n    /*#__NO_SIDE_EFFECTS__*/\n    const noop = (any) => any;\n\n    /**\n     * Pipe\n     * Compose other transformers to run linearily\n     * pipe(min(20), max(40))\n     * @param  {...functions} transformers\n     * @return {function}\n     */\n    const combineFunctions = (a, b) => (v) => b(a(v));\n    const pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n    /*\n      Progress within given range\n\n      Given a lower limit and an upper limit, we return the progress\n      (expressed as a number 0-1) represented by the given value, and\n      limit that progress to within 0-1.\n\n      @param [number]: Lower limit\n      @param [number]: Upper limit\n      @param [number]: Value to find progress within given range\n      @return [number]: Progress of value within range as expressed 0-1\n    */\n    /*#__NO_SIDE_EFFECTS__*/\n    const progress = (from, to, value) => {\n        const toFromDifference = to - from;\n        return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n    };\n\n    class SubscriptionManager {\n        constructor() {\n            this.subscriptions = [];\n        }\n        add(handler) {\n            addUniqueItem(this.subscriptions, handler);\n            return () => removeItem(this.subscriptions, handler);\n        }\n        notify(a, b, c) {\n            const numSubscriptions = this.subscriptions.length;\n            if (!numSubscriptions)\n                return;\n            if (numSubscriptions === 1) {\n                /**\n                 * If there's only a single handler we can just call it without invoking a loop.\n                 */\n                this.subscriptions[0](a, b, c);\n            }\n            else {\n                for (let i = 0; i < numSubscriptions; i++) {\n                    /**\n                     * Check whether the handler exists before firing as it's possible\n                     * the subscriptions were modified during this loop running.\n                     */\n                    const handler = this.subscriptions[i];\n                    handler && handler(a, b, c);\n                }\n            }\n        }\n        getSize() {\n            return this.subscriptions.length;\n        }\n        clear() {\n            this.subscriptions.length = 0;\n        }\n    }\n\n    /**\n     * Converts seconds to milliseconds\n     *\n     * @param seconds - Time in seconds.\n     * @return milliseconds - Converted time in milliseconds.\n     */\n    /*#__NO_SIDE_EFFECTS__*/\n    const secondsToMilliseconds = (seconds) => seconds * 1000;\n    /*#__NO_SIDE_EFFECTS__*/\n    const millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\n    /*\n      Convert velocity into velocity per second\n\n      @param [number]: Unit per frame\n      @param [number]: Frame duration in ms\n    */\n    function velocityPerSecond(velocity, frameDuration) {\n        return frameDuration ? velocity * (1000 / frameDuration) : 0;\n    }\n\n    const warned = new Set();\n    function hasWarned(message) {\n        return warned.has(message);\n    }\n    function warnOnce(condition, message, element) {\n        if (condition || warned.has(message))\n            return;\n        console.warn(message);\n        if (element)\n            console.warn(element);\n        warned.add(message);\n    }\n\n    const wrap = (min, max, v) => {\n        const rangeSize = max - min;\n        return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n    };\n\n    /*\n      Bezier function generator\n      This has been modified from GaÃ«tan Renaudeau's BezierEasing\n      https://github.com/gre/bezier-easing/blob/master/src/index.js\n      https://github.com/gre/bezier-easing/blob/master/LICENSE\n      \n      I've removed the newtonRaphsonIterate algo because in benchmarking it\n      wasn't noticiably faster than binarySubdivision, indeed removing it\n      usually improved times, depending on the curve.\n      I also removed the lookup table, as for the added bundle size and loop we're\n      only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n      to 12 to compensate and this still tended to be faster for no perceivable\n      loss in accuracy.\n      Usage\n        const easeOut = cubicBezier(.17,.67,.83,.67);\n        const x = easeOut(0.5); // returns 0.627...\n    */\n    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n    const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n        t;\n    const subdivisionPrecision = 0.0000001;\n    const subdivisionMaxIterations = 12;\n    function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n        let currentX;\n        let currentT;\n        let i = 0;\n        do {\n            currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - x;\n            if (currentX > 0.0) {\n                upperBound = currentT;\n            }\n            else {\n                lowerBound = currentT;\n            }\n        } while (Math.abs(currentX) > subdivisionPrecision &&\n            ++i < subdivisionMaxIterations);\n        return currentT;\n    }\n    function cubicBezier(mX1, mY1, mX2, mY2) {\n        // If this is a linear gradient, return linear easing\n        if (mX1 === mY1 && mX2 === mY2)\n            return noop;\n        const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n        // If animation is at start/end, return t without easing\n        return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n    }\n\n    // Accepts an easing function and returns a new one that outputs mirrored values for\n    // the second half of the animation. Turns easeIn into easeInOut.\n    const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n    // Accepts an easing function and returns a new one that outputs reversed values.\n    // Turns easeIn into easeOut.\n    const reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\n    const backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\n    const backIn = /*@__PURE__*/ reverseEasing(backOut);\n    const backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\n    const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\n    const circIn = (p) => 1 - Math.sin(Math.acos(p));\n    const circOut = reverseEasing(circIn);\n    const circInOut = mirrorEasing(circIn);\n\n    const easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\n    const easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\n    const easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\n    function steps(numSteps, direction = \"end\") {\n        return (progress) => {\n            progress =\n                direction === \"end\"\n                    ? Math.min(progress, 0.999)\n                    : Math.max(progress, 0.001);\n            const expanded = progress * numSteps;\n            const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n            return clamp(0, 1, rounded / numSteps);\n        };\n    }\n\n    const isEasingArray = (ease) => {\n        return Array.isArray(ease) && typeof ease[0] !== \"number\";\n    };\n\n    function getEasingForSegment(easing, i) {\n        return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n    }\n\n    const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\n    const easingLookup = {\n        linear: noop,\n        easeIn,\n        easeInOut,\n        easeOut,\n        circIn,\n        circInOut,\n        circOut,\n        backIn,\n        backInOut,\n        backOut,\n        anticipate,\n    };\n    const isValidEasing = (easing) => {\n        return typeof easing === \"string\";\n    };\n    const easingDefinitionToFunction = (definition) => {\n        if (isBezierDefinition(definition)) {\n            // If cubic bezier definition, create bezier curve\n            exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n            const [x1, y1, x2, y2] = definition;\n            return cubicBezier(x1, y1, x2, y2);\n        }\n        else if (isValidEasing(definition)) {\n            // Else lookup from table\n            exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n            return easingLookup[definition];\n        }\n        return definition;\n    };\n\n    exports.MotionGlobalConfig = MotionGlobalConfig;\n    exports.SubscriptionManager = SubscriptionManager;\n    exports.addUniqueItem = addUniqueItem;\n    exports.anticipate = anticipate;\n    exports.backIn = backIn;\n    exports.backInOut = backInOut;\n    exports.backOut = backOut;\n    exports.circIn = circIn;\n    exports.circInOut = circInOut;\n    exports.circOut = circOut;\n    exports.clamp = clamp;\n    exports.cubicBezier = cubicBezier;\n    exports.easeIn = easeIn;\n    exports.easeInOut = easeInOut;\n    exports.easeOut = easeOut;\n    exports.easingDefinitionToFunction = easingDefinitionToFunction;\n    exports.getEasingForSegment = getEasingForSegment;\n    exports.hasWarned = hasWarned;\n    exports.isBezierDefinition = isBezierDefinition;\n    exports.isEasingArray = isEasingArray;\n    exports.isNumericalString = isNumericalString;\n    exports.isZeroValueString = isZeroValueString;\n    exports.memo = memo;\n    exports.millisecondsToSeconds = millisecondsToSeconds;\n    exports.mirrorEasing = mirrorEasing;\n    exports.moveItem = moveItem;\n    exports.noop = noop;\n    exports.pipe = pipe;\n    exports.progress = progress;\n    exports.removeItem = removeItem;\n    exports.reverseEasing = reverseEasing;\n    exports.secondsToMilliseconds = secondsToMilliseconds;\n    exports.steps = steps;\n    exports.velocityPerSecond = velocityPerSecond;\n    exports.warnOnce = warnOnce;\n    exports.wrap = wrap;\n\n}));\n"
        }
    ]
}