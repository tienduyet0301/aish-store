{
    "sourceFile": "node_modules/@next/eslint-plugin-next/dist/utils/url.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891883486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    execOnce: function() {\n        return execOnce;\n    },\n    getUrlFromAppDirectory: function() {\n        return getUrlFromAppDirectory;\n    },\n    getUrlFromPagesDirectories: function() {\n        return getUrlFromPagesDirectories;\n    },\n    normalizeAppPath: function() {\n        return normalizeAppPath;\n    },\n    normalizeURL: function() {\n        return normalizeURL;\n    }\n});\nvar _path = /*#__PURE__*/ _interop_require_wildcard(require(\"path\"));\nvar _fs = /*#__PURE__*/ _interop_require_wildcard(require(\"fs\"));\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\n// Cache for fs.readdirSync lookup.\n// Prevent multiple blocking IO requests that have already been calculated.\nvar fsReadDirSyncCache = {};\n/**\n * Recursively parse directory for page URLs.\n */ function parseUrlForPages(urlprefix, directory) {\n    var _fsReadDirSyncCache, _directory;\n    var _;\n    (_ = (_fsReadDirSyncCache = fsReadDirSyncCache)[_directory = directory]) !== null && _ !== void 0 ? _ : _fsReadDirSyncCache[_directory] = _fs.readdirSync(directory, {\n        withFileTypes: true\n    });\n    var res = [];\n    fsReadDirSyncCache[directory].forEach(function(dirent) {\n        // TODO: this should account for all page extensions\n        // not just js(x) and ts(x)\n        if (/(\\.(j|t)sx?)$/.test(dirent.name)) {\n            if (/^index(\\.(j|t)sx?)$/.test(dirent.name)) {\n                res.push(\"\".concat(urlprefix).concat(dirent.name.replace(/^index(\\.(j|t)sx?)$/, '')));\n            }\n            res.push(\"\".concat(urlprefix).concat(dirent.name.replace(/(\\.(j|t)sx?)$/, '')));\n        } else {\n            var dirPath = _path.join(directory, dirent.name);\n            if (dirent.isDirectory() && !dirent.isSymbolicLink()) {\n                var _res;\n                (_res = res).push.apply(_res, _to_consumable_array(parseUrlForPages(urlprefix + dirent.name + '/', dirPath)));\n            }\n        }\n    });\n    return res;\n}\n/**\n * Recursively parse app directory for URLs.\n */ function parseUrlForAppDir(urlprefix, directory) {\n    var _fsReadDirSyncCache, _directory;\n    var _;\n    (_ = (_fsReadDirSyncCache = fsReadDirSyncCache)[_directory = directory]) !== null && _ !== void 0 ? _ : _fsReadDirSyncCache[_directory] = _fs.readdirSync(directory, {\n        withFileTypes: true\n    });\n    var res = [];\n    fsReadDirSyncCache[directory].forEach(function(dirent) {\n        // TODO: this should account for all page extensions\n        // not just js(x) and ts(x)\n        if (/(\\.(j|t)sx?)$/.test(dirent.name)) {\n            if (/^page(\\.(j|t)sx?)$/.test(dirent.name)) {\n                res.push(\"\".concat(urlprefix).concat(dirent.name.replace(/^page(\\.(j|t)sx?)$/, '')));\n            } else if (!/^layout(\\.(j|t)sx?)$/.test(dirent.name)) {\n                res.push(\"\".concat(urlprefix).concat(dirent.name.replace(/(\\.(j|t)sx?)$/, '')));\n            }\n        } else {\n            var dirPath = _path.join(directory, dirent.name);\n            if (dirent.isDirectory(dirPath) && !dirent.isSymbolicLink()) {\n                var _res;\n                (_res = res).push.apply(_res, _to_consumable_array(parseUrlForPages(urlprefix + dirent.name + '/', dirPath)));\n            }\n        }\n    });\n    return res;\n}\nfunction normalizeURL(url) {\n    if (!url) {\n        return;\n    }\n    url = url.split('?', 1)[0];\n    url = url.split('#', 1)[0];\n    url = url = url.replace(/(\\/index\\.html)$/, '/');\n    // Empty URLs should not be trailed with `/`, e.g. `#heading`\n    if (url === '') {\n        return url;\n    }\n    url = url.endsWith('/') ? url : url + '/';\n    return url;\n}\nfunction normalizeAppPath(route) {\n    return ensureLeadingSlash(route.split('/').reduce(function(pathname, segment, index, segments) {\n        // Empty segments are ignored.\n        if (!segment) {\n            return pathname;\n        }\n        // Groups are ignored.\n        if (isGroupSegment(segment)) {\n            return pathname;\n        }\n        // Parallel segments are ignored.\n        if (segment[0] === '@') {\n            return pathname;\n        }\n        // The last segment (if it's a leaf) should be ignored.\n        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {\n            return pathname;\n        }\n        return \"\".concat(pathname, \"/\").concat(segment);\n    }, ''));\n}\nfunction getUrlFromPagesDirectories(urlPrefix, directories) {\n    return Array.from(// De-duplicate similar pages across multiple directories.\n    new Set(directories.flatMap(function(directory) {\n        return parseUrlForPages(urlPrefix, directory);\n    }).map(// Since the URLs are normalized we add `^` and `$` to the RegExp to make sure they match exactly.\n    function(url) {\n        return \"^\".concat(normalizeURL(url), \"$\");\n    }))).map(function(urlReg) {\n        urlReg = urlReg.replace(/\\[.*\\]/g, '((?!.+?\\\\..+?).*?)');\n        return new RegExp(urlReg);\n    });\n}\nfunction getUrlFromAppDirectory(urlPrefix, directories) {\n    return Array.from(// De-duplicate similar pages across multiple directories.\n    new Set(directories.map(function(directory) {\n        return parseUrlForAppDir(urlPrefix, directory);\n    }).flat().map(// Since the URLs are normalized we add `^` and `$` to the RegExp to make sure they match exactly.\n    function(url) {\n        return \"^\".concat(normalizeAppPath(url), \"$\");\n    }))).map(function(urlReg) {\n        urlReg = urlReg.replace(/\\[.*\\]/g, '((?!.+?\\\\..+?).*?)');\n        return new RegExp(urlReg);\n    });\n}\nfunction execOnce(fn) {\n    var used = false;\n    var result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn.apply(void 0, _to_consumable_array(args));\n        }\n        return result;\n    };\n}\nfunction ensureLeadingSlash(route) {\n    return route.startsWith('/') ? route : \"/\".concat(route);\n}\nfunction isGroupSegment(segment) {\n    return segment[0] === '(' && segment.endsWith(')');\n}\n"
        }
    ]
}