{
    "sourceFile": "node_modules/@next/eslint-plugin-next/dist/rules/no-html-link-for-pages.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891883008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar _definerule = require(\"../utils/define-rule\");\nvar _path = /*#__PURE__*/ _interop_require_wildcard(require(\"path\"));\nvar _fs = /*#__PURE__*/ _interop_require_wildcard(require(\"fs\"));\nvar _getrootdirs = require(\"../utils/get-root-dirs\");\nvar _url = require(\"../utils/url\");\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {\n        __proto__: null\n    };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar pagesDirWarning = (0, _url.execOnce)(function(pagesDirs) {\n    console.warn(\"Pages directory cannot be found at \".concat(pagesDirs.join(' or '), \". \") + 'If using a custom path, please configure with the `no-html-link-for-pages` rule in your eslint config file.');\n});\n// Cache for fs.existsSync lookup.\n// Prevent multiple blocking IO requests that have already been calculated.\nvar fsExistsSyncCache = {};\nvar memoize = function(fn) {\n    var cache = {};\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var key = JSON.stringify(args);\n        if (cache[key] === undefined) {\n            cache[key] = fn.apply(void 0, _to_consumable_array(args));\n        }\n        return cache[key];\n    };\n};\nvar cachedGetUrlFromPagesDirectories = memoize(_url.getUrlFromPagesDirectories);\nvar cachedGetUrlFromAppDirectory = memoize(_url.getUrlFromAppDirectory);\nvar url = 'https://nextjs.org/docs/messages/no-html-link-for-pages';\nmodule.exports = (0, _definerule.defineRule)({\n    meta: {\n        docs: {\n            description: 'Prevent usage of `<a>` elements to navigate to internal Next.js pages.',\n            category: 'HTML',\n            recommended: true,\n            url: url\n        },\n        type: 'problem',\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: 'string'\n                    },\n                    {\n                        type: 'array',\n                        uniqueItems: true,\n                        items: {\n                            type: 'string'\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    /**\n   * Creates an ESLint rule listener.\n   */ create: function create(context) {\n        var ruleOptions = context.options;\n        var _ruleOptions = _sliced_to_array(ruleOptions, 1), customPagesDirectory = _ruleOptions[0];\n        var rootDirs = (0, _getrootdirs.getRootDirs)(context);\n        var pagesDirs = (customPagesDirectory ? [\n            customPagesDirectory\n        ] : rootDirs.map(function(dir) {\n            return [\n                _path.join(dir, 'pages'),\n                _path.join(dir, 'src', 'pages')\n            ];\n        })).flat();\n        var foundPagesDirs = pagesDirs.filter(function(dir) {\n            if (fsExistsSyncCache[dir] === undefined) {\n                fsExistsSyncCache[dir] = _fs.existsSync(dir);\n            }\n            return fsExistsSyncCache[dir];\n        });\n        var appDirs = rootDirs.map(function(dir) {\n            return [\n                _path.join(dir, 'app'),\n                _path.join(dir, 'src', 'app')\n            ];\n        }).flat();\n        var foundAppDirs = appDirs.filter(function(dir) {\n            if (fsExistsSyncCache[dir] === undefined) {\n                fsExistsSyncCache[dir] = _fs.existsSync(dir);\n            }\n            return fsExistsSyncCache[dir];\n        });\n        // warn if there are no pages and app directories\n        if (foundPagesDirs.length === 0 && foundAppDirs.length === 0) {\n            pagesDirWarning(pagesDirs);\n            return {};\n        }\n        var pageUrls = cachedGetUrlFromPagesDirectories('/', foundPagesDirs);\n        var appDirUrls = cachedGetUrlFromAppDirectory('/', foundAppDirs);\n        var allUrlRegex = _to_consumable_array(pageUrls).concat(_to_consumable_array(appDirUrls));\n        return {\n            JSXOpeningElement: function JSXOpeningElement(node) {\n                if (node.name.name !== 'a') {\n                    return;\n                }\n                if (node.attributes.length === 0) {\n                    return;\n                }\n                var target = node.attributes.find(function(attr) {\n                    return attr.type === 'JSXAttribute' && attr.name.name === 'target';\n                });\n                if (target && target.value.value === '_blank') {\n                    return;\n                }\n                var href = node.attributes.find(function(attr) {\n                    return attr.type === 'JSXAttribute' && attr.name.name === 'href';\n                });\n                if (!href || href.value && href.value.type !== 'Literal') {\n                    return;\n                }\n                var hasDownloadAttr = node.attributes.find(function(attr) {\n                    return attr.type === 'JSXAttribute' && attr.name.name === 'download';\n                });\n                if (hasDownloadAttr) {\n                    return;\n                }\n                var hrefPath = (0, _url.normalizeURL)(href.value.value);\n                // Outgoing links are ignored\n                if (/^(https?:\\/\\/|\\/\\/)/.test(hrefPath)) {\n                    return;\n                }\n                allUrlRegex.forEach(function(foundUrl) {\n                    if (foundUrl.test((0, _url.normalizeURL)(hrefPath))) {\n                        context.report({\n                            node: node,\n                            message: \"Do not use an `<a>` element to navigate to `\".concat(hrefPath, \"`. Use `<Link />` from `next/link` instead. See: \").concat(url)\n                        });\n                    }\n                });\n            }\n        };\n    }\n});\n"
        }
    ]
}