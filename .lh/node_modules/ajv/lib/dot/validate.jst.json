{
    "sourceFile": "node_modules/ajv/lib/dot/validate.jst",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892015307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "{{# def.definitions }}\n{{# def.errors }}\n{{# def.defaults }}\n{{# def.coerce }}\n\n{{ /**\n    * schema compilation (render) time:\n    * it = { schema, RULES, _validate, opts }\n    * it.validate - this template function,\n    *   it is used recursively to generate code for subschemas\n    *\n    * runtime:\n    * \"validate\" is a variable name to which this function will be assigned\n    * validateRef etc. are defined in the parent scope in index.js\n    */ }}\n\n{{\n  var $async = it.schema.$async === true\n    , $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref')\n    , $id = it.self._getId(it.schema);\n}}\n\n{{\n  if (it.opts.strictKeywords) {\n    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);\n    if ($unknownKwd) {\n      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;\n      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);\n      else throw new Error($keywordsMsg);\n    }\n  }\n}}\n\n{{? it.isTop }}\n  var validate = {{?$async}}{{it.async = true;}}async {{?}}function(data, dataPath, parentData, parentDataProperty, rootData) {\n    'use strict';\n    {{? $id && (it.opts.sourceCode || it.opts.processCode) }}\n      {{= '/\\*# sourceURL=' + $id + ' */' }}\n    {{?}}\n{{?}}\n\n{{? typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref) }}\n  {{ var $keyword = 'false schema'; }}\n  {{# def.setupKeyword }}\n  {{? it.schema === false}}\n    {{? it.isTop}}\n      {{ $breakOnError = true; }}\n    {{??}}\n      var {{=$valid}} = false;\n    {{?}}\n    {{# def.error:'false schema' }}\n  {{??}}\n    {{? it.isTop}}\n      {{? $async }}\n        return data;\n      {{??}}\n        validate.errors = null;\n        return true;\n      {{?}}\n    {{??}}\n      var {{=$valid}} = true;\n    {{?}}\n  {{?}}\n\n  {{? it.isTop}}\n    };\n    return validate;\n  {{?}}\n\n  {{ return out; }}\n{{?}}\n\n\n{{? it.isTop }}\n  {{\n    var $top = it.isTop\n      , $lvl = it.level = 0\n      , $dataLvl = it.dataLevel = 0\n      , $data = 'data';\n    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n\n    it.dataPathArr = [\"\"];\n\n    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {\n      var $defaultMsg = 'default is ignored in the schema root';\n      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n      else throw new Error($defaultMsg);\n    }\n  }}\n\n  var vErrors = null; {{ /* don't edit, used in replace */ }}\n  var errors = 0;     {{ /* don't edit, used in replace */ }}\n  if (rootData === undefined) rootData = data; {{ /* don't edit, used in replace */ }}\n{{??}}\n  {{\n    var $lvl = it.level\n      , $dataLvl = it.dataLevel\n      , $data = 'data' + ($dataLvl || '');\n\n    if ($id) it.baseId = it.resolve.url(it.baseId, $id);\n\n    if ($async && !it.async) throw new Error('async schema in sync schema');\n  }}\n\n  var errs_{{=$lvl}} = errors;\n{{?}}\n\n{{\n  var $valid = 'valid' + $lvl\n    , $breakOnError = !it.opts.allErrors\n    , $closingBraces1 = ''\n    , $closingBraces2 = '';\n\n  var $errorKeyword;\n  var $typeSchema = it.schema.type\n    , $typeIsArray = Array.isArray($typeSchema);\n\n  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {\n    if ($typeIsArray) {\n      if ($typeSchema.indexOf('null') == -1)\n        $typeSchema = $typeSchema.concat('null');\n    } else if ($typeSchema != 'null') {\n      $typeSchema = [$typeSchema, 'null'];\n      $typeIsArray = true;\n    }\n  }\n\n  if ($typeIsArray && $typeSchema.length == 1) {\n    $typeSchema = $typeSchema[0];\n    $typeIsArray = false;\n  }\n}}\n\n{{## def.checkType:\n  {{\n    var $schemaPath = it.schemaPath + '.type'\n      , $errSchemaPath = it.errSchemaPath + '/type'\n      , $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';\n  }}\n\n  if ({{= it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) }}) {\n#}}\n\n{{? it.schema.$ref && $refKeywords }}\n  {{? it.opts.extendRefs == 'fail' }}\n    {{ throw new Error('$ref: validation keywords used in schema at path \"' + it.errSchemaPath + '\" (see option extendRefs)'); }}\n  {{?? it.opts.extendRefs !== true }}\n    {{\n      $refKeywords = false;\n      it.logger.warn('$ref: keywords ignored in schema at path \"' + it.errSchemaPath + '\"');\n    }}\n  {{?}}\n{{?}}\n\n{{? it.schema.$comment && it.opts.$comment }}\n  {{= it.RULES.all.$comment.code(it, '$comment') }}\n{{?}}\n\n{{? $typeSchema }}\n  {{? it.opts.coerceTypes }}\n    {{ var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema); }}\n  {{?}}\n\n  {{ var $rulesGroup = it.RULES.types[$typeSchema]; }}\n  {{? $coerceToTypes || $typeIsArray || $rulesGroup === true ||\n    ($rulesGroup && !$shouldUseGroup($rulesGroup)) }}\n    {{\n      var $schemaPath = it.schemaPath + '.type'\n        , $errSchemaPath = it.errSchemaPath + '/type';\n    }}\n    {{# def.checkType }}\n      {{? $coerceToTypes }}\n        {{# def.coerceType }}\n      {{??}}\n        {{# def.error:'type' }}\n      {{?}}\n    }\n  {{?}}\n{{?}}\n\n\n{{? it.schema.$ref && !$refKeywords }}\n  {{= it.RULES.all.$ref.code(it, '$ref') }}\n  {{? $breakOnError }}\n    }\n    if (errors === {{?$top}}0{{??}}errs_{{=$lvl}}{{?}}) {\n    {{ $closingBraces2 += '}'; }}\n  {{?}}\n{{??}}\n  {{~ it.RULES:$rulesGroup }}\n    {{? $shouldUseGroup($rulesGroup) }}\n      {{? $rulesGroup.type }}\n        if ({{= it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) }}) {\n      {{?}}\n        {{? it.opts.useDefaults }}\n          {{? $rulesGroup.type == 'object' && it.schema.properties }}\n            {{# def.defaultProperties }}\n          {{?? $rulesGroup.type == 'array' && Array.isArray(it.schema.items) }}\n            {{# def.defaultItems }}\n          {{?}}\n        {{?}}\n        {{~ $rulesGroup.rules:$rule }}\n          {{? $shouldUseRule($rule) }}\n            {{ var $code = $rule.code(it, $rule.keyword, $rulesGroup.type); }}\n            {{? $code }}\n              {{= $code }}\n              {{? $breakOnError }}\n                {{ $closingBraces1 += '}'; }}\n              {{?}}\n            {{?}}\n          {{?}}\n        {{~}}\n        {{? $breakOnError }}\n          {{= $closingBraces1 }}\n          {{ $closingBraces1 = ''; }}\n        {{?}}\n      {{? $rulesGroup.type }}\n        }\n        {{? $typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes }}\n          else {\n            {{\n              var $schemaPath = it.schemaPath + '.type'\n                , $errSchemaPath = it.errSchemaPath + '/type';\n            }}\n            {{# def.error:'type' }}\n          }\n        {{?}}\n      {{?}}\n\n      {{? $breakOnError }}\n        if (errors === {{?$top}}0{{??}}errs_{{=$lvl}}{{?}}) {\n        {{ $closingBraces2 += '}'; }}\n      {{?}}\n    {{?}}\n  {{~}}\n{{?}}\n\n{{? $breakOnError }} {{= $closingBraces2 }} {{?}}\n\n{{? $top }}\n    {{? $async }}\n      if (errors === 0) return data;           {{ /* don't edit, used in replace */ }}\n      else throw new ValidationError(vErrors); {{ /* don't edit, used in replace */ }}\n    {{??}}\n      validate.errors = vErrors; {{ /* don't edit, used in replace */ }}\n      return errors === 0;       {{ /* don't edit, used in replace */ }}\n    {{?}}\n  };\n\n  return validate;\n{{??}}\n  var {{=$valid}} = errors === errs_{{=$lvl}};\n{{?}}\n\n{{\n  function $shouldUseGroup($rulesGroup) {\n    var rules = $rulesGroup.rules;\n    for (var i=0; i < rules.length; i++)\n      if ($shouldUseRule(rules[i]))\n        return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined ||\n           ($rule.implements && $ruleImplementsSomeKeyword($rule));\n  }\n\n  function $ruleImplementsSomeKeyword($rule) {\n    var impl = $rule.implements;\n    for (var i=0; i < impl.length; i++)\n      if (it.schema[impl[i]] !== undefined)\n        return true;\n  }\n}}\n"
        }
    ]
}