{
    "sourceFile": "node_modules/ajv/lib/ajv.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892013461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "declare var ajv: {\n  (options?: ajv.Options): ajv.Ajv;\n  new(options?: ajv.Options): ajv.Ajv;\n  ValidationError: typeof AjvErrors.ValidationError;\n  MissingRefError: typeof AjvErrors.MissingRefError;\n  $dataMetaSchema: object;\n}\n\ndeclare namespace AjvErrors {\n  class ValidationError extends Error {\n    constructor(errors: Array<ajv.ErrorObject>);\n\n    message: string;\n    errors: Array<ajv.ErrorObject>;\n    ajv: true;\n    validation: true;\n  }\n\n  class MissingRefError extends Error {\n    constructor(baseId: string, ref: string, message?: string);\n    static message: (baseId: string, ref: string) => string;\n\n    message: string;\n    missingRef: string;\n    missingSchema: string;\n  }\n}\n\ndeclare namespace ajv {\n  type ValidationError = AjvErrors.ValidationError;\n\n  type MissingRefError = AjvErrors.MissingRefError;\n\n  interface Ajv {\n    /**\n    * Validate data using schema\n    * Schema will be compiled and cached (using serialized JSON as key, [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize by default).\n    * @param  {string|object|Boolean} schemaKeyRef key, ref or schema object\n    * @param  {Any} data to be validated\n    * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n    */\n    validate(schemaKeyRef: object | string | boolean, data: any): boolean | PromiseLike<any>;\n    /**\n    * Create validating function for passed schema.\n    * @param  {object|Boolean} schema schema object\n    * @return {Function} validating function\n    */\n    compile(schema: object | boolean): ValidateFunction;\n    /**\n    * Creates validating function for passed schema with asynchronous loading of missing schemas.\n    * `loadSchema` option should be a function that accepts schema uri and node-style callback.\n    * @this  Ajv\n    * @param {object|Boolean} schema schema object\n    * @param {Boolean} meta optional true to compile meta-schema; this parameter can be skipped\n    * @param {Function} callback optional node-style callback, it is always called with 2 parameters: error (or null) and validating function.\n    * @return {PromiseLike<ValidateFunction>} validating function\n    */\n    compileAsync(schema: object | boolean, meta?: Boolean, callback?: (err: Error, validate: ValidateFunction) => any): PromiseLike<ValidateFunction>;\n    /**\n    * Adds schema to the instance.\n    * @param {object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n    * @param {string} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    * @return {Ajv} this for method chaining\n    */\n    addSchema(schema: Array<object> | object, key?: string): Ajv;\n    /**\n    * Add schema that will be used to validate other schemas\n    * options in META_IGNORE_OPTIONS are alway set to false\n    * @param {object} schema schema object\n    * @param {string} key optional schema key\n    * @return {Ajv} this for method chaining\n    */\n    addMetaSchema(schema: object, key?: string): Ajv;\n    /**\n    * Validate schema\n    * @param {object|Boolean} schema schema to validate\n    * @return {Boolean} true if schema is valid\n    */\n    validateSchema(schema: object | boolean): boolean;\n    /**\n    * Get compiled schema from the instance by `key` or `ref`.\n    * @param  {string} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n    * @return {Function} schema validating function (with property `schema`). Returns undefined if keyRef can't be resolved to an existing schema.\n    */\n    getSchema(keyRef: string): ValidateFunction | undefined;\n    /**\n    * Remove cached schema(s).\n    * If no parameter is passed all schemas but meta-schemas are removed.\n    * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    * @param  {string|object|RegExp|Boolean} schemaKeyRef key, ref, pattern to match key/ref or schema object\n    * @return {Ajv} this for method chaining\n    */\n    removeSchema(schemaKeyRef?: object | string | RegExp | boolean): Ajv;\n    /**\n    * Add custom format\n    * @param {string} name format name\n    * @param {string|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n    * @return {Ajv} this for method chaining\n    */\n    addFormat(name: string, format: FormatValidator | FormatDefinition): Ajv;\n    /**\n    * Define custom keyword\n    * @this  Ajv\n    * @param {string} keyword custom keyword, should be a valid identifier, should be different from all standard, custom and macro keywords.\n    * @param {object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n    * @return {Ajv} this for method chaining\n    */\n    addKeyword(keyword: string, definition: KeywordDefinition): Ajv;\n    /**\n    * Get keyword definition\n    * @this  Ajv\n    * @param {string} keyword pre-defined or custom keyword.\n    * @return {object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n    */\n    getKeyword(keyword: string): object | boolean;\n    /**\n    * Remove keyword\n    * @this  Ajv\n    * @param {string} keyword pre-defined or custom keyword.\n    * @return {Ajv} this for method chaining\n    */\n    removeKeyword(keyword: string): Ajv;\n    /**\n    * Validate keyword\n    * @this  Ajv\n    * @param {object} definition keyword definition object\n    * @param {boolean} throwError true to throw exception if definition is invalid\n    * @return {boolean} validation result\n    */\n    validateKeyword(definition: KeywordDefinition, throwError: boolean): boolean;\n    /**\n    * Convert array of error message objects to string\n    * @param  {Array<object>} errors optional array of validation errors, if not passed errors from the instance are used.\n    * @param  {object} options optional options with properties `separator` and `dataVar`.\n    * @return {string} human readable string with all errors descriptions\n    */\n    errorsText(errors?: Array<ErrorObject> | null, options?: ErrorsTextOptions): string;\n    errors?: Array<ErrorObject> | null;\n    _opts: Options;\n  }\n\n  interface CustomLogger {\n    log(...args: any[]): any;\n    warn(...args: any[]): any;\n    error(...args: any[]): any;\n  }\n\n  interface ValidateFunction {\n    (\n      data: any,\n      dataPath?: string,\n      parentData?: object | Array<any>,\n      parentDataProperty?: string | number,\n      rootData?: object | Array<any>\n    ): boolean | PromiseLike<any>;\n    schema?: object | boolean;\n    errors?: null | Array<ErrorObject>;\n    refs?: object;\n    refVal?: Array<any>;\n    root?: ValidateFunction | object;\n    $async?: true;\n    source?: object;\n  }\n\n  interface Options {\n    $data?: boolean;\n    allErrors?: boolean;\n    verbose?: boolean;\n    jsonPointers?: boolean;\n    uniqueItems?: boolean;\n    unicode?: boolean;\n    format?: false | string;\n    formats?: object;\n    keywords?: object;\n    unknownFormats?: true | string[] | 'ignore';\n    schemas?: Array<object> | object;\n    schemaId?: '$id' | 'id' | 'auto';\n    missingRefs?: true | 'ignore' | 'fail';\n    extendRefs?: true | 'ignore' | 'fail';\n    loadSchema?: (uri: string, cb?: (err: Error, schema: object) => void) => PromiseLike<object | boolean>;\n    removeAdditional?: boolean | 'all' | 'failing';\n    useDefaults?: boolean | 'empty' | 'shared';\n    coerceTypes?: boolean | 'array';\n    strictDefaults?: boolean | 'log';\n    strictKeywords?: boolean | 'log';\n    strictNumbers?: boolean;\n    async?: boolean | string;\n    transpile?: string | ((code: string) => string);\n    meta?: boolean | object;\n    validateSchema?: boolean | 'log';\n    addUsedSchema?: boolean;\n    inlineRefs?: boolean | number;\n    passContext?: boolean;\n    loopRequired?: number;\n    ownProperties?: boolean;\n    multipleOfPrecision?: boolean | number;\n    errorDataPath?: string,\n    messages?: boolean;\n    sourceCode?: boolean;\n    processCode?: (code: string, schema: object) => string;\n    cache?: object;\n    logger?: CustomLogger | false;\n    nullable?: boolean;\n    serialize?: ((schema: object | boolean) => any) | false;\n  }\n\n  type FormatValidator = string | RegExp | ((data: string) => boolean | PromiseLike<any>);\n  type NumberFormatValidator = ((data: number) => boolean | PromiseLike<any>);\n\n  interface NumberFormatDefinition {\n    type: \"number\",\n    validate: NumberFormatValidator;\n    compare?: (data1: number, data2: number) => number;\n    async?: boolean;\n  }\n\n  interface StringFormatDefinition {\n    type?: \"string\",\n    validate: FormatValidator;\n    compare?: (data1: string, data2: string) => number;\n    async?: boolean;\n  }\n\n  type FormatDefinition = NumberFormatDefinition | StringFormatDefinition;\n\n  interface KeywordDefinition {\n    type?: string | Array<string>;\n    async?: boolean;\n    $data?: boolean;\n    errors?: boolean | string;\n    metaSchema?: object;\n    // schema: false makes validate not to expect schema (ValidateFunction)\n    schema?: boolean;\n    statements?: boolean;\n    dependencies?: Array<string>;\n    modifying?: boolean;\n    valid?: boolean;\n    // one and only one of the following properties should be present\n    validate?: SchemaValidateFunction | ValidateFunction;\n    compile?: (schema: any, parentSchema: object, it: CompilationContext) => ValidateFunction;\n    macro?: (schema: any, parentSchema: object, it: CompilationContext) => object | boolean;\n    inline?: (it: CompilationContext, keyword: string, schema: any, parentSchema: object) => string;\n  }\n\n  interface CompilationContext {\n    level: number;\n    dataLevel: number;\n    dataPathArr: string[];\n    schema: any;\n    schemaPath: string;\n    baseId: string;\n    async: boolean;\n    opts: Options;\n    formats: {\n      [index: string]: FormatDefinition | undefined;\n    };\n    keywords: {\n      [index: string]: KeywordDefinition | undefined;\n    };\n    compositeRule: boolean;\n    validate: (schema: object) => boolean;\n    util: {\n      copy(obj: any, target?: any): any;\n      toHash(source: string[]): { [index: string]: true | undefined };\n      equal(obj: any, target: any): boolean;\n      getProperty(str: string): string;\n      schemaHasRules(schema: object, rules: any): string;\n      escapeQuotes(str: string): string;\n      toQuotedString(str: string): string;\n      getData(jsonPointer: string, dataLevel: number, paths: string[]): string;\n      escapeJsonPointer(str: string): string;\n      unescapeJsonPointer(str: string): string;\n      escapeFragment(str: string): string;\n      unescapeFragment(str: string): string;\n    };\n    self: Ajv;\n  }\n\n  interface SchemaValidateFunction {\n    (\n      schema: any,\n      data: any,\n      parentSchema?: object,\n      dataPath?: string,\n      parentData?: object | Array<any>,\n      parentDataProperty?: string | number,\n      rootData?: object | Array<any>\n    ): boolean | PromiseLike<any>;\n    errors?: Array<ErrorObject>;\n  }\n\n  interface ErrorsTextOptions {\n    separator?: string;\n    dataVar?: string;\n  }\n\n  interface ErrorObject {\n    keyword: string;\n    dataPath: string;\n    schemaPath: string;\n    params: ErrorParameters;\n    // Added to validation errors of propertyNames keyword schema\n    propertyName?: string;\n    // Excluded if messages set to false.\n    message?: string;\n    // These are added with the `verbose` option.\n    schema?: any;\n    parentSchema?: object;\n    data?: any;\n  }\n\n  type ErrorParameters = RefParams | LimitParams | AdditionalPropertiesParams |\n    DependenciesParams | FormatParams | ComparisonParams |\n    MultipleOfParams | PatternParams | RequiredParams |\n    TypeParams | UniqueItemsParams | CustomParams |\n    PatternRequiredParams | PropertyNamesParams |\n    IfParams | SwitchParams | NoParams | EnumParams;\n\n  interface RefParams {\n    ref: string;\n  }\n\n  interface LimitParams {\n    limit: number;\n  }\n\n  interface AdditionalPropertiesParams {\n    additionalProperty: string;\n  }\n\n  interface DependenciesParams {\n    property: string;\n    missingProperty: string;\n    depsCount: number;\n    deps: string;\n  }\n\n  interface FormatParams {\n    format: string\n  }\n\n  interface ComparisonParams {\n    comparison: string;\n    limit: number | string;\n    exclusive: boolean;\n  }\n\n  interface MultipleOfParams {\n    multipleOf: number;\n  }\n\n  interface PatternParams {\n    pattern: string;\n  }\n\n  interface RequiredParams {\n    missingProperty: string;\n  }\n\n  interface TypeParams {\n    type: string;\n  }\n\n  interface UniqueItemsParams {\n    i: number;\n    j: number;\n  }\n\n  interface CustomParams {\n    keyword: string;\n  }\n\n  interface PatternRequiredParams {\n    missingPattern: string;\n  }\n\n  interface PropertyNamesParams {\n    propertyName: string;\n  }\n\n  interface IfParams {\n    failingKeyword: string;\n  }\n\n  interface SwitchParams {\n    caseIndex: number;\n  }\n\n  interface NoParams { }\n\n  interface EnumParams {\n    allowedValues: Array<any>;\n  }\n}\n\nexport = ajv;\n"
        }
    ]
}