{
    "sourceFile": "node_modules/which-builtin-type/test/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893112017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar test = require('tape');\nvar inspect = require('object-inspect');\nvar assign = require('object.assign');\nvar forEach = require('for-each');\nvar arrows = require('make-arrow-function').list();\nvar generators = require('make-generator-function')();\nvar asyncs = require('make-async-function').list();\nvar hasSymbols = require('has-symbols')();\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar hasBigInts = require('has-bigints')();\nvar availableTypedArrays = require('available-typed-arrays');\n\nvar which = require('../');\n\nif (typeof process !== 'undefined') {\n\tprocess.on('unhandledRejection', function () {});\n}\n\ntest('nullish', function (t) {\n\tt.equal(which(null), null, 'null is null');\n\tt.equal(which(undefined), undefined, 'undefined is undefined');\n\t// @ts-expect-error\n\tt.equal(which(), undefined, 'absent is undefined');\n\n\tt.end();\n});\n\ntest('non-nullish', function (t) {\n\t/** @constructor */\n\tvar F = function Foo() {};\n\n\tvar tests = {\n\t\tNumber: [\n\t\t\t0,\n\t\t\t-0,\n\t\t\t42,\n\t\t\tInfinity,\n\t\t\t-Infinity,\n\t\t\tNaN,\n\t\t\t0.5\n\t\t],\n\t\tBoolean: [\n\t\t\ttrue,\n\t\t\tfalse\n\t\t],\n\t\tString: [\n\t\t\t'',\n\t\t\t'foo'\n\t\t],\n\t\tDate: [\n\t\t\tnew Date(),\n\t\t\tnew Date(NaN),\n\t\t\tassign(new Date(), { constructor: Object })\n\t\t],\n\t\tRegExp: [\n\t\t\t/(?:)/,\n\t\t\t/a/g,\n\t\t\tassign(/constructor/, { constructor: Object })\n\t\t],\n\t\tArray: [\n\t\t\t[],\n\t\t\t[42],\n\t\t\tassign([], { constructor: Object })\n\t\t],\n\t\tFunction: [\n\t\t\tfunction () {},\n\t\t\tfunction f() {},\n\t\t\tassign(function constructor() {}, { constructor: Object })\n\t\t].concat(arrows),\n\t\tGeneratorFunction: generators,\n\t\tAsyncFunction: asyncs,\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tObject: /** @type {object[]} */ ([\n\t\t\t{},\n\t\t\t{ constructor: null },\n\t\t\tMath\n\t\t]),\n\t\tSymbol: hasSymbols ? [\n\t\t\tSymbol.iterator,\n\t\t\tSymbol(),\n\t\t\tSymbol('foo'),\n\t\t\tSymbol['for'] ? Symbol['for']('bar') : Symbol('no \"for\" support') // eslint-disable-line no-restricted-properties\n\t\t] : [],\n\t\tBigInt: hasBigInts ? [\n\t\t\tBigInt(0),\n\t\t\tBigInt(42)\n\t\t] : [],\n\t\tFoo: [\n\t\t\tnew F()\n\t\t],\n\t\tMap: typeof Map === 'function' ? [\n\t\t\tnew Map(),\n\t\t\tnew Map([[1, 2], [3, 4]]),\n\t\t\tassign(new Map(), { constructor: Object })\n\t\t] : [],\n\t\tWeakMap: typeof WeakMap === 'function' ? [\n\t\t\tnew WeakMap(),\n\t\t\tassign(new WeakMap(), { constructor: Object })\n\t\t] : [],\n\t\tSet: typeof Set === 'function' ? [\n\t\t\tnew Set(),\n\t\t\tnew Set([1, 2, 3, 4]),\n\t\t\tassign(new Set(), { constructor: Object })\n\t\t] : [],\n\t\tWeakSet: typeof WeakSet === 'function' ? [\n\t\t\tnew WeakSet(),\n\t\t\tassign(new WeakSet(), { constructor: Object })\n\t\t] : [],\n\t\tWeakRef: typeof WeakRef === 'function' ? [\n\t\t\tnew WeakRef({}),\n\t\t\tassign(new WeakRef({}), { constructor: Object })\n\t\t] : [],\n\t\tFinalizationRegistry: typeof FinalizationRegistry === 'function' ? [\n\t\t\tnew FinalizationRegistry(function () {}),\n\t\t\tassign(new FinalizationRegistry(function () {}), { constructor: Object })\n\t\t] : [],\n\t\tPromise: typeof Promise === 'function' ? [\n\t\t\tPromise.resolve(42),\n\t\t\tPromise.reject(NaN),\n\t\t\tnew Promise(function () {})\n\t\t] : []\n\t};\n\tforEach(availableTypedArrays(), function (TypedArray) {\n\t\t// @ts-expect-error not sure how to infer this as being spreaded into the above object literal\n\t\ttests[TypedArray] = [\n\t\t\tnew global[TypedArray](0),\n\t\t\tnew global[TypedArray](2)\n\t\t];\n\t});\n\tforEach(tests, function (values, expected) {\n\t\tforEach(values, function (value) {\n\t\t\tt.equal(which(value), expected, inspect(value) + ' is ' + inspect(expected));\n\t\t\tvar obj = Object(value);\n\t\t\tif (value !== obj) {\n\t\t\t\tt.equal(which(obj), expected, inspect(obj) + ' is ' + inspect(expected));\n\t\t\t}\n\t\t\tif (\n\t\t\t\texpected !== 'Object' // the fallback can't fall back\n\t\t\t\t&& expected !== 'Foo' // not a builtin\n\t\t\t) {\n\t\t\t\tif (hasToStringTag) {\n\t\t\t\t\t/** @type {{ [k in typeof Symbol.toStringTag]?: string }} */\n\t\t\t\t\tvar fakerTag = {};\n\t\t\t\t\tfakerTag[Symbol.toStringTag] = expected;\n\t\t\t\t\tt.equal(\n\t\t\t\t\t\twhich(fakerTag),\n\t\t\t\t\t\t'Object',\n\t\t\t\t\t\tinspect(fakerTag) + ' lies and claims it is a ' + expected + ', but instead it is Object'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t/** @typedef {Exclude<typeof expected, 'GeneratorFunction' | 'AsyncFunction' | 'Foo'>} GlobalKey */\n\n\t\t\t\tvar fakerConstructor = {\n\t\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\tconstructor: global[/** @type {GlobalKey} */ (expected)] || tests[expected]\n\t\t\t\t};\n\t\t\t\tt.equal(\n\t\t\t\t\twhich(fakerConstructor),\n\t\t\t\t\t'Object',\n\t\t\t\t\tinspect(fakerConstructor) + ' lies and claims it is a ' + expected + ', but instead it is Object'\n\t\t\t\t);\n\n\t\t\t\tif (hasToStringTag) {\n\t\t\t\t\t/** @type {{ constructor: Function } & { [k in typeof Symbol.toStringTag]?: string }} */\n\t\t\t\t\tvar fakerConstructorTag = {\n\t\t\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\t\t\tconstructor: global[/** @type {GlobalKey} */ (expected)] || tests[expected]\n\t\t\t\t\t};\n\t\t\t\t\tfakerConstructorTag[Symbol.toStringTag] = expected;\n\t\t\t\t\tt.equal(\n\t\t\t\t\t\twhich(fakerConstructorTag),\n\t\t\t\t\t\t'Object',\n\t\t\t\t\t\tinspect(fakerConstructorTag) + ' lies with a tag and claims it is a ' + expected + ', but instead it is Object'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\tt.end();\n});\n"
        }
    ]
}