{
    "sourceFile": "node_modules/enhanced-resolve/lib/Resolver.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892117494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require(\"tapable\");\nconst createInnerContext = require(\"./createInnerContext\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst {\n\tnormalize,\n\tcachedJoin: join,\n\tgetType,\n\tPathType\n} = require(\"./util/path\");\n\n/** @typedef {import(\"./ResolverFactory\").ResolveOptions} ResolveOptions */\n\n/** @typedef {Error & { details?: string }} ErrorWithDetail */\n\n/** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) => void} ResolveCallback */\n\n/**\n * @typedef {Object} PossibleFileSystemError\n * @property {string=} code\n * @property {number=} errno\n * @property {string=} path\n * @property {string=} syscall\n */\n\n/**\n * @template T\n * @callback FileSystemCallback\n * @param {PossibleFileSystemError & Error | null} err\n * @param {T=} result\n */\n\n/**\n * @typedef {string | Buffer | URL} PathLike\n */\n\n/**\n * @typedef {PathLike | number} PathOrFileDescriptor\n */\n\n/**\n * @typedef {Object} ObjectEncodingOptions\n * @property {BufferEncoding | null | undefined} [encoding]\n */\n\n/** @typedef {function(NodeJS.ErrnoException | null, string=): void} StringCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, Buffer=): void} BufferCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, (string | Buffer)=): void} StringOrBufferCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, IStats=): void} StatsCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, IBigIntStats=): void} BigIntStatsCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, (IStats | IBigIntStats)=): void} StatsOrBigIntStatsCallback */\n/** @typedef {function(NodeJS.ErrnoException | Error | null, JsonObject=): void} ReadJsonCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, string[]=): void} ReaddirStringCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, Buffer[]=): void} ReaddirBufferCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, (string[] | Buffer[])=): void} ReaddirStringOrBufferCallback */\n/** @typedef {function(NodeJS.ErrnoException | null, Dirent[]=): void} ReaddirDirentCallback */\n\n/**\n * @template T\n * @typedef {Object} IStatsBase\n * @property {() => boolean} isFile\n * @property {() => boolean} isDirectory\n * @property {() => boolean} isBlockDevice\n * @property {() => boolean} isCharacterDevice\n * @property {() => boolean} isSymbolicLink\n * @property {() => boolean} isFIFO\n * @property {() => boolean} isSocket\n * @property {T} dev\n * @property {T} ino\n * @property {T} mode\n * @property {T} nlink\n * @property {T} uid\n * @property {T} gid\n * @property {T} rdev\n * @property {T} size\n * @property {T} blksize\n * @property {T} blocks\n * @property {T} atimeMs\n * @property {T} mtimeMs\n * @property {T} ctimeMs\n * @property {T} birthtimeMs\n * @property {Date} atime\n * @property {Date} mtime\n * @property {Date} ctime\n * @property {Date} birthtime\n */\n\n/**\n * @typedef {IStatsBase<number>} IStats\n */\n\n/**\n * @typedef {IStatsBase<bigint> & { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint  }} IBigIntStats\n */\n\n/**\n * @typedef {Object} Dirent\n * @property {() => boolean} isFile\n * @property {() => boolean} isDirectory\n * @property {() => boolean} isBlockDevice\n * @property {() => boolean} isCharacterDevice\n * @property {() => boolean} isSymbolicLink\n * @property {() => boolean} isFIFO\n * @property {() => boolean} isSocket\n * @property {string} name\n * @property {string} path\n */\n\n/**\n * @typedef {Object} StatOptions\n * @property {(boolean | undefined)=} bigint\n */\n\n/**\n * @typedef {Object} StatSyncOptions\n * @property {(boolean | undefined)=} bigint\n * @property {(boolean | undefined)=} throwIfNoEntry\n */\n\n/**\n * @typedef {{\n * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined } & import(\"events\").Abortable) | undefined | null, callback: BufferCallback): void;\n * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined } & import(\"events\").Abortable) | BufferEncoding, callback: StringCallback): void;\n * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions & { flag?: string | undefined } & import(\"events\").Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;\n * (path: PathOrFileDescriptor, callback: BufferCallback): void;\n * }} ReadFile\n */\n\n/**\n * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null} EncodingOption\n */\n\n/**\n * @typedef {'buffer'| { encoding: 'buffer' }} BufferEncodingOption\n */\n\n/**\n * @typedef {{\n * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined } | null): Buffer;\n * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined } | BufferEncoding): string;\n * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions & { flag?: string | undefined }) | BufferEncoding | null): string | Buffer;\n * }} ReadFileSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null, callback: ReaddirStringCallback): void;\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer', callback: ReaddirBufferCallback): void;\n * (path: PathLike, callback: ReaddirStringCallback): void;\n * (path: PathLike, options: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | undefined | null, callback: ReaddirStringOrBufferCallback): void;\n * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }, callback: ReaddirDirentCallback): void;\n * }} Readdir\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | null): string[];\n * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer'): Buffer[];\n * (path: PathLike, options?: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | null): string[] | Buffer[];\n * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }): Dirent[];\n * }} ReaddirSync\n\n /**\n * @typedef {function(PathOrFileDescriptor, ReadJsonCallback): void} ReadJson\n */\n\n/**\n * @typedef {function(PathOrFileDescriptor): JsonObject} ReadJsonSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: EncodingOption, callback: StringCallback): void;\n * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;\n * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;\n * (path: PathLike, callback: StringCallback): void;\n * }} Readlink\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: EncodingOption): string;\n * (path: PathLike, options: BufferEncodingOption): Buffer;\n * (path: PathLike, options?: EncodingOption): string | Buffer;\n * }} ReadlinkSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, callback: StatsCallback): void;\n * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;\n * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;\n * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;\n * }} LStat\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: undefined): IStats;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;\n * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;\n * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;\n * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;\n * }} LStatSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, callback: StatsCallback): void;\n * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;\n * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;\n * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;\n * }} Stat\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: undefined): IStats;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;\n * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;\n * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;\n * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;\n * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;\n * }} StatSync\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options: EncodingOption, callback: StringCallback): void;\n * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;\n * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;\n * (path: PathLike, callback: StringCallback): void;\n * }} RealPath\n */\n\n/**\n * @typedef {{\n * (path: PathLike, options?: EncodingOption): string;\n * (path: PathLike, options: BufferEncodingOption): Buffer;\n * (path: PathLike, options?: EncodingOption): string | Buffer;\n * }} RealPathSync\n */\n\n/**\n * @typedef {Object} FileSystem\n * @property {ReadFile} readFile\n * @property {Readdir} readdir\n * @property {ReadJson=} readJson\n * @property {Readlink} readlink\n * @property {LStat=} lstat\n * @property {Stat} stat\n * @property {RealPath=} realpath\n */\n\n/**\n * @typedef {Object} SyncFileSystem\n * @property {ReadFileSync} readFileSync\n * @property {ReaddirSync} readdirSync\n * @property {ReadJsonSync=} readJsonSync\n * @property {ReadlinkSync} readlinkSync\n * @property {LStatSync=} lstatSync\n * @property {StatSync} statSync\n * @property {RealPathSync=} realpathSync\n */\n\n/**\n * @typedef {Object} ParsedIdentifier\n * @property {string} request\n * @property {string} query\n * @property {string} fragment\n * @property {boolean} directory\n * @property {boolean} module\n * @property {boolean} file\n * @property {boolean} internal\n */\n\n/** @typedef {string | number | boolean | null} JsonPrimitive */\n/** @typedef {JsonValue[]} JsonArray */\n/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */\n/** @typedef {{[Key in string]: JsonValue} & {[Key in string]?: JsonValue | undefined}} JsonObject */\n\n/**\n * @typedef {Object} BaseResolveRequest\n * @property {string | false} path\n * @property {object=} context\n * @property {string=} descriptionFilePath\n * @property {string=} descriptionFileRoot\n * @property {JsonObject=} descriptionFileData\n * @property {string=} relativePath\n * @property {boolean=} ignoreSymlinks\n * @property {boolean=} fullySpecified\n * @property {string=} __innerRequest\n * @property {string=} __innerRequest_request\n * @property {string=} __innerRequest_relativePath\n */\n\n/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */\n\n/**\n * String with special formatting\n * @typedef {string} StackEntry\n */\n\n/**\n * @template T\n * @typedef {{ add: (item: T) => void }} WriteOnlySet\n */\n\n/** @typedef {(function (ResolveRequest): void)} ResolveContextYield */\n\n/**\n * Resolve context\n * @typedef {Object} ResolveContext\n * @property {WriteOnlySet<string>=} contextDependencies\n * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system\n * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system\n * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n * @property {(function(string): void)=} log log function\n * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results\n */\n\n/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */\n\n/**\n * @typedef {Object} KnownHooks\n * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep\n * @property {SyncHook<[ResolveRequest, Error]>} noResolve\n * @property {ResolveStepHook} resolve\n * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result\n */\n\n/**\n * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks\n */\n\n/**\n * @param {string} str input string\n * @returns {string} in camel case\n */\nfunction toCamelCase(str) {\n\treturn str.replace(/-([a-z])/g, str => str.slice(1).toUpperCase());\n}\n\nclass Resolver {\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @returns {StackEntry} stack entry\n\t */\n\tstatic createStackEntry(hook, request) {\n\t\treturn (\n\t\t\thook.name +\n\t\t\t\": (\" +\n\t\t\trequest.path +\n\t\t\t\") \" +\n\t\t\t(request.request || \"\") +\n\t\t\t(request.query || \"\") +\n\t\t\t(request.fragment || \"\") +\n\t\t\t(request.directory ? \" directory\" : \"\") +\n\t\t\t(request.module ? \" module\" : \"\")\n\t\t);\n\t}\n\n\t/**\n\t * @param {FileSystem} fileSystem a filesystem\n\t * @param {ResolveOptions} options options\n\t */\n\tconstructor(fileSystem, options) {\n\t\tthis.fileSystem = fileSystem;\n\t\tthis.options = options;\n\t\t/** @type {KnownHooks} */\n\t\tthis.hooks = {\n\t\t\tresolveStep: new SyncHook([\"hook\", \"request\"], \"resolveStep\"),\n\t\t\tnoResolve: new SyncHook([\"request\", \"error\"], \"noResolve\"),\n\t\t\tresolve: new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\t\"resolve\"\n\t\t\t),\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"], \"result\")\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tensureHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n\t\t\t\t\tstage: -10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n\t\t\t\t\tstage: 10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t/** @type {ResolveStepHook} */\n\t\tconst hook = /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\tif (!hook) {\n\t\t\t/** @type {KnownHooks & EnsuredHooks} */\n\t\t\t(this.hooks)[name] = new AsyncSeriesBailHook(\n\t\t\t\t[\"request\", \"resolveContext\"],\n\t\t\t\tname\n\t\t\t);\n\n\t\t\treturn /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {string | ResolveStepHook} name hook name or hook itself\n\t * @returns {ResolveStepHook} the hook\n\t */\n\tgetHook(name) {\n\t\tif (typeof name !== \"string\") {\n\t\t\treturn name;\n\t\t}\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({\n\t\t\t\t\tstage: -10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn /** @type {ResolveStepHook} */ (\n\t\t\t\tthis.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({\n\t\t\t\t\tstage: 10\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\t/** @type {ResolveStepHook} */\n\t\tconst hook = /** @type {KnownHooks & EnsuredHooks} */ (this.hooks)[name];\n\t\tif (!hook) {\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\n\t\t}\n\t\treturn hook;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @returns {string | false} result\n\t */\n\tresolveSync(context, path, request) {\n\t\t/** @type {Error | null | undefined} */\n\t\tlet err = undefined;\n\t\t/** @type {string | false | undefined} */\n\t\tlet result = undefined;\n\t\tlet sync = false;\n\t\tthis.resolve(context, path, request, {}, (e, r) => {\n\t\t\terr = e;\n\t\t\tresult = r;\n\t\t\tsync = true;\n\t\t});\n\t\tif (!sync) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\"\n\t\t\t);\n\t\t}\n\t\tif (err) throw err;\n\t\tif (result === undefined) throw new Error(\"No result\");\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {object} context context information object\n\t * @param {string} path context path\n\t * @param {string} request request string\n\t * @param {ResolveContext} resolveContext resolve context\n\t * @param {ResolveCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolve(context, path, request, resolveContext, callback) {\n\t\tif (!context || typeof context !== \"object\")\n\t\t\treturn callback(new Error(\"context argument is not an object\"));\n\t\tif (typeof path !== \"string\")\n\t\t\treturn callback(new Error(\"path argument is not a string\"));\n\t\tif (typeof request !== \"string\")\n\t\t\treturn callback(new Error(\"request argument is not a string\"));\n\t\tif (!resolveContext)\n\t\t\treturn callback(new Error(\"resolveContext argument is not set\"));\n\n\t\t/** @type {ResolveRequest} */\n\t\tconst obj = {\n\t\t\tcontext: context,\n\t\t\tpath: path,\n\t\t\trequest: request\n\t\t};\n\n\t\t/** @type {ResolveContextYield | undefined} */\n\t\tlet yield_;\n\t\tlet yieldCalled = false;\n\t\t/** @type {ResolveContextYield | undefined} */\n\t\tlet finishYield;\n\t\tif (typeof resolveContext.yield === \"function\") {\n\t\t\tconst old = resolveContext.yield;\n\t\t\t/**\n\t\t\t * @param {ResolveRequest} obj object\n\t\t\t */\n\t\t\tyield_ = obj => {\n\t\t\t\told(obj);\n\t\t\t\tyieldCalled = true;\n\t\t\t};\n\t\t\t/**\n\t\t\t * @param {ResolveRequest} result result\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tfinishYield = result => {\n\t\t\t\tif (result) {\n\t\t\t\t\t/** @type {ResolveContextYield} */ (yield_)(result);\n\t\t\t\t}\n\t\t\t\tcallback(null);\n\t\t\t};\n\t\t}\n\n\t\tconst message = `resolve '${request}' in '${path}'`;\n\n\t\t/**\n\t\t * @param {ResolveRequest} result result\n\t\t * @returns {void}\n\t\t */\n\t\tconst finishResolved = result => {\n\t\t\treturn callback(\n\t\t\t\tnull,\n\t\t\t\tresult.path === false\n\t\t\t\t\t? false\n\t\t\t\t\t: `${result.path.replace(/#/g, \"\\0#\")}${\n\t\t\t\t\t\t\tresult.query ? result.query.replace(/#/g, \"\\0#\") : \"\"\n\t\t\t\t\t  }${result.fragment || \"\"}`,\n\t\t\t\tresult\n\t\t\t);\n\t\t};\n\n\t\t/**\n\t\t * @param {string[]} log logs\n\t\t * @returns {void}\n\t\t */\n\t\tconst finishWithoutResolve = log => {\n\t\t\t/**\n\t\t\t * @type {ErrorWithDetail}\n\t\t\t */\n\t\t\tconst error = new Error(\"Can't \" + message);\n\t\t\terror.details = log.join(\"\\n\");\n\t\t\tthis.hooks.noResolve.call(obj, error);\n\t\t\treturn callback(error);\n\t\t};\n\n\t\tif (resolveContext.log) {\n\t\t\t// We need log anyway to capture it in case of an error\n\t\t\tconst parentLog = resolveContext.log;\n\t\t\t/** @type {string[]} */\n\t\t\tconst log = [];\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: msg => {\n\t\t\t\t\t\tparentLog(msg);\n\t\t\t\t\t\tlog.push(msg);\n\t\t\t\t\t},\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\t// Try to resolve assuming there is no error\n\t\t\t// We don't log stuff in this case\n\t\t\treturn this.doResolve(\n\t\t\t\tthis.hooks.resolve,\n\t\t\t\tobj,\n\t\t\t\tmessage,\n\t\t\t\t{\n\t\t\t\t\tlog: undefined,\n\t\t\t\t\tyield: yield_,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t},\n\t\t\t\t(err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result) return finishResolved(result);\n\n\t\t\t\t\t// log is missing for the error details\n\t\t\t\t\t// so we redo the resolving for the log info\n\t\t\t\t\t// this is more expensive to the success case\n\t\t\t\t\t// is assumed by default\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst log = [];\n\n\t\t\t\t\treturn this.doResolve(\n\t\t\t\t\t\tthis.hooks.resolve,\n\t\t\t\t\t\tobj,\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog: msg => log.push(msg),\n\t\t\t\t\t\t\tyield: yield_,\n\t\t\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t// In a case that there is a race condition and yield will be called\n\t\t\t\t\t\t\tif (yieldCalled || (result && yield_)) {\n\t\t\t\t\t\t\t\treturn /** @type {ResolveContextYield} */ (finishYield)(\n\t\t\t\t\t\t\t\t\t/** @type {ResolveRequest} */ (result)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn finishWithoutResolve(log);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ResolveStepHook} hook hook\n\t * @param {ResolveRequest} request request\n\t * @param {null|string} message string\n\t * @param {ResolveContext} resolveContext resolver context\n\t * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback\n\t * @returns {void}\n\t */\n\tdoResolve(hook, request, message, resolveContext, callback) {\n\t\tconst stackEntry = Resolver.createStackEntry(hook, request);\n\n\t\t/** @type {Set<string> | undefined} */\n\t\tlet newStack;\n\t\tif (resolveContext.stack) {\n\t\t\tnewStack = new Set(resolveContext.stack);\n\t\t\tif (resolveContext.stack.has(stackEntry)) {\n\t\t\t\t/**\n\t\t\t\t * Prevent recursion\n\t\t\t\t * @type {Error & {recursion?: boolean}}\n\t\t\t\t */\n\t\t\t\tconst recursionError = new Error(\n\t\t\t\t\t\"Recursion in resolving\\nStack:\\n  \" +\n\t\t\t\t\t\tArray.from(newStack).join(\"\\n  \")\n\t\t\t\t);\n\t\t\t\trecursionError.recursion = true;\n\t\t\t\tif (resolveContext.log)\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\n\t\t\t\treturn callback(recursionError);\n\t\t\t}\n\t\t\tnewStack.add(stackEntry);\n\t\t} else {\n\t\t\t// creating a set with new Set([item])\n\t\t\t// allocates a new array that has to be garbage collected\n\t\t\t// this is an EXTREMELY hot path, so let's avoid it\n\t\t\tnewStack = new Set();\n\t\t\tnewStack.add(stackEntry);\n\t\t}\n\t\tthis.hooks.resolveStep.call(hook, request);\n\n\t\tif (hook.isUsed()) {\n\t\t\tconst innerContext = createInnerContext(\n\t\t\t\t{\n\t\t\t\t\tlog: resolveContext.log,\n\t\t\t\t\tyield: resolveContext.yield,\n\t\t\t\t\tfileDependencies: resolveContext.fileDependencies,\n\t\t\t\t\tcontextDependencies: resolveContext.contextDependencies,\n\t\t\t\t\tmissingDependencies: resolveContext.missingDependencies,\n\t\t\t\t\tstack: newStack\n\t\t\t\t},\n\t\t\t\tmessage\n\t\t\t);\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) return callback(null, result);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier identifier\n\t * @returns {ParsedIdentifier} parsed identifier\n\t */\n\tparse(identifier) {\n\t\tconst part = {\n\t\t\trequest: \"\",\n\t\t\tquery: \"\",\n\t\t\tfragment: \"\",\n\t\t\tmodule: false,\n\t\t\tdirectory: false,\n\t\t\tfile: false,\n\t\t\tinternal: false\n\t\t};\n\n\t\tconst parsedIdentifier = parseIdentifier(identifier);\n\n\t\tif (!parsedIdentifier) return part;\n\n\t\t[part.request, part.query, part.fragment] = parsedIdentifier;\n\n\t\tif (part.request.length > 0) {\n\t\t\tpart.internal = this.isPrivate(identifier);\n\t\t\tpart.module = this.isModule(part.request);\n\t\t\tpart.directory = this.isDirectory(part.request);\n\t\t\tif (part.directory) {\n\t\t\t\tpart.request = part.request.slice(0, -1);\n\t\t\t}\n\t\t}\n\n\t\treturn part;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {boolean} true, if the path is a module\n\t */\n\tisModule(path) {\n\t\treturn getType(path) === PathType.Normal;\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {boolean} true, if the path is private\n\t */\n\tisPrivate(path) {\n\t\treturn getType(path) === PathType.Internal;\n\t}\n\n\t/**\n\t * @param {string} path a path\n\t * @returns {boolean} true, if the path is a directory path\n\t */\n\tisDirectory(path) {\n\t\treturn path.endsWith(\"/\");\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {string} request request\n\t * @returns {string} joined path\n\t */\n\tjoin(path, request) {\n\t\treturn join(path, request);\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @returns {string} normalized path\n\t */\n\tnormalize(path) {\n\t\treturn normalize(path);\n\t}\n}\n\nmodule.exports = Resolver;\n"
        }
    ]
}