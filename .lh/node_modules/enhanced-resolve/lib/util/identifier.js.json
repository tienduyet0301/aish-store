{
    "sourceFile": "node_modules/enhanced-resolve/lib/util/identifier.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892118027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst PATH_QUERY_FRAGMENT_REGEXP =\n\t/^(#?(?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst ZERO_ESCAPE_REGEXP = /\\0(.)/g;\n\n/**\n * @param {string} identifier identifier\n * @returns {[string, string, string]|null} parsed identifier\n */\nfunction parseIdentifier(identifier) {\n\tif (!identifier) {\n\t\treturn null;\n\t}\n\n\tconst firstEscape = identifier.indexOf(\"\\0\");\n\tif (firstEscape < 0) {\n\t\t// Fast path for inputs that don't use \\0 escaping.\n\t\tconst queryStart = identifier.indexOf(\"?\");\n\t\t// Start at index 1 to ignore a possible leading hash.\n\t\tconst fragmentStart = identifier.indexOf(\"#\", 1);\n\n\t\tif (fragmentStart < 0) {\n\t\t\tif (queryStart < 0) {\n\t\t\t\t// No fragment, no query\n\t\t\t\treturn [identifier, \"\", \"\"];\n\t\t\t}\n\t\t\t// Query, no fragment\n\t\t\treturn [\n\t\t\t\tidentifier.slice(0, queryStart),\n\t\t\t\tidentifier.slice(queryStart),\n\t\t\t\t\"\"\n\t\t\t];\n\t\t}\n\n\t\tif (queryStart < 0 || fragmentStart < queryStart) {\n\t\t\t// Fragment, no query\n\t\t\treturn [\n\t\t\t\tidentifier.slice(0, fragmentStart),\n\t\t\t\t\"\",\n\t\t\t\tidentifier.slice(fragmentStart)\n\t\t\t];\n\t\t}\n\n\t\t// Query and fragment\n\t\treturn [\n\t\t\tidentifier.slice(0, queryStart),\n\t\t\tidentifier.slice(queryStart, fragmentStart),\n\t\t\tidentifier.slice(fragmentStart)\n\t\t];\n\t}\n\n\tconst match = PATH_QUERY_FRAGMENT_REGEXP.exec(identifier);\n\n\tif (!match) return null;\n\n\treturn [\n\t\tmatch[1].replace(ZERO_ESCAPE_REGEXP, \"$1\"),\n\t\tmatch[2] ? match[2].replace(ZERO_ESCAPE_REGEXP, \"$1\") : \"\",\n\t\tmatch[3] || \"\"\n\t];\n}\n\nmodule.exports.parseIdentifier = parseIdentifier;\n"
        }
    ]
}