{
    "sourceFile": "node_modules/enhanced-resolve/lib/util/entrypoints.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892117980,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {[string[], string | null]} resolved paths with used field\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst { parseIdentifier } = require(\"./identifier\");\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\nconst patternRegEx = /\\*/g;\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsField(exportsField),\n\t\trequest => (request.length === 0 ? \".\" : \"./\" + request),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget\n\t);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField\n) {\n\treturn createFieldProcessor(\n\t\timportsField,\n\t\trequest => \"#\" + request,\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget\n\t);\n};\n\n/**\n * @param {ExportsField | ImportsField} field root\n * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(\n\tfield,\n\tnormalizeRequest,\n\tassertRequest,\n\tassertTarget\n) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\trequest = assertRequest(request);\n\n\t\tconst match = findMatch(normalizeRequest(request), field);\n\n\t\tif (match === null) return [[], null];\n\n\t\tconst [mapping, remainingRequest, isSubpathMapping, isPattern, usedField] =\n\t\t\tmatch;\n\n\t\t/** @type {DirectMapping|null} */\n\t\tlet direct = null;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [[], null];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\treturn [\n\t\t\tdirectMapping(\n\t\t\t\tremainingRequest,\n\t\t\t\tisPattern,\n\t\t\t\tisSubpathMapping,\n\t\t\t\tdirect,\n\t\t\t\tconditionNames,\n\t\t\t\tassertTarget\n\t\t\t),\n\t\t\tusedField\n\t\t];\n\t};\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return \"\";\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tconst parsedIdentifier = parseIdentifier(exp);\n\n\tif (!parsedIdentifier) {\n\t\treturn;\n\t}\n\n\tconst [relativePath] = parsedIdentifier;\n\tconst isFolder =\n\t\trelativePath.charCodeAt(relativePath.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst parsedIdentifier = parseIdentifier(imp);\n\n\tif (!parsedIdentifier) {\n\t\treturn;\n\t}\n\n\tconst [relativePath] = parsedIdentifier;\n\tconst isFolder =\n\t\trelativePath.charCodeAt(relativePath.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} a first string\n * @param {string} b second string\n * @returns {number} compare result\n */\nfunction patternKeyCompare(a, b) {\n\tconst aPatternIndex = a.indexOf(\"*\");\n\tconst bPatternIndex = b.indexOf(\"*\");\n\tconst baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n\tconst baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n\n\tif (baseLenA > baseLenB) return -1;\n\tif (baseLenB > baseLenA) return 1;\n\tif (aPatternIndex === -1) return 1;\n\tif (bPatternIndex === -1) return -1;\n\tif (a.length > b.length) return -1;\n\tif (b.length > a.length) return 1;\n\n\treturn 0;\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {ExportsField | ImportsField} field exports or import field\n * @returns {[MappingValue, string, boolean, boolean, string]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, field) {\n\tif (\n\t\tObject.prototype.hasOwnProperty.call(field, request) &&\n\t\t!request.includes(\"*\") &&\n\t\t!request.endsWith(\"/\")\n\t) {\n\t\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[request];\n\n\t\treturn [target, \"\", false, false, request];\n\t}\n\n\t/** @type {string} */\n\tlet bestMatch = \"\";\n\t/** @type {string|undefined} */\n\tlet bestMatchSubpath;\n\n\tconst keys = Object.getOwnPropertyNames(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst patternIndex = key.indexOf(\"*\");\n\n\t\tif (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {\n\t\t\tconst patternTrailer = key.slice(patternIndex + 1);\n\n\t\t\tif (\n\t\t\t\trequest.length >= key.length &&\n\t\t\t\trequest.endsWith(patternTrailer) &&\n\t\t\t\tpatternKeyCompare(bestMatch, key) === 1 &&\n\t\t\t\tkey.lastIndexOf(\"*\") === patternIndex\n\t\t\t) {\n\t\t\t\tbestMatch = key;\n\t\t\t\tbestMatchSubpath = request.slice(\n\t\t\t\t\tpatternIndex,\n\t\t\t\t\trequest.length - patternTrailer.length\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// For legacy `./foo/`\n\t\telse if (\n\t\t\tkey[key.length - 1] === \"/\" &&\n\t\t\trequest.startsWith(key) &&\n\t\t\tpatternKeyCompare(bestMatch, key) === 1\n\t\t) {\n\t\t\tbestMatch = key;\n\t\t\tbestMatchSubpath = request.slice(key.length);\n\t\t}\n\t}\n\n\tif (bestMatch === \"\") return null;\n\n\tconst target = /** @type {{[k: string]: MappingValue}} */ (field)[bestMatch];\n\tconst isSubpathMapping = bestMatch.endsWith(\"/\");\n\tconst isPattern = bestMatch.includes(\"*\");\n\n\treturn [\n\t\ttarget,\n\t\t/** @type {string} */ (bestMatchSubpath),\n\t\tisSubpathMapping,\n\t\tisPattern,\n\t\tbestMatch\n\t];\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tconditionNames,\n\tassert\n) {\n\tif (mappingTarget === null) return [];\n\n\tif (typeof mappingTarget === \"string\") {\n\t\treturn [\n\t\t\ttargetMapping(\n\t\t\t\tremainingRequest,\n\t\t\t\tisPattern,\n\t\t\t\tisSubpathMapping,\n\t\t\t\tmappingTarget,\n\t\t\t\tassert\n\t\t\t)\n\t\t];\n\t}\n\n\t/** @type {string[]} */\n\tconst targets = [];\n\n\tfor (const exp of mappingTarget) {\n\t\tif (typeof exp === \"string\") {\n\t\t\ttargets.push(\n\t\t\t\ttargetMapping(\n\t\t\t\t\tremainingRequest,\n\t\t\t\t\tisPattern,\n\t\t\t\t\tisSubpathMapping,\n\t\t\t\t\texp,\n\t\t\t\t\tassert\n\t\t\t\t)\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tisPattern,\n\t\t\tisSubpathMapping,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} isPattern true, if mapping is a pattern (contains \"*\")\n * @param {boolean} isSubpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(\n\tremainingRequest,\n\tisPattern,\n\tisSubpathMapping,\n\tmappingTarget,\n\tassert\n) {\n\tif (remainingRequest === undefined) {\n\t\tassert(mappingTarget, false);\n\n\t\treturn mappingTarget;\n\t}\n\n\tif (isSubpathMapping) {\n\t\tassert(mappingTarget, true);\n\n\t\treturn mappingTarget + remainingRequest;\n\t}\n\n\tassert(mappingTarget, false);\n\n\tlet result = mappingTarget;\n\n\tif (isPattern) {\n\t\tresult = result.replace(\n\t\t\tpatternRegEx,\n\t\t\tremainingRequest.replace(/\\$/g, \"$$\")\n\t\t);\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tlet lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\tif (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (\n\t\t\t\t\t\tinnerMapping\n\t\t\t\t\t);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {ExportsField} normalized exports field\n */\nfunction buildExportsField(field) {\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\" || Array.isArray(field)) {\n\t\treturn { \".\": field };\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn { \".\": field };\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn field;\n}\n"
        }
    ]
}