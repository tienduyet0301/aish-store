{
    "sourceFile": "node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892116503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst forEachBail = require(\"./forEachBail\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {{ alias: string|string[], extension: string }} ExtensionAliasOption */\n\nmodule.exports = class ExtensionAliasPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {ExtensionAliasOption} options options\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = options;\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tconst { extension, alias } = this.options;\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ExtensionAliasPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst requestPath = request.request;\n\t\t\t\tif (!requestPath || !requestPath.endsWith(extension)) return callback();\n\t\t\t\tconst isAliasString = typeof alias === \"string\";\n\t\t\t\t/**\n\t\t\t\t * @param {string} alias extension alias\n\t\t\t\t * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback\n\t\t\t\t * @param {number} [index] index\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst resolve = (alias, callback, index) => {\n\t\t\t\t\tconst newRequest = `${requestPath.slice(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t-extension.length\n\t\t\t\t\t)}${alias}`;\n\n\t\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\trequest: newRequest,\n\t\t\t\t\t\t\tfullySpecified: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t`aliased from extension alias with mapping '${extension}' to '${alias}'`,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t// Throw error if we are on the last alias (for multiple aliases) and it failed, always throw if we are not an array or we have only one alias\n\t\t\t\t\t\t\tif (!isAliasString && index) {\n\t\t\t\t\t\t\t\tif (index !== this.options.alias.length) {\n\t\t\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t\t\t\t\t`Failed to alias from extension alias with mapping '${extension}' to '${alias}' for '${newRequest}': ${err}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(err, result);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t\t/**\n\t\t\t\t * @param {null|Error} [err] error\n\t\t\t\t * @param {null|ResolveRequest} [result] result\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst stoppingCallback = (err, result) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t};\n\t\t\t\tif (isAliasString) {\n\t\t\t\t\tresolve(alias, stoppingCallback);\n\t\t\t\t} else if (alias.length > 1) {\n\t\t\t\t\tforEachBail(alias, resolve, stoppingCallback);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(alias[0], stoppingCallback);\n\t\t\t\t}\n\t\t\t});\n\t}\n};\n"
        }
    ]
}