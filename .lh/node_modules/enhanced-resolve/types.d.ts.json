{
    "sourceFile": "node_modules/enhanced-resolve/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892118255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n * This file was automatically generated.\n * DO NOT MODIFY BY HAND.\n * Run `yarn special-lint-fix` to update\n */\n\nimport { Buffer } from \"buffer\";\nimport { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } from \"tapable\";\nimport { URL as URL_Import } from \"url\";\n\ndeclare interface Abortable {\n\t/**\n\t * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.\n\t */\n\tsignal?: AbortSignal;\n}\ntype Alias = string | false | string[];\ndeclare interface AliasOption {\n\talias: Alias;\n\tname: string;\n\tonlyModule?: boolean;\n}\ntype AliasOptionNewRequest = string | false | string[];\ndeclare interface AliasOptions {\n\t[index: string]: AliasOptionNewRequest;\n}\ntype BaseFileSystem = FileSystem & SyncFileSystem;\ndeclare interface BaseResolveRequest {\n\tpath: string | false;\n\tcontext?: object;\n\tdescriptionFilePath?: string;\n\tdescriptionFileRoot?: string;\n\tdescriptionFileData?: JsonObject;\n\trelativePath?: string;\n\tignoreSymlinks?: boolean;\n\tfullySpecified?: boolean;\n\t__innerRequest?: string;\n\t__innerRequest_request?: string;\n\t__innerRequest_relativePath?: string;\n}\ntype BufferEncoding =\n\t| \"ascii\"\n\t| \"utf8\"\n\t| \"utf-8\"\n\t| \"utf16le\"\n\t| \"utf-16le\"\n\t| \"ucs2\"\n\t| \"ucs-2\"\n\t| \"base64\"\n\t| \"base64url\"\n\t| \"latin1\"\n\t| \"binary\"\n\t| \"hex\";\ntype BufferEncodingOption = \"buffer\" | { encoding: \"buffer\" };\ndeclare class CachedInputFileSystem {\n\tconstructor(fileSystem: BaseFileSystem, duration: number);\n\tfileSystem: BaseFileSystem;\n\tlstat?: LStat;\n\tlstatSync?: LStatSync;\n\tstat: Stat;\n\tstatSync: StatSync;\n\treaddir: Readdir;\n\treaddirSync: ReaddirSync;\n\treadFile: ReadFile;\n\treadFileSync: ReadFileSync;\n\treadJson?: (\n\t\targ0: PathOrFileDescriptor,\n\t\targ1: (\n\t\t\targ0: null | Error | NodeJS.ErrnoException,\n\t\t\targ1?: JsonObject\n\t\t) => void\n\t) => void;\n\treadJsonSync?: (arg0: PathOrFileDescriptor) => JsonObject;\n\treadlink: Readlink;\n\treadlinkSync: ReadlinkSync;\n\trealpath?: RealPath;\n\trealpathSync?: RealPathSync;\n\tpurge(\n\t\twhat?:\n\t\t\t| string\n\t\t\t| number\n\t\t\t| Buffer\n\t\t\t| URL_url\n\t\t\t| (string | number | Buffer | URL_url)[]\n\t\t\t| Set<string | number | Buffer | URL_url>\n\t): void;\n}\ndeclare class CloneBasenamePlugin {\n\tconstructor(\n\t\tsource:\n\t\t\t| string\n\t\t\t| AsyncSeriesBailHook<\n\t\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\t\tnull | ResolveRequest\n\t\t\t  >,\n\t\ttarget:\n\t\t\t| string\n\t\t\t| AsyncSeriesBailHook<\n\t\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\t\tnull | ResolveRequest\n\t\t\t  >\n\t);\n\tsource:\n\t\t| string\n\t\t| AsyncSeriesBailHook<\n\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\tnull | ResolveRequest\n\t\t  >;\n\ttarget:\n\t\t| string\n\t\t| AsyncSeriesBailHook<\n\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\tnull | ResolveRequest\n\t\t  >;\n\tapply(resolver: Resolver): void;\n}\ndeclare interface Dirent {\n\tisFile: () => boolean;\n\tisDirectory: () => boolean;\n\tisBlockDevice: () => boolean;\n\tisCharacterDevice: () => boolean;\n\tisSymbolicLink: () => boolean;\n\tisFIFO: () => boolean;\n\tisSocket: () => boolean;\n\tname: string;\n\tpath: string;\n}\ntype EncodingOption =\n\t| undefined\n\t| null\n\t| \"ascii\"\n\t| \"utf8\"\n\t| \"utf-8\"\n\t| \"utf16le\"\n\t| \"utf-16le\"\n\t| \"ucs2\"\n\t| \"ucs-2\"\n\t| \"base64\"\n\t| \"base64url\"\n\t| \"latin1\"\n\t| \"binary\"\n\t| \"hex\"\n\t| ObjectEncodingOptions;\ntype ErrorWithDetail = Error & { details?: string };\ndeclare interface ExtensionAliasOption {\n\talias: string | string[];\n\textension: string;\n}\ndeclare interface ExtensionAliasOptions {\n\t[index: string]: string | string[];\n}\ndeclare interface FileSystem {\n\treadFile: ReadFile;\n\treaddir: Readdir;\n\treadJson?: (\n\t\targ0: PathOrFileDescriptor,\n\t\targ1: (\n\t\t\targ0: null | Error | NodeJS.ErrnoException,\n\t\t\targ1?: JsonObject\n\t\t) => void\n\t) => void;\n\treadlink: Readlink;\n\tlstat?: LStat;\n\tstat: Stat;\n\trealpath?: RealPath;\n}\ntype IBigIntStats = IStatsBase<bigint> & {\n\tatimeNs: bigint;\n\tmtimeNs: bigint;\n\tctimeNs: bigint;\n\tbirthtimeNs: bigint;\n};\ndeclare interface IStats {\n\tisFile: () => boolean;\n\tisDirectory: () => boolean;\n\tisBlockDevice: () => boolean;\n\tisCharacterDevice: () => boolean;\n\tisSymbolicLink: () => boolean;\n\tisFIFO: () => boolean;\n\tisSocket: () => boolean;\n\tdev: number;\n\tino: number;\n\tmode: number;\n\tnlink: number;\n\tuid: number;\n\tgid: number;\n\trdev: number;\n\tsize: number;\n\tblksize: number;\n\tblocks: number;\n\tatimeMs: number;\n\tmtimeMs: number;\n\tctimeMs: number;\n\tbirthtimeMs: number;\n\tatime: Date;\n\tmtime: Date;\n\tctime: Date;\n\tbirthtime: Date;\n}\ndeclare interface IStatsBase<T> {\n\tisFile: () => boolean;\n\tisDirectory: () => boolean;\n\tisBlockDevice: () => boolean;\n\tisCharacterDevice: () => boolean;\n\tisSymbolicLink: () => boolean;\n\tisFIFO: () => boolean;\n\tisSocket: () => boolean;\n\tdev: T;\n\tino: T;\n\tmode: T;\n\tnlink: T;\n\tuid: T;\n\tgid: T;\n\trdev: T;\n\tsize: T;\n\tblksize: T;\n\tblocks: T;\n\tatimeMs: T;\n\tmtimeMs: T;\n\tctimeMs: T;\n\tbirthtimeMs: T;\n\tatime: Date;\n\tmtime: Date;\n\tctime: Date;\n\tbirthtime: Date;\n}\ndeclare interface Iterator<T, Z> {\n\t(\n\t\titem: T,\n\t\tcallback: (err?: null | Error, result?: null | Z) => void,\n\t\ti: number\n\t): void;\n}\ntype JsonObject = { [index: string]: JsonValue } & {\n\t[index: string]:\n\t\t| undefined\n\t\t| null\n\t\t| string\n\t\t| number\n\t\t| boolean\n\t\t| JsonObject\n\t\t| JsonValue[];\n};\ntype JsonValue = null | string | number | boolean | JsonObject | JsonValue[];\ndeclare interface KnownHooks {\n\tresolveStep: SyncHook<\n\t\t[\n\t\t\tAsyncSeriesBailHook<\n\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\tnull | ResolveRequest\n\t\t\t>,\n\t\t\tResolveRequest\n\t\t]\n\t>;\n\tnoResolve: SyncHook<[ResolveRequest, Error]>;\n\tresolve: AsyncSeriesBailHook<\n\t\t[ResolveRequest, ResolveContext],\n\t\tnull | ResolveRequest\n\t>;\n\tresult: AsyncSeriesHook<[ResolveRequest, ResolveContext]>;\n}\ndeclare interface LStat {\n\t(\n\t\tpath: PathLike,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: IStats) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: undefined | (StatOptions & { bigint?: false }),\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: IStats) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: StatOptions & { bigint: true },\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: IBigIntStats) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: undefined | StatOptions,\n\t\tcallback: (\n\t\t\targ0: null | NodeJS.ErrnoException,\n\t\t\targ1?: IStats | IBigIntStats\n\t\t) => void\n\t): void;\n}\ndeclare interface LStatSync {\n\t(path: PathLike, options?: undefined): IStats;\n\t(\n\t\tpath: PathLike,\n\t\toptions?: StatSyncOptions & { bigint?: false; throwIfNoEntry: false }\n\t): undefined | IStats;\n\t(\n\t\tpath: PathLike,\n\t\toptions: StatSyncOptions & { bigint: true; throwIfNoEntry: false }\n\t): undefined | IBigIntStats;\n\t(path: PathLike, options?: StatSyncOptions & { bigint?: false }): IStats;\n\t(path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n\t(\n\t\tpath: PathLike,\n\t\toptions: StatSyncOptions & { bigint: boolean; throwIfNoEntry?: false }\n\t): IStats | IBigIntStats;\n\t(path: PathLike, options?: StatSyncOptions):\n\t\t| undefined\n\t\t| IStats\n\t\t| IBigIntStats;\n}\ndeclare class LogInfoPlugin {\n\tconstructor(\n\t\tsource:\n\t\t\t| string\n\t\t\t| AsyncSeriesBailHook<\n\t\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\t\tnull | ResolveRequest\n\t\t\t  >\n\t);\n\tsource:\n\t\t| string\n\t\t| AsyncSeriesBailHook<\n\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\tnull | ResolveRequest\n\t\t  >;\n\tapply(resolver: Resolver): void;\n}\ndeclare interface ObjectEncodingOptions {\n\tencoding?:\n\t\t| null\n\t\t| \"ascii\"\n\t\t| \"utf8\"\n\t\t| \"utf-8\"\n\t\t| \"utf16le\"\n\t\t| \"utf-16le\"\n\t\t| \"ucs2\"\n\t\t| \"ucs-2\"\n\t\t| \"base64\"\n\t\t| \"base64url\"\n\t\t| \"latin1\"\n\t\t| \"binary\"\n\t\t| \"hex\";\n}\ndeclare interface ParsedIdentifier {\n\trequest: string;\n\tquery: string;\n\tfragment: string;\n\tdirectory: boolean;\n\tmodule: boolean;\n\tfile: boolean;\n\tinternal: boolean;\n}\ntype PathLike = string | Buffer | URL_url;\ntype PathOrFileDescriptor = string | number | Buffer | URL_url;\ntype Plugin =\n\t| undefined\n\t| null\n\t| false\n\t| \"\"\n\t| 0\n\t| { apply: (arg0: Resolver) => void }\n\t| ((this: Resolver, arg1: Resolver) => void);\ndeclare interface PnpApi {\n\tresolveToUnqualified: (\n\t\targ0: string,\n\t\targ1: string,\n\t\targ2: object\n\t) => null | string;\n}\ndeclare interface ReadFile {\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\toptions:\n\t\t\t| undefined\n\t\t\t| null\n\t\t\t| ({ encoding?: null; flag?: string } & Abortable),\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: Buffer) => void\n\t): void;\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\toptions:\n\t\t\t| ({ encoding: BufferEncoding; flag?: string } & Abortable)\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\",\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string) => void\n\t): void;\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\toptions:\n\t\t\t| undefined\n\t\t\t| null\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| (ObjectEncodingOptions & { flag?: string } & Abortable),\n\t\tcallback: (\n\t\t\targ0: null | NodeJS.ErrnoException,\n\t\t\targ1?: string | Buffer\n\t\t) => void\n\t): void;\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: Buffer) => void\n\t): void;\n}\ndeclare interface ReadFileSync {\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\toptions?: null | { encoding?: null; flag?: string }\n\t): Buffer;\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\toptions:\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| { encoding: BufferEncoding; flag?: string }\n\t): string;\n\t(\n\t\tpath: PathOrFileDescriptor,\n\t\toptions?:\n\t\t\t| null\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| (ObjectEncodingOptions & { flag?: string })\n\t): string | Buffer;\n}\ndeclare interface Readdir {\n\t(\n\t\tpath: PathLike,\n\t\toptions:\n\t\t\t| undefined\n\t\t\t| null\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| {\n\t\t\t\t\tencoding:\n\t\t\t\t\t\t| null\n\t\t\t\t\t\t| \"ascii\"\n\t\t\t\t\t\t| \"utf8\"\n\t\t\t\t\t\t| \"utf-8\"\n\t\t\t\t\t\t| \"utf16le\"\n\t\t\t\t\t\t| \"utf-16le\"\n\t\t\t\t\t\t| \"ucs2\"\n\t\t\t\t\t\t| \"ucs-2\"\n\t\t\t\t\t\t| \"base64\"\n\t\t\t\t\t\t| \"base64url\"\n\t\t\t\t\t\t| \"latin1\"\n\t\t\t\t\t\t| \"binary\"\n\t\t\t\t\t\t| \"hex\";\n\t\t\t\t\twithFileTypes?: false;\n\t\t\t\t\trecursive?: boolean;\n\t\t\t  },\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string[]) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions:\n\t\t\t| { encoding: \"buffer\"; withFileTypes?: false; recursive?: boolean }\n\t\t\t| \"buffer\",\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: Buffer[]) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string[]) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions:\n\t\t\t| undefined\n\t\t\t| null\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| (ObjectEncodingOptions & {\n\t\t\t\t\twithFileTypes?: false;\n\t\t\t\t\trecursive?: boolean;\n\t\t\t  }),\n\t\tcallback: (\n\t\t\targ0: null | NodeJS.ErrnoException,\n\t\t\targ1?: string[] | Buffer[]\n\t\t) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: ObjectEncodingOptions & {\n\t\t\twithFileTypes: true;\n\t\t\trecursive?: boolean;\n\t\t},\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: Dirent[]) => void\n\t): void;\n}\ndeclare interface ReaddirSync {\n\t(\n\t\tpath: PathLike,\n\t\toptions?:\n\t\t\t| null\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| {\n\t\t\t\t\tencoding:\n\t\t\t\t\t\t| null\n\t\t\t\t\t\t| \"ascii\"\n\t\t\t\t\t\t| \"utf8\"\n\t\t\t\t\t\t| \"utf-8\"\n\t\t\t\t\t\t| \"utf16le\"\n\t\t\t\t\t\t| \"utf-16le\"\n\t\t\t\t\t\t| \"ucs2\"\n\t\t\t\t\t\t| \"ucs-2\"\n\t\t\t\t\t\t| \"base64\"\n\t\t\t\t\t\t| \"base64url\"\n\t\t\t\t\t\t| \"latin1\"\n\t\t\t\t\t\t| \"binary\"\n\t\t\t\t\t\t| \"hex\";\n\t\t\t\t\twithFileTypes?: false;\n\t\t\t\t\trecursive?: boolean;\n\t\t\t  }\n\t): string[];\n\t(\n\t\tpath: PathLike,\n\t\toptions:\n\t\t\t| \"buffer\"\n\t\t\t| { encoding: \"buffer\"; withFileTypes?: false; recursive?: boolean }\n\t): Buffer[];\n\t(\n\t\tpath: PathLike,\n\t\toptions?:\n\t\t\t| null\n\t\t\t| \"ascii\"\n\t\t\t| \"utf8\"\n\t\t\t| \"utf-8\"\n\t\t\t| \"utf16le\"\n\t\t\t| \"utf-16le\"\n\t\t\t| \"ucs2\"\n\t\t\t| \"ucs-2\"\n\t\t\t| \"base64\"\n\t\t\t| \"base64url\"\n\t\t\t| \"latin1\"\n\t\t\t| \"binary\"\n\t\t\t| \"hex\"\n\t\t\t| (ObjectEncodingOptions & { withFileTypes?: false; recursive?: boolean })\n\t): string[] | Buffer[];\n\t(\n\t\tpath: PathLike,\n\t\toptions: ObjectEncodingOptions & {\n\t\t\twithFileTypes: true;\n\t\t\trecursive?: boolean;\n\t\t}\n\t): Dirent[];\n}\ndeclare interface Readlink {\n\t(\n\t\tpath: PathLike,\n\t\toptions: EncodingOption,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: BufferEncodingOption,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: Buffer) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: EncodingOption,\n\t\tcallback: (\n\t\t\targ0: null | NodeJS.ErrnoException,\n\t\t\targ1?: string | Buffer\n\t\t) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string) => void\n\t): void;\n}\ndeclare interface ReadlinkSync {\n\t(path: PathLike, options?: EncodingOption): string;\n\t(path: PathLike, options: BufferEncodingOption): Buffer;\n\t(path: PathLike, options?: EncodingOption): string | Buffer;\n}\ndeclare interface RealPath {\n\t(\n\t\tpath: PathLike,\n\t\toptions: EncodingOption,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: BufferEncodingOption,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: Buffer) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: EncodingOption,\n\t\tcallback: (\n\t\t\targ0: null | NodeJS.ErrnoException,\n\t\t\targ1?: string | Buffer\n\t\t) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: string) => void\n\t): void;\n}\ndeclare interface RealPathSync {\n\t(path: PathLike, options?: EncodingOption): string;\n\t(path: PathLike, options: BufferEncodingOption): Buffer;\n\t(path: PathLike, options?: EncodingOption): string | Buffer;\n}\ndeclare interface ResolveContext {\n\tcontextDependencies?: WriteOnlySet<string>;\n\n\t/**\n\t * files that was found on file system\n\t */\n\tfileDependencies?: WriteOnlySet<string>;\n\n\t/**\n\t * dependencies that was not found on file system\n\t */\n\tmissingDependencies?: WriteOnlySet<string>;\n\n\t/**\n\t * set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,\n\t */\n\tstack?: Set<string>;\n\n\t/**\n\t * log function\n\t */\n\tlog?: (arg0: string) => void;\n\n\t/**\n\t * yield result, if provided plugins can return several results\n\t */\n\tyield?: (arg0: ResolveRequest) => void;\n}\ndeclare interface ResolveFunction {\n\t(context: object, path: string, request: string): string | false;\n\t(path: string, request: string): string | false;\n}\ndeclare interface ResolveFunctionAsync {\n\t(\n\t\tcontext: object,\n\t\tpath: string,\n\t\trequest: string,\n\t\tresolveContext: ResolveContext,\n\t\tcallback: (\n\t\t\terr: null | ErrorWithDetail,\n\t\t\tres?: string | false,\n\t\t\treq?: ResolveRequest\n\t\t) => void\n\t): void;\n\t(\n\t\tcontext: object,\n\t\tpath: string,\n\t\trequest: string,\n\t\tcallback: (\n\t\t\terr: null | ErrorWithDetail,\n\t\t\tres?: string | false,\n\t\t\treq?: ResolveRequest\n\t\t) => void\n\t): void;\n\t(\n\t\tpath: string,\n\t\trequest: string,\n\t\tresolveContext: ResolveContext,\n\t\tcallback: (\n\t\t\terr: null | ErrorWithDetail,\n\t\t\tres?: string | false,\n\t\t\treq?: ResolveRequest\n\t\t) => void\n\t): void;\n\t(\n\t\tpath: string,\n\t\trequest: string,\n\t\tcallback: (\n\t\t\terr: null | ErrorWithDetail,\n\t\t\tres?: string | false,\n\t\t\treq?: ResolveRequest\n\t\t) => void\n\t): void;\n}\ntype ResolveOptionsOptionalFS = Omit<\n\tResolveOptionsResolverFactoryObject_2,\n\t\"fileSystem\"\n> &\n\tPartial<Pick<ResolveOptionsResolverFactoryObject_2, \"fileSystem\">>;\ndeclare interface ResolveOptionsResolverFactoryObject_1 {\n\talias: AliasOption[];\n\tfallback: AliasOption[];\n\taliasFields: Set<string | string[]>;\n\textensionAlias: ExtensionAliasOption[];\n\tcachePredicate: (arg0: ResolveRequest) => boolean;\n\tcacheWithContext: boolean;\n\n\t/**\n\t * A list of exports field condition names.\n\t */\n\tconditionNames: Set<string>;\n\tdescriptionFiles: string[];\n\tenforceExtension: boolean;\n\texportsFields: Set<string | string[]>;\n\timportsFields: Set<string | string[]>;\n\textensions: Set<string>;\n\tfileSystem: FileSystem;\n\tunsafeCache: false | object;\n\tsymlinks: boolean;\n\tresolver?: Resolver;\n\tmodules: (string | string[])[];\n\tmainFields: { name: string[]; forceRelative: boolean }[];\n\tmainFiles: Set<string>;\n\tplugins: Plugin[];\n\tpnpApi: null | PnpApi;\n\troots: Set<string>;\n\tfullySpecified: boolean;\n\tresolveToContext: boolean;\n\trestrictions: Set<string | RegExp>;\n\tpreferRelative: boolean;\n\tpreferAbsolute: boolean;\n}\ndeclare interface ResolveOptionsResolverFactoryObject_2 {\n\t/**\n\t * A list of module alias configurations or an object which maps key to value\n\t */\n\talias?: AliasOptions | AliasOption[];\n\n\t/**\n\t * A list of module alias configurations or an object which maps key to value, applied only after modules option\n\t */\n\tfallback?: AliasOptions | AliasOption[];\n\n\t/**\n\t * An object which maps extension to extension aliases\n\t */\n\textensionAlias?: ExtensionAliasOptions;\n\n\t/**\n\t * A list of alias fields in description files\n\t */\n\taliasFields?: (string | string[])[];\n\n\t/**\n\t * A function which decides whether a request should be cached or not. An object is passed with at least `path` and `request` properties.\n\t */\n\tcachePredicate?: (arg0: ResolveRequest) => boolean;\n\n\t/**\n\t * Whether or not the unsafeCache should include request context as part of the cache key.\n\t */\n\tcacheWithContext?: boolean;\n\n\t/**\n\t * A list of description files to read from\n\t */\n\tdescriptionFiles?: string[];\n\n\t/**\n\t * A list of exports field condition names.\n\t */\n\tconditionNames?: string[];\n\n\t/**\n\t * Enforce that a extension from extensions must be used\n\t */\n\tenforceExtension?: boolean;\n\n\t/**\n\t * A list of exports fields in description files\n\t */\n\texportsFields?: (string | string[])[];\n\n\t/**\n\t * A list of imports fields in description files\n\t */\n\timportsFields?: (string | string[])[];\n\n\t/**\n\t * A list of extensions which should be tried for files\n\t */\n\textensions?: string[];\n\n\t/**\n\t * The file system which should be used\n\t */\n\tfileSystem: FileSystem;\n\n\t/**\n\t * Use this cache object to unsafely cache the successful requests\n\t */\n\tunsafeCache?: boolean | object;\n\n\t/**\n\t * Resolve symlinks to their symlinked location\n\t */\n\tsymlinks?: boolean;\n\n\t/**\n\t * A prepared Resolver to which the plugins are attached\n\t */\n\tresolver?: Resolver;\n\n\t/**\n\t * A list of directories to resolve modules from, can be absolute path or folder name\n\t */\n\tmodules?: string | string[];\n\n\t/**\n\t * A list of main fields in description files\n\t */\n\tmainFields?: (\n\t\t| string\n\t\t| string[]\n\t\t| { name: string | string[]; forceRelative: boolean }\n\t)[];\n\n\t/**\n\t * A list of main files in directories\n\t */\n\tmainFiles?: string[];\n\n\t/**\n\t * A list of additional resolve plugins which should be applied\n\t */\n\tplugins?: Plugin[];\n\n\t/**\n\t * A PnP API that should be used - null is \"never\", undefined is \"auto\"\n\t */\n\tpnpApi?: null | PnpApi;\n\n\t/**\n\t * A list of root paths\n\t */\n\troots?: string[];\n\n\t/**\n\t * The request is already fully specified and no extensions or directories are resolved for it\n\t */\n\tfullySpecified?: boolean;\n\n\t/**\n\t * Resolve to a context instead of a file\n\t */\n\tresolveToContext?: boolean;\n\n\t/**\n\t * A list of resolve restrictions\n\t */\n\trestrictions?: (string | RegExp)[];\n\n\t/**\n\t * Use only the sync constraints of the file system calls\n\t */\n\tuseSyncFileSystemCalls?: boolean;\n\n\t/**\n\t * Prefer to resolve module requests as relative requests before falling back to modules\n\t */\n\tpreferRelative?: boolean;\n\n\t/**\n\t * Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots\n\t */\n\tpreferAbsolute?: boolean;\n}\ntype ResolveRequest = BaseResolveRequest & Partial<ParsedIdentifier>;\ndeclare abstract class Resolver {\n\tfileSystem: FileSystem;\n\toptions: ResolveOptionsResolverFactoryObject_1;\n\thooks: KnownHooks;\n\tensureHook(\n\t\tname:\n\t\t\t| string\n\t\t\t| AsyncSeriesBailHook<\n\t\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\t\tnull | ResolveRequest\n\t\t\t  >\n\t): AsyncSeriesBailHook<\n\t\t[ResolveRequest, ResolveContext],\n\t\tnull | ResolveRequest\n\t>;\n\tgetHook(\n\t\tname:\n\t\t\t| string\n\t\t\t| AsyncSeriesBailHook<\n\t\t\t\t\t[ResolveRequest, ResolveContext],\n\t\t\t\t\tnull | ResolveRequest\n\t\t\t  >\n\t): AsyncSeriesBailHook<\n\t\t[ResolveRequest, ResolveContext],\n\t\tnull | ResolveRequest\n\t>;\n\tresolveSync(context: object, path: string, request: string): string | false;\n\tresolve(\n\t\tcontext: object,\n\t\tpath: string,\n\t\trequest: string,\n\t\tresolveContext: ResolveContext,\n\t\tcallback: (\n\t\t\terr: null | ErrorWithDetail,\n\t\t\tres?: string | false,\n\t\t\treq?: ResolveRequest\n\t\t) => void\n\t): void;\n\tdoResolve(\n\t\thook: AsyncSeriesBailHook<\n\t\t\t[ResolveRequest, ResolveContext],\n\t\t\tnull | ResolveRequest\n\t\t>,\n\t\trequest: ResolveRequest,\n\t\tmessage: null | string,\n\t\tresolveContext: ResolveContext,\n\t\tcallback: (err?: null | Error, result?: ResolveRequest) => void\n\t): void;\n\tparse(identifier: string): ParsedIdentifier;\n\tisModule(path: string): boolean;\n\tisPrivate(path: string): boolean;\n\tisDirectory(path: string): boolean;\n\tjoin(path: string, request: string): string;\n\tnormalize(path: string): string;\n}\ndeclare interface Stat {\n\t(\n\t\tpath: PathLike,\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: IStats) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: undefined | (StatOptions & { bigint?: false }),\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: IStats) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: StatOptions & { bigint: true },\n\t\tcallback: (arg0: null | NodeJS.ErrnoException, arg1?: IBigIntStats) => void\n\t): void;\n\t(\n\t\tpath: PathLike,\n\t\toptions: undefined | StatOptions,\n\t\tcallback: (\n\t\t\targ0: null | NodeJS.ErrnoException,\n\t\t\targ1?: IStats | IBigIntStats\n\t\t) => void\n\t): void;\n}\ndeclare interface StatOptions {\n\tbigint?: boolean;\n}\ndeclare interface StatSync {\n\t(path: PathLike, options?: undefined): IStats;\n\t(\n\t\tpath: PathLike,\n\t\toptions?: StatSyncOptions & { bigint?: false; throwIfNoEntry: false }\n\t): undefined | IStats;\n\t(\n\t\tpath: PathLike,\n\t\toptions: StatSyncOptions & { bigint: true; throwIfNoEntry: false }\n\t): undefined | IBigIntStats;\n\t(path: PathLike, options?: StatSyncOptions & { bigint?: false }): IStats;\n\t(path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;\n\t(\n\t\tpath: PathLike,\n\t\toptions: StatSyncOptions & { bigint: boolean; throwIfNoEntry?: false }\n\t): IStats | IBigIntStats;\n\t(path: PathLike, options?: StatSyncOptions):\n\t\t| undefined\n\t\t| IStats\n\t\t| IBigIntStats;\n}\ndeclare interface StatSyncOptions {\n\tbigint?: boolean;\n\tthrowIfNoEntry?: boolean;\n}\ndeclare interface SyncFileSystem {\n\treadFileSync: ReadFileSync;\n\treaddirSync: ReaddirSync;\n\treadJsonSync?: (arg0: PathOrFileDescriptor) => JsonObject;\n\treadlinkSync: ReadlinkSync;\n\tlstatSync?: LStatSync;\n\tstatSync: StatSync;\n\trealpathSync?: RealPathSync;\n}\n\n/**\n * `URL` class is a global reference for `require('url').URL`\n * https://nodejs.org/api/url.html#the-whatwg-url-api\n */\ndeclare interface URL_url extends URL_Import {}\ndeclare interface WriteOnlySet<T> {\n\tadd: (item: T) => void;\n}\ndeclare function exports(\n\tcontext: object,\n\tpath: string,\n\trequest: string,\n\tresolveContext: ResolveContext,\n\tcallback: (\n\t\terr: null | ErrorWithDetail,\n\t\tres?: string | false,\n\t\treq?: ResolveRequest\n\t) => void\n): void;\ndeclare function exports(\n\tcontext: object,\n\tpath: string,\n\trequest: string,\n\tcallback: (\n\t\terr: null | ErrorWithDetail,\n\t\tres?: string | false,\n\t\treq?: ResolveRequest\n\t) => void\n): void;\ndeclare function exports(\n\tpath: string,\n\trequest: string,\n\tresolveContext: ResolveContext,\n\tcallback: (\n\t\terr: null | ErrorWithDetail,\n\t\tres?: string | false,\n\t\treq?: ResolveRequest\n\t) => void\n): void;\ndeclare function exports(\n\tpath: string,\n\trequest: string,\n\tcallback: (\n\t\terr: null | ErrorWithDetail,\n\t\tres?: string | false,\n\t\treq?: ResolveRequest\n\t) => void\n): void;\ndeclare namespace exports {\n\texport const sync: ResolveFunction;\n\texport function create(\n\t\toptions: ResolveOptionsOptionalFS\n\t): ResolveFunctionAsync;\n\texport namespace create {\n\t\texport const sync: (options: ResolveOptionsOptionalFS) => ResolveFunction;\n\t}\n\texport namespace ResolverFactory {\n\t\texport let createResolver: (\n\t\t\toptions: ResolveOptionsResolverFactoryObject_2\n\t\t) => Resolver;\n\t}\n\texport const forEachBail: <T, Z>(\n\t\tarray: T[],\n\t\titerator: Iterator<T, Z>,\n\t\tcallback: (err?: null | Error, result?: null | Z, i?: number) => void\n\t) => void;\n\texport type ResolveCallback = (\n\t\terr: null | ErrorWithDetail,\n\t\tres?: string | false,\n\t\treq?: ResolveRequest\n\t) => void;\n\texport {\n\t\tCachedInputFileSystem,\n\t\tCloneBasenamePlugin,\n\t\tLogInfoPlugin,\n\t\tResolveOptionsOptionalFS,\n\t\tPnpApi,\n\t\tResolver,\n\t\tFileSystem,\n\t\tResolveContext,\n\t\tResolveRequest,\n\t\tPlugin,\n\t\tResolveOptionsResolverFactoryObject_2 as ResolveOptions,\n\t\tResolveFunctionAsync,\n\t\tResolveFunction\n\t};\n}\n\nexport = exports;\n"
        }
    ]
}