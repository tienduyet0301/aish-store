{
    "sourceFile": "node_modules/tapable/tapable.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893051836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "type FixedSizeArray<T extends number, U> = T extends 0\n\t? void[]\n\t: ReadonlyArray<U> & {\n\t\t\t0: U;\n\t\t\tlength: T;\n\t  };\ntype Measure<T extends number> = T extends 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\n\t? T\n\t: never;\ntype Append<T extends any[], U> = {\n\t0: [U];\n\t1: [T[0], U];\n\t2: [T[0], T[1], U];\n\t3: [T[0], T[1], T[2], U];\n\t4: [T[0], T[1], T[2], T[3], U];\n\t5: [T[0], T[1], T[2], T[3], T[4], U];\n\t6: [T[0], T[1], T[2], T[3], T[4], T[5], U];\n\t7: [T[0], T[1], T[2], T[3], T[4], T[5], T[6], U];\n\t8: [T[0], T[1], T[2], T[3], T[4], T[5], T[6], T[7], U];\n}[Measure<T[\"length\"]>];\ntype AsArray<T> = T extends any[] ? T : [T];\n\ndeclare class UnsetAdditionalOptions {\n\t_UnsetAdditionalOptions: true\n}\ntype IfSet<X> = X extends UnsetAdditionalOptions ? {} : X;\n\ntype Callback<E, T> = (error: E | null, result?: T) => void;\ntype InnerCallback<E, T> = (error?: E | null | false, result?: T) => void;\n\ntype FullTap = Tap & {\n\ttype: \"sync\" | \"async\" | \"promise\",\n\tfn: Function\n}\n\ntype Tap = TapOptions & {\n\tname: string;\n};\n\ntype TapOptions = {\n\tbefore?: string;\n\tstage?: number;\n};\n\ninterface HookInterceptor<T, R, AdditionalOptions = UnsetAdditionalOptions> {\n\tname?: string;\n\ttap?: (tap: FullTap & IfSet<AdditionalOptions>) => void;\n\tcall?: (...args: any[]) => void;\n\tloop?: (...args: any[]) => void;\n\terror?: (err: Error) => void;\n\tresult?: (result: R) => void;\n\tdone?: () => void;\n\tregister?: (tap: FullTap & IfSet<AdditionalOptions>) => FullTap & IfSet<AdditionalOptions>;\n}\n\ntype ArgumentNames<T extends any[]> = FixedSizeArray<T[\"length\"], string>;\n\ndeclare class Hook<T, R, AdditionalOptions = UnsetAdditionalOptions> {\n\tconstructor(args?: ArgumentNames<AsArray<T>>, name?: string);\n\tname: string | undefined;\n\ttaps: FullTap[];\n\tintercept(interceptor: HookInterceptor<T, R, AdditionalOptions>): void;\n\tisUsed(): boolean;\n\tcallAsync(...args: Append<AsArray<T>, Callback<Error, R>>): void;\n\tpromise(...args: AsArray<T>): Promise<R>;\n\ttap(options: string | Tap & IfSet<AdditionalOptions>, fn: (...args: AsArray<T>) => R): void;\n\twithOptions(options: TapOptions & IfSet<AdditionalOptions>): Omit<this, \"call\" | \"callAsync\" | \"promise\">;\n}\n\nexport class SyncHook<T, R = void, AdditionalOptions = UnsetAdditionalOptions> extends Hook<T, R, AdditionalOptions> {\n\tcall(...args: AsArray<T>): R;\n}\n\nexport class SyncBailHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends SyncHook<T, R, AdditionalOptions> {}\nexport class SyncLoopHook<T, AdditionalOptions = UnsetAdditionalOptions> extends SyncHook<T, void, AdditionalOptions> {}\nexport class SyncWaterfallHook<T, AdditionalOptions = UnsetAdditionalOptions> extends SyncHook<T, AsArray<T>[0], AdditionalOptions> {}\n\ndeclare class AsyncHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends Hook<T, R, AdditionalOptions> {\n\ttapAsync(\n\t\toptions: string | Tap & IfSet<AdditionalOptions>,\n\t\tfn: (...args: Append<AsArray<T>, InnerCallback<Error, R>>) => void\n\t): void;\n\ttapPromise(\n\t\toptions: string | Tap & IfSet<AdditionalOptions>,\n\t\tfn: (...args: AsArray<T>) => Promise<R>\n\t): void;\n}\n\nexport class AsyncParallelHook<T, AdditionalOptions = UnsetAdditionalOptions> extends AsyncHook<T, void, AdditionalOptions> {}\nexport class AsyncParallelBailHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends AsyncHook<T, R, AdditionalOptions> {}\nexport class AsyncSeriesHook<T, AdditionalOptions = UnsetAdditionalOptions> extends AsyncHook<T, void, AdditionalOptions> {}\nexport class AsyncSeriesBailHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends AsyncHook<T, R, AdditionalOptions> {}\nexport class AsyncSeriesLoopHook<T, AdditionalOptions = UnsetAdditionalOptions> extends AsyncHook<T, void, AdditionalOptions> {}\nexport class AsyncSeriesWaterfallHook<T, AdditionalOptions = UnsetAdditionalOptions> extends AsyncHook<T, AsArray<T>[0], AdditionalOptions> {}\n\ntype HookFactory<H> = (key: any, hook?: H) => H;\n\ninterface HookMapInterceptor<H> {\n\tfactory?: HookFactory<H>;\n}\n\nexport class HookMap<H> {\n\tconstructor(factory: HookFactory<H>, name?: string);\n\tname: string | undefined;\n\tget(key: any): H | undefined;\n\tfor(key: any): H;\n\tintercept(interceptor: HookMapInterceptor<H>): void;\n}\n\nexport class MultiHook<H> {\n\tconstructor(hooks: H[], name?: string);\n\tname: string | undefined;\n\ttap(options: string | Tap, fn?: Function): void;\n\ttapAsync(options: string | Tap, fn?: Function): void;\n\ttapPromise(options: string | Tap, fn?: Function): void;\n}\n"
        }
    ]
}