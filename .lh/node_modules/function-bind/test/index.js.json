{
    "sourceFile": "node_modules/function-bind/test/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892310745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// jscs:disable requireUseStrict\n\nvar test = require('tape');\n\nvar functionBind = require('../implementation');\nvar getCurrentContext = function () { return this; };\n\ntest('functionBind is a function', function (t) {\n    t.equal(typeof functionBind, 'function');\n    t.end();\n});\n\ntest('non-functions', function (t) {\n    var nonFunctions = [true, false, [], {}, 42, 'foo', NaN, /a/g];\n    t.plan(nonFunctions.length);\n    for (var i = 0; i < nonFunctions.length; ++i) {\n        try { functionBind.call(nonFunctions[i]); } catch (ex) {\n            t.ok(ex instanceof TypeError, 'throws when given ' + String(nonFunctions[i]));\n        }\n    }\n    t.end();\n});\n\ntest('without a context', function (t) {\n    t.test('binds properly', function (st) {\n        var args, context;\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                context = this;\n            })\n        };\n        namespace.func(1, 2, 3);\n        st.deepEqual(args, [1, 2, 3]);\n        st.equal(context, getCurrentContext.call());\n        st.end();\n    });\n\n    t.test('binds properly, and still supplies bound arguments', function (st) {\n        var args, context;\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                context = this;\n            }, undefined, 1, 2, 3)\n        };\n        namespace.func(4, 5, 6);\n        st.deepEqual(args, [1, 2, 3, 4, 5, 6]);\n        st.equal(context, getCurrentContext.call());\n        st.end();\n    });\n\n    t.test('returns properly', function (st) {\n        var args;\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                return this;\n            }, null)\n        };\n        var context = namespace.func(1, 2, 3);\n        st.equal(context, getCurrentContext.call(), 'returned context is namespaced context');\n        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');\n        st.end();\n    });\n\n    t.test('returns properly with bound arguments', function (st) {\n        var args;\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                return this;\n            }, null, 1, 2, 3)\n        };\n        var context = namespace.func(4, 5, 6);\n        st.equal(context, getCurrentContext.call(), 'returned context is namespaced context');\n        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');\n        st.end();\n    });\n\n    t.test('called as a constructor', function (st) {\n        var thunkify = function (value) {\n            return function () { return value; };\n        };\n        st.test('returns object value', function (sst) {\n            var expectedReturnValue = [1, 2, 3];\n            var Constructor = functionBind.call(thunkify(expectedReturnValue), null);\n            var result = new Constructor();\n            sst.equal(result, expectedReturnValue);\n            sst.end();\n        });\n\n        st.test('does not return primitive value', function (sst) {\n            var Constructor = functionBind.call(thunkify(42), null);\n            var result = new Constructor();\n            sst.notEqual(result, 42);\n            sst.end();\n        });\n\n        st.test('object from bound constructor is instance of original and bound constructor', function (sst) {\n            var A = function (x) {\n                this.name = x || 'A';\n            };\n            var B = functionBind.call(A, null, 'B');\n\n            var result = new B();\n            sst.ok(result instanceof B, 'result is instance of bound constructor');\n            sst.ok(result instanceof A, 'result is instance of original constructor');\n            sst.end();\n        });\n\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('with a context', function (t) {\n    t.test('with no bound arguments', function (st) {\n        var args, context;\n        var boundContext = {};\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                context = this;\n            }, boundContext)\n        };\n        namespace.func(1, 2, 3);\n        st.equal(context, boundContext, 'binds a context properly');\n        st.deepEqual(args, [1, 2, 3], 'supplies passed arguments');\n        st.end();\n    });\n\n    t.test('with bound arguments', function (st) {\n        var args, context;\n        var boundContext = {};\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                context = this;\n            }, boundContext, 1, 2, 3)\n        };\n        namespace.func(4, 5, 6);\n        st.equal(context, boundContext, 'binds a context properly');\n        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'supplies bound and passed arguments');\n        st.end();\n    });\n\n    t.test('returns properly', function (st) {\n        var boundContext = {};\n        var args;\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                return this;\n            }, boundContext)\n        };\n        var context = namespace.func(1, 2, 3);\n        st.equal(context, boundContext, 'returned context is bound context');\n        st.notEqual(context, getCurrentContext.call(), 'returned context is not lexical context');\n        st.deepEqual(args, [1, 2, 3], 'passed arguments are correct');\n        st.end();\n    });\n\n    t.test('returns properly with bound arguments', function (st) {\n        var boundContext = {};\n        var args;\n        var namespace = {\n            func: functionBind.call(function () {\n                args = Array.prototype.slice.call(arguments);\n                return this;\n            }, boundContext, 1, 2, 3)\n        };\n        var context = namespace.func(4, 5, 6);\n        st.equal(context, boundContext, 'returned context is bound context');\n        st.notEqual(context, getCurrentContext.call(), 'returned context is not lexical context');\n        st.deepEqual(args, [1, 2, 3, 4, 5, 6], 'passed arguments are correct');\n        st.end();\n    });\n\n    t.test('passes the correct arguments when called as a constructor', function (st) {\n        var expected = { name: 'Correct' };\n        var namespace = {\n            Func: functionBind.call(function (arg) {\n                return arg;\n            }, { name: 'Incorrect' })\n        };\n        var returned = new namespace.Func(expected);\n        st.equal(returned, expected, 'returns the right arg when called as a constructor');\n        st.end();\n    });\n\n    t.test('has the new instance\\'s context when called as a constructor', function (st) {\n        var actualContext;\n        var expectedContext = { foo: 'bar' };\n        var namespace = {\n            Func: functionBind.call(function () {\n                actualContext = this;\n            }, expectedContext)\n        };\n        var result = new namespace.Func();\n        st.equal(result instanceof namespace.Func, true);\n        st.notEqual(actualContext, expectedContext);\n        st.end();\n    });\n\n    t.end();\n});\n\ntest('bound function length', function (t) {\n    t.test('sets a correct length without thisArg', function (st) {\n        var subject = functionBind.call(function (a, b, c) { return a + b + c; });\n        st.equal(subject.length, 3);\n        st.equal(subject(1, 2, 3), 6);\n        st.end();\n    });\n\n    t.test('sets a correct length with thisArg', function (st) {\n        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {});\n        st.equal(subject.length, 3);\n        st.equal(subject(1, 2, 3), 6);\n        st.end();\n    });\n\n    t.test('sets a correct length without thisArg and first argument', function (st) {\n        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, undefined, 1);\n        st.equal(subject.length, 2);\n        st.equal(subject(2, 3), 6);\n        st.end();\n    });\n\n    t.test('sets a correct length with thisArg and first argument', function (st) {\n        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {}, 1);\n        st.equal(subject.length, 2);\n        st.equal(subject(2, 3), 6);\n        st.end();\n    });\n\n    t.test('sets a correct length without thisArg and too many arguments', function (st) {\n        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, undefined, 1, 2, 3, 4);\n        st.equal(subject.length, 0);\n        st.equal(subject(), 6);\n        st.end();\n    });\n\n    t.test('sets a correct length with thisArg and too many arguments', function (st) {\n        var subject = functionBind.call(function (a, b, c) { return a + b + c; }, {}, 1, 2, 3, 4);\n        st.equal(subject.length, 0);\n        st.equal(subject(), 6);\n        st.end();\n    });\n});\n"
        }
    ]
}