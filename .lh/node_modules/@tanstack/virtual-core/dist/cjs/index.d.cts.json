{
    "sourceFile": "node_modules/@tanstack/virtual-core/dist/cjs/index.d.cts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891953028,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "export * from './utils.cjs';\ntype ScrollDirection = 'forward' | 'backward';\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto';\ntype ScrollBehavior = 'auto' | 'smooth';\nexport interface ScrollToOptions {\n    align?: ScrollAlignment;\n    behavior?: ScrollBehavior;\n}\ntype ScrollToOffsetOptions = ScrollToOptions;\ntype ScrollToIndexOptions = ScrollToOptions;\nexport interface Range {\n    startIndex: number;\n    endIndex: number;\n    overscan: number;\n    count: number;\n}\ntype Key = number | string | bigint;\nexport interface VirtualItem {\n    key: Key;\n    index: number;\n    start: number;\n    end: number;\n    size: number;\n    lane: number;\n}\nexport interface Rect {\n    width: number;\n    height: number;\n}\nexport declare const defaultKeyExtractor: (index: number) => number;\nexport declare const defaultRangeExtractor: (range: Range) => number[];\nexport declare const observeElementRect: <T extends Element>(instance: Virtualizer<T, any>, cb: (rect: Rect) => void) => (() => void) | undefined;\nexport declare const observeWindowRect: (instance: Virtualizer<Window, any>, cb: (rect: Rect) => void) => (() => void) | undefined;\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void;\nexport declare const observeElementOffset: <T extends Element>(instance: Virtualizer<T, any>, cb: ObserveOffsetCallBack) => (() => void) | undefined;\nexport declare const observeWindowOffset: (instance: Virtualizer<Window, any>, cb: ObserveOffsetCallBack) => (() => void) | undefined;\nexport declare const measureElement: <TItemElement extends Element>(element: TItemElement, entry: ResizeObserverEntry | undefined, instance: Virtualizer<any, TItemElement>) => number;\nexport declare const windowScroll: <T extends Window>(offset: number, { adjustments, behavior, }: {\n    adjustments?: number | undefined;\n    behavior?: ScrollBehavior | undefined;\n}, instance: Virtualizer<T, any>) => void;\nexport declare const elementScroll: <T extends Element>(offset: number, { adjustments, behavior, }: {\n    adjustments?: number | undefined;\n    behavior?: ScrollBehavior | undefined;\n}, instance: Virtualizer<T, any>) => void;\nexport interface VirtualizerOptions<TScrollElement extends Element | Window, TItemElement extends Element> {\n    count: number;\n    getScrollElement: () => TScrollElement | null;\n    estimateSize: (index: number) => number;\n    scrollToFn: (offset: number, options: {\n        adjustments?: number;\n        behavior?: ScrollBehavior;\n    }, instance: Virtualizer<TScrollElement, TItemElement>) => void;\n    observeElementRect: (instance: Virtualizer<TScrollElement, TItemElement>, cb: (rect: Rect) => void) => void | (() => void);\n    observeElementOffset: (instance: Virtualizer<TScrollElement, TItemElement>, cb: ObserveOffsetCallBack) => void | (() => void);\n    debug?: boolean;\n    initialRect?: Rect;\n    onChange?: (instance: Virtualizer<TScrollElement, TItemElement>, sync: boolean) => void;\n    measureElement?: (element: TItemElement, entry: ResizeObserverEntry | undefined, instance: Virtualizer<TScrollElement, TItemElement>) => number;\n    overscan?: number;\n    horizontal?: boolean;\n    paddingStart?: number;\n    paddingEnd?: number;\n    scrollPaddingStart?: number;\n    scrollPaddingEnd?: number;\n    initialOffset?: number | (() => number);\n    getItemKey?: (index: number) => Key;\n    rangeExtractor?: (range: Range) => Array<number>;\n    scrollMargin?: number;\n    gap?: number;\n    indexAttribute?: string;\n    initialMeasurementsCache?: Array<VirtualItem>;\n    lanes?: number;\n    isScrollingResetDelay?: number;\n    useScrollendEvent?: boolean;\n    enabled?: boolean;\n    isRtl?: boolean;\n    useAnimationFrameWithResizeObserver?: boolean;\n}\nexport declare class Virtualizer<TScrollElement extends Element | Window, TItemElement extends Element> {\n    private unsubs;\n    options: Required<VirtualizerOptions<TScrollElement, TItemElement>>;\n    scrollElement: TScrollElement | null;\n    targetWindow: (Window & typeof globalThis) | null;\n    isScrolling: boolean;\n    private scrollToIndexTimeoutId;\n    measurementsCache: Array<VirtualItem>;\n    private itemSizeCache;\n    private pendingMeasuredCacheIndexes;\n    scrollRect: Rect | null;\n    scrollOffset: number | null;\n    scrollDirection: ScrollDirection | null;\n    private scrollAdjustments;\n    shouldAdjustScrollPositionOnItemSizeChange: undefined | ((item: VirtualItem, delta: number, instance: Virtualizer<TScrollElement, TItemElement>) => boolean);\n    elementsCache: Map<Key, TItemElement>;\n    private observer;\n    range: {\n        startIndex: number;\n        endIndex: number;\n    } | null;\n    constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>);\n    setOptions: (opts: VirtualizerOptions<TScrollElement, TItemElement>) => void;\n    private notify;\n    private maybeNotify;\n    private cleanup;\n    _didMount: () => () => void;\n    _willUpdate: () => void;\n    private getSize;\n    private getScrollOffset;\n    private getFurthestMeasurement;\n    private getMeasurementOptions;\n    private getMeasurements;\n    calculateRange: {\n        (): {\n            startIndex: number;\n            endIndex: number;\n        } | null;\n        updateDeps(newDeps: [VirtualItem[], number, number, number]): void;\n    };\n    getVirtualIndexes: {\n        (): number[];\n        updateDeps(newDeps: [(range: Range) => number[], number, number, number | null, number | null]): void;\n    };\n    indexFromElement: (node: TItemElement) => number;\n    private _measureElement;\n    resizeItem: (index: number, size: number) => void;\n    measureElement: (node: TItemElement | null | undefined) => void;\n    getVirtualItems: {\n        (): VirtualItem[];\n        updateDeps(newDeps: [number[], VirtualItem[]]): void;\n    };\n    getVirtualItemForOffset: (offset: number) => VirtualItem | undefined;\n    getOffsetForAlignment: (toOffset: number, align: ScrollAlignment, itemSize?: number) => number;\n    getOffsetForIndex: (index: number, align?: ScrollAlignment) => readonly [number, \"auto\"] | readonly [number, \"start\" | \"center\" | \"end\"] | undefined;\n    private isDynamicMode;\n    private cancelScrollToIndex;\n    scrollToOffset: (toOffset: number, { align, behavior }?: ScrollToOffsetOptions) => void;\n    scrollToIndex: (index: number, { align: initialAlign, behavior }?: ScrollToIndexOptions) => void;\n    scrollBy: (delta: number, { behavior }?: ScrollToOffsetOptions) => void;\n    getTotalSize: () => number;\n    private _scrollToOffset;\n    measure: () => void;\n}\n"
        }
    ]
}