{
    "sourceFile": "node_modules/@typescript-eslint/types/dist/generated/ast-spec.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891998252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**********************************************\n *      DO NOT MODIFY THIS FILE MANUALLY      *\n *                                            *\n *  THIS FILE HAS BEEN COPIED FROM ast-spec.  *\n * ANY CHANGES WILL BE LOST ON THE NEXT BUILD *\n *                                            *\n *   MAKE CHANGES TO ast-spec AND THEN RUN    *\n *                 yarn build                 *\n **********************************************/\nimport type { SyntaxKind } from 'typescript';\nexport declare type Accessibility = 'private' | 'protected' | 'public';\nexport declare type AccessorProperty = AccessorPropertyComputedName | AccessorPropertyNonComputedName;\nexport declare interface AccessorPropertyComputedName extends PropertyDefinitionComputedNameBase {\n    type: AST_NODE_TYPES.AccessorProperty;\n}\nexport declare interface AccessorPropertyNonComputedName extends PropertyDefinitionNonComputedNameBase {\n    type: AST_NODE_TYPES.AccessorProperty;\n}\nexport declare interface ArrayExpression extends BaseNode {\n    type: AST_NODE_TYPES.ArrayExpression;\n    /**\n     * an element will be `null` in the case of a sparse array: `[1, ,3]`\n     */\n    elements: (Expression | SpreadElement | null)[];\n}\nexport declare interface ArrayPattern extends BaseNode {\n    type: AST_NODE_TYPES.ArrayPattern;\n    decorators: Decorator[];\n    elements: (DestructuringPattern | null)[];\n    optional: boolean;\n    typeAnnotation: TSTypeAnnotation | undefined;\n}\nexport declare interface ArrowFunctionExpression extends BaseNode {\n    type: AST_NODE_TYPES.ArrowFunctionExpression;\n    async: boolean;\n    body: BlockStatement | Expression;\n    expression: boolean;\n    generator: boolean;\n    id: null;\n    params: Parameter[];\n    returnType: TSTypeAnnotation | undefined;\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare interface AssignmentExpression extends BaseNode {\n    type: AST_NODE_TYPES.AssignmentExpression;\n    left: Expression;\n    operator: ValueOf<AssignmentOperatorToText>;\n    right: Expression;\n}\nexport declare interface AssignmentOperatorToText {\n    [SyntaxKind.AmpersandAmpersandEqualsToken]: '&&=';\n    [SyntaxKind.AmpersandEqualsToken]: '&=';\n    [SyntaxKind.AsteriskAsteriskEqualsToken]: '**=';\n    [SyntaxKind.AsteriskEqualsToken]: '*=';\n    [SyntaxKind.BarBarEqualsToken]: '||=';\n    [SyntaxKind.BarEqualsToken]: '|=';\n    [SyntaxKind.CaretEqualsToken]: '^=';\n    [SyntaxKind.EqualsToken]: '=';\n    [SyntaxKind.GreaterThanGreaterThanEqualsToken]: '>>=';\n    [SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: '>>>=';\n    [SyntaxKind.LessThanLessThanEqualsToken]: '<<=';\n    [SyntaxKind.MinusEqualsToken]: '-=';\n    [SyntaxKind.PercentEqualsToken]: '%=';\n    [SyntaxKind.PlusEqualsToken]: '+=';\n    [SyntaxKind.QuestionQuestionEqualsToken]: '??=';\n    [SyntaxKind.SlashEqualsToken]: '/=';\n}\nexport declare interface AssignmentPattern extends BaseNode {\n    type: AST_NODE_TYPES.AssignmentPattern;\n    decorators: Decorator[];\n    left: BindingName;\n    optional: boolean;\n    right: Expression;\n    typeAnnotation: TSTypeAnnotation | undefined;\n}\nexport declare enum AST_NODE_TYPES {\n    AccessorProperty = \"AccessorProperty\",\n    ArrayExpression = \"ArrayExpression\",\n    ArrayPattern = \"ArrayPattern\",\n    ArrowFunctionExpression = \"ArrowFunctionExpression\",\n    AssignmentExpression = \"AssignmentExpression\",\n    AssignmentPattern = \"AssignmentPattern\",\n    AwaitExpression = \"AwaitExpression\",\n    BinaryExpression = \"BinaryExpression\",\n    BlockStatement = \"BlockStatement\",\n    BreakStatement = \"BreakStatement\",\n    CallExpression = \"CallExpression\",\n    CatchClause = \"CatchClause\",\n    ChainExpression = \"ChainExpression\",\n    ClassBody = \"ClassBody\",\n    ClassDeclaration = \"ClassDeclaration\",\n    ClassExpression = \"ClassExpression\",\n    ConditionalExpression = \"ConditionalExpression\",\n    ContinueStatement = \"ContinueStatement\",\n    DebuggerStatement = \"DebuggerStatement\",\n    Decorator = \"Decorator\",\n    DoWhileStatement = \"DoWhileStatement\",\n    EmptyStatement = \"EmptyStatement\",\n    ExportAllDeclaration = \"ExportAllDeclaration\",\n    ExportDefaultDeclaration = \"ExportDefaultDeclaration\",\n    ExportNamedDeclaration = \"ExportNamedDeclaration\",\n    ExportSpecifier = \"ExportSpecifier\",\n    ExpressionStatement = \"ExpressionStatement\",\n    ForInStatement = \"ForInStatement\",\n    ForOfStatement = \"ForOfStatement\",\n    ForStatement = \"ForStatement\",\n    FunctionDeclaration = \"FunctionDeclaration\",\n    FunctionExpression = \"FunctionExpression\",\n    Identifier = \"Identifier\",\n    IfStatement = \"IfStatement\",\n    ImportAttribute = \"ImportAttribute\",\n    ImportDeclaration = \"ImportDeclaration\",\n    ImportDefaultSpecifier = \"ImportDefaultSpecifier\",\n    ImportExpression = \"ImportExpression\",\n    ImportNamespaceSpecifier = \"ImportNamespaceSpecifier\",\n    ImportSpecifier = \"ImportSpecifier\",\n    JSXAttribute = \"JSXAttribute\",\n    JSXClosingElement = \"JSXClosingElement\",\n    JSXClosingFragment = \"JSXClosingFragment\",\n    JSXElement = \"JSXElement\",\n    JSXEmptyExpression = \"JSXEmptyExpression\",\n    JSXExpressionContainer = \"JSXExpressionContainer\",\n    JSXFragment = \"JSXFragment\",\n    JSXIdentifier = \"JSXIdentifier\",\n    JSXMemberExpression = \"JSXMemberExpression\",\n    JSXNamespacedName = \"JSXNamespacedName\",\n    JSXOpeningElement = \"JSXOpeningElement\",\n    JSXOpeningFragment = \"JSXOpeningFragment\",\n    JSXSpreadAttribute = \"JSXSpreadAttribute\",\n    JSXSpreadChild = \"JSXSpreadChild\",\n    JSXText = \"JSXText\",\n    LabeledStatement = \"LabeledStatement\",\n    Literal = \"Literal\",\n    LogicalExpression = \"LogicalExpression\",\n    MemberExpression = \"MemberExpression\",\n    MetaProperty = \"MetaProperty\",\n    MethodDefinition = \"MethodDefinition\",\n    NewExpression = \"NewExpression\",\n    ObjectExpression = \"ObjectExpression\",\n    ObjectPattern = \"ObjectPattern\",\n    PrivateIdentifier = \"PrivateIdentifier\",\n    Program = \"Program\",\n    Property = \"Property\",\n    PropertyDefinition = \"PropertyDefinition\",\n    RestElement = \"RestElement\",\n    ReturnStatement = \"ReturnStatement\",\n    SequenceExpression = \"SequenceExpression\",\n    SpreadElement = \"SpreadElement\",\n    StaticBlock = \"StaticBlock\",\n    Super = \"Super\",\n    SwitchCase = \"SwitchCase\",\n    SwitchStatement = \"SwitchStatement\",\n    TaggedTemplateExpression = \"TaggedTemplateExpression\",\n    TemplateElement = \"TemplateElement\",\n    TemplateLiteral = \"TemplateLiteral\",\n    ThisExpression = \"ThisExpression\",\n    ThrowStatement = \"ThrowStatement\",\n    TryStatement = \"TryStatement\",\n    UnaryExpression = \"UnaryExpression\",\n    UpdateExpression = \"UpdateExpression\",\n    VariableDeclaration = \"VariableDeclaration\",\n    VariableDeclarator = \"VariableDeclarator\",\n    WhileStatement = \"WhileStatement\",\n    WithStatement = \"WithStatement\",\n    YieldExpression = \"YieldExpression\",\n    TSAbstractAccessorProperty = \"TSAbstractAccessorProperty\",\n    TSAbstractKeyword = \"TSAbstractKeyword\",\n    TSAbstractMethodDefinition = \"TSAbstractMethodDefinition\",\n    TSAbstractPropertyDefinition = \"TSAbstractPropertyDefinition\",\n    TSAnyKeyword = \"TSAnyKeyword\",\n    TSArrayType = \"TSArrayType\",\n    TSAsExpression = \"TSAsExpression\",\n    TSAsyncKeyword = \"TSAsyncKeyword\",\n    TSBigIntKeyword = \"TSBigIntKeyword\",\n    TSBooleanKeyword = \"TSBooleanKeyword\",\n    TSCallSignatureDeclaration = \"TSCallSignatureDeclaration\",\n    TSClassImplements = \"TSClassImplements\",\n    TSConditionalType = \"TSConditionalType\",\n    TSConstructorType = \"TSConstructorType\",\n    TSConstructSignatureDeclaration = \"TSConstructSignatureDeclaration\",\n    TSDeclareFunction = \"TSDeclareFunction\",\n    TSDeclareKeyword = \"TSDeclareKeyword\",\n    TSEmptyBodyFunctionExpression = \"TSEmptyBodyFunctionExpression\",\n    TSEnumBody = \"TSEnumBody\",\n    TSEnumDeclaration = \"TSEnumDeclaration\",\n    TSEnumMember = \"TSEnumMember\",\n    TSExportAssignment = \"TSExportAssignment\",\n    TSExportKeyword = \"TSExportKeyword\",\n    TSExternalModuleReference = \"TSExternalModuleReference\",\n    TSFunctionType = \"TSFunctionType\",\n    TSImportEqualsDeclaration = \"TSImportEqualsDeclaration\",\n    TSImportType = \"TSImportType\",\n    TSIndexedAccessType = \"TSIndexedAccessType\",\n    TSIndexSignature = \"TSIndexSignature\",\n    TSInferType = \"TSInferType\",\n    TSInstantiationExpression = \"TSInstantiationExpression\",\n    TSInterfaceBody = \"TSInterfaceBody\",\n    TSInterfaceDeclaration = \"TSInterfaceDeclaration\",\n    TSInterfaceHeritage = \"TSInterfaceHeritage\",\n    TSIntersectionType = \"TSIntersectionType\",\n    TSIntrinsicKeyword = \"TSIntrinsicKeyword\",\n    TSLiteralType = \"TSLiteralType\",\n    TSMappedType = \"TSMappedType\",\n    TSMethodSignature = \"TSMethodSignature\",\n    TSModuleBlock = \"TSModuleBlock\",\n    TSModuleDeclaration = \"TSModuleDeclaration\",\n    TSNamedTupleMember = \"TSNamedTupleMember\",\n    TSNamespaceExportDeclaration = \"TSNamespaceExportDeclaration\",\n    TSNeverKeyword = \"TSNeverKeyword\",\n    TSNonNullExpression = \"TSNonNullExpression\",\n    TSNullKeyword = \"TSNullKeyword\",\n    TSNumberKeyword = \"TSNumberKeyword\",\n    TSObjectKeyword = \"TSObjectKeyword\",\n    TSOptionalType = \"TSOptionalType\",\n    TSParameterProperty = \"TSParameterProperty\",\n    TSPrivateKeyword = \"TSPrivateKeyword\",\n    TSPropertySignature = \"TSPropertySignature\",\n    TSProtectedKeyword = \"TSProtectedKeyword\",\n    TSPublicKeyword = \"TSPublicKeyword\",\n    TSQualifiedName = \"TSQualifiedName\",\n    TSReadonlyKeyword = \"TSReadonlyKeyword\",\n    TSRestType = \"TSRestType\",\n    TSSatisfiesExpression = \"TSSatisfiesExpression\",\n    TSStaticKeyword = \"TSStaticKeyword\",\n    TSStringKeyword = \"TSStringKeyword\",\n    TSSymbolKeyword = \"TSSymbolKeyword\",\n    TSTemplateLiteralType = \"TSTemplateLiteralType\",\n    TSThisType = \"TSThisType\",\n    TSTupleType = \"TSTupleType\",\n    TSTypeAliasDeclaration = \"TSTypeAliasDeclaration\",\n    TSTypeAnnotation = \"TSTypeAnnotation\",\n    TSTypeAssertion = \"TSTypeAssertion\",\n    TSTypeLiteral = \"TSTypeLiteral\",\n    TSTypeOperator = \"TSTypeOperator\",\n    TSTypeParameter = \"TSTypeParameter\",\n    TSTypeParameterDeclaration = \"TSTypeParameterDeclaration\",\n    TSTypeParameterInstantiation = \"TSTypeParameterInstantiation\",\n    TSTypePredicate = \"TSTypePredicate\",\n    TSTypeQuery = \"TSTypeQuery\",\n    TSTypeReference = \"TSTypeReference\",\n    TSUndefinedKeyword = \"TSUndefinedKeyword\",\n    TSUnionType = \"TSUnionType\",\n    TSUnknownKeyword = \"TSUnknownKeyword\",\n    TSVoidKeyword = \"TSVoidKeyword\"\n}\nexport declare enum AST_TOKEN_TYPES {\n    Boolean = \"Boolean\",\n    Identifier = \"Identifier\",\n    JSXIdentifier = \"JSXIdentifier\",\n    JSXText = \"JSXText\",\n    Keyword = \"Keyword\",\n    Null = \"Null\",\n    Numeric = \"Numeric\",\n    Punctuator = \"Punctuator\",\n    RegularExpression = \"RegularExpression\",\n    String = \"String\",\n    Template = \"Template\",\n    Block = \"Block\",\n    Line = \"Line\"\n}\nexport declare interface AwaitExpression extends BaseNode {\n    type: AST_NODE_TYPES.AwaitExpression;\n    argument: Expression;\n}\nexport declare interface BaseNode extends NodeOrTokenData {\n    type: AST_NODE_TYPES;\n}\ndeclare interface BaseToken extends NodeOrTokenData {\n    type: AST_TOKEN_TYPES;\n    value: string;\n}\nexport declare interface BigIntLiteral extends LiteralBase {\n    bigint: string;\n    value: bigint | null;\n}\nexport declare interface BinaryExpression extends BaseNode {\n    type: AST_NODE_TYPES.BinaryExpression;\n    left: Expression | PrivateIdentifier;\n    operator: ValueOf<BinaryOperatorToText>;\n    right: Expression;\n}\nexport declare interface BinaryOperatorToText {\n    [SyntaxKind.AmpersandAmpersandToken]: '&&';\n    [SyntaxKind.AmpersandToken]: '&';\n    [SyntaxKind.AsteriskAsteriskToken]: '**';\n    [SyntaxKind.AsteriskToken]: '*';\n    [SyntaxKind.BarBarToken]: '||';\n    [SyntaxKind.BarToken]: '|';\n    [SyntaxKind.CaretToken]: '^';\n    [SyntaxKind.EqualsEqualsEqualsToken]: '===';\n    [SyntaxKind.EqualsEqualsToken]: '==';\n    [SyntaxKind.ExclamationEqualsEqualsToken]: '!==';\n    [SyntaxKind.ExclamationEqualsToken]: '!=';\n    [SyntaxKind.GreaterThanEqualsToken]: '>=';\n    [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>';\n    [SyntaxKind.GreaterThanGreaterThanToken]: '>>';\n    [SyntaxKind.GreaterThanToken]: '>';\n    [SyntaxKind.InKeyword]: 'in';\n    [SyntaxKind.InstanceOfKeyword]: 'instanceof';\n    [SyntaxKind.LessThanEqualsToken]: '<=';\n    [SyntaxKind.LessThanLessThanToken]: '<<';\n    [SyntaxKind.LessThanToken]: '<';\n    [SyntaxKind.MinusToken]: '-';\n    [SyntaxKind.PercentToken]: '%';\n    [SyntaxKind.PlusToken]: '+';\n    [SyntaxKind.SlashToken]: '/';\n}\nexport declare type BindingName = BindingPattern | Identifier;\nexport declare type BindingPattern = ArrayPattern | ObjectPattern;\nexport declare interface BlockComment extends BaseToken {\n    type: AST_TOKEN_TYPES.Block;\n}\nexport declare interface BlockStatement extends BaseNode {\n    type: AST_NODE_TYPES.BlockStatement;\n    body: Statement[];\n}\nexport declare interface BooleanLiteral extends LiteralBase {\n    raw: 'false' | 'true';\n    value: boolean;\n}\nexport declare interface BooleanToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Boolean;\n}\nexport declare interface BreakStatement extends BaseNode {\n    type: AST_NODE_TYPES.BreakStatement;\n    label: Identifier | null;\n}\nexport declare interface CallExpression extends BaseNode {\n    type: AST_NODE_TYPES.CallExpression;\n    arguments: CallExpressionArgument[];\n    callee: Expression;\n    optional: boolean;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n}\nexport declare type CallExpressionArgument = Expression | SpreadElement;\nexport declare interface CatchClause extends BaseNode {\n    type: AST_NODE_TYPES.CatchClause;\n    body: BlockStatement;\n    param: BindingName | null;\n}\nexport declare type ChainElement = CallExpression | MemberExpression | TSNonNullExpression;\nexport declare interface ChainExpression extends BaseNode {\n    type: AST_NODE_TYPES.ChainExpression;\n    expression: ChainElement;\n}\ndeclare interface ClassBase extends BaseNode {\n    /**\n     * Whether the class is an abstract class.\n     * @example\n     * ```ts\n     * abstract class Foo {}\n     * ```\n     */\n    abstract: boolean;\n    /**\n     * The class body.\n     */\n    body: ClassBody;\n    /**\n     * Whether the class has been `declare`d:\n     * @example\n     * ```ts\n     * declare class Foo {}\n     * ```\n     */\n    declare: boolean;\n    /**\n     * The decorators declared for the class.\n     * @example\n     * ```ts\n     * @deco\n     * class Foo {}\n     * ```\n     */\n    decorators: Decorator[];\n    /**\n     * The class's name.\n     * - For a `ClassExpression` this may be `null` if the name is omitted.\n     * - For a `ClassDeclaration` this may be `null` if and only if the parent is\n     *   an `ExportDefaultDeclaration`.\n     */\n    id: Identifier | null;\n    /**\n     * The implemented interfaces for the class.\n     */\n    implements: TSClassImplements[];\n    /**\n     * The super class this class extends.\n     */\n    superClass: LeftHandSideExpression | null;\n    /**\n     * The generic type parameters passed to the superClass.\n     */\n    superTypeArguments: TSTypeParameterInstantiation | undefined;\n    /**\n     * The generic type parameters declared for the class.\n     */\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare interface ClassBody extends BaseNode {\n    type: AST_NODE_TYPES.ClassBody;\n    body: ClassElement[];\n}\nexport declare type ClassDeclaration = ClassDeclarationWithName | ClassDeclarationWithOptionalName;\ndeclare interface ClassDeclarationBase extends ClassBase {\n    type: AST_NODE_TYPES.ClassDeclaration;\n}\n/**\n * A normal class declaration:\n * ```\n * class A {}\n * ```\n */\nexport declare interface ClassDeclarationWithName extends ClassDeclarationBase {\n    id: Identifier;\n}\n/**\n * Default-exported class declarations have optional names:\n * ```\n * export default class {}\n * ```\n */\nexport declare interface ClassDeclarationWithOptionalName extends ClassDeclarationBase {\n    id: Identifier | null;\n}\nexport declare type ClassElement = AccessorProperty | MethodDefinition | PropertyDefinition | StaticBlock | TSAbstractAccessorProperty | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSIndexSignature;\nexport declare interface ClassExpression extends ClassBase {\n    type: AST_NODE_TYPES.ClassExpression;\n    abstract: false;\n    declare: false;\n}\ndeclare interface ClassMethodDefinitionNonComputedNameBase extends MethodDefinitionBase {\n    computed: false;\n    key: ClassPropertyNameNonComputed;\n}\ndeclare interface ClassPropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {\n    computed: false;\n    key: ClassPropertyNameNonComputed;\n}\nexport declare type ClassPropertyNameNonComputed = PrivateIdentifier | PropertyNameNonComputed;\nexport declare type Comment = BlockComment | LineComment;\nexport declare interface ConditionalExpression extends BaseNode {\n    type: AST_NODE_TYPES.ConditionalExpression;\n    alternate: Expression;\n    consequent: Expression;\n    test: Expression;\n}\nexport declare interface ConstDeclaration extends LetOrConstOrVarDeclarationBase {\n    /**\n     * In a `declare const` declaration, the declarators may have initializers, but\n     * not definite assignment assertions. Each declarator cannot have both an\n     * initializer and a type annotation.\n     *\n     * Even if the declaration has no `declare`, it may still be ambient and have\n     * no initializer.\n     */\n    declarations: VariableDeclaratorMaybeInit[];\n    kind: 'const';\n}\nexport declare interface ContinueStatement extends BaseNode {\n    type: AST_NODE_TYPES.ContinueStatement;\n    label: Identifier | null;\n}\nexport declare interface DebuggerStatement extends BaseNode {\n    type: AST_NODE_TYPES.DebuggerStatement;\n}\n/**\n * @deprecated\n * Note that this is neither up to date nor fully correct.\n */\nexport declare type DeclarationStatement = ClassDeclaration | ClassExpression | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | FunctionDeclaration | TSDeclareFunction | TSEnumDeclaration | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration;\nexport declare interface Decorator extends BaseNode {\n    type: AST_NODE_TYPES.Decorator;\n    expression: LeftHandSideExpression;\n}\nexport declare type DefaultExportDeclarations = ClassDeclarationWithOptionalName | Expression | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;\nexport declare type DestructuringPattern = ArrayPattern | AssignmentPattern | Identifier | MemberExpression | ObjectPattern | RestElement;\nexport declare interface DoWhileStatement extends BaseNode {\n    type: AST_NODE_TYPES.DoWhileStatement;\n    body: Statement;\n    test: Expression;\n}\nexport declare interface EmptyStatement extends BaseNode {\n    type: AST_NODE_TYPES.EmptyStatement;\n}\nexport declare type EntityName = Identifier | ThisExpression | TSQualifiedName;\nexport declare interface ExportAllDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.ExportAllDeclaration;\n    /**\n     * The assertions declared for the export.\n     * @example\n     * ```ts\n     * export * from 'mod' assert \\{ type: 'json' \\};\n     * ```\n     * @deprecated Replaced with {@link `attributes`}.\n     */\n    assertions: ImportAttribute[];\n    /**\n     * The attributes declared for the export.\n     * @example\n     * ```ts\n     * export * from 'mod' with \\{ type: 'json' \\};\n     * ```\n     */\n    attributes: ImportAttribute[];\n    /**\n     * The name for the exported items (`as X`). `null` if no name is assigned.\n     */\n    exported: Identifier | null;\n    /**\n     * The kind of the export.\n     */\n    exportKind: ExportKind;\n    /**\n     * The source module being exported from.\n     */\n    source: StringLiteral;\n}\ndeclare type ExportAndImportKind = 'type' | 'value';\nexport declare type ExportDeclaration = DefaultExportDeclarations | NamedExportDeclarations;\nexport declare interface ExportDefaultDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.ExportDefaultDeclaration;\n    /**\n     * The declaration being exported.\n     */\n    declaration: DefaultExportDeclarations;\n    /**\n     * The kind of the export. Always `value` for default exports.\n     */\n    exportKind: 'value';\n}\ndeclare type ExportKind = ExportAndImportKind;\nexport declare type ExportNamedDeclaration = ExportNamedDeclarationWithoutSourceWithMultiple | ExportNamedDeclarationWithoutSourceWithSingle | ExportNamedDeclarationWithSource;\ndeclare interface ExportNamedDeclarationBase extends BaseNode {\n    type: AST_NODE_TYPES.ExportNamedDeclaration;\n    /**\n     * The assertions declared for the export.\n     * @example\n     * ```ts\n     * export { foo } from 'mod' assert \\{ type: 'json' \\};\n     * ```\n     * This will be an empty array if `source` is `null`\n     * @deprecated Replaced with {@link `attributes`}.\n     */\n    assertions: ImportAttribute[];\n    /**\n     * The attributes declared for the export.\n     * @example\n     * ```ts\n     * export { foo } from 'mod' with \\{ type: 'json' \\};\n     * ```\n     * This will be an empty array if `source` is `null`\n     */\n    attributes: ImportAttribute[];\n    /**\n     * The exported declaration.\n     * @example\n     * ```ts\n     * export const x = 1;\n     * ```\n     * This will be `null` if `source` is not `null`, or if there are `specifiers`\n     */\n    declaration: NamedExportDeclarations | null;\n    /**\n     * The kind of the export.\n     */\n    exportKind: ExportKind;\n    /**\n     * The source module being exported from.\n     */\n    source: StringLiteral | null;\n    /**\n     * The specifiers being exported.\n     * @example\n     * ```ts\n     * export { a, b };\n     * ```\n     * This will be an empty array if `declaration` is not `null`\n     */\n    specifiers: ExportSpecifier[];\n}\nexport declare type ExportNamedDeclarationWithoutSource = ExportNamedDeclarationWithoutSourceWithMultiple | ExportNamedDeclarationWithoutSourceWithSingle;\n/**\n * Exporting names from the current module.\n * ```\n * export {};\n * export { a, b };\n * ```\n */\nexport declare interface ExportNamedDeclarationWithoutSourceWithMultiple extends ExportNamedDeclarationBase {\n    /**\n     * This will always be an empty array.\n     * @deprecated Replaced with {@link `attributes`}.\n     */\n    assertions: ImportAttribute[];\n    /**\n     * This will always be an empty array.\n     */\n    attributes: ImportAttribute[];\n    declaration: null;\n    source: null;\n    specifiers: ExportSpecifierWithIdentifierLocal[];\n}\n/**\n * Exporting a single named declaration.\n * ```\n * export const x = 1;\n * ```\n */\nexport declare interface ExportNamedDeclarationWithoutSourceWithSingle extends ExportNamedDeclarationBase {\n    /**\n     * This will always be an empty array.\n     * @deprecated Replaced with {@link `attributes`}.\n     */\n    assertions: ImportAttribute[];\n    /**\n     * This will always be an empty array.\n     */\n    attributes: ImportAttribute[];\n    declaration: NamedExportDeclarations;\n    source: null;\n    /**\n     * This will always be an empty array.\n     */\n    specifiers: ExportSpecifierWithIdentifierLocal[];\n}\n/**\n * Export names from another module.\n * ```\n * export { a, b } from 'mod';\n * ```\n */\nexport declare interface ExportNamedDeclarationWithSource extends ExportNamedDeclarationBase {\n    declaration: null;\n    source: StringLiteral;\n}\nexport declare type ExportSpecifier = ExportSpecifierWithIdentifierLocal | ExportSpecifierWithStringOrLiteralLocal;\ndeclare interface ExportSpecifierBase extends BaseNode {\n    type: AST_NODE_TYPES.ExportSpecifier;\n    exported: Identifier | StringLiteral;\n    exportKind: ExportKind;\n    local: Identifier | StringLiteral;\n}\nexport declare interface ExportSpecifierWithIdentifierLocal extends ExportSpecifierBase {\n    local: Identifier;\n}\nexport declare interface ExportSpecifierWithStringOrLiteralLocal extends ExportSpecifierBase {\n    local: Identifier | StringLiteral;\n}\nexport declare type Expression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AwaitExpression | BinaryExpression | CallExpression | ChainExpression | ClassExpression | ConditionalExpression | FunctionExpression | Identifier | ImportExpression | JSXElement | JSXFragment | LiteralExpression | LogicalExpression | MemberExpression | MetaProperty | NewExpression | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | TemplateLiteral | ThisExpression | TSAsExpression | TSInstantiationExpression | TSNonNullExpression | TSSatisfiesExpression | TSTypeAssertion | UnaryExpression | UpdateExpression | YieldExpression;\nexport declare interface ExpressionStatement extends BaseNode {\n    type: AST_NODE_TYPES.ExpressionStatement;\n    directive: string | undefined;\n    expression: Expression;\n}\nexport declare type ForInitialiser = Expression | LetOrConstOrVarDeclaration;\nexport declare interface ForInStatement extends BaseNode {\n    type: AST_NODE_TYPES.ForInStatement;\n    body: Statement;\n    left: ForInitialiser;\n    right: Expression;\n}\ndeclare type ForOfInitialiser = Expression | LetOrConstOrVarDeclaration | UsingInForOfDeclaration;\nexport declare interface ForOfStatement extends BaseNode {\n    type: AST_NODE_TYPES.ForOfStatement;\n    await: boolean;\n    body: Statement;\n    left: ForOfInitialiser;\n    right: Expression;\n}\nexport declare interface ForStatement extends BaseNode {\n    type: AST_NODE_TYPES.ForStatement;\n    body: Statement;\n    init: Expression | ForInitialiser | null;\n    test: Expression | null;\n    update: Expression | null;\n}\ndeclare interface FunctionBase extends BaseNode {\n    /**\n     * Whether the function is async:\n     * ```\n     * async function foo() {}\n     * const x = async function () {}\n     * const x = async () => {}\n     * ```\n     */\n    async: boolean;\n    /**\n     * The body of the function.\n     * - For an `ArrowFunctionExpression` this may be an `Expression` or `BlockStatement`.\n     * - For a `FunctionDeclaration` or `FunctionExpression` this is always a `BlockStatement`.\n     * - For a `TSDeclareFunction` this is always `undefined`.\n     * - For a `TSEmptyBodyFunctionExpression` this is always `null`.\n     */\n    body: BlockStatement | Expression | null | undefined;\n    /**\n     * This is only `true` if and only if the node is a `TSDeclareFunction` and it has `declare`:\n     * ```\n     * declare function foo() {}\n     * ```\n     */\n    declare: boolean;\n    /**\n     * This is only ever `true` if and only the node is an `ArrowFunctionExpression` and the body\n     * is an expression:\n     * ```\n     * (() => 1)\n     * ```\n     */\n    expression: boolean;\n    /**\n     * Whether the function is a generator function:\n     * ```\n     * function *foo() {}\n     * const x = function *() {}\n     * ```\n     * This is always `false` for arrow functions as they cannot be generators.\n     */\n    generator: boolean;\n    /**\n     * The function's name.\n     * - For an `ArrowFunctionExpression` this is always `null`.\n     * - For a `FunctionExpression` this may be `null` if the name is omitted.\n     * - For a `FunctionDeclaration` or `TSDeclareFunction` this may be `null` if\n     *   and only if the parent is an `ExportDefaultDeclaration`.\n     */\n    id: Identifier | null;\n    /**\n     * The list of parameters declared for the function.\n     */\n    params: Parameter[];\n    /**\n     * The return type annotation for the function.\n     */\n    returnType: TSTypeAnnotation | undefined;\n    /**\n     * The generic type parameter declaration for the function.\n     */\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare type FunctionDeclaration = FunctionDeclarationWithName | FunctionDeclarationWithOptionalName;\ndeclare interface FunctionDeclarationBase extends FunctionBase {\n    type: AST_NODE_TYPES.FunctionDeclaration;\n    body: BlockStatement;\n    declare: false;\n    expression: false;\n}\n/**\n * A normal function declaration:\n * ```\n * function f() {}\n * ```\n */\nexport declare interface FunctionDeclarationWithName extends FunctionDeclarationBase {\n    id: Identifier;\n}\n/**\n * Default-exported function declarations have optional names:\n * ```\n * export default function () {}\n * ```\n */\nexport declare interface FunctionDeclarationWithOptionalName extends FunctionDeclarationBase {\n    id: Identifier | null;\n}\nexport declare interface FunctionExpression extends FunctionBase {\n    type: AST_NODE_TYPES.FunctionExpression;\n    body: BlockStatement;\n    expression: false;\n}\nexport declare type FunctionLike = ArrowFunctionExpression | FunctionDeclaration | FunctionExpression | TSDeclareFunction | TSEmptyBodyFunctionExpression;\nexport declare interface Identifier extends BaseNode {\n    type: AST_NODE_TYPES.Identifier;\n    decorators: Decorator[];\n    name: string;\n    optional: boolean;\n    typeAnnotation: TSTypeAnnotation | undefined;\n}\nexport declare interface IdentifierToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Identifier;\n}\nexport declare interface IfStatement extends BaseNode {\n    type: AST_NODE_TYPES.IfStatement;\n    alternate: Statement | null;\n    consequent: Statement;\n    test: Expression;\n}\nexport declare interface ImportAttribute extends BaseNode {\n    type: AST_NODE_TYPES.ImportAttribute;\n    key: Identifier | Literal;\n    value: Literal;\n}\nexport declare type ImportClause = ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier;\nexport declare interface ImportDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.ImportDeclaration;\n    /**\n     * The assertions declared for the export.\n     * @example\n     * ```ts\n     * import * from 'mod' assert \\{ type: 'json' \\};\n     * ```\n     * @deprecated Replaced with {@link `attributes`}.\n     */\n    assertions: ImportAttribute[];\n    /**\n     * The attributes declared for the export.\n     * @example\n     * ```ts\n     * import * from 'mod' with \\{ type: 'json' \\};\n     * ```\n     */\n    attributes: ImportAttribute[];\n    /**\n     * The kind of the import.\n     */\n    importKind: ImportKind;\n    /**\n     * The source module being imported from.\n     */\n    source: StringLiteral;\n    /**\n     * The specifiers being imported.\n     * If this is an empty array then either there are no specifiers:\n     * ```\n     * import {} from 'mod';\n     * ```\n     * Or it is a side-effect import:\n     * ```\n     * import 'mod';\n     * ```\n     */\n    specifiers: ImportClause[];\n}\nexport declare interface ImportDefaultSpecifier extends BaseNode {\n    type: AST_NODE_TYPES.ImportDefaultSpecifier;\n    local: Identifier;\n}\nexport declare interface ImportExpression extends BaseNode {\n    type: AST_NODE_TYPES.ImportExpression;\n    /**\n     * The attributes declared for the dynamic import.\n     * @example\n     * ```ts\n     * import('mod', \\{ assert: \\{ type: 'json' \\} \\});\n     * ```\n     * @deprecated Replaced with {@link `options`}.\n     */\n    attributes: Expression | null;\n    /**\n     * The options bag declared for the dynamic import.\n     * @example\n     * ```ts\n     * import('mod', \\{ assert: \\{ type: 'json' \\} \\});\n     * ```\n     */\n    options: Expression | null;\n    source: Expression;\n}\ndeclare type ImportKind = ExportAndImportKind;\nexport declare interface ImportNamespaceSpecifier extends BaseNode {\n    type: AST_NODE_TYPES.ImportNamespaceSpecifier;\n    local: Identifier;\n}\nexport declare interface ImportSpecifier extends BaseNode {\n    type: AST_NODE_TYPES.ImportSpecifier;\n    imported: Identifier | StringLiteral;\n    importKind: ImportKind;\n    local: Identifier;\n}\nexport declare type IterationStatement = DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | WhileStatement;\nexport declare interface JSXAttribute extends BaseNode {\n    type: AST_NODE_TYPES.JSXAttribute;\n    name: JSXIdentifier | JSXNamespacedName;\n    value: JSXElement | JSXExpression | Literal | null;\n}\nexport declare type JSXChild = JSXElement | JSXExpression | JSXFragment | JSXText;\nexport declare interface JSXClosingElement extends BaseNode {\n    type: AST_NODE_TYPES.JSXClosingElement;\n    name: JSXTagNameExpression;\n}\nexport declare interface JSXClosingFragment extends BaseNode {\n    type: AST_NODE_TYPES.JSXClosingFragment;\n}\nexport declare interface JSXElement extends BaseNode {\n    type: AST_NODE_TYPES.JSXElement;\n    children: JSXChild[];\n    closingElement: JSXClosingElement | null;\n    openingElement: JSXOpeningElement;\n}\nexport declare interface JSXEmptyExpression extends BaseNode {\n    type: AST_NODE_TYPES.JSXEmptyExpression;\n}\nexport declare type JSXExpression = JSXExpressionContainer | JSXSpreadChild;\nexport declare interface JSXExpressionContainer extends BaseNode {\n    type: AST_NODE_TYPES.JSXExpressionContainer;\n    expression: Expression | JSXEmptyExpression;\n}\nexport declare interface JSXFragment extends BaseNode {\n    type: AST_NODE_TYPES.JSXFragment;\n    children: JSXChild[];\n    closingFragment: JSXClosingFragment;\n    openingFragment: JSXOpeningFragment;\n}\nexport declare interface JSXIdentifier extends BaseNode {\n    type: AST_NODE_TYPES.JSXIdentifier;\n    name: string;\n}\nexport declare interface JSXIdentifierToken extends BaseToken {\n    type: AST_TOKEN_TYPES.JSXIdentifier;\n}\nexport declare interface JSXMemberExpression extends BaseNode {\n    type: AST_NODE_TYPES.JSXMemberExpression;\n    object: JSXTagNameExpression;\n    property: JSXIdentifier;\n}\nexport declare interface JSXNamespacedName extends BaseNode {\n    type: AST_NODE_TYPES.JSXNamespacedName;\n    name: JSXIdentifier;\n    namespace: JSXIdentifier;\n}\nexport declare interface JSXOpeningElement extends BaseNode {\n    type: AST_NODE_TYPES.JSXOpeningElement;\n    attributes: (JSXAttribute | JSXSpreadAttribute)[];\n    name: JSXTagNameExpression;\n    selfClosing: boolean;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n}\nexport declare interface JSXOpeningFragment extends BaseNode {\n    type: AST_NODE_TYPES.JSXOpeningFragment;\n}\nexport declare interface JSXSpreadAttribute extends BaseNode {\n    type: AST_NODE_TYPES.JSXSpreadAttribute;\n    argument: Expression;\n}\nexport declare interface JSXSpreadChild extends BaseNode {\n    type: AST_NODE_TYPES.JSXSpreadChild;\n    expression: Expression | JSXEmptyExpression;\n}\nexport declare type JSXTagNameExpression = JSXIdentifier | JSXMemberExpression | JSXNamespacedName;\nexport declare interface JSXText extends BaseNode {\n    type: AST_NODE_TYPES.JSXText;\n    raw: string;\n    value: string;\n}\nexport declare interface JSXTextToken extends BaseToken {\n    type: AST_TOKEN_TYPES.JSXText;\n}\nexport declare interface KeywordToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Keyword;\n}\nexport declare interface LabeledStatement extends BaseNode {\n    type: AST_NODE_TYPES.LabeledStatement;\n    body: Statement;\n    label: Identifier;\n}\nexport declare type LeftHandSideExpression = ArrayExpression | ArrayPattern | ArrowFunctionExpression | CallExpression | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | LiteralExpression | MemberExpression | MetaProperty | ObjectExpression | ObjectPattern | SequenceExpression | Super | TaggedTemplateExpression | ThisExpression | TSAsExpression | TSNonNullExpression | TSTypeAssertion;\nexport declare type LetOrConstOrVarDeclaration = ConstDeclaration | LetOrVarDeclaredDeclaration | LetOrVarNonDeclaredDeclaration;\ndeclare interface LetOrConstOrVarDeclarationBase extends BaseNode {\n    type: AST_NODE_TYPES.VariableDeclaration;\n    /**\n     * The variables declared by this declaration.\n     * Always non-empty.\n     * @example\n     * ```ts\n     * let x;\n     * let y, z;\n     * ```\n     */\n    declarations: LetOrConstOrVarDeclarator[];\n    /**\n     * Whether the declaration is `declare`d\n     * @example\n     * ```ts\n     * declare const x = 1;\n     * ```\n     */\n    declare: boolean;\n    /**\n     * The keyword used to declare the variable(s)\n     * @example\n     * ```ts\n     * const x = 1;\n     * let y = 2;\n     * var z = 3;\n     * ```\n     */\n    kind: 'const' | 'let' | 'var';\n}\nexport declare type LetOrConstOrVarDeclarator = VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit | VariableDeclaratorNoInit;\nexport declare interface LetOrVarDeclaredDeclaration extends LetOrConstOrVarDeclarationBase {\n    /**\n     * In a `declare let` declaration, the declarators must not have definite assignment\n     * assertions or initializers.\n     *\n     * @example\n     * ```ts\n     * using x = 1;\n     * using y =1, z = 2;\n     * ```\n     */\n    declarations: VariableDeclaratorNoInit[];\n    declare: true;\n    kind: 'let' | 'var';\n}\nexport declare interface LetOrVarNonDeclaredDeclaration extends LetOrConstOrVarDeclarationBase {\n    /**\n     * In a `let`/`var` declaration, the declarators may have definite assignment\n     * assertions or initializers, but not both.\n     */\n    declarations: (VariableDeclaratorDefiniteAssignment | VariableDeclaratorMaybeInit)[];\n    declare: false;\n    kind: 'let' | 'var';\n}\nexport declare interface LineComment extends BaseToken {\n    type: AST_TOKEN_TYPES.Line;\n}\nexport declare type Literal = BigIntLiteral | BooleanLiteral | NullLiteral | NumberLiteral | RegExpLiteral | StringLiteral;\ndeclare interface LiteralBase extends BaseNode {\n    type: AST_NODE_TYPES.Literal;\n    raw: string;\n    value: bigint | boolean | number | string | RegExp | null;\n}\nexport declare type LiteralExpression = Literal | TemplateLiteral;\nexport declare interface LogicalExpression extends BaseNode {\n    type: AST_NODE_TYPES.LogicalExpression;\n    left: Expression;\n    operator: '&&' | '??' | '||';\n    right: Expression;\n}\nexport declare type MemberExpression = MemberExpressionComputedName | MemberExpressionNonComputedName;\ndeclare interface MemberExpressionBase extends BaseNode {\n    computed: boolean;\n    object: Expression;\n    optional: boolean;\n    property: Expression | Identifier | PrivateIdentifier;\n}\nexport declare interface MemberExpressionComputedName extends MemberExpressionBase {\n    type: AST_NODE_TYPES.MemberExpression;\n    computed: true;\n    property: Expression;\n}\nexport declare interface MemberExpressionNonComputedName extends MemberExpressionBase {\n    type: AST_NODE_TYPES.MemberExpression;\n    computed: false;\n    property: Identifier | PrivateIdentifier;\n}\nexport declare interface MetaProperty extends BaseNode {\n    type: AST_NODE_TYPES.MetaProperty;\n    meta: Identifier;\n    property: Identifier;\n}\nexport declare type MethodDefinition = MethodDefinitionComputedName | MethodDefinitionNonComputedName;\n/** this should not be directly used - instead use MethodDefinitionComputedNameBase or MethodDefinitionNonComputedNameBase */\ndeclare interface MethodDefinitionBase extends BaseNode {\n    accessibility: Accessibility | undefined;\n    computed: boolean;\n    decorators: Decorator[];\n    key: PropertyName;\n    kind: 'constructor' | 'get' | 'method' | 'set';\n    optional: boolean;\n    override: boolean;\n    static: boolean;\n    value: FunctionExpression | TSEmptyBodyFunctionExpression;\n}\nexport declare interface MethodDefinitionComputedName extends MethodDefinitionComputedNameBase {\n    type: AST_NODE_TYPES.MethodDefinition;\n}\ndeclare interface MethodDefinitionComputedNameBase extends MethodDefinitionBase {\n    computed: true;\n    key: PropertyNameComputed;\n}\nexport declare interface MethodDefinitionNonComputedName extends ClassMethodDefinitionNonComputedNameBase {\n    type: AST_NODE_TYPES.MethodDefinition;\n}\ndeclare interface MethodDefinitionNonComputedNameBase extends MethodDefinitionBase {\n    computed: false;\n    key: PropertyNameNonComputed;\n}\nexport declare type NamedExportDeclarations = ClassDeclarationWithName | ClassDeclarationWithOptionalName | FunctionDeclarationWithName | FunctionDeclarationWithOptionalName | TSDeclareFunction | TSEnumDeclaration | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSTypeAliasDeclaration | VariableDeclaration;\nexport declare interface NewExpression extends BaseNode {\n    type: AST_NODE_TYPES.NewExpression;\n    arguments: CallExpressionArgument[];\n    callee: Expression;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n}\nexport declare type Node = AccessorProperty | ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BlockStatement | BreakStatement | CallExpression | CatchClause | ChainExpression | ClassBody | ClassDeclaration | ClassExpression | ConditionalExpression | ContinueStatement | DebuggerStatement | Decorator | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportExpression | ImportNamespaceSpecifier | ImportSpecifier | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | Literal | LogicalExpression | MemberExpression | MetaProperty | MethodDefinition | NewExpression | ObjectExpression | ObjectPattern | PrivateIdentifier | Program | Property | PropertyDefinition | RestElement | ReturnStatement | SequenceExpression | SpreadElement | StaticBlock | Super | SwitchCase | SwitchStatement | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThrowStatement | TryStatement | TSAbstractAccessorProperty | TSAbstractKeyword | TSAbstractMethodDefinition | TSAbstractPropertyDefinition | TSAnyKeyword | TSArrayType | TSAsExpression | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSClassImplements | TSConditionalType | TSConstructorType | TSConstructSignatureDeclaration | TSDeclareFunction | TSDeclareKeyword | TSEmptyBodyFunctionExpression | TSEnumBody | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExportKeyword | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexedAccessType | TSIndexSignature | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSInterfaceHeritage | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSPrivateKeyword | TSPropertySignature | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSSatisfiesExpression | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;\nexport declare interface NodeOrTokenData {\n    type: string;\n    /**\n     * The source location information of the node.\n     *\n     * The loc property is defined as nullable by ESTree, but ESLint requires this property.\n     */\n    loc: SourceLocation;\n    range: Range;\n}\nexport declare interface NullLiteral extends LiteralBase {\n    raw: 'null';\n    value: null;\n}\nexport declare interface NullToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Null;\n}\nexport declare interface NumberLiteral extends LiteralBase {\n    value: number;\n}\nexport declare interface NumericToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Numeric;\n}\nexport declare interface ObjectExpression extends BaseNode {\n    type: AST_NODE_TYPES.ObjectExpression;\n    properties: ObjectLiteralElement[];\n}\nexport declare type ObjectLiteralElement = Property | SpreadElement;\nexport declare type ObjectLiteralElementLike = ObjectLiteralElement;\nexport declare interface ObjectPattern extends BaseNode {\n    type: AST_NODE_TYPES.ObjectPattern;\n    decorators: Decorator[];\n    optional: boolean;\n    properties: (Property | RestElement)[];\n    typeAnnotation: TSTypeAnnotation | undefined;\n}\nexport declare type OptionalRangeAndLoc<T> = {\n    loc?: SourceLocation;\n    range?: Range;\n} & Pick<T, Exclude<keyof T, 'loc' | 'range'>>;\nexport declare type Parameter = ArrayPattern | AssignmentPattern | Identifier | ObjectPattern | RestElement | TSParameterProperty;\nexport declare interface Position {\n    /**\n     * Column number on the line (0-indexed)\n     */\n    column: number;\n    /**\n     * Line number (1-indexed)\n     */\n    line: number;\n}\nexport declare type PrimaryExpression = ArrayExpression | ArrayPattern | ClassExpression | FunctionExpression | Identifier | JSXElement | JSXFragment | JSXOpeningElement | LiteralExpression | MetaProperty | ObjectExpression | ObjectPattern | Super | TemplateLiteral | ThisExpression | TSNullKeyword;\nexport declare interface PrivateIdentifier extends BaseNode {\n    type: AST_NODE_TYPES.PrivateIdentifier;\n    name: string;\n}\nexport declare interface Program extends NodeOrTokenData {\n    type: AST_NODE_TYPES.Program;\n    body: ProgramStatement[];\n    comments: Comment[] | undefined;\n    sourceType: 'module' | 'script';\n    tokens: Token[] | undefined;\n}\nexport declare type ProgramStatement = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | Statement | TSImportEqualsDeclaration | TSNamespaceExportDeclaration;\nexport declare type Property = PropertyComputedName | PropertyNonComputedName;\ndeclare interface PropertyBase extends BaseNode {\n    type: AST_NODE_TYPES.Property;\n    computed: boolean;\n    key: PropertyName;\n    kind: 'get' | 'init' | 'set';\n    method: boolean;\n    optional: boolean;\n    shorthand: boolean;\n    value: AssignmentPattern | BindingName | Expression | TSEmptyBodyFunctionExpression;\n}\nexport declare interface PropertyComputedName extends PropertyBase {\n    computed: true;\n    key: PropertyNameComputed;\n}\nexport declare type PropertyDefinition = PropertyDefinitionComputedName | PropertyDefinitionNonComputedName;\ndeclare interface PropertyDefinitionBase extends BaseNode {\n    accessibility: Accessibility | undefined;\n    computed: boolean;\n    declare: boolean;\n    decorators: Decorator[];\n    definite: boolean;\n    key: PropertyName;\n    optional: boolean;\n    override: boolean;\n    readonly: boolean;\n    static: boolean;\n    typeAnnotation: TSTypeAnnotation | undefined;\n    value: Expression | null;\n}\nexport declare interface PropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {\n    type: AST_NODE_TYPES.PropertyDefinition;\n}\ndeclare interface PropertyDefinitionComputedNameBase extends PropertyDefinitionBase {\n    computed: true;\n    key: PropertyNameComputed;\n}\nexport declare interface PropertyDefinitionNonComputedName extends ClassPropertyDefinitionNonComputedNameBase {\n    type: AST_NODE_TYPES.PropertyDefinition;\n}\ndeclare interface PropertyDefinitionNonComputedNameBase extends PropertyDefinitionBase {\n    computed: false;\n    key: PropertyNameNonComputed;\n}\nexport declare type PropertyName = ClassPropertyNameNonComputed | PropertyNameComputed | PropertyNameNonComputed;\nexport declare type PropertyNameComputed = Expression;\nexport declare type PropertyNameNonComputed = Identifier | NumberLiteral | StringLiteral;\nexport declare interface PropertyNonComputedName extends PropertyBase {\n    computed: false;\n    key: PropertyNameNonComputed;\n}\nexport declare interface PunctuatorToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Punctuator;\n    value: ValueOf<PunctuatorTokenToText>;\n}\nexport declare interface PunctuatorTokenToText extends AssignmentOperatorToText {\n    [SyntaxKind.AmpersandAmpersandToken]: '&&';\n    [SyntaxKind.AmpersandToken]: '&';\n    [SyntaxKind.AsteriskAsteriskToken]: '**';\n    [SyntaxKind.AsteriskToken]: '*';\n    [SyntaxKind.AtToken]: '@';\n    [SyntaxKind.BacktickToken]: '`';\n    [SyntaxKind.BarBarToken]: '||';\n    [SyntaxKind.BarToken]: '|';\n    [SyntaxKind.CaretToken]: '^';\n    [SyntaxKind.CloseBraceToken]: '}';\n    [SyntaxKind.CloseBracketToken]: ']';\n    [SyntaxKind.CloseParenToken]: ')';\n    [SyntaxKind.ColonToken]: ':';\n    [SyntaxKind.CommaToken]: ',';\n    [SyntaxKind.DotDotDotToken]: '...';\n    [SyntaxKind.DotToken]: '.';\n    [SyntaxKind.EqualsEqualsEqualsToken]: '===';\n    [SyntaxKind.EqualsEqualsToken]: '==';\n    [SyntaxKind.EqualsGreaterThanToken]: '=>';\n    [SyntaxKind.ExclamationEqualsEqualsToken]: '!==';\n    [SyntaxKind.ExclamationEqualsToken]: '!=';\n    [SyntaxKind.ExclamationToken]: '!';\n    [SyntaxKind.GreaterThanEqualsToken]: '>=';\n    [SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: '>>>';\n    [SyntaxKind.GreaterThanGreaterThanToken]: '>>';\n    [SyntaxKind.GreaterThanToken]: '>';\n    [SyntaxKind.HashToken]: '#';\n    [SyntaxKind.LessThanEqualsToken]: '<=';\n    [SyntaxKind.LessThanLessThanToken]: '<<';\n    [SyntaxKind.LessThanSlashToken]: '</';\n    [SyntaxKind.LessThanToken]: '<';\n    [SyntaxKind.MinusMinusToken]: '--';\n    [SyntaxKind.MinusToken]: '-';\n    [SyntaxKind.OpenBraceToken]: '{';\n    [SyntaxKind.OpenBracketToken]: '[';\n    [SyntaxKind.OpenParenToken]: '(';\n    [SyntaxKind.PercentToken]: '%';\n    [SyntaxKind.PlusPlusToken]: '++';\n    [SyntaxKind.PlusToken]: '+';\n    [SyntaxKind.QuestionDotToken]: '?.';\n    [SyntaxKind.QuestionQuestionToken]: '??';\n    [SyntaxKind.QuestionToken]: '?';\n    [SyntaxKind.SemicolonToken]: ';';\n    [SyntaxKind.SlashToken]: '/';\n    [SyntaxKind.TildeToken]: '~';\n}\n/**\n * An array of two numbers.\n * Both numbers are a 0-based index which is the position in the array of source code characters.\n * The first is the start position of the node, the second is the end position of the node.\n */\nexport declare type Range = [number, number];\nexport declare interface RegExpLiteral extends LiteralBase {\n    regex: {\n        flags: string;\n        pattern: string;\n    };\n    value: RegExp | null;\n}\nexport declare interface RegularExpressionToken extends BaseToken {\n    type: AST_TOKEN_TYPES.RegularExpression;\n    regex: {\n        flags: string;\n        pattern: string;\n    };\n}\nexport declare interface RestElement extends BaseNode {\n    type: AST_NODE_TYPES.RestElement;\n    argument: DestructuringPattern;\n    decorators: Decorator[];\n    optional: boolean;\n    typeAnnotation: TSTypeAnnotation | undefined;\n    value: AssignmentPattern | undefined;\n}\nexport declare interface ReturnStatement extends BaseNode {\n    type: AST_NODE_TYPES.ReturnStatement;\n    argument: Expression | null;\n}\nexport declare interface SequenceExpression extends BaseNode {\n    type: AST_NODE_TYPES.SequenceExpression;\n    expressions: Expression[];\n}\nexport declare interface SourceLocation {\n    /**\n     * The position of the first character after the parsed source region\n     */\n    end: Position;\n    /**\n     * The position of the first character of the parsed source region\n     */\n    start: Position;\n}\nexport declare interface SpreadElement extends BaseNode {\n    type: AST_NODE_TYPES.SpreadElement;\n    argument: Expression;\n}\nexport declare type Statement = BlockStatement | BreakStatement | ClassDeclarationWithName | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclarationWithName | IfStatement | ImportDeclaration | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | TSDeclareFunction | TSEnumDeclaration | TSExportAssignment | TSImportEqualsDeclaration | TSInterfaceDeclaration | TSModuleDeclaration | TSNamespaceExportDeclaration | TSTypeAliasDeclaration | VariableDeclaration | WhileStatement | WithStatement;\nexport declare interface StaticBlock extends BaseNode {\n    type: AST_NODE_TYPES.StaticBlock;\n    body: Statement[];\n}\nexport declare interface StringLiteral extends LiteralBase {\n    value: string;\n}\nexport declare interface StringToken extends BaseToken {\n    type: AST_TOKEN_TYPES.String;\n}\nexport declare interface Super extends BaseNode {\n    type: AST_NODE_TYPES.Super;\n}\nexport declare interface SwitchCase extends BaseNode {\n    type: AST_NODE_TYPES.SwitchCase;\n    consequent: Statement[];\n    test: Expression | null;\n}\nexport declare interface SwitchStatement extends BaseNode {\n    type: AST_NODE_TYPES.SwitchStatement;\n    cases: SwitchCase[];\n    discriminant: Expression;\n}\nexport declare interface TaggedTemplateExpression extends BaseNode {\n    type: AST_NODE_TYPES.TaggedTemplateExpression;\n    quasi: TemplateLiteral;\n    tag: Expression;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n}\nexport declare interface TemplateElement extends BaseNode {\n    type: AST_NODE_TYPES.TemplateElement;\n    tail: boolean;\n    value: {\n        cooked: string;\n        raw: string;\n    };\n}\nexport declare interface TemplateLiteral extends BaseNode {\n    type: AST_NODE_TYPES.TemplateLiteral;\n    expressions: Expression[];\n    quasis: TemplateElement[];\n}\nexport declare interface TemplateToken extends BaseToken {\n    type: AST_TOKEN_TYPES.Template;\n}\nexport declare interface ThisExpression extends BaseNode {\n    type: AST_NODE_TYPES.ThisExpression;\n}\nexport declare interface ThrowStatement extends BaseNode {\n    type: AST_NODE_TYPES.ThrowStatement;\n    argument: Expression;\n}\nexport declare type Token = BooleanToken | Comment | IdentifierToken | JSXIdentifierToken | JSXTextToken | KeywordToken | NullToken | NumericToken | PunctuatorToken | RegularExpressionToken | StringToken | TemplateToken;\nexport declare interface TryStatement extends BaseNode {\n    type: AST_NODE_TYPES.TryStatement;\n    block: BlockStatement;\n    finalizer: BlockStatement | null;\n    handler: CatchClause | null;\n}\nexport declare type TSAbstractAccessorProperty = TSAbstractAccessorPropertyComputedName | TSAbstractAccessorPropertyNonComputedName;\nexport declare interface TSAbstractAccessorPropertyComputedName extends PropertyDefinitionComputedNameBase {\n    type: AST_NODE_TYPES.TSAbstractAccessorProperty;\n    value: null;\n}\nexport declare interface TSAbstractAccessorPropertyNonComputedName extends PropertyDefinitionNonComputedNameBase {\n    type: AST_NODE_TYPES.TSAbstractAccessorProperty;\n    value: null;\n}\nexport declare interface TSAbstractKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSAbstractKeyword;\n}\nexport declare type TSAbstractMethodDefinition = TSAbstractMethodDefinitionComputedName | TSAbstractMethodDefinitionNonComputedName;\nexport declare interface TSAbstractMethodDefinitionComputedName extends MethodDefinitionComputedNameBase {\n    type: AST_NODE_TYPES.TSAbstractMethodDefinition;\n}\nexport declare interface TSAbstractMethodDefinitionNonComputedName extends MethodDefinitionNonComputedNameBase {\n    type: AST_NODE_TYPES.TSAbstractMethodDefinition;\n}\nexport declare type TSAbstractPropertyDefinition = TSAbstractPropertyDefinitionComputedName | TSAbstractPropertyDefinitionNonComputedName;\nexport declare interface TSAbstractPropertyDefinitionComputedName extends PropertyDefinitionComputedNameBase {\n    type: AST_NODE_TYPES.TSAbstractPropertyDefinition;\n    value: null;\n}\nexport declare interface TSAbstractPropertyDefinitionNonComputedName extends PropertyDefinitionNonComputedNameBase {\n    type: AST_NODE_TYPES.TSAbstractPropertyDefinition;\n    value: null;\n}\nexport declare interface TSAnyKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSAnyKeyword;\n}\nexport declare interface TSArrayType extends BaseNode {\n    type: AST_NODE_TYPES.TSArrayType;\n    elementType: TypeNode;\n}\nexport declare interface TSAsExpression extends BaseNode {\n    type: AST_NODE_TYPES.TSAsExpression;\n    expression: Expression;\n    typeAnnotation: TypeNode;\n}\nexport declare interface TSAsyncKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSAsyncKeyword;\n}\nexport declare interface TSBigIntKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSBigIntKeyword;\n}\nexport declare interface TSBooleanKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSBooleanKeyword;\n}\nexport declare interface TSCallSignatureDeclaration extends TSFunctionSignatureBase {\n    type: AST_NODE_TYPES.TSCallSignatureDeclaration;\n}\nexport declare interface TSClassImplements extends TSHeritageBase {\n    type: AST_NODE_TYPES.TSClassImplements;\n}\nexport declare interface TSConditionalType extends BaseNode {\n    type: AST_NODE_TYPES.TSConditionalType;\n    checkType: TypeNode;\n    extendsType: TypeNode;\n    falseType: TypeNode;\n    trueType: TypeNode;\n}\nexport declare interface TSConstructorType extends TSFunctionSignatureBase {\n    type: AST_NODE_TYPES.TSConstructorType;\n    abstract: boolean;\n}\nexport declare interface TSConstructSignatureDeclaration extends TSFunctionSignatureBase {\n    type: AST_NODE_TYPES.TSConstructSignatureDeclaration;\n}\nexport declare type TSDeclareFunction = TSDeclareFunctionNoDeclare | TSDeclareFunctionWithDeclare;\ndeclare interface TSDeclareFunctionBase extends FunctionBase {\n    type: AST_NODE_TYPES.TSDeclareFunction;\n    /**\n     * TS1183: An implementation cannot be declared in ambient contexts.\n     */\n    body: undefined;\n    /**\n     * Whether the declaration has `declare` modifier.\n     */\n    declare: boolean;\n    expression: false;\n}\n/**\n * Function declaration without the `declare` keyword:\n * ```\n * function foo(): void;\n * ```\n * This can either be an overload signature or a declaration in an ambient context\n * (e.g. `declare module`)\n */\nexport declare interface TSDeclareFunctionNoDeclare extends TSDeclareFunctionBase {\n    declare: false;\n    /**\n     * - TS1221: Generators are not allowed in an ambient context.\n     * - TS1222: An overload signature cannot be declared as a generator.\n     */\n    generator: false;\n}\n/**\n * Function declaration with the `declare` keyword:\n * ```\n * declare function foo(): void;\n * ```\n */\nexport declare interface TSDeclareFunctionWithDeclare extends TSDeclareFunctionBase {\n    /**\n     * TS1040: 'async' modifier cannot be used in an ambient context.\n     */\n    async: false;\n    declare: true;\n    /**\n     * TS1221: Generators are not allowed in an ambient context.\n     */\n    generator: false;\n}\nexport declare interface TSDeclareKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSDeclareKeyword;\n}\nexport declare interface TSEmptyBodyFunctionExpression extends FunctionBase {\n    type: AST_NODE_TYPES.TSEmptyBodyFunctionExpression;\n    body: null;\n    id: null;\n}\nexport declare interface TSEnumBody extends BaseNode {\n    type: AST_NODE_TYPES.TSEnumBody;\n    members: TSEnumMember[];\n}\nexport declare interface TSEnumDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.TSEnumDeclaration;\n    /**\n     * The body of the enum.\n     */\n    body: TSEnumBody;\n    /**\n     * Whether this is a `const` enum.\n     * @example\n     * ```ts\n     * const enum Foo {}\n     * ```\n     */\n    const: boolean;\n    /**\n     * Whether this is a `declare`d enum.\n     * @example\n     * ```ts\n     * declare enum Foo {}\n     * ```\n     */\n    declare: boolean;\n    /**\n     * The enum name.\n     */\n    id: Identifier;\n    /**\n     * The enum members.\n     * @deprecated Use {@link body} instead.\n     */\n    members: TSEnumMember[];\n}\nexport declare type TSEnumMember = TSEnumMemberComputedName | TSEnumMemberNonComputedName;\ndeclare interface TSEnumMemberBase extends BaseNode {\n    type: AST_NODE_TYPES.TSEnumMember;\n    computed: boolean;\n    id: PropertyNameComputed | PropertyNameNonComputed;\n    initializer: Expression | undefined;\n}\n/**\n * this should only really happen in semantically invalid code (errors 1164 and 2452)\n *\n * @example\n * ```ts\n * // VALID:\n * enum Foo { ['a'] }\n *\n * // INVALID:\n * const x = 'a';\n * enum Foo { [x] }\n * enum Bar { ['a' + 'b'] }\n * ```\n */\nexport declare interface TSEnumMemberComputedName extends TSEnumMemberBase {\n    computed: true;\n    id: PropertyNameComputed;\n}\nexport declare interface TSEnumMemberNonComputedName extends TSEnumMemberBase {\n    computed: false;\n    id: PropertyNameNonComputed;\n}\nexport declare interface TSExportAssignment extends BaseNode {\n    type: AST_NODE_TYPES.TSExportAssignment;\n    expression: Expression;\n}\nexport declare interface TSExportKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSExportKeyword;\n}\nexport declare interface TSExternalModuleReference extends BaseNode {\n    type: AST_NODE_TYPES.TSExternalModuleReference;\n    expression: StringLiteral;\n}\ndeclare interface TSFunctionSignatureBase extends BaseNode {\n    params: Parameter[];\n    returnType: TSTypeAnnotation | undefined;\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare interface TSFunctionType extends TSFunctionSignatureBase {\n    type: AST_NODE_TYPES.TSFunctionType;\n}\ndeclare interface TSHeritageBase extends BaseNode {\n    expression: Expression;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n}\nexport declare type TSImportEqualsDeclaration = TSImportEqualsNamespaceDeclaration | TSImportEqualsRequireDeclaration;\ndeclare interface TSImportEqualsDeclarationBase extends BaseNode {\n    type: AST_NODE_TYPES.TSImportEqualsDeclaration;\n    /**\n     * The locally imported name.\n     */\n    id: Identifier;\n    /**\n     * The kind of the import. Always `'value'` unless `moduleReference` is a\n     * `TSExternalModuleReference`.\n     */\n    importKind: ImportKind;\n    /**\n     * The value being aliased.\n     * @example\n     * ```ts\n     * import F1 = A;\n     * import F2 = A.B.C;\n     * import F3 = require('mod');\n     * ```\n     */\n    moduleReference: Identifier | TSExternalModuleReference | TSQualifiedName;\n}\nexport declare interface TSImportEqualsNamespaceDeclaration extends TSImportEqualsDeclarationBase {\n    /**\n     * The kind of the import.\n     */\n    importKind: 'value';\n    /**\n     * The value being aliased.\n     * ```\n     * import F1 = A;\n     * import F2 = A.B.C;\n     * ```\n     */\n    moduleReference: Identifier | TSQualifiedName;\n}\nexport declare interface TSImportEqualsRequireDeclaration extends TSImportEqualsDeclarationBase {\n    /**\n     * The kind of the import.\n     */\n    importKind: ImportKind;\n    /**\n     * The value being aliased.\n     * ```\n     * import F3 = require('mod');\n     * ```\n     */\n    moduleReference: TSExternalModuleReference;\n}\nexport declare interface TSImportType extends BaseNode {\n    type: AST_NODE_TYPES.TSImportType;\n    argument: TypeNode;\n    options: ObjectExpression | null;\n    qualifier: EntityName | null;\n    typeArguments: TSTypeParameterInstantiation | null;\n}\nexport declare interface TSIndexedAccessType extends BaseNode {\n    type: AST_NODE_TYPES.TSIndexedAccessType;\n    indexType: TypeNode;\n    objectType: TypeNode;\n}\nexport declare interface TSIndexSignature extends BaseNode {\n    type: AST_NODE_TYPES.TSIndexSignature;\n    accessibility: Accessibility | undefined;\n    parameters: Parameter[];\n    readonly: boolean;\n    static: boolean;\n    typeAnnotation: TSTypeAnnotation | undefined;\n}\nexport declare interface TSInferType extends BaseNode {\n    type: AST_NODE_TYPES.TSInferType;\n    typeParameter: TSTypeParameter;\n}\nexport declare interface TSInstantiationExpression extends BaseNode {\n    type: AST_NODE_TYPES.TSInstantiationExpression;\n    expression: Expression;\n    typeArguments: TSTypeParameterInstantiation;\n}\nexport declare interface TSInterfaceBody extends BaseNode {\n    type: AST_NODE_TYPES.TSInterfaceBody;\n    body: TypeElement[];\n}\nexport declare interface TSInterfaceDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.TSInterfaceDeclaration;\n    /**\n     * The body of the interface\n     */\n    body: TSInterfaceBody;\n    /**\n     * Whether the interface was `declare`d\n     */\n    declare: boolean;\n    /**\n     * The types this interface `extends`\n     */\n    extends: TSInterfaceHeritage[];\n    /**\n     * The name of this interface\n     */\n    id: Identifier;\n    /**\n     * The generic type parameters declared for the interface. Empty declaration\n     * (`<>`) is different from no declaration.\n     */\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare interface TSInterfaceHeritage extends TSHeritageBase {\n    type: AST_NODE_TYPES.TSInterfaceHeritage;\n}\nexport declare interface TSIntersectionType extends BaseNode {\n    type: AST_NODE_TYPES.TSIntersectionType;\n    types: TypeNode[];\n}\nexport declare interface TSIntrinsicKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSIntrinsicKeyword;\n}\nexport declare interface TSLiteralType extends BaseNode {\n    type: AST_NODE_TYPES.TSLiteralType;\n    literal: LiteralExpression | UnaryExpression | UpdateExpression;\n}\nexport declare interface TSMappedType extends BaseNode {\n    type: AST_NODE_TYPES.TSMappedType;\n    constraint: TypeNode;\n    key: Identifier;\n    nameType: TypeNode | null;\n    optional: boolean | '+' | '-' | undefined;\n    readonly: boolean | '+' | '-' | undefined;\n    typeAnnotation: TypeNode | undefined;\n    /** @deprecated Use {@link `constraint`} and {@link `key`} instead. */\n    typeParameter: TSTypeParameter;\n}\nexport declare type TSMethodSignature = TSMethodSignatureComputedName | TSMethodSignatureNonComputedName;\ndeclare interface TSMethodSignatureBase extends BaseNode {\n    type: AST_NODE_TYPES.TSMethodSignature;\n    accessibility: Accessibility | undefined;\n    computed: boolean;\n    key: PropertyName;\n    kind: 'get' | 'method' | 'set';\n    optional: boolean;\n    params: Parameter[];\n    readonly: boolean;\n    returnType: TSTypeAnnotation | undefined;\n    static: boolean;\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare interface TSMethodSignatureComputedName extends TSMethodSignatureBase {\n    computed: true;\n    key: PropertyNameComputed;\n}\nexport declare interface TSMethodSignatureNonComputedName extends TSMethodSignatureBase {\n    computed: false;\n    key: PropertyNameNonComputed;\n}\nexport declare interface TSModuleBlock extends BaseNode {\n    type: AST_NODE_TYPES.TSModuleBlock;\n    body: ProgramStatement[];\n}\nexport declare type TSModuleDeclaration = TSModuleDeclarationGlobal | TSModuleDeclarationModule | TSModuleDeclarationNamespace;\ndeclare interface TSModuleDeclarationBase extends BaseNode {\n    type: AST_NODE_TYPES.TSModuleDeclaration;\n    /**\n     * The body of the module.\n     * This can only be `undefined` for the code `declare module 'mod';`\n     */\n    body?: TSModuleBlock;\n    /**\n     * Whether the module is `declare`d\n     * @example\n     * ```ts\n     * declare namespace F {}\n     * ```\n     */\n    declare: boolean;\n    /**\n     * Whether this is a global declaration\n     * @example\n     * ```ts\n     * declare global {}\n     * ```\n     *\n     * @deprecated Use {@link kind} instead\n     */\n    global: boolean;\n    /**\n     * The name of the module\n     * ```\n     * namespace A {}\n     * namespace A.B.C {}\n     * module 'a' {}\n     * ```\n     */\n    id: Identifier | Literal | TSQualifiedName;\n    /**\n     * The keyword used to define this module declaration\n     * @example\n     * ```ts\n     * namespace Foo {}\n     * ^^^^^^^^^\n     *\n     * module 'foo' {}\n     * ^^^^^^\n     *\n     * global {}\n     * ^^^^^^\n     * ```\n     */\n    kind: TSModuleDeclarationKind;\n}\nexport declare interface TSModuleDeclarationGlobal extends TSModuleDeclarationBase {\n    body: TSModuleBlock;\n    /**\n     * This will always be an Identifier with name `global`\n     */\n    id: Identifier;\n    kind: 'global';\n}\nexport declare type TSModuleDeclarationKind = 'global' | 'module' | 'namespace';\nexport declare type TSModuleDeclarationModule = TSModuleDeclarationModuleWithIdentifierId | TSModuleDeclarationModuleWithStringId;\ndeclare interface TSModuleDeclarationModuleBase extends TSModuleDeclarationBase {\n    kind: 'module';\n}\n/**\n * The legacy module declaration, replaced with namespace declarations.\n * ```\n * module A {}\n * ```\n */\nexport declare interface TSModuleDeclarationModuleWithIdentifierId extends TSModuleDeclarationModuleBase {\n    body: TSModuleBlock;\n    id: Identifier;\n    kind: 'module';\n}\nexport declare type TSModuleDeclarationModuleWithStringId = TSModuleDeclarationModuleWithStringIdDeclared | TSModuleDeclarationModuleWithStringIdNotDeclared;\n/**\n * A string module declaration that is declared:\n * ```\n * declare module 'foo' {}\n * declare module 'foo';\n * ```\n */\nexport declare interface TSModuleDeclarationModuleWithStringIdDeclared extends TSModuleDeclarationModuleBase {\n    body?: TSModuleBlock;\n    declare: true;\n    id: StringLiteral;\n    kind: 'module';\n}\n/**\n * A string module declaration that is not declared:\n * ```\n * module 'foo' {}\n * ```\n */\nexport declare interface TSModuleDeclarationModuleWithStringIdNotDeclared extends TSModuleDeclarationModuleBase {\n    body: TSModuleBlock;\n    declare: false;\n    id: StringLiteral;\n    kind: 'module';\n}\nexport declare interface TSModuleDeclarationNamespace extends TSModuleDeclarationBase {\n    body: TSModuleBlock;\n    id: Identifier | TSQualifiedName;\n    kind: 'namespace';\n}\nexport declare interface TSNamedTupleMember extends BaseNode {\n    type: AST_NODE_TYPES.TSNamedTupleMember;\n    elementType: TypeNode;\n    label: Identifier;\n    optional: boolean;\n}\n/**\n * For the following declaration:\n * ```\n * export as namespace X;\n * ```\n */\nexport declare interface TSNamespaceExportDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.TSNamespaceExportDeclaration;\n    /**\n     * The name of the global variable that's exported as namespace\n     */\n    id: Identifier;\n}\nexport declare interface TSNeverKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSNeverKeyword;\n}\nexport declare interface TSNonNullExpression extends BaseNode {\n    type: AST_NODE_TYPES.TSNonNullExpression;\n    expression: Expression;\n}\nexport declare interface TSNullKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSNullKeyword;\n}\nexport declare interface TSNumberKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSNumberKeyword;\n}\nexport declare interface TSObjectKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSObjectKeyword;\n}\nexport declare interface TSOptionalType extends BaseNode {\n    type: AST_NODE_TYPES.TSOptionalType;\n    typeAnnotation: TypeNode;\n}\nexport declare interface TSParameterProperty extends BaseNode {\n    type: AST_NODE_TYPES.TSParameterProperty;\n    accessibility: Accessibility | undefined;\n    decorators: Decorator[];\n    override: boolean;\n    parameter: AssignmentPattern | BindingName | RestElement;\n    readonly: boolean;\n    static: boolean;\n}\nexport declare interface TSPrivateKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSPrivateKeyword;\n}\nexport declare type TSPropertySignature = TSPropertySignatureComputedName | TSPropertySignatureNonComputedName;\ndeclare interface TSPropertySignatureBase extends BaseNode {\n    type: AST_NODE_TYPES.TSPropertySignature;\n    accessibility: Accessibility | undefined;\n    computed: boolean;\n    key: PropertyName;\n    optional: boolean;\n    readonly: boolean;\n    static: boolean;\n    typeAnnotation: TSTypeAnnotation | undefined;\n}\nexport declare interface TSPropertySignatureComputedName extends TSPropertySignatureBase {\n    computed: true;\n    key: PropertyNameComputed;\n}\nexport declare interface TSPropertySignatureNonComputedName extends TSPropertySignatureBase {\n    computed: false;\n    key: PropertyNameNonComputed;\n}\nexport declare interface TSProtectedKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSProtectedKeyword;\n}\nexport declare interface TSPublicKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSPublicKeyword;\n}\nexport declare interface TSQualifiedName extends BaseNode {\n    type: AST_NODE_TYPES.TSQualifiedName;\n    left: EntityName;\n    right: Identifier;\n}\nexport declare interface TSReadonlyKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSReadonlyKeyword;\n}\nexport declare interface TSRestType extends BaseNode {\n    type: AST_NODE_TYPES.TSRestType;\n    typeAnnotation: TypeNode;\n}\nexport declare interface TSSatisfiesExpression extends BaseNode {\n    type: AST_NODE_TYPES.TSSatisfiesExpression;\n    expression: Expression;\n    typeAnnotation: TypeNode;\n}\nexport declare interface TSStaticKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSStaticKeyword;\n}\nexport declare interface TSStringKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSStringKeyword;\n}\nexport declare interface TSSymbolKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSSymbolKeyword;\n}\nexport declare interface TSTemplateLiteralType extends BaseNode {\n    type: AST_NODE_TYPES.TSTemplateLiteralType;\n    quasis: TemplateElement[];\n    types: TypeNode[];\n}\nexport declare interface TSThisType extends BaseNode {\n    type: AST_NODE_TYPES.TSThisType;\n}\nexport declare interface TSTupleType extends BaseNode {\n    type: AST_NODE_TYPES.TSTupleType;\n    elementTypes: TypeNode[];\n}\nexport declare interface TSTypeAliasDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeAliasDeclaration;\n    /**\n     * Whether the type was `declare`d.\n     * @example\n     * ```ts\n     * declare type T = 1;\n     * ```\n     */\n    declare: boolean;\n    /**\n     * The name of the type.\n     */\n    id: Identifier;\n    /**\n     * The \"value\" (type) of the declaration\n     */\n    typeAnnotation: TypeNode;\n    /**\n     * The generic type parameters declared for the type. Empty declaration\n     * (`<>`) is different from no declaration.\n     */\n    typeParameters: TSTypeParameterDeclaration | undefined;\n}\nexport declare interface TSTypeAnnotation extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeAnnotation;\n    typeAnnotation: TypeNode;\n}\nexport declare interface TSTypeAssertion extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeAssertion;\n    expression: Expression;\n    typeAnnotation: TypeNode;\n}\nexport declare interface TSTypeLiteral extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeLiteral;\n    members: TypeElement[];\n}\nexport declare interface TSTypeOperator extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeOperator;\n    operator: 'keyof' | 'readonly' | 'unique';\n    typeAnnotation: TypeNode | undefined;\n}\nexport declare interface TSTypeParameter extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeParameter;\n    const: boolean;\n    constraint: TypeNode | undefined;\n    default: TypeNode | undefined;\n    in: boolean;\n    name: Identifier;\n    out: boolean;\n}\nexport declare interface TSTypeParameterDeclaration extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeParameterDeclaration;\n    params: TSTypeParameter[];\n}\nexport declare interface TSTypeParameterInstantiation extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeParameterInstantiation;\n    params: TypeNode[];\n}\nexport declare interface TSTypePredicate extends BaseNode {\n    type: AST_NODE_TYPES.TSTypePredicate;\n    asserts: boolean;\n    parameterName: Identifier | TSThisType;\n    typeAnnotation: TSTypeAnnotation | null;\n}\nexport declare interface TSTypeQuery extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeQuery;\n    exprName: EntityName | TSImportType;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n}\nexport declare interface TSTypeReference extends BaseNode {\n    type: AST_NODE_TYPES.TSTypeReference;\n    typeArguments: TSTypeParameterInstantiation | undefined;\n    typeName: EntityName;\n}\nexport declare type TSUnaryExpression = AwaitExpression | LeftHandSideExpression | UnaryExpression | UpdateExpression;\nexport declare interface TSUndefinedKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSUndefinedKeyword;\n}\nexport declare interface TSUnionType extends BaseNode {\n    type: AST_NODE_TYPES.TSUnionType;\n    types: TypeNode[];\n}\nexport declare interface TSUnknownKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSUnknownKeyword;\n}\nexport declare interface TSVoidKeyword extends BaseNode {\n    type: AST_NODE_TYPES.TSVoidKeyword;\n}\nexport declare type TypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSIndexSignature | TSMethodSignature | TSPropertySignature;\nexport declare type TypeNode = TSAbstractKeyword | TSAnyKeyword | TSArrayType | TSAsyncKeyword | TSBigIntKeyword | TSBooleanKeyword | TSConditionalType | TSConstructorType | TSDeclareKeyword | TSExportKeyword | TSFunctionType | TSImportType | TSIndexedAccessType | TSInferType | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSNamedTupleMember | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSPrivateKeyword | TSProtectedKeyword | TSPublicKeyword | TSQualifiedName | TSReadonlyKeyword | TSRestType | TSStaticKeyword | TSStringKeyword | TSSymbolKeyword | TSTemplateLiteralType | TSThisType | TSTupleType | TSTypeLiteral | TSTypeOperator | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword;\nexport declare interface UnaryExpression extends UnaryExpressionBase {\n    type: AST_NODE_TYPES.UnaryExpression;\n    operator: '!' | '+' | '~' | '-' | 'delete' | 'typeof' | 'void';\n}\ndeclare interface UnaryExpressionBase extends BaseNode {\n    argument: Expression;\n    operator: string;\n    prefix: boolean;\n}\nexport declare interface UpdateExpression extends UnaryExpressionBase {\n    type: AST_NODE_TYPES.UpdateExpression;\n    operator: '++' | '--';\n}\nexport declare type UsingDeclaration = UsingInForOfDeclaration | UsingInNormalContextDeclaration;\ndeclare interface UsingDeclarationBase extends BaseNode {\n    type: AST_NODE_TYPES.VariableDeclaration;\n    /**\n     * This value will always be `false`\n     * because 'declare' modifier cannot appear on a 'using' declaration.\n     */\n    declare: false;\n    /**\n     * The keyword used to declare the variable(s)\n     * @example\n     * ```ts\n     * using x = 1;\n     * await using y = 2;\n     * ```\n     */\n    kind: 'await using' | 'using';\n}\nexport declare type UsingDeclarator = UsingInForOfDeclarator | UsingInNormalContextDeclarator;\nexport declare interface UsingInForOfDeclaration extends UsingDeclarationBase {\n    /**\n     * The variables declared by this declaration.\n     * Always has exactly one element.\n     * @example\n     * ```ts\n     * for (using x of y) {}\n     * ```\n     */\n    declarations: [UsingInForOfDeclarator];\n}\nexport declare interface UsingInForOfDeclarator extends VariableDeclaratorBase {\n    definite: false;\n    id: Identifier;\n    init: null;\n}\nexport declare interface UsingInNormalContextDeclaration extends UsingDeclarationBase {\n    /**\n     * The variables declared by this declaration.\n     * Always non-empty.\n     * @example\n     * ```ts\n     * using x = 1;\n     * using y = 1, z = 2;\n     * ```\n     */\n    declarations: UsingInNormalContextDeclarator[];\n}\nexport declare interface UsingInNormalContextDeclarator extends VariableDeclaratorBase {\n    definite: false;\n    id: Identifier;\n    init: Expression;\n}\ndeclare type ValueOf<T> = T[keyof T];\nexport declare type VariableDeclaration = LetOrConstOrVarDeclaration | UsingDeclaration;\nexport declare type VariableDeclarator = LetOrConstOrVarDeclarator | UsingDeclarator;\ndeclare interface VariableDeclaratorBase extends BaseNode {\n    type: AST_NODE_TYPES.VariableDeclarator;\n    /**\n     * Whether there's definite assignment assertion (`let x!: number`).\n     * If `true`, then: `id` must be an identifier with a type annotation,\n     * `init` must be `null`, and the declarator must be a `var`/`let` declarator.\n     */\n    definite: boolean;\n    /**\n     * The name(s) of the variable(s).\n     */\n    id: BindingName;\n    /**\n     * The initializer expression of the variable. Must be present for `const` unless\n     * in a `declare const`.\n     */\n    init: Expression | null;\n}\nexport declare interface VariableDeclaratorDefiniteAssignment extends VariableDeclaratorBase {\n    definite: true;\n    /**\n     * The name of the variable. Must have a type annotation.\n     */\n    id: Identifier;\n    init: null;\n}\nexport declare interface VariableDeclaratorMaybeInit extends VariableDeclaratorBase {\n    definite: false;\n}\nexport declare interface VariableDeclaratorNoInit extends VariableDeclaratorBase {\n    definite: false;\n    init: null;\n}\nexport declare interface WhileStatement extends BaseNode {\n    type: AST_NODE_TYPES.WhileStatement;\n    body: Statement;\n    test: Expression;\n}\nexport declare interface WithStatement extends BaseNode {\n    type: AST_NODE_TYPES.WithStatement;\n    body: Statement;\n    object: Expression;\n}\nexport declare interface YieldExpression extends BaseNode {\n    type: AST_NODE_TYPES.YieldExpression;\n    argument: Expression | null;\n    delegate: boolean;\n}\nexport {};\n//# sourceMappingURL=ast-spec.d.ts.map"
        }
    ]
}