{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/ScopeManager.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891995651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { SourceType, TSESTree } from '@typescript-eslint/types';\nimport type { Scope } from './scope';\nimport type { Variable } from './variable';\nimport { BlockScope, CatchScope, ClassScope, ConditionalTypeScope, ForScope, FunctionExpressionNameScope, FunctionScope, FunctionTypeScope, GlobalScope, MappedTypeScope, ModuleScope, SwitchScope, TSEnumScope, TSModuleScope, TypeScope, WithScope } from './scope';\nimport { ClassFieldInitializerScope } from './scope/ClassFieldInitializerScope';\nimport { ClassStaticBlockScope } from './scope/ClassStaticBlockScope';\ninterface ScopeManagerOptions {\n    globalReturn?: boolean;\n    impliedStrict?: boolean;\n    sourceType?: SourceType;\n}\n/**\n * @see https://eslint.org/docs/latest/developer-guide/scope-manager-interface#scopemanager-interface\n */\nexport declare class ScopeManager {\n    #private;\n    currentScope: Scope | null;\n    readonly declaredVariables: WeakMap<TSESTree.Node, Variable[]>;\n    /**\n     * The root scope\n     */\n    globalScope: GlobalScope | null;\n    readonly nodeToScope: WeakMap<TSESTree.Node, Scope[]>;\n    /**\n     * All scopes\n     * @public\n     */\n    readonly scopes: Scope[];\n    constructor(options: ScopeManagerOptions);\n    isES6(): boolean;\n    isGlobalReturn(): boolean;\n    isImpliedStrict(): boolean;\n    isModule(): boolean;\n    isStrictModeSupported(): boolean;\n    get variables(): Variable[];\n    /**\n     * Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node.\n     * If the node does not define any variable, this returns an empty array.\n     * @param node An AST node to get their variables.\n     */\n    getDeclaredVariables(node: TSESTree.Node): Variable[];\n    /**\n     * Get the scope of a given AST node. The gotten scope's `block` property is the node.\n     * This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`.\n     *\n     * @param node An AST node to get their scope.\n     * @param inner If the node has multiple scopes, this returns the outermost scope normally.\n     *                If `inner` is `true` then this returns the innermost scope.\n     */\n    acquire(node: TSESTree.Node, inner?: boolean): Scope | null;\n    nestBlockScope(node: BlockScope['block']): BlockScope;\n    nestCatchScope(node: CatchScope['block']): CatchScope;\n    nestClassFieldInitializerScope(node: ClassFieldInitializerScope['block']): ClassFieldInitializerScope;\n    nestClassScope(node: ClassScope['block']): ClassScope;\n    nestClassStaticBlockScope(node: ClassStaticBlockScope['block']): ClassStaticBlockScope;\n    nestConditionalTypeScope(node: ConditionalTypeScope['block']): ConditionalTypeScope;\n    nestForScope(node: ForScope['block']): ForScope;\n    nestFunctionExpressionNameScope(node: FunctionExpressionNameScope['block']): FunctionExpressionNameScope;\n    nestFunctionScope(node: FunctionScope['block'], isMethodDefinition: boolean): FunctionScope;\n    nestFunctionTypeScope(node: FunctionTypeScope['block']): FunctionTypeScope;\n    nestGlobalScope(node: GlobalScope['block']): GlobalScope;\n    nestMappedTypeScope(node: MappedTypeScope['block']): MappedTypeScope;\n    nestModuleScope(node: ModuleScope['block']): ModuleScope;\n    nestSwitchScope(node: SwitchScope['block']): SwitchScope;\n    nestTSEnumScope(node: TSEnumScope['block']): TSEnumScope;\n    nestTSModuleScope(node: TSModuleScope['block']): TSModuleScope;\n    nestTypeScope(node: TypeScope['block']): TypeScope;\n    nestWithScope(node: WithScope['block']): WithScope;\n    protected nestScope<T extends Scope>(scope: T): T;\n}\nexport {};\n//# sourceMappingURL=ScopeManager.d.ts.map"
        }
    ]
}