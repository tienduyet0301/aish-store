{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeBase.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891994867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScopeBase = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst assert_1 = require(\"../assert\");\nconst definition_1 = require(\"../definition\");\nconst ID_1 = require(\"../ID\");\nconst Reference_1 = require(\"../referencer/Reference\");\nconst variable_1 = require(\"../variable\");\nconst ScopeType_1 = require(\"./ScopeType\");\n/**\n * Test if scope is strict\n */\nfunction isStrictScope(scope, block, isMethodDefinition) {\n    let body;\n    // When upper scope is exists and strict, inner scope is also strict.\n    if (scope.upper?.isStrict) {\n        return true;\n    }\n    if (isMethodDefinition) {\n        return true;\n    }\n    if (scope.type === ScopeType_1.ScopeType.class ||\n        scope.type === ScopeType_1.ScopeType.conditionalType ||\n        scope.type === ScopeType_1.ScopeType.functionType ||\n        scope.type === ScopeType_1.ScopeType.mappedType ||\n        scope.type === ScopeType_1.ScopeType.module ||\n        scope.type === ScopeType_1.ScopeType.tsEnum ||\n        scope.type === ScopeType_1.ScopeType.tsModule ||\n        scope.type === ScopeType_1.ScopeType.type) {\n        return true;\n    }\n    if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) {\n        return false;\n    }\n    if (scope.type === ScopeType_1.ScopeType.function) {\n        const functionBody = block;\n        switch (functionBody.type) {\n            case types_1.AST_NODE_TYPES.ArrowFunctionExpression:\n                if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {\n                    return false;\n                }\n                body = functionBody.body;\n                break;\n            case types_1.AST_NODE_TYPES.Program:\n                body = functionBody;\n                break;\n            default:\n                body = functionBody.body;\n        }\n        if (!body) {\n            return false;\n        }\n    }\n    else if (scope.type === ScopeType_1.ScopeType.global) {\n        body = block;\n    }\n    else {\n        return false;\n    }\n    // Search 'use strict' directive.\n    for (const stmt of body.body) {\n        if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {\n            break;\n        }\n        if (stmt.directive === 'use strict') {\n            return true;\n        }\n        const expr = stmt.expression;\n        if (expr.type !== types_1.AST_NODE_TYPES.Literal) {\n            break;\n        }\n        if (expr.raw === '\"use strict\"' || expr.raw === \"'use strict'\") {\n            return true;\n        }\n        if (expr.value === 'use strict') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction registerScope(scopeManager, scope) {\n    scopeManager.scopes.push(scope);\n    const scopes = scopeManager.nodeToScope.get(scope.block);\n    if (scopes) {\n        scopes.push(scope);\n    }\n    else {\n        scopeManager.nodeToScope.set(scope.block, [scope]);\n    }\n}\nconst generator = (0, ID_1.createIdGenerator)();\nconst VARIABLE_SCOPE_TYPES = new Set([\n    ScopeType_1.ScopeType.classFieldInitializer,\n    ScopeType_1.ScopeType.classStaticBlock,\n    ScopeType_1.ScopeType.function,\n    ScopeType_1.ScopeType.global,\n    ScopeType_1.ScopeType.module,\n    ScopeType_1.ScopeType.tsModule,\n]);\nclass ScopeBase {\n    /**\n     * A unique ID for this instance - primarily used to help debugging and testing\n     */\n    $id = generator();\n    /**\n     * The AST node which created this scope.\n     * @public\n     */\n    block;\n    /**\n     * The array of child scopes. This does not include grandchild scopes.\n     * @public\n     */\n    childScopes = [];\n    /**\n     * A map of the variables for each node in this scope.\n     * This is map is a pointer to the one in the parent ScopeManager instance\n     */\n    #declaredVariables;\n    /**\n     * Generally, through the lexical scoping of JS you can always know which variable an identifier in the source code\n     * refers to. There are a few exceptions to this rule. With `global` and `with` scopes you can only decide at runtime\n     * which variable a reference refers to.\n     * All those scopes are considered \"dynamic\".\n     */\n    #dynamic;\n    /**\n     * Whether this scope is created by a FunctionExpression.\n     * @public\n     */\n    functionExpressionScope = false;\n    /**\n     * Whether 'use strict' is in effect in this scope.\n     * @public\n     */\n    isStrict;\n    /**\n     * List of {@link Reference}s that are left to be resolved (i.e. which\n     * need to be linked to the variable they refer to).\n     */\n    leftToResolve = [];\n    /**\n     * Any variable {@link Reference} found in this scope.\n     * This includes occurrences of local variables as well as variables from parent scopes (including the global scope).\n     * For local variables this also includes defining occurrences (like in a 'var' statement).\n     * In a 'function' scope this does not include the occurrences of the formal parameter in the parameter list.\n     * @public\n     */\n    references = [];\n    /**\n     * The map from variable names to variable objects.\n     * @public\n     */\n    set = new Map();\n    /**\n     * The {@link Reference}s that are not resolved with this scope.\n     * @public\n     */\n    through = [];\n    type;\n    /**\n     * Reference to the parent {@link Scope}.\n     * @public\n     */\n    upper;\n    /**\n     * The scoped {@link Variable}s of this scope.\n     * In the case of a 'function' scope this includes the automatic argument `arguments` as its first element, as well\n     * as all further formal arguments.\n     * This does not include variables which are defined in child scopes.\n     * @public\n     */\n    variables = [];\n    /**\n     * For scopes that can contain variable declarations, this is a self-reference.\n     * For other scope types this is the *variableScope* value of the parent scope.\n     * @public\n     */\n    #dynamicCloseRef = (ref) => {\n        // notify all names are through to global\n        let current = this;\n        do {\n            /* eslint-disable @typescript-eslint/no-non-null-assertion */\n            current.through.push(ref);\n            current = current.upper;\n            /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        } while (current);\n    };\n    #globalCloseRef = (ref, scopeManager) => {\n        // let/const/class declarations should be resolved statically.\n        // others should be resolved dynamically.\n        if (this.shouldStaticallyCloseForGlobal(ref, scopeManager)) {\n            this.#staticCloseRef(ref);\n        }\n        else {\n            this.#dynamicCloseRef(ref);\n        }\n    };\n    #staticCloseRef = (ref) => {\n        const resolve = () => {\n            const name = ref.identifier.name;\n            const variable = this.set.get(name);\n            if (!variable) {\n                return false;\n            }\n            if (!this.isValidResolution(ref, variable)) {\n                return false;\n            }\n            // make sure we don't match a type reference to a value variable\n            const isValidTypeReference = ref.isTypeReference && variable.isTypeVariable;\n            const isValidValueReference = ref.isValueReference && variable.isValueVariable;\n            if (!isValidTypeReference && !isValidValueReference) {\n                return false;\n            }\n            variable.references.push(ref);\n            ref.resolved = variable;\n            return true;\n        };\n        if (!resolve()) {\n            this.delegateToUpperScope(ref);\n        }\n    };\n    variableScope;\n    constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n        const upperScopeAsScopeBase = upperScope;\n        this.type = type;\n        this.#dynamic =\n            this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with;\n        this.block = block;\n        this.variableScope = this.isVariableScope()\n            ? this\n            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                upperScopeAsScopeBase.variableScope;\n        this.upper = upperScope;\n        /**\n         * Whether 'use strict' is in effect in this scope.\n         * @member {boolean} Scope#isStrict\n         */\n        this.isStrict = isStrictScope(this, block, isMethodDefinition);\n        // this is guaranteed to be correct at runtime\n        upperScopeAsScopeBase?.childScopes.push(this);\n        this.#declaredVariables = scopeManager.declaredVariables;\n        registerScope(scopeManager, this);\n    }\n    isVariableScope() {\n        return VARIABLE_SCOPE_TYPES.has(this.type);\n    }\n    shouldStaticallyCloseForGlobal(ref, scopeManager) {\n        // On global scope, let/const/class declarations should be resolved statically.\n        const name = ref.identifier.name;\n        const variable = this.set.get(name);\n        if (!variable) {\n            return false;\n        }\n        // variable exists on the scope\n        // in module mode, we can statically resolve everything, regardless of its decl type\n        if (scopeManager.isModule()) {\n            return true;\n        }\n        // in script mode, only certain cases should be statically resolved\n        // Example:\n        // a `var` decl is ignored by the runtime if it clashes with a global name\n        // this means that we should not resolve the reference to the variable\n        const defs = variable.defs;\n        return (defs.length > 0 &&\n            defs.every(def => {\n                if (def.type === definition_1.DefinitionType.Variable && def.parent.kind === 'var') {\n                    return false;\n                }\n                return true;\n            }));\n    }\n    close(scopeManager) {\n        let closeRef;\n        if (this.shouldStaticallyClose()) {\n            closeRef = this.#staticCloseRef;\n        }\n        else if (this.type !== 'global') {\n            closeRef = this.#dynamicCloseRef;\n        }\n        else {\n            closeRef = this.#globalCloseRef;\n        }\n        // Try Resolving all references in this scope.\n        (0, assert_1.assert)(this.leftToResolve);\n        this.leftToResolve.forEach(ref => closeRef(ref, scopeManager));\n        this.leftToResolve = null;\n        return this.upper;\n    }\n    shouldStaticallyClose() {\n        return !this.#dynamic;\n    }\n    /**\n     * To override by function scopes.\n     * References in default parameters isn't resolved to variables which are in their function body.\n     */\n    defineVariable(nameOrVariable, set, variables, node, def) {\n        const name = typeof nameOrVariable === 'string' ? nameOrVariable : nameOrVariable.name;\n        let variable = set.get(name);\n        if (!variable) {\n            variable =\n                typeof nameOrVariable === 'string'\n                    ? new variable_1.Variable(name, this)\n                    : nameOrVariable;\n            set.set(name, variable);\n            variables.push(variable);\n        }\n        if (def) {\n            variable.defs.push(def);\n            this.addDeclaredVariablesOfNode(variable, def.node);\n            this.addDeclaredVariablesOfNode(variable, def.parent);\n        }\n        if (node) {\n            variable.identifiers.push(node);\n        }\n    }\n    delegateToUpperScope(ref) {\n        this.upper?.leftToResolve?.push(ref);\n        this.through.push(ref);\n    }\n    isValidResolution(_ref, _variable) {\n        return true;\n    }\n    addDeclaredVariablesOfNode(variable, node) {\n        if (node == null) {\n            return;\n        }\n        let variables = this.#declaredVariables.get(node);\n        if (variables == null) {\n            variables = [];\n            this.#declaredVariables.set(node, variables);\n        }\n        if (!variables.includes(variable)) {\n            variables.push(variable);\n        }\n    }\n    defineIdentifier(node, def) {\n        this.defineVariable(node.name, this.set, this.variables, node, def);\n    }\n    defineLiteralIdentifier(node, def) {\n        this.defineVariable(node.value, this.set, this.variables, null, def);\n    }\n    referenceDualValueType(node) {\n        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);\n        this.references.push(ref);\n        this.leftToResolve?.push(ref);\n    }\n    referenceType(node) {\n        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);\n        this.references.push(ref);\n        this.leftToResolve?.push(ref);\n    }\n    referenceValue(node, assign = Reference_1.ReferenceFlag.Read, writeExpr, maybeImplicitGlobal, init = false) {\n        const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);\n        this.references.push(ref);\n        this.leftToResolve?.push(ref);\n    }\n}\nexports.ScopeBase = ScopeBase;\n"
        }
    ]
}