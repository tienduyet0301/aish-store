{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/ScopeManager.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891996222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScopeManager = void 0;\nconst assert_1 = require(\"./assert\");\nconst scope_1 = require(\"./scope\");\nconst ClassFieldInitializerScope_1 = require(\"./scope/ClassFieldInitializerScope\");\nconst ClassStaticBlockScope_1 = require(\"./scope/ClassStaticBlockScope\");\n/**\n * @see https://eslint.org/docs/latest/developer-guide/scope-manager-interface#scopemanager-interface\n */\nclass ScopeManager {\n    #options;\n    currentScope;\n    declaredVariables;\n    /**\n     * The root scope\n     */\n    globalScope;\n    nodeToScope;\n    /**\n     * All scopes\n     * @public\n     */\n    scopes;\n    constructor(options) {\n        this.scopes = [];\n        this.globalScope = null;\n        this.nodeToScope = new WeakMap();\n        this.currentScope = null;\n        this.#options = options;\n        this.declaredVariables = new WeakMap();\n    }\n    isES6() {\n        return true;\n    }\n    isGlobalReturn() {\n        return this.#options.globalReturn === true;\n    }\n    isImpliedStrict() {\n        return this.#options.impliedStrict === true;\n    }\n    isModule() {\n        return this.#options.sourceType === 'module';\n    }\n    isStrictModeSupported() {\n        return true;\n    }\n    get variables() {\n        const variables = new Set();\n        function recurse(scope) {\n            scope.variables.forEach(v => variables.add(v));\n            scope.childScopes.forEach(recurse);\n        }\n        this.scopes.forEach(recurse);\n        return [...variables].sort((a, b) => a.$id - b.$id);\n    }\n    /**\n     * Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node.\n     * If the node does not define any variable, this returns an empty array.\n     * @param node An AST node to get their variables.\n     */\n    getDeclaredVariables(node) {\n        return this.declaredVariables.get(node) ?? [];\n    }\n    /**\n     * Get the scope of a given AST node. The gotten scope's `block` property is the node.\n     * This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`.\n     *\n     * @param node An AST node to get their scope.\n     * @param inner If the node has multiple scopes, this returns the outermost scope normally.\n     *                If `inner` is `true` then this returns the innermost scope.\n     */\n    acquire(node, inner = false) {\n        function predicate(testScope) {\n            if (testScope.type === scope_1.ScopeType.function &&\n                testScope.functionExpressionScope) {\n                return false;\n            }\n            return true;\n        }\n        const scopes = this.nodeToScope.get(node);\n        if (!scopes || scopes.length === 0) {\n            return null;\n        }\n        // Heuristic selection from all scopes.\n        // If you would like to get all scopes, please use ScopeManager#acquireAll.\n        if (scopes.length === 1) {\n            return scopes[0];\n        }\n        if (inner) {\n            for (let i = scopes.length - 1; i >= 0; --i) {\n                const scope = scopes[i];\n                if (predicate(scope)) {\n                    return scope;\n                }\n            }\n            return null;\n        }\n        return scopes.find(predicate) ?? null;\n    }\n    nestBlockScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.BlockScope(this, this.currentScope, node));\n    }\n    nestCatchScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.CatchScope(this, this.currentScope, node));\n    }\n    nestClassFieldInitializerScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new ClassFieldInitializerScope_1.ClassFieldInitializerScope(this, this.currentScope, node));\n    }\n    nestClassScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.ClassScope(this, this.currentScope, node));\n    }\n    nestClassStaticBlockScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new ClassStaticBlockScope_1.ClassStaticBlockScope(this, this.currentScope, node));\n    }\n    nestConditionalTypeScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.ConditionalTypeScope(this, this.currentScope, node));\n    }\n    nestForScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.ForScope(this, this.currentScope, node));\n    }\n    nestFunctionExpressionNameScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.FunctionExpressionNameScope(this, this.currentScope, node));\n    }\n    nestFunctionScope(node, isMethodDefinition) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.FunctionScope(this, this.currentScope, node, isMethodDefinition));\n    }\n    nestFunctionTypeScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.FunctionTypeScope(this, this.currentScope, node));\n    }\n    nestGlobalScope(node) {\n        return this.nestScope(new scope_1.GlobalScope(this, node));\n    }\n    nestMappedTypeScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.MappedTypeScope(this, this.currentScope, node));\n    }\n    nestModuleScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.ModuleScope(this, this.currentScope, node));\n    }\n    nestSwitchScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.SwitchScope(this, this.currentScope, node));\n    }\n    nestTSEnumScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.TSEnumScope(this, this.currentScope, node));\n    }\n    nestTSModuleScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.TSModuleScope(this, this.currentScope, node));\n    }\n    nestTypeScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.TypeScope(this, this.currentScope, node));\n    }\n    nestWithScope(node) {\n        (0, assert_1.assert)(this.currentScope);\n        return this.nestScope(new scope_1.WithScope(this, this.currentScope, node));\n    }\n    nestScope(scope) {\n        if (scope instanceof scope_1.GlobalScope) {\n            (0, assert_1.assert)(this.currentScope == null);\n            this.globalScope = scope;\n        }\n        this.currentScope = scope;\n        return scope;\n    }\n}\nexports.ScopeManager = ScopeManager;\n"
        }
    ]
}