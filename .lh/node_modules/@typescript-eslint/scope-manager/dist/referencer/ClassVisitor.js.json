{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/referencer/ClassVisitor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891993170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClassVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst definition_1 = require(\"../definition\");\nconst TypeVisitor_1 = require(\"./TypeVisitor\");\nconst Visitor_1 = require(\"./Visitor\");\nclass ClassVisitor extends Visitor_1.Visitor {\n    #classNode;\n    #referencer;\n    constructor(referencer, node) {\n        super(referencer);\n        this.#referencer = referencer;\n        this.#classNode = node;\n    }\n    static visit(referencer, node) {\n        const classVisitor = new ClassVisitor(referencer, node);\n        classVisitor.visitClass(node);\n    }\n    visit(node) {\n        // make sure we only handle the nodes we are designed to handle\n        if (node && node.type in this) {\n            super.visit(node);\n        }\n        else {\n            this.#referencer.visit(node);\n        }\n    }\n    ///////////////////\n    // Visit helpers //\n    ///////////////////\n    visitClass(node) {\n        if (node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id) {\n            this.#referencer\n                .currentScope()\n                .defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n        }\n        node.decorators.forEach(d => this.#referencer.visit(d));\n        this.#referencer.scopeManager.nestClassScope(node);\n        if (node.id) {\n            // define the class name again inside the new scope\n            // references to the class should not resolve directly to the parent class\n            this.#referencer\n                .currentScope()\n                .defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n        }\n        this.#referencer.visit(node.superClass);\n        // visit the type param declarations\n        this.visitType(node.typeParameters);\n        // then the usages\n        this.visitType(node.superTypeArguments);\n        node.implements.forEach(imp => this.visitType(imp));\n        this.visit(node.body);\n        this.#referencer.close(node);\n    }\n    visitFunctionParameterTypeAnnotation(node) {\n        switch (node.type) {\n            case types_1.AST_NODE_TYPES.AssignmentPattern:\n                this.visitType(node.left.typeAnnotation);\n                break;\n            case types_1.AST_NODE_TYPES.TSParameterProperty:\n                this.visitFunctionParameterTypeAnnotation(node.parameter);\n                break;\n            default:\n                this.visitType(node.typeAnnotation);\n        }\n    }\n    visitMethod(node) {\n        if (node.computed) {\n            this.#referencer.visit(node.key);\n        }\n        if (node.value.type === types_1.AST_NODE_TYPES.FunctionExpression) {\n            this.visitMethodFunction(node.value, node);\n        }\n        else {\n            this.#referencer.visit(node.value);\n        }\n        node.decorators.forEach(d => this.#referencer.visit(d));\n    }\n    visitMethodFunction(node, methodNode) {\n        if (node.id) {\n            // FunctionExpression with name creates its special scope;\n            // FunctionExpressionNameScope.\n            this.#referencer.scopeManager.nestFunctionExpressionNameScope(node);\n        }\n        node.params.forEach(param => {\n            param.decorators.forEach(d => this.visit(d));\n        });\n        // Consider this function is in the MethodDefinition.\n        this.#referencer.scopeManager.nestFunctionScope(node, true);\n        /**\n         * class A {\n         *   @meta     // <--- check this\n         *   foo(a: Type) {}\n         *\n         *   @meta     // <--- check this\n         *   foo(): Type {}\n         * }\n         */\n        let withMethodDecorators = !!methodNode.decorators.length;\n        /**\n         * class A {\n         *   foo(\n         *     @meta    // <--- check this\n         *     a: Type\n         *   ) {}\n         *\n         *   set foo(\n         *     @meta    // <--- EXCEPT this. TS do nothing for this\n         *     a: Type\n         *   ) {}\n         * }\n         */\n        withMethodDecorators ||=\n            methodNode.kind !== 'set' &&\n                node.params.some(param => param.decorators.length);\n        if (!withMethodDecorators && methodNode.kind === 'set') {\n            const keyName = getLiteralMethodKeyName(methodNode);\n            /**\n             * class A {\n             *   @meta      // <--- check this\n             *   get a() {}\n             *   set ['a'](v: Type) {}\n             * }\n             */\n            if (keyName != null &&\n                this.#classNode.body.body.find((node) => node !== methodNode &&\n                    node.type === types_1.AST_NODE_TYPES.MethodDefinition &&\n                    // Node must both be static or not\n                    node.static === methodNode.static &&\n                    getLiteralMethodKeyName(node) === keyName)?.decorators.length) {\n                withMethodDecorators = true;\n            }\n        }\n        /**\n         * @meta      // <--- check this\n         * class A {\n         *   constructor(a: Type) {}\n         * }\n         */\n        if (!withMethodDecorators &&\n            methodNode.kind === 'constructor' &&\n            this.#classNode.decorators.length) {\n            withMethodDecorators = true;\n        }\n        // Process parameter declarations.\n        for (const param of node.params) {\n            this.visitPattern(param, (pattern, info) => {\n                this.#referencer\n                    .currentScope()\n                    .defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n                this.#referencer.referencingDefaultValue(pattern, info.assignments, null, true);\n            }, { processRightHandNodes: true });\n            this.visitFunctionParameterTypeAnnotation(param);\n        }\n        this.visitType(node.returnType);\n        this.visitType(node.typeParameters);\n        this.#referencer.visitChildren(node.body);\n        this.#referencer.close(node);\n    }\n    visitPropertyBase(node) {\n        if (node.computed) {\n            this.#referencer.visit(node.key);\n        }\n        if (node.value) {\n            if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition ||\n                node.type === types_1.AST_NODE_TYPES.AccessorProperty) {\n                this.#referencer.scopeManager.nestClassFieldInitializerScope(node.value);\n            }\n            this.#referencer.visit(node.value);\n            if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition ||\n                node.type === types_1.AST_NODE_TYPES.AccessorProperty) {\n                this.#referencer.close(node.value);\n            }\n        }\n        node.decorators.forEach(d => this.#referencer.visit(d));\n    }\n    visitPropertyDefinition(node) {\n        this.visitPropertyBase(node);\n        /**\n         * class A {\n         *   @meta     // <--- check this\n         *   foo: Type;\n         * }\n         */\n        this.visitType(node.typeAnnotation);\n    }\n    visitType(node) {\n        if (!node) {\n            return;\n        }\n        TypeVisitor_1.TypeVisitor.visit(this.#referencer, node);\n    }\n    /////////////////////\n    // Visit selectors //\n    /////////////////////\n    AccessorProperty(node) {\n        this.visitPropertyDefinition(node);\n    }\n    ClassBody(node) {\n        // this is here on purpose so that this visitor explicitly declares visitors\n        // for all nodes it cares about (see the instance visit method above)\n        this.visitChildren(node);\n    }\n    Identifier(node) {\n        this.#referencer.visit(node);\n    }\n    MethodDefinition(node) {\n        this.visitMethod(node);\n    }\n    PrivateIdentifier() {\n        // intentionally skip\n    }\n    PropertyDefinition(node) {\n        this.visitPropertyDefinition(node);\n    }\n    StaticBlock(node) {\n        this.#referencer.scopeManager.nestClassStaticBlockScope(node);\n        node.body.forEach(b => this.visit(b));\n        this.#referencer.close(node);\n    }\n    TSAbstractAccessorProperty(node) {\n        this.visitPropertyDefinition(node);\n    }\n    TSAbstractMethodDefinition(node) {\n        this.visitPropertyBase(node);\n    }\n    TSAbstractPropertyDefinition(node) {\n        this.visitPropertyDefinition(node);\n    }\n    TSIndexSignature(node) {\n        this.visitType(node);\n    }\n}\nexports.ClassVisitor = ClassVisitor;\n/**\n * Only if key is one of [identifier, string, number], ts will combine metadata of accessors .\n * class A {\n *   get a() {}\n *   set ['a'](v: Type) {}\n *\n *   get [1]() {}\n *   set [1](v: Type) {}\n *\n *   // Following won't be combined\n *   get [key]() {}\n *   set [key](v: Type) {}\n *\n *   get [true]() {}\n *   set [true](v: Type) {}\n *\n *   get ['a'+'b']() {}\n *   set ['a'+'b']() {}\n * }\n */\nfunction getLiteralMethodKeyName(node) {\n    if (node.computed && node.key.type === types_1.AST_NODE_TYPES.Literal) {\n        if (typeof node.key.value === 'string' ||\n            typeof node.key.value === 'number') {\n            return node.key.value;\n        }\n    }\n    else if (!node.computed && node.key.type === types_1.AST_NODE_TYPES.Identifier) {\n        return node.key.name;\n    }\n    return null;\n}\n"
        }
    ]
}