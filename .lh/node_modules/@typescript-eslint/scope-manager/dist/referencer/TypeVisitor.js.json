{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/referencer/TypeVisitor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891993655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst definition_1 = require(\"../definition\");\nconst scope_1 = require(\"../scope\");\nconst Visitor_1 = require(\"./Visitor\");\nclass TypeVisitor extends Visitor_1.Visitor {\n    #referencer;\n    constructor(referencer) {\n        super(referencer);\n        this.#referencer = referencer;\n    }\n    static visit(referencer, node) {\n        const typeReferencer = new TypeVisitor(referencer);\n        typeReferencer.visit(node);\n    }\n    ///////////////////\n    // Visit helpers //\n    ///////////////////\n    visitFunctionType(node) {\n        // arguments and type parameters can only be referenced from within the function\n        this.#referencer.scopeManager.nestFunctionTypeScope(node);\n        this.visit(node.typeParameters);\n        for (const param of node.params) {\n            let didVisitAnnotation = false;\n            this.visitPattern(param, (pattern, info) => {\n                // a parameter name creates a value type variable which can be referenced later via typeof arg\n                this.#referencer\n                    .currentScope()\n                    .defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n                if (pattern.typeAnnotation) {\n                    this.visit(pattern.typeAnnotation);\n                    didVisitAnnotation = true;\n                }\n            });\n            // there are a few special cases where the type annotation is owned by the parameter, not the pattern\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!didVisitAnnotation && 'typeAnnotation' in param) {\n                this.visit(param.typeAnnotation);\n            }\n        }\n        this.visit(node.returnType);\n        this.#referencer.close(node);\n    }\n    visitPropertyKey(node) {\n        if (!node.computed) {\n            return;\n        }\n        // computed members are treated as value references, and TS expects they have a literal type\n        this.#referencer.visit(node.key);\n    }\n    /////////////////////\n    // Visit selectors //\n    /////////////////////\n    Identifier(node) {\n        this.#referencer.currentScope().referenceType(node);\n    }\n    MemberExpression(node) {\n        this.visit(node.object);\n        // don't visit the property\n    }\n    TSCallSignatureDeclaration(node) {\n        this.visitFunctionType(node);\n    }\n    TSConditionalType(node) {\n        // conditional types can define inferred type parameters\n        // which are only accessible from inside the conditional parameter\n        this.#referencer.scopeManager.nestConditionalTypeScope(node);\n        // type parameters inferred in the condition clause are not accessible within the false branch\n        this.visitChildren(node, ['falseType']);\n        this.#referencer.close(node);\n        this.visit(node.falseType);\n    }\n    TSConstructorType(node) {\n        this.visitFunctionType(node);\n    }\n    TSConstructSignatureDeclaration(node) {\n        this.visitFunctionType(node);\n    }\n    TSFunctionType(node) {\n        this.visitFunctionType(node);\n    }\n    TSImportType(node) {\n        // the TS parser allows any type to be the parameter, but it's a syntax error - so we can ignore it\n        this.visit(node.typeArguments);\n        // the qualifier is just part of a standard EntityName, so it should not be visited\n    }\n    TSIndexSignature(node) {\n        for (const param of node.parameters) {\n            if (param.type === types_1.AST_NODE_TYPES.Identifier) {\n                this.visit(param.typeAnnotation);\n            }\n        }\n        this.visit(node.typeAnnotation);\n    }\n    TSInferType(node) {\n        const typeParameter = node.typeParameter;\n        let scope = this.#referencer.currentScope();\n        /*\n        In cases where there is a sub-type scope created within a conditional type, then the generic should be defined in the\n        conditional type's scope, not the child type scope.\n        If we define it within the child type's scope then it won't be able to be referenced outside the child type\n        */\n        if (scope.type === scope_1.ScopeType.functionType ||\n            scope.type === scope_1.ScopeType.mappedType) {\n            // search up the scope tree to figure out if we're in a nested type scope\n            let currentScope = scope.upper;\n            while (currentScope) {\n                if (currentScope.type === scope_1.ScopeType.functionType ||\n                    currentScope.type === scope_1.ScopeType.mappedType) {\n                    // ensure valid type parents only\n                    currentScope = currentScope.upper;\n                    continue;\n                }\n                if (currentScope.type === scope_1.ScopeType.conditionalType) {\n                    scope = currentScope;\n                    break;\n                }\n                break;\n            }\n        }\n        scope.defineIdentifier(typeParameter.name, new definition_1.TypeDefinition(typeParameter.name, typeParameter));\n        this.visit(typeParameter.constraint);\n    }\n    TSInterfaceDeclaration(node) {\n        this.#referencer\n            .currentScope()\n            .defineIdentifier(node.id, new definition_1.TypeDefinition(node.id, node));\n        if (node.typeParameters) {\n            // type parameters cannot be referenced from outside their current scope\n            this.#referencer.scopeManager.nestTypeScope(node);\n            this.visit(node.typeParameters);\n        }\n        node.extends.forEach(this.visit, this);\n        this.visit(node.body);\n        if (node.typeParameters) {\n            this.#referencer.close(node);\n        }\n    }\n    TSMappedType(node) {\n        // mapped types key can only be referenced within their return value\n        this.#referencer.scopeManager.nestMappedTypeScope(node);\n        this.#referencer\n            .currentScope()\n            .defineIdentifier(node.key, new definition_1.TypeDefinition(node.key, node));\n        this.visit(node.constraint);\n        this.visit(node.nameType);\n        this.visit(node.typeAnnotation);\n        this.#referencer.close(node);\n    }\n    TSMethodSignature(node) {\n        this.visitPropertyKey(node);\n        this.visitFunctionType(node);\n    }\n    TSNamedTupleMember(node) {\n        this.visit(node.elementType);\n        // we don't visit the label as the label only exists for the purposes of documentation\n    }\n    TSPropertySignature(node) {\n        this.visitPropertyKey(node);\n        this.visit(node.typeAnnotation);\n    }\n    TSQualifiedName(node) {\n        this.visit(node.left);\n        // we don't visit the right as it a name on the thing, not a name to reference\n    }\n    TSTypeAliasDeclaration(node) {\n        this.#referencer\n            .currentScope()\n            .defineIdentifier(node.id, new definition_1.TypeDefinition(node.id, node));\n        if (node.typeParameters) {\n            // type parameters cannot be referenced from outside their current scope\n            this.#referencer.scopeManager.nestTypeScope(node);\n            this.visit(node.typeParameters);\n        }\n        this.visit(node.typeAnnotation);\n        if (node.typeParameters) {\n            this.#referencer.close(node);\n        }\n    }\n    TSTypeParameter(node) {\n        this.#referencer\n            .currentScope()\n            .defineIdentifier(node.name, new definition_1.TypeDefinition(node.name, node));\n        this.visit(node.constraint);\n        this.visit(node.default);\n    }\n    TSTypePredicate(node) {\n        if (node.parameterName.type !== types_1.AST_NODE_TYPES.TSThisType) {\n            this.#referencer.currentScope().referenceValue(node.parameterName);\n        }\n        this.visit(node.typeAnnotation);\n    }\n    // a type query `typeof foo` is a special case that references a _non-type_ variable,\n    TSTypeAnnotation(node) {\n        // check\n        this.visitChildren(node);\n    }\n    TSTypeQuery(node) {\n        let entityName;\n        if (node.exprName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n            let iter = node.exprName;\n            while (iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n                iter = iter.left;\n            }\n            entityName = iter.left;\n        }\n        else {\n            entityName = node.exprName;\n            if (node.exprName.type === types_1.AST_NODE_TYPES.TSImportType) {\n                this.visit(node.exprName);\n            }\n        }\n        if (entityName.type === types_1.AST_NODE_TYPES.Identifier) {\n            this.#referencer.currentScope().referenceValue(entityName);\n        }\n        this.visit(node.typeArguments);\n    }\n}\nexports.TypeVisitor = TypeVisitor;\n"
        }
    ]
}