{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/referencer/PatternVisitor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891993436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PatternVisitor = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst VisitorBase_1 = require(\"./VisitorBase\");\nclass PatternVisitor extends VisitorBase_1.VisitorBase {\n    #assignments = [];\n    #callback;\n    #restElements = [];\n    #rootPattern;\n    rightHandNodes = [];\n    constructor(options, rootPattern, callback) {\n        super(options);\n        this.#rootPattern = rootPattern;\n        this.#callback = callback;\n    }\n    static isPattern(node) {\n        const nodeType = node.type;\n        return (nodeType === types_1.AST_NODE_TYPES.Identifier ||\n            nodeType === types_1.AST_NODE_TYPES.ObjectPattern ||\n            nodeType === types_1.AST_NODE_TYPES.ArrayPattern ||\n            nodeType === types_1.AST_NODE_TYPES.SpreadElement ||\n            nodeType === types_1.AST_NODE_TYPES.RestElement ||\n            nodeType === types_1.AST_NODE_TYPES.AssignmentPattern);\n    }\n    ArrayExpression(node) {\n        node.elements.forEach(this.visit, this);\n    }\n    ArrayPattern(pattern) {\n        for (const element of pattern.elements) {\n            this.visit(element);\n        }\n    }\n    AssignmentExpression(node) {\n        this.#assignments.push(node);\n        this.visit(node.left);\n        this.rightHandNodes.push(node.right);\n        this.#assignments.pop();\n    }\n    AssignmentPattern(pattern) {\n        this.#assignments.push(pattern);\n        this.visit(pattern.left);\n        this.rightHandNodes.push(pattern.right);\n        this.#assignments.pop();\n    }\n    CallExpression(node) {\n        // arguments are right hand nodes.\n        node.arguments.forEach(a => {\n            this.rightHandNodes.push(a);\n        });\n        this.visit(node.callee);\n    }\n    Decorator() {\n        // don't visit any decorators when exploring a pattern\n    }\n    Identifier(pattern) {\n        const lastRestElement = this.#restElements.at(-1);\n        this.#callback(pattern, {\n            assignments: this.#assignments,\n            rest: lastRestElement?.argument === pattern,\n            topLevel: pattern === this.#rootPattern,\n        });\n    }\n    MemberExpression(node) {\n        // Computed property's key is a right hand node.\n        if (node.computed) {\n            this.rightHandNodes.push(node.property);\n        }\n        // the object is only read, write to its property.\n        this.rightHandNodes.push(node.object);\n    }\n    Property(property) {\n        // Computed property's key is a right hand node.\n        if (property.computed) {\n            this.rightHandNodes.push(property.key);\n        }\n        // If it's shorthand, its key is same as its value.\n        // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).\n        // If it's not shorthand, the name of new variable is its value's.\n        this.visit(property.value);\n    }\n    RestElement(pattern) {\n        this.#restElements.push(pattern);\n        this.visit(pattern.argument);\n        this.#restElements.pop();\n    }\n    SpreadElement(node) {\n        this.visit(node.argument);\n    }\n    TSTypeAnnotation() {\n        // we don't want to visit types\n    }\n}\nexports.PatternVisitor = PatternVisitor;\n"
        }
    ]
}