{
    "sourceFile": "node_modules/@typescript-eslint/scope-manager/dist/referencer/Referencer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891993588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Referencer = void 0;\nconst types_1 = require(\"@typescript-eslint/types\");\nconst assert_1 = require(\"../assert\");\nconst definition_1 = require(\"../definition\");\nconst lib_1 = require(\"../lib\");\nconst ClassVisitor_1 = require(\"./ClassVisitor\");\nconst ExportVisitor_1 = require(\"./ExportVisitor\");\nconst ImportVisitor_1 = require(\"./ImportVisitor\");\nconst PatternVisitor_1 = require(\"./PatternVisitor\");\nconst Reference_1 = require(\"./Reference\");\nconst TypeVisitor_1 = require(\"./TypeVisitor\");\nconst Visitor_1 = require(\"./Visitor\");\n// Referencing variables and creating bindings.\nclass Referencer extends Visitor_1.Visitor {\n    #hasReferencedJsxFactory = false;\n    #hasReferencedJsxFragmentFactory = false;\n    #jsxFragmentName;\n    #jsxPragma;\n    #lib;\n    scopeManager;\n    constructor(options, scopeManager) {\n        super(options);\n        this.scopeManager = scopeManager;\n        this.#jsxPragma = options.jsxPragma;\n        this.#jsxFragmentName = options.jsxFragmentName;\n        this.#lib = options.lib;\n    }\n    populateGlobalsFromLib(globalScope) {\n        const flattenedLibs = new Set();\n        for (const lib of this.#lib) {\n            const definition = lib_1.lib.get(lib);\n            if (!definition) {\n                throw new Error(`Invalid value for lib provided: ${lib}`);\n            }\n            flattenedLibs.add(definition);\n        }\n        // Flatten and deduplicate the set of included libs\n        for (const lib of flattenedLibs) {\n            // By adding the dependencies to the set as we iterate it,\n            // they get iterated only if they are new\n            for (const referencedLib of lib.libs) {\n                flattenedLibs.add(referencedLib);\n            }\n            // This loop is guaranteed to see each included lib exactly once\n            for (const [name, variable] of lib.variables) {\n                globalScope.defineImplicitVariable(name, variable);\n            }\n        }\n        // for const assertions (`{} as const` / `<const>{}`)\n        globalScope.defineImplicitVariable('const', {\n            eslintImplicitGlobalSetting: 'readonly',\n            isTypeVariable: true,\n            isValueVariable: false,\n        });\n    }\n    close(node) {\n        while (this.currentScope(true) && node === this.currentScope().block) {\n            this.scopeManager.currentScope = this.currentScope().close(this.scopeManager);\n        }\n    }\n    currentScope(dontThrowOnNull) {\n        if (!dontThrowOnNull) {\n            (0, assert_1.assert)(this.scopeManager.currentScope, 'aaa');\n        }\n        return this.scopeManager.currentScope;\n    }\n    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {\n        assignments.forEach(assignment => {\n            this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);\n        });\n    }\n    /**\n     * Searches for a variable named \"name\" in the upper scopes and adds a pseudo-reference from itself to itself\n     */\n    referenceInSomeUpperScope(name) {\n        let scope = this.scopeManager.currentScope;\n        while (scope) {\n            const variable = scope.set.get(name);\n            if (!variable) {\n                scope = scope.upper;\n                continue;\n            }\n            scope.referenceValue(variable.identifiers[0]);\n            return true;\n        }\n        return false;\n    }\n    referenceJsxFragment() {\n        if (this.#jsxFragmentName == null ||\n            this.#hasReferencedJsxFragmentFactory) {\n            return;\n        }\n        this.#hasReferencedJsxFragmentFactory = this.referenceInSomeUpperScope(this.#jsxFragmentName);\n    }\n    referenceJsxPragma() {\n        if (this.#jsxPragma == null || this.#hasReferencedJsxFactory) {\n            return;\n        }\n        this.#hasReferencedJsxFactory = this.referenceInSomeUpperScope(this.#jsxPragma);\n    }\n    ///////////////////\n    // Visit helpers //\n    ///////////////////\n    visitClass(node) {\n        ClassVisitor_1.ClassVisitor.visit(this, node);\n    }\n    visitForIn(node) {\n        if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration &&\n            node.left.kind !== 'var') {\n            this.scopeManager.nestForScope(node);\n        }\n        if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration) {\n            this.visit(node.left);\n            this.visitPattern(node.left.declarations[0].id, pattern => {\n                this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, null, true);\n            });\n        }\n        else {\n            this.visitPattern(node.left, (pattern, info) => {\n                const maybeImplicitGlobal = !this.currentScope().isStrict\n                    ? {\n                        node,\n                        pattern,\n                    }\n                    : null;\n                this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);\n            }, { processRightHandNodes: true });\n        }\n        this.visit(node.right);\n        this.visit(node.body);\n        this.close(node);\n    }\n    visitFunction(node) {\n        // FunctionDeclaration name is defined in upper scope\n        // NOTE: Not referring variableScope. It is intended.\n        // Since\n        //  in ES5, FunctionDeclaration should be in FunctionBody.\n        //  in ES6, FunctionDeclaration should be block scoped.\n        if (node.type === types_1.AST_NODE_TYPES.FunctionExpression) {\n            if (node.id) {\n                // FunctionExpression with name creates its special scope;\n                // FunctionExpressionNameScope.\n                this.scopeManager.nestFunctionExpressionNameScope(node);\n            }\n        }\n        else if (node.id) {\n            // id is defined in upper scope\n            this.currentScope().defineIdentifier(node.id, new definition_1.FunctionNameDefinition(node.id, node));\n        }\n        // Consider this function is in the MethodDefinition.\n        this.scopeManager.nestFunctionScope(node, false);\n        // Process parameter declarations.\n        for (const param of node.params) {\n            this.visitPattern(param, (pattern, info) => {\n                this.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n                this.referencingDefaultValue(pattern, info.assignments, null, true);\n            }, { processRightHandNodes: true });\n            this.visitFunctionParameterTypeAnnotation(param);\n            param.decorators.forEach(d => this.visit(d));\n        }\n        this.visitType(node.returnType);\n        this.visitType(node.typeParameters);\n        // In TypeScript there are a number of function-like constructs which have no body,\n        // so check it exists before traversing\n        if (node.body) {\n            // Skip BlockStatement to prevent creating BlockStatement scope.\n            if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {\n                this.visitChildren(node.body);\n            }\n            else {\n                this.visit(node.body);\n            }\n        }\n        this.close(node);\n    }\n    visitFunctionParameterTypeAnnotation(node) {\n        switch (node.type) {\n            case types_1.AST_NODE_TYPES.AssignmentPattern:\n                this.visitType(node.left.typeAnnotation);\n                break;\n            case types_1.AST_NODE_TYPES.TSParameterProperty:\n                this.visitFunctionParameterTypeAnnotation(node.parameter);\n                break;\n            default:\n                this.visitType(node.typeAnnotation);\n                break;\n        }\n    }\n    visitJSXElement(node) {\n        if (node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier) {\n            if (node.name.name[0].toUpperCase() === node.name.name[0] ||\n                node.name.name === 'this') {\n                // lower cased component names are always treated as \"intrinsic\" names, and are converted to a string,\n                // not a variable by JSX transforms:\n                // <div /> => React.createElement(\"div\", null)\n                // the only case we want to visit a lower-cased component has its name as \"this\",\n                this.visit(node.name);\n            }\n        }\n        else {\n            this.visit(node.name);\n        }\n    }\n    visitProperty(node) {\n        if (node.computed) {\n            this.visit(node.key);\n        }\n        this.visit(node.value);\n    }\n    visitType(node) {\n        if (!node) {\n            return;\n        }\n        TypeVisitor_1.TypeVisitor.visit(this, node);\n    }\n    visitTypeAssertion(node) {\n        this.visit(node.expression);\n        this.visitType(node.typeAnnotation);\n    }\n    /////////////////////\n    // Visit selectors //\n    /////////////////////\n    ArrowFunctionExpression(node) {\n        this.visitFunction(node);\n    }\n    AssignmentExpression(node) {\n        const left = this.visitExpressionTarget(node.left);\n        if (PatternVisitor_1.PatternVisitor.isPattern(left)) {\n            if (node.operator === '=') {\n                this.visitPattern(left, (pattern, info) => {\n                    const maybeImplicitGlobal = !this.currentScope().isStrict\n                        ? {\n                            node,\n                            pattern,\n                        }\n                        : null;\n                    this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n                    this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);\n                }, { processRightHandNodes: true });\n            }\n            else if (left.type === types_1.AST_NODE_TYPES.Identifier) {\n                this.currentScope().referenceValue(left, Reference_1.ReferenceFlag.ReadWrite, node.right);\n            }\n        }\n        else {\n            this.visit(left);\n        }\n        this.visit(node.right);\n    }\n    BlockStatement(node) {\n        this.scopeManager.nestBlockScope(node);\n        this.visitChildren(node);\n        this.close(node);\n    }\n    BreakStatement() {\n        // don't reference the break statement's label\n    }\n    CallExpression(node) {\n        this.visitChildren(node, ['typeArguments']);\n        this.visitType(node.typeArguments);\n    }\n    CatchClause(node) {\n        this.scopeManager.nestCatchScope(node);\n        if (node.param) {\n            const param = node.param;\n            this.visitPattern(param, (pattern, info) => {\n                this.currentScope().defineIdentifier(pattern, new definition_1.CatchClauseDefinition(param, node));\n                this.referencingDefaultValue(pattern, info.assignments, null, true);\n            }, { processRightHandNodes: true });\n        }\n        this.visit(node.body);\n        this.close(node);\n    }\n    ClassDeclaration(node) {\n        this.visitClass(node);\n    }\n    ClassExpression(node) {\n        this.visitClass(node);\n    }\n    ContinueStatement() {\n        // don't reference the continue statement's label\n    }\n    ExportAllDeclaration() {\n        // this defines no local variables\n    }\n    ExportDefaultDeclaration(node) {\n        if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {\n            ExportVisitor_1.ExportVisitor.visit(this, node);\n        }\n        else {\n            this.visit(node.declaration);\n        }\n    }\n    ExportNamedDeclaration(node) {\n        if (node.declaration) {\n            this.visit(node.declaration);\n        }\n        else {\n            ExportVisitor_1.ExportVisitor.visit(this, node);\n        }\n    }\n    ForInStatement(node) {\n        this.visitForIn(node);\n    }\n    ForOfStatement(node) {\n        this.visitForIn(node);\n    }\n    ForStatement(node) {\n        // Create ForStatement declaration.\n        // NOTE: In ES6, ForStatement dynamically generates per iteration environment. However, this is\n        // a static analyzer, we only generate one scope for ForStatement.\n        if (node.init &&\n            node.init.type === types_1.AST_NODE_TYPES.VariableDeclaration &&\n            node.init.kind !== 'var') {\n            this.scopeManager.nestForScope(node);\n        }\n        this.visitChildren(node);\n        this.close(node);\n    }\n    FunctionDeclaration(node) {\n        this.visitFunction(node);\n    }\n    FunctionExpression(node) {\n        this.visitFunction(node);\n    }\n    Identifier(node) {\n        this.currentScope().referenceValue(node);\n        this.visitType(node.typeAnnotation);\n    }\n    ImportAttribute() {\n        // import assertions are module metadata and thus have no variables to reference\n    }\n    ImportDeclaration(node) {\n        (0, assert_1.assert)(this.scopeManager.isModule(), 'ImportDeclaration should appear when the mode is ES6 and in the module context.');\n        ImportVisitor_1.ImportVisitor.visit(this, node);\n    }\n    JSXAttribute(node) {\n        this.visit(node.value);\n    }\n    JSXClosingElement(node) {\n        this.visitJSXElement(node);\n    }\n    JSXFragment(node) {\n        this.referenceJsxPragma();\n        this.referenceJsxFragment();\n        this.visitChildren(node);\n    }\n    JSXIdentifier(node) {\n        this.currentScope().referenceValue(node);\n    }\n    JSXMemberExpression(node) {\n        if (node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier ||\n            node.object.name !== 'this') {\n            this.visit(node.object);\n        }\n        // we don't ever reference the property as it's always going to be a property on the thing\n    }\n    JSXOpeningElement(node) {\n        this.referenceJsxPragma();\n        this.visitJSXElement(node);\n        this.visitType(node.typeArguments);\n        for (const attr of node.attributes) {\n            this.visit(attr);\n        }\n    }\n    LabeledStatement(node) {\n        this.visit(node.body);\n    }\n    MemberExpression(node) {\n        this.visit(node.object);\n        if (node.computed) {\n            this.visit(node.property);\n        }\n    }\n    MetaProperty() {\n        // meta properties all builtin globals\n    }\n    NewExpression(node) {\n        this.visitChildren(node, ['typeArguments']);\n        this.visitType(node.typeArguments);\n    }\n    PrivateIdentifier() {\n        // private identifiers are members on classes and thus have no variables to reference\n    }\n    Program(node) {\n        const globalScope = this.scopeManager.nestGlobalScope(node);\n        this.populateGlobalsFromLib(globalScope);\n        if (this.scopeManager.isGlobalReturn()) {\n            // Force strictness of GlobalScope to false when using node.js scope.\n            this.currentScope().isStrict = false;\n            this.scopeManager.nestFunctionScope(node, false);\n        }\n        if (this.scopeManager.isModule()) {\n            this.scopeManager.nestModuleScope(node);\n        }\n        if (this.scopeManager.isImpliedStrict()) {\n            this.currentScope().isStrict = true;\n        }\n        this.visitChildren(node);\n        this.close(node);\n    }\n    Property(node) {\n        this.visitProperty(node);\n    }\n    SwitchStatement(node) {\n        this.visit(node.discriminant);\n        this.scopeManager.nestSwitchScope(node);\n        for (const switchCase of node.cases) {\n            this.visit(switchCase);\n        }\n        this.close(node);\n    }\n    TaggedTemplateExpression(node) {\n        this.visit(node.tag);\n        this.visit(node.quasi);\n        this.visitType(node.typeArguments);\n    }\n    TSAsExpression(node) {\n        this.visitTypeAssertion(node);\n    }\n    TSDeclareFunction(node) {\n        this.visitFunction(node);\n    }\n    TSEmptyBodyFunctionExpression(node) {\n        this.visitFunction(node);\n    }\n    TSEnumDeclaration(node) {\n        this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node));\n        // enum members can be referenced within the enum body\n        this.scopeManager.nestTSEnumScope(node);\n        for (const member of node.body.members) {\n            // TS resolves literal named members to be actual names\n            // enum Foo {\n            //   'a' = 1,\n            //   b = a, // this references the 'a' member\n            // }\n            if (member.id.type === types_1.AST_NODE_TYPES.Literal &&\n                typeof member.id.value === 'string') {\n                const name = member.id;\n                this.currentScope().defineLiteralIdentifier(name, new definition_1.TSEnumMemberDefinition(name, member));\n            }\n            else if (!member.computed &&\n                member.id.type === types_1.AST_NODE_TYPES.Identifier) {\n                this.currentScope().defineIdentifier(member.id, new definition_1.TSEnumMemberDefinition(member.id, member));\n            }\n            this.visit(member.initializer);\n        }\n        this.close(node);\n    }\n    TSExportAssignment(node) {\n        if (node.expression.type === types_1.AST_NODE_TYPES.Identifier) {\n            // this is a special case - you can `export = T` where `T` is a type OR a\n            // value however `T[U]` is illegal when `T` is a type and `T.U` is illegal\n            // when `T.U` is a type\n            // i.e. if the expression is JUST an Identifier - it could be either ref\n            // kind; otherwise the standard rules apply\n            this.currentScope().referenceDualValueType(node.expression);\n        }\n        else {\n            this.visit(node.expression);\n        }\n    }\n    TSImportEqualsDeclaration(node) {\n        this.currentScope().defineIdentifier(node.id, new definition_1.ImportBindingDefinition(node.id, node, node));\n        if (node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n            let moduleIdentifier = node.moduleReference.left;\n            while (moduleIdentifier.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n                moduleIdentifier = moduleIdentifier.left;\n            }\n            this.visit(moduleIdentifier);\n        }\n        else {\n            this.visit(node.moduleReference);\n        }\n    }\n    TSInstantiationExpression(node) {\n        this.visitChildren(node, ['typeArguments']);\n        this.visitType(node.typeArguments);\n    }\n    TSInterfaceDeclaration(node) {\n        this.visitType(node);\n    }\n    TSModuleDeclaration(node) {\n        if (node.id.type === types_1.AST_NODE_TYPES.Identifier && node.kind !== 'global') {\n            this.currentScope().defineIdentifier(node.id, new definition_1.TSModuleNameDefinition(node.id, node));\n        }\n        this.scopeManager.nestTSModuleScope(node);\n        this.visit(node.body);\n        this.close(node);\n    }\n    TSSatisfiesExpression(node) {\n        this.visitTypeAssertion(node);\n    }\n    TSTypeAliasDeclaration(node) {\n        this.visitType(node);\n    }\n    TSTypeAssertion(node) {\n        this.visitTypeAssertion(node);\n    }\n    UpdateExpression(node) {\n        const argument = this.visitExpressionTarget(node.argument);\n        if (PatternVisitor_1.PatternVisitor.isPattern(argument)) {\n            this.visitPattern(argument, pattern => {\n                this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, null);\n            });\n        }\n        else {\n            this.visitChildren(node);\n        }\n    }\n    VariableDeclaration(node) {\n        const variableTargetScope = node.kind === 'var'\n            ? this.currentScope().variableScope\n            : this.currentScope();\n        for (const decl of node.declarations) {\n            const init = decl.init;\n            this.visitPattern(decl.id, (pattern, info) => {\n                variableTargetScope.defineIdentifier(pattern, new definition_1.VariableDefinition(pattern, decl, node));\n                this.referencingDefaultValue(pattern, info.assignments, null, true);\n                if (init) {\n                    this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, null, true);\n                }\n            }, { processRightHandNodes: true });\n            this.visit(decl.init);\n            this.visitType(decl.id.typeAnnotation);\n        }\n    }\n    WithStatement(node) {\n        this.visit(node.object);\n        // Then nest scope for WithStatement.\n        this.scopeManager.nestWithScope(node);\n        this.visit(node.body);\n        this.close(node);\n    }\n    visitExpressionTarget(left) {\n        switch (left.type) {\n            case types_1.AST_NODE_TYPES.TSAsExpression:\n            case types_1.AST_NODE_TYPES.TSTypeAssertion:\n                // explicitly visit the type annotation\n                this.visitType(left.typeAnnotation);\n            // intentional fallthrough\n            case types_1.AST_NODE_TYPES.TSNonNullExpression:\n                // unwrap the expression\n                left = left.expression;\n        }\n        return left;\n    }\n}\nexports.Referencer = Referencer;\n"
        }
    ]
}