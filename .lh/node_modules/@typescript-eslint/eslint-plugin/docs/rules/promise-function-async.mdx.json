{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/promise-function-async.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require any function or method that returns a Promise to be marked async.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/promise-function-async** for documentation.\n\nEnsures that each function is only capable of:\n\n- returning a rejected promise, or\n- throwing an Error object.\n\nIn contrast, non-`async`, `Promise`-returning functions are technically capable of either.\nCode that handles the results of those functions will often need to handle both cases, which can get complex.\nThis rule's practice removes a requirement for creating code to handle both cases.\n\n> When functions return unions of `Promise` and non-`Promise` types implicitly, it is usually a mistake—this rule flags those cases. If it is intentional, make the return type explicitly to allow the rule to pass.\n\n## Examples\n\nExamples of code for this rule\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nconst arrowFunctionReturnsPromise = () => Promise.resolve('value');\n\nfunction functionReturnsPromise() {\n  return Promise.resolve('value');\n}\n\nfunction functionReturnsUnionWithPromiseImplicitly(p: boolean) {\n  return p ? 'value' : Promise.resolve('value');\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nconst arrowFunctionReturnsPromise = async () => Promise.resolve('value');\n\nasync function functionReturnsPromise() {\n  return Promise.resolve('value');\n}\n\n// An explicit return type that is not Promise means this function cannot be made async, so it is ignored by the rule\nfunction functionReturnsUnionWithPromiseExplicitly(\n  p: boolean,\n): string | Promise<string> {\n  return p ? 'value' : Promise.resolve('value');\n}\n\nasync function functionReturnsUnionWithPromiseImplicitly(p: boolean) {\n  return p ? 'value' : Promise.resolve('value');\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `allowAny`\n\n{/* insert option description */}\n\nIf you want additional safety, consider turning this option off, as it makes the rule less able to catch incorrect Promise behaviors.\n\nExamples of code with `{ \"allowAny\": false }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowAny\": false }'\nconst returnsAny = () => ({}) as any;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowAny\": false }'\nconst returnsAny = async () => ({}) as any;\n```\n\n</TabItem>\n</Tabs>\n\n### `allowedPromiseNames`\n\n{/* insert option description */}\n\nFor projects that use constructs other than the global built-in `Promise` for asynchronous code.\nThis option allows specifying string names of classes or interfaces that cause a function to be checked as well.\n\nExamples of code with `{ \"allowedPromiseNames\": [\"Bluebird\"] }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowedPromiseNames\": [\"Bluebird\"] }'\nclass Bluebird {}\n\nconst returnsBluebird = () => new Bluebird(() => {});\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowedPromiseNames\": [\"Bluebird\"] }'\nclass Bluebird {}\n\nconst returnsBluebird = async () => new Bluebird(() => {});\n```\n\n</TabItem>\n</Tabs>\n\n### `checkArrowFunctions`\n\n{/* insert option description */}\n\n### `checkFunctionDeclarations`\n\n{/* insert option description */}\n\n### `checkFunctionExpressions`\n\n{/* insert option description */}\n\n### `checkMethodDeclarations`\n\n{/* insert option description */}\n\n## When Not To Use It\n\nThis rule can be difficult to enable on projects that use APIs which require functions to always be `async`.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) along with filing issues on your dependencies for those specific situations instead of completely disabling this rule.\n"
        }
    ]
}