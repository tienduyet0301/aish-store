{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/return-await.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce consistent awaiting of returned promises.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> üõë This file is source code, not the primary documentation location! üõë\n>\n> See **https://typescript-eslint.io/rules/return-await** for documentation.\n\nIn `async` functions, it is valid to return a promise-wrapped value or a value directly, both of which ultimately produce a promise with the same fulfillment value. Returning a value rather than a promise-wrapped value can have several subtle benefits:\n\n- Returning an awaited promise [improves stack trace information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#improving_stack_trace).\n- When the `return` statement is in `try...catch`, awaiting the promise allows the promise's rejection to be caught instead of leaving the error to the caller.\n- Contrary to popular belief, `return await promise;` is [at least as fast as directly returning the promise](https://github.com/tc39/proposal-faster-promise-adoption).\n\nThis rule enforces consistent handling of whether to await promises before returning them.\n\n:::info\n\nThis rule used to be considered an extension of the (now-deprecated) ESLint core rule [`no-return-await`](https://eslint.org/docs/latest/rules/no-return-await#options).\nWithout type information, the only situations that could be flagged by `no-return-await` were of neutral-to-negative value, which eventually led to its deprecation.\nIn contrast, with access to type information, `@typescript-eslint/return-await` delivers enough positive value to earn it a spot in our strict preset.\n\nIf you previously used `no-return-await`, this rule's `in-try-catch` option has the closest behavior to the `no-return-await` rule.\n\n:::\n\n## Options\n\n```ts\ntype Options =\n  | 'in-try-catch'\n  | 'always'\n  | 'error-handling-correctness-only'\n  | 'never';\n\nconst defaultOptions: Options = 'in-try-catch';\n```\n\nThe options in this rule distinguish between \"ordinary contexts\" and \"error-handling contexts\".\nAn error-handling context is anywhere where returning an unawaited promise would cause unexpected control flow regarding exceptions/rejections.\nSee detailed examples in the sections for each option.\n\n- If you return a promise within a `try` block, it should be awaited in order to trigger subsequent `catch` or `finally` blocks as expected.\n- If you return a promise within a `catch` block, and there _is_ a `finally` block, it should be awaited in order to trigger the `finally` block as expected.\n- If you return a promise between a `using` or `await using` declaration and the end of its scope, it should be awaited, since it behaves equivalently to code wrapped in a `try` block followed by a `finally`.\n\nOrdinary contexts are anywhere else a promise may be returned.\nThe choice of whether to await a returned promise in an ordinary context is mostly stylistic.\n\nWith these terms defined, the options may be summarized as follows:\n\n|              Option               | Ordinary Context <br/> (stylistic preference üé®) |        Error-Handling Context <br/> (catches bugs üêõ)        |                 Should I use this option?                  |\n| :-------------------------------: | :----------------------------------------------: | :----------------------------------------------------------: | :--------------------------------------------------------: |\n|             `always`              |             `return await promise;`              |                   `return await promise;`                    |                          ‚úÖ Yes!                           |\n|          `in-try-catch`           |                `return promise;`                 |                   `return await promise;`                    |                          ‚úÖ Yes!                           |\n| `error-handling-correctness-only` |                  don't care ü§∑                   |                   `return await promise;`                    | üü° Okay to use, but the above options would be preferable. |\n|              `never`              |                `return promise;`                 | `return promise;` <br/> (‚ö†Ô∏è This behavior may be harmful ‚ö†Ô∏è) |             ‚ùå No. This option is deprecated.              |\n\n### `in-try-catch`\n\nIn error-handling contexts, the rule enforces that returned promises must be awaited.\nIn ordinary contexts, the rule enforces that returned promises _must not_ be awaited.\n\nThis is a good option if you prefer the shorter `return promise` form for stylistic reasons, wherever it's safe to use.\n\nExamples of code with `in-try-catch`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='\"in-try-catch\"'\nasync function invalidInTryCatch1() {\n  try {\n    return Promise.reject('try');\n  } catch (e) {\n    // Doesn't execute due to missing await.\n  }\n}\n\nasync function invalidInTryCatch2() {\n  try {\n    throw new Error('error');\n  } catch (e) {\n    // Unnecessary await; rejections here don't impact control flow.\n    return await Promise.reject('catch');\n  }\n}\n\n// Prints 'starting async work', 'cleanup', 'async work done'.\nasync function invalidInTryCatch3() {\n  async function doAsyncWork(): Promise<void> {\n    console.log('starting async work');\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    console.log('async work done');\n  }\n\n  try {\n    throw new Error('error');\n  } catch (e) {\n    // Missing await.\n    return doAsyncWork();\n  } finally {\n    console.log('cleanup');\n  }\n}\n\nasync function invalidInTryCatch4() {\n  try {\n    throw new Error('error');\n  } catch (e) {\n    throw new Error('error2');\n  } finally {\n    // Unnecessary await; rejections here don't impact control flow.\n    return await Promise.reject('finally');\n  }\n}\n\nasync function invalidInTryCatch5() {\n  return await Promise.resolve('try');\n}\n\nasync function invalidInTryCatch6() {\n  return await 'value';\n}\n\nasync function invalidInTryCatch7() {\n  using x = createDisposable();\n  return Promise.reject('using in scope');\n}\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='\"in-try-catch\"'\nasync function validInTryCatch1() {\n  try {\n    return await Promise.reject('try');\n  } catch (e) {\n    // Executes as expected.\n  }\n}\n\nasync function validInTryCatch2() {\n  try {\n    throw new Error('error');\n  } catch (e) {\n    return Promise.reject('catch');\n  }\n}\n\n// Prints 'starting async work', 'async work done', 'cleanup'.\nasync function validInTryCatch3() {\n  async function doAsyncWork(): Promise<void> {\n    console.log('starting async work');\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    console.log('async work done');\n  }\n\n  try {\n    throw new Error('error');\n  } catch (e) {\n    return await doAsyncWork();\n  } finally {\n    console.log('cleanup');\n  }\n}\n\nasync function validInTryCatch4() {\n  try {\n    throw new Error('error');\n  } catch (e) {\n    throw new Error('error2');\n  } finally {\n    return Promise.reject('finally');\n  }\n}\n\nasync function validInTryCatch5() {\n  return Promise.resolve('try');\n}\n\nasync function validInTryCatch6() {\n  return 'value';\n}\n\nasync function validInTryCatch7() {\n  using x = createDisposable();\n  return await Promise.reject('using in scope');\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `always`\n\n{/* insert option description */}\n\nRequires that all returned promises be awaited.\n\nThis is a good option if you like the consistency of simply always awaiting promises, or prefer not having to consider the distinction between error-handling contexts and ordinary contexts.\n\nExamples of code with `always`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='\"always\"'\nasync function invalidAlways1() {\n  try {\n    return Promise.resolve('try');\n  } catch (e) {}\n}\n\nasync function invalidAlways2() {\n  return Promise.resolve('try');\n}\n\nasync function invalidAlways3() {\n  return await 'value';\n}\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='\"always\"'\nasync function validAlways1() {\n  try {\n    return await Promise.resolve('try');\n  } catch (e) {}\n}\n\nasync function validAlways2() {\n  return await Promise.resolve('try');\n}\n\nasync function validAlways3() {\n  return 'value';\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `error-handling-correctness-only`\n\nIn error-handling contexts, the rule enforces that returned promises must be awaited.\nIn ordinary contexts, the rule does not enforce any particular behavior around whether returned promises are awaited.\n\nThis is a good option if you only want to benefit from rule's ability to catch control flow bugs in error-handling contexts, but don't want to enforce a particular style otherwise.\n\n:::info\nWe recommend you configure either `in-try-catch` or `always` instead of this option.\nWhile the choice of whether to await promises outside of error-handling contexts is mostly stylistic, it's generally best to be consistent.\n:::\n\nExamples of additional correct code with `error-handling-correctness-only`:\n\n<Tabs>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='\"error-handling-correctness-only\"'\nasync function asyncFunction(): Promise<void> {\n  if (Math.random() < 0.5) {\n    return await Promise.resolve();\n  } else {\n    return Promise.resolve();\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `never`\n\n{/* insert option description */}\n\nDisallows awaiting any returned promises.\n\n:::warning\n\nThis option is deprecated and will be removed in a future major version of typescript-eslint.\n\nThe `never` option introduces undesirable behavior in error-handling contexts.\nIf you prefer to minimize returning awaited promises, consider instead using `in-try-catch` instead, which also generally bans returning awaited promises, but only where it is _safe_ not to await a promise.\n\nSee more details at [typescript-eslint#9433](https://github.com/typescript-eslint/typescript-eslint/issues/9433).\n:::\n\nExamples of code with `never`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='\"never\"'\nasync function invalidNever1() {\n  try {\n    return await Promise.resolve('try');\n  } catch (e) {}\n}\n\nasync function invalidNever2() {\n  return await Promise.resolve('try');\n}\n\nasync function invalidNever3() {\n  return await 'value';\n}\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='\"never\"'\nasync function validNever1() {\n  try {\n    return Promise.resolve('try');\n  } catch (e) {}\n}\n\nasync function validNever2() {\n  return Promise.resolve('try');\n}\n\nasync function validNever3() {\n  return 'value';\n}\n```\n\n</TabItem>\n</Tabs>\n\n{/* Intentionally Omitted: When Not To Use It */}\n"
        }
    ]
}