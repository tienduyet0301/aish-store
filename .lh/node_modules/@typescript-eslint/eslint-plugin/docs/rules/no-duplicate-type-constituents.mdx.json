{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-duplicate-type-constituents.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891980167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow duplicate constituents of union or intersection types.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-duplicate-type-constituents** for documentation.\n\nTypeScript supports types (\"constituents\") within union and intersection types being duplicates of each other.\nHowever, developers typically expect each constituent to be unique within its intersection or union.\nDuplicate values make the code overly verbose and generally reduce readability.\n\nThis rule disallows duplicate union or intersection constituents.\nWe consider types to be duplicate if they evaluate to the same result in the type system.\nFor example, given `type A = string` and `type T = string | A`, this rule would flag that `A` is the same type as `string`.\n\nThis rule also disallows explicitly listing `undefined` in a type union when a function parameter is marked as optional.\nDoing so is unnecessary.\nPlease note that this check only applies to parameters, not properties.\nTherefore, it does not conflict with the [`exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig/#exactOptionalPropertyTypes) TypeScript compiler setting.\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\ntype T1 = 'A' | 'A';\n\ntype T2 = string | string | number;\n\ntype T3 = { a: string } & { a: string };\n\ntype T4 = [1, 2, 3] | [1, 2, 3];\n\ntype StringA = string;\ntype StringB = string;\ntype T5 = StringA | StringB;\n\nconst fn = (a?: string | undefined) => {};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\ntype T1 = 'A' | 'B';\n\ntype T2 = string | number | boolean;\n\ntype T3 = { a: string } & { b: string };\n\ntype T4 = [1, 2, 3] | [1, 2, 3, 4];\n\ntype StringA = string;\ntype NumberB = number;\ntype T5 = StringA | NumberB;\n\nconst fn = (a?: string) => {};\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `ignoreIntersections`\n\n{/* insert option description */}\n\nWhen set to true, duplicate checks on intersection type constituents are ignored.\n\n### `ignoreUnions`\n\n{/* insert option description */}\n\nWhen set to true, duplicate checks on union type constituents are ignored.\n\n## When Not To Use It\n\nIt can sometimes be useful for the sake of documentation to include aliases for the same type.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\n> In some of those cases, [branded types](https://basarat.gitbook.io/typescript/main-1/nominaltyping#using-interfaces) might be a type-safe way to represent the underlying data types.\n\n## Related To\n\n- [no-redundant-type-constituents](./no-redundant-type-constituents.mdx)\n"
        }
    ]
}