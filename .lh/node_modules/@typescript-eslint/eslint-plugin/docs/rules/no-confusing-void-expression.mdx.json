{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-confusing-void-expression.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891980053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require expressions of type void to appear in statement position.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/no-confusing-void-expression** for documentation.\n\n`void` in TypeScript refers to a function return that is meant to be ignored.\nAttempting to use a `void`-typed value, such as storing the result of a called function in a variable, is often a sign of a programmer error.\n`void` can also be misleading for other developers even if used correctly.\n\nThis rule prevents `void` type expressions from being used in misleading locations such as being assigned to a variable, provided as a function argument, or returned from a function.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\n// somebody forgot that `alert` doesn't return anything\nconst response = alert('Are you sure?');\nconsole.log(alert('Are you sure?'));\n\n// it's not obvious whether the chained promise will contain the response (fixable)\npromise.then(value => window.postMessage(value));\n\n// it looks like we are returning the result of `console.error` (fixable)\nfunction doSomething() {\n  if (!somethingToDo) {\n    return console.error('Nothing to do!');\n  }\n\n  console.log('Doing a thing...');\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\n// just a regular void function in a statement position\nalert('Hello, world!');\n\n// this function returns a boolean value so it's ok\nconst response = confirm('Are you sure?');\nconsole.log(confirm('Are you sure?'));\n\n// now it's obvious that `postMessage` doesn't return any response\npromise.then(value => {\n  window.postMessage(value);\n});\n\n// now it's explicit that we want to log the error and return early\nfunction doSomething() {\n  if (!somethingToDo) {\n    console.error('Nothing to do!');\n    return;\n  }\n\n  console.log('Doing a thing...');\n}\n\n// using logical expressions for their side effects is fine\ncond && console.log('true');\ncond || console.error('false');\ncond ? console.log('true') : console.error('false');\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `ignoreArrowShorthand`\n\n{/* insert option description */}\n\nIt might be undesirable to wrap every arrow function shorthand expression.\nEspecially when using the Prettier formatter, which spreads such code across 3 lines instead of 1.\n\nExamples of additional **correct** code with this option enabled:\n\n```ts option='{ \"ignoreArrowShorthand\": true }' showPlaygroundButton\npromise.then(value => window.postMessage(value));\n```\n\n### `ignoreVoidOperator`\n\n{/* insert option description */}\n\nIt might be preferable to only use some distinct syntax\nto explicitly mark the confusing but valid usage of void expressions.\nThis option allows void expressions which are explicitly wrapped in the `void` operator.\nThis can help avoid confusion among other developers as long as they are made aware of this code style.\n\nThis option also changes the automatic fixes for common cases to use the `void` operator.\nIt also enables a suggestion fix to wrap the void expression with `void` operator for every problem reported.\n\nExamples of additional **correct** code with this option enabled:\n\n```ts option='{ \"ignoreVoidOperator\": true }' showPlaygroundButton\n// now it's obvious that we don't expect any response\npromise.then(value => void window.postMessage(value));\n\n// now it's explicit that we don't want to return anything\nfunction doSomething() {\n  if (!somethingToDo) {\n    return void console.error('Nothing to do!');\n  }\n\n  console.log('Doing a thing...');\n}\n\n// we are sure that we want to always log `undefined`\nconsole.log(void alert('Hello, world!'));\n```\n\n### `ignoreVoidReturningFunctions`\n\n{/* insert option description */}\n\nSome projects prefer allowing functions that explicitly return `void` to return `void` expressions. Doing so allows more writing more succinct functions.\n\n:::note\nThis is technically risky as the `void`-returning function might actually be returning a value not seen by the type system.\n:::\n\n```ts option='{ \"ignoreVoidReturningFunctions\": true }' showPlaygroundButton\nfunction foo(): void {\n  return console.log();\n}\n\nfunction onError(callback: () => void): void {\n  callback();\n}\n\nonError(() => console.log('oops'));\n```\n\n## When Not To Use It\n\nThe return type of a function can be inspected by going to its definition or hovering over it in an IDE.\nIf you don't care about being explicit about the void type in actual code then don't use this rule.\nAlso, if you strongly prefer a concise coding style more strongly than any fear of `void`-related bugs then you can avoid this rule.\n"
        }
    ]
}