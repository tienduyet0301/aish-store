{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/consistent-type-assertions.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce consistent usage of type assertions.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/consistent-type-assertions** for documentation.\n\nTypeScript provides two syntaxes for \"type assertions\":\n\n- Angle brackets: `<Type>value`\n- As: `value as Type`\n\nThis rule aims to standardize the use of type assertion style across the codebase.\nKeeping to one syntax consistently helps with code readability.\n\n:::note\nType assertions are also commonly referred as \"type casting\" in TypeScript.\nHowever, that term is technically slightly different to what is understood by type casting in other languages.\nType assertions are a way to say to the TypeScript compiler, _\"I know better than you, it's actually this different type!\"_.\n:::\n\n[`const` assertions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) are always allowed by this rule.\nExamples of them include `let x = \"hello\" as const;` and `let x = <const>\"hello\";`.\n\n## Options\n\n### `assertionStyle`\n\n{/* insert option description */}\n\nValid values for `assertionStyle` are:\n\n- `as` will enforce that you always use `... as foo`.\n- `angle-bracket` will enforce that you always use `<foo>...`\n- `never` will enforce that you do not do any type assertions.\n\nMost codebases will want to enforce not using `angle-bracket` style because it conflicts with JSX syntax, and is confusing when paired with generic syntax.\n\nSome codebases like to go for an extra level of type safety, and ban assertions altogether via the `never` option.\n\n### `objectLiteralTypeAssertions`\n\n{/* insert option description */}\n\nFor example, this would prefer `const x: T = { ... };` to `const x = { ... } as T;` (or similar with angle brackets).\nThe type assertion in the latter case is either unnecessary or will probably hide an error.\n\nThe compiler will warn for excess properties with this syntax, but not missing _required_ fields. For example: `const x: { foo: number } = {};` will fail to compile, but `const x = {} as { foo: number }` will succeed.\n\nThe const assertion `const x = { foo: 1 } as const`, introduced in TypeScript 3.4, is considered beneficial and is ignored by this option.\n\nAssertions to `any` are also ignored by this option.\n\nExamples of code for `{ assertionStyle: 'as', objectLiteralTypeAssertions: 'never' }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"assertionStyle\": \"as\", \"objectLiteralTypeAssertions\": \"never\" }'\nconst x = { foo: 1 } as T;\n\nfunction bar() {\n  return { foo: 1 } as T;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"assertionStyle\": \"as\", \"objectLiteralTypeAssertions\": \"never\" }'\nconst x: T = { foo: 1 };\nconst y = { foo: 1 } as any;\nconst z = { foo: 1 } as unknown;\n\nfunction bar(): T {\n  return { foo: 1 };\n}\n```\n\n</TabItem>\n</Tabs>\n\nExamples of code for `{ assertionStyle: 'as', objectLiteralTypeAssertions: 'allow-as-parameter' }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"assertionStyle\": \"as\", \"objectLiteralTypeAssertions\": \"allow-as-parameter\" }'\nconst x = { foo: 1 } as T;\n\nfunction bar() {\n  return { foo: 1 } as T;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```tsx option='{ \"assertionStyle\": \"as\", \"objectLiteralTypeAssertions\": \"allow-as-parameter\" }'\nconst x: T = { foo: 1 };\nconst y = { foo: 1 } as any;\nconst z = { foo: 1 } as unknown;\nbar({ foo: 1 } as T);\nnew Clazz({ foo: 1 } as T);\nfunction bar() {\n  throw { foo: 1 } as Foo;\n}\nconst foo = <Foo props={{ bar: 1 } as Bar} />;\n```\n\n</TabItem>\n</Tabs>\n\n### `arrayLiteralTypeAssertions`\n\n{/* insert option description */}\n\nFor example, this would prefer `const x: T[] = [ ... ];` to `const x = [ ... ] as T[];` (or similar with angle brackets).\n\nThe compiler will warn for excess properties of elements with this syntax, but not missing _required_ fields of those objects.\nFor example: `const x: {foo: number}[] = [{}];` will fail to compile, but `const x = [{}] as [{ foo: number }]` will succeed.\n\nThe const assertion `const x = [1, 2, 3] as const`, introduced in TypeScript 3.4, is considered beneficial and is ignored by this option.\n\nAssertions to `any` are also ignored by this option.\n\nExamples of code for `{ assertionStyle: 'as', arrayLiteralTypeAssertions: 'never' }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"assertionStyle\": \"as\", \"arrayLiteralTypeAssertions\": \"never\" }'\nconst x = ['foo'] as T;\n\nfunction bar() {\n  return ['foo'] as T;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"assertionStyle\": \"as\", \"arrayLiteralTypeAssertions\": \"never\" }'\nconst x: T = ['foo'];\nconst y = ['foo'] as any;\nconst z = ['foo'] as unknown;\n\nfunction bar(): T {\n  return ['foo'];\n}\n```\n\n</TabItem>\n</Tabs>\n\nExamples of code for `{ assertionStyle: 'as', arrayLiteralTypeAssertions: 'allow-as-parameter' }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"assertionStyle\": \"as\", \"arrayLiteralTypeAssertions\": \"allow-as-parameter\" }'\nconst x = ['foo'] as T;\n\nfunction bar() {\n  return ['foo'] as T;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```tsx option='{ \"assertionStyle\": \"as\", \"arrayLiteralTypeAssertions\": \"allow-as-parameter\" }'\nconst x: T = ['foo'];\nconst y = ['foo'] as any;\nconst z = ['foo'] as unknown;\nbar(['foo'] as T);\nnew Clazz(['foo'] as T);\nfunction bar() {\n  throw ['foo'] as Foo;\n}\nconst foo = <Foo props={['foo'] as Bar} />;\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you do not want to enforce consistent type assertions.\n\nHowever, keep in mind that inconsistent style can harm readability in a project.\nWe recommend picking a single option for this rule that works best for your project.\n"
        }
    ]
}