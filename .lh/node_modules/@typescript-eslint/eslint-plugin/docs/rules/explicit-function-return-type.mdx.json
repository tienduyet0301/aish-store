{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/explicit-function-return-type.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require explicit return types on functions and class methods.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/explicit-function-return-type** for documentation.\n\nFunctions in TypeScript often don't need to be given an explicit return type annotation.\nLeaving off the return type is less code to read or write and allows the compiler to infer it from the contents of the function.\n\nHowever, explicit return types do make it visually more clear what type is returned by a function.\nThey can also speed up TypeScript type checking performance in large codebases with many large functions.\n\nThis rule enforces that functions do have an explicit return type annotation.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\n// Should indicate that no value is returned (void)\nfunction test() {\n  return;\n}\n\n// Should indicate that a number is returned\nvar fn = function () {\n  return 1;\n};\n\n// Should indicate that a string is returned\nvar arrowFn = () => 'test';\n\nclass Test {\n  // Should indicate that no value is returned (void)\n  method() {\n    return;\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\n// No return value should be expected (void)\nfunction test(): void {\n  return;\n}\n\n// A return value of type number\nvar fn = function (): number {\n  return 1;\n};\n\n// A return value of type string\nvar arrowFn = (): string => 'test';\n\nclass Test {\n  // No return value should be expected (void)\n  method(): void {\n    return;\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### Configuring in a mixed JS/TS codebase\n\nIf you are working on a codebase within which you lint non-TypeScript code (i.e. `.js`/`.mjs`/`.cjs`/`.jsx`), you should ensure that you should use [ESLint `overrides`](https://eslint.org/docs/user-guide/configuring#disabling-rules-only-for-a-group-of-files) to only enable the rule on `.ts`/`.mts`/`.cts`/`.tsx` files. If you don't, then you will get unfixable lint errors reported within `.js`/`.mjs`/`.cjs`/`.jsx` files.\n\n```jsonc\n{\n  \"rules\": {\n    // disable the rule for all files\n    \"@typescript-eslint/explicit-function-return-type\": \"off\",\n  },\n  \"overrides\": [\n    {\n      // enable the rule specifically for TypeScript files\n      \"files\": [\"*.ts\", \"*.mts\", \"*.cts\", \"*.tsx\"],\n      \"rules\": {\n        \"@typescript-eslint/explicit-function-return-type\": \"error\",\n      },\n    },\n  ],\n}\n```\n\n### `allowExpressions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowExpressions: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowExpressions\": true }'\nfunction test() {}\n\nconst fn = () => {};\n\nexport default () => {};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowExpressions\": true }'\nnode.addEventListener('click', () => {});\n\nnode.addEventListener('click', function () {});\n\nconst foo = arr.map(i => i * i);\n```\n\n</TabItem>\n</Tabs>\n\n### `allowTypedFunctionExpressions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowTypedFunctionExpressions: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowTypedFunctionExpressions\": true }'\nlet arrowFn = () => 'test';\n\nlet funcExpr = function () {\n  return 'test';\n};\n\nlet objectProp = {\n  foo: () => 1,\n};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowTypedFunctionExpressions\": true }'\ntype FuncType = () => string;\n\nlet arrowFn: FuncType = () => 'test';\n\nlet funcExpr: FuncType = function () {\n  return 'test';\n};\n\nlet asTyped = (() => '') as () => string;\n\ninterface ObjectType {\n  foo(): number;\n}\nlet objectProp: ObjectType = {\n  foo: () => 1,\n};\nlet objectPropAs = {\n  foo: () => 1,\n} as ObjectType;\n\ndeclare function functionWithArg(arg: () => number);\nfunctionWithArg(() => 1);\n\ndeclare function functionWithObjectArg(arg: { method: () => number });\nfunctionWithObjectArg({\n  method() {\n    return 1;\n  },\n});\n```\n\n</TabItem>\n</Tabs>\n\n### `allowHigherOrderFunctions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowHigherOrderFunctions: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowHigherOrderFunctions\": true }'\nvar arrowFn = () => () => {};\n\nfunction fn() {\n  return function () {};\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowHigherOrderFunctions\": true }'\nvar arrowFn = () => (): void => {};\n\nfunction fn() {\n  return function (): void {};\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `allowDirectConstAssertionInArrowFunctions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowDirectConstAssertionInArrowFunctions: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowDirectConstAssertionInArrowFunctions\": true }'\nconst func = (value: number) => ({ type: 'X', value }) as any;\nconst func = (value: number) => ({ type: 'X', value }) as Action;\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowDirectConstAssertionInArrowFunctions\": true }'\nconst func = (value: number) => ({ foo: 'bar', value }) as const;\nconst func = () => x as const;\n```\n\n</TabItem>\n</Tabs>\n\n### `allowConciseArrowFunctionExpressionsStartingWithVoid`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowConciseArrowFunctionExpressionsStartingWithVoid: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowConciseArrowFunctionExpressionsStartingWithVoid\": true }'\nvar join = (a: string, b: string) => `${a}${b}`;\n\nconst log = (message: string) => {\n  console.log(message);\n};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowConciseArrowFunctionExpressionsStartingWithVoid\": true }'\nvar log = (message: string) => void console.log(message);\n```\n\n</TabItem>\n</Tabs>\n\n### `allowFunctionsWithoutTypeParameters`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowFunctionsWithoutTypeParameters: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowFunctionsWithoutTypeParameters\": true }'\nfunction foo<T>(t: T) {\n  return t;\n}\n\nconst bar = <T>(t: T) => t;\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowFunctionsWithoutTypeParameters\": true }'\nfunction foo<T>(t: T): T {\n  return t;\n}\n\nconst bar = <T>(t: T): T => t;\n\nfunction allowedFunction(x: string) {\n  return x;\n}\n\nconst allowedArrow = (x: string) => x;\n```\n\n</TabItem>\n</Tabs>\n\n### `allowedNames`\n\n{/* insert option description */}\n\nYou may pass function/method names you would like this rule to ignore, like so:\n\n```json\n{\n  \"@typescript-eslint/explicit-function-return-type\": [\n    \"error\",\n    {\n      \"allowedNames\": [\"ignoredFunctionName\", \"ignoredMethodName\"]\n    }\n  ]\n}\n```\n\n### `allowIIFEs`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowIIFEs: true }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowIIFEs\": true }'\nvar func = () => 'foo';\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowIIFEs\": true }'\nvar foo = (() => 'foo')();\n\nvar bar = (function () {\n  return 'bar';\n})();\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you don't find the added cost of explicitly writing function return types to be worth the visual clarity, or your project is not large enough for it to be a factor in type checking performance, then you will not need this rule.\n\n## Further Reading\n\n- TypeScript [Functions](https://www.typescriptlang.org/docs/handbook/functions.html#function-types)\n"
        }
    ]
}