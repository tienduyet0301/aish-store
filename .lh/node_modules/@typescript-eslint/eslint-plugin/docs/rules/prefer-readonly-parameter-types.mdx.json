{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/prefer-readonly-parameter-types.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require function parameters to be typed as `readonly` to prevent accidental mutation of inputs.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/prefer-readonly-parameter-types** for documentation.\n\nMutating function arguments can lead to confusing, hard to debug behavior.\nWhilst it's easy to implicitly remember to not modify function arguments, explicitly typing arguments as readonly provides clear contract to consumers.\nThis contract makes it easier for a consumer to reason about if a function has side-effects.\n\nThis rule allows you to enforce that function parameters resolve to readonly types.\nA type is considered readonly if:\n\n- it is a primitive type (`string`, `number`, `boolean`, `symbol`, or an enum),\n- it is a function signature type,\n- it is a readonly array type whose element type is considered readonly.\n- it is a readonly tuple type whose elements are all considered readonly.\n- it is an object type whose properties are all marked as readonly, and whose values are all considered readonly.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\nfunction array1(arg: string[]) {} // array is not readonly\nfunction array2(arg: readonly string[][]) {} // array element is not readonly\nfunction array3(arg: [string, number]) {} // tuple is not readonly\nfunction array4(arg: readonly [string[], number]) {} // tuple element is not readonly\n// the above examples work the same if you use ReadonlyArray<T> instead\n\nfunction object1(arg: { prop: string }) {} // property is not readonly\nfunction object2(arg: { readonly prop: string; prop2: string }) {} // not all properties are readonly\nfunction object3(arg: { readonly prop: { prop2: string } }) {} // nested property is not readonly\n// the above examples work the same if you use Readonly<T> instead\n\ninterface CustomArrayType extends ReadonlyArray<string> {\n  prop: string; // note: this property is mutable\n}\nfunction custom1(arg: CustomArrayType) {}\n\ninterface CustomFunction {\n  (): void;\n  prop: string; // note: this property is mutable\n}\nfunction custom2(arg: CustomFunction) {}\n\nfunction union(arg: string[] | ReadonlyArray<number[]>) {} // not all types are readonly\n\n// rule also checks function types\ninterface Foo {\n  (arg: string[]): void;\n}\ninterface Foo {\n  new (arg: string[]): void;\n}\nconst x = { foo(arg: string[]): void {} };\nfunction foo(arg: string[]);\ntype Foo = (arg: string[]) => void;\ninterface Foo {\n  foo(arg: string[]): void;\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\nfunction array1(arg: readonly string[]) {}\nfunction array2(arg: readonly (readonly string[])[]) {}\nfunction array3(arg: readonly [string, number]) {}\nfunction array4(arg: readonly [readonly string[], number]) {}\n// the above examples work the same if you use ReadonlyArray<T> instead\n\nfunction object1(arg: { readonly prop: string }) {}\nfunction object2(arg: { readonly prop: string; readonly prop2: string }) {}\nfunction object3(arg: { readonly prop: { readonly prop2: string } }) {}\n// the above examples work the same if you use Readonly<T> instead\n\ninterface CustomArrayType extends ReadonlyArray<string> {\n  readonly prop: string;\n}\nfunction custom1(arg: Readonly<CustomArrayType>) {}\n// interfaces that extend the array types are not considered arrays, and thus must be made readonly.\n\ninterface CustomFunction {\n  (): void;\n  readonly prop: string;\n}\nfunction custom2(arg: CustomFunction) {}\n\nfunction union(arg: readonly string[] | ReadonlyArray<number>) {}\n\nfunction primitive1(arg: string) {}\nfunction primitive2(arg: number) {}\nfunction primitive3(arg: boolean) {}\nfunction primitive4(arg: unknown) {}\nfunction primitive5(arg: null) {}\nfunction primitive6(arg: undefined) {}\nfunction primitive7(arg: any) {}\nfunction primitive8(arg: never) {}\nfunction primitive9(arg: string | number | undefined) {}\n\nfunction fnSig(arg: () => void) {}\n\nenum Foo {\n  a,\n  b,\n}\nfunction enumArg(arg: Foo) {}\n\nfunction symb1(arg: symbol) {}\nconst customSymbol = Symbol('a');\nfunction symb2(arg: typeof customSymbol) {}\n\n// function types\ninterface Foo {\n  (arg: readonly string[]): void;\n}\ninterface Foo {\n  new (arg: readonly string[]): void;\n}\nconst x = { foo(arg: readonly string[]): void {} };\nfunction foo(arg: readonly string[]);\ntype Foo = (arg: readonly string[]) => void;\ninterface Foo {\n  foo(arg: readonly string[]): void;\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `allow`\n\n{/* insert option description */}\n\nSome complex types cannot easily be made readonly, for example the `HTMLElement` type or the `JQueryStatic` type from `@types/jquery`. This option allows you to globally disable reporting of such types.\n\nThis option takes the shared [`TypeOrValueSpecifier` format](/packages/type-utils/type-or-value-specifier).\n\nExamples of code for this rule with:\n\n```json\n{\n  \"allow\": [\n    { \"from\": \"file\", \"name\": \"Foo\" },\n    { \"from\": \"lib\", \"name\": \"HTMLElement\" },\n    { \"from\": \"package\", \"name\": \"Bar\", \"package\": \"bar-lib\" }\n  ]\n}\n```\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{\"allow\":[{\"from\":\"file\",\"name\":\"Foo\"},{\"from\":\"lib\",\"name\":\"HTMLElement\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\ninterface ThisIsMutable {\n  prop: string;\n}\n\ninterface Wrapper {\n  sub: ThisIsMutable;\n}\n\ninterface WrapperWithOther {\n  readonly sub: Foo;\n  otherProp: string;\n}\n\n// Incorrect because ThisIsMutable is not readonly\nfunction fn1(arg: ThisIsMutable) {}\n\n// Incorrect because Wrapper.sub is not readonly\nfunction fn2(arg: Wrapper) {}\n\n// Incorrect because WrapperWithOther.otherProp is not readonly and not in the allowlist\nfunction fn3(arg: WrapperWithOther) {}\n```\n\n```ts option='{\"allow\":[{\"from\":\"file\",\"name\":\"Foo\"},{\"from\":\"lib\",\"name\":\"HTMLElement\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\nimport { Foo } from 'some-lib';\nimport { Bar } from 'incorrect-lib';\n\ninterface HTMLElement {\n  prop: string;\n}\n\n// Incorrect because Foo is not a local type\nfunction fn1(arg: Foo) {}\n\n// Incorrect because HTMLElement is not from the default library\nfunction fn2(arg: HTMLElement) {}\n\n// Incorrect because Bar is not from \"bar-lib\"\nfunction fn3(arg: Bar) {}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{\"allow\":[{\"from\":\"file\",\"name\":\"Foo\"},{\"from\":\"lib\",\"name\":\"HTMLElement\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\ninterface Foo {\n  prop: string;\n}\n\ninterface Wrapper {\n  readonly sub: Foo;\n  readonly otherProp: string;\n}\n\n// Works because Foo is allowed\nfunction fn1(arg: Foo) {}\n\n// Works even when Foo is nested somewhere in the type, with other properties still being checked\nfunction fn2(arg: Wrapper) {}\n```\n\n```ts option='{\"allow\":[{\"from\":\"file\",\"name\":\"Foo\"},{\"from\":\"lib\",\"name\":\"HTMLElement\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\nimport { Bar } from 'bar-lib';\n\ninterface Foo {\n  prop: string;\n}\n\n// Works because Foo is a local type\nfunction fn1(arg: Foo) {}\n\n// Works because HTMLElement is from the default library\nfunction fn2(arg: HTMLElement) {}\n\n// Works because Bar is from \"bar-lib\"\nfunction fn3(arg: Bar) {}\n```\n\n```ts option='{\"allow\":[{\"from\":\"file\",\"name\":\"Foo\"},{\"from\":\"lib\",\"name\":\"HTMLElement\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\nimport { Foo } from './foo';\n\n// Works because Foo is still a local type - it has to be in the same package\nfunction fn(arg: Foo) {}\n```\n\n</TabItem>\n</Tabs>\n\n### `checkParameterProperties`\n\n{/* insert option description */}\n\nBecause parameter properties create properties on the class, it may be undesirable to force them to be readonly.\n\nExamples of code for this rule with `{checkParameterProperties: true}`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"checkParameterProperties\": true }'\nclass Foo {\n  constructor(private paramProp: string[]) {}\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"checkParameterProperties\": true }'\nclass Foo {\n  constructor(private paramProp: readonly string[]) {}\n}\n```\n\n</TabItem>\n</Tabs>\n\nExamples of **correct** code for this rule with `{checkParameterProperties: false}`:\n\n```ts option='{ \"checkParameterProperties\": false }' showPlaygroundButton\nclass Foo {\n  constructor(\n    private paramProp1: string[],\n    private paramProp2: readonly string[],\n  ) {}\n}\n```\n\n### `ignoreInferredTypes`\n\n{/* insert option description */}\n\nThis may be desirable in cases where an external dependency specifies a callback with mutable parameters, and manually annotating the callback's parameters is undesirable.\n\nExamples of code for this rule with `{ignoreInferredTypes: true}`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"ignoreInferredTypes\": true }' skipValidation\nimport { acceptsCallback, CallbackOptions } from 'external-dependency';\n\nacceptsCallback((options: CallbackOptions) => {});\n```\n\n<details>\n<summary>external-dependency.d.ts</summary>\n\n```ts option='{ \"ignoreInferredTypes\": true }'\nexport interface CallbackOptions {\n  prop: string;\n}\ntype Callback = (options: CallbackOptions) => void;\ntype AcceptsCallback = (callback: Callback) => void;\n\nexport const acceptsCallback: AcceptsCallback;\n```\n\n</details>\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"ignoreInferredTypes\": true }'\nimport { acceptsCallback } from 'external-dependency';\n\nacceptsCallback(options => {});\n```\n\n<details>\n<summary>external-dependency.d.ts</summary>\n\n```ts option='{ \"ignoreInferredTypes\": true }' skipValidation\nexport interface CallbackOptions {\n  prop: string;\n}\ntype Callback = (options: CallbackOptions) => void;\ntype AcceptsCallback = (callback: Callback) => void;\n\nexport const acceptsCallback: AcceptsCallback;\n```\n\n</details>\n\n</TabItem>\n</Tabs>\n\n### `treatMethodsAsReadonly`\n\n{/* insert option description */}\n\nThis may be desirable when you are never reassigning methods.\n\nExamples of code for this rule with `{treatMethodsAsReadonly: false}`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"treatMethodsAsReadonly\": false }'\ntype MyType = {\n  readonly prop: string;\n  method(): string; // note: this method is mutable\n};\nfunction foo(arg: MyType) {}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"treatMethodsAsReadonly\": false }'\ntype MyType = Readonly<{\n  prop: string;\n  method(): string;\n}>;\nfunction foo(arg: MyType) {}\n\ntype MyOtherType = {\n  readonly prop: string;\n  readonly method: () => string;\n};\nfunction bar(arg: MyOtherType) {}\n```\n\n</TabItem>\n</Tabs>\n\nExamples of **correct** code for this rule with `{treatMethodsAsReadonly: true}`:\n\n```ts option='{ \"treatMethodsAsReadonly\": true }' showPlaygroundButton\ntype MyType = {\n  readonly prop: string;\n  method(): string; // note: this method is mutable\n};\nfunction foo(arg: MyType) {}\n```\n\n## When Not To Use It\n\nIf your project does not attempt to enforce strong immutability guarantees of parameters, you can avoid this rule.\n\nThis rule is very strict on what it considers mutable.\nMany types that describe themselves as readonly are considered mutable because they have mutable properties such as arrays or tuples.\nTo work around these limitations, you might need to use the rule's options.\nIn particular, the [`allow` option](#allow) can explicitly mark a type as readonly.\n"
        }
    ]
}