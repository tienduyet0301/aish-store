{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-type-alias.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891981133,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow type aliases.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-type-alias** for documentation.\n\n:::danger Deprecated\n\nThis rule has been deprecated in favour of the [`@typescript-eslint/consistent-type-definitions`](./consistent-type-definitions.mdx) rule.\nTypeScript type aliases are a commonly necessary language feature; banning it altogether is oftentimes counterproductive.\n\n:::\n\n:::note\n\nIf you want to ban certain classifications of type aliases, consider using [`no-restricted-syntax`](https://eslint.org/docs/latest/rules/no-restricted-syntax).\nSee [Troubleshooting & FAQs](/troubleshooting/faqs/general#how-can-i-ban-specific-language-feature).\n\n:::\n\nIn TypeScript, type aliases serve three purposes:\n\n- Aliasing other types so that we can refer to them using a simpler name.\n\n```ts\n// this...\ntype Person = {\n  firstName: string;\n  lastName: string;\n  age: number;\n};\n\nfunction addPerson(person: Person) {\n  // ...\n}\n\n// is easier to read than this...\nfunction addPerson(person: {\n  firstName: string;\n  lastName: string;\n  age: number;\n}) {\n  // ...\n}\n```\n\n- Act sort of like an interface, providing a set of methods and properties that must exist\n  in the objects implementing the type.\n\n```ts\ntype Person = {\n  firstName: string;\n  lastName: string;\n  age: number;\n  walk: () => void;\n  talk: () => void;\n};\n\n// you know person will have 3 properties and 2 methods,\n// because the structure has already been defined.\nvar person: Person = {\n  // ...\n};\n\n// so we can be sure that this will work\nperson.walk();\n```\n\n- Act like mapping tools between types to allow quick modifications.\n\n```ts\ntype Immutable<T> = { readonly [P in keyof T]: T[P] };\n\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype ImmutablePerson = Immutable<Person>;\n\nvar person: ImmutablePerson = { name: 'John', age: 30 };\nperson.name = 'Brad'; // error, readonly property\n```\n\nWhen aliasing, the type alias does not create a new type, it just creates a new name\nto refer to the original type. So aliasing primitives and other simple types, tuples, unions\nor intersections can some times be redundant.\n\n```ts\n// this doesn't make much sense\ntype myString = string;\n```\n\nOn the other hand, using a type alias as an interface can limit your ability to:\n\n- Reuse your code: interfaces can be extended or implemented by other types. Type aliases cannot.\n- Debug your code: interfaces create a new name, so is easy to identify the base type of an object\n  while debugging the application.\n\nFinally, mapping types is an advanced technique and leaving it open can quickly become a pain point\nin your application.\n\n## Examples\n\nThis rule disallows the use of type aliases in favor of interfaces\nand simplified types (primitives, tuples, unions, intersections, etc).\n\n## Options\n\n### `allowAliases`\n\n{/* insert option description */}\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows aliasing in union statements, e.g. `type Foo = string | string[];`\n- `\"in-intersections\"`, allows aliasing in intersection statements, e.g. `type Foo = string & string[];`\n- `\"in-unions-and-intersections\"`, allows aliasing in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowAliases\": \"always\" }` options:\n\n```ts option='{ \"allowAliases\": \"always\" }' showPlaygroundButton\n// primitives\ntype Foo = 'a';\n\ntype Foo = 'a' | 'b';\n\ntype Foo = string;\n\ntype Foo = string | string[];\n\ntype Foo = string & string[];\n\ntype Foo = `foo-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar | Baz;\n\ntype Foo = Bar & Baz;\n```\n\nExamples of **incorrect** code for the `{ \"allowAliases\": \"in-unions\" }` option:\n\n```ts option='{ \"allowAliases\": \"in-unions\" }' showPlaygroundButton\n// primitives\ntype Foo = 'a';\n\ntype Foo = string;\n\ntype Foo = string & string[];\n\ntype Foo = `foo-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar & Baz;\n```\n\nExamples of **correct** code for the `{ \"allowAliases\": \"in-unions\" }` option:\n\n```ts option='{ \"allowAliases\": \"in-unions\" }' showPlaygroundButton\n// primitives\ntype Foo = 'a' | 'b';\n\ntype Foo = string | string[];\n\ntype Foo = `a-${number}` | `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar | Baz;\n```\n\nExamples of **incorrect** code for the `{ \"allowAliases\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowAliases\": \"in-intersections\" }' showPlaygroundButton\n// primitives\ntype Foo = 'a';\n\ntype Foo = 'a' | 'b';\n\ntype Foo = string;\n\ntype Foo = string | string[];\n\ntype Foo = `a-${number}` | `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n\ntype Foo = Bar | Baz;\n```\n\nExamples of **correct** code for the `{ \"allowAliases\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowAliases\": \"in-intersections\" }' showPlaygroundButton\n// primitives\ntype Foo = string & string[];\n\ntype Foo = `a-${number}` & `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar & Baz;\n```\n\nExamples of **incorrect** code for the `{ \"allowAliases\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowAliases\": \"in-unions-and-intersections\" }' showPlaygroundButton\n// primitives\ntype Foo = 'a';\n\ntype Foo = string;\n\ntype Foo = `foo-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar;\n```\n\nExamples of **correct** code for the `{ \"allowAliases\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowAliases\": \"in-unions-and-intersections\" }' showPlaygroundButton\n// primitives\ntype Foo = 'a' | 'b';\n\ntype Foo = string | string[];\n\ntype Foo = string & string[];\n\ntype Foo = `a-${number}` & `b-${number}`;\n\ntype Foo = `a-${number}` | `b-${number}`;\n\n// reference types\ninterface Bar {}\nclass Baz implements Bar {}\n\ntype Foo = Bar | Baz;\n\ntype Foo = Bar & Baz;\n```\n\n### `allowCallbacks`\n\n{/* insert option description */}\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n\nExamples of **correct** code for the `{ \"allowCallbacks\": \"always\" }` option:\n\n```ts option='{ \"allowCallbacks\": \"always\" }' showPlaygroundButton\ntype Foo = () => void;\n\ntype Foo = (name: string) => string;\n\nclass Person {}\n\ntype Foo = (name: string, age: number) => string | Person;\n\ntype Foo = (name: string, age: number) => string & Person;\n```\n\n### `allowConditionalTypes`\n\n{/* insert option description */}\n\nExamples of **correct** code for the `{ \"allowConditionalTypes\": \"always\" }` option:\n\n```ts option='{ \"allowConditionalTypes\": \"always\" }' showPlaygroundButton\ntype Foo<T> = T extends number ? number : null;\n```\n\n### `allowConstructors`\n\n{/* insert option description */}\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n\nExamples of **correct** code for the `{ \"allowConstructors\": \"always\" }` option:\n\n```ts option='{ \"allowConstructors\": \"always\" }' showPlaygroundButton\ntype Foo = new () => void;\n```\n\n### `allowLiterals`\n\n{/* insert option description */}\n\nThe setting accepts the following options:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows literals in union statements, e.g. `type Foo = string | string[];`\n- `\"in-intersections\"`, allows literals in intersection statements, e.g. `type Foo = string & string[];`\n- `\"in-unions-and-intersections\"`, allows literals in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"always\" }` options:\n\n```ts option='{ \"allowLiterals\": \"always\" }' showPlaygroundButton\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } | { age: number };\n\ntype Foo = { name: string } & { age: number };\n```\n\nExamples of **incorrect** code for the `{ \"allowLiterals\": \"in-unions\" }` option:\n\n```ts option='{ \"allowLiterals\": \"in-unions\" }' showPlaygroundButton\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } & { age: number };\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-unions\" }` option:\n\n```ts option='{ \"allowLiterals\": \"in-unions\" }' showPlaygroundButton\ntype Foo = { name: string } | { age: number };\n```\n\nExamples of **incorrect** code for the `{ \"allowLiterals\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowLiterals\": \"in-intersections\" }' showPlaygroundButton\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n\ntype Foo = { name: string } | { age: number };\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowLiterals\": \"in-intersections\" }' showPlaygroundButton\ntype Foo = { name: string } & { age: number };\n```\n\nExamples of **incorrect** code for the `{ \"allowLiterals\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowLiterals\": \"in-unions-and-intersections\" }' showPlaygroundButton\ntype Foo = {};\n\ntype Foo = {\n  name: string;\n  age: number;\n};\n\ntype Foo = {\n  name: string;\n  age: number;\n  walk: (miles: number) => void;\n};\n```\n\nExamples of **correct** code for the `{ \"allowLiterals\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowLiterals\": \"in-unions-and-intersections\" }' showPlaygroundButton\ntype Foo = { name: string } | { age: number };\n\ntype Foo = { name: string } & { age: number };\n```\n\n### `allowMappedTypes`\n\n{/* insert option description */}\n\nThe setting accepts the following values:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows aliasing in union statements, e.g. `type Foo = string | string[];`\n- `\"in-intersections\"`, allows aliasing in intersection statements, e.g. `type Foo = string & string[];`\n- `\"in-unions-and-intersections\"`, allows aliasing in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"always\" }` options:\n\n```ts option='{ \"allowMappedTypes\": \"always\" }' showPlaygroundButton\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\nExamples of **incorrect** code for the `{ \"allowMappedTypes\": \"in-unions\" }` option:\n\n```ts option='{ \"allowMappedTypes\": \"in-unions\" }' showPlaygroundButton\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"in-unions\" }` option:\n\n```ts option='{ \"allowMappedTypes\": \"in-unions\" }' showPlaygroundButton\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n```\n\nExamples of **incorrect** code for the `{ \"allowMappedTypes\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowMappedTypes\": \"in-intersections\" }' showPlaygroundButton\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n```\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowMappedTypes\": \"in-intersections\" }' showPlaygroundButton\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\nExamples of **incorrect** code for the `{ \"allowMappedTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowMappedTypes\": \"in-unions-and-intersections\" }' showPlaygroundButton\ntype Foo<T> = { readonly [P in keyof T]: T[P] };\n\ntype Foo<T> = { [P in keyof T]?: T[P] };\n```\n\nExamples of **correct** code for the `{ \"allowMappedTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowMappedTypes\": \"in-unions-and-intersections\" }' showPlaygroundButton\ntype Foo<T, U> =\n  | { readonly [P in keyof T]: T[P] }\n  | { readonly [P in keyof U]: U[P] };\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } | { [P in keyof U]?: U[P] };\n\ntype Foo<T, U> = { readonly [P in keyof T]: T[P] } & {\n  readonly [P in keyof U]: U[P];\n};\n\ntype Foo<T, U> = { [P in keyof T]?: T[P] } & { [P in keyof U]?: U[P] };\n```\n\n### `allowTupleTypes`\n\n{/* insert option description */}\n\nThe setting accepts the following options:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n- `\"in-unions\"`, allows tuples in union statements, e.g. `type Foo = [string] | [string, string];`\n- `\"in-intersections\"`, allows tuples in intersection statements, e.g. `type Foo = [string] & [string, string];`\n- `\"in-unions-and-intersections\"`, allows tuples in union and/or intersection statements.\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"always\" }` options:\n\n```ts option='{ \"allowTupleTypes\": \"always\" }' showPlaygroundButton\ntype Foo = [number];\n\ntype Foo = [number] | [number, number];\n\ntype Foo = [number] & [number, number];\n\ntype Foo = [number] | ([number, number] & [string, string]);\n```\n\nExamples of **incorrect** code for the `{ \"allowTupleTypes\": \"in-unions\" }` option:\n\n```ts option='{ \"allowTupleTypes\": \"in-unions\" }' showPlaygroundButton\ntype Foo = [number];\n\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] & [number];\n```\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"in-unions\" }` option:\n\n```ts option='{ \"allowTupleTypes\": \"in-unions\" }' showPlaygroundButton\ntype Foo = [number] | [number, number];\n\ntype Foo = [string] | [number];\n```\n\nExamples of **incorrect** code for the `{ \"allowTupleTypes\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowTupleTypes\": \"in-intersections\" }' showPlaygroundButton\ntype Foo = [number];\n\ntype Foo = [number] | [number, number];\n\ntype Foo = [string] | [number];\n```\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"in-intersections\" }` option:\n\n```ts option='{ \"allowTupleTypes\": \"in-intersections\" }' showPlaygroundButton\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] & [number];\n```\n\nExamples of **incorrect** code for the `{ \"allowTupleTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowTupleTypes\": \"in-unions-and-intersections\" }' showPlaygroundButton\ntype Foo = [number];\n\ntype Foo = [string];\n```\n\nExamples of **correct** code for the `{ \"allowTupleTypes\": \"in-unions-and-intersections\" }` option:\n\n```ts option='{ \"allowTupleTypes\": \"in-unions-and-intersections\" }' showPlaygroundButton\ntype Foo = [number] & [number, number];\n\ntype Foo = [string] | [number];\n```\n\n### `allowGenerics`\n\n{/* insert option description */}\n\nThe setting accepts the following options:\n\n- `\"always\"` or `\"never\"` to active or deactivate the feature.\n\nExamples of **correct** code for the `{ \"allowGenerics\": \"always\" }` options:\n\n```ts option='{ \"allowGenerics\": \"always\" }' showPlaygroundButton\ntype Foo = Bar<string>;\n\ntype Foo = Record<string, number>;\n\ntype Foo = Readonly<Bar>;\n\ntype Foo = Partial<Bar>;\n\ntype Foo = Omit<Bar, 'a' | 'b'>;\n```\n\n{/* Intentionally Omitted: When Not To Use It */}\n\n## Further Reading\n\n- [Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)\n"
        }
    ]
}