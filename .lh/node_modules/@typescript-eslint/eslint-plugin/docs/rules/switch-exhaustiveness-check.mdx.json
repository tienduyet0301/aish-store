{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/switch-exhaustiveness-check.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require switch-case statements to be exhaustive.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/switch-exhaustiveness-check** for documentation.\n\nWhen working with union types or enums in TypeScript, it's common to want to write a `switch` statement intended to contain a `case` for each possible type in the union or the enum.\nHowever, if the union type or the enum changes, it's easy to forget to modify the cases to account for any new types.\n\nThis rule reports when a `switch` statement over a value typed as a union of literals or as an enum is missing a case for any of those literal types and does not have a `default` clause.\n\n## Options\n\n### `allowDefaultCaseForExhaustiveSwitch`\n\n{/* insert option description */}\n\nIf set to false, this rule will also report when a `switch` statement has a case for everything in a union and _also_ contains a `default` case. Thus, by setting this option to false, the rule becomes stricter.\n\nWhen a `switch` statement over a union type is exhaustive, a final `default` case would be a form of dead code.\nAdditionally, if a new value is added to the union type and you're using [`considerDefaultExhaustiveForUnions`](#considerDefaultExhaustiveForUnions), a `default` would prevent the `switch-exhaustiveness-check` rule from reporting on the new case not being handled in the `switch` statement.\n\n#### `allowDefaultCaseForExhaustiveSwitch` Caveats\n\nIt can sometimes be useful to include a redundant `default` case on an exhaustive `switch` statement if it's possible for values to have types not represented by the union type.\nFor example, in applications that can have version mismatches between clients and servers, it's possible for a server running a newer software version to send a value not recognized by the client's older typings.\n\nIf your project has a small number of intentionally redundant `default` cases, you might want to use an [inline ESLint disable comment](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for each of them.\n\nIf your project has many intentionally redundant `default` cases, you may want to disable `allowDefaultCaseForExhaustiveSwitch` and use the [`default-case` core ESLint rule](https://eslint.org/docs/latest/rules/default-case) along with [a `satisfies never` check](https://www.typescriptlang.org/play?#code/C4TwDgpgBAYgTgVwJbCgXigcgIZjAGwkygB8sAjbAO2u0wG4AoRgMwSoGNgkB7KqBAGcI8ZMAAULRCgBcsacACUcwcDhIqAcygBvRlCiCA7ig4ALKJIWLd+g1A7ZhWXASJy99+3AjAEcfhw8QgApZA4iJi8AX2YvR2dMShoaTA87Lx8-AIpaGjCkCIYMqFiSgBMIFmwEfGB0rwMpMUNsbkEWJAhBKCoIADcIOCjGrP9A9gBrKh4jKgKikYNY5cZYoA).\n\n### `requireDefaultForNonUnion`\n\n{/* insert option description */}\n\nIf set to true, this rule will also report when a `switch` statement switches over a non-union type (like a `number` or `string`, for example) and that `switch` statement does not have a `default` case. Thus, by setting this option to true, the rule becomes stricter.\n\nThis is generally desirable so that `number` and `string` switches will be subject to the same exhaustive checks that your other switches are.\n\nExamples of additional **incorrect** code for this rule with `{ requireDefaultForNonUnion: true }`:\n\n```ts option='{ \"requireDefaultForNonUnion\": true }' showPlaygroundButton\nconst value: number = Math.floor(Math.random() * 3);\n\nswitch (value) {\n  case 0:\n    return 0;\n  case 1:\n    return 1;\n}\n```\n\nSince `value` is a non-union type it requires the switch case to have a default clause only with `requireDefaultForNonUnion` enabled.\n\n### `considerDefaultExhaustiveForUnions`\n\n{/* insert option description */}\n\nIf set to true, a `switch` statement over a union type that includes a `default` case is considered exhaustive.\nOtherwise, the rule enforces explicitly handling every constituent of the union type with their own explicit `case`.\nKeeping this option disabled can be useful if you want to make sure every value added to the union receives explicit handling, with the `default` case reserved for reporting an error.\n\nExamples of additional **correct** code with `{ considerDefaultExhaustiveForUnions: true }`:\n\n```ts option='{ \"considerDefaultExhaustiveForUnions\": true }' showPlaygroundButton\ndeclare const literal: 'a' | 'b';\n\nswitch (literal) {\n  case 'a':\n    break;\n  default:\n    break;\n}\n```\n\n### `defaultCaseCommentPattern`\n\n{/* insert option description */}\n\nDefault: `/^no default$/iu`.\n\nIt can sometimes be preferable to omit the default case for only some switch statements.\nFor those situations, this rule can be given a pattern for a comment that's allowed to take the place of a `default:`.\n\nExamples of additional **correct** code with `{ defaultCaseCommentPattern: \"^skip\\\\sdefault\" }`:\n\n```ts option='{ \"defaultCaseCommentPattern\": \"^skip default\" }' showPlaygroundButton\ndeclare const value: 'a' | 'b';\n\nswitch (value) {\n  case 'a':\n    break;\n  // skip default\n}\n```\n\n## Examples\n\nWhen the switch doesn't have exhaustive cases, either filling them all out or adding a default (if you have `considerDefaultExhaustiveForUnions` enabled) will address the rule's complaint.\n\nHere are some examples of code working with a union of literals:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\ntype Day =\n  | 'Monday'\n  | 'Tuesday'\n  | 'Wednesday'\n  | 'Thursday'\n  | 'Friday'\n  | 'Saturday'\n  | 'Sunday';\n\ndeclare const day: Day;\nlet result = 0;\n\nswitch (day) {\n  case 'Monday':\n    result = 1;\n    break;\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct (Exhaustive)\">\n\n```ts\ntype Day =\n  | 'Monday'\n  | 'Tuesday'\n  | 'Wednesday'\n  | 'Thursday'\n  | 'Friday'\n  | 'Saturday'\n  | 'Sunday';\n\ndeclare const day: Day;\nlet result = 0;\n\nswitch (day) {\n  case 'Monday':\n    result = 1;\n    break;\n  case 'Tuesday':\n    result = 2;\n    break;\n  case 'Wednesday':\n    result = 3;\n    break;\n  case 'Thursday':\n    result = 4;\n    break;\n  case 'Friday':\n    result = 5;\n    break;\n  case 'Saturday':\n    result = 6;\n    break;\n  case 'Sunday':\n    result = 7;\n    break;\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct (Defaulted)\">\n\n```ts option='{ \"considerDefaultExhaustiveForUnions\": true }'\n// requires `considerDefaultExhaustiveForUnions` to be set to true\n\ntype Day =\n  | 'Monday'\n  | 'Tuesday'\n  | 'Wednesday'\n  | 'Thursday'\n  | 'Friday'\n  | 'Saturday'\n  | 'Sunday';\n\ndeclare const day: Day;\nlet result = 0;\n\nswitch (day) {\n  case 'Monday':\n    result = 1;\n    break;\n  default:\n    result = 42;\n}\n```\n\n</TabItem>\n</Tabs>\n\nLikewise, here are some examples of code working with an enum:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\nenum Fruit {\n  Apple,\n  Banana,\n  Cherry,\n}\n\ndeclare const fruit: Fruit;\n\nswitch (fruit) {\n  case Fruit.Apple:\n    console.log('an apple');\n    break;\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct (Exhaustive)\">\n\n```ts\nenum Fruit {\n  Apple,\n  Banana,\n  Cherry,\n}\n\ndeclare const fruit: Fruit;\n\nswitch (fruit) {\n  case Fruit.Apple:\n    console.log('an apple');\n    break;\n\n  case Fruit.Banana:\n    console.log('a banana');\n    break;\n\n  case Fruit.Cherry:\n    console.log('a cherry');\n    break;\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct (Defaulted)\">\n\n```ts option='{ \"considerDefaultExhaustiveForUnions\": true }'\n// requires `considerDefaultExhaustiveForUnions` to be set to true\n\nenum Fruit {\n  Apple,\n  Banana,\n  Cherry,\n}\n\ndeclare const fruit: Fruit;\n\nswitch (fruit) {\n  case Fruit.Apple:\n    console.log('an apple');\n    break;\n\n  default:\n    console.log('a fruit');\n    break;\n}\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you don't frequently `switch` over union types or enums with many parts, or intentionally wish to leave out some parts, this rule may not be for you.\n"
        }
    ]
}