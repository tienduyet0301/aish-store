{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/explicit-module-boundary-types.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: \"Require explicit return and argument types on exported functions' and classes' public class methods.\"\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/explicit-module-boundary-types** for documentation.\n\nExplicit types for function return values and arguments makes it clear to any calling code what is the module boundary's input and output.\nAdding explicit type annotations for those types can help improve code readability.\nIt can also improve TypeScript type checking performance on larger codebases.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\n// Should indicate that no value is returned (void)\nexport function test() {\n  return;\n}\n\n// Should indicate that a string is returned\nexport var arrowFn = () => 'test';\n\n// All arguments should be typed\nexport var arrowFn = (arg): string => `test ${arg}`;\nexport var arrowFn = (arg: any): string => `test ${arg}`;\n\nexport class Test {\n  // Should indicate that no value is returned (void)\n  method() {\n    return;\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\n// A function with no return value (void)\nexport function test(): void {\n  return;\n}\n\n// A return value of type string\nexport var arrowFn = (): string => 'test';\n\n// All arguments should be typed\nexport var arrowFn = (arg: string): string => `test ${arg}`;\nexport var arrowFn = (arg: unknown): string => `test ${arg}`;\n\nexport class Test {\n  // A class method with no return value (void)\n  method(): void {\n    return;\n  }\n}\n\n// The function does not apply because it is not an exported function.\nfunction test() {\n  return;\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### Configuring in a mixed JS/TS codebase\n\nIf you are working on a codebase within which you lint non-TypeScript code (i.e. `.js`/`.mjs`/`.cjs`/`.jsx`), you should ensure that you should use [ESLint `overrides`](https://eslint.org/docs/user-guide/configuring#disabling-rules-only-for-a-group-of-files) to only enable the rule on `.ts`/`.mts`/`.cts`/`.tsx` files. If you don't, then you will get unfixable lint errors reported within `.js`/`.mjs`/`.cjs`/`.jsx` files.\n\n```jsonc\n{\n  \"rules\": {\n    // disable the rule for all files\n    \"@typescript-eslint/explicit-module-boundary-types\": \"off\",\n  },\n  \"overrides\": [\n    {\n      // enable the rule specifically for TypeScript files\n      \"files\": [\"*.ts\", \"*.mts\", \"*.cts\", \"*.tsx\"],\n      \"rules\": {\n        \"@typescript-eslint/explicit-module-boundary-types\": \"error\",\n      },\n    },\n  ],\n}\n```\n\n### `allowArgumentsExplicitlyTypedAsAny`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowArgumentsExplicitlyTypedAsAny: false }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowArgumentsExplicitlyTypedAsAny\": false }'\nexport const func = (value: any): number => value + 1;\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowArgumentsExplicitlyTypedAsAny\": true }'\nexport const func = (value: any): number => value + 1;\n```\n\n</TabItem>\n</Tabs>\n\n### `allowDirectConstAssertionInArrowFunctions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowDirectConstAssertionInArrowFunctions: false }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowDirectConstAssertionInArrowFunctions\": false }'\nexport const func = (value: number) => ({ type: 'X', value });\nexport const foo = () => ({\n  bar: true,\n});\nexport const bar = () => 1;\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowDirectConstAssertionInArrowFunctions\": true }'\nexport const func = (value: number) => ({ type: 'X', value }) as const;\nexport const foo = () =>\n  ({\n    bar: true,\n  }) as const;\nexport const bar = () => 1 as const;\n```\n\n</TabItem>\n</Tabs>\n\n### `allowedNames`\n\n{/* insert option description */}\n\nYou may pass function/method names you would like this rule to ignore, like so:\n\n```json\n{\n  \"@typescript-eslint/explicit-module-boundary-types\": [\n    \"error\",\n    {\n      \"allowedNames\": [\"ignoredFunctionName\", \"ignoredMethodName\"]\n    }\n  ]\n}\n```\n\n### `allowHigherOrderFunctions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowHigherOrderFunctions: false }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowHigherOrderFunctions\": false }'\nexport const arrowFn = () => () => {};\n\nexport function fn() {\n  return function () {};\n}\n\nexport function foo(outer: string) {\n  return function (inner: string) {};\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowHigherOrderFunctions\": true }'\nexport const arrowFn = () => (): void => {};\n\nexport function fn() {\n  return function (): void {};\n}\n\nexport function foo(outer: string) {\n  return function (inner: string): void {};\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `allowTypedFunctionExpressions`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ allowTypedFunctionExpressions: false }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowTypedFunctionExpressions\": false }'\nexport let arrowFn = () => 'test';\n\nexport let funcExpr = function () {\n  return 'test';\n};\n\nexport let objectProp = {\n  foo: () => 1,\n};\n\nexport const foo = bar => {};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowTypedFunctionExpressions\": true }'\ntype FuncType = () => string;\n\nexport let arrowFn: FuncType = () => 'test';\n\nexport let funcExpr: FuncType = function () {\n  return 'test';\n};\n\nexport let asTyped = (() => '') as () => string;\n\ninterface ObjectType {\n  foo(): number;\n}\nexport let objectProp: ObjectType = {\n  foo: () => 1,\n};\nexport let objectPropAs = {\n  foo: () => 1,\n} as ObjectType;\n\ntype FooType = (bar: string) => void;\nexport const foo: FooType = bar => {};\n```\n\n</TabItem>\n</Tabs>\n\n### `allowOverloadFunctions`\n\n{/* insert option description */}\n\nExamples of correct code when `allowOverloadFunctions` is set to `true`:\n\n```ts option='{ \"allowOverloadFunctions\": true }' showPlaygroundButton\nexport function test(a: string): string;\nexport function test(a: number): number;\nexport function test(a: unknown) {\n  return a;\n}\n```\n\n## When Not To Use It\n\nIf your project is not used by downstream consumers that are sensitive to API types, you can disable this rule.\n\n## Further Reading\n\n- TypeScript [Functions](https://www.typescriptlang.org/docs/handbook/functions.html#function-types)\n\n## Related To\n\n- [explicit-function-return-type](./explicit-function-return-type.mdx)\n"
        }
    ]
}