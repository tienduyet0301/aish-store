{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/strict-boolean-expressions.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow certain types in boolean expressions.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/strict-boolean-expressions** for documentation.\n\nForbids usage of non-boolean types in expressions where a boolean is expected.\n`boolean` and `never` types are always allowed.\nAdditional types which are considered safe in a boolean context can be configured via options.\n\nThe following nodes are considered boolean expressions and their type is checked:\n\n- Argument to the logical negation operator (`!arg`).\n- The condition in a conditional expression (`cond ? x : y`).\n- Conditions for `if`, `for`, `while`, and `do-while` statements.\n- Operands of logical binary operators (`lhs || rhs` and `lhs && rhs`).\n  - Right-hand side operand is ignored when it's not a descendant of another boolean expression.\n    This is to allow usage of boolean operators for their short-circuiting behavior.\n- Asserted argument of an assertion function (`assert(arg)`).\n- Return type of array predicate functions such as `filter()`, `some()`, etc.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\n// nullable numbers are considered unsafe by default\ndeclare const num: number | undefined;\nif (num) {\n  console.log('num is defined');\n}\n\n// nullable strings are considered unsafe by default\ndeclare const str: string | null;\nif (!str) {\n  console.log('str is empty');\n}\n\n// nullable booleans are considered unsafe by default\nfunction foo(bool?: boolean) {\n  if (bool) {\n    bar();\n  }\n}\n\n// `any`, unconstrained generics and unions of more than one primitive type are disallowed\nconst foo = <T>(arg: T) => (arg ? 1 : 0);\n\n// always-truthy and always-falsy types are disallowed\nlet obj = {};\nwhile (obj) {\n  obj = getObj();\n}\n\n// assertion functions without an `is` are boolean contexts.\ndeclare function assert(value: unknown): asserts value;\nlet maybeString = Math.random() > 0.5 ? '' : undefined;\nassert(maybeString);\n\n// array predicates' return types are boolean contexts.\n['one', null].filter(x => x);\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```tsx\n// nullable values should be checked explicitly against null or undefined\nlet num: number | undefined = 0;\nif (num != null) {\n  console.log('num is defined');\n}\n\nlet str: string | null = null;\nif (str != null && !str) {\n  console.log('str is empty');\n}\n\nfunction foo(bool?: boolean) {\n  if (bool ?? false) {\n    bar();\n  }\n}\n\n// `any` types should be converted to boolean explicitly\nconst foo = (arg: any) => (Boolean(arg) ? 1 : 0);\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `allowString`\n\n{/* insert option description */}\n\nThis can be safe because strings have only one falsy value (`\"\"`).\nSet this to `false` if you prefer the explicit `str != \"\"` or `str.length > 0` style.\n\n### `allowNumber`\n\n{/* insert option description */}\n\nThis can be safe because numbers have only two falsy values (`0` and `NaN`).\nSet this to `false` if you prefer the explicit `num != 0` and `!Number.isNaN(num)` style.\n\n### `allowNullableObject`\n\n{/* insert option description */}\n\nThis can be safe because objects, functions, and symbols don't have falsy values.\nSet this to `false` if you prefer the explicit `obj != null` style.\n\n### `allowNullableBoolean`\n\n{/* insert option description */}\n\nThis is unsafe because nullable booleans can be either `false` or nullish.\nSet this to `false` if you want to enforce explicit `bool ?? false` or `bool ?? true` style.\nSet this to `true` if you don't mind implicitly treating false the same as a nullish value.\n\n### `allowNullableString`\n\n{/* insert option description */}\n\nThis is unsafe because nullable strings can be either an empty string or nullish.\nSet this to `true` if you don't mind implicitly treating an empty string the same as a nullish value.\n\n### `allowNullableNumber`\n\n{/* insert option description */}\n\nThis is unsafe because nullable numbers can be either a falsy number or nullish.\nSet this to `true` if you don't mind implicitly treating zero or NaN the same as a nullish value.\n\n### `allowNullableEnum`\n\n{/* insert option description */}\n\nThis is unsafe because nullable enums can be either a falsy number or nullish.\nSet this to `true` if you don't mind implicitly treating an enum whose value is zero the same as a nullish value.\n\n### `allowAny`\n\n{/* insert option description */}\n\nThis is unsafe for because `any` allows any values and disables many type checking checks.\nSet this to `true` at your own risk.\n\n### `allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing`\n\n{/* insert option description */}\n\n:::danger Deprecated\n\nThis option will be removed in the next major version of typescript-eslint.\n\n:::\n\nIf this is set to `false`, then the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.\n\nWithout `strictNullChecks`, TypeScript essentially erases `undefined` and `null` from the types. This means when this rule inspects the types from a variable, **it will not be able to tell that the variable might be `null` or `undefined`**, which essentially makes this rule a lot less useful.\n\nYou should be using `strictNullChecks` to ensure complete type-safety in your codebase.\n\nIf for some reason you cannot turn on `strictNullChecks`, but still want to use this rule - you can use this option to allow it - but know that the behavior of this rule is _undefined_ with the compiler option turned off. We will not accept bug reports if you are using this option.\n\n## When Not To Use It\n\nIf your project isn't likely to experience bugs from falsy non-boolean values being used in logical conditions, you can skip enabling this rule.\n\nOtherwise, this rule can be quite strict around requiring exact comparisons in logical checks.\nIf you prefer more succinct checks over more precise boolean logic, this rule might not be for you.\n\n## Related To\n\n- [no-unnecessary-condition](./no-unnecessary-condition.mdx) - Similar rule which reports always-truthy and always-falsy values in conditions\n"
        }
    ]
}