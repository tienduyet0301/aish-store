{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/method-signature-style.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce using a particular method signature syntax.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/method-signature-style** for documentation.\n\nTypeScript provides two ways to define an object/interface function property:\n\n```ts\ninterface Example {\n  // method shorthand syntax\n  func(arg: string): number;\n\n  // regular property with function type\n  func: (arg: string) => number;\n}\n```\n\nThe two are very similar; most of the time it doesn't matter which one you use.\n\nA good practice is to use the TypeScript's `strict` option (which implies `strictFunctionTypes`) which enables correct typechecking for function properties only (method signatures get old behavior).\n\nTypeScript FAQ:\n\n> A method and a function property of the same type behave differently.\n> Methods are always bivariant in their argument, while function properties are contravariant in their argument under `strictFunctionTypes`.\n\nSee the reasoning behind that in the [TypeScript PR for the compiler option](https://github.com/microsoft/TypeScript/pull/18654).\n\n## Options\n\nThis rule accepts one string option:\n\n- `\"property\"`: Enforce using property signature for functions. Use this to enforce maximum correctness together with TypeScript's strict mode.\n- `\"method\"`: Enforce using method signature for functions. Use this if you aren't using TypeScript's strict mode and prefer this style.\n\n### `property`\n\n{/* insert option description */}\n\nExamples of code with `property` option.\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='\"property\"'\ninterface T1 {\n  func(arg: string): number;\n}\ntype T2 = {\n  func(arg: boolean): void;\n};\ninterface T3 {\n  func(arg: number): void;\n  func(arg: string): void;\n  func(arg: boolean): void;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='\"property\"'\ninterface T1 {\n  func: (arg: string) => number;\n}\ntype T2 = {\n  func: (arg: boolean) => void;\n};\n// this is equivalent to the overload\ninterface T3 {\n  func: ((arg: number) => void) &\n    ((arg: string) => void) &\n    ((arg: boolean) => void);\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `method`\n\n{/* insert option description */}\n\nExamples of code with `method` option.\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='\"method\"'\ninterface T1 {\n  func: (arg: string) => number;\n}\ntype T2 = {\n  func: (arg: boolean) => void;\n};\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='\"method\"'\ninterface T1 {\n  func(arg: string): number;\n}\ntype T2 = {\n  func(arg: boolean): void;\n};\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you don't want to enforce a particular style for object/interface function types, and/or if you don't use `strictFunctionTypes`, then you don't need this rule.\n\nHowever, keep in mind that inconsistent style can harm readability in a project.\nWe recommend picking a single option for this rule that works best for your project.\n"
        }
    ]
}