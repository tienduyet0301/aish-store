{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/consistent-type-definitions.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce type definitions to consistently use either `interface` or `type`.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/consistent-type-definitions** for documentation.\n\nTypeScript provides two common ways to define an object type: `interface` and `type`.\n\n```ts\n// type alias\ntype T1 = {\n  a: string;\n  b: number;\n};\n\n// interface keyword\ninterface T2 {\n  a: string;\n  b: number;\n}\n```\n\nThe two are generally very similar, and can often be used interchangeably.\nUsing the same type declaration style consistently helps with code readability.\n\n## Options\n\n- `'interface'` _(default)_: enforce using `interface`s for object type definitions.\n- `'type'`: enforce using `type`s for object type definitions.\n\n### `'interface'`\n\n{/* insert option description */}\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='\"interface\"'\ntype T = { x: number };\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='\"interface\"'\ntype T = string;\ntype Foo = string | {};\n\ninterface T {\n  x: number;\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `'type'`\n\n{/* insert option description */}\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='\"type\"'\ninterface T {\n  x: number;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='\"type\"'\ntype T = { x: number };\n```\n\n</TabItem>\n</Tabs>\n\n## FAQs\n\n### What are the differences between `interface` and `type`?\n\nThere are very few differences between interfaces and object types in TypeScript.\nOther than type aliases being used to represent union types, it is rare that you will need to choose one over the other.\n\n| Feature               | Interfaces | Object Types | Explanation                                                                                            |\n| --------------------- | ---------- | ------------ | ------------------------------------------------------------------------------------------------------ |\n| Object shapes         | ✅         | ✅           | Both can be used to represent general object shapes.                                                   |\n| General performance   | ✅         | ✅           | Both are optimized for performance in TypeScript's type checker.                                       |\n| Edge case performance | ✅         |              | Large, complex logical types can be optimized better with interfaces by TypeScript's type checker.     |\n| Traditional semantics | ✅         |              | Interfaces are typically the default in much -though not all- of the TypeScript community.             |\n| Non-object shapes     |            | ✅           | Object types may describe literals, primitives, unions, and intersections.                             |\n| Logical types         |            | ✅           | Object types may include conditional and mapped types.                                                 |\n| Merging               | Allowed    | Not allowed  | Interfaces of the same name are treated as one interface (\"merged\"); type aliases may not share names. |\n\nWe recommend choosing one definition style, using it when possible, and falling back to the other style when needed.\nThe benefits of remaining consistent within a codebase almost always outweigh the benefits of either definition style.\n\n### When do the performance differences between `interface` and `type` matter?\n\nAlmost never.\nMost TypeScript projects do not -and should not- utilize types that exercise the performance differences between the two kinds of definitions.\n\nIf you are having problems with type checking performance, see the [TypeScript Wiki's Performance page](https://github.com/microsoft/TypeScript/wiki/Performance).\n\n### Why is the default `interface`?\n\nInterfaces are the prevailing, most common style in the TypeScript.\n`interface` has traditionally been TypeScript's intended (\"semantic\") way to convey _\"an object with these fields\"_.\n\nWe generally recommend staying with the default, `'interface'`, to be stylistically consistent with the majority of TypeScript projects.\nIf you strongly prefer `'type'`, that's fine too.\n\n## When Not To Use It\n\nIf you specifically want to manually choose whether to use an interface or type literal for stylistic reasons each time you define a type, you can avoid this rule.\n\nHowever, keep in mind that inconsistent style can harm readability in a project.\nWe recommend picking a single option for this rule that works best for your project.\n\nYou might occasionally need to a different definition type in specific cases, such as if your project is a dependency or dependent of another project that relies on a specific type definition style.\nConsider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\n## Further Reading\n\n- [TypeScript Handbook > Everyday Types > Differences Between Type Aliases and Interfaces](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)\n- [StackOverflow: Interfaces vs Types in TypeScript](https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript)\n"
        }
    ]
}