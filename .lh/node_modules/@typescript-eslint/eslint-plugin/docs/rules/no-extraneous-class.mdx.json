{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-extraneous-class.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891980375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow classes used as namespaces.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/no-extraneous-class** for documentation.\n\nThis rule reports when a class has no non-static members, such as for a class used exclusively as a static namespace.\n\nUsers who come from a [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming) paradigm may wrap their utility functions in an extra class, instead of putting them at the top level of an ECMAScript module.\nDoing so is generally unnecessary in JavaScript and TypeScript projects.\n\n- Wrapper classes add extra cognitive complexity to code without adding any structural improvements\n  - Whatever would be put on them, such as utility functions, are already organized by virtue of being in a module.\n  - As an alternative, you can `import * as ...` the module to get all of them in a single object.\n- IDEs can't provide as good suggestions for static class or namespace imported properties when you start typing property names\n- It's more difficult to statically analyze code for unused variables, etc. when they're all on the class (see: [Finding dead code (and dead types) in TypeScript](https://effectivetypescript.com/2020/10/20/tsprune)).\n\nThis rule also reports classes that have only a constructor and no fields.\nThose classes can generally be replaced with a standalone function.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nclass StaticConstants {\n  static readonly version = 42;\n\n  static isProduction() {\n    return process.env.NODE_ENV === 'production';\n  }\n}\n\nclass HelloWorldLogger {\n  constructor() {\n    console.log('Hello, world!');\n  }\n}\n\nabstract class Foo {}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nexport const version = 42;\n\nexport function isProduction() {\n  return process.env.NODE_ENV === 'production';\n}\n\nfunction logHelloWorld() {\n  console.log('Hello, world!');\n}\n\nabstract class Foo {\n  abstract prop: string;\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Alternatives\n\n### Individual Exports (Recommended)\n\nInstead of using a static utility class we recommend you individually export the utilities from your module.\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nexport class Utilities {\n  static util1() {\n    return Utilities.util3();\n  }\n\n  static util2() {\n    /* ... */\n  }\n\n  static util3() {\n    /* ... */\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nexport function util1() {\n  return util3();\n}\n\nexport function util2() {\n  /* ... */\n}\n\nexport function util3() {\n  /* ... */\n}\n```\n\n</TabItem>\n</Tabs>\n\n### Namespace Imports (Not Recommended)\n\nIf you strongly prefer to have all constructs from a module available as properties of a single object, you can `import * as` the module.\nThis is known as a \"namespace import\".\nNamespace imports are sometimes preferable because they keep all properties nested and don't need to be changed as you start or stop using various properties from the module.\n\nHowever, namespace imports are impacted by these downsides:\n\n- They also don't play as well with tree shaking in modern bundlers\n- They require a name prefix before each property's usage\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\n// utilities.ts\nexport class Utilities {\n  static sayHello() {\n    console.log('Hello, world!');\n  }\n}\n\n// consumers.ts\nimport { Utilities } from './utilities';\n\nUtilities.sayHello();\n```\n\n</TabItem>\n<TabItem value=\"⚠️ Namespace Imports\">\n\n```ts\n// utilities.ts\nexport function sayHello() {\n  console.log('Hello, world!');\n}\n\n// consumers.ts\nimport * as utilities from './utilities';\n\nutilities.sayHello();\n```\n\n</TabItem>\n<TabItem value=\"✅ Standalone Imports\">\n\n```ts\n// utilities.ts\nexport function sayHello() {\n  console.log('Hello, world!');\n}\n\n// consumers.ts\nimport { sayHello } from './utilities';\n\nsayHello();\n```\n\n</TabItem>\n</Tabs>\n\n### Notes on Mutating Variables\n\nOne case you need to be careful of is exporting mutable variables.\nWhile class properties can be mutated externally, exported variables are always constant.\nThis means that importers can only ever read the first value they are assigned and cannot write to the variables.\n\nNeeding to write to an exported variable is very rare and is generally considered a code smell.\nIf you do need it you can accomplish it using getter and setter functions:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nexport class Utilities {\n  static mutableCount = 1;\n\n  static incrementCount() {\n    Utilities.mutableCount += 1;\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nlet mutableCount = 1;\n\nexport function getMutableCount() {\n  return mutableField;\n}\n\nexport function incrementCount() {\n  mutableField += 1;\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\nThis rule normally bans classes that are empty (have no constructor or fields).\nThe rule's options each add an exemption for a specific type of class.\n\n### `allowConstructorOnly`\n\n{/* insert option description */}\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowConstructorOnly\": true }'\nclass NoFields {}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowConstructorOnly\": true }'\nclass NoFields {\n  constructor() {\n    console.log('Hello, world!');\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `allowEmpty`\n\n{/* insert option description */}\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowEmpty\": true }'\nclass NoFields {\n  constructor() {\n    console.log('Hello, world!');\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowEmpty\": true }'\nclass NoFields {}\n```\n\n</TabItem>\n</Tabs>\n\n### `allowStaticOnly`\n\n{/* insert option description */}\n\n:::caution\nWe strongly recommend against the `allowStaticOnly` exemption.\nIt works against this rule's primary purpose of discouraging classes used only for static members.\n:::\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowStaticOnly\": true }'\nclass EmptyClass {}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowStaticOnly\": true }'\nclass NotEmptyClass {\n  static version = 42;\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `allowWithDecorator`\n\n{/* insert option description */}\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowWithDecorator\": true }'\nclass Constants {\n  static readonly version = 42;\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowWithDecorator\": true }'\n@logOnRead()\nclass Constants {\n  static readonly version = 42;\n}\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf your project was set up before modern class and namespace practices, and you don't have the time to switch over, you might not be practically able to use this rule.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n"
        }
    ]
}