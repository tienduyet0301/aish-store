{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/sort-type-constituents.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce constituents of a type union/intersection to be sorted alphabetically.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/sort-type-constituents** for documentation.\n\n:::danger Deprecated\nThis rule has been deprecated in favor of the [`perfectionist/sort-intersection-types`](https://perfectionist.dev/rules/sort-intersection-types) and [`perfectionist/sort-union-types`](https://perfectionist.dev/rules/sort-union-types) rules.\n\nSee [Docs: Deprecate sort-type-constituents in favor of eslint-plugin-perfectionist](https://github.com/typescript-eslint/typescript-eslint/issues/8915) and [eslint-plugin: Feature freeze naming and sorting stylistic rules](https://github.com/typescript-eslint/typescript-eslint/issues/8792) for more information.\n:::\n\nSorting union (`|`) and intersection (`&`) types can help:\n\n- keep your codebase standardized\n- find repeated types\n- reduce diff churn\n\nThis rule reports on any types that aren't sorted alphabetically.\n\n> Types are sorted case-insensitively and treating numbers like a human would, falling back to character code sorting in case of ties.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\ntype T1 = B | A;\n\ntype T2 = { b: string } & { a: string };\n\ntype T3 = [1, 2, 4] & [1, 2, 3];\n\ntype T4 =\n  | [1, 2, 4]\n  | [1, 2, 3]\n  | { b: string }\n  | { a: string }\n  | (() => void)\n  | (() => string)\n  | 'b'\n  | 'a'\n  | 'b'\n  | 'a'\n  | readonly string[]\n  | readonly number[]\n  | string[]\n  | number[]\n  | B\n  | A\n  | string\n  | any;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\ntype T1 = A | B;\n\ntype T2 = { a: string } & { b: string };\n\ntype T3 = [1, 2, 3] & [1, 2, 4];\n\ntype T4 =\n  | A\n  | B\n  | number[]\n  | string[]\n  | any\n  | string\n  | readonly number[]\n  | readonly string[]\n  | 'a'\n  | 'a'\n  | 'b'\n  | 'b'\n  | (() => string)\n  | (() => void)\n  | { a: string }\n  | { b: string }\n  | [1, 2, 3]\n  | [1, 2, 4];\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `caseSensitive`\n\n{/* insert option description */}\n\nExamples of code with `{ \"caseSensitive\": true }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"caseSensitive\": true }'\ntype T = 'DeletedAt' | 'DeleteForever';\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"caseSensitive\": true }'\ntype T = 'DeleteForever' | 'DeletedAt';\n```\n\n</TabItem>\n</Tabs>\n\n### `checkIntersections`\n\n{/* insert option description */}\n\nExamples of code with `{ \"checkIntersections\": true }` (the default):\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"checkIntersections\": true }'\ntype ExampleIntersection = B & A;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"checkIntersections\": true }'\ntype ExampleIntersection = A & B;\n```\n\n</TabItem>\n</Tabs>\n\n### `checkUnions`\n\n{/* insert option description */}\n\nExamples of code with `{ \"checkUnions\": true }` (the default):\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"checkUnions\": true }'\ntype ExampleUnion = B | A;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"checkUnions\": true }'\ntype ExampleUnion = A | B;\n```\n\n</TabItem>\n</Tabs>\n\n### `groupOrder`\n\n{/* insert option description */}\n\nEach constituent of the type is placed into a group, and then the rule sorts alphabetically within each group.\nThe ordering of groups is determined by this option.\n\n- `conditional` - Conditional types (`A extends B ? C : D`)\n- `function` - Function and constructor types (`() => void`, `new () => type`)\n- `import` - Import types (`import('path')`)\n- `intersection` - Intersection types (`A & B`)\n- `keyword` - Keyword types (`any`, `string`, etc)\n- `literal` - Literal types (`1`, `'b'`, `true`, etc)\n- `named` - Named types (`A`, `A['prop']`, `B[]`, `Array<C>`)\n- `object` - Object types (`{ a: string }`, `{ [key: string]: number }`)\n- `operator` - Operator types (`keyof A`, `typeof B`, `readonly C[]`)\n- `tuple` - Tuple types (`[A, B, C]`)\n- `union` - Union types (`A | B`)\n- `nullish` - `null` and `undefined`\n\nFor example, configuring the rule with `{ \"groupOrder\": [\"literal\", \"nullish\" ]}`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"groupOrder\": [\"literal\", \"nullish\" ]}'\ntype ExampleGroup = null | 123;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"groupOrder\": [\"literal\", \"nullish\" ]}'\ntype ExampleGroup = 123 | null;\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nThis rule is purely a stylistic rule for maintaining consistency in your project.\nYou can turn it off if you don't want to keep a consistent, predictable order for intersection and union types.\nHowever, keep in mind that inconsistent style can harm readability in a project.\n"
        }
    ]
}