{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/prefer-literal-enum-member.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require all enum members to be literal values.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/prefer-literal-enum-member** for documentation.\n\nTypeScript allows the value of an enum member to be many different kinds of valid JavaScript expressions.\nHowever, because enums create their own scope whereby each enum member becomes a variable in that scope, developers are often surprised at the resultant values.\nFor example:\n\n```ts\nconst imOutside = 2;\nconst b = 2;\nenum Foo {\n  outer = imOutside,\n  a = 1,\n  b = a,\n  c = b,\n  // does c == Foo.b == Foo.c == 1?\n  // or does c == b == 2?\n}\n```\n\n> The answer is that `Foo.c` will be `1` at runtime [[TypeScript playground](https://www.typescriptlang.org/play/#src=const%20imOutside%20%3D%202%3B%0D%0Aconst%20b%20%3D%202%3B%0D%0Aenum%20Foo%20%7B%0D%0A%20%20%20%20outer%20%3D%20imOutside%2C%0D%0A%20%20%20%20a%20%3D%201%2C%0D%0A%20%20%20%20b%20%3D%20a%2C%0D%0A%20%20%20%20c%20%3D%20b%2C%0D%0A%20%20%20%20%2F%2F%20does%20c%20%3D%3D%20Foo.b%20%3D%3D%20Foo.c%20%3D%3D%201%3F%0D%0A%20%20%20%20%2F%2F%20or%20does%20c%20%3D%3D%20b%20%3D%3D%202%3F%0D%0A%7D)].\n\nTherefore, it's often better to prevent unexpected results in code by requiring the use of literal values as enum members.\nThis rule reports when an enum member is given a value that is not a literal.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nconst str = 'Test';\nconst string1 = 'string1';\nconst string2 = 'string2';\n\nenum Invalid {\n  A = str, // Variable assignment\n  B = `Interpolates ${string1} and ${string2}`, // Template literal with interpolation\n  C = 2 + 2, // Expression assignment\n  D = C, // Assignment to another enum member\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nenum Valid {\n  A, // No initializer; initialized with ascending integers starting from 0\n  B = 'TestStr', // A regular string\n  C = `A template literal string`, // A template literal without interpolation\n  D = 4, // A number\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `allowBitwiseExpressions`\n\n{/* insert option description */}\n\nExamples of code for the `{ \"allowBitwiseExpressions\": true }` option:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"allowBitwiseExpressions\": true }'\nconst x = 1;\nenum Foo {\n  A = x << 0,\n  B = x >> 0,\n  C = x >>> 0,\n  D = x | 0,\n  E = x & 0,\n  F = x ^ 0,\n  G = ~x,\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"allowBitwiseExpressions\": true }'\nenum Foo {\n  A = 1 << 0,\n  B = 1 >> 0,\n  C = 1 >>> 0,\n  D = 1 | 0,\n  E = 1 & 0,\n  F = 1 ^ 0,\n  G = ~1,\n}\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you want use anything other than simple literals as an enum value, this rule might not be for you.\n"
        }
    ]
}