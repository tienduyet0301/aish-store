{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-unsafe-enum-comparison.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891981475,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow comparing an enum value with a non-enum value.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/no-unsafe-enum-comparison** for documentation.\n\nThe TypeScript compiler can be surprisingly lenient when working with enums.\nWhile overt safety problems with enums were [resolved in TypeScript 5.0](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#all-enums-are-union-enums), some logical pitfalls remain permitted.\nFor example, it is allowed to compare enum values against non-enum values:\n\n```ts\nenum Vegetable {\n  Asparagus = 'asparagus',\n}\n\ndeclare const vegetable: Vegetable;\n\nvegetable === 'asparagus'; // No error\n```\n\nThe above code snippet should instead be written as `vegetable === Vegetable.Asparagus`.\nAllowing non-enums in comparisons subverts the point of using enums in the first place.\nBy enforcing comparisons with properly typed enums:\n\n- It makes a codebase more resilient to enum members changing values.\n- It allows for code IDEs to use the \"Rename Symbol\" feature to quickly rename an enum.\n- It aligns code to the proper enum semantics of referring to them by name and treating their values as implementation details.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nenum Fruit {\n  Apple,\n}\n\ndeclare let fruit: Fruit;\n\n// bad - comparison between enum and explicit value instead of named enum member\nfruit === 0;\n\nenum Vegetable {\n  Asparagus = 'asparagus',\n}\n\ndeclare let vegetable: Vegetable;\n\n// bad - comparison between enum and explicit value instead of named enum member\nvegetable === 'asparagus';\n\ndeclare let anyString: string;\n\n// bad - comparison between enum and non-enum value\nanyString === Vegetable.Asparagus;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nenum Fruit {\n  Apple,\n}\n\ndeclare let fruit: Fruit;\n\nfruit === Fruit.Apple;\n\nenum Vegetable {\n  Asparagus = 'asparagus',\n}\n\ndeclare let vegetable: Vegetable;\n\nvegetable === Vegetable.Asparagus;\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you don't mind enums being treated as a namespaced bag of values, rather than opaque identifiers, you likely don't need this rule.\n\nSometimes, you may want to ingest a value from an API or user input, then use it as an enum throughout your application.\nWhile validating the input, it may be appropriate to disable the rule.\nAlternately, you might consider making use of a validation library like [Zod](https://zod.dev/?id=native-enums).\nSee further discussion of this topic in [#8557](https://github.com/typescript-eslint/typescript-eslint/issues/8557).\n\nFinally, in the rare case of relying on an third party enums that are only imported as `type`s, it may be difficult to adhere to this rule.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n"
        }
    ]
}