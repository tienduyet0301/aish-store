{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/prefer-reduce-type-parameter.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce using type parameter when calling `Array#reduce` instead of using a type assertion.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/prefer-reduce-type-parameter** for documentation.\n\nIt's common to call `Array#reduce` with a generic type, such as an array or object, as the initial value.\nSince these values are empty, their types are not usable:\n\n- `[]` has type `never[]`, which can't have items pushed into it as nothing is type `never`\n- `{}` has type `{}`, which doesn't have an index signature and so can't have properties added to it\n\nA common solution to this problem is to use an `as` assertion on the initial value.\nWhile this will work, it's not the most optimal solution as type assertions have subtle effects on the underlying types that can allow bugs to slip in.\n\nA better solution is to pass the type in as a generic type argument to `Array#reduce` explicitly.\nThis means that TypeScript doesn't have to try to infer the type, and avoids the common pitfalls that come with assertions.\n\nThis rule looks for calls to `Array#reduce`, and reports if an initial value is being passed & asserted.\nIt will suggest instead pass the asserted type to `Array#reduce` as a generic type argument.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\n[1, 2, 3].reduce((arr, num) => arr.concat(num * 2), [] as number[]);\n\n['a', 'b'].reduce(\n  (accum, name) => ({\n    ...accum,\n    [name]: true,\n  }),\n  {} as Record<string, boolean>,\n);\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\n[1, 2, 3].reduce<number[]>((arr, num) => arr.concat(num * 2), []);\n\n['a', 'b'].reduce<Record<string, boolean>>(\n  (accum, name) => ({\n    ...accum,\n    [name]: true,\n  }),\n  {},\n);\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nThis rule can sometimes be difficult to work around when creating objects using a `.reduce`.\nSee [[prefer-reduce-type-parameter] unfixable reporting #3440](https://github.com/typescript-eslint/typescript-eslint/issues/3440) for more details.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n"
        }
    ]
}