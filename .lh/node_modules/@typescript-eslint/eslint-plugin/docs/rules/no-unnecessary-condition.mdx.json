{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-unnecessary-condition.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891981184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow conditionals where the type is always truthy or always falsy.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-unnecessary-condition** for documentation.\n\nAny expression being used as a condition must be able to evaluate as truthy or falsy in order to be considered \"necessary\".\nConversely, any expression that always evaluates to truthy or always evaluates to falsy, as determined by the type of the expression, is considered unnecessary and will be flagged by this rule.\n\nThe following expressions are checked:\n\n- Arguments to the `&&`, `||` and `?:` (ternary) operators\n- Conditions for `if`, `for`, `while`, and `do-while` statements\n- `case`s in `switch` statements\n- Base values of optional chain expressions\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\nfunction head<T>(items: T[]) {\n  // items can never be nullable, so this is unnecessary\n  if (items) {\n    return items[0].toUpperCase();\n  }\n}\n\nfunction foo(arg: 'bar' | 'baz') {\n  // arg is never nullable or empty string, so this is unnecessary\n  if (arg) {\n  }\n}\n\nfunction bar<T>(arg: string) {\n  // arg can never be nullish, so ?. is unnecessary\n  return arg?.length;\n}\n\n// Checks array predicate return types, where possible\n[\n  [1, 2],\n  [3, 4],\n].filter(t => t); // number[] is always truthy\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\nfunction head<T>(items: T[]) {\n  // Necessary, since items.length might be 0\n  if (items.length) {\n    return items[0].toUpperCase();\n  }\n}\n\nfunction foo(arg: string) {\n  // Necessary, since arg might be ''.\n  if (arg) {\n  }\n}\n\nfunction bar(arg?: string | null) {\n  // Necessary, since arg might be nullish\n  return arg?.length;\n}\n\n[0, 1, 2, 3].filter(t => t); // number can be truthy or falsy\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `allowConstantLoopConditions`\n\n{/* insert option description */}\n\n#### `'never'`\n\nDisallow constant conditions in loops. Same as `false`.\n\nExample of incorrect code for `{ allowConstantLoopConditions: 'never' }`:\n\n```ts option='{ \"allowConstantLoopConditions\": \"never\" }' showPlaygroundButton\nwhile (true) {\n  // ...\n}\n\nfor (; true; ) {\n  // ...\n}\n\ndo {\n  // ...\n} while (true);\n```\n\n#### `'always'`\n\nAllow constant conditions in loops. Same as `true`.\n\nExample of correct code for `{ allowConstantLoopConditions: 'always' }`:\n\n```ts option='{ \"allowConstantLoopConditions\": \"always\" }' showPlaygroundButton\nwhile (true) {\n  // ...\n}\n\nfor (; true; ) {\n  // ...\n}\n\ndo {\n  // ...\n} while (true);\n```\n\n#### `'only-allowed-literals'`\n\nPermit idiomatic constant literal conditions in `while` loop conditions.\n\nSpecifically, `true`, `false`, `0`, and `1` are allowed despite always being truthy or falsy, as these are common patterns and are not likely to represent developer errors.\n\nExample of correct code for `{ allowConstantLoopConditions: 'only-allowed-literals' }`:\n\n```ts option='{ \"allowConstantLoopConditions\": \"only-allowed-literals\" }' showPlaygroundButton\nwhile (true) {\n  // ...\n}\n```\n\nExample of incorrect code for `{ allowConstantLoopConditions: 'only-allowed-literals' }`:\n\n```ts option='{ \"allowConstantLoopConditions\": \"only-allowed-literals\" }' showPlaygroundButton\n// `alwaysTrue` has the type of `true` (which isn't allowed)\n// as only the literal value of `true` is allowed.\n\ndeclare const alwaysTrue: true;\n\nwhile (alwaysTrue) {\n  // ...\n}\n\n// not even a variable that references the value of `true` is allowed, only\n// the literal value of `true` used directly.\n\nconst thisIsTrue = true;\n\nwhile (thisIsTrue) {\n  // ...\n}\n```\n\n### `checkTypePredicates`\n\n{/* insert option description */}\n\nExample of additional incorrect code with `{ checkTypePredicates: true }`:\n\n```ts option='{ \"checkTypePredicates\": true }' showPlaygroundButton\nfunction assert(condition: unknown): asserts condition {\n  if (!condition) {\n    throw new Error('Condition is falsy');\n  }\n}\n\nassert(false); // Unnecessary; condition is always falsy.\n\nconst neverNull = {};\nassert(neverNull); // Unnecessary; condition is always truthy.\n\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\ndeclare const s: string;\n\n// Unnecessary; s is always a string.\nif (isString(s)) {\n}\n\nfunction assertIsString(value: unknown): asserts value is string {\n  if (!isString(value)) {\n    throw new Error('Value is not a string');\n  }\n}\n\nassertIsString(s); // Unnecessary; s is always a string.\n```\n\nWhether this option makes sense for your project may vary.\nSome projects may intentionally use type predicates to ensure that runtime values do indeed match the types according to TypeScript, especially in test code.\nOften, it makes sense to use eslint-disable comments in these cases, with a comment indicating why the condition should be checked at runtime, despite appearing unnecessary.\nHowever, in some contexts, it may be more appropriate to keep this option disabled entirely.\n\n### `allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing`\n\n{/* insert option description */}\n\n:::danger Deprecated\nThis option will be removed in the next major version of typescript-eslint.\n:::\n\nIf this is set to `false`, then the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.\n\nWithout `strictNullChecks`, TypeScript essentially erases `undefined` and `null` from the types. This means when this rule inspects the types from a variable, **it will not be able to tell that the variable might be `null` or `undefined`**, which essentially makes this rule useless.\n\nYou should be using `strictNullChecks` to ensure complete type-safety in your codebase.\n\nIf for some reason you cannot turn on `strictNullChecks`, but still want to use this rule - you can use this option to allow it - but know that the behavior of this rule is _undefined_ with the compiler option turned off. We will not accept bug reports if you are using this option.\n\n## When Not To Use It\n\nIf your project is not accurately typed, such as if it's in the process of being converted to TypeScript or is susceptible to [trade-offs in control flow analysis](https://github.com/Microsoft/TypeScript/issues/9998), it may be difficult to enable this rule for particularly non-type-safe areas of code.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\nThis rule has a known edge case of triggering on conditions that were modified within function calls (as side effects).\nIt is due to limitations of TypeScript's type narrowing.\nSee [#9998](https://github.com/microsoft/TypeScript/issues/9998) for details.\nWe recommend using a [type assertion](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions) in those cases.\n\n```ts\nlet condition = false as boolean;\n\nconst f = () => (condition = true);\nf();\n\nif (condition) {\n}\n```\n\n## Related To\n\n- ESLint: [no-constant-condition](https://eslint.org/docs/rules/no-constant-condition) - `no-unnecessary-condition` is essentially a stronger version of `no-constant-condition`, but requires type information.\n- [strict-boolean-expressions](./strict-boolean-expressions.mdx) - a more opinionated version of `no-unnecessary-condition`. `strict-boolean-expressions` enforces a specific code style, while `no-unnecessary-condition` is about correctness.\n"
        }
    ]
}