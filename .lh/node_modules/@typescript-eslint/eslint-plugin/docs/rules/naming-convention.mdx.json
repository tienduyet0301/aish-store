{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/naming-convention.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce naming conventions for everything across a codebase.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/naming-convention** for documentation.\n\nEnforcing naming conventions helps keep the codebase consistent, and reduces overhead when thinking about how to name a variable.\nAdditionally, a well-designed style guide can help communicate intent, such as by enforcing all private properties begin with an `_`, and all global-level constants are written in `UPPER_CASE`.\n\n:::note\nThis rule is _feature frozen_: it will no longer receive new features such as new options.\nIt still will accept bug and documentation fixes for its existing area of features and to support new TypeScript versions.\n\nStylistic rules that enforce naming and/or sorting conventions tend to grow incomprehensibly complex as increasingly obscure features are requested.\nThis rule has reached the limit of what is reasonable for the typescript-eslint project to maintain.\nSee [eslint-plugin: Feature freeze naming and sorting stylistic rules](https://github.com/typescript-eslint/typescript-eslint/issues/8792) for more information.\n:::\n\n## Examples\n\nThis rule allows you to enforce conventions for any identifier, using granular selectors to create a fine-grained style guide.\n\n:::note\n\nThis rule only needs type information in specific cases, detailed below.\n\n:::\n\n## Options\n\nThis rule accepts an array of objects, with each object describing a different naming convention.\nEach property will be described in detail below. Also see the examples section below for illustrated examples.\n\n```ts\ntype Options = {\n  // format options\n  format:\n    | (\n        | 'camelCase'\n        | 'strictCamelCase'\n        | 'PascalCase'\n        | 'StrictPascalCase'\n        | 'snake_case'\n        | 'UPPER_CASE'\n      )[]\n    | null;\n  custom?: {\n    regex: string;\n    match: boolean;\n  };\n  leadingUnderscore?:\n    | 'forbid'\n    | 'require'\n    | 'requireDouble'\n    | 'allow'\n    | 'allowDouble'\n    | 'allowSingleOrDouble';\n  trailingUnderscore?:\n    | 'forbid'\n    | 'require'\n    | 'requireDouble'\n    | 'allow'\n    | 'allowDouble'\n    | 'allowSingleOrDouble';\n  prefix?: string[];\n  suffix?: string[];\n\n  // selector options\n  selector: Selector | Selector[];\n  filter?:\n    | string\n    | {\n        regex: string;\n        match: boolean;\n      };\n  // the allowed values for these are dependent on the selector - see below\n  modifiers?: Modifiers<Selector>[];\n  types?: Types<Selector>[];\n}[];\n\n// the default config is similar to ESLint's camelcase rule but more strict\nconst defaultOptions: Options = [\n  {\n    selector: 'default',\n    format: ['camelCase'],\n    leadingUnderscore: 'allow',\n    trailingUnderscore: 'allow',\n  },\n\n  {\n    selector: 'import',\n    format: ['camelCase', 'PascalCase'],\n  },\n\n  {\n    selector: 'variable',\n    format: ['camelCase', 'UPPER_CASE'],\n    leadingUnderscore: 'allow',\n    trailingUnderscore: 'allow',\n  },\n\n  {\n    selector: 'typeLike',\n    format: ['PascalCase'],\n  },\n];\n```\n\n### Format Options\n\nEvery single selector can have the same set of format options.\nFor information about how each selector is applied, see [\"How does the rule evaluate a name's format?\"](#how-does-the-rule-evaluate-a-names-format).\n\n#### `format`\n\nThe `format` option defines the allowed formats for the identifier. This option accepts an array of the following values, and the identifier can match any of them:\n\n- `camelCase` - standard camelCase format - no underscores are allowed between characters, and consecutive capitals are allowed (i.e. both `myID` and `myId` are valid).\n- `PascalCase` - same as `camelCase`, except the first character must be upper-case.\n- `snake_case` - standard snake_case format - all characters must be lower-case, and underscores are allowed.\n- `strictCamelCase` - same as `camelCase`, but consecutive capitals are not allowed (i.e. `myId` is valid, but `myID` is not).\n- `StrictPascalCase` - same as `strictCamelCase`, except the first character must be upper-case.\n- `UPPER_CASE` - same as `snake_case`, except all characters must be upper-case.\n\nInstead of an array, you may also pass `null`. This signifies \"this selector shall not have its format checked\".\nThis can be useful if you want to enforce no particular format for a specific selector, after applying a group selector.\n\n#### `custom`\n\nThe `custom` option defines a custom regex that the identifier must (or must not) match. This option allows you to have a bit more finer-grained control over identifiers, letting you ban (or force) certain patterns and substrings.\nAccepts an object with the following properties:\n\n- `match` - true if the identifier _must_ match the `regex`, false if the identifier _must not_ match the `regex`.\n- `regex` - a string that is then passed into RegExp to create a new regular expression: `new RegExp(regex)`\n\n#### `filter`\n\nThe `filter` option operates similar to `custom`, accepting the same shaped object, except that it controls if the rest of the configuration should or should not be applied to an identifier.\n\nYou can use this to include or exclude specific identifiers from specific configurations.\n\nAccepts an object with the following properties:\n\n- `match` - true if the identifier _must_ match the `regex`, false if the identifier _must not_ match the `regex`.\n- `regex` - a string that is then passed into RegExp to create a new regular expression: `new RegExp(regex)`\n\nAlternatively, `filter` accepts a regular expression (anything accepted into `new RegExp(filter)`). In this case, it's treated as if you had passed an object with the regex and `match: true`.\n\n#### `leadingUnderscore` / `trailingUnderscore`\n\nThe `leadingUnderscore` / `trailingUnderscore` options control whether leading/trailing underscores are considered valid. Accepts one of the following values:\n\n- `allow` - existence of a single leading/trailing underscore is not explicitly enforced.\n- `allowDouble` - existence of a double leading/trailing underscore is not explicitly enforced.\n- `allowSingleOrDouble` - existence of a single or a double leading/trailing underscore is not explicitly enforced.\n- `forbid` - a leading/trailing underscore is not allowed at all.\n- `require` - a single leading/trailing underscore must be included.\n- `requireDouble` - two leading/trailing underscores must be included.\n\n#### `prefix` / `suffix`\n\nThe `prefix` / `suffix` options control which prefix/suffix strings must exist for the identifier. Accepts an array of strings.\n\nIf these are provided, the identifier must start with one of the provided values. For example, if you provide `{ prefix: ['Class', 'IFace', 'Type'] }`, then the following names are valid: `ClassBar`, `IFaceFoo`, `TypeBaz`, but the name `Bang` is not valid, as it contains none of the prefixes.\n\n**Note:** As [documented above](#format-options), the prefix is trimmed before format is validated, therefore PascalCase must be used to allow variables such as `isEnabled` using the prefix `is`.\n\n### Selector Options\n\n- `selector` allows you to specify what types of identifiers to target.\n  - Accepts one or array of selectors to define an option block that applies to one or multiple selectors.\n  - For example, if you provide `{ selector: ['function', 'variable'] }`, then it will apply the same option to variable and function nodes.\n  - See [Allowed Selectors, Modifiers and Types](#allowed-selectors-modifiers-and-types) below for the complete list of allowed selectors.\n- `modifiers` allows you to specify which modifiers to granularly apply to, such as the accessibility (`#private`/`private`/`protected`/`public`), or if the thing is `static`, etc.\n  - The name must match _all_ of the modifiers.\n  - For example, if you provide `{ modifiers: ['private','readonly','static'] }`, then it will only match something that is `private static readonly`, and something that is just `private` will not match.\n  - The following `modifiers` are allowed:\n    - `abstract`,`override`,`private`,`protected`,`readonly`,`static` - matches any member explicitly declared with the given modifier.\n    - `async` - matches any method, function, or function variable which is async via the `async` keyword (e.g. does not match functions that return promises without using `async` keyword)\n    - `const` - matches a variable declared as being `const` (`const x = 1`).\n    - `destructured` - matches a variable declared via an object destructuring pattern (`const {x, z = 2}`).\n      - Note that this does not match renamed destructured properties (`const {x: y, a: b = 2}`).\n    - `exported` - matches anything that is exported from the module.\n    - `global` - matches a variable/function declared in the top-level scope.\n    - `#private` - matches any member with a private identifier (an identifier that starts with `#`)\n    - `public` - matches any member that is either explicitly declared as `public`, or has no visibility modifier (i.e. implicitly public).\n    - `requiresQuotes` - matches any name that requires quotes as it is not a valid identifier (i.e. has a space, a dash, etc in it).\n    - `unused` - matches anything that is not used.\n- `types` allows you to specify which types to match. This option supports simple, primitive types only (`array`,`boolean`,`function`,`number`,`string`).\n  - The name must match _one_ of the types.\n  - **_NOTE - Using this option will require that you lint with type information._**\n  - For example, this lets you do things like enforce that `boolean` variables are prefixed with a verb.\n  - The following `types` are allowed:\n    - `array` matches any type assignable to `Array<unknown> | null | undefined`\n    - `boolean` matches any type assignable to `boolean | null | undefined`\n    - `function` matches any type assignable to `Function | null | undefined`\n    - `number` matches any type assignable to `number | null | undefined`\n    - `string` matches any type assignable to `string | null | undefined`\n\nThe ordering of selectors does not matter. The implementation will automatically sort the selectors to ensure they match from most-specific to least specific. It will keep checking selectors in that order until it finds one that matches the name. See [\"How does the rule automatically order selectors?\"](#how-does-the-rule-automatically-order-selectors)\n\n#### Allowed Selectors, Modifiers and Types\n\nThere are two types of selectors, individual selectors, and grouped selectors.\n\n##### Individual Selectors\n\nIndividual Selectors match specific, well-defined sets. There is no overlap between each of the individual selectors.\n\n- `classicAccessor` - matches any accessor. It refers to the methods attached to `get` and `set` syntax.\n  - Allowed `modifiers`: `abstract`, `override`, `private`, `protected`, `public`, `requiresQuotes`, `static`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `autoAccessor` - matches any auto-accessor. An auto-accessor is just a class field starting with an `accessor` keyword.\n  - Allowed `modifiers`: `abstract`, `override`, `private`, `protected`, `public`, `requiresQuotes`, `static`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `class` - matches any class declaration.\n  - Allowed `modifiers`: `abstract`, `exported`, `unused`.\n  - Allowed `types`: none.\n- `classMethod` - matches any class method. Also matches properties that have direct function expression or arrow function expression values. Does not match accessors.\n  - Allowed `modifiers`: `abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `requiresQuotes`, `static`.\n  - Allowed `types`: none.\n- `classProperty` - matches any class property. Does not match properties that have direct function expression or arrow function expression values.\n  - Allowed `modifiers`: `abstract`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `enum` - matches any enum declaration.\n  - Allowed `modifiers`: `exported`, `unused`.\n  - Allowed `types`: none.\n- `enumMember` - matches any enum member.\n  - Allowed `modifiers`: `requiresQuotes`.\n  - Allowed `types`: none.\n- `function` - matches any named function declaration or named function expression.\n  - Allowed `modifiers`: `async`, `exported`, `global`, `unused`.\n  - Allowed `types`: none.\n- `import` - matches namespace imports and default imports (i.e. does not match named imports).\n  - Allowed `modifiers`: `default`, `namespace`.\n  - Allowed `types`: none.\n- `interface` - matches any interface declaration.\n  - Allowed `modifiers`: `exported`, `unused`.\n  - Allowed `types`: none.\n- `objectLiteralMethod` - matches any object literal method. Also matches properties that have direct function expression or arrow function expression values. Does not match accessors.\n  - Allowed `modifiers`: `async`, `public`, `requiresQuotes`.\n  - Allowed `types`: none.\n- `objectLiteralProperty` - matches any object literal property. Does not match properties that have direct function expression or arrow function expression values.\n  - Allowed `modifiers`: `public`, `requiresQuotes`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `parameter` - matches any function parameter. Does not match parameter properties.\n  - Allowed `modifiers`: `destructured`, `unused`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `parameterProperty` - matches any parameter property.\n  - Allowed `modifiers`: `private`, `protected`, `public`, `readonly`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `typeAlias` - matches any type alias declaration.\n  - Allowed `modifiers`: `exported`, `unused`.\n  - Allowed `types`: none.\n- `typeMethod` - matches any object type method. Also matches properties that have direct function expression or arrow function expression values. Does not match accessors.\n  - Allowed `modifiers`: `public`, `requiresQuotes`.\n  - Allowed `types`: none.\n- `typeParameter` - matches any generic type parameter declaration.\n  - Allowed `modifiers`: `unused`.\n  - Allowed `types`: none.\n- `typeProperty` - matches any object type property. Does not match properties that have direct function expression or arrow function expression values.\n  - Allowed `modifiers`: `public`, `readonly`, `requiresQuotes`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `variable` - matches any `const` / `let` / `var` variable name.\n  - Allowed `modifiers`: `async`, `const`, `destructured`, `exported`, `global`, `unused`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n\n##### Group Selectors\n\nGroup Selectors are provided for convenience, and essentially bundle up sets of individual selectors.\n\n- `default` - matches everything.\n  - Allowed `modifiers`: all modifiers.\n  - Allowed `types`: none.\n- `accessor` - matches the same as `classicAccessor` and `autoAccessor`.\n  - Allowed `modifiers`: `abstract`, `override`, `private`, `protected`, `public`, `requiresQuotes`, `static`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `memberLike` - matches the same as `classicAccessor`, `autoAccessor`, `enumMember`, `method`, `parameterProperty`, `property`.\n  - Allowed `modifiers`: `abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.\n  - Allowed `types`: none.\n- `method` - matches the same as `classMethod`, `objectLiteralMethod`, `typeMethod`.\n  - Allowed `modifiers`: `abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.\n  - Allowed `types`: none.\n- `property` - matches the same as `classProperty`, `objectLiteralProperty`, `typeProperty`.\n  - Allowed `modifiers`: `abstract`, `async`, `override`, `#private`, `private`, `protected`, `public`, `readonly`, `requiresQuotes`, `static`.\n  - Allowed `types`: `array`, `boolean`, `function`, `number`, `string`.\n- `typeLike` - matches the same as `class`, `enum`, `interface`, `typeAlias`, `typeParameter`.\n  - Allowed `modifiers`: `abstract`, `unused`.\n  - Allowed `types`: none.\n- `variableLike` - matches the same as `function`, `parameter` and `variable`.\n  - Allowed `modifiers`: `async`, `unused`.\n  - Allowed `types`: none.\n\n## FAQ\n\nThis is a big rule, and there's a lot of docs. Here are a few clarifications that people often ask about or figure out via trial-and-error.\n\n### How does the rule evaluate a selector?\n\nEach selector is checked in the following way:\n\n1. check the `filter`\n   1. if `filter` is omitted â†’ skip this step.\n   2. if the name matches the `filter` â†’ continue evaluating this selector.\n   3. if the name does not match the `filter` â†’ skip this selector and continue to the next selector.\n2. check the `selector`\n   1. if `selector` is one individual selector â†’ the name's type must be of that type.\n   2. if `selector` is a group selector â†’ the name's type must be one of the grouped types.\n   3. if `selector` is an array of selectors â†’ apply the above for each selector in the array.\n3. check the `types`\n   1. if `types` is omitted â†’ skip this step.\n   2. if the name has a type in `types` â†’ continue evaluating this selector.\n   3. if the name does not have a type in `types` â†’ skip this selector and continue to the next selector.\n\nA name is considered to pass the config if it:\n\n1. Matches one selector and passes all of that selector's format checks.\n2. Matches no selectors.\n\nA name is considered to fail the config if it matches one selector and fails one that selector's format checks.\n\n### How does the rule automatically order selectors?\n\nEach identifier should match exactly one selector. It may match multiple group selectors - but only ever one selector.\nWith that in mind - the base sort order works out to be:\n\n1. Individual Selectors\n2. Grouped Selectors\n3. Default Selector\n\nWithin each of these categories, some further sorting occurs based on what selector options are supplied:\n\n1. `filter` is given the highest priority above all else.\n2. `types`\n3. `modifiers`\n4. everything else\n\nFor example, if you provide the following config:\n\n```ts\n[\n  /* 1 */ { selector: 'default', format: ['camelCase'] },\n  /* 2 */ { selector: 'variable', format: ['snake_case'] },\n  /* 3 */ { selector: 'variable', types: ['boolean'], format: ['UPPER_CASE'] },\n  /* 4 */ { selector: 'variableLike', format: ['PascalCase'] },\n];\n```\n\nThen for the code `const x = 1`, the rule will validate the selectors in the following order: `3`, `2`, `4`, `1`.\nTo clearly spell it out:\n\n- (3) is tested first because it has `types` and is an individual selector.\n- (2) is tested next because it is an individual selector.\n- (4) is tested next as it is a grouped selector.\n- (1) is tested last as it is the base default selector.\n\nIts worth noting that whilst this order is applied, all selectors may not run on a name.\nThis is explained in [\"How does the rule evaluate a name's format?\"](#how-does-the-rule-evaluate-a-names-format)\n\n### How does the rule evaluate a name's format?\n\nWhen the format of an identifier is checked, it is checked in the following order:\n\n1. validate leading underscore\n1. validate trailing underscore\n1. validate prefix\n1. validate suffix\n1. validate custom\n1. validate format\n\nFor steps 1-4, if the identifier matches the option, the matching part will be removed.\nThis is done so that you can apply formats like PascalCase without worrying about prefixes or underscores causing it to not match.\n\nOne final note is that if the name were to become empty via this trimming process, it is considered to match all `format`s. An example of where this might be useful is for generic type parameters, where you want all names to be prefixed with `T`, but also want to allow for the single character `T` name.\n\nHere are some examples to help illustrate\n\nName: `_IMyInterface`\nSelector:\n\n```json\n{\n  \"leadingUnderscore\": \"require\",\n  \"prefix\": [\"I\"],\n  \"format\": [\"UPPER_CASE\", \"StrictPascalCase\"]\n}\n```\n\n1. `name = _IMyInterface`\n1. validate leading underscore\n   1. config is provided\n   1. check name â†’ pass\n   1. Trim underscore â†’ `name = IMyInterface`\n1. validate trailing underscore\n   1. config is not provided â†’ skip\n1. validate prefix\n   1. config is provided\n   1. check name â†’ pass\n   1. Trim prefix â†’ `name = MyInterface`\n1. validate suffix\n   1. config is not provided â†’ skip\n1. validate custom\n   1. config is not provided â†’ skip\n1. validate format\n   1. for each format...\n      1. `format = 'UPPER_CASE'`\n         1. check format â†’ fail.\n            - Important to note that if you supply multiple formats - the name only needs to match _one_ of them!\n      1. `format = 'StrictPascalCase'`\n         1. check format â†’ success.\n1. **_success_**\n\nName: `IMyInterface`\nSelector:\n\n```json\n{\n  \"format\": [\"StrictPascalCase\"],\n  \"trailingUnderscore\": \"allow\",\n  \"custom\": {\n    \"regex\": \"^I[A-Z]\",\n    \"match\": false\n  }\n}\n```\n\n1. `name = IMyInterface`\n1. validate leading underscore\n   1. config is not provided â†’ skip\n1. validate trailing underscore\n   1. config is provided\n   1. check name â†’ pass\n   1. Trim underscore â†’ `name = IMyInterface`\n1. validate prefix\n   1. config is not provided â†’ skip\n1. validate suffix\n   1. config is not provided â†’ skip\n1. validate custom\n   1. config is provided\n   1. `regex = new RegExp(\"^I[A-Z]\")`\n   1. `regex.test(name) === custom.match`\n   1. **_fail_** â†’ report and exit\n\n### What happens if I provide a `modifiers` to a Group Selector?\n\nSome group selectors accept `modifiers`. For the most part these will work exactly the same as with individual selectors.\nThere is one exception to this in that a modifier might not apply to all individual selectors covered by a group selector.\n\nFor example - `memberLike` includes the `enumMember` selector, and it allows the `protected` modifier.\nAn `enumMember` can never ever be `protected`, which means that the following config will never match any `enumMember`:\n\n```json\n{\n  \"selector\": \"memberLike\",\n  \"modifiers\": [\"protected\"]\n}\n```\n\nTo help with matching, members that cannot specify an accessibility will always have the `public` modifier. This means that the following config will always match any `enumMember`:\n\n```json\n{\n  \"selector\": \"memberLike\",\n  \"modifiers\": [\"public\"]\n}\n```\n\n## Examples\n\n### Enforce that all variables, functions and properties follow are camelCase\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    { \"selector\": \"variableLike\", \"format\": [\"camelCase\"] }\n  ]\n}\n```\n\n### Enforce that private members are prefixed with an underscore\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"memberLike\",\n      \"modifiers\": [\"private\"],\n      \"format\": [\"camelCase\"],\n      \"leadingUnderscore\": \"require\"\n    }\n  ]\n}\n```\n\n### Enforce that boolean variables are prefixed with an allowed verb\n\n**Note:** As [documented above](#format-options), the prefix is trimmed before format is validated, thus PascalCase must be used to allow variables such as `isEnabled`.\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"variable\",\n      \"types\": [\"boolean\"],\n      \"format\": [\"PascalCase\"],\n      \"prefix\": [\"is\", \"should\", \"has\", \"can\", \"did\", \"will\"]\n    }\n  ]\n}\n```\n\n### Enforce that all variables are either in camelCase or UPPER_CASE\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"variable\",\n      \"format\": [\"camelCase\", \"UPPER_CASE\"]\n    }\n  ]\n}\n```\n\n### Enforce that all const variables are in UPPER_CASE\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"variable\",\n      \"modifiers\": [\"const\"],\n      \"format\": [\"UPPER_CASE\"]\n    }\n  ]\n}\n```\n\n### Enforce that type parameters (generics) are prefixed with `T`\n\nThis allows you to emulate the old `generic-type-naming` rule.\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"typeParameter\",\n      \"format\": [\"PascalCase\"],\n      \"prefix\": [\"T\"]\n    }\n  ]\n}\n```\n\n### Enforce that interface names do not begin with an `I`\n\nThis allows you to emulate the old `interface-name-prefix` rule.\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"interface\",\n      \"format\": [\"PascalCase\"],\n      \"custom\": {\n        \"regex\": \"^I[A-Z]\",\n        \"match\": false\n      }\n    }\n  ]\n}\n```\n\n### Enforce that function names are either in camelCase or PascalCase\n\nFunction names are typically camelCase, but UI library components (especially JSX, such as React and Solid) use PascalCase to distinguish them from intrinsic elements. If you are writing function components, consider allowing both camelCase and PascalCase for functions.\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"function\",\n      \"format\": [\"camelCase\", \"PascalCase\"]\n    }\n  ]\n}\n```\n\n### Enforce that variable and function names are in camelCase\n\nThis allows you to lint multiple type with same pattern.\n\n```json\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": [\"variable\", \"function\"],\n      \"format\": [\"camelCase\"],\n      \"leadingUnderscore\": \"allow\"\n    }\n  ]\n}\n```\n\n### Ignore properties that **_require_** quotes\n\nSometimes you have to use a quoted name that breaks the convention (for example, HTTP headers).\nIf this is a common thing in your codebase, then you have a few options.\n\nIf you simply want to allow all property names that require quotes, you can use the `requiresQuotes` modifier to match any property name that _requires_ quoting, and use `format: null` to ignore the name.\n\n```jsonc\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": [\n        \"classProperty\",\n        \"objectLiteralProperty\",\n        \"typeProperty\",\n        \"classMethod\",\n        \"objectLiteralMethod\",\n        \"typeMethod\",\n        \"accessor\",\n        \"enumMember\",\n      ],\n      \"format\": null,\n      \"modifiers\": [\"requiresQuotes\"],\n    },\n  ],\n}\n```\n\nIf you have a small and known list of exceptions, you can use the `filter` option to ignore these specific names only:\n\n```jsonc\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"property\",\n      \"format\": [\"strictCamelCase\"],\n      \"filter\": {\n        // you can expand this regex to add more allowed names\n        \"regex\": \"^(Property-Name-One|Property-Name-Two)$\",\n        \"match\": false,\n      },\n    },\n  ],\n}\n```\n\nYou can use the `filter` option to ignore names with specific characters:\n\n```jsonc\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"property\",\n      \"format\": [\"strictCamelCase\"],\n      \"filter\": {\n        // you can expand this regex as you find more cases that require quoting that you want to allow\n        \"regex\": \"[- ]\",\n        \"match\": false,\n      },\n    },\n  ],\n}\n```\n\nNote that there is no way to ignore any name that is quoted - only names that are required to be quoted.\nThis is intentional - adding quotes around a name is not an escape hatch for proper naming.\nIf you want an escape hatch for a specific name - you should can use an [`eslint-disable` comment](https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments).\n\n### Ignore destructured names\n\nSometimes you might want to allow destructured properties to retain their original name, even if it breaks your naming convention.\n\nYou can use the `destructured` modifier to match these names, and explicitly set `format: null` to apply no formatting:\n\n```jsonc\n{\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"variable\",\n      \"modifiers\": [\"destructured\"],\n      \"format\": null,\n    },\n  ],\n}\n```\n\n### Enforce the codebase follows ESLint's `camelcase` conventions\n\n```json\n{\n  \"camelcase\": \"off\",\n  \"@typescript-eslint/naming-convention\": [\n    \"error\",\n    {\n      \"selector\": \"default\",\n      \"format\": [\"camelCase\"]\n    },\n\n    {\n      \"selector\": \"variable\",\n      \"format\": [\"camelCase\", \"UPPER_CASE\"]\n    },\n    {\n      \"selector\": \"parameter\",\n      \"format\": [\"camelCase\"],\n      \"leadingUnderscore\": \"allow\"\n    },\n\n    {\n      \"selector\": \"memberLike\",\n      \"modifiers\": [\"private\"],\n      \"format\": [\"camelCase\"],\n      \"leadingUnderscore\": \"require\"\n    },\n\n    {\n      \"selector\": \"typeLike\",\n      \"format\": [\"PascalCase\"]\n    }\n  ]\n}\n```\n\n## When Not To Use It\n\nThis rule can be very strict.\nIf you don't have strong needs for enforcing naming conventions, we recommend using it only to flag very egregious violations of your naming standards.\nConsider documenting your naming conventions and enforcing them in code review if you have processes like that.\n\nIf you do not want to enforce naming conventions for anything, you can disable this rule.\n\nHowever, keep in mind that inconsistent style can harm readability in a project.\nWe recommend that if you care about naming conventions, pick a single option for this rule that works best for your project.\n"
        }
    ]
}