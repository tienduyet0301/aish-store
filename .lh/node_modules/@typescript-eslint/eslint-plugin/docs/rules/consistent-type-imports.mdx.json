{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/consistent-type-imports.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce consistent usage of type imports.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/consistent-type-imports** for documentation.\n\nTypeScript allows specifying a `type` keyword on imports to indicate that the export exists only in the type system, not at runtime.\nThis allows transpilers to drop imports without knowing the types of the dependencies.\n\n> See [Blog > Consistent Type Exports and Imports: Why and How](/blog/consistent-type-imports-and-exports-why-and-how) for more details.\n\n## Options\n\n### `prefer`\n\n{/* insert option description */}\n\nValid values for `prefer` are:\n\n- `type-imports` will enforce that you always use `import type Foo from '...'` except referenced by metadata of decorators. It is the default.\n- `no-type-imports` will enforce that you always use `import Foo from '...'`.\n\nExamples of **correct** code with `{prefer: 'type-imports'}`, and **incorrect** code with `{prefer: 'no-type-imports'}`.\n\n```ts option='{ \"prefer\": \"type-imports\" }' showPlaygroundButton\nimport type { Foo } from 'Foo';\nimport type Bar from 'Bar';\ntype T = Foo;\nconst x: Bar = 1;\n```\n\nExamples of **incorrect** code with `{prefer: 'type-imports'}`, and **correct** code with `{prefer: 'no-type-imports'}`.\n\n```ts option='{ \"prefer\": \"type-imports\" }' showPlaygroundButton\nimport { Foo } from 'Foo';\nimport Bar from 'Bar';\ntype T = Foo;\nconst x: Bar = 1;\n```\n\n### `fixStyle`\n\n{/* insert option description */}\n\nValid values for `fixStyle` are:\n\n- `separate-type-imports` will add the type keyword after the import keyword `import type { A } from '...'`. It is the default.\n- `inline-type-imports` will inline the type keyword `import { type A } from '...'` and is only available in TypeScript 4.5 and onwards. See [documentation here](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html#type-modifiers-on-import-names 'TypeScript 4.5 documentation on type modifiers and import names').\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nimport { Foo } from 'Foo';\nimport Bar from 'Bar';\ntype T = Foo;\nconst x: Bar = 1;\n```\n\n</TabItem>\n<TabItem value=\"✅ With `separate-type-imports`\">\n\n```ts option='{ \"fixStyle\": \"separate-type-imports\" }'\nimport type { Foo } from 'Foo';\nimport type Bar from 'Bar';\ntype T = Foo;\nconst x: Bar = 1;\n```\n\n</TabItem>\n<TabItem value=\"✅ With `inline-type-imports`\">\n\n```ts option='{ \"fixStyle\": \"inline-type-imports\" }'\nimport { type Foo } from 'Foo';\nimport type Bar from 'Bar';\ntype T = Foo;\nconst x: Bar = 1;\n```\n\n</TabItem>\n</Tabs>\n\n### `disallowTypeAnnotations`\n\n{/* insert option description */}\n\nExamples of **incorrect** code with `{disallowTypeAnnotations: true}`:\n\n```ts option='{ \"disallowTypeAnnotations\": true }' showPlaygroundButton\ntype T = import('Foo').Foo;\nconst x: import('Bar') = 1;\n```\n\n## Caveat: `@decorators` + `experimentalDecorators: true` + `emitDecoratorMetadata: true`\n\n:::note\nIf you are using `experimentalDecorators: false` (eg [TypeScript v5.0's stable decorators](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#decorators)) then the rule will always report errors as expected.\nThis caveat **only** applies to `experimentalDecorators: true`\n:::\n\nThe rule will **_not_** report any errors in files _that contain decorators_ when **both** `experimentalDecorators` and `emitDecoratorMetadata` are turned on.\n\n> See [Blog > Changes to consistent-type-imports when used with legacy decorators and decorator metadata](/blog/changes-to-consistent-type-imports-with-decorators) for more details.\n\nIf you are using [type-aware linting](/getting-started/typed-linting) then we will automatically infer your setup from your tsconfig and you should not need to configure anything.\nOtherwise you can explicitly tell our tooling to analyze your code as if the compiler option was turned on by setting both [`parserOptions.emitDecoratorMetadata = true`](/packages/parser/#emitdecoratormetadata) and [`parserOptions.experimentalDecorators = true`](/packages/parser/#experimentaldecorators).\n\n## Comparison with `importsNotUsedAsValues` / `verbatimModuleSyntax`\n\n[`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) was introduced in TypeScript v5.0 (as a replacement for `importsNotUsedAsValues`).\nThis rule and `verbatimModuleSyntax` _mostly_ behave in the same way.\nThere are a few behavior differences:\n| Situation | `consistent-type-imports` (ESLint) | `verbatimModuleSyntax` (TypeScript) |\n| -------------------------------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------- |\n| Unused imports | Ignored (consider using [`@typescript-eslint/no-unused-vars`](/rules/no-unused-vars)) | Type error |\n| Usage with `emitDecoratorMetadata` & `experimentalDecorations` | Ignores files that contain decorators | Reports on files that contain decorators |\n| Failures detected | Does not fail `tsc` build; can be auto-fixed with `--fix` | Fails `tsc` build; cannot be auto-fixed on the command-line |\n| `import { type T } from 'T';` | TypeScript will emit nothing (it \"elides\" the import) | TypeScript emits `import {} from 'T'` |\n\nBecause there are some differences, using both this rule and `verbatimModuleSyntax` at the same time can lead to conflicting errors.\nAs such we recommend that you only ever use one _or_ the other -- never both.\n\n## When Not To Use It\n\nIf you specifically want to use both import kinds for stylistic reasons, or don't wish to enforce one style over the other, you can avoid this rule.\n\nHowever, keep in mind that inconsistent style can harm readability in a project.\nWe recommend picking a single option for this rule that works best for your project.\n\n## Related To\n\n- [`no-import-type-side-effects`](./no-import-type-side-effects.mdx)\n- [`import/consistent-type-specifier-style`](https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/consistent-type-specifier-style.md)\n- [`import/no-duplicates` with `{\"prefer-inline\": true}`](https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/no-duplicates.md#inline-type-imports)\n"
        }
    ]
}