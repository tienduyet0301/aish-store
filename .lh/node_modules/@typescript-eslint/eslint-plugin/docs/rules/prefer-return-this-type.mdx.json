{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/prefer-return-this-type.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce that `this` is used when only `this` type is returned.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/prefer-return-this-type** for documentation.\n\n[Method chaining](https://en.wikipedia.org/wiki/Method_chaining) is a common pattern in OOP languages and TypeScript provides a special [polymorphic `this` type](https://www.typescriptlang.org/docs/handbook/2/classes.html#this-types) to facilitate it.\nClass methods that explicitly declare a return type of the class name instead of `this` make it harder for extending classes to call that method: the returned object will be typed as the base class, not the derived class.\n\nThis rule reports when a class method declares a return type of that class name instead of `this`.\n\n```ts\nclass Animal {\n  eat(): Animal {\n    //   ~~~~~~\n    // Either removing this type annotation or replacing\n    // it with `this` would remove the type error below.\n    console.log(\"I'm moving!\");\n    return this;\n  }\n}\n\nclass Cat extends Animal {\n  meow(): Cat {\n    console.log('Meow~');\n    return this;\n  }\n}\n\nconst cat = new Cat();\ncat.eat().meow();\n//        ~~~~\n// Error: Property 'meow' does not exist on type 'Animal'.\n// because `eat` returns `Animal` and not all animals meow.\n```\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\nclass Foo {\n  f1(): Foo {\n    return this;\n  }\n  f2 = (): Foo => {\n    return this;\n  };\n  f3(): Foo | undefined {\n    return Math.random() > 0.5 ? this : undefined;\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\nclass Foo {\n  f1(): this {\n    return this;\n  }\n  f2() {\n    return this;\n  }\n  f3 = (): this => {\n    return this;\n  };\n  f4 = () => {\n    return this;\n  };\n}\n\nclass Base {}\nclass Derived extends Base {\n  f(): Base {\n    return this;\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf you don't use method chaining or explicit return values, you can safely turn this rule off.\n"
        }
    ]
}