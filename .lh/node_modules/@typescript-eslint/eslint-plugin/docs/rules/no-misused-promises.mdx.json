{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-misused-promises.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891980694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow Promises in places not designed to handle them.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-misused-promises** for documentation.\n\nThis rule forbids providing Promises to logical locations such as if statements in places where the TypeScript compiler allows them but they are not handled properly.\nThese situations can often arise due to a missing `await` keyword or just a misunderstanding of the way async\nfunctions are handled/awaited.\n\n:::tip\n`no-misused-promises` only detects code that provides Promises to incorrect _logical_ locations.\nSee [`no-floating-promises`](./no-floating-promises.mdx) for detecting unhandled Promise _statements_.\n:::\n\n## Options\n\n### `checksConditionals`\n\n{/* insert option description */}\n\nIf you don't want to check conditionals, you can configure the rule with `\"checksConditionals\": false`:\n\n```json\n{\n  \"@typescript-eslint/no-misused-promises\": [\n    \"error\",\n    {\n      \"checksConditionals\": false\n    }\n  ]\n}\n```\n\nDoing so prevents the rule from looking at code like `if (somePromise)`.\n\n### `checksVoidReturn`\n\n{/* insert option description */}\n\nLikewise, if you don't want to check functions that return promises where a void return is\nexpected, your configuration will look like this:\n\n```json\n{\n  \"@typescript-eslint/no-misused-promises\": [\n    \"error\",\n    {\n      \"checksVoidReturn\": false\n    }\n  ]\n}\n```\n\nYou can disable selective parts of the `checksVoidReturn` option by providing an object that disables specific checks. For example, if you don't mind that passing a `() => Promise<void>` to a `() => void` parameter or JSX attribute can lead to a floating unhandled Promise:\n\n```json\n{\n  \"@typescript-eslint/no-misused-promises\": [\n    \"error\",\n    {\n      \"checksVoidReturn\": {\n        \"arguments\": false,\n        \"attributes\": false\n      }\n    }\n  ]\n}\n```\n\nThe following sub-options are supported:\n\n#### `arguments`\n\nDisables checking an asynchronous function passed as argument where the parameter type expects a function that returns `void`.\n\n#### `attributes`\n\nDisables checking an asynchronous function passed as a JSX attribute expected to be a function that returns `void`.\n\n#### `inheritedMethods`\n\nDisables checking an asynchronous method in a type that extends or implements another type expecting that method to return `void`.\n\n:::note\nFor now, `no-misused-promises` only checks _named_ methods against extended/implemented types: that is, call/construct/index signatures are ignored. Call signatures are not required in TypeScript to be consistent with one another, and construct signatures cannot be `async` in the first place. Index signature checking may be implemented in the future.\n:::\n\n#### `properties`\n\nDisables checking an asynchronous function passed as an object property expected to be a function that returns `void`.\n\n#### `returns`\n\nDisables checking an asynchronous function returned in a function whose return type is a function that returns `void`.\n\n#### `variables`\n\nDisables checking an asynchronous function used as a variable whose return type is a function that returns `void`.\n\n### `checksSpreads`\n\n{/* insert option description */}\n\nIf you don't want to check object spreads, you can add this configuration:\n\n```json\n{\n  \"@typescript-eslint/no-misused-promises\": [\n    \"error\",\n    {\n      \"checksSpreads\": false\n    }\n  ]\n}\n```\n\n## Examples\n\n### `checksConditionals`\n\n{/* insert option description */}\n\nExamples of code for this rule with `checksConditionals: true`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"checksConditionals\": true }'\nconst promise = Promise.resolve('value');\n\nif (promise) {\n  // Do something\n}\n\nconst val = promise ? 123 : 456;\n\n[1, 2, 3].filter(() => promise);\n\nwhile (promise) {\n  // Do something\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"checksConditionals\": true }'\nconst promise = Promise.resolve('value');\n\n// Always `await` the Promise in a conditional\nif (await promise) {\n  // Do something\n}\n\nconst val = (await promise) ? 123 : 456;\n\nconst returnVal = await promise;\n[1, 2, 3].filter(() => returnVal);\n\nwhile (await promise) {\n  // Do something\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `checksVoidReturn`\n\n{/* insert option description */}\n\nExamples of code for this rule with `checksVoidReturn: true`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"checksVoidReturn\": true }'\n[1, 2, 3].forEach(async value => {\n  await fetch(`/${value}`);\n});\n\nnew Promise<void>(async (resolve, reject) => {\n  await fetch('/');\n  resolve();\n});\n\ndocument.addEventListener('click', async () => {\n  console.log('synchronous call');\n  await fetch('/');\n  console.log('synchronous call');\n});\n\ninterface MySyncInterface {\n  setThing(): void;\n}\nclass MyClass implements MySyncInterface {\n  async setThing(): Promise<void> {\n    this.thing = await fetchThing();\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"checksVoidReturn\": true }'\n// for-of puts `await` in outer context\nfor (const value of [1, 2, 3]) {\n  await doSomething(value);\n}\n\n// If outer context is not `async`, handle error explicitly\nPromise.all(\n  [1, 2, 3].map(async value => {\n    await doSomething(value);\n  }),\n).catch(handleError);\n\n// Use an async IIFE wrapper\nnew Promise((resolve, reject) => {\n  // combine with `void` keyword to tell `no-floating-promises` rule to ignore unhandled rejection\n  void (async () => {\n    await doSomething();\n    resolve();\n  })();\n});\n\n// Name the async wrapper to call it later\ndocument.addEventListener('click', () => {\n  const handler = async () => {\n    await doSomething();\n    otherSynchronousCall();\n  };\n\n  try {\n    synchronousCall();\n  } catch (err) {\n    handleSpecificError(err);\n  }\n\n  handler().catch(handleError);\n});\n\ninterface MyAsyncInterface {\n  setThing(): Promise<void>;\n}\nclass MyClass implements MyAsyncInterface {\n  async setThing(): Promise<void> {\n    this.thing = await fetchThing();\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `checksSpreads`\n\n{/* insert option description */}\n\nExamples of code for this rule with `checksSpreads: true`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"checksSpreads\": true }'\nconst getData = () => fetch('/');\n\nconsole.log({ foo: 42, ...getData() });\n\nconst awaitData = async () => {\n  await fetch('/');\n};\n\nconsole.log({ foo: 42, ...awaitData() });\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"checksSpreads\": true }'\nconst getData = () => fetch('/');\n\nconsole.log({ foo: 42, ...(await getData()) });\n\nconst awaitData = async () => {\n  await fetch('/');\n};\n\nconsole.log({ foo: 42, ...(await awaitData()) });\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nThis rule can be difficult to enable on large existing projects that set up many misused Promises.\nAlternately, if you're not worried about crashes from floating or misused Promises -such as if you have global unhandled Promise handlers registered- then in some cases it may be safe to not use this rule.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\n## Further Reading\n\n- [TypeScript void function assignability](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void)\n\n## Related To\n\n- [`no-floating-promises`](./no-floating-promises.mdx)\n"
        }
    ]
}