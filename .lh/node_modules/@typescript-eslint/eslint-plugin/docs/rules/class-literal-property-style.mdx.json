{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/class-literal-property-style.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce that literals on classes are exposed in a consistent style.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/class-literal-property-style** for documentation.\n\nSome TypeScript applications store literal values on classes using fields with the `readonly` modifier to prevent them from being reassigned.\nWhen writing TypeScript libraries that could be used by JavaScript users, however, it's typically safer to expose these literals using `getter`s, since the `readonly` modifier is enforced at compile type.\n\nThis rule aims to ensure that literals exposed by classes are done so consistently, in one of the two style described above.\nBy default this rule prefers the `fields` style as it means JS doesn't have to setup & teardown a function closure.\n\n## Options\n\n:::note\nThis rule only checks for constant _literal_ values (string, template string, number, bigint, boolean, regexp, null). It does not check objects or arrays, because a readonly field behaves differently to a getter in those cases. It also does not check functions, as it is a common pattern to use readonly fields with arrow function values as auto-bound methods.\nThis is because these types can be mutated and carry with them more complex implications about their usage.\n:::\n\n### `\"fields\"`\n\nThis style checks for any getter methods that return literal values, and requires them to be defined using fields with the `readonly` modifier instead.\n\nExamples of code with the `fields` style:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='\"fields\"'\nclass Mx {\n  public static get myField1() {\n    return 1;\n  }\n\n  private get ['myField2']() {\n    return 'hello world';\n  }\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='\"fields\"'\nclass Mx {\n  public readonly myField1 = 1;\n\n  // not a literal\n  public readonly myField2 = [1, 2, 3];\n\n  private readonly ['myField3'] = 'hello world';\n\n  public get myField4() {\n    return `hello from ${window.location.href}`;\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n### `\"getters\"`\n\nThis style checks for any `readonly` fields that are assigned literal values, and requires them to be defined as getters instead.\nThis style pairs well with the [`@typescript-eslint/prefer-readonly`](prefer-readonly.mdx) rule,\nas it will identify fields that can be `readonly`, and thus should be made into getters.\n\nExamples of code with the `getters` style:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='\"getters\"'\nclass Mx {\n  readonly myField1 = 1;\n  readonly myField2 = `hello world`;\n  private readonly myField3 = 'hello world';\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='\"getters\"'\nclass Mx {\n  // no readonly modifier\n  public myField1 = 'hello';\n\n  // not a literal\n  public readonly myField2 = [1, 2, 3];\n\n  public static get myField3() {\n    return 1;\n  }\n\n  private get ['myField4']() {\n    return 'hello world';\n  }\n}\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nWhen you have no strong preference, or do not wish to enforce a particular style for how literal values are exposed by your classes.\n"
        }
    ]
}