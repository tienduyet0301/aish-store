{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/unbound-method.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce unbound methods are called with their expected scope.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/unbound-method** for documentation.\n\nClass method functions don't preserve the class scope when passed as standalone variables (\"unbound\").\nIf your function does not access `this`, [you can annotate it with `this: void`](https://www.typescriptlang.org/docs/handbook/2/functions.html#declaring-this-in-a-function), or consider using an arrow function instead.\nOtherwise, passing class methods around as values can remove type safety by failing to capture `this`.\n\nThis rule reports when a class method is referenced in an unbound manner.\n\n:::note Tip\nIf you're working with `jest`, you can use [`eslint-plugin-jest`'s version of this rule](https://github.com/jest-community/eslint-plugin-jest/blob/main/docs/rules/unbound-method.md) to lint your test files, which knows when it's ok to pass an unbound method to `expect` calls.\n:::\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nclass MyClass {\n  public log(): void {\n    console.log(this);\n  }\n}\n\nconst instance = new MyClass();\n\n// This logs the global scope (`window`/`global`), not the class instance\nconst myLog = instance.log;\nmyLog();\n\n// This log might later be called with an incorrect scope\nconst { log } = instance;\n\n// arith.double may refer to `this` internally\nconst arith = {\n  double(x: number): number {\n    return x * 2;\n  },\n};\nconst { double } = arith;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nclass MyClass {\n  public logUnbound(): void {\n    console.log(this);\n  }\n\n  public logBound = () => console.log(this);\n}\n\nconst instance = new MyClass();\n\n// logBound will always be bound with the correct scope\nconst { logBound } = instance;\nlogBound();\n\n// .bind and lambdas will also add a correct scope\nconst dotBindLog = instance.logUnbound.bind(instance);\nconst innerLog = () => instance.logUnbound();\n\n// arith.double explicitly declares that it does not refer to `this` internally\nconst arith = {\n  double(this: void, x: number): number {\n    return x * 2;\n  },\n};\nconst { double } = arith;\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `ignoreStatic`\n\n{/* insert option description */}\n\nExamples of **correct** code for this rule with `{ ignoreStatic: true }`:\n\n```ts option='{ \"ignoreStatic\": true }' showPlaygroundButton\nclass OtherClass {\n  static log() {\n    console.log(OtherClass);\n  }\n}\n\n// With `ignoreStatic`, statics are assumed to not rely on a particular scope\nconst { log } = OtherClass;\n\nlog();\n```\n\n## When Not To Use It\n\nIf your project dynamically changes `this` scopes around in a way TypeScript has difficulties modeling, this rule may not be viable to use.\nFor example, some functions have an additional parameter for specifying the `this` context, such as `Reflect.apply`, and array methods like `Array.prototype.map`.\nThis semantic is not easily expressed by TypeScript.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\nIf you're wanting to use `toBeCalled` and similar matches in `jest` tests, you can disable this rule for your test files in favor of [`eslint-plugin-jest`'s version of this rule](https://github.com/jest-community/eslint-plugin-jest/blob/main/docs/rules/unbound-method.mdx).\n"
        }
    ]
}