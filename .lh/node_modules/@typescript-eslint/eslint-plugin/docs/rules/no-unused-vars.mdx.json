{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-unused-vars.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891981650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow unused variables.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-unused-vars** for documentation.\n\nIt adds support for TypeScript features, such as types.\n\n## Options\n\n## FAQs\n\n### What benefits does this rule have over TypeScript?\n\nTypeScript provides [`noUnusedLocals`](https://www.typescriptlang.org/tsconfig#noUnusedLocals) and [`noUnusedParameters`](https://www.typescriptlang.org/tsconfig#noUnusedParameters) compiler options that can report errors on unused local variables or parameters, respectively.\nThose compiler options can be convenient to use if you don't want to set up ESLint and typescript-eslint.\nHowever:\n\n- These lint rules are more configurable than TypeScript's compiler options.\n  - For example, the [`varsIgnorePattern` option](https://eslint.org/docs/latest/rules/no-unused-vars#varsignorepattern) can customize what names are always allowed to be exempted. TypeScript hardcodes its exemptions to names starting with `_`.\n    If you would like to emulate the TypeScript style of exempting names starting with `_`, you can use this configuration (this includes errors as well):\n    ```json\n    {\n      \"rules\": {\n        \"@typescript-eslint/no-unused-vars\": [\n          \"error\",\n          {\n            \"args\": \"all\",\n            \"argsIgnorePattern\": \"^_\",\n            \"caughtErrors\": \"all\",\n            \"caughtErrorsIgnorePattern\": \"^_\",\n            \"destructuredArrayIgnorePattern\": \"^_\",\n            \"varsIgnorePattern\": \"^_\",\n            \"ignoreRestSiblings\": true\n          }\n        ]\n      }\n    }\n    ```\n- [ESLint can be configured](https://eslint.org/docs/latest/use/configure/rules) within lines, files, and folders. TypeScript compiler options are linked to their TSConfig file.\n- Many projects configure TypeScript's reported errors to block builds more aggressively than ESLint complaints. Blocking builds on unused variables can be inconvenient.\n\nWe generally recommend using `@typescript-eslint/no-unused-vars` to flag unused locals and parameters instead of TypeScript.\n\n:::tip\nEditors such as VS Code will still generally \"grey out\" unused variables even if `noUnusedLocals` and `noUnusedParameters` are not enabled in a project.\n:::\n\nAlso see similar rules provided by ESLint:\n\n- [`no-unused-private-class-members`](https://eslint.org/docs/latest/rules/no-unused-private-class-members)\n- [`no-unused-labels`](https://eslint.org/docs/latest/rules/no-unused-labels)\n\n### Why does this rule report variables used only for types?\n\nThis rule does not count type-only uses when determining whether a variable is used.\nDeclaring variables only to use them for types adds code and runtime complexity.\nThe variables are never actually used at runtime.\nThey can be misleading to readers of the code.\n\n<Tabs>\n\n<TabItem value=\"typeof Variables\">\n\nFor example, if a variable is only used for `typeof`, this rule will report:\n\n```ts\nconst box = {\n  //  ~~~\n  //  'box' is assigned a value but only used as a type.\n  value: 123,\n};\n\nexport type Box = typeof box;\n```\n\nInstead, it's often cleaner and less code to write out the types directly:\n\n```ts\nexport interface Box {\n  value: number;\n}\n```\n\n</TabItem>\n\n<TabItem value=\"Zod Schemas\">\n\nFor example, if a Zod schema variable is only used for `typeof`, this rule will report:\n\n```ts\nimport { z } from 'zod';\n\nconst schema = z.object({\n  //  ~~~~~~\n  //  'schema' is assigned a value but only used as a type.\n  value: z.number(),\n});\n\nexport type Box = z.infer<typeof schema>;\n```\n\nInstead, it's often cleaner and less code to write out the types directly:\n\n```ts\nexport interface Box {\n  value: number;\n}\n```\n\n</TabItem>\n\n</Tabs>\n\nIf you find yourself writing runtime values only for types, consider refactoring your code to declare types directly.\n"
        }
    ]
}