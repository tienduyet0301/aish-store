{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/adjacent-overload-signatures.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891979074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require that function overload signatures be consecutive.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/adjacent-overload-signatures** for documentation.\n\nFunction overload signatures represent multiple ways a function can be called, potentially with different return types.\nIt's typical for an interface or type alias describing a function to place all overload signatures next to each other.\nIf Signatures placed elsewhere in the type are easier to be missed by future developers reading the code.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\ndeclare namespace Foo {\n  export function foo(s: string): void;\n  export function foo(n: number): void;\n  export function bar(): void;\n  export function foo(sn: string | number): void;\n}\n\ntype Foo = {\n  foo(s: string): void;\n  foo(n: number): void;\n  bar(): void;\n  foo(sn: string | number): void;\n};\n\ninterface Foo {\n  foo(s: string): void;\n  foo(n: number): void;\n  bar(): void;\n  foo(sn: string | number): void;\n}\n\nclass Foo {\n  foo(s: string): void;\n  foo(n: number): void;\n  bar(): void {}\n  foo(sn: string | number): void {}\n}\n\nexport function foo(s: string): void;\nexport function foo(n: number): void;\nexport function bar(): void;\nexport function foo(sn: string | number): void;\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\ndeclare namespace Foo {\n  export function foo(s: string): void;\n  export function foo(n: number): void;\n  export function foo(sn: string | number): void;\n  export function bar(): void;\n}\n\ntype Foo = {\n  foo(s: string): void;\n  foo(n: number): void;\n  foo(sn: string | number): void;\n  bar(): void;\n};\n\ninterface Foo {\n  foo(s: string): void;\n  foo(n: number): void;\n  foo(sn: string | number): void;\n  bar(): void;\n}\n\nclass Foo {\n  foo(s: string): void;\n  foo(n: number): void;\n  foo(sn: string | number): void {}\n  bar(): void {}\n}\n\nexport function bar(): void;\nexport function foo(s: string): void;\nexport function foo(n: number): void;\nexport function foo(sn: string | number): void;\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIt can sometimes be useful to place overload signatures alongside other meaningful parts of a type.\nFor example, if each of a function's overloads corresponds to a different property, you might wish to put each overloads next to its corresponding property.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\n## Related To\n\n- [`unified-signatures`](./unified-signatures.mdx)\n"
        }
    ]
}