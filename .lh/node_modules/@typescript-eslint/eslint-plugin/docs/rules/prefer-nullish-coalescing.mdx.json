{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/prefer-nullish-coalescing.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce using the nullish coalescing operator instead of logical assignments or chaining.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/prefer-nullish-coalescing** for documentation.\n\nThe `??` nullish coalescing runtime operator allows providing a default value when dealing with `null` or `undefined`.\nBecause the nullish coalescing operator _only_ coalesces when the original value is `null` or `undefined`, it is much safer than relying upon logical OR operator chaining `||`, which coalesces on any _falsy_ value.\n\nThis rule reports when you may consider replacing:\n\n- An `||` operator with `??`\n- An `||=` operator with `??=`\n- Ternary expressions (`?:`) that are equivalent to `||` or `??` with `??`\n\n:::caution\nThis rule will not work as expected if [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks) is not enabled.\n:::\n\n## Options\n\n### `ignoreTernaryTests`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ ignoreTernaryTests: false }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"ignoreTernaryTests\": false }'\ndeclare const a: any;\na !== undefined && a !== null ? a : 'a string';\na === undefined || a === null ? 'a string' : a;\na == undefined ? 'a string' : a;\na == null ? 'a string' : a;\n\ndeclare const b: string | undefined;\nb !== undefined ? b : 'a string';\nb === undefined ? 'a string' : b;\nb ? b : 'a string';\n!b ? 'a string' : b;\n\ndeclare const c: string | null;\nc !== null ? c : 'a string';\nc === null ? 'a string' : c;\nc ? c : 'a string';\n!c ? 'a string' : c;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"ignoreTernaryTests\": false }'\ndeclare const a: any;\na ?? 'a string';\n\ndeclare const b: string | undefined;\nb ?? 'a string';\n\ndeclare const c: string | null;\nc ?? 'a string';\n```\n\n</TabItem>\n</Tabs>\n\n### `ignoreConditionalTests`\n\n{/* insert option description */}\n\nGenerally expressions within conditional tests intentionally use the falsy fallthrough behavior of the logical or operator, meaning that fixing the operator to the nullish coalesce operator could cause bugs.\n\nIf you're looking to enforce stricter conditional tests, you should consider using the `strict-boolean-expressions` rule.\n\nExamples of code for this rule with `{ ignoreConditionalTests: false }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"ignoreConditionalTests\": false }'\ndeclare const a: string | null;\ndeclare const b: string | null;\n\nif (a || b) {\n}\nif ((a ||= b)) {\n}\nwhile (a || b) {}\nwhile ((a ||= b)) {}\ndo {} while (a || b);\nfor (let i = 0; a || b; i += 1) {}\na || b ? true : false;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"ignoreConditionalTests\": false }'\ndeclare const a: string | null;\ndeclare const b: string | null;\n\nif (a ?? b) {\n}\nif ((a ??= b)) {\n}\nwhile (a ?? b) {}\nwhile ((a ??= b)) {}\ndo {} while (a ?? b);\nfor (let i = 0; a ?? b; i += 1) {}\n(a ?? b) ? true : false;\n```\n\n</TabItem>\n</Tabs>\n\n### `ignoreMixedLogicalExpressions`\n\n{/* insert option description */}\n\nGenerally expressions within mixed logical expressions intentionally use the falsy fallthrough behavior of the logical or operator, meaning that fixing the operator to the nullish coalesce operator could cause bugs.\n\nIf you're looking to enforce stricter conditional tests, you should consider using the `strict-boolean-expressions` rule.\n\nExamples of code for this rule with `{ ignoreMixedLogicalExpressions: false }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"ignoreMixedLogicalExpressions\": false }'\ndeclare const a: string | null;\ndeclare const b: string | null;\ndeclare const c: string | null;\ndeclare const d: string | null;\n\na || (b && c);\na ||= b && c;\n(a && b) || c || d;\na || (b && c) || d;\na || (b && c && d);\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"ignoreMixedLogicalExpressions\": false }'\ndeclare const a: string | null;\ndeclare const b: string | null;\ndeclare const c: string | null;\ndeclare const d: string | null;\n\na ?? (b && c);\na ??= b && c;\n(a && b) ?? c ?? d;\na ?? (b && c) ?? d;\na ?? (b && c && d);\n```\n\n</TabItem>\n</Tabs>\n\n**_NOTE:_** Errors for this specific case will be presented as suggestions (see below), instead of fixes. This is because it is not always safe to automatically convert `||` to `??` within a mixed logical expression, as we cannot tell the intended precedence of the operator. Note that by design, `??` requires parentheses when used with `&&` or `||` in the same expression.\n\n### `ignorePrimitives`\n\n{/* insert option description */}\n\nIf you would like to ignore expressions containing operands of certain primitive types that can be falsy then you may pass an object containing a boolean value for each primitive:\n\n- `string: true`, ignores `null` or `undefined` unions with `string` (default: `false`).\n- `number: true`, ignores `null` or `undefined` unions with `number` (default: `false`).\n- `bigint: true`, ignores `null` or `undefined` unions with `bigint` (default: `false`).\n- `boolean: true`, ignores `null` or `undefined` unions with `boolean` (default: `false`).\n\nExamples of code for this rule with `{ ignorePrimitives: { string: false } }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"ignorePrimitives\": { \"string\": false } }'\ndeclare const foo: string | undefined;\n\nfoo || 'a string';\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"ignorePrimitives\": { \"string\": false } }'\ndeclare const foo: string | undefined;\n\nfoo ?? 'a string';\n```\n\n</TabItem>\n</Tabs>\n\nAlso, if you would like to ignore all primitives types, you can set `ignorePrimitives: true`. It is equivalent to `ignorePrimitives: { string: true, number: true, bigint: true, boolean: true }`.\n\n### `ignoreBooleanCoercion`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ ignoreBooleanCoercion: false }`:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts option='{ \"ignoreBooleanCoercion\": false }'\ndeclare const a: string | true | undefined;\ndeclare const b: string | boolean | undefined;\n\nconst x = Boolean(a || b);\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts option='{ \"ignoreBooleanCoercion\": false }'\ndeclare const a: string | true | undefined;\ndeclare const b: string | boolean | undefined;\n\nconst x = Boolean(a ?? b);\n```\n\n</TabItem>\n</Tabs>\n\n### `allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing`\n\n:::danger Deprecated\n\nThis option will be removed in the next major version of typescript-eslint.\n\n:::\n\n{/* insert option description */}\n\nWithout `strictNullChecks`, TypeScript essentially erases `undefined` and `null` from the types. This means when this rule inspects the types from a variable, **it will not be able to tell that the variable might be `null` or `undefined`**, which essentially makes this rule useless.\n\nYou should be using `strictNullChecks` to ensure complete type-safety in your codebase.\n\nIf for some reason you cannot turn on `strictNullChecks`, but still want to use this rule - you can use this option to allow it - but know that the behavior of this rule is _undefined_ with the compiler option turned off. We will not accept bug reports if you are using this option.\n\n## When Not To Use It\n\nIf you are not using TypeScript 3.7 (or greater), then you will not be able to use this rule, as the operator is not supported.\n\n## Further Reading\n\n- [TypeScript 3.7 Release Notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n- [Nullish Coalescing Operator Proposal](https://github.com/tc39/proposal-nullish-coalescing/)\n"
        }
    ]
}