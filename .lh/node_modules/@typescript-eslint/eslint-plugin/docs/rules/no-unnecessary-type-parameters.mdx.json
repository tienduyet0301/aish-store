{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-unnecessary-type-parameters.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891981347,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: \"Disallow type parameters that aren't used multiple times.\"\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> 🛑 This file is source code, not the primary documentation location! 🛑\n>\n> See **https://typescript-eslint.io/rules/no-unnecessary-type-parameters** for documentation.\n\nThis rule forbids type parameters that aren't used multiple times in a function, method, or class definition.\n\nType parameters relate two types.\nIf a type parameter is only used once, then it is not relating anything.\nIt can usually be replaced with explicit types such as `unknown`.\n\nAt best unnecessary type parameters make code harder to read.\nAt worst they can be used to disguise unsafe type assertions.\n\n:::warning\nThis rule was recently added, and has a surprising amount of hidden complexity compared to most of our rules. If you encounter unexpected behavior with it, please check closely the [Limitations](#limitations) and [FAQ](#faq) sections below and our [issue tracker](https://github.com/typescript-eslint/typescript-eslint/issues?q=is%3Aissue+no-unnecessary-type-parameters).\nIf you don't see your case covered, please [reach out to us](https://typescript-eslint.io/contributing/issues)!\n:::\n\n## Examples\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\nfunction second<A, B>(a: A, b: B): B {\n  return b;\n}\n\nfunction parseJSON<T>(input: string): T {\n  return JSON.parse(input);\n}\n\nfunction printProperty<T, K extends keyof T>(obj: T, key: K) {\n  console.log(obj[key]);\n}\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\nfunction second<B>(a: unknown, b: B): B {\n  return b;\n}\n\nfunction parseJSON(input: string): unknown {\n  return JSON.parse(input);\n}\n\nfunction printProperty<T>(obj: T, key: keyof T) {\n  console.log(obj[key]);\n}\n\n// T appears twice: in the type of arg and as the return type\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// T appears twice: \"keyof T\" and in the inferred return type (T[K]).\n// K appears twice: \"key: K\" and in the inferred return type (T[K]).\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\n```\n\n</TabItem>\n</Tabs>\n\n## Limitations\n\nNote that this rule allows any type parameter that is used multiple times, even if those uses are via a type argument.\nFor example, the following `T` is used multiple times by virtue of being in an `Array`, even though its name only appears once after declaration:\n\n```ts\ndeclare function createStateHistory<T>(): T[];\n```\n\nThis is because the type parameter `T` relates multiple methods in `T[]` (`Array<T>`) together, making it used more than once.\n\nTherefore, this rule won't report on type parameters used as a type argument.\nThis includes type arguments provided to global types such as `Array`, `Map`, and `Set` that have multiple methods and properties that can change values based on the type parameter.\n\nOn the other hand, readonly and fixed array-likes such as `readonly T[]`, `ReadonlyArray`, and tuples such as `[T]` are special cases that are specifically reported on when used as input types, or as `readonly` output types.\nThe following example will be reported because `T` is used only once as type argument for the `ReadonlyArray` global type:\n\n<Tabs>\n<TabItem value=\"❌ Incorrect\">\n\n```ts\ndeclare function length<T>(array: ReadonlyArray<T>): number;\n```\n\n</TabItem>\n<TabItem value=\"✅ Correct\">\n\n```ts\ndeclare function length(array: ReadonlyArray<unknown>): number;\n```\n\n</TabItem>\n</Tabs>\n\n## FAQ\n\n### The return type is only used as an input, so why isn't the rule reporting?\n\nOne common reason that this might be the case is when the return type is not specified explicitly.\nThe rule uses uses type information to count implicit usages of the type parameter in the function signature, including in the inferred return type.\nFor example, the following function...\n\n```ts\nfunction identity<T>(arg: T) {\n  return arg;\n}\n```\n\n...implicitly has a return type of `T`. Therefore, the type parameter `T` is used twice, and the rule will not report this function.\n\nFor other reasons the rule might not be reporting, be sure to check the [Limitations section](#limitations) and other FAQs.\n\n### I'm using the type parameter inside the function, so why is the rule reporting?\n\nYou might be surprised to that the rule reports on a function like this:\n\n```ts\nfunction log<T extends string>(string1: T): void {\n  const string2: T = string1;\n  console.log(string2);\n}\n```\n\nAfter all, the type parameter `T` relates the input `string1` and the local variable `string2`, right?\nHowever, this usage is unnecessary, since we can achieve the same results by replacing all usages of the type parameter with its constraint.\nThat is to say, the function can always be rewritten as:\n\n```ts\nfunction log(string1: string): void {\n  const string2: string = string1;\n  console.log(string2);\n}\n```\n\nTherefore, this rule only counts usages of a type parameter in the _signature_ of a function, method, or class, but not in the implementation. See also [#9735](https://github.com/typescript-eslint/typescript-eslint/issues/9735)\n\n### Why am I getting TypeScript errors saying \"Object literal may only specify known properties\" after removing an unnecessary type parameter?\n\nSuppose you have a situation like the following, which will trigger the rule to report.\n\n```ts\ninterface SomeProperties {\n  foo: string;\n}\n\n// T is only used once, so the rule will report.\nfunction serialize<T extends SomeProperties>(x: T): string {\n  return JSON.stringify(x);\n}\n\nserialize({ foo: 'bar', anotherProperty: 'baz' });\n```\n\nIf we remove the unnecessary type parameter, we'll get an error:\n\n```ts\nfunction serialize(x: SomeProperties): string {\n  return JSON.stringify(x);\n}\n\n// TS Error: Object literal may only specify known properties, and 'anotherProperty' does not exist in type 'SomeProperties'.\nserialize({ foo: 'bar', anotherProperty: 'baz' });\n```\n\nThis is because TypeScript figures it's _usually_ an error to explicitly provide excess properties in a location that expects a specific type.\nSee [the TypeScript handbook's section on excess property checks](https://www.typescriptlang.org/docs/handbook/2/objects.html#excess-property-checks) for further discussion.\n\nTo resolve this, you have two approaches to choose from.\n\n1. If it doesn't make sense to accept excess properties in your function, you'll want to fix the errors at the call sites. Usually, you can simply remove any excess properties where the function is called.\n2. Otherwise, if you do want your function to accept excess properties, you can modify the parameter type in order to allow excess properties explicitly by using an [index signature](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures):\n\n   ```ts\n   interface SomeProperties {\n     foo: string;\n\n     // This allows any other properties.\n     // You may wish to make these types more specific according to your use case.\n     [key: PropertKey]: unknown;\n   }\n\n   function serialize(x: SomeProperties): string {\n     return JSON.stringify(x);\n   }\n\n   // No error!\n   serialize({ foo: 'bar', anotherProperty: 'baz' });\n   ```\n\nWhich solution is appropriate is a case-by-case decision, depending on the intended use case of your function.\n\n### I have a complex scenario that is reported by the rule, but I can't see how to remove the type parameter. What should I do?\n\nSometimes, you may be able to rewrite the code by reaching for some niche TypeScript features, such as [the `NoInfer<T>` utility type](https://www.typescriptlang.org/docs/handbook/utility-types.html#noinfertype) (see [#9751](https://github.com/typescript-eslint/typescript-eslint/issues/9751)).\n\nBut, quite possibly, you've hit an edge case where the type is being used in a subtle way that the rule doesn't account for.\nFor example, the following arcane code is a way of testing whether two types are equal, and will be reported by the rule (see [#9709](https://github.com/typescript-eslint/typescript-eslint/issues/9709)):\n\n{/* prettier-ignore */}\n```ts\ntype Compute<A> = A extends Function ? A : { [K in keyof A]: Compute<A[K]> };\ntype Equal<X, Y> =\n  (<T1>() => T1 extends Compute<X> ? 1 : 2) extends\n    (<T2>() => T2 extends Compute<Y> ? 1 : 2)\n  ? true\n  : false;\n```\n\nIn this case, the function types created within the `Equal` type are never expected to be assigned to; they're just created for the purpose of type system manipulations.\nThis usage is not what the rule is intended to analyze.\n\nUse eslint-disable comments as appropriate to suppress the rule in these kinds of cases.\n\n{/* TODO - include an FAQ entry regarding instantiation expressions once the conversation in https://github.com/typescript-eslint/typescript-eslint/pull/9536#discussion_r1705850744 is done */}\n\n## When Not To Use It\n\nThis rule will report on functions that use type parameters solely to test types, for example:\n\n```ts\nfunction assertType<T>(arg: T) {}\n\nassertType<number>(123);\nassertType<number>('abc');\n//                 ~~~~~\n// Argument of type 'string' is not assignable to parameter of type 'number'.\n```\n\nIf you're using this pattern then you'll want to disable this rule on files that test types.\n\n## Further Reading\n\n- TypeScript handbook: [Type Parameters Should Appear Twice](https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice)\n- Effective TypeScript: [The Golden Rule of Generics](https://effectivetypescript.com/2020/08/12/generics-golden-rule/)\n\n## Related To\n\n- eslint-plugin-etc's [`no-misused-generics`](https://github.com/cartant/eslint-plugin-etc/blob/main/docs/rules/no-misused-generics.md)\n- wotan's [`no-misused-generics`](https://github.com/fimbullinter/wotan/blob/master/packages/mimir/docs/no-misused-generics.md)\n- DefinitelyTyped-tools' [`no-unnecessary-generics`](https://github.com/microsoft/DefinitelyTyped-tools/blob/main/packages/eslint-plugin/docs/rules/no-unnecessary-generics.md)\n"
        }
    ]
}