{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-floating-promises.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891980401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Require Promise-like statements to be handled appropriately.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-floating-promises** for documentation.\n\nA \"floating\" Promise is one that is created without any code set up to handle any errors it might throw.\nFloating Promises can cause several issues, such as improperly sequenced operations, ignored Promise rejections, and more.\n\nThis rule will report Promise-valued statements that are not treated in one of the following ways:\n\n- Calling its `.then()` with two arguments\n- Calling its `.catch()` with one argument\n- `await`ing it\n- `return`ing it\n- [`void`ing it](#ignorevoid)\n\nThis rule also reports when an Array containing Promises is created and not properly handled. The main way to resolve this is by using one of the Promise concurrency methods to create a single Promise, then handling that according to the procedure above. These methods include:\n\n- `Promise.all()`\n- `Promise.allSettled()`\n- `Promise.any()`\n- `Promise.race()`\n\n:::tip\n`no-floating-promises` only detects apparently unhandled Promise _statements_.\nSee [`no-misused-promises`](./no-misused-promises.mdx) for detecting code that provides Promises to _logical_ locations such as if statements.\n\nSee [_Using promises (error handling) on MDN_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#error_handling) for a detailed writeup on Promise error-handling.\n:::\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\nconst promise = new Promise((resolve, reject) => resolve('value'));\npromise;\n\nasync function returnsPromise() {\n  return 'value';\n}\nreturnsPromise().then(() => {});\n\nPromise.reject('value').catch();\n\nPromise.reject('value').finally();\n\n[1, 2, 3].map(async x => x + 1);\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\nconst promise = new Promise((resolve, reject) => resolve('value'));\nawait promise;\n\nasync function returnsPromise() {\n  return 'value';\n}\n\nvoid returnsPromise();\n\nreturnsPromise().then(\n  () => {},\n  () => {},\n);\n\nPromise.reject('value').catch(() => {});\n\nawait Promise.reject('value').finally(() => {});\n\nawait Promise.all([1, 2, 3].map(async x => x + 1));\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\n### `checkThenables`\n\n{/* insert option description */}\n\nA [\"Thenable\"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables) value is an object which has a `then` method, such as a `Promise`.\nOther Thenables include TypeScript's built-in `PromiseLike` interface and any custom object that happens to have a `.then()`.\n\nThe `checkThenables` option triggers `no-floating-promises` to also consider all values that satisfy the Thenable shape (a `.then()` method that takes two callback parameters), not just Promises.\nThis can be useful if your code works with older `Promise` polyfills instead of the native `Promise` class.\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{\"checkThenables\": true}'\ndeclare function createPromiseLike(): PromiseLike<string>;\n\ncreatePromiseLike();\n\ninterface MyThenable {\n  then(onFulfilled: () => void, onRejected: () => void): MyThenable;\n}\n\ndeclare function createMyThenable(): MyThenable;\n\ncreateMyThenable();\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{\"checkThenables\": true}'\ndeclare function createPromiseLike(): PromiseLike<string>;\n\nawait createPromiseLike();\n\ninterface MyThenable {\n  then(onFulfilled: () => void, onRejected: () => void): MyThenable;\n}\n\ndeclare function createMyThenable(): MyThenable;\n\nawait createMyThenable();\n```\n\n</TabItem>\n</Tabs>\n\n### `ignoreVoid`\n\n{/* insert option description */}\n\nPlacing the [`void` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void) in front of a Promise can be a convenient way to explicitly mark that Promise as intentionally not awaited.\n\n:::warning\nVoiding a Promise doesn't handle it or change the runtime behavior.\nThe outcome is just ignored, like disabling the rule with an [ESLint disable comment](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1).\nSuch Promise rejections will still be unhandled.\n:::\n\nExamples of **correct** code for this rule with `{ ignoreVoid: true }`:\n\n```ts option='{ \"ignoreVoid\": true }' showPlaygroundButton\nasync function returnsPromise() {\n  return 'value';\n}\nvoid returnsPromise();\n\nvoid Promise.reject('value');\n```\n\nWhen this option is set to `true`, if you are using `no-void`, you should turn on the [`allowAsStatement`](https://eslint.org/docs/rules/no-void#allowasstatement) option.\n\n### `ignoreIIFE`\n\n{/* insert option description */}\n\nExamples of **correct** code for this rule with `{ ignoreIIFE: true }`:\n\n{/* prettier-ignore */}\n```ts option='{ \"ignoreIIFE\": true }' showPlaygroundButton\nawait (async function () {\n  await res(1);\n})();\n\n(async function () {\n  await res(1);\n})();\n```\n\n### `allowForKnownSafePromises`\n\n{/* insert option description */}\n\nFor example, you may need to do this in the case of libraries whose APIs return Promises whose rejections are safely handled by the library.\n\nThis option takes the shared [`TypeOrValueSpecifier` format](/packages/type-utils/type-or-value-specifier).\n\nExamples of code for this rule with:\n\n```json\n{\n  \"allowForKnownSafePromises\": [\n    { \"from\": \"file\", \"name\": \"SafePromise\" },\n    { \"from\": \"lib\", \"name\": \"PromiseLike\" },\n    { \"from\": \"package\", \"name\": \"Bar\", \"package\": \"bar-lib\" }\n  ]\n}\n```\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{\"allowForKnownSafePromises\":[{\"from\":\"file\",\"name\":\"SafePromise\"},{\"from\":\"lib\",\"name\":\"PromiseLike\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\nlet promise: Promise<number> = Promise.resolve(2);\npromise;\n\nfunction returnsPromise(): Promise<number> {\n  return Promise.resolve(42);\n}\n\nreturnsPromise();\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{\"allowForKnownSafePromises\":[{\"from\":\"file\",\"name\":\"SafePromise\"},{\"from\":\"lib\",\"name\":\"PromiseLike\"},{\"from\":\"package\",\"name\":\"Bar\",\"package\":\"bar-lib\"}]}'\n// promises can be marked as safe by using branded types\ntype SafePromise = Promise<number> & { __linterBrands?: string };\n\nlet promise: SafePromise = Promise.resolve(2);\npromise;\n\nfunction returnsSafePromise(): SafePromise {\n  return Promise.resolve(42);\n}\n\nreturnsSafePromise();\n```\n\n</TabItem>\n</Tabs>\n\n### `allowForKnownSafeCalls`\n\n{/* insert option description */}\n\nFor example, you may need to do this in the case of libraries whose APIs may be called without handling the resultant Promises.\n\nThis option takes the shared [`TypeOrValueSpecifier` format](/packages/type-utils/type-or-value-specifier).\n\nExamples of code for this rule with:\n\n```json\n{\n  \"allowForKnownSafeCalls\": [\n    { \"from\": \"file\", \"name\": \"safe\", \"path\": \"input.ts\" }\n  ]\n}\n```\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{\"allowForKnownSafeCalls\":[{\"from\":\"file\",\"name\":\"safe\",\"path\":\"input.ts\"}]}'\ndeclare function unsafe(...args: unknown[]): Promise<void>;\n\nunsafe('...', () => {});\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{\"allowForKnownSafeCalls\":[{\"from\":\"file\",\"name\":\"safe\",\"path\":\"input.ts\"}]}' skipValidation\ndeclare function safe(...args: unknown[]): Promise<void>;\n\nsafe('...', () => {});\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nThis rule can be difficult to enable on large existing projects that set up many floating Promises.\nAlternately, if you're not worried about crashes from floating or misused Promises -such as if you have global unhandled Promise handlers registered- then in some cases it may be safe to not use this rule.\nYou might consider using `void`s and/or [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\n## Related To\n\n- [`no-misused-promises`](./no-misused-promises.mdx)\n\n## Further Reading\n\n- [\"Using Promises\" MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises). Note especially the sections on [Promise rejection events](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#promise_rejection_events) and [Composition](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#composition).\n"
        }
    ]
}