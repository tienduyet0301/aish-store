{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/prefer-optional-chain.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891982185,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Enforce using concise optional chain expressions instead of chained logical ands, negated logical ors, or empty objects.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> üõë This file is source code, not the primary documentation location! üõë\n>\n> See **https://typescript-eslint.io/rules/prefer-optional-chain** for documentation.\n\n`?.` optional chain expressions provide `undefined` if an object is `null` or `undefined`.\nBecause the optional chain operator _only_ chains when the property value is `null` or `undefined`, it is much safer than relying upon logical AND operator chaining `&&`; which chains on any _truthy_ value.\nIt is also often less code to use `?.` optional chaining than `&&` truthiness checks.\n\nThis rule reports on code where an `&&` operator can be safely replaced with `?.` optional chaining.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts\nfoo && foo.a && foo.a.b && foo.a.b.c;\nfoo && foo['a'] && foo['a'].b && foo['a'].b.c;\nfoo && foo.a && foo.a.b && foo.a.b.method && foo.a.b.method();\n\n// With empty objects\n(((foo || {}).a || {}).b || {}).c;\n(((foo || {})['a'] || {}).b || {}).c;\n\n// With negated `or`s\n!foo || !foo.bar;\n!foo || !foo[bar];\n!foo || !foo.bar || !foo.bar.baz || !foo.bar.baz();\n\n// this rule also supports converting chained strict nullish checks:\nfoo &&\n  foo.a != null &&\n  foo.a.b !== null &&\n  foo.a.b.c != undefined &&\n  foo.a.b.c.d !== undefined &&\n  foo.a.b.c.d.e;\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts\nfoo?.a?.b?.c;\nfoo?.['a']?.b?.c;\nfoo?.a?.b?.method?.();\n\nfoo?.a?.b?.c?.d?.e;\n\n!foo?.bar;\n!foo?.[bar];\n!foo?.bar?.baz?.();\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\nIn the context of the descriptions below a \"loose boolean\" operand is any operand that implicitly coerces the value to a boolean.\nSpecifically the argument of the not operator (`!loose`) or a bare value in a logical expression (`loose && looser`).\n\n### `allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing`\n\n{/* insert option description */}\n\nWhen this option is `true`, the rule will provide an auto-fixer for cases where the return type of the expression would change. For example for the expression `!foo || foo.bar` the return type of the expression is `true | T`, however for the equivalent optional chain `foo?.bar` the return type of the expression is `undefined | T`. Thus changing the code from a logical expression to an optional chain expression has altered the type of the expression.\n\nIn some cases this distinction _may_ matter - which is why these fixers are considered unsafe - they may break the build! For example in the following code:\n\n```ts option='{ \"allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing\": true }' showPlaygroundButton\ndeclare const foo: { bar: boolean } | null | undefined;\ndeclare function acceptsBoolean(arg: boolean): void;\n\n// ‚úÖ typechecks succesfully as the expression only returns `boolean`\nacceptsBoolean(foo != null && foo.bar);\n\n// ‚ùå typechecks UNSUCCESSFULLY as the expression returns `boolean | undefined`\nacceptsBoolean(foo?.bar);\n```\n\nThis style of code isn't super common - which means having this option set to `true` _should_ be safe in most codebases. However we default it to `false` due to its unsafe nature. We have provided this option for convenience because it increases the autofix cases covered by the rule. If you set option to `true` the onus is entirely on you and your team to ensure that each fix is correct and safe and that it does not break the build.\n\nWhen this option is `false` unsafe cases will have suggestion fixers provided instead of auto-fixers - meaning you can manually apply the fix using your IDE tooling.\n\n### `checkAny`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ checkAny: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"checkAny\": true }'\ndeclare const thing: any;\n\nthing && thing.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"checkAny\": true }'\ndeclare const thing: any;\n\nthing?.toString();\n```\n\n</TabItem>\n</Tabs>\n\n### `checkUnknown`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ checkUnknown: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"checkUnknown\": true }'\ndeclare const thing: unknown;\n\nthing && thing.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"checkUnknown\": true }'\ndeclare const thing: unknown;\n\nthing?.toString();\n```\n\n</TabItem>\n</Tabs>\n\n### `checkString`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ checkString: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"checkString\": true }'\ndeclare const thing: string;\n\nthing && thing.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"checkString\": true }'\ndeclare const thing: string;\n\nthing?.toString();\n```\n\n</TabItem>\n</Tabs>\n\n### `checkNumber`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ checkNumber: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"checkNumber\": true }'\ndeclare const thing: number;\n\nthing && thing.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"checkNumber\": true }'\ndeclare const thing: number;\n\nthing?.toString();\n```\n\n</TabItem>\n</Tabs>\n\n### `checkBoolean`\n\n{/* insert option description */}\n\n:::note\n\nThis rule intentionally ignores the following case:\n\n```ts\ndeclare const x: false | { a: string };\nx && x.a;\n!x || x.a;\n```\n\nThe boolean expression narrows out the non-nullish falsy cases - so converting the chain to `x?.a` would introduce a type error.\n\n:::\n\nExamples of code for this rule with `{ checkBoolean: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"checkBoolean\": true }'\ndeclare const thing: true;\n\nthing && thing.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"checkBoolean\": true }'\ndeclare const thing: true;\n\nthing?.toString();\n```\n\n</TabItem>\n</Tabs>\n\n### `checkBigInt`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ checkBigInt: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"checkBigInt\": true }'\ndeclare const thing: bigint;\n\nthing && thing.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"checkBigInt\": true }'\ndeclare const thing: bigint;\n\nthing?.toString();\n```\n\n</TabItem>\n</Tabs>\n\n### `requireNullish`\n\n{/* insert option description */}\n\nExamples of code for this rule with `{ requireNullish: true }`:\n\n<Tabs>\n<TabItem value=\"‚ùå Incorrect\">\n\n```ts option='{ \"requireNullish\": true }'\ndeclare const thing1: string | null;\nthing1 && thing1.toString();\n```\n\n</TabItem>\n<TabItem value=\"‚úÖ Correct\">\n\n```ts option='{ \"requireNullish\": true }'\ndeclare const thing1: string | null;\nthing1?.toString();\n\ndeclare const thing2: string;\nthing2 && thing2.toString();\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf your project is not accurately typed, such as if it's in the process of being converted to TypeScript or is susceptible to [trade-offs in control flow analysis](https://github.com/Microsoft/TypeScript/issues/9998), it may be difficult to enable this rule for particularly non-type-safe areas of code.\nYou might consider using [ESLint disable comments](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1) for those specific situations instead of completely disabling this rule.\n\n## Further Reading\n\n- [TypeScript 3.7 Release Notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html)\n- [Optional Chaining Proposal](https://github.com/tc39/proposal-optional-chaining/)\n"
        }
    ]
}