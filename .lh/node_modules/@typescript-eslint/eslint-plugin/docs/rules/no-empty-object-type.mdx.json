{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/docs/rules/no-empty-object-type.mdx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891980261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "---\ndescription: 'Disallow accidentally using the \"empty object\" type.'\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n> ðŸ›‘ This file is source code, not the primary documentation location! ðŸ›‘\n>\n> See **https://typescript-eslint.io/rules/no-empty-object-type** for documentation.\n\nThe `{}`, or \"empty object\" type in TypeScript is a common source of confusion for developers unfamiliar with TypeScript's structural typing.\n`{}` represents any _non-nullish value_, including literals like `0` and `\"\"`:\n\n```ts\nlet anyNonNullishValue: {} = 'Intentionally allowed by TypeScript.';\n```\n\nOften, developers writing `{}` actually mean either:\n\n- `object`: representing any _object_ value\n- `unknown`: representing any value at all, including `null` and `undefined`\n\nIn other words, the \"empty object\" type `{}` really means _\"any value that is defined\"_.\nThat includes arrays, class instances, functions, and primitives such as `string` and `symbol`.\n\nTo avoid confusion around the `{}` type allowing any _non-nullish value_, this rule bans usage of the `{}` type.\nThat includes interfaces and object type aliases with no fields.\n\n:::tip\nIf you do have a use case for an API allowing `{}`, you can always configure the [rule's options](#options), use an [ESLint disable comment](https://eslint.org/docs/latest/use/configure/rules#using-configuration-comments-1), or [disable the rule in your ESLint config](https://eslint.org/docs/latest/use/configure/rules#using-configuration-files-1).\n:::\n\nNote that this rule does not report on:\n\n- `{}` as a type constituent in an intersection type (e.g. types like TypeScript's built-in `type NonNullable<T> = T & {}`), as this can be useful in type system operations.\n- Interfaces that extend from multiple other interfaces.\n\n## Examples\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts\nlet anyObject: {};\nlet anyValue: {};\n\ninterface AnyObjectA {}\ninterface AnyValueA {}\n\ntype AnyObjectB = {};\ntype AnyValueB = {};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts\nlet anyObject: object;\nlet anyValue: unknown;\n\ntype AnyObjectA = object;\ntype AnyValueA = unknown;\n\ntype AnyObjectB = object;\ntype AnyValueB = unknown;\n\nlet objectWith: { property: boolean };\n\ninterface InterfaceWith {\n  property: boolean;\n}\n\ntype TypeWith = { property: boolean };\n```\n\n</TabItem>\n</Tabs>\n\n## Options\n\nBy default, this rule flags both interfaces and object types.\n\n### `allowInterfaces`\n\n{/* insert option description */}\n\nAllowed values are:\n\n- `'always'`: to always allow interfaces with no fields\n- `'never'` _(default)_: to never allow interfaces with no fields\n- `'with-single-extends'`: to allow empty interfaces that `extend` from a single base interface\n\nExamples of **correct** code for this rule with `{ allowInterfaces: 'with-single-extends' }`:\n\n```ts option='{ \"allowInterfaces\": \"with-single-extends\" }' showPlaygroundButton\ninterface Base {\n  value: boolean;\n}\n\ninterface Derived extends Base {}\n```\n\n### `allowObjectTypes`\n\n{/* insert option description */}\n\nAllowed values are:\n\n- `'always'`: to always allow object type literals with no fields\n- `'never'` _(default)_: to never allow object type literals with no fields\n\n### `allowWithName`\n\n{/* insert option description */}\n\nThis can be useful if your existing code style includes a pattern of declaring empty types with `{}` instead of `object`.\n\nExamples of code for this rule with `{ allowWithName: 'Props$' }`:\n\n<Tabs>\n<TabItem value=\"âŒ Incorrect\">\n\n```ts option='{ \"allowWithName\": \"Props$\" }' showPlaygroundButton\ninterface InterfaceValue {}\n\ntype TypeValue = {};\n```\n\n</TabItem>\n<TabItem value=\"âœ… Correct\">\n\n```ts option='{ \"allowWithName\": \"Props$\" }' showPlaygroundButton\ninterface InterfaceProps {}\n\ntype TypeProps = {};\n```\n\n</TabItem>\n</Tabs>\n\n## When Not To Use It\n\nIf your code commonly needs to represent the _\"any non-nullish value\"_ type, this rule may not be for you.\nProjects that extensively use type operations such as conditional types and mapped types oftentimes benefit from disabling this rule.\n\n## Further Reading\n\n- [Enhancement: [ban-types] Split the {} ban into a separate, better-phrased rule](https://github.com/typescript-eslint/typescript-eslint/issues/8700)\n- [The Empty Object Type in TypeScript](https://www.totaltypescript.com/the-empty-object-type-in-typescript)\n"
        }
    ]
}