{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/collectUnusedVariables.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891976203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectVariables = collectVariables;\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst isTypeImport_1 = require(\"./isTypeImport\");\nconst referenceContainsTypeQuery_1 = require(\"./referenceContainsTypeQuery\");\n/**\n * This class leverages an AST visitor to mark variables as used via the\n * `eslintUsed` property.\n */\nclass UnusedVarsVisitor extends scope_manager_1.Visitor {\n    /**\n     * We keep a weak cache so that multiple rules can share the calculation\n     */\n    static RESULTS_CACHE = new WeakMap();\n    ClassDeclaration = this.visitClass;\n    ClassExpression = this.visitClass;\n    ForInStatement = this.visitForInForOf;\n    ForOfStatement = this.visitForInForOf;\n    //#region HELPERS\n    FunctionDeclaration = this.visitFunction;\n    FunctionExpression = this.visitFunction;\n    MethodDefinition = this.visitSetter;\n    Property = this.visitSetter;\n    TSCallSignatureDeclaration = this.visitFunctionTypeSignature;\n    TSConstructorType = this.visitFunctionTypeSignature;\n    TSConstructSignatureDeclaration = this.visitFunctionTypeSignature;\n    TSDeclareFunction = this.visitFunctionTypeSignature;\n    TSEmptyBodyFunctionExpression = this.visitFunctionTypeSignature;\n    //#endregion HELPERS\n    //#region VISITORS\n    // NOTE - This is a simple visitor - meaning it does not support selectors\n    TSFunctionType = this.visitFunctionTypeSignature;\n    TSMethodSignature = this.visitFunctionTypeSignature;\n    #scopeManager;\n    constructor(scopeManager) {\n        super({\n            visitChildrenEvenIfSelectorExists: true,\n        });\n        this.#scopeManager = scopeManager;\n    }\n    static collectUnusedVariables(program, scopeManager) {\n        const cached = this.RESULTS_CACHE.get(program);\n        if (cached) {\n            return cached;\n        }\n        const visitor = new this(scopeManager);\n        visitor.visit(program);\n        const unusedVars = visitor.collectUnusedVariables(visitor.getScope(program));\n        this.RESULTS_CACHE.set(program, unusedVars);\n        return unusedVars;\n    }\n    Identifier(node) {\n        const scope = this.getScope(node);\n        if (scope.type === utils_1.TSESLint.Scope.ScopeType.function &&\n            node.name === 'this' &&\n            // this parameters should always be considered used as they're pseudo-parameters\n            'params' in scope.block &&\n            scope.block.params.includes(node)) {\n            this.markVariableAsUsed(node);\n        }\n    }\n    TSEnumDeclaration(node) {\n        // enum members create variables because they can be referenced within the enum,\n        // but they obviously aren't unused variables for the purposes of this rule.\n        const scope = this.getScope(node);\n        for (const variable of scope.variables) {\n            this.markVariableAsUsed(variable);\n        }\n    }\n    TSMappedType(node) {\n        // mapped types create a variable for their type name, but it's not necessary to reference it,\n        // so we shouldn't consider it as unused for the purpose of this rule.\n        this.markVariableAsUsed(node.key);\n    }\n    TSModuleDeclaration(node) {\n        // -- global augmentation can be in any file, and they do not need exports\n        if (node.kind === 'global') {\n            this.markVariableAsUsed('global', node.parent);\n        }\n    }\n    TSParameterProperty(node) {\n        let identifier = null;\n        switch (node.parameter.type) {\n            case utils_1.AST_NODE_TYPES.AssignmentPattern:\n                if (node.parameter.left.type === utils_1.AST_NODE_TYPES.Identifier) {\n                    identifier = node.parameter.left;\n                }\n                break;\n            case utils_1.AST_NODE_TYPES.Identifier:\n                identifier = node.parameter;\n                break;\n        }\n        if (identifier) {\n            this.markVariableAsUsed(identifier);\n        }\n    }\n    collectUnusedVariables(scope, variables = {\n        unusedVariables: new Set(),\n        usedVariables: new Set(),\n    }) {\n        if (\n        // skip function expression names\n        // this scope is created just to house the variable that allows a function\n        // expression to self-reference if it has a name defined\n        !scope.functionExpressionScope) {\n            for (const variable of scope.variables) {\n                // cases that we don't want to treat as used or unused\n                if (\n                // implicit lib variables (from @typescript-eslint/scope-manager)\n                // these aren't variables that should be checked ever\n                variable instanceof scope_manager_1.ImplicitLibVariable) {\n                    continue;\n                }\n                if (\n                // variables marked with markVariableAsUsed()\n                variable.eslintUsed ||\n                    // basic exported variables\n                    isExported(variable) ||\n                    // variables implicitly exported via a merged declaration\n                    isMergableExported(variable) ||\n                    // used variables\n                    isUsedVariable(variable)) {\n                    variables.usedVariables.add(variable);\n                }\n                else {\n                    variables.unusedVariables.add(variable);\n                }\n            }\n        }\n        for (const childScope of scope.childScopes) {\n            this.collectUnusedVariables(childScope, variables);\n        }\n        return variables;\n    }\n    getScope(currentNode) {\n        // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n        const inner = currentNode.type !== utils_1.AST_NODE_TYPES.Program;\n        let node = currentNode;\n        while (node) {\n            const scope = this.#scopeManager.acquire(node, inner);\n            if (scope) {\n                if (scope.type === scope_manager_1.ScopeType.functionExpressionName) {\n                    return scope.childScopes[0];\n                }\n                return scope;\n            }\n            node = node.parent;\n        }\n        return this.#scopeManager.scopes[0];\n    }\n    markVariableAsUsed(variableOrIdentifierOrName, parent) {\n        if (typeof variableOrIdentifierOrName !== 'string' &&\n            !('type' in variableOrIdentifierOrName)) {\n            variableOrIdentifierOrName.eslintUsed = true;\n            return;\n        }\n        let name;\n        let node;\n        if (typeof variableOrIdentifierOrName === 'string') {\n            name = variableOrIdentifierOrName;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            node = parent;\n        }\n        else {\n            name = variableOrIdentifierOrName.name;\n            node = variableOrIdentifierOrName;\n        }\n        let currentScope = this.getScope(node);\n        while (currentScope) {\n            const variable = currentScope.variables.find(scopeVar => scopeVar.name === name);\n            if (variable) {\n                variable.eslintUsed = true;\n                return;\n            }\n            currentScope = currentScope.upper;\n        }\n    }\n    visitClass(node) {\n        // skip a variable of class itself name in the class scope\n        const scope = this.getScope(node);\n        for (const variable of scope.variables) {\n            if (variable.identifiers[0] === scope.block.id) {\n                this.markVariableAsUsed(variable);\n                return;\n            }\n        }\n    }\n    visitForInForOf(node) {\n        /**\n         * (Brad Zacher): I hate that this has to exist.\n         * But it is required for compat with the base ESLint rule.\n         *\n         * In 2015, ESLint decided to add an exception for these two specific cases\n         * ```\n         * for (var key in object) return;\n         *\n         * var key;\n         * for (key in object) return;\n         * ```\n         *\n         * I disagree with it, but what are you going to do...\n         *\n         * https://github.com/eslint/eslint/issues/2342\n         */\n        let idOrVariable;\n        if (node.left.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {\n            const variable = this.#scopeManager.getDeclaredVariables(node.left).at(0);\n            if (!variable) {\n                return;\n            }\n            idOrVariable = variable;\n        }\n        if (node.left.type === utils_1.AST_NODE_TYPES.Identifier) {\n            idOrVariable = node.left;\n        }\n        if (idOrVariable == null) {\n            return;\n        }\n        let body = node.body;\n        if (node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n            if (node.body.body.length !== 1) {\n                return;\n            }\n            body = node.body.body[0];\n        }\n        if (body.type !== utils_1.AST_NODE_TYPES.ReturnStatement) {\n            return;\n        }\n        this.markVariableAsUsed(idOrVariable);\n    }\n    visitFunction(node) {\n        const scope = this.getScope(node);\n        // skip implicit \"arguments\" variable\n        const variable = scope.set.get('arguments');\n        if (variable?.defs.length === 0) {\n            this.markVariableAsUsed(variable);\n        }\n    }\n    visitFunctionTypeSignature(node) {\n        // function type signature params create variables because they can be referenced within the signature,\n        // but they obviously aren't unused variables for the purposes of this rule.\n        for (const param of node.params) {\n            this.visitPattern(param, name => {\n                this.markVariableAsUsed(name);\n            });\n        }\n    }\n    visitSetter(node) {\n        if (node.kind === 'set') {\n            // ignore setter parameters because they're syntactically required to exist\n            for (const param of node.value.params) {\n                this.visitPattern(param, id => {\n                    this.markVariableAsUsed(id);\n                });\n            }\n        }\n    }\n}\n//#region private helpers\n/**\n * Checks the position of given nodes.\n * @param inner A node which is expected as inside.\n * @param outer A node which is expected as outside.\n * @returns `true` if the `inner` node exists in the `outer` node.\n */\nfunction isInside(inner, outer) {\n    return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n}\n/**\n * Determine if an identifier is referencing an enclosing name.\n * This only applies to declarations that create their own scope (modules, functions, classes)\n * @param ref The reference to check.\n * @param nodes The candidate function nodes.\n * @returns True if it's a self-reference, false if not.\n */\nfunction isSelfReference(ref, nodes) {\n    let scope = ref.from;\n    while (scope) {\n        if (nodes.has(scope.block)) {\n            return true;\n        }\n        scope = scope.upper;\n    }\n    return false;\n}\nconst MERGABLE_TYPES = new Set([\n    utils_1.AST_NODE_TYPES.ClassDeclaration,\n    utils_1.AST_NODE_TYPES.FunctionDeclaration,\n    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n    utils_1.AST_NODE_TYPES.TSModuleDeclaration,\n    utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n]);\n/**\n * Determine if the variable is directly exported\n * @param variable the variable to check\n */\nfunction isMergableExported(variable) {\n    // If all of the merged things are of the same type, TS will error if not all of them are exported - so we only need to find one\n    for (const def of variable.defs) {\n        // parameters can never be exported.\n        // their `node` prop points to the function decl, which can be exported\n        // so we need to special case them\n        if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n            continue;\n        }\n        if ((MERGABLE_TYPES.has(def.node.type) &&\n            def.node.parent?.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration) ||\n            def.node.parent?.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Determines if a given variable is being exported from a module.\n * @param variable eslint-scope variable object.\n * @returns True if the variable is exported, false if not.\n */\nfunction isExported(variable) {\n    return variable.defs.some(definition => {\n        let node = definition.node;\n        if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            node = node.parent;\n        }\n        else if (definition.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n            return false;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return node.parent.type.startsWith('Export');\n    });\n}\nconst LOGICAL_ASSIGNMENT_OPERATORS = new Set(['??=', '&&=', '||=']);\n/**\n * Determines if the variable is used.\n * @param variable The variable to check.\n * @returns True if the variable is used\n */\nfunction isUsedVariable(variable) {\n    /**\n     * Gets a list of function definitions for a specified variable.\n     * @param variable eslint-scope variable object.\n     * @returns Function nodes.\n     */\n    function getFunctionDefinitions(variable) {\n        const functionDefinitions = new Set();\n        variable.defs.forEach(def => {\n            // FunctionDeclarations\n            if (def.type === utils_1.TSESLint.Scope.DefinitionType.FunctionName) {\n                functionDefinitions.add(def.node);\n            }\n            // FunctionExpressions\n            if (def.type === utils_1.TSESLint.Scope.DefinitionType.Variable &&\n                (def.node.init?.type === utils_1.AST_NODE_TYPES.FunctionExpression ||\n                    def.node.init?.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {\n                functionDefinitions.add(def.node.init);\n            }\n        });\n        return functionDefinitions;\n    }\n    function getTypeDeclarations(variable) {\n        const nodes = new Set();\n        variable.defs.forEach(def => {\n            if (def.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||\n                def.node.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {\n                nodes.add(def.node);\n            }\n        });\n        return nodes;\n    }\n    function getModuleDeclarations(variable) {\n        const nodes = new Set();\n        variable.defs.forEach(def => {\n            if (def.node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {\n                nodes.add(def.node);\n            }\n        });\n        return nodes;\n    }\n    function getEnumDeclarations(variable) {\n        const nodes = new Set();\n        variable.defs.forEach(def => {\n            if (def.node.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration) {\n                nodes.add(def.node);\n            }\n        });\n        return nodes;\n    }\n    /**\n     * Checks if the ref is contained within one of the given nodes\n     */\n    function isInsideOneOf(ref, nodes) {\n        for (const node of nodes) {\n            if (isInside(ref.identifier, node)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks whether a given node is unused expression or not.\n     * @param node The node itself\n     * @returns The node is an unused expression.\n     */\n    function isUnusedExpression(node) {\n        const parent = node.parent;\n        if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n            return true;\n        }\n        if (parent.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n            const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n            if (!isLastExpression) {\n                return true;\n            }\n            return isUnusedExpression(parent);\n        }\n        return false;\n    }\n    /**\n     * If a given reference is left-hand side of an assignment, this gets\n     * the right-hand side node of the assignment.\n     *\n     * In the following cases, this returns null.\n     *\n     * - The reference is not the LHS of an assignment expression.\n     * - The reference is inside of a loop.\n     * - The reference is inside of a function scope which is different from\n     *   the declaration.\n     * @param ref A reference to check.\n     * @param prevRhsNode The previous RHS node.\n     * @returns The RHS node or null.\n     */\n    function getRhsNode(ref, prevRhsNode) {\n        /**\n         * Checks whether the given node is in a loop or not.\n         * @param node The node to check.\n         * @returns `true` if the node is in a loop.\n         */\n        function isInLoop(node) {\n            let currentNode = node;\n            while (currentNode) {\n                if (utils_1.ASTUtils.isFunction(currentNode)) {\n                    break;\n                }\n                if (utils_1.ASTUtils.isLoop(currentNode)) {\n                    return true;\n                }\n                currentNode = currentNode.parent;\n            }\n            return false;\n        }\n        const id = ref.identifier;\n        const parent = id.parent;\n        const refScope = ref.from.variableScope;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const varScope = ref.resolved.scope.variableScope;\n        const canBeUsedLater = refScope !== varScope || isInLoop(id);\n        /*\n         * Inherits the previous node if this reference is in the node.\n         * This is for `a = a + a`-like code.\n         */\n        if (prevRhsNode && isInside(id, prevRhsNode)) {\n            return prevRhsNode;\n        }\n        if (parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression &&\n            isUnusedExpression(parent) &&\n            id === parent.left &&\n            !canBeUsedLater) {\n            return parent.right;\n        }\n        return null;\n    }\n    /**\n     * Checks whether a given reference is a read to update itself or not.\n     * @param ref A reference to check.\n     * @param rhsNode The RHS node of the previous assignment.\n     * @returns The reference is a read to update itself.\n     */\n    function isReadForItself(ref, rhsNode) {\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param id An Identifier node to check.\n         * @param rhsNode The RHS node of the previous assignment.\n         * @returns `true` if the `id` node exists inside of a function node which can be used later.\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            /**\n             * Finds a function node from ancestors of a node.\n             * @param node A start node to find.\n             * @returns A found function node.\n             */\n            function getUpperFunction(node) {\n                let currentNode = node;\n                while (currentNode) {\n                    if (utils_1.ASTUtils.isFunction(currentNode)) {\n                        return currentNode;\n                    }\n                    currentNode = currentNode.parent;\n                }\n                return null;\n            }\n            /**\n             * Checks whether a given function node is stored to somewhere or not.\n             * If the function node is stored, the function can be used later.\n             * @param funcNode A function node to check.\n             * @param rhsNode The RHS node of the previous assignment.\n             * @returns `true` if under the following conditions:\n             *      - the funcNode is assigned to a variable.\n             *      - the funcNode is bound as an argument of a function call.\n             *      - the function is bound to a property and the object satisfies above conditions.\n             */\n            function isStorableFunction(funcNode, rhsNode) {\n                let node = funcNode;\n                let parent = funcNode.parent;\n                while (parent && isInside(parent, rhsNode)) {\n                    switch (parent.type) {\n                        case utils_1.AST_NODE_TYPES.SequenceExpression:\n                            if (parent.expressions[parent.expressions.length - 1] !== node) {\n                                return false;\n                            }\n                            break;\n                        case utils_1.AST_NODE_TYPES.CallExpression:\n                        case utils_1.AST_NODE_TYPES.NewExpression:\n                            return parent.callee !== node;\n                        case utils_1.AST_NODE_TYPES.AssignmentExpression:\n                        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n                        case utils_1.AST_NODE_TYPES.YieldExpression:\n                            return true;\n                        default:\n                            if (parent.type.endsWith('Statement') ||\n                                parent.type.endsWith('Declaration')) {\n                                /*\n                                 * If it encountered statements, this is a complex pattern.\n                                 * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                                 */\n                                return true;\n                            }\n                    }\n                    node = parent;\n                    parent = parent.parent;\n                }\n                return false;\n            }\n            const funcNode = getUpperFunction(id);\n            return (!!funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode));\n        }\n        const id = ref.identifier;\n        const parent = id.parent;\n        return (ref.isRead() && // in RHS of an assignment for itself. e.g. `a = a + 1`\n            // self update. e.g. `a += 1`, `a++`\n            ((parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression &&\n                !LOGICAL_ASSIGNMENT_OPERATORS.has(parent.operator) &&\n                isUnusedExpression(parent) &&\n                parent.left === id) ||\n                (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression &&\n                    isUnusedExpression(parent)) ||\n                (!!rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode))));\n    }\n    const functionNodes = getFunctionDefinitions(variable);\n    const isFunctionDefinition = functionNodes.size > 0;\n    const typeDeclNodes = getTypeDeclarations(variable);\n    const isTypeDecl = typeDeclNodes.size > 0;\n    const moduleDeclNodes = getModuleDeclarations(variable);\n    const isModuleDecl = moduleDeclNodes.size > 0;\n    const enumDeclNodes = getEnumDeclarations(variable);\n    const isEnumDecl = enumDeclNodes.size > 0;\n    const isImportedAsType = variable.defs.every(isTypeImport_1.isTypeImport);\n    let rhsNode = null;\n    return variable.references.some(ref => {\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return (ref.isRead() &&\n            !forItself &&\n            !(!isImportedAsType && (0, referenceContainsTypeQuery_1.referenceContainsTypeQuery)(ref.identifier)) &&\n            !(isFunctionDefinition && isSelfReference(ref, functionNodes)) &&\n            !(isTypeDecl && isInsideOneOf(ref, typeDeclNodes)) &&\n            !(isModuleDecl && isSelfReference(ref, moduleDeclNodes)) &&\n            !(isEnumDecl && isSelfReference(ref, enumDeclNodes)));\n    });\n}\n//#endregion private helpers\n/**\n * Collects the set of unused variables for a given context.\n *\n * Due to complexity, this does not take into consideration:\n * - variables within declaration files\n * - variables within ambient module declarations\n */\nfunction collectVariables(context) {\n    return UnusedVarsVisitor.collectUnusedVariables(context.sourceCode.ast, utils_1.ESLintUtils.nullThrows(context.sourceCode.scopeManager, 'Missing required scope manager'));\n}\n"
        }
    ]
}