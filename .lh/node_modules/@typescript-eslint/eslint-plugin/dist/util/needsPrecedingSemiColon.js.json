{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/needsPrecedingSemiColon.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891978477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.needsPrecedingSemicolon = needsPrecedingSemicolon;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ast_utils_1 = require(\"@typescript-eslint/utils/ast-utils\");\n// The following is adapted from `eslint`'s source code.\n// https://github.com/eslint/eslint/blob/3a4eaf921543b1cd5d1df4ea9dec02fab396af2a/lib/rules/utils/ast-utils.js#L1043-L1132\n// Could be export { isStartOfExpressionStatement } from 'eslint/lib/rules/utils/ast-utils'\nconst BREAK_OR_CONTINUE = new Set([\n    utils_1.AST_NODE_TYPES.BreakStatement,\n    utils_1.AST_NODE_TYPES.ContinueStatement,\n]);\n// Declaration types that must contain a string Literal node at the end.\nconst DECLARATIONS = new Set([\n    utils_1.AST_NODE_TYPES.ExportAllDeclaration,\n    utils_1.AST_NODE_TYPES.ExportNamedDeclaration,\n    utils_1.AST_NODE_TYPES.ImportDeclaration,\n]);\nconst IDENTIFIER_OR_KEYWORD = new Set([\n    utils_1.AST_NODE_TYPES.Identifier,\n    utils_1.AST_TOKEN_TYPES.Keyword,\n]);\n// Keywords that can immediately precede an ExpressionStatement node, mapped to the their node types.\nconst NODE_TYPES_BY_KEYWORD = {\n    __proto__: null,\n    break: utils_1.AST_NODE_TYPES.BreakStatement,\n    continue: utils_1.AST_NODE_TYPES.ContinueStatement,\n    debugger: utils_1.AST_NODE_TYPES.DebuggerStatement,\n    do: utils_1.AST_NODE_TYPES.DoWhileStatement,\n    else: utils_1.AST_NODE_TYPES.IfStatement,\n    return: utils_1.AST_NODE_TYPES.ReturnStatement,\n    yield: utils_1.AST_NODE_TYPES.YieldExpression,\n};\n/*\n * Before an opening parenthesis, postfix `++` and `--` always trigger ASI;\n * the tokens `:`, `;`, `{` and `=>` don't expect a semicolon, as that would count as an empty statement.\n */\nconst PUNCTUATORS = new Set(['--', ';', ':', '{', '++', '=>']);\n/*\n * Statements that can contain an `ExpressionStatement` after a closing parenthesis.\n * DoWhileStatement is an exception in that it always triggers ASI after the closing parenthesis.\n */\nconst STATEMENTS = new Set([\n    utils_1.AST_NODE_TYPES.DoWhileStatement,\n    utils_1.AST_NODE_TYPES.ForInStatement,\n    utils_1.AST_NODE_TYPES.ForOfStatement,\n    utils_1.AST_NODE_TYPES.ForStatement,\n    utils_1.AST_NODE_TYPES.IfStatement,\n    utils_1.AST_NODE_TYPES.WhileStatement,\n    utils_1.AST_NODE_TYPES.WithStatement,\n]);\n/**\n * Determines whether an opening parenthesis `(`, bracket `[` or backtick ``` ` ``` needs to be preceded by a semicolon.\n * This opening parenthesis or bracket should be at the start of an `ExpressionStatement`, a `MethodDefinition` or at\n * the start of the body of an `ArrowFunctionExpression`.\n * @param sourceCode The source code object.\n * @param node A node at the position where an opening parenthesis or bracket will be inserted.\n * @returns Whether a semicolon is required before the opening parenthesis or bracket.\n */\nfunction needsPrecedingSemicolon(sourceCode, node) {\n    const prevToken = sourceCode.getTokenBefore(node);\n    if (!prevToken ||\n        (prevToken.type === utils_1.AST_TOKEN_TYPES.Punctuator &&\n            PUNCTUATORS.has(prevToken.value))) {\n        return false;\n    }\n    const prevNode = sourceCode.getNodeByRangeIndex(prevToken.range[0]);\n    if (!prevNode) {\n        return false;\n    }\n    if ((0, ast_utils_1.isClosingParenToken)(prevToken)) {\n        return !STATEMENTS.has(prevNode.type);\n    }\n    if ((0, ast_utils_1.isClosingBraceToken)(prevToken)) {\n        return ((prevNode.type === utils_1.AST_NODE_TYPES.BlockStatement &&\n            prevNode.parent.type === utils_1.AST_NODE_TYPES.FunctionExpression &&\n            prevNode.parent.parent.type !== utils_1.AST_NODE_TYPES.MethodDefinition) ||\n            (prevNode.type === utils_1.AST_NODE_TYPES.ClassBody &&\n                prevNode.parent.type === utils_1.AST_NODE_TYPES.ClassExpression) ||\n            prevNode.type === utils_1.AST_NODE_TYPES.ObjectExpression);\n    }\n    if (!prevNode.parent) {\n        return false;\n    }\n    if (IDENTIFIER_OR_KEYWORD.has(prevToken.type)) {\n        if (BREAK_OR_CONTINUE.has(prevNode.parent.type)) {\n            return false;\n        }\n        const keyword = prevToken.value;\n        const nodeType = NODE_TYPES_BY_KEYWORD[keyword];\n        return prevNode.type !== nodeType;\n    }\n    if (prevToken.type === utils_1.AST_TOKEN_TYPES.String) {\n        return !DECLARATIONS.has(prevNode.parent.type);\n    }\n    return true;\n}\n"
        }
    ]
}