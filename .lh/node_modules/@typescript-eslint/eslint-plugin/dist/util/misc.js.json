{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/misc.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891978408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isStaticMemberAccessOfValue = exports.MemberNameType = void 0;\nexports.isDefinitionFile = isDefinitionFile;\nexports.upperCaseFirst = upperCaseFirst;\nexports.arrayGroupByToMap = arrayGroupByToMap;\nexports.arraysAreEqual = arraysAreEqual;\nexports.findFirstResult = findFirstResult;\nexports.getNameFromIndexSignature = getNameFromIndexSignature;\nexports.getNameFromMember = getNameFromMember;\nexports.getEnumNames = getEnumNames;\nexports.formatWordList = formatWordList;\nexports.findLastIndex = findLastIndex;\nexports.typeNodeRequiresParentheses = typeNodeRequiresParentheses;\nexports.isRestParameterDeclaration = isRestParameterDeclaration;\nexports.isParenlessArrowFunction = isParenlessArrowFunction;\nexports.getStaticMemberAccessValue = getStaticMemberAccessValue;\nconst type_utils_1 = require(\"@typescript-eslint/type-utils\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst astUtils_1 = require(\"./astUtils\");\nconst DEFINITION_EXTENSIONS = [\n    ts.Extension.Dts,\n    ts.Extension.Dcts,\n    ts.Extension.Dmts,\n];\n/**\n * Check if the context file name is *.d.ts or *.d.tsx\n */\nfunction isDefinitionFile(fileName) {\n    const lowerFileName = fileName.toLowerCase();\n    for (const definitionExt of DEFINITION_EXTENSIONS) {\n        if (lowerFileName.endsWith(definitionExt)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Upper cases the first character or the string\n */\nfunction upperCaseFirst(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nfunction arrayGroupByToMap(array, getKey) {\n    const groups = new Map();\n    for (const item of array) {\n        const key = getKey(item);\n        const existing = groups.get(key);\n        if (existing) {\n            existing.push(item);\n        }\n        else {\n            groups.set(key, [item]);\n        }\n    }\n    return groups;\n}\nfunction arraysAreEqual(a, b, eq) {\n    return (a === b ||\n        (a != null &&\n            b != null &&\n            a.length === b.length &&\n            a.every((x, idx) => eq(x, b[idx]))));\n}\n/** Returns the first non-`undefined` result. */\nfunction findFirstResult(inputs, getResult) {\n    for (const element of inputs) {\n        const result = getResult(element);\n        // eslint-disable-next-line @typescript-eslint/internal/eqeq-nullish\n        if (result !== undefined) {\n            return result;\n        }\n    }\n    return undefined;\n}\n/**\n * Gets a string representation of the name of the index signature.\n */\nfunction getNameFromIndexSignature(node) {\n    const propName = node.parameters.find((parameter) => parameter.type === utils_1.AST_NODE_TYPES.Identifier);\n    return propName ? propName.name : '(index signature)';\n}\nvar MemberNameType;\n(function (MemberNameType) {\n    MemberNameType[MemberNameType[\"Private\"] = 1] = \"Private\";\n    MemberNameType[MemberNameType[\"Quoted\"] = 2] = \"Quoted\";\n    MemberNameType[MemberNameType[\"Normal\"] = 3] = \"Normal\";\n    MemberNameType[MemberNameType[\"Expression\"] = 4] = \"Expression\";\n})(MemberNameType || (exports.MemberNameType = MemberNameType = {}));\n/**\n * Gets a string name representation of the name of the given MethodDefinition\n * or PropertyDefinition node, with handling for computed property names.\n */\nfunction getNameFromMember(member, sourceCode) {\n    if (member.key.type === utils_1.AST_NODE_TYPES.Identifier) {\n        return {\n            name: member.key.name,\n            type: MemberNameType.Normal,\n        };\n    }\n    if (member.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n        return {\n            name: `#${member.key.name}`,\n            type: MemberNameType.Private,\n        };\n    }\n    if (member.key.type === utils_1.AST_NODE_TYPES.Literal) {\n        const name = `${member.key.value}`;\n        if ((0, type_utils_1.requiresQuoting)(name)) {\n            return {\n                name: `\"${name}\"`,\n                type: MemberNameType.Quoted,\n            };\n        }\n        return {\n            name,\n            type: MemberNameType.Normal,\n        };\n    }\n    return {\n        name: sourceCode.text.slice(...member.key.range),\n        type: MemberNameType.Expression,\n    };\n}\nfunction getEnumNames(myEnum) {\n    return Object.keys(myEnum).filter(x => isNaN(Number(x)));\n}\n/**\n * Given an array of words, returns an English-friendly concatenation, separated with commas, with\n * the `and` clause inserted before the last item.\n *\n * Example: ['foo', 'bar', 'baz' ] returns the string \"foo, bar, and baz\".\n */\nfunction formatWordList(words) {\n    if (!words.length) {\n        return '';\n    }\n    if (words.length === 1) {\n        return words[0];\n    }\n    return [words.slice(0, -1).join(', '), words.slice(-1)[0]].join(' and ');\n}\n/**\n * Iterates the array in reverse and returns the index of the first element it\n * finds which passes the predicate function.\n *\n * @returns Returns the index of the element if it finds it or -1 otherwise.\n */\nfunction findLastIndex(members, predicate) {\n    let idx = members.length - 1;\n    while (idx >= 0) {\n        const valid = predicate(members[idx]);\n        if (valid) {\n            return idx;\n        }\n        idx--;\n    }\n    return -1;\n}\nfunction typeNodeRequiresParentheses(node, text) {\n    return (node.type === utils_1.AST_NODE_TYPES.TSFunctionType ||\n        node.type === utils_1.AST_NODE_TYPES.TSConstructorType ||\n        node.type === utils_1.AST_NODE_TYPES.TSConditionalType ||\n        (node.type === utils_1.AST_NODE_TYPES.TSUnionType && text.startsWith('|')) ||\n        (node.type === utils_1.AST_NODE_TYPES.TSIntersectionType && text.startsWith('&')));\n}\nfunction isRestParameterDeclaration(decl) {\n    return ts.isParameter(decl) && decl.dotDotDotToken != null;\n}\nfunction isParenlessArrowFunction(node, sourceCode) {\n    return (node.params.length === 1 && !(0, astUtils_1.isParenthesized)(node.params[0], sourceCode));\n}\n/**\n * Gets a member being accessed or declared if its value can be determined statically, and\n * resolves it to the string or symbol value that will be used as the actual member\n * access key at runtime. Otherwise, returns `undefined`.\n *\n * ```ts\n * x.member // returns 'member'\n * ^^^^^^^^\n *\n * x?.member // returns 'member' (optional chaining is treated the same)\n * ^^^^^^^^^\n *\n * x['value'] // returns 'value'\n * ^^^^^^^^^^\n *\n * x[Math.random()] // returns undefined (not a static value)\n * ^^^^^^^^^^^^^^^^\n *\n * arr[0] // returns '0' (NOT 0)\n * ^^^^^^\n *\n * arr[0n] // returns '0' (NOT 0n)\n * ^^^^^^^\n *\n * const s = Symbol.for('symbolName')\n * x[s] // returns `Symbol.for('symbolName')` (since it's a static/global symbol)\n * ^^^^\n *\n * const us = Symbol('symbolName')\n * x[us] // returns undefined (since it's a unique symbol, so not statically analyzable)\n * ^^^^^\n *\n * var object = {\n *     1234: '4567', // returns '1234' (NOT 1234)\n *     ^^^^^^^^^^^^\n *     method() { } // returns 'method'\n *     ^^^^^^^^^^^^\n * }\n *\n * class WithMembers {\n *     foo: string // returns 'foo'\n *     ^^^^^^^^^^^\n * }\n * ```\n */\nfunction getStaticMemberAccessValue(node, { sourceCode }) {\n    const key = node.type === utils_1.AST_NODE_TYPES.MemberExpression ? node.property : node.key;\n    const { type } = key;\n    if (!node.computed &&\n        (type === utils_1.AST_NODE_TYPES.Identifier ||\n            type === utils_1.AST_NODE_TYPES.PrivateIdentifier)) {\n        return key.name;\n    }\n    const result = (0, astUtils_1.getStaticValue)(key, sourceCode.getScope(node));\n    if (!result) {\n        return undefined;\n    }\n    const { value } = result;\n    return typeof value === 'symbol' ? value : String(value);\n}\n/**\n * Answers whether the member expression looks like\n * `x.value`, `x['value']`,\n * or even `const v = 'value'; x[v]` (or optional variants thereof).\n */\nconst isStaticMemberAccessOfValue = (memberExpression, context, ...values) => values.includes(getStaticMemberAccessValue(memberExpression, context));\nexports.isStaticMemberAccessOfValue = isStaticMemberAccessOfValue;\n"
        }
    ]
}