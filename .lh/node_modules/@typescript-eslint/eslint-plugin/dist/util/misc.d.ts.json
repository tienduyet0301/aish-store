{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/misc.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891978355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Really small utility functions that didn't deserve their own files\n */\nimport type { TSESLint, TSESTree } from '@typescript-eslint/utils';\nimport type { RuleContext } from '@typescript-eslint/utils/ts-eslint';\nimport * as ts from 'typescript';\n/**\n * Check if the context file name is *.d.ts or *.d.tsx\n */\nexport declare function isDefinitionFile(fileName: string): boolean;\n/**\n * Upper cases the first character or the string\n */\nexport declare function upperCaseFirst(str: string): string;\nexport declare function arrayGroupByToMap<T, Key extends number | string>(array: T[], getKey: (item: T) => Key): Map<Key, T[]>;\n/** Return true if both parameters are equal. */\nexport type Equal<T> = (a: T, b: T) => boolean;\nexport declare function arraysAreEqual<T>(a: T[] | undefined, b: T[] | undefined, eq: (a: T, b: T) => boolean): boolean;\n/** Returns the first non-`undefined` result. */\nexport declare function findFirstResult<T, U>(inputs: T[], getResult: (t: T) => U | undefined): U | undefined;\n/**\n * Gets a string representation of the name of the index signature.\n */\nexport declare function getNameFromIndexSignature(node: TSESTree.TSIndexSignature): string;\nexport declare enum MemberNameType {\n    Private = 1,\n    Quoted = 2,\n    Normal = 3,\n    Expression = 4\n}\n/**\n * Gets a string name representation of the name of the given MethodDefinition\n * or PropertyDefinition node, with handling for computed property names.\n */\nexport declare function getNameFromMember(member: TSESTree.AccessorProperty | TSESTree.MethodDefinition | TSESTree.Property | TSESTree.PropertyDefinition | TSESTree.TSAbstractAccessorProperty | TSESTree.TSAbstractMethodDefinition | TSESTree.TSAbstractPropertyDefinition | TSESTree.TSMethodSignature | TSESTree.TSPropertySignature, sourceCode: TSESLint.SourceCode): {\n    name: string;\n    type: MemberNameType;\n};\nexport type ExcludeKeys<Obj extends Record<string, unknown>, Keys extends keyof Obj> = {\n    [k in Exclude<keyof Obj, Keys>]: Obj[k];\n};\nexport type RequireKeys<Obj extends Record<string, unknown>, Keys extends keyof Obj> = {\n    [k in Keys]-?: Exclude<Obj[k], undefined>;\n} & ExcludeKeys<Obj, Keys>;\nexport declare function getEnumNames<T extends string>(myEnum: Record<T, unknown>): T[];\n/**\n * Given an array of words, returns an English-friendly concatenation, separated with commas, with\n * the `and` clause inserted before the last item.\n *\n * Example: ['foo', 'bar', 'baz' ] returns the string \"foo, bar, and baz\".\n */\nexport declare function formatWordList(words: string[]): string;\n/**\n * Iterates the array in reverse and returns the index of the first element it\n * finds which passes the predicate function.\n *\n * @returns Returns the index of the element if it finds it or -1 otherwise.\n */\nexport declare function findLastIndex<T>(members: T[], predicate: (member: T) => boolean | null | undefined): number;\nexport declare function typeNodeRequiresParentheses(node: TSESTree.TypeNode, text: string): boolean;\nexport declare function isRestParameterDeclaration(decl: ts.Declaration): boolean;\nexport declare function isParenlessArrowFunction(node: TSESTree.ArrowFunctionExpression, sourceCode: TSESLint.SourceCode): boolean;\nexport type NodeWithKey = TSESTree.AccessorProperty | TSESTree.MemberExpression | TSESTree.MethodDefinition | TSESTree.Property | TSESTree.PropertyDefinition | TSESTree.TSAbstractMethodDefinition | TSESTree.TSAbstractPropertyDefinition;\n/**\n * Gets a member being accessed or declared if its value can be determined statically, and\n * resolves it to the string or symbol value that will be used as the actual member\n * access key at runtime. Otherwise, returns `undefined`.\n *\n * ```ts\n * x.member // returns 'member'\n * ^^^^^^^^\n *\n * x?.member // returns 'member' (optional chaining is treated the same)\n * ^^^^^^^^^\n *\n * x['value'] // returns 'value'\n * ^^^^^^^^^^\n *\n * x[Math.random()] // returns undefined (not a static value)\n * ^^^^^^^^^^^^^^^^\n *\n * arr[0] // returns '0' (NOT 0)\n * ^^^^^^\n *\n * arr[0n] // returns '0' (NOT 0n)\n * ^^^^^^^\n *\n * const s = Symbol.for('symbolName')\n * x[s] // returns `Symbol.for('symbolName')` (since it's a static/global symbol)\n * ^^^^\n *\n * const us = Symbol('symbolName')\n * x[us] // returns undefined (since it's a unique symbol, so not statically analyzable)\n * ^^^^^\n *\n * var object = {\n *     1234: '4567', // returns '1234' (NOT 1234)\n *     ^^^^^^^^^^^^\n *     method() { } // returns 'method'\n *     ^^^^^^^^^^^^\n * }\n *\n * class WithMembers {\n *     foo: string // returns 'foo'\n *     ^^^^^^^^^^^\n * }\n * ```\n */\nexport declare function getStaticMemberAccessValue(node: NodeWithKey, { sourceCode }: RuleContext<string, unknown[]>): string | symbol | undefined;\n/**\n * Answers whether the member expression looks like\n * `x.value`, `x['value']`,\n * or even `const v = 'value'; x[v]` (or optional variants thereof).\n */\nexport declare const isStaticMemberAccessOfValue: (memberExpression: NodeWithKey, context: RuleContext<string, unknown[]>, ...values: (string | symbol)[]) => boolean;\n//# sourceMappingURL=misc.d.ts.map"
        }
    ]
}