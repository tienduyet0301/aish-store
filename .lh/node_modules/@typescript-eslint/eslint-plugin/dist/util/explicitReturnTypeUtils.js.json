{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/explicitReturnTypeUtils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891976436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.doesImmediatelyReturnFunctionExpression = doesImmediatelyReturnFunctionExpression;\nexports.isTypedFunctionExpression = isTypedFunctionExpression;\nexports.isValidFunctionExpressionReturnType = isValidFunctionExpressionReturnType;\nexports.checkFunctionReturnType = checkFunctionReturnType;\nexports.checkFunctionExpressionReturnType = checkFunctionExpressionReturnType;\nexports.ancestorHasReturnType = ancestorHasReturnType;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst astUtils_1 = require(\"./astUtils\");\nconst getFunctionHeadLoc_1 = require(\"./getFunctionHeadLoc\");\n/**\n * Checks if a node is a variable declarator with a type annotation.\n * ```\n * const x: Foo = ...\n * ```\n */\nfunction isVariableDeclaratorWithTypeAnnotation(node) {\n    return (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator && !!node.id.typeAnnotation);\n}\n/**\n * Checks if a node is a class property with a type annotation.\n * ```\n * public x: Foo = ...\n * ```\n */\nfunction isPropertyDefinitionWithTypeAnnotation(node) {\n    return (node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && !!node.typeAnnotation);\n}\n/**\n * Checks if a node belongs to:\n * ```\n * foo(() => 1)\n * ```\n */\nfunction isFunctionArgument(parent, callee) {\n    return (parent.type === utils_1.AST_NODE_TYPES.CallExpression &&\n        // make sure this isn't an IIFE\n        parent.callee !== callee);\n}\n/**\n * Checks if a node is type-constrained in JSX\n * ```\n * <Foo x={() => {}} />\n * <Bar>{() => {}}</Bar>\n * <Baz {...props} />\n * ```\n */\nfunction isTypedJSX(node) {\n    return (node.type === utils_1.AST_NODE_TYPES.JSXExpressionContainer ||\n        node.type === utils_1.AST_NODE_TYPES.JSXSpreadAttribute);\n}\nfunction isTypedParent(parent, callee) {\n    return ((0, astUtils_1.isTypeAssertion)(parent) ||\n        isVariableDeclaratorWithTypeAnnotation(parent) ||\n        isDefaultFunctionParameterWithTypeAnnotation(parent) ||\n        isPropertyDefinitionWithTypeAnnotation(parent) ||\n        isFunctionArgument(parent, callee) ||\n        isTypedJSX(parent));\n}\nfunction isDefaultFunctionParameterWithTypeAnnotation(node) {\n    return (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern &&\n        node.left.typeAnnotation != null);\n}\n/**\n * Checks if a node belongs to:\n * ```\n * new Foo(() => {})\n *         ^^^^^^^^\n * ```\n */\nfunction isConstructorArgument(node) {\n    return node.type === utils_1.AST_NODE_TYPES.NewExpression;\n}\n/**\n * Checks if a node is a property or a nested property of a typed object:\n * ```\n * const x: Foo = { prop: () => {} }\n * const x = { prop: () => {} } as Foo\n * const x = <Foo>{ prop: () => {} }\n * const x: Foo = { bar: { prop: () => {} } }\n * ```\n */\nfunction isPropertyOfObjectWithType(property) {\n    if (!property || property.type !== utils_1.AST_NODE_TYPES.Property) {\n        return false;\n    }\n    const objectExpr = property.parent;\n    if (objectExpr.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {\n        return false;\n    }\n    const parent = objectExpr.parent;\n    return isTypedParent(parent) || isPropertyOfObjectWithType(parent);\n}\n/**\n * Checks if a function belongs to:\n * ```\n * () => () => ...\n * () => function () { ... }\n * () => { return () => ... }\n * () => { return function () { ... } }\n * function fn() { return () => ... }\n * function fn() { return function() { ... } }\n * ```\n */\nfunction doesImmediatelyReturnFunctionExpression({ node, returns, }) {\n    if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n        utils_1.ASTUtils.isFunction(node.body)) {\n        return true;\n    }\n    if (returns.length === 0) {\n        return false;\n    }\n    return returns.every(node => node.argument && utils_1.ASTUtils.isFunction(node.argument));\n}\n/**\n * Checks if a function belongs to:\n * ```\n * ({ action: 'xxx' } as const)\n * ```\n */\nfunction isConstAssertion(node) {\n    if ((0, astUtils_1.isTypeAssertion)(node)) {\n        const { typeAnnotation } = node;\n        if (typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n            const { typeName } = typeAnnotation;\n            if (typeName.type === utils_1.AST_NODE_TYPES.Identifier &&\n                typeName.name === 'const') {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * True when the provided function expression is typed.\n */\nfunction isTypedFunctionExpression(node, options) {\n    const parent = utils_1.ESLintUtils.nullThrows(node.parent, utils_1.ESLintUtils.NullThrowsReasons.MissingParent);\n    if (!options.allowTypedFunctionExpressions) {\n        return false;\n    }\n    return (isTypedParent(parent, node) ||\n        isPropertyOfObjectWithType(parent) ||\n        isConstructorArgument(parent));\n}\n/**\n * Check whether the function expression return type is either typed or valid\n * with the provided options.\n */\nfunction isValidFunctionExpressionReturnType(node, options) {\n    if (isTypedFunctionExpression(node, options)) {\n        return true;\n    }\n    const parent = utils_1.ESLintUtils.nullThrows(node.parent, utils_1.ESLintUtils.NullThrowsReasons.MissingParent);\n    if (options.allowExpressions &&\n        parent.type !== utils_1.AST_NODE_TYPES.VariableDeclarator &&\n        parent.type !== utils_1.AST_NODE_TYPES.MethodDefinition &&\n        parent.type !== utils_1.AST_NODE_TYPES.ExportDefaultDeclaration &&\n        parent.type !== utils_1.AST_NODE_TYPES.PropertyDefinition) {\n        return true;\n    }\n    // https://github.com/typescript-eslint/typescript-eslint/issues/653\n    if (!options.allowDirectConstAssertionInArrowFunctions ||\n        node.type !== utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n        return false;\n    }\n    let body = node.body;\n    while (body.type === utils_1.AST_NODE_TYPES.TSSatisfiesExpression) {\n        body = body.expression;\n    }\n    return isConstAssertion(body);\n}\n/**\n * Check that the function expression or declaration is valid.\n */\nfunction isValidFunctionReturnType({ node, returns }, options) {\n    if (options.allowHigherOrderFunctions &&\n        doesImmediatelyReturnFunctionExpression({ node, returns })) {\n        return true;\n    }\n    return (node.returnType != null ||\n        (0, astUtils_1.isConstructor)(node.parent) ||\n        (0, astUtils_1.isSetter)(node.parent));\n}\n/**\n * Checks if a function declaration/expression has a return type.\n */\nfunction checkFunctionReturnType({ node, returns }, options, sourceCode, report) {\n    if (isValidFunctionReturnType({ node, returns }, options)) {\n        return;\n    }\n    report((0, getFunctionHeadLoc_1.getFunctionHeadLoc)(node, sourceCode));\n}\n/**\n * Checks if a function declaration/expression has a return type.\n */\nfunction checkFunctionExpressionReturnType(info, options, sourceCode, report) {\n    if (isValidFunctionExpressionReturnType(info.node, options)) {\n        return;\n    }\n    checkFunctionReturnType(info, options, sourceCode, report);\n}\n/**\n * Check whether any ancestor of the provided function has a valid return type.\n */\nfunction ancestorHasReturnType(node) {\n    let ancestor = node.parent;\n    if (ancestor.type === utils_1.AST_NODE_TYPES.Property) {\n        ancestor = ancestor.value;\n    }\n    // if the ancestor is not a return, then this function was not returned at all, so we can exit early\n    const isReturnStatement = ancestor.type === utils_1.AST_NODE_TYPES.ReturnStatement;\n    const isBodylessArrow = ancestor.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n        ancestor.body.type !== utils_1.AST_NODE_TYPES.BlockStatement;\n    if (!isReturnStatement && !isBodylessArrow) {\n        return false;\n    }\n    while (ancestor) {\n        switch (ancestor.type) {\n            case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n            case utils_1.AST_NODE_TYPES.FunctionExpression:\n            case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n                if (ancestor.returnType) {\n                    return true;\n                }\n                break;\n            // const x: Foo = () => {};\n            // Assume that a typed variable types the function expression\n            case utils_1.AST_NODE_TYPES.VariableDeclarator:\n                return !!ancestor.id.typeAnnotation;\n            case utils_1.AST_NODE_TYPES.PropertyDefinition:\n                return !!ancestor.typeAnnotation;\n            case utils_1.AST_NODE_TYPES.ExpressionStatement:\n                return false;\n        }\n        ancestor = ancestor.parent;\n    }\n    return false;\n}\n"
        }
    ]
}