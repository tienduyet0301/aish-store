{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/getWrappingFixer.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891977567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWrappingFixer = getWrappingFixer;\nexports.getMovedNodeCode = getMovedNodeCode;\nexports.isStrongPrecedenceNode = isStrongPrecedenceNode;\nconst utils_1 = require(\"@typescript-eslint/utils\");\n/**\n * Wraps node with some code. Adds parenthesis as necessary.\n * @returns Fixer which adds the specified code and parens if necessary.\n */\nfunction getWrappingFixer(params) {\n    const { node, innerNode = node, sourceCode, wrap } = params;\n    const innerNodes = Array.isArray(innerNode) ? innerNode : [innerNode];\n    return (fixer) => {\n        const innerCodes = innerNodes.map(innerNode => {\n            let code = sourceCode.getText(innerNode);\n            /**\n             * Wrap our node in parens to prevent the following cases:\n             * - It has a weaker precedence than the code we are wrapping it in\n             * - It's gotten mistaken as block statement instead of object expression\n             */\n            if (!isStrongPrecedenceNode(innerNode) ||\n                isObjectExpressionInOneLineReturn(node, innerNode)) {\n                code = `(${code})`;\n            }\n            return code;\n        });\n        // do the wrapping\n        let code = wrap(...innerCodes);\n        // check the outer expression's precedence\n        if (isWeakPrecedenceParent(node) &&\n            // we wrapped the node in some expression which very likely has a different precedence than original wrapped node\n            // let's wrap the whole expression in parens just in case\n            !utils_1.ASTUtils.isParenthesized(node, sourceCode)) {\n            code = `(${code})`;\n        }\n        // check if we need to insert semicolon\n        if (/^[`([]/.test(code) && isMissingSemicolonBefore(node, sourceCode)) {\n            code = `;${code}`;\n        }\n        return fixer.replaceText(node, code);\n    };\n}\n/**\n * If the node to be moved and the destination node require parentheses, include parentheses in the node to be moved.\n * @param sourceCode Source code of current file\n * @param nodeToMove Nodes that need to be moved\n * @param destinationNode Final destination node with nodeToMove\n * @returns If parentheses are required, code for the nodeToMove node is returned with parentheses at both ends of the code.\n */\nfunction getMovedNodeCode(params) {\n    const { destinationNode, nodeToMove: existingNode, sourceCode } = params;\n    const code = sourceCode.getText(existingNode);\n    if (isStrongPrecedenceNode(existingNode)) {\n        // Moved node never needs parens\n        return code;\n    }\n    if (!isWeakPrecedenceParent(destinationNode)) {\n        // Destination would never needs parens, regardless what node moves there\n        return code;\n    }\n    // Parens may be necessary\n    return `(${code})`;\n}\n/**\n * Check if a node will always have the same precedence if it's parent changes.\n */\nfunction isStrongPrecedenceNode(innerNode) {\n    return (innerNode.type === utils_1.AST_NODE_TYPES.Literal ||\n        innerNode.type === utils_1.AST_NODE_TYPES.Identifier ||\n        innerNode.type === utils_1.AST_NODE_TYPES.TSTypeReference ||\n        innerNode.type === utils_1.AST_NODE_TYPES.TSTypeOperator ||\n        innerNode.type === utils_1.AST_NODE_TYPES.ArrayExpression ||\n        innerNode.type === utils_1.AST_NODE_TYPES.ObjectExpression ||\n        innerNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||\n        innerNode.type === utils_1.AST_NODE_TYPES.CallExpression ||\n        innerNode.type === utils_1.AST_NODE_TYPES.NewExpression ||\n        innerNode.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression ||\n        innerNode.type === utils_1.AST_NODE_TYPES.TSInstantiationExpression);\n}\n/**\n * Check if a node's parent could have different precedence if the node changes.\n */\nfunction isWeakPrecedenceParent(node) {\n    const parent = node.parent;\n    if (!parent) {\n        return false;\n    }\n    if (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.UnaryExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.BinaryExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.LogicalExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.AwaitExpression) {\n        return true;\n    }\n    if (parent.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n        parent.object === node) {\n        return true;\n    }\n    if ((parent.type === utils_1.AST_NODE_TYPES.CallExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.NewExpression) &&\n        parent.callee === node) {\n        return true;\n    }\n    if (parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression &&\n        parent.tag === node) {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if a node is at the beginning of expression statement and the statement above doesn't end with semicolon.\n * Doesn't check if the node begins with `(`, `[` or `` ` ``.\n */\nfunction isMissingSemicolonBefore(node, sourceCode) {\n    for (;;) {\n        // https://github.com/typescript-eslint/typescript-eslint/issues/6225\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const parent = node.parent;\n        if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n            const block = parent.parent;\n            if (block.type === utils_1.AST_NODE_TYPES.Program ||\n                block.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n                // parent is an expression statement in a block\n                const statementIndex = block.body.indexOf(parent);\n                const previousStatement = block.body[statementIndex - 1];\n                if (statementIndex > 0 &&\n                    utils_1.ESLintUtils.nullThrows(sourceCode.getLastToken(previousStatement), 'Mismatched semicolon and block').value !== ';') {\n                    return true;\n                }\n            }\n        }\n        if (!isLeftHandSide(node)) {\n            return false;\n        }\n        node = parent;\n    }\n}\n/**\n * Checks if a node is LHS of an operator.\n */\nfunction isLeftHandSide(node) {\n    // https://github.com/typescript-eslint/typescript-eslint/issues/6225\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const parent = node.parent;\n    // a++\n    if (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression) {\n        return true;\n    }\n    // a + b\n    if ((parent.type === utils_1.AST_NODE_TYPES.BinaryExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.LogicalExpression ||\n        parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression) &&\n        node === parent.left) {\n        return true;\n    }\n    // a ? b : c\n    if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression &&\n        node === parent.test) {\n        return true;\n    }\n    // a(b)\n    if (parent.type === utils_1.AST_NODE_TYPES.CallExpression && node === parent.callee) {\n        return true;\n    }\n    // a`b`\n    if (parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression &&\n        node === parent.tag) {\n        return true;\n    }\n    return false;\n}\n/**\n * Checks if a node's parent is arrow function expression and a inner node is object expression\n */\nfunction isObjectExpressionInOneLineReturn(node, innerNode) {\n    return (node.parent?.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n        node.parent.body === node &&\n        innerNode.type === utils_1.AST_NODE_TYPES.ObjectExpression);\n}\n"
        }
    ]
}