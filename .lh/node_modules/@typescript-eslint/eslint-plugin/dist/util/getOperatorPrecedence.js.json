{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/getOperatorPrecedence.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891977019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OperatorPrecedence = void 0;\nexports.getOperatorPrecedenceForNode = getOperatorPrecedenceForNode;\nexports.getOperatorPrecedence = getOperatorPrecedence;\nexports.getBinaryOperatorPrecedence = getBinaryOperatorPrecedence;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst typescript_1 = require(\"typescript\");\nvar OperatorPrecedence;\n(function (OperatorPrecedence) {\n    // Expression:\n    //     AssignmentExpression\n    //     Expression `,` AssignmentExpression\n    OperatorPrecedence[OperatorPrecedence[\"Comma\"] = 0] = \"Comma\";\n    // NOTE: `Spread` is higher than `Comma` due to how it is parsed in |ElementList|\n    // SpreadElement:\n    //     `...` AssignmentExpression\n    OperatorPrecedence[OperatorPrecedence[\"Spread\"] = 1] = \"Spread\";\n    // AssignmentExpression:\n    //     ConditionalExpression\n    //     YieldExpression\n    //     ArrowFunction\n    //     AsyncArrowFunction\n    //     LeftHandSideExpression `=` AssignmentExpression\n    //     LeftHandSideExpression AssignmentOperator AssignmentExpression\n    //\n    // NOTE: AssignmentExpression is broken down into several precedences due to the requirements\n    //       of the parenthesize rules.\n    // AssignmentExpression: YieldExpression\n    // YieldExpression:\n    //     `yield`\n    //     `yield` AssignmentExpression\n    //     `yield` `*` AssignmentExpression\n    OperatorPrecedence[OperatorPrecedence[\"Yield\"] = 2] = \"Yield\";\n    // AssignmentExpression: LeftHandSideExpression `=` AssignmentExpression\n    // AssignmentExpression: LeftHandSideExpression AssignmentOperator AssignmentExpression\n    // AssignmentOperator: one of\n    //     `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=` `**=`\n    OperatorPrecedence[OperatorPrecedence[\"Assignment\"] = 3] = \"Assignment\";\n    // NOTE: `Conditional` is considered higher than `Assignment` here, but in reality they have\n    //       the same precedence.\n    // AssignmentExpression: ConditionalExpression\n    // ConditionalExpression:\n    //     ShortCircuitExpression\n    //     ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression\n    // ShortCircuitExpression:\n    //     LogicalORExpression\n    //     CoalesceExpression\n    OperatorPrecedence[OperatorPrecedence[\"Conditional\"] = 4] = \"Conditional\";\n    // CoalesceExpression:\n    //     CoalesceExpressionHead `??` BitwiseORExpression\n    // CoalesceExpressionHead:\n    //     CoalesceExpression\n    //     BitwiseORExpression\n    OperatorPrecedence[OperatorPrecedence[\"Coalesce\"] = 4] = \"Coalesce\";\n    // LogicalORExpression:\n    //     LogicalANDExpression\n    //     LogicalORExpression `||` LogicalANDExpression\n    OperatorPrecedence[OperatorPrecedence[\"LogicalOR\"] = 5] = \"LogicalOR\";\n    // LogicalANDExpression:\n    //     BitwiseORExpression\n    //     LogicalANDExpression `&&` BitwiseORExpression\n    OperatorPrecedence[OperatorPrecedence[\"LogicalAND\"] = 6] = \"LogicalAND\";\n    // BitwiseORExpression:\n    //     BitwiseXORExpression\n    //     BitwiseORExpression `^` BitwiseXORExpression\n    OperatorPrecedence[OperatorPrecedence[\"BitwiseOR\"] = 7] = \"BitwiseOR\";\n    // BitwiseXORExpression:\n    //     BitwiseANDExpression\n    //     BitwiseXORExpression `^` BitwiseANDExpression\n    OperatorPrecedence[OperatorPrecedence[\"BitwiseXOR\"] = 8] = \"BitwiseXOR\";\n    // BitwiseANDExpression:\n    //     EqualityExpression\n    //     BitwiseANDExpression `^` EqualityExpression\n    OperatorPrecedence[OperatorPrecedence[\"BitwiseAND\"] = 9] = \"BitwiseAND\";\n    // EqualityExpression:\n    //     RelationalExpression\n    //     EqualityExpression `==` RelationalExpression\n    //     EqualityExpression `!=` RelationalExpression\n    //     EqualityExpression `===` RelationalExpression\n    //     EqualityExpression `!==` RelationalExpression\n    OperatorPrecedence[OperatorPrecedence[\"Equality\"] = 10] = \"Equality\";\n    // RelationalExpression:\n    //     ShiftExpression\n    //     RelationalExpression `<` ShiftExpression\n    //     RelationalExpression `>` ShiftExpression\n    //     RelationalExpression `<=` ShiftExpression\n    //     RelationalExpression `>=` ShiftExpression\n    //     RelationalExpression `instanceof` ShiftExpression\n    //     RelationalExpression `in` ShiftExpression\n    //     [+TypeScript] RelationalExpression `as` Type\n    OperatorPrecedence[OperatorPrecedence[\"Relational\"] = 11] = \"Relational\";\n    // ShiftExpression:\n    //     AdditiveExpression\n    //     ShiftExpression `<<` AdditiveExpression\n    //     ShiftExpression `>>` AdditiveExpression\n    //     ShiftExpression `>>>` AdditiveExpression\n    OperatorPrecedence[OperatorPrecedence[\"Shift\"] = 12] = \"Shift\";\n    // AdditiveExpression:\n    //     MultiplicativeExpression\n    //     AdditiveExpression `+` MultiplicativeExpression\n    //     AdditiveExpression `-` MultiplicativeExpression\n    OperatorPrecedence[OperatorPrecedence[\"Additive\"] = 13] = \"Additive\";\n    // MultiplicativeExpression:\n    //     ExponentiationExpression\n    //     MultiplicativeExpression MultiplicativeOperator ExponentiationExpression\n    // MultiplicativeOperator: one of `*`, `/`, `%`\n    OperatorPrecedence[OperatorPrecedence[\"Multiplicative\"] = 14] = \"Multiplicative\";\n    // ExponentiationExpression:\n    //     UnaryExpression\n    //     UpdateExpression `**` ExponentiationExpression\n    OperatorPrecedence[OperatorPrecedence[\"Exponentiation\"] = 15] = \"Exponentiation\";\n    // UnaryExpression:\n    //     UpdateExpression\n    //     `delete` UnaryExpression\n    //     `void` UnaryExpression\n    //     `typeof` UnaryExpression\n    //     `+` UnaryExpression\n    //     `-` UnaryExpression\n    //     `~` UnaryExpression\n    //     `!` UnaryExpression\n    //     AwaitExpression\n    // UpdateExpression:            // TODO: Do we need to investigate the precedence here?\n    //     `++` UnaryExpression\n    //     `--` UnaryExpression\n    OperatorPrecedence[OperatorPrecedence[\"Unary\"] = 16] = \"Unary\";\n    // UpdateExpression:\n    //     LeftHandSideExpression\n    //     LeftHandSideExpression `++`\n    //     LeftHandSideExpression `--`\n    OperatorPrecedence[OperatorPrecedence[\"Update\"] = 17] = \"Update\";\n    // LeftHandSideExpression:\n    //     NewExpression\n    //     CallExpression\n    // NewExpression:\n    //     MemberExpression\n    //     `new` NewExpression\n    OperatorPrecedence[OperatorPrecedence[\"LeftHandSide\"] = 18] = \"LeftHandSide\";\n    // CallExpression:\n    //     CoverCallExpressionAndAsyncArrowHead\n    //     SuperCall\n    //     ImportCall\n    //     CallExpression Arguments\n    //     CallExpression `[` Expression `]`\n    //     CallExpression `.` IdentifierName\n    //     CallExpression TemplateLiteral\n    // MemberExpression:\n    //     PrimaryExpression\n    //     MemberExpression `[` Expression `]`\n    //     MemberExpression `.` IdentifierName\n    //     MemberExpression TemplateLiteral\n    //     SuperProperty\n    //     MetaProperty\n    //     `new` MemberExpression Arguments\n    OperatorPrecedence[OperatorPrecedence[\"Member\"] = 19] = \"Member\";\n    // TODO: JSXElement?\n    // PrimaryExpression:\n    //     `this`\n    //     IdentifierReference\n    //     Literal\n    //     ArrayLiteral\n    //     ObjectLiteral\n    //     FunctionExpression\n    //     ClassExpression\n    //     GeneratorExpression\n    //     AsyncFunctionExpression\n    //     AsyncGeneratorExpression\n    //     RegularExpressionLiteral\n    //     TemplateLiteral\n    //     CoverParenthesizedExpressionAndArrowParameterList\n    OperatorPrecedence[OperatorPrecedence[\"Primary\"] = 20] = \"Primary\";\n    OperatorPrecedence[OperatorPrecedence[\"Highest\"] = 20] = \"Highest\";\n    OperatorPrecedence[OperatorPrecedence[\"Lowest\"] = 0] = \"Lowest\";\n    // -1 is lower than all other precedences. Returning it will cause binary expression\n    // parsing to stop.\n    OperatorPrecedence[OperatorPrecedence[\"Invalid\"] = -1] = \"Invalid\";\n})(OperatorPrecedence || (exports.OperatorPrecedence = OperatorPrecedence = {}));\nfunction getOperatorPrecedenceForNode(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.SpreadElement:\n        case utils_1.AST_NODE_TYPES.RestElement:\n            return OperatorPrecedence.Spread;\n        case utils_1.AST_NODE_TYPES.YieldExpression:\n        case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n            return OperatorPrecedence.Yield;\n        case utils_1.AST_NODE_TYPES.ConditionalExpression:\n            return OperatorPrecedence.Conditional;\n        case utils_1.AST_NODE_TYPES.SequenceExpression:\n            return OperatorPrecedence.Comma;\n        case utils_1.AST_NODE_TYPES.AssignmentExpression:\n        case utils_1.AST_NODE_TYPES.BinaryExpression:\n        case utils_1.AST_NODE_TYPES.LogicalExpression:\n            switch (node.operator) {\n                case '==':\n                case '+=':\n                case '-=':\n                case '**=':\n                case '*=':\n                case '/=':\n                case '%=':\n                case '<<=':\n                case '>>=':\n                case '>>>=':\n                case '&=':\n                case '^=':\n                case '|=':\n                case '||=':\n                case '&&=':\n                case '??=':\n                    return OperatorPrecedence.Assignment;\n                default:\n                    return getBinaryOperatorPrecedence(node.operator);\n            }\n        case utils_1.AST_NODE_TYPES.TSTypeAssertion:\n        case utils_1.AST_NODE_TYPES.TSNonNullExpression:\n        case utils_1.AST_NODE_TYPES.UnaryExpression:\n        case utils_1.AST_NODE_TYPES.AwaitExpression:\n            return OperatorPrecedence.Unary;\n        case utils_1.AST_NODE_TYPES.UpdateExpression:\n            // TODO: Should prefix `++` and `--` be moved to the `Update` precedence?\n            if (node.prefix) {\n                return OperatorPrecedence.Unary;\n            }\n            return OperatorPrecedence.Update;\n        case utils_1.AST_NODE_TYPES.ChainExpression:\n            return getOperatorPrecedenceForNode(node.expression);\n        case utils_1.AST_NODE_TYPES.CallExpression:\n            return OperatorPrecedence.LeftHandSide;\n        case utils_1.AST_NODE_TYPES.NewExpression:\n            return node.arguments.length > 0\n                ? OperatorPrecedence.Member\n                : OperatorPrecedence.LeftHandSide;\n        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n        case utils_1.AST_NODE_TYPES.MemberExpression:\n        case utils_1.AST_NODE_TYPES.MetaProperty:\n            return OperatorPrecedence.Member;\n        case utils_1.AST_NODE_TYPES.TSAsExpression:\n            return OperatorPrecedence.Relational;\n        case utils_1.AST_NODE_TYPES.ThisExpression:\n        case utils_1.AST_NODE_TYPES.Super:\n        case utils_1.AST_NODE_TYPES.Identifier:\n        case utils_1.AST_NODE_TYPES.PrivateIdentifier:\n        case utils_1.AST_NODE_TYPES.Literal:\n        case utils_1.AST_NODE_TYPES.ArrayExpression:\n        case utils_1.AST_NODE_TYPES.ObjectExpression:\n        case utils_1.AST_NODE_TYPES.FunctionExpression:\n        case utils_1.AST_NODE_TYPES.ClassExpression:\n        case utils_1.AST_NODE_TYPES.TemplateLiteral:\n        case utils_1.AST_NODE_TYPES.JSXElement:\n        case utils_1.AST_NODE_TYPES.JSXFragment:\n            // we don't have nodes for these cases\n            // case SyntaxKind.ParenthesizedExpression:\n            // case SyntaxKind.OmittedExpression:\n            return OperatorPrecedence.Primary;\n        default:\n            return OperatorPrecedence.Invalid;\n    }\n}\nfunction getOperatorPrecedence(nodeKind, operatorKind, hasArguments) {\n    switch (nodeKind) {\n        // A list of comma-separated expressions. This node is only created by transformations.\n        case typescript_1.SyntaxKind.CommaListExpression:\n            return OperatorPrecedence.Comma;\n        case typescript_1.SyntaxKind.SpreadElement:\n            return OperatorPrecedence.Spread;\n        case typescript_1.SyntaxKind.YieldExpression:\n            return OperatorPrecedence.Yield;\n        case typescript_1.SyntaxKind.ConditionalExpression:\n            return OperatorPrecedence.Conditional;\n        case typescript_1.SyntaxKind.BinaryExpression:\n            switch (operatorKind) {\n                case typescript_1.SyntaxKind.AmpersandAmpersandEqualsToken:\n                case typescript_1.SyntaxKind.AmpersandEqualsToken:\n                case typescript_1.SyntaxKind.AsteriskAsteriskEqualsToken:\n                case typescript_1.SyntaxKind.AsteriskEqualsToken:\n                case typescript_1.SyntaxKind.BarBarEqualsToken:\n                case typescript_1.SyntaxKind.BarEqualsToken:\n                case typescript_1.SyntaxKind.CaretEqualsToken:\n                case typescript_1.SyntaxKind.EqualsToken:\n                case typescript_1.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case typescript_1.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n                case typescript_1.SyntaxKind.LessThanLessThanEqualsToken:\n                case typescript_1.SyntaxKind.MinusEqualsToken:\n                case typescript_1.SyntaxKind.PercentEqualsToken:\n                case typescript_1.SyntaxKind.PlusEqualsToken:\n                case typescript_1.SyntaxKind.QuestionQuestionEqualsToken:\n                case typescript_1.SyntaxKind.SlashEqualsToken:\n                    return OperatorPrecedence.Assignment;\n                case typescript_1.SyntaxKind.CommaToken:\n                    return OperatorPrecedence.Comma;\n                default:\n                    return getBinaryOperatorPrecedence(operatorKind);\n            }\n        // TODO: Should prefix `++` and `--` be moved to the `Update` precedence?\n        case typescript_1.SyntaxKind.TypeAssertionExpression:\n        case typescript_1.SyntaxKind.NonNullExpression:\n        case typescript_1.SyntaxKind.PrefixUnaryExpression:\n        case typescript_1.SyntaxKind.TypeOfExpression:\n        case typescript_1.SyntaxKind.VoidExpression:\n        case typescript_1.SyntaxKind.DeleteExpression:\n        case typescript_1.SyntaxKind.AwaitExpression:\n            return OperatorPrecedence.Unary;\n        case typescript_1.SyntaxKind.PostfixUnaryExpression:\n            return OperatorPrecedence.Update;\n        case typescript_1.SyntaxKind.CallExpression:\n            return OperatorPrecedence.LeftHandSide;\n        case typescript_1.SyntaxKind.NewExpression:\n            return hasArguments\n                ? OperatorPrecedence.Member\n                : OperatorPrecedence.LeftHandSide;\n        case typescript_1.SyntaxKind.TaggedTemplateExpression:\n        case typescript_1.SyntaxKind.PropertyAccessExpression:\n        case typescript_1.SyntaxKind.ElementAccessExpression:\n        case typescript_1.SyntaxKind.MetaProperty:\n            return OperatorPrecedence.Member;\n        case typescript_1.SyntaxKind.AsExpression:\n        case typescript_1.SyntaxKind.SatisfiesExpression:\n            return OperatorPrecedence.Relational;\n        case typescript_1.SyntaxKind.ThisKeyword:\n        case typescript_1.SyntaxKind.SuperKeyword:\n        case typescript_1.SyntaxKind.Identifier:\n        case typescript_1.SyntaxKind.PrivateIdentifier:\n        case typescript_1.SyntaxKind.NullKeyword:\n        case typescript_1.SyntaxKind.TrueKeyword:\n        case typescript_1.SyntaxKind.FalseKeyword:\n        case typescript_1.SyntaxKind.NumericLiteral:\n        case typescript_1.SyntaxKind.BigIntLiteral:\n        case typescript_1.SyntaxKind.StringLiteral:\n        case typescript_1.SyntaxKind.ArrayLiteralExpression:\n        case typescript_1.SyntaxKind.ObjectLiteralExpression:\n        case typescript_1.SyntaxKind.FunctionExpression:\n        case typescript_1.SyntaxKind.ArrowFunction:\n        case typescript_1.SyntaxKind.ClassExpression:\n        case typescript_1.SyntaxKind.RegularExpressionLiteral:\n        case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\n        case typescript_1.SyntaxKind.TemplateExpression:\n        case typescript_1.SyntaxKind.ParenthesizedExpression:\n        case typescript_1.SyntaxKind.OmittedExpression:\n        case typescript_1.SyntaxKind.JsxElement:\n        case typescript_1.SyntaxKind.JsxSelfClosingElement:\n        case typescript_1.SyntaxKind.JsxFragment:\n            return OperatorPrecedence.Primary;\n        default:\n            return OperatorPrecedence.Invalid;\n    }\n}\nfunction getBinaryOperatorPrecedence(kind) {\n    switch (kind) {\n        case '-':\n        case '+':\n        case typescript_1.SyntaxKind.MinusToken:\n        case typescript_1.SyntaxKind.PlusToken:\n            return OperatorPrecedence.Additive;\n        case '!=':\n        case '!==':\n        case '==':\n        case '===':\n        case typescript_1.SyntaxKind.EqualsEqualsEqualsToken:\n        case typescript_1.SyntaxKind.EqualsEqualsToken:\n        case typescript_1.SyntaxKind.ExclamationEqualsEqualsToken:\n        case typescript_1.SyntaxKind.ExclamationEqualsToken:\n            return OperatorPrecedence.Equality;\n        case '??':\n        case typescript_1.SyntaxKind.QuestionQuestionToken:\n            return OperatorPrecedence.Coalesce;\n        case '*':\n        case '/':\n        case '%':\n        case typescript_1.SyntaxKind.AsteriskToken:\n        case typescript_1.SyntaxKind.PercentToken:\n        case typescript_1.SyntaxKind.SlashToken:\n            return OperatorPrecedence.Multiplicative;\n        case '**':\n        case typescript_1.SyntaxKind.AsteriskAsteriskToken:\n            return OperatorPrecedence.Exponentiation;\n        case '&':\n        case typescript_1.SyntaxKind.AmpersandToken:\n            return OperatorPrecedence.BitwiseAND;\n        case '&&':\n        case typescript_1.SyntaxKind.AmpersandAmpersandToken:\n            return OperatorPrecedence.LogicalAND;\n        case '^':\n        case typescript_1.SyntaxKind.CaretToken:\n            return OperatorPrecedence.BitwiseXOR;\n        case '<':\n        case '<=':\n        case '>':\n        case '>=':\n        case 'in':\n        case 'instanceof':\n        case typescript_1.SyntaxKind.AsKeyword:\n        case typescript_1.SyntaxKind.GreaterThanEqualsToken:\n        case typescript_1.SyntaxKind.GreaterThanToken:\n        case typescript_1.SyntaxKind.InKeyword:\n        case typescript_1.SyntaxKind.InstanceOfKeyword:\n        case typescript_1.SyntaxKind.LessThanEqualsToken:\n        case typescript_1.SyntaxKind.LessThanToken:\n            // case 'as': -- we don't have a token for this\n            return OperatorPrecedence.Relational;\n        case '<<':\n        case '>>':\n        case '>>>':\n        case typescript_1.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n        case typescript_1.SyntaxKind.GreaterThanGreaterThanToken:\n        case typescript_1.SyntaxKind.LessThanLessThanToken:\n            return OperatorPrecedence.Shift;\n        case '|':\n        case typescript_1.SyntaxKind.BarToken:\n            return OperatorPrecedence.BitwiseOR;\n        case '||':\n        case typescript_1.SyntaxKind.BarBarToken:\n            return OperatorPrecedence.LogicalOR;\n    }\n    // -1 is lower than all other precedences.  Returning it will cause binary expression\n    // parsing to stop.\n    return -1;\n}\n"
        }
    ]
}