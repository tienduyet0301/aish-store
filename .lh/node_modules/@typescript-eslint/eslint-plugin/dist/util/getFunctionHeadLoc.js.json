{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/util/getFunctionHeadLoc.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891976855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n// adapted from https://github.com/eslint/eslint/blob/5bdaae205c3a0089ea338b382df59e21d5b06436/lib/rules/utils/ast-utils.js#L1668-L1787\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFunctionHeadLoc = getFunctionHeadLoc;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst astUtils_1 = require(\"./astUtils\");\n/**\n * Gets the `(` token of the given function node.\n * @param node The function node to get.\n * @param sourceCode The source code object to get tokens.\n * @returns `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    // If the node is an arrow function and doesn't have parens, this returns the identifier of the first param.\n    if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n        node.params.length === 1) {\n        const argToken = utils_1.ESLintUtils.nullThrows(sourceCode.getFirstToken(node.params[0]), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('parameter', 'arrow function'));\n        const maybeParenToken = sourceCode.getTokenBefore(argToken);\n        return maybeParenToken && (0, astUtils_1.isOpeningParenToken)(maybeParenToken)\n            ? maybeParenToken\n            : argToken;\n    }\n    // Otherwise, returns paren.\n    return node.id != null\n        ? utils_1.ESLintUtils.nullThrows(sourceCode.getTokenAfter(node.id, astUtils_1.isOpeningParenToken), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('id', 'function'))\n        : utils_1.ESLintUtils.nullThrows(sourceCode.getFirstToken(node, astUtils_1.isOpeningParenToken), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('opening parenthesis', 'function'));\n}\n/**\n * Gets the location of the given function node for reporting.\n *\n * - `function foo() {}`\n *    ^^^^^^^^^^^^\n * - `(function foo() {})`\n *     ^^^^^^^^^^^^\n * - `(function() {})`\n *     ^^^^^^^^\n * - `function* foo() {}`\n *    ^^^^^^^^^^^^^\n * - `(function* foo() {})`\n *     ^^^^^^^^^^^^^\n * - `(function*() {})`\n *     ^^^^^^^^^\n * - `() => {}`\n *       ^^\n * - `async () => {}`\n *             ^^\n * - `({ foo: function foo() {} })`\n *       ^^^^^^^^^^^^^^^^^\n * - `({ foo: function() {} })`\n *       ^^^^^^^^^^^^^\n * - `({ ['foo']: function() {} })`\n *       ^^^^^^^^^^^^^^^^^\n * - `({ [foo]: function() {} })`\n *       ^^^^^^^^^^^^^^^\n * - `({ foo() {} })`\n *       ^^^\n * - `({ foo: function* foo() {} })`\n *       ^^^^^^^^^^^^^^^^^^\n * - `({ foo: function*() {} })`\n *       ^^^^^^^^^^^^^^\n * - `({ ['foo']: function*() {} })`\n *       ^^^^^^^^^^^^^^^^^^\n * - `({ [foo]: function*() {} })`\n *       ^^^^^^^^^^^^^^^^\n * - `({ *foo() {} })`\n *       ^^^^\n * - `({ foo: async function foo() {} })`\n *       ^^^^^^^^^^^^^^^^^^^^^^^\n * - `({ foo: async function() {} })`\n *       ^^^^^^^^^^^^^^^^^^^\n * - `({ ['foo']: async function() {} })`\n *       ^^^^^^^^^^^^^^^^^^^^^^^\n * - `({ [foo]: async function() {} })`\n *       ^^^^^^^^^^^^^^^^^^^^^\n * - `({ async foo() {} })`\n *       ^^^^^^^^^\n * - `({ get foo() {} })`\n *       ^^^^^^^\n * - `({ set foo(a) {} })`\n *       ^^^^^^^\n * - `class A { constructor() {} }`\n *              ^^^^^^^^^^^\n * - `class A { foo() {} }`\n *              ^^^\n * - `class A { *foo() {} }`\n *              ^^^^\n * - `class A { async foo() {} }`\n *              ^^^^^^^^^\n * - `class A { ['foo']() {} }`\n *              ^^^^^^^\n * - `class A { *['foo']() {} }`\n *              ^^^^^^^^\n * - `class A { async ['foo']() {} }`\n *              ^^^^^^^^^^^^^\n * - `class A { [foo]() {} }`\n *              ^^^^^\n * - `class A { *[foo]() {} }`\n *              ^^^^^^\n * - `class A { async [foo]() {} }`\n *              ^^^^^^^^^^^\n * - `class A { get foo() {} }`\n *              ^^^^^^^\n * - `class A { set foo(a) {} }`\n *              ^^^^^^^\n * - `class A { static foo() {} }`\n *              ^^^^^^^^^^\n * - `class A { static *foo() {} }`\n *              ^^^^^^^^^^^\n * - `class A { static async foo() {} }`\n *              ^^^^^^^^^^^^^^^^\n * - `class A { static get foo() {} }`\n *              ^^^^^^^^^^^^^^\n * - `class A { static set foo(a) {} }`\n *              ^^^^^^^^^^^^^^\n * - `class A { foo = function() {} }`\n *              ^^^^^^^^^^^^^^\n * - `class A { static foo = function() {} }`\n *              ^^^^^^^^^^^^^^^^^^^^^\n * - `class A { foo = (a, b) => {} }`\n *              ^^^^^^\n * @param node The function node to get.\n * @param sourceCode The source code object to get tokens.\n * @returns The location of the function node for reporting.\n */\nfunction getFunctionHeadLoc(node, sourceCode) {\n    const parent = node.parent;\n    let start = null;\n    let end = null;\n    if (parent.type === utils_1.AST_NODE_TYPES.MethodDefinition ||\n        parent.type === utils_1.AST_NODE_TYPES.PropertyDefinition) {\n        // the decorator's range is included within the member\n        // however it's usually irrelevant to the member itself - so we don't want\n        // to highlight it ever.\n        if (parent.decorators.length > 0) {\n            const lastDecorator = parent.decorators[parent.decorators.length - 1];\n            const firstTokenAfterDecorator = utils_1.ESLintUtils.nullThrows(sourceCode.getTokenAfter(lastDecorator), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('modifier or member name', 'class member'));\n            start = firstTokenAfterDecorator.loc.start;\n        }\n        else {\n            start = parent.loc.start;\n        }\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n    else if (parent.type === utils_1.AST_NODE_TYPES.Property) {\n        start = parent.loc.start;\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n    else if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n        const arrowToken = utils_1.ESLintUtils.nullThrows(sourceCode.getTokenBefore(node.body, astUtils_1.isArrowToken), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('arrow token', 'arrow function'));\n        start = arrowToken.loc.start;\n        end = arrowToken.loc.end;\n    }\n    else {\n        start = node.loc.start;\n        end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n    return {\n        end: { ...end },\n        start: { ...start },\n    };\n}\n"
        }
    ]
}