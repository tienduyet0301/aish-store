{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unnecessary-type-parameters.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891969597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-unnecessary-type-parameters',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: \"Disallow type parameters that aren't used multiple times\",\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            replaceUsagesWithConstraint: 'Replace all usages of type parameter with its constraint.',\n            sole: 'Type parameter {{name}} is {{uses}} in the {{descriptor}} signature.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const parserServices = (0, util_1.getParserServices)(context);\n        function checkNode(node, descriptor) {\n            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n            const checker = parserServices.program.getTypeChecker();\n            let counts;\n            // Get the scope in which the type parameters are declared.\n            const scope = context.sourceCode.getScope(node);\n            for (const typeParameter of tsNode.typeParameters) {\n                const esTypeParameter = parserServices.tsNodeToESTreeNodeMap.get(typeParameter);\n                const smTypeParameterVariable = (0, util_1.nullThrows)((() => {\n                    const variable = scope.set.get(esTypeParameter.name.name);\n                    return variable?.isTypeVariable ? variable : undefined;\n                })(), \"Type parameter should be present in scope's variables.\");\n                // Quick path: if the type parameter is used multiple times in the AST,\n                // we don't need to dip into types to know it's repeated.\n                if (isTypeParameterRepeatedInAST(esTypeParameter, smTypeParameterVariable.references, node.body?.range[0] ?? node.returnType?.range[1])) {\n                    continue;\n                }\n                // For any inferred types, we have to dip into type checking.\n                counts ??= countTypeParameterUsage(checker, tsNode);\n                const identifierCounts = counts.get(typeParameter.name);\n                if (!identifierCounts || identifierCounts > 2) {\n                    continue;\n                }\n                context.report({\n                    node: esTypeParameter,\n                    messageId: 'sole',\n                    data: {\n                        name: typeParameter.name.text,\n                        descriptor,\n                        uses: identifierCounts === 1 ? 'never used' : 'used only once',\n                    },\n                    suggest: [\n                        {\n                            messageId: 'replaceUsagesWithConstraint',\n                            *fix(fixer) {\n                                // Replace all the usages of the type parameter with the constraint...\n                                const constraint = esTypeParameter.constraint;\n                                // special case - a constraint of 'any' actually acts like 'unknown'\n                                const constraintText = constraint != null &&\n                                    constraint.type !== utils_1.AST_NODE_TYPES.TSAnyKeyword\n                                    ? context.sourceCode.getText(constraint)\n                                    : 'unknown';\n                                for (const reference of smTypeParameterVariable.references) {\n                                    if (reference.isTypeReference) {\n                                        const referenceNode = reference.identifier;\n                                        yield fixer.replaceText(referenceNode, constraintText);\n                                    }\n                                }\n                                // ...and remove the type parameter itself from the declaration.\n                                const typeParamsNode = (0, util_1.nullThrows)(node.typeParameters, 'node should have type parameters');\n                                // We are assuming at this point that the reported type parameter\n                                // is present in the inspected node's type parameters.\n                                if (typeParamsNode.params.length === 1) {\n                                    // Remove the whole <T> generic syntax if we're removing the only type parameter in the list.\n                                    yield fixer.remove(typeParamsNode);\n                                }\n                                else {\n                                    const index = typeParamsNode.params.indexOf(esTypeParameter);\n                                    if (index === 0) {\n                                        const commaAfter = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(esTypeParameter, token => token.value === ','), util_1.NullThrowsReasons.MissingToken('comma', 'type parameter list'));\n                                        const tokenAfterComma = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(commaAfter, {\n                                            includeComments: true,\n                                        }), util_1.NullThrowsReasons.MissingToken('token', 'type parameter list'));\n                                        yield fixer.removeRange([\n                                            esTypeParameter.range[0],\n                                            tokenAfterComma.range[0],\n                                        ]);\n                                    }\n                                    else {\n                                        const commaBefore = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(esTypeParameter, token => token.value === ','), util_1.NullThrowsReasons.MissingToken('comma', 'type parameter list'));\n                                        yield fixer.removeRange([\n                                            commaBefore.range[0],\n                                            esTypeParameter.range[1],\n                                        ]);\n                                    }\n                                }\n                            },\n                        },\n                    ],\n                });\n            }\n        }\n        return {\n            [[\n                'ArrowFunctionExpression[typeParameters]',\n                'FunctionDeclaration[typeParameters]',\n                'FunctionExpression[typeParameters]',\n                'TSCallSignatureDeclaration[typeParameters]',\n                'TSConstructorType[typeParameters]',\n                'TSDeclareFunction[typeParameters]',\n                'TSEmptyBodyFunctionExpression[typeParameters]',\n                'TSFunctionType[typeParameters]',\n                'TSMethodSignature[typeParameters]',\n            ].join(', ')](node) {\n                checkNode(node, 'function');\n            },\n            [[\n                'ClassDeclaration[typeParameters]',\n                'ClassExpression[typeParameters]',\n            ].join(', ')](node) {\n                checkNode(node, 'class');\n            },\n        };\n    },\n});\nfunction isTypeParameterRepeatedInAST(node, references, startOfBody = Infinity) {\n    let total = 0;\n    for (const reference of references) {\n        // References inside the type parameter's definition don't count...\n        if (reference.identifier.range[0] < node.range[1] &&\n            reference.identifier.range[1] > node.range[0]) {\n            continue;\n        }\n        // ...nor references that are outside the declaring signature.\n        if (reference.identifier.range[0] > startOfBody) {\n            continue;\n        }\n        // Neither do references that aren't to the same type parameter,\n        // namely value-land (non-type) identifiers of the type parameter's type,\n        // and references to different type parameters or values.\n        if (!reference.isTypeReference ||\n            reference.identifier.name !== node.name.name) {\n            continue;\n        }\n        // If the type parameter is being used as a type argument, then we\n        // know the type parameter is being reused and can't be reported.\n        if (reference.identifier.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n            const grandparent = skipConstituentsUpward(reference.identifier.parent.parent);\n            if (grandparent.type === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation &&\n                grandparent.params.includes(reference.identifier.parent) &&\n                // Array and ReadonlyArray must be handled carefully\n                // let's defer the check to the type-aware phase\n                !(grandparent.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference &&\n                    grandparent.parent.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&\n                    ['Array', 'ReadonlyArray'].includes(grandparent.parent.typeName.name))) {\n                return true;\n            }\n        }\n        total += 1;\n        if (total >= 2) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction skipConstituentsUpward(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSIntersectionType:\n        case utils_1.AST_NODE_TYPES.TSUnionType:\n            return skipConstituentsUpward(node.parent);\n        default:\n            return node;\n    }\n}\n/**\n * Count uses of type parameters in inferred return types.\n * We need to resolve and analyze the inferred return type of a function\n * to see whether it contains additional references to the type parameters.\n * For classes, we need to do this for all their methods.\n */\nfunction countTypeParameterUsage(checker, node) {\n    const counts = new Map();\n    if (ts.isClassLike(node)) {\n        for (const typeParameter of node.typeParameters) {\n            collectTypeParameterUsageCounts(checker, typeParameter, counts, true);\n        }\n        for (const member of node.members) {\n            collectTypeParameterUsageCounts(checker, member, counts, true);\n        }\n    }\n    else {\n        collectTypeParameterUsageCounts(checker, node, counts, false);\n    }\n    return counts;\n}\n/**\n * Populates {@link foundIdentifierUsages} by the number of times each type parameter\n * appears in the given type by checking its uses through its type references.\n * This is essentially a limited subset of the scope manager, but for types.\n */\nfunction collectTypeParameterUsageCounts(checker, node, foundIdentifierUsages, fromClass) {\n    const visitedSymbolLists = new Set();\n    const type = checker.getTypeAtLocation(node);\n    const typeUsages = new Map();\n    const visitedConstraints = new Set();\n    let functionLikeType = false;\n    let visitedDefault = false;\n    if (ts.isCallSignatureDeclaration(node) ||\n        ts.isConstructorDeclaration(node)) {\n        functionLikeType = true;\n        visitSignature(checker.getSignatureFromDeclaration(node));\n    }\n    if (!functionLikeType) {\n        visitType(type, false);\n    }\n    function visitType(type, assumeMultipleUses, isReturnType = false) {\n        // Seeing the same type > (threshold=3 ** 2) times indicates a likely\n        // recursive type, like `type T = { [P in keyof T]: T }`.\n        // If it's not recursive, then heck, we've seen it enough times that any\n        // referenced types have been counted enough to qualify as used.\n        if (!type || incrementTypeUsages(type) > 9) {\n            return;\n        }\n        if (tsutils.isTypeParameter(type)) {\n            const declaration = type.getSymbol()?.getDeclarations()?.[0];\n            if (declaration) {\n                incrementIdentifierCount(declaration.name, assumeMultipleUses);\n                // Visiting the type of a constrained type parameter will recurse into\n                // the constraint. We avoid infinite loops by visiting each only once.\n                if (declaration.constraint &&\n                    !visitedConstraints.has(declaration.constraint)) {\n                    visitedConstraints.add(declaration.constraint);\n                    visitType(checker.getTypeAtLocation(declaration.constraint), false);\n                }\n                if (declaration.default && !visitedDefault) {\n                    visitedDefault = true;\n                    visitType(checker.getTypeAtLocation(declaration.default), false);\n                }\n            }\n        }\n        // Catch-all: generic type references like `Exclude<T, null>`\n        else if (type.aliasTypeArguments) {\n            // We don't descend into the definition of the type alias, so we don't\n            // know whether it's used multiple times. It's safest to assume it is.\n            visitTypesList(type.aliasTypeArguments, true);\n        }\n        // Intersections and unions like `0 | 1`\n        else if (tsutils.isUnionOrIntersectionType(type)) {\n            visitTypesList(type.types, assumeMultipleUses);\n        }\n        // Index access types like `T[K]`\n        else if (tsutils.isIndexedAccessType(type)) {\n            visitType(type.objectType, assumeMultipleUses);\n            visitType(type.indexType, assumeMultipleUses);\n        }\n        // Tuple types like `[K, V]`\n        // Generic type references like `Map<K, V>`\n        else if (tsutils.isTypeReference(type)) {\n            for (const typeArgument of type.typeArguments ?? []) {\n                // currently, if we are in a \"class context\", everything is accepted\n                let thisAssumeMultipleUses = fromClass || assumeMultipleUses;\n                // special cases - readonly arrays/tuples are considered only to use the\n                // type parameter once. Mutable arrays/tuples are considered to use the\n                // type parameter multiple times if and only if they are returned.\n                // other kind of type references always count as multiple uses\n                thisAssumeMultipleUses ||= tsutils.isTupleType(type.target)\n                    ? isReturnType && !type.target.readonly\n                    : checker.isArrayType(type.target)\n                        ? isReturnType &&\n                            type.symbol?.getName() === 'Array'\n                        : true;\n                visitType(typeArgument, thisAssumeMultipleUses, isReturnType);\n            }\n        }\n        // Template literals like `a${T}b`\n        else if (tsutils.isTemplateLiteralType(type)) {\n            for (const subType of type.types) {\n                visitType(subType, assumeMultipleUses);\n            }\n        }\n        // Conditional types like `T extends string ? T : never`\n        else if (tsutils.isConditionalType(type)) {\n            visitType(type.checkType, assumeMultipleUses);\n            visitType(type.extendsType, assumeMultipleUses);\n        }\n        // Catch-all: inferred object types like `{ K: V }`.\n        // These catch-alls should be _after_ more specific checks like\n        // `isTypeReference` to avoid descending into all the properties of a\n        // generic interface/class, e.g. `Map<K, V>`.\n        else if (tsutils.isObjectType(type)) {\n            const properties = type.getProperties();\n            visitSymbolsListOnce(properties, false);\n            if (isMappedType(type)) {\n                visitType(type.typeParameter, false);\n                if (properties.length === 0) {\n                    // TS treats mapped types like `{[k in \"a\"]: T}` like `{a: T}`.\n                    // They have properties, so we need to avoid double-counting.\n                    visitType(type.templateType ?? type.constraintType, false);\n                }\n            }\n            visitType(type.getNumberIndexType(), true);\n            visitType(type.getStringIndexType(), true);\n            type.getCallSignatures().forEach(signature => {\n                functionLikeType = true;\n                visitSignature(signature);\n            });\n            type.getConstructSignatures().forEach(signature => {\n                functionLikeType = true;\n                visitSignature(signature);\n            });\n        }\n        // Catch-all: operator types like `keyof T`\n        else if (isOperatorType(type)) {\n            visitType(type.type, assumeMultipleUses);\n        }\n    }\n    function incrementIdentifierCount(id, assumeMultipleUses) {\n        const identifierCount = foundIdentifierUsages.get(id) ?? 0;\n        const value = assumeMultipleUses ? 2 : 1;\n        foundIdentifierUsages.set(id, identifierCount + value);\n    }\n    function incrementTypeUsages(type) {\n        const count = (typeUsages.get(type) ?? 0) + 1;\n        typeUsages.set(type, count);\n        return count;\n    }\n    function visitSignature(signature) {\n        if (!signature) {\n            return;\n        }\n        if (signature.thisParameter) {\n            visitType(checker.getTypeOfSymbol(signature.thisParameter), false);\n        }\n        for (const parameter of signature.parameters) {\n            visitType(checker.getTypeOfSymbol(parameter), false);\n        }\n        for (const typeParameter of signature.getTypeParameters() ?? []) {\n            visitType(typeParameter, false);\n        }\n        visitType(checker.getTypePredicateOfSignature(signature)?.type ??\n            signature.getReturnType(), false, true);\n    }\n    function visitSymbolsListOnce(symbols, assumeMultipleUses) {\n        if (visitedSymbolLists.has(symbols)) {\n            return;\n        }\n        visitedSymbolLists.add(symbols);\n        for (const symbol of symbols) {\n            visitType(checker.getTypeOfSymbol(symbol), assumeMultipleUses);\n        }\n    }\n    function visitTypesList(types, assumeMultipleUses) {\n        for (const type of types) {\n            visitType(type, assumeMultipleUses);\n        }\n    }\n}\nfunction isMappedType(type) {\n    return 'typeParameter' in type;\n}\nfunction isOperatorType(type) {\n    return 'type' in type && !!type.type;\n}\n"
        }
    ]
}