{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/naming-convention-utils/format.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891962195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PredefinedFormatToCheckFunction = void 0;\nconst enums_1 = require(\"./enums\");\n/*\nThese format functions are taken from `tslint-consistent-codestyle/naming-convention`:\nhttps://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/rules/namingConventionRule.ts#L603-L645\n\nThe license for the code can be viewed here:\nhttps://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/LICENSE\n*/\n/*\nWhy not regex here? Because it's actually really, really difficult to create a regex to handle\nall of the unicode cases, and we have many non-english users that use non-english characters.\nhttps://gist.github.com/mathiasbynens/6334847\n*/\nfunction isPascalCase(name) {\n    return (name.length === 0 ||\n        (name[0] === name[0].toUpperCase() && !name.includes('_')));\n}\nfunction isStrictPascalCase(name) {\n    return (name.length === 0 ||\n        (name[0] === name[0].toUpperCase() && hasStrictCamelHumps(name, true)));\n}\nfunction isCamelCase(name) {\n    return (name.length === 0 ||\n        (name[0] === name[0].toLowerCase() && !name.includes('_')));\n}\nfunction isStrictCamelCase(name) {\n    return (name.length === 0 ||\n        (name[0] === name[0].toLowerCase() && hasStrictCamelHumps(name, false)));\n}\nfunction hasStrictCamelHumps(name, isUpper) {\n    function isUppercaseChar(char) {\n        return char === char.toUpperCase() && char !== char.toLowerCase();\n    }\n    if (name.startsWith('_')) {\n        return false;\n    }\n    for (let i = 1; i < name.length; ++i) {\n        if (name[i] === '_') {\n            return false;\n        }\n        if (isUpper === isUppercaseChar(name[i])) {\n            if (isUpper) {\n                return false;\n            }\n        }\n        else {\n            isUpper = !isUpper;\n        }\n    }\n    return true;\n}\nfunction isSnakeCase(name) {\n    return (name.length === 0 ||\n        (name === name.toLowerCase() && validateUnderscores(name)));\n}\nfunction isUpperCase(name) {\n    return (name.length === 0 ||\n        (name === name.toUpperCase() && validateUnderscores(name)));\n}\n/** Check for leading trailing and adjacent underscores */\nfunction validateUnderscores(name) {\n    if (name.startsWith('_')) {\n        return false;\n    }\n    let wasUnderscore = false;\n    for (let i = 1; i < name.length; ++i) {\n        if (name[i] === '_') {\n            if (wasUnderscore) {\n                return false;\n            }\n            wasUnderscore = true;\n        }\n        else {\n            wasUnderscore = false;\n        }\n    }\n    return !wasUnderscore;\n}\nexports.PredefinedFormatToCheckFunction = {\n    [enums_1.PredefinedFormats.camelCase]: isCamelCase,\n    [enums_1.PredefinedFormats.PascalCase]: isPascalCase,\n    [enums_1.PredefinedFormats.snake_case]: isSnakeCase,\n    [enums_1.PredefinedFormats.strictCamelCase]: isStrictCamelCase,\n    [enums_1.PredefinedFormats.StrictPascalCase]: isStrictPascalCase,\n    [enums_1.PredefinedFormats.UPPER_CASE]: isUpperCase,\n};\n"
        }
    ]
}