{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/naming-convention-utils/validator.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891962758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createValidator = createValidator;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../../util\");\nconst enums_1 = require(\"./enums\");\nconst format_1 = require(\"./format\");\nconst shared_1 = require(\"./shared\");\nfunction createValidator(type, context, allConfigs) {\n    // make sure the \"highest priority\" configs are checked first\n    const selectorType = enums_1.Selectors[type];\n    const configs = allConfigs\n        // gather all of the applicable selectors\n        .filter(c => (c.selector & selectorType) !== 0 ||\n        c.selector === enums_1.MetaSelectors.default)\n        .sort((a, b) => {\n        if (a.selector === b.selector) {\n            // in the event of the same selector, order by modifier weight\n            // sort descending - the type modifiers are \"more important\"\n            return b.modifierWeight - a.modifierWeight;\n        }\n        const aIsMeta = (0, shared_1.isMetaSelector)(a.selector);\n        const bIsMeta = (0, shared_1.isMetaSelector)(b.selector);\n        // non-meta selectors should go ahead of meta selectors\n        if (aIsMeta && !bIsMeta) {\n            return 1;\n        }\n        if (!aIsMeta && bIsMeta) {\n            return -1;\n        }\n        const aIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(a.selector);\n        const bIsMethodOrProperty = (0, shared_1.isMethodOrPropertySelector)(b.selector);\n        // for backward compatibility, method and property have higher precedence than other meta selectors\n        if (aIsMethodOrProperty && !bIsMethodOrProperty) {\n            return -1;\n        }\n        if (!aIsMethodOrProperty && bIsMethodOrProperty) {\n            return 1;\n        }\n        // both aren't meta selectors\n        // sort descending - the meta selectors are \"least important\"\n        return b.selector - a.selector;\n    });\n    return (node, modifiers = new Set()) => {\n        const originalName = node.type === utils_1.AST_NODE_TYPES.Identifier ||\n            node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier\n            ? node.name\n            : `${node.value}`;\n        // return will break the loop and stop checking configs\n        // it is only used when the name is known to have failed or succeeded a config.\n        for (const config of configs) {\n            if (config.filter?.regex.test(originalName) !== config.filter?.match) {\n                // name does not match the filter\n                continue;\n            }\n            if (config.modifiers?.some(modifier => !modifiers.has(modifier))) {\n                // does not have the required modifiers\n                continue;\n            }\n            if (!isCorrectType(node, config, context, selectorType)) {\n                // is not the correct type\n                continue;\n            }\n            let name = originalName;\n            name = validateUnderscore('leading', config, name, node, originalName);\n            if (name == null) {\n                // fail\n                return;\n            }\n            name = validateUnderscore('trailing', config, name, node, originalName);\n            if (name == null) {\n                // fail\n                return;\n            }\n            name = validateAffix('prefix', config, name, node, originalName);\n            if (name == null) {\n                // fail\n                return;\n            }\n            name = validateAffix('suffix', config, name, node, originalName);\n            if (name == null) {\n                // fail\n                return;\n            }\n            if (!validateCustom(config, name, node, originalName)) {\n                // fail\n                return;\n            }\n            if (!validatePredefinedFormat(config, name, node, originalName, modifiers)) {\n                // fail\n                return;\n            }\n            // it's valid for this config, so we don't need to check any more configs\n            return;\n        }\n    };\n    // centralizes the logic for formatting the report data\n    function formatReportData({ affixes, count, custom, formats, originalName, position, processedName, }) {\n        return {\n            affixes: affixes?.join(', '),\n            count,\n            formats: formats?.map(f => enums_1.PredefinedFormats[f]).join(', '),\n            name: originalName,\n            position,\n            processedName,\n            regex: custom?.regex.toString(),\n            regexMatch: custom?.match === true\n                ? 'match'\n                : custom?.match === false\n                    ? 'not match'\n                    : null,\n            type: (0, shared_1.selectorTypeToMessageString)(type),\n        };\n    }\n    /**\n     * @returns the name with the underscore removed, if it is valid according to the specified underscore option, null otherwise\n     */\n    function validateUnderscore(position, config, name, node, originalName) {\n        const option = position === 'leading'\n            ? config.leadingUnderscore\n            : config.trailingUnderscore;\n        if (!option) {\n            return name;\n        }\n        const hasSingleUnderscore = position === 'leading'\n            ? () => name.startsWith('_')\n            : () => name.endsWith('_');\n        const trimSingleUnderscore = position === 'leading'\n            ? () => name.slice(1)\n            : () => name.slice(0, -1);\n        const hasDoubleUnderscore = position === 'leading'\n            ? () => name.startsWith('__')\n            : () => name.endsWith('__');\n        const trimDoubleUnderscore = position === 'leading'\n            ? () => name.slice(2)\n            : () => name.slice(0, -2);\n        switch (option) {\n            // ALLOW - no conditions as the user doesn't care if it's there or not\n            case enums_1.UnderscoreOptions.allow: {\n                if (hasSingleUnderscore()) {\n                    return trimSingleUnderscore();\n                }\n                return name;\n            }\n            case enums_1.UnderscoreOptions.allowDouble: {\n                if (hasDoubleUnderscore()) {\n                    return trimDoubleUnderscore();\n                }\n                return name;\n            }\n            case enums_1.UnderscoreOptions.allowSingleOrDouble: {\n                if (hasDoubleUnderscore()) {\n                    return trimDoubleUnderscore();\n                }\n                if (hasSingleUnderscore()) {\n                    return trimSingleUnderscore();\n                }\n                return name;\n            }\n            // FORBID\n            case enums_1.UnderscoreOptions.forbid: {\n                if (hasSingleUnderscore()) {\n                    context.report({\n                        data: formatReportData({\n                            count: 'one',\n                            originalName,\n                            position,\n                        }),\n                        messageId: 'unexpectedUnderscore',\n                        node,\n                    });\n                    return null;\n                }\n                return name;\n            }\n            // REQUIRE\n            case enums_1.UnderscoreOptions.require: {\n                if (!hasSingleUnderscore()) {\n                    context.report({\n                        data: formatReportData({\n                            count: 'one',\n                            originalName,\n                            position,\n                        }),\n                        messageId: 'missingUnderscore',\n                        node,\n                    });\n                    return null;\n                }\n                return trimSingleUnderscore();\n            }\n            case enums_1.UnderscoreOptions.requireDouble: {\n                if (!hasDoubleUnderscore()) {\n                    context.report({\n                        data: formatReportData({\n                            count: 'two',\n                            originalName,\n                            position,\n                        }),\n                        messageId: 'missingUnderscore',\n                        node,\n                    });\n                    return null;\n                }\n                return trimDoubleUnderscore();\n            }\n        }\n    }\n    /**\n     * @returns the name with the affix removed, if it is valid according to the specified affix option, null otherwise\n     */\n    function validateAffix(position, config, name, node, originalName) {\n        const affixes = config[position];\n        if (!affixes || affixes.length === 0) {\n            return name;\n        }\n        for (const affix of affixes) {\n            const hasAffix = position === 'prefix' ? name.startsWith(affix) : name.endsWith(affix);\n            const trimAffix = position === 'prefix'\n                ? () => name.slice(affix.length)\n                : () => name.slice(0, -affix.length);\n            if (hasAffix) {\n                // matches, so trim it and return\n                return trimAffix();\n            }\n        }\n        context.report({\n            data: formatReportData({\n                affixes,\n                originalName,\n                position,\n            }),\n            messageId: 'missingAffix',\n            node,\n        });\n        return null;\n    }\n    /**\n     * @returns true if the name is valid according to the `regex` option, false otherwise\n     */\n    function validateCustom(config, name, node, originalName) {\n        const custom = config.custom;\n        if (!custom) {\n            return true;\n        }\n        const result = custom.regex.test(name);\n        if (custom.match && result) {\n            return true;\n        }\n        if (!custom.match && !result) {\n            return true;\n        }\n        context.report({\n            data: formatReportData({\n                custom,\n                originalName,\n            }),\n            messageId: 'satisfyCustom',\n            node,\n        });\n        return false;\n    }\n    /**\n     * @returns true if the name is valid according to the `format` option, false otherwise\n     */\n    function validatePredefinedFormat(config, name, node, originalName, modifiers) {\n        const formats = config.format;\n        if (!formats?.length) {\n            return true;\n        }\n        if (!modifiers.has(enums_1.Modifiers.requiresQuotes)) {\n            for (const format of formats) {\n                const checker = format_1.PredefinedFormatToCheckFunction[format];\n                if (checker(name)) {\n                    return true;\n                }\n            }\n        }\n        context.report({\n            data: formatReportData({\n                formats,\n                originalName,\n                processedName: name,\n            }),\n            messageId: originalName === name\n                ? 'doesNotMatchFormat'\n                : 'doesNotMatchFormatTrimmed',\n            node,\n        });\n        return false;\n    }\n}\nconst SelectorsAllowedToHaveTypes = enums_1.Selectors.variable |\n    enums_1.Selectors.parameter |\n    enums_1.Selectors.classProperty |\n    enums_1.Selectors.objectLiteralProperty |\n    enums_1.Selectors.typeProperty |\n    enums_1.Selectors.parameterProperty |\n    enums_1.Selectors.classicAccessor;\nfunction isCorrectType(node, config, context, selector) {\n    if (config.types == null) {\n        return true;\n    }\n    if ((SelectorsAllowedToHaveTypes & selector) === 0) {\n        return true;\n    }\n    const services = (0, util_1.getParserServices)(context);\n    const checker = services.program.getTypeChecker();\n    const type = services\n        .getTypeAtLocation(node)\n        // remove null and undefined from the type, as we don't care about it here\n        .getNonNullableType();\n    for (const allowedType of config.types) {\n        switch (allowedType) {\n            case enums_1.TypeModifiers.array:\n                if (isAllTypesMatch(type, t => checker.isArrayType(t) || checker.isTupleType(t))) {\n                    return true;\n                }\n                break;\n            case enums_1.TypeModifiers.function:\n                if (isAllTypesMatch(type, t => t.getCallSignatures().length > 0)) {\n                    return true;\n                }\n                break;\n            case enums_1.TypeModifiers.boolean:\n            case enums_1.TypeModifiers.number:\n            case enums_1.TypeModifiers.string: {\n                const typeString = checker.typeToString(\n                // this will resolve things like true => boolean, 'a' => string and 1 => number\n                checker.getWidenedType(checker.getBaseTypeOfLiteralType(type)));\n                const allowedTypeString = enums_1.TypeModifiers[allowedType];\n                if (typeString === allowedTypeString) {\n                    return true;\n                }\n                break;\n            }\n        }\n    }\n    return false;\n}\n/**\n * @returns `true` if the type (or all union types) in the given type return true for the callback\n */\nfunction isAllTypesMatch(type, cb) {\n    if (type.isUnion()) {\n        return type.types.every(t => cb(t));\n    }\n    return cb(type);\n}\n"
        }
    ]
}