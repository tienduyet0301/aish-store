{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/naming-convention-utils/parse-options.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891962402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseOptions = parseOptions;\nconst util_1 = require(\"../../util\");\nconst enums_1 = require(\"./enums\");\nconst shared_1 = require(\"./shared\");\nconst validator_1 = require(\"./validator\");\nfunction normalizeOption(option) {\n    let weight = 0;\n    option.modifiers?.forEach(mod => {\n        weight |= enums_1.Modifiers[mod];\n    });\n    option.types?.forEach(mod => {\n        weight |= enums_1.TypeModifiers[mod];\n    });\n    // give selectors with a filter the _highest_ priority\n    if (option.filter) {\n        weight |= 1 << 30;\n    }\n    const normalizedOption = {\n        // format options\n        custom: option.custom\n            ? {\n                match: option.custom.match,\n                regex: new RegExp(option.custom.regex, 'u'),\n            }\n            : null,\n        filter: option.filter != null\n            ? typeof option.filter === 'string'\n                ? {\n                    match: true,\n                    regex: new RegExp(option.filter, 'u'),\n                }\n                : {\n                    match: option.filter.match,\n                    regex: new RegExp(option.filter.regex, 'u'),\n                }\n            : null,\n        format: option.format ? option.format.map(f => enums_1.PredefinedFormats[f]) : null,\n        leadingUnderscore: option.leadingUnderscore != null\n            ? enums_1.UnderscoreOptions[option.leadingUnderscore]\n            : null,\n        modifiers: option.modifiers?.map(m => enums_1.Modifiers[m]) ?? null,\n        prefix: option.prefix && option.prefix.length > 0 ? option.prefix : null,\n        suffix: option.suffix && option.suffix.length > 0 ? option.suffix : null,\n        trailingUnderscore: option.trailingUnderscore != null\n            ? enums_1.UnderscoreOptions[option.trailingUnderscore]\n            : null,\n        types: option.types?.map(m => enums_1.TypeModifiers[m]) ?? null,\n        // calculated ordering weight based on modifiers\n        modifierWeight: weight,\n    };\n    const selectors = Array.isArray(option.selector)\n        ? option.selector\n        : [option.selector];\n    return selectors.map(selector => ({\n        selector: (0, shared_1.isMetaSelector)(selector)\n            ? enums_1.MetaSelectors[selector]\n            : enums_1.Selectors[selector],\n        ...normalizedOption,\n    }));\n}\nfunction parseOptions(context) {\n    const normalizedOptions = context.options.flatMap(normalizeOption);\n    return Object.fromEntries((0, util_1.getEnumNames)(enums_1.Selectors).map(k => [\n        k,\n        (0, validator_1.createValidator)(k, context, normalizedOptions),\n    ]));\n}\n"
        }
    ]
}