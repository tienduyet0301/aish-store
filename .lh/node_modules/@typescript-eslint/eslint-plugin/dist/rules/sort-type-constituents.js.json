{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/sort-type-constituents.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nvar Group;\n(function (Group) {\n    Group[\"conditional\"] = \"conditional\";\n    Group[\"function\"] = \"function\";\n    Group[\"import\"] = \"import\";\n    Group[\"intersection\"] = \"intersection\";\n    Group[\"keyword\"] = \"keyword\";\n    Group[\"nullish\"] = \"nullish\";\n    Group[\"literal\"] = \"literal\";\n    Group[\"named\"] = \"named\";\n    Group[\"object\"] = \"object\";\n    Group[\"operator\"] = \"operator\";\n    Group[\"tuple\"] = \"tuple\";\n    Group[\"union\"] = \"union\";\n})(Group || (Group = {}));\nfunction getGroup(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSConditionalType:\n            return Group.conditional;\n        case utils_1.AST_NODE_TYPES.TSConstructorType:\n        case utils_1.AST_NODE_TYPES.TSFunctionType:\n            return Group.function;\n        case utils_1.AST_NODE_TYPES.TSImportType:\n            return Group.import;\n        case utils_1.AST_NODE_TYPES.TSIntersectionType:\n            return Group.intersection;\n        case utils_1.AST_NODE_TYPES.TSAnyKeyword:\n        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:\n        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n        case utils_1.AST_NODE_TYPES.TSNeverKeyword:\n        case utils_1.AST_NODE_TYPES.TSNumberKeyword:\n        case utils_1.AST_NODE_TYPES.TSObjectKeyword:\n        case utils_1.AST_NODE_TYPES.TSStringKeyword:\n        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:\n        case utils_1.AST_NODE_TYPES.TSThisType:\n        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:\n        case utils_1.AST_NODE_TYPES.TSIntrinsicKeyword:\n            return Group.keyword;\n        case utils_1.AST_NODE_TYPES.TSNullKeyword:\n        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:\n        case utils_1.AST_NODE_TYPES.TSVoidKeyword:\n            return Group.nullish;\n        case utils_1.AST_NODE_TYPES.TSLiteralType:\n        case utils_1.AST_NODE_TYPES.TSTemplateLiteralType:\n            return Group.literal;\n        case utils_1.AST_NODE_TYPES.TSArrayType:\n        case utils_1.AST_NODE_TYPES.TSIndexedAccessType:\n        case utils_1.AST_NODE_TYPES.TSInferType:\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n        case utils_1.AST_NODE_TYPES.TSQualifiedName:\n            return Group.named;\n        case utils_1.AST_NODE_TYPES.TSMappedType:\n        case utils_1.AST_NODE_TYPES.TSTypeLiteral:\n            return Group.object;\n        case utils_1.AST_NODE_TYPES.TSTypeOperator:\n        case utils_1.AST_NODE_TYPES.TSTypeQuery:\n            return Group.operator;\n        case utils_1.AST_NODE_TYPES.TSTupleType:\n            return Group.tuple;\n        case utils_1.AST_NODE_TYPES.TSUnionType:\n            return Group.union;\n        // These types should never occur as part of a union/intersection\n        case utils_1.AST_NODE_TYPES.TSAbstractKeyword:\n        case utils_1.AST_NODE_TYPES.TSAsyncKeyword:\n        case utils_1.AST_NODE_TYPES.TSDeclareKeyword:\n        case utils_1.AST_NODE_TYPES.TSExportKeyword:\n        case utils_1.AST_NODE_TYPES.TSNamedTupleMember:\n        case utils_1.AST_NODE_TYPES.TSOptionalType:\n        case utils_1.AST_NODE_TYPES.TSPrivateKeyword:\n        case utils_1.AST_NODE_TYPES.TSProtectedKeyword:\n        case utils_1.AST_NODE_TYPES.TSPublicKeyword:\n        case utils_1.AST_NODE_TYPES.TSReadonlyKeyword:\n        case utils_1.AST_NODE_TYPES.TSRestType:\n        case utils_1.AST_NODE_TYPES.TSStaticKeyword:\n        case utils_1.AST_NODE_TYPES.TSTypePredicate:\n            /* istanbul ignore next */\n            throw new Error(`Unexpected Type ${node.type}`);\n    }\n}\nfunction caseSensitiveSort(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexports.default = (0, util_1.createRule)({\n    name: 'sort-type-constituents',\n    meta: {\n        type: 'suggestion',\n        deprecated: true,\n        docs: {\n            description: 'Enforce constituents of a type union/intersection to be sorted alphabetically',\n        },\n        fixable: 'code',\n        hasSuggestions: true,\n        messages: {\n            notSorted: '{{type}} type constituents must be sorted.',\n            notSortedNamed: '{{type}} type {{name}} constituents must be sorted.',\n            suggestFix: 'Sort constituents of type (removes all comments).',\n        },\n        replacedBy: [\n            'perfectionist/sort-intersection-types',\n            'perfectionist/sort-union-types',\n        ],\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    caseSensitive: {\n                        type: 'boolean',\n                        description: 'Whether to sort using case sensitive string comparisons.',\n                    },\n                    checkIntersections: {\n                        type: 'boolean',\n                        description: 'Whether to check intersection types (`&`).',\n                    },\n                    checkUnions: {\n                        type: 'boolean',\n                        description: 'Whether to check union types (`|`).',\n                    },\n                    groupOrder: {\n                        type: 'array',\n                        description: 'Ordering of the groups.',\n                        items: {\n                            type: 'string',\n                            enum: (0, util_1.getEnumNames)(Group),\n                        },\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            caseSensitive: false,\n            checkIntersections: true,\n            checkUnions: true,\n            groupOrder: [\n                Group.named,\n                Group.keyword,\n                Group.operator,\n                Group.literal,\n                Group.function,\n                Group.import,\n                Group.conditional,\n                Group.object,\n                Group.tuple,\n                Group.intersection,\n                Group.union,\n                Group.nullish,\n            ],\n        },\n    ],\n    create(context, [{ caseSensitive, checkIntersections, checkUnions, groupOrder }]) {\n        const collator = new Intl.Collator('en', {\n            numeric: true,\n            sensitivity: 'base',\n        });\n        function checkSorting(node) {\n            const sourceOrder = node.types.map(type => {\n                const group = groupOrder?.indexOf(getGroup(type)) ?? -1;\n                return {\n                    node: type,\n                    group: group === -1 ? Number.MAX_SAFE_INTEGER : group,\n                    text: context.sourceCode.getText(type),\n                };\n            });\n            const expectedOrder = [...sourceOrder].sort((a, b) => {\n                if (a.group !== b.group) {\n                    return a.group - b.group;\n                }\n                if (caseSensitive) {\n                    return caseSensitiveSort(a.text, b.text);\n                }\n                return (collator.compare(a.text, b.text) ||\n                    (a.text < b.text ? -1 : a.text > b.text ? 1 : 0));\n            });\n            const hasComments = node.types.some(type => {\n                const count = context.sourceCode.getCommentsBefore(type).length +\n                    context.sourceCode.getCommentsAfter(type).length;\n                return count > 0;\n            });\n            for (let i = 0; i < expectedOrder.length; i += 1) {\n                if (expectedOrder[i].node !== sourceOrder[i].node) {\n                    let messageId = 'notSorted';\n                    const data = {\n                        name: '',\n                        type: node.type === utils_1.AST_NODE_TYPES.TSIntersectionType\n                            ? 'Intersection'\n                            : 'Union',\n                    };\n                    if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {\n                        messageId = 'notSortedNamed';\n                        data.name = node.parent.id.name;\n                    }\n                    const fix = fixer => {\n                        const sorted = expectedOrder\n                            .map(t => (0, util_1.typeNodeRequiresParentheses)(t.node, t.text) ||\n                            (node.type === utils_1.AST_NODE_TYPES.TSIntersectionType &&\n                                t.node.type === utils_1.AST_NODE_TYPES.TSUnionType)\n                            ? `(${t.text})`\n                            : t.text)\n                            .join(node.type === utils_1.AST_NODE_TYPES.TSIntersectionType ? ' & ' : ' | ');\n                        return fixer.replaceText(node, sorted);\n                    };\n                    return context.report({\n                        node,\n                        messageId,\n                        data,\n                        // don't autofix if any of the types have leading/trailing comments\n                        // the logic for preserving them correctly is a pain - we may implement this later\n                        ...(hasComments\n                            ? {\n                                suggest: [\n                                    {\n                                        messageId: 'suggestFix',\n                                        fix,\n                                    },\n                                ],\n                            }\n                            : { fix }),\n                    });\n                }\n            }\n        }\n        return {\n            ...(checkIntersections && {\n                TSIntersectionType(node) {\n                    checkSorting(node);\n                },\n            }),\n            ...(checkUnions && {\n                TSUnionType(node) {\n                    checkSorting(node);\n                },\n            }),\n        };\n    },\n});\n"
        }
    ]
}