{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/array-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891959409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\n/**\n * Check whatever node can be considered as simple\n * @param node the node to be evaluated.\n */\nfunction isSimpleType(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.Identifier:\n        case utils_1.AST_NODE_TYPES.TSAnyKeyword:\n        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n        case utils_1.AST_NODE_TYPES.TSNeverKeyword:\n        case utils_1.AST_NODE_TYPES.TSNumberKeyword:\n        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:\n        case utils_1.AST_NODE_TYPES.TSObjectKeyword:\n        case utils_1.AST_NODE_TYPES.TSStringKeyword:\n        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:\n        case utils_1.AST_NODE_TYPES.TSUnknownKeyword:\n        case utils_1.AST_NODE_TYPES.TSVoidKeyword:\n        case utils_1.AST_NODE_TYPES.TSNullKeyword:\n        case utils_1.AST_NODE_TYPES.TSArrayType:\n        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:\n        case utils_1.AST_NODE_TYPES.TSThisType:\n        case utils_1.AST_NODE_TYPES.TSQualifiedName:\n            return true;\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n            if (node.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&\n                node.typeName.name === 'Array') {\n                if (!node.typeArguments) {\n                    return true;\n                }\n                if (node.typeArguments.params.length === 1) {\n                    return isSimpleType(node.typeArguments.params[0]);\n                }\n            }\n            else {\n                if (node.typeArguments) {\n                    return false;\n                }\n                return isSimpleType(node.typeName);\n            }\n            return false;\n        default:\n            return false;\n    }\n}\n/**\n * Check if node needs parentheses\n * @param node the node to be evaluated.\n */\nfunction typeNeedsParentheses(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n            return typeNeedsParentheses(node.typeName);\n        case utils_1.AST_NODE_TYPES.TSUnionType:\n        case utils_1.AST_NODE_TYPES.TSFunctionType:\n        case utils_1.AST_NODE_TYPES.TSIntersectionType:\n        case utils_1.AST_NODE_TYPES.TSTypeOperator:\n        case utils_1.AST_NODE_TYPES.TSInferType:\n        case utils_1.AST_NODE_TYPES.TSConstructorType:\n        case utils_1.AST_NODE_TYPES.TSConditionalType:\n            return true;\n        case utils_1.AST_NODE_TYPES.Identifier:\n            return node.name === 'ReadonlyArray';\n        default:\n            return false;\n    }\n}\nexports.default = (0, util_1.createRule)({\n    name: 'array-type',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require consistently using either `T[]` or `Array<T>` for arrays',\n            recommended: 'stylistic',\n        },\n        fixable: 'code',\n        messages: {\n            errorStringArray: \"Array type using '{{className}}<{{type}}>' is forbidden. Use '{{readonlyPrefix}}{{type}}[]' instead.\",\n            errorStringArrayReadonly: \"Array type using '{{className}}<{{type}}>' is forbidden. Use '{{readonlyPrefix}}{{type}}' instead.\",\n            errorStringArraySimple: \"Array type using '{{className}}<{{type}}>' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}[]' instead.\",\n            errorStringArraySimpleReadonly: \"Array type using '{{className}}<{{type}}>' is forbidden for simple types. Use '{{readonlyPrefix}}{{type}}' instead.\",\n            errorStringGeneric: \"Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden. Use '{{className}}<{{type}}>' instead.\",\n            errorStringGenericSimple: \"Array type using '{{readonlyPrefix}}{{type}}[]' is forbidden for non-simple types. Use '{{className}}<{{type}}>' instead.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                $defs: {\n                    arrayOption: {\n                        type: 'string',\n                        enum: ['array', 'generic', 'array-simple'],\n                    },\n                },\n                additionalProperties: false,\n                properties: {\n                    default: {\n                        $ref: '#/items/0/$defs/arrayOption',\n                        description: 'The array type expected for mutable cases.',\n                    },\n                    readonly: {\n                        $ref: '#/items/0/$defs/arrayOption',\n                        description: 'The array type expected for readonly cases. If omitted, the value for `default` will be used.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            default: 'array',\n        },\n    ],\n    create(context, [options]) {\n        const defaultOption = options.default;\n        const readonlyOption = options.readonly ?? defaultOption;\n        /**\n         * @param node the node to be evaluated.\n         */\n        function getMessageType(node) {\n            if (isSimpleType(node)) {\n                return context.sourceCode.getText(node);\n            }\n            return 'T';\n        }\n        return {\n            TSArrayType(node) {\n                const isReadonly = node.parent.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&\n                    node.parent.operator === 'readonly';\n                const currentOption = isReadonly ? readonlyOption : defaultOption;\n                if (currentOption === 'array' ||\n                    (currentOption === 'array-simple' && isSimpleType(node.elementType))) {\n                    return;\n                }\n                const messageId = currentOption === 'generic'\n                    ? 'errorStringGeneric'\n                    : 'errorStringGenericSimple';\n                const errorNode = isReadonly ? node.parent : node;\n                context.report({\n                    node: errorNode,\n                    messageId,\n                    data: {\n                        type: getMessageType(node.elementType),\n                        className: isReadonly ? 'ReadonlyArray' : 'Array',\n                        readonlyPrefix: isReadonly ? 'readonly ' : '',\n                    },\n                    fix(fixer) {\n                        const typeNode = node.elementType;\n                        const arrayType = isReadonly ? 'ReadonlyArray' : 'Array';\n                        return [\n                            fixer.replaceTextRange([errorNode.range[0], typeNode.range[0]], `${arrayType}<`),\n                            fixer.replaceTextRange([typeNode.range[1], errorNode.range[1]], '>'),\n                        ];\n                    },\n                });\n            },\n            TSTypeReference(node) {\n                if (node.typeName.type !== utils_1.AST_NODE_TYPES.Identifier ||\n                    !(node.typeName.name === 'Array' ||\n                        node.typeName.name === 'ReadonlyArray' ||\n                        node.typeName.name === 'Readonly') ||\n                    (node.typeName.name === 'Readonly' &&\n                        node.typeArguments?.params[0].type !== utils_1.AST_NODE_TYPES.TSArrayType)) {\n                    return;\n                }\n                const isReadonlyWithGenericArrayType = node.typeName.name === 'Readonly' &&\n                    node.typeArguments?.params[0].type === utils_1.AST_NODE_TYPES.TSArrayType;\n                const isReadonlyArrayType = node.typeName.name === 'ReadonlyArray' ||\n                    isReadonlyWithGenericArrayType;\n                const currentOption = isReadonlyArrayType\n                    ? readonlyOption\n                    : defaultOption;\n                if (currentOption === 'generic') {\n                    return;\n                }\n                const readonlyPrefix = isReadonlyArrayType ? 'readonly ' : '';\n                const typeParams = node.typeArguments?.params;\n                const messageId = currentOption === 'array'\n                    ? isReadonlyWithGenericArrayType\n                        ? 'errorStringArrayReadonly'\n                        : 'errorStringArray'\n                    : isReadonlyArrayType && node.typeName.name !== 'ReadonlyArray'\n                        ? 'errorStringArraySimpleReadonly'\n                        : 'errorStringArraySimple';\n                if (!typeParams || typeParams.length === 0) {\n                    // Create an 'any' array\n                    context.report({\n                        node,\n                        messageId,\n                        data: {\n                            type: 'any',\n                            className: isReadonlyArrayType ? 'ReadonlyArray' : 'Array',\n                            readonlyPrefix,\n                        },\n                        fix(fixer) {\n                            return fixer.replaceText(node, `${readonlyPrefix}any[]`);\n                        },\n                    });\n                    return;\n                }\n                if (typeParams.length !== 1 ||\n                    (currentOption === 'array-simple' && !isSimpleType(typeParams[0]))) {\n                    return;\n                }\n                const type = typeParams[0];\n                const typeParens = typeNeedsParentheses(type);\n                const parentParens = readonlyPrefix &&\n                    node.parent.type === utils_1.AST_NODE_TYPES.TSArrayType &&\n                    !(0, util_1.isParenthesized)(node.parent.elementType, context.sourceCode);\n                const start = `${parentParens ? '(' : ''}${readonlyPrefix}${typeParens ? '(' : ''}`;\n                const end = `${typeParens ? ')' : ''}${isReadonlyWithGenericArrayType ? '' : `[]`}${parentParens ? ')' : ''}`;\n                context.report({\n                    node,\n                    messageId,\n                    data: {\n                        type: getMessageType(type),\n                        className: isReadonlyArrayType ? node.typeName.name : 'Array',\n                        readonlyPrefix,\n                    },\n                    fix(fixer) {\n                        return [\n                            fixer.replaceTextRange([node.range[0], type.range[0]], start),\n                            fixer.replaceTextRange([type.range[1], node.range[1]], end),\n                        ];\n                    },\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}