{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unsafe-argument.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891969705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nvar RestTypeKind;\n(function (RestTypeKind) {\n    RestTypeKind[RestTypeKind[\"Array\"] = 0] = \"Array\";\n    RestTypeKind[RestTypeKind[\"Tuple\"] = 1] = \"Tuple\";\n    RestTypeKind[RestTypeKind[\"Other\"] = 2] = \"Other\";\n})(RestTypeKind || (RestTypeKind = {}));\nclass FunctionSignature {\n    paramTypes;\n    restType;\n    hasConsumedArguments = false;\n    parameterTypeIndex = 0;\n    constructor(paramTypes, restType) {\n        this.paramTypes = paramTypes;\n        this.restType = restType;\n    }\n    static create(checker, tsNode) {\n        const signature = checker.getResolvedSignature(tsNode);\n        if (!signature) {\n            return null;\n        }\n        const paramTypes = [];\n        let restType = null;\n        const parameters = signature.getParameters();\n        for (let i = 0; i < parameters.length; i += 1) {\n            const param = parameters[i];\n            const type = checker.getTypeOfSymbolAtLocation(param, tsNode);\n            const decl = param.getDeclarations()?.[0];\n            if (decl && (0, util_1.isRestParameterDeclaration)(decl)) {\n                // is a rest param\n                if (checker.isArrayType(type)) {\n                    restType = {\n                        type: checker.getTypeArguments(type)[0],\n                        index: i,\n                        kind: RestTypeKind.Array,\n                    };\n                }\n                else if (checker.isTupleType(type)) {\n                    restType = {\n                        index: i,\n                        kind: RestTypeKind.Tuple,\n                        typeArguments: checker.getTypeArguments(type),\n                    };\n                }\n                else {\n                    restType = {\n                        type,\n                        index: i,\n                        kind: RestTypeKind.Other,\n                    };\n                }\n                break;\n            }\n            paramTypes.push(type);\n        }\n        return new this(paramTypes, restType);\n    }\n    consumeRemainingArguments() {\n        this.hasConsumedArguments = true;\n    }\n    getNextParameterType() {\n        const index = this.parameterTypeIndex;\n        this.parameterTypeIndex += 1;\n        if (index >= this.paramTypes.length || this.hasConsumedArguments) {\n            if (this.restType == null) {\n                return null;\n            }\n            switch (this.restType.kind) {\n                case RestTypeKind.Tuple: {\n                    const typeArguments = this.restType.typeArguments;\n                    if (this.hasConsumedArguments) {\n                        // all types consumed by a rest - just assume it's the last type\n                        // there is one edge case where this is wrong, but we ignore it because\n                        // it's rare and really complicated to handle\n                        // eg: function foo(...a: [number, ...string[], number])\n                        return typeArguments[typeArguments.length - 1];\n                    }\n                    const typeIndex = index - this.restType.index;\n                    if (typeIndex >= typeArguments.length) {\n                        return typeArguments[typeArguments.length - 1];\n                    }\n                    return typeArguments[typeIndex];\n                }\n                case RestTypeKind.Array:\n                case RestTypeKind.Other:\n                    return this.restType.type;\n            }\n        }\n        return this.paramTypes[index];\n    }\n}\nexports.default = (0, util_1.createRule)({\n    name: 'no-unsafe-argument',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow calling a function with a value with type `any`',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            unsafeArgument: 'Unsafe argument of type {{sender}} assigned to a parameter of type {{receiver}}.',\n            unsafeArraySpread: 'Unsafe spread of an {{sender}} array type.',\n            unsafeSpread: 'Unsafe spread of an {{sender}} type.',\n            unsafeTupleSpread: 'Unsafe spread of a tuple type. The argument is {{sender}} and is assigned to a parameter of type {{receiver}}.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function describeType(type) {\n            if (tsutils.isIntrinsicErrorType(type)) {\n                return 'error typed';\n            }\n            return `\\`${checker.typeToString(type)}\\``;\n        }\n        function describeTypeForSpread(type) {\n            if (checker.isArrayType(type) &&\n                tsutils.isIntrinsicErrorType(checker.getTypeArguments(type)[0])) {\n                return 'error';\n            }\n            return describeType(type);\n        }\n        function describeTypeForTuple(type) {\n            if (tsutils.isIntrinsicErrorType(type)) {\n                return 'error typed';\n            }\n            return `of type \\`${checker.typeToString(type)}\\``;\n        }\n        function checkUnsafeArguments(args, callee, node) {\n            if (args.length === 0) {\n                return;\n            }\n            // ignore any-typed calls as these are caught by no-unsafe-call\n            if ((0, util_1.isTypeAnyType)(services.getTypeAtLocation(callee))) {\n                return;\n            }\n            const tsNode = services.esTreeNodeToTSNodeMap.get(node);\n            const signature = (0, util_1.nullThrows)(FunctionSignature.create(checker, tsNode), 'Expected to a signature resolved');\n            if (node.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {\n                // Consumes the first parameter (TemplateStringsArray) of the function called with TaggedTemplateExpression.\n                signature.getNextParameterType();\n            }\n            for (const argument of args) {\n                switch (argument.type) {\n                    // spreads consume\n                    case utils_1.AST_NODE_TYPES.SpreadElement: {\n                        const spreadArgType = services.getTypeAtLocation(argument.argument);\n                        if ((0, util_1.isTypeAnyType)(spreadArgType)) {\n                            // foo(...any)\n                            context.report({\n                                node: argument,\n                                messageId: 'unsafeSpread',\n                                data: { sender: describeType(spreadArgType) },\n                            });\n                        }\n                        else if ((0, util_1.isTypeAnyArrayType)(spreadArgType, checker)) {\n                            // foo(...any[])\n                            // TODO - we could break down the spread and compare the array type against each argument\n                            context.report({\n                                node: argument,\n                                messageId: 'unsafeArraySpread',\n                                data: { sender: describeTypeForSpread(spreadArgType) },\n                            });\n                        }\n                        else if (checker.isTupleType(spreadArgType)) {\n                            // foo(...[tuple1, tuple2])\n                            const spreadTypeArguments = checker.getTypeArguments(spreadArgType);\n                            for (const tupleType of spreadTypeArguments) {\n                                const parameterType = signature.getNextParameterType();\n                                if (parameterType == null) {\n                                    continue;\n                                }\n                                const result = (0, util_1.isUnsafeAssignment)(tupleType, parameterType, checker, \n                                // we can't pass the individual tuple members in here as this will most likely be a spread variable\n                                // not a spread array\n                                null);\n                                if (result) {\n                                    context.report({\n                                        node: argument,\n                                        messageId: 'unsafeTupleSpread',\n                                        data: {\n                                            receiver: describeType(parameterType),\n                                            sender: describeTypeForTuple(tupleType),\n                                        },\n                                    });\n                                }\n                            }\n                            if (spreadArgType.target.combinedFlags & ts.ElementFlags.Variable) {\n                                // the last element was a rest - so all remaining defined arguments can be considered \"consumed\"\n                                // all remaining arguments should be compared against the rest type (if one exists)\n                                signature.consumeRemainingArguments();\n                            }\n                        }\n                        else {\n                            // something that's iterable\n                            // handling this will be pretty complex - so we ignore it for now\n                            // TODO - handle generic iterable case\n                        }\n                        break;\n                    }\n                    default: {\n                        const parameterType = signature.getNextParameterType();\n                        if (parameterType == null) {\n                            continue;\n                        }\n                        const argumentType = services.getTypeAtLocation(argument);\n                        const result = (0, util_1.isUnsafeAssignment)(argumentType, parameterType, checker, argument);\n                        if (result) {\n                            context.report({\n                                node: argument,\n                                messageId: 'unsafeArgument',\n                                data: {\n                                    receiver: describeType(parameterType),\n                                    sender: describeType(argumentType),\n                                },\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return {\n            'CallExpression, NewExpression'(node) {\n                checkUnsafeArguments(node.arguments, node.callee, node);\n            },\n            TaggedTemplateExpression(node) {\n                checkUnsafeArguments(node.quasi.expressions, node.tag, node);\n            },\n        };\n    },\n});\n"
        }
    ]
}