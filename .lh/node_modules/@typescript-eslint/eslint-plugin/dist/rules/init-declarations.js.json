{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/init-declarations.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891961672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('init-declarations');\nexports.default = (0, util_1.createRule)({\n    name: 'init-declarations',\n    meta: {\n        type: 'suggestion',\n        // defaultOptions, -- base rule does not use defaultOptions\n        docs: {\n            description: 'Require or disallow initialization in variable declarations',\n            extendsBaseRule: true,\n        },\n        hasSuggestions: baseRule.meta.hasSuggestions,\n        messages: baseRule.meta.messages,\n        schema: baseRule.meta.schema,\n    },\n    defaultOptions: ['always'],\n    create(context, [mode]) {\n        // Make a custom context to adjust the loc of reports where the base\n        // rule's behavior is a bit too aggressive with TS-specific syntax (namely,\n        // type annotations).\n        function getBaseContextOverride() {\n            const reportOverride = descriptor => {\n                if ('node' in descriptor && descriptor.loc == null) {\n                    const { node, ...rest } = descriptor;\n                    // We only want to special case the report loc when reporting on\n                    // variables declarations that are not initialized. Declarations that\n                    // _are_ initialized get reported by the base rule due to a setting to\n                    // prohibit initializing variables entirely, in which case underlining\n                    // the whole node including the type annotation and initializer is\n                    // appropriate.\n                    if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator &&\n                        node.init == null) {\n                        context.report({\n                            ...rest,\n                            loc: getReportLoc(node),\n                        });\n                        return;\n                    }\n                }\n                context.report(descriptor);\n            };\n            // `return { ...context, report: reportOverride }` isn't safe because the\n            // `context` object has some getters that need to be preserved.\n            //\n            // `return new Proxy(context, ...)` doesn't work because `context` has\n            // non-configurable properties that throw when constructing a Proxy.\n            //\n            // So, we'll just use Proxy on a dummy object and use the `get` trap to\n            // proxy `context`'s properties.\n            return new Proxy({}, {\n                get: (target, prop, receiver) => prop === 'report'\n                    ? reportOverride\n                    : Reflect.get(context, prop, receiver),\n            });\n        }\n        const rules = baseRule.create(getBaseContextOverride());\n        return {\n            'VariableDeclaration:exit'(node) {\n                if (mode === 'always') {\n                    if (node.declare) {\n                        return;\n                    }\n                    if (isAncestorNamespaceDeclared(node)) {\n                        return;\n                    }\n                }\n                rules['VariableDeclaration:exit'](node);\n            },\n        };\n        function isAncestorNamespaceDeclared(node) {\n            let ancestor = node.parent;\n            while (ancestor) {\n                if (ancestor.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration &&\n                    ancestor.declare) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n    },\n});\n/**\n * When reporting an uninitialized variable declarator, get the loc excluding\n * the type annotation.\n */\nfunction getReportLoc(node) {\n    const start = structuredClone(node.loc.start);\n    const end = {\n        line: node.loc.start.line,\n        // `if (id.type === AST_NODE_TYPES.Identifier)` is a condition for\n        // reporting in the base rule (as opposed to things like destructuring\n        // assignment), so the type assertion should always be valid.\n        column: node.loc.start.column + node.id.name.length,\n    };\n    return {\n        start,\n        end,\n    };\n}\n"
        }
    ]
}