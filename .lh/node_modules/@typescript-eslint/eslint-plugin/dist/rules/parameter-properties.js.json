{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/parameter-properties.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891971665,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'parameter-properties',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Require or disallow parameter properties in class constructors',\n        },\n        messages: {\n            preferClassProperty: 'Property {{parameter}} should be declared as a class property.',\n            preferParameterProperty: 'Property {{parameter}} should be declared as a parameter property.',\n        },\n        schema: [\n            {\n                type: 'object',\n                $defs: {\n                    modifier: {\n                        type: 'string',\n                        enum: [\n                            'readonly',\n                            'private',\n                            'protected',\n                            'public',\n                            'private readonly',\n                            'protected readonly',\n                            'public readonly',\n                        ],\n                    },\n                },\n                additionalProperties: false,\n                properties: {\n                    allow: {\n                        type: 'array',\n                        description: 'Whether to allow certain kinds of properties to be ignored.',\n                        items: {\n                            $ref: '#/items/0/$defs/modifier',\n                        },\n                    },\n                    prefer: {\n                        type: 'string',\n                        description: 'Whether to prefer class properties or parameter properties.',\n                        enum: ['class-property', 'parameter-property'],\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allow: [],\n            prefer: 'class-property',\n        },\n    ],\n    create(context, [{ allow = [], prefer = 'class-property' }]) {\n        /**\n         * Gets the modifiers of `node`.\n         * @param node the node to be inspected.\n         */\n        function getModifiers(node) {\n            const modifiers = [];\n            if (node.accessibility) {\n                modifiers.push(node.accessibility);\n            }\n            if (node.readonly) {\n                modifiers.push('readonly');\n            }\n            return modifiers.filter(Boolean).join(' ');\n        }\n        if (prefer === 'class-property') {\n            return {\n                TSParameterProperty(node) {\n                    const modifiers = getModifiers(node);\n                    if (!allow.includes(modifiers)) {\n                        // HAS to be an identifier or assignment or TSC will throw\n                        if (node.parameter.type !== utils_1.AST_NODE_TYPES.Identifier &&\n                            node.parameter.type !== utils_1.AST_NODE_TYPES.AssignmentPattern) {\n                            return;\n                        }\n                        const name = node.parameter.type === utils_1.AST_NODE_TYPES.Identifier\n                            ? node.parameter.name\n                            : // has to be an Identifier or TSC will throw an error\n                                node.parameter.left.name;\n                        context.report({\n                            node,\n                            messageId: 'preferClassProperty',\n                            data: {\n                                parameter: name,\n                            },\n                        });\n                    }\n                },\n            };\n        }\n        const propertyNodesByNameStack = [];\n        function getNodesByName(name) {\n            const propertyNodesByName = propertyNodesByNameStack[propertyNodesByNameStack.length - 1];\n            const existing = propertyNodesByName.get(name);\n            if (existing) {\n                return existing;\n            }\n            const created = {};\n            propertyNodesByName.set(name, created);\n            return created;\n        }\n        function typeAnnotationsMatch(classProperty, constructorParameter) {\n            if (!classProperty.typeAnnotation ||\n                !constructorParameter.typeAnnotation) {\n                return (classProperty.typeAnnotation === constructorParameter.typeAnnotation);\n            }\n            return (context.sourceCode.getText(classProperty.typeAnnotation) ===\n                context.sourceCode.getText(constructorParameter.typeAnnotation));\n        }\n        return {\n            ':matches(ClassDeclaration, ClassExpression):exit'() {\n                const propertyNodesByName = (0, util_1.nullThrows)(propertyNodesByNameStack.pop(), 'Stack should exist on class exit');\n                for (const [name, nodes] of propertyNodesByName) {\n                    if (nodes.classProperty &&\n                        nodes.constructorAssignment &&\n                        nodes.constructorParameter &&\n                        typeAnnotationsMatch(nodes.classProperty, nodes.constructorParameter)) {\n                        context.report({\n                            node: nodes.classProperty,\n                            messageId: 'preferParameterProperty',\n                            data: {\n                                parameter: name,\n                            },\n                        });\n                    }\n                }\n            },\n            ClassBody(node) {\n                for (const element of node.body) {\n                    if (element.type === utils_1.AST_NODE_TYPES.PropertyDefinition &&\n                        element.key.type === utils_1.AST_NODE_TYPES.Identifier &&\n                        !element.value &&\n                        !allow.includes(getModifiers(element))) {\n                        getNodesByName(element.key.name).classProperty = element;\n                    }\n                }\n            },\n            'ClassDeclaration, ClassExpression'() {\n                propertyNodesByNameStack.push(new Map());\n            },\n            'MethodDefinition[kind=\"constructor\"]'(node) {\n                for (const parameter of node.value.params) {\n                    if (parameter.type === utils_1.AST_NODE_TYPES.Identifier) {\n                        getNodesByName(parameter.name).constructorParameter = parameter;\n                    }\n                }\n                for (const statement of node.value.body?.body ?? []) {\n                    if (statement.type !== utils_1.AST_NODE_TYPES.ExpressionStatement ||\n                        statement.expression.type !== utils_1.AST_NODE_TYPES.AssignmentExpression ||\n                        statement.expression.left.type !==\n                            utils_1.AST_NODE_TYPES.MemberExpression ||\n                        statement.expression.left.object.type !==\n                            utils_1.AST_NODE_TYPES.ThisExpression ||\n                        statement.expression.left.property.type !==\n                            utils_1.AST_NODE_TYPES.Identifier ||\n                        statement.expression.right.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                        break;\n                    }\n                    getNodesByName(statement.expression.right.name).constructorAssignment = statement.expression;\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}