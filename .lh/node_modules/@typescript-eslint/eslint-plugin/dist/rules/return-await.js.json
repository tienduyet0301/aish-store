{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/return-await.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'return-await',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Enforce consistent awaiting of returned promises',\n            recommended: {\n                strict: ['error-handling-correctness-only'],\n            },\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- suggestions are exposed through a helper.\n        hasSuggestions: true,\n        messages: {\n            disallowedPromiseAwait: 'Returning an awaited promise is not allowed in this context.',\n            disallowedPromiseAwaitSuggestion: 'Remove `await` before the expression. Use caution as this may impact control flow.',\n            nonPromiseAwait: 'Returning an awaited value that is not a promise is not allowed.',\n            requiredPromiseAwait: 'Returning an awaited promise is required in this context.',\n            requiredPromiseAwaitSuggestion: 'Add `await` before the expression. Use caution as this may impact control flow.',\n        },\n        schema: [\n            {\n                type: 'string',\n                oneOf: [\n                    {\n                        type: 'string',\n                        description: 'Requires that all returned promises be awaited.',\n                        enum: ['always'],\n                    },\n                    {\n                        type: 'string',\n                        description: 'In error-handling contexts, the rule enforces that returned promises must be awaited. In ordinary contexts, the rule does not enforce any particular behavior around whether returned promises are awaited.',\n                        enum: ['error-handling-correctness-only'],\n                    },\n                    {\n                        type: 'string',\n                        description: 'In error-handling contexts, the rule enforces that returned promises must be awaited. In ordinary contexts, the rule enforces that returned promises _must not_ be awaited.',\n                        enum: ['in-try-catch'],\n                    },\n                    {\n                        type: 'string',\n                        description: 'Disallows awaiting any returned promises.',\n                        enum: ['never'],\n                    },\n                ],\n            },\n        ],\n    },\n    defaultOptions: ['in-try-catch'],\n    create(context, [option]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const scopeInfoStack = [];\n        function enterFunction(node) {\n            scopeInfoStack.push({\n                hasAsync: node.async,\n                owningFunc: node,\n            });\n        }\n        function exitFunction() {\n            scopeInfoStack.pop();\n        }\n        function affectsExplicitResourceManagement(node) {\n            // just need to determine if there is a `using` declaration in scope.\n            let scope = context.sourceCode.getScope(node);\n            const functionScope = scope.variableScope;\n            while (true) {\n                for (const variable of scope.variables) {\n                    if (variable.defs.length !== 1) {\n                        // This can't be the case for `using` or `await using` since it's\n                        // an error to redeclare those more than once in the same scope,\n                        // unlike, say, `var` declarations.\n                        continue;\n                    }\n                    const declaration = variable.defs[0];\n                    const declaratorNode = declaration.node;\n                    const declarationNode = declaratorNode.parent;\n                    // if it's a using/await using declaration, and it comes _before_ the\n                    // node we're checking, it affects control flow for that node.\n                    if (['await using', 'using'].includes(declarationNode.kind) &&\n                        declaratorNode.range[1] < node.range[0]) {\n                        return true;\n                    }\n                }\n                if (scope === functionScope) {\n                    // We've checked all the relevant scopes\n                    break;\n                }\n                // This should always exist, since the rule should only be checking\n                // contexts in which `return` statements are legal, which should always\n                // be inside a function.\n                scope = (0, util_1.nullThrows)(scope.upper, 'Expected parent scope to exist. return-await should only operate on return statements within functions');\n            }\n            return false;\n        }\n        /**\n         * Tests whether a node is inside of an explicit error handling context\n         * (try/catch/finally) in a way that throwing an exception will have an\n         * impact on the program's control flow.\n         */\n        function affectsExplicitErrorHandling(node) {\n            // If an error-handling block is followed by another error-handling block,\n            // control flow is affected by whether promises in it are awaited or not.\n            // Otherwise, we need to check recursively for nested try statements until\n            // we get to the top level of a function or the program. If by then,\n            // there's no offending error-handling blocks, it doesn't affect control\n            // flow.\n            const tryAncestorResult = findContainingTryStatement(node);\n            if (tryAncestorResult == null) {\n                return false;\n            }\n            const { block, tryStatement } = tryAncestorResult;\n            switch (block) {\n                case 'catch':\n                    // Exceptions thrown in catch blocks followed by a finally block affect\n                    // control flow.\n                    if (tryStatement.finallyBlock != null) {\n                        return true;\n                    }\n                    // Otherwise recurse.\n                    return affectsExplicitErrorHandling(tryStatement);\n                case 'finally':\n                    return affectsExplicitErrorHandling(tryStatement);\n                case 'try':\n                    // Try blocks are always followed by either a catch or finally,\n                    // so exceptions thrown here always affect control flow.\n                    return true;\n                default: {\n                    const __never = block;\n                    throw new Error(`Unexpected block type: ${String(__never)}`);\n                }\n            }\n        }\n        /**\n         * A try _statement_ is the whole thing that encompasses try block,\n         * catch clause, and finally block. This function finds the nearest\n         * enclosing try statement (if present) for a given node, and reports which\n         * part of the try statement the node is in.\n         */\n        function findContainingTryStatement(node) {\n            let child = node;\n            let ancestor = node.parent;\n            while (ancestor && !ts.isFunctionLike(ancestor)) {\n                if (ts.isTryStatement(ancestor)) {\n                    let block;\n                    if (child === ancestor.tryBlock) {\n                        block = 'try';\n                    }\n                    else if (child === ancestor.catchClause) {\n                        block = 'catch';\n                    }\n                    else if (child === ancestor.finallyBlock) {\n                        block = 'finally';\n                    }\n                    return {\n                        block: (0, util_1.nullThrows)(block, 'Child of a try statement must be a try block, catch clause, or finally block'),\n                        tryStatement: ancestor,\n                    };\n                }\n                child = ancestor;\n                ancestor = ancestor.parent;\n            }\n            return undefined;\n        }\n        function removeAwait(fixer, node) {\n            // Should always be an await node; but let's be safe.\n            /* istanbul ignore if */ if (!(0, util_1.isAwaitExpression)(node)) {\n                return null;\n            }\n            const awaitToken = context.sourceCode.getFirstToken(node, util_1.isAwaitKeyword);\n            // Should always be the case; but let's be safe.\n            /* istanbul ignore if */ if (!awaitToken) {\n                return null;\n            }\n            const startAt = awaitToken.range[0];\n            let endAt = awaitToken.range[1];\n            // Also remove any extraneous whitespace after `await`, if there is any.\n            const nextToken = context.sourceCode.getTokenAfter(awaitToken, {\n                includeComments: true,\n            });\n            if (nextToken) {\n                endAt = nextToken.range[0];\n            }\n            return fixer.removeRange([startAt, endAt]);\n        }\n        function insertAwait(fixer, node, isHighPrecendence) {\n            if (isHighPrecendence) {\n                return fixer.insertTextBefore(node, 'await ');\n            }\n            return [\n                fixer.insertTextBefore(node, 'await ('),\n                fixer.insertTextAfter(node, ')'),\n            ];\n        }\n        function test(node, expression) {\n            let child;\n            const isAwait = ts.isAwaitExpression(expression);\n            if (isAwait) {\n                child = expression.getChildAt(1);\n            }\n            else {\n                child = expression;\n            }\n            const type = checker.getTypeAtLocation(child);\n            const certainty = (0, util_1.needsToBeAwaited)(checker, expression, type);\n            // handle awaited _non_thenables\n            if (certainty !== util_1.Awaitable.Always) {\n                if (isAwait) {\n                    if (certainty === util_1.Awaitable.May) {\n                        return;\n                    }\n                    context.report({\n                        node,\n                        messageId: 'nonPromiseAwait',\n                        fix: fixer => removeAwait(fixer, node),\n                    });\n                }\n                return;\n            }\n            // At this point it's definitely a thenable.\n            const affectsErrorHandling = affectsExplicitErrorHandling(expression) ||\n                affectsExplicitResourceManagement(node);\n            const useAutoFix = !affectsErrorHandling;\n            const ruleConfiguration = getConfiguration(option);\n            const shouldAwaitInCurrentContext = affectsErrorHandling\n                ? ruleConfiguration.errorHandlingContext\n                : ruleConfiguration.ordinaryContext;\n            switch (shouldAwaitInCurrentContext) {\n                case 'await':\n                    if (!isAwait) {\n                        context.report({\n                            node,\n                            messageId: 'requiredPromiseAwait',\n                            ...(0, util_1.getFixOrSuggest)({\n                                fixOrSuggest: useAutoFix ? 'fix' : 'suggest',\n                                suggestion: {\n                                    messageId: 'requiredPromiseAwaitSuggestion',\n                                    fix: fixer => insertAwait(fixer, node, (0, util_1.isHigherPrecedenceThanAwait)(expression)),\n                                },\n                            }),\n                        });\n                    }\n                    break;\n                case \"don't-care\":\n                    break;\n                case 'no-await':\n                    if (isAwait) {\n                        context.report({\n                            node,\n                            messageId: 'disallowedPromiseAwait',\n                            ...(0, util_1.getFixOrSuggest)({\n                                fixOrSuggest: useAutoFix ? 'fix' : 'suggest',\n                                suggestion: {\n                                    messageId: 'disallowedPromiseAwaitSuggestion',\n                                    fix: fixer => removeAwait(fixer, node),\n                                },\n                            }),\n                        });\n                    }\n                    break;\n            }\n        }\n        function findPossiblyReturnedNodes(node) {\n            if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n                return [\n                    ...findPossiblyReturnedNodes(node.alternate),\n                    ...findPossiblyReturnedNodes(node.consequent),\n                ];\n            }\n            return [node];\n        }\n        return {\n            ArrowFunctionExpression: enterFunction,\n            'ArrowFunctionExpression:exit': exitFunction,\n            FunctionDeclaration: enterFunction,\n            'FunctionDeclaration:exit': exitFunction,\n            FunctionExpression: enterFunction,\n            'FunctionExpression:exit': exitFunction,\n            // executes after less specific handler, so exitFunction is called\n            'ArrowFunctionExpression[async = true]:exit'(node) {\n                if (node.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                    findPossiblyReturnedNodes(node.body).forEach(node => {\n                        const tsNode = services.esTreeNodeToTSNodeMap.get(node);\n                        test(node, tsNode);\n                    });\n                }\n            },\n            ReturnStatement(node) {\n                const scopeInfo = scopeInfoStack.at(-1);\n                if (!scopeInfo?.hasAsync || !node.argument) {\n                    return;\n                }\n                findPossiblyReturnedNodes(node.argument).forEach(node => {\n                    const tsNode = services.esTreeNodeToTSNodeMap.get(node);\n                    test(node, tsNode);\n                });\n            },\n        };\n    },\n});\nfunction getConfiguration(option) {\n    switch (option) {\n        case 'always':\n            return {\n                errorHandlingContext: 'await',\n                ordinaryContext: 'await',\n            };\n        case 'error-handling-correctness-only':\n            return {\n                errorHandlingContext: 'await',\n                ordinaryContext: \"don't-care\",\n            };\n        case 'in-try-catch':\n            return {\n                errorHandlingContext: 'await',\n                ordinaryContext: 'no-await',\n            };\n        case 'never':\n            return {\n                errorHandlingContext: 'no-await',\n                ordinaryContext: 'no-await',\n            };\n    }\n}\n"
        }
    ]
}