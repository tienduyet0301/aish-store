{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unnecessary-condition.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891968836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst assertionFunctionUtils_1 = require(\"../util/assertionFunctionUtils\");\n// #region\nfunction toStaticValue(type) {\n    // type.isLiteral() only covers numbers/bigints and strings, hence the rest of the branches.\n    if (tsutils.isBooleanLiteralType(type)) {\n        return { value: tsutils.isTrueLiteralType(type) };\n    }\n    if (type.flags === ts.TypeFlags.Undefined) {\n        return { value: undefined };\n    }\n    if (type.flags === ts.TypeFlags.Null) {\n        return { value: null };\n    }\n    if (type.isLiteral()) {\n        return { value: (0, util_1.getValueOfLiteralType)(type) };\n    }\n    return undefined;\n}\nconst BOOL_OPERATORS = new Set([\n    '<',\n    '>',\n    '<=',\n    '>=',\n    '==',\n    '===',\n    '!=',\n    '!==',\n]);\nfunction isBoolOperator(operator) {\n    return BOOL_OPERATORS.has(operator);\n}\nfunction booleanComparison(left, operator, right) {\n    switch (operator) {\n        case '!=':\n            // eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality\n            return left != right;\n        case '!==':\n            return left !== right;\n        case '<':\n            // @ts-expect-error: we don't care if the comparison seems unintentional.\n            return left < right;\n        case '<=':\n            // @ts-expect-error: we don't care if the comparison seems unintentional.\n            return left <= right;\n        case '==':\n            // eslint-disable-next-line eqeqeq -- intentionally comparing with loose equality\n            return left == right;\n        case '===':\n            return left === right;\n        case '>':\n            // @ts-expect-error: we don't care if the comparison seems unintentional.\n            return left > right;\n        case '>=':\n            // @ts-expect-error: we don't care if the comparison seems unintentional.\n            return left >= right;\n    }\n}\nconst constantLoopConditionsAllowedLiterals = new Set([\n    true,\n    false,\n    1,\n    0,\n]);\nexports.default = (0, util_1.createRule)({\n    name: 'no-unnecessary-condition',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow conditionals where the type is always truthy or always falsy',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            alwaysFalsy: 'Unnecessary conditional, value is always falsy.',\n            alwaysFalsyFunc: 'This callback should return a conditional, but return is always falsy.',\n            alwaysNullish: 'Unnecessary conditional, left-hand side of `??` operator is always `null` or `undefined`.',\n            alwaysTruthy: 'Unnecessary conditional, value is always truthy.',\n            alwaysTruthyFunc: 'This callback should return a conditional, but return is always truthy.',\n            comparisonBetweenLiteralTypes: 'Unnecessary conditional, comparison is always {{trueOrFalse}}, since `{{left}} {{operator}} {{right}}` is {{trueOrFalse}}.',\n            never: 'Unnecessary conditional, value is `never`.',\n            neverNullish: 'Unnecessary conditional, expected left-hand side of `??` operator to be possibly null or undefined.',\n            neverOptionalChain: 'Unnecessary optional chain on a non-nullish value.',\n            noOverlapBooleanExpression: 'Unnecessary conditional, the types have no overlap.',\n            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',\n            typeGuardAlreadyIsType: 'Unnecessary conditional, expression already has the type being checked by the {{typeGuardOrAssertionFunction}}.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowConstantLoopConditions: {\n                        description: 'Whether to ignore constant loop conditions, such as `while (true)`.',\n                        oneOf: [\n                            {\n                                type: 'boolean',\n                            },\n                            {\n                                type: 'string',\n                                enum: ['always', 'never', 'only-allowed-literals'],\n                            },\n                        ],\n                    },\n                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n                        type: 'boolean',\n                        description: 'Whether to not error when running with a tsconfig that has strictNullChecks turned.',\n                    },\n                    checkTypePredicates: {\n                        type: 'boolean',\n                        description: 'Whether to check the asserted argument of a type predicate function for unnecessary conditions',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowConstantLoopConditions: 'never',\n            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,\n            checkTypePredicates: false,\n        },\n    ],\n    create(context, [{ allowConstantLoopConditions, allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing, checkTypePredicates, },]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const compilerOptions = services.program.getCompilerOptions();\n        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');\n        const isNoUncheckedIndexedAccess = tsutils.isCompilerOptionEnabled(compilerOptions, 'noUncheckedIndexedAccess');\n        const allowConstantLoopConditionsOption = normalizeAllowConstantLoopConditions(\n        // https://github.com/typescript-eslint/typescript-eslint/issues/5439\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        allowConstantLoopConditions);\n        if (!isStrictNullChecks &&\n            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n            context.report({\n                loc: {\n                    start: { column: 0, line: 0 },\n                    end: { column: 0, line: 0 },\n                },\n                messageId: 'noStrictNullCheck',\n            });\n        }\n        function nodeIsArrayType(node) {\n            const nodeType = (0, util_1.getConstrainedTypeAtLocation)(services, node);\n            return tsutils\n                .unionTypeParts(nodeType)\n                .some(part => checker.isArrayType(part));\n        }\n        function nodeIsTupleType(node) {\n            const nodeType = (0, util_1.getConstrainedTypeAtLocation)(services, node);\n            return tsutils\n                .unionTypeParts(nodeType)\n                .some(part => checker.isTupleType(part));\n        }\n        function isArrayIndexExpression(node) {\n            return (\n            // Is an index signature\n            node.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                node.computed &&\n                // ...into an array type\n                (nodeIsArrayType(node.object) ||\n                    // ... or a tuple type\n                    (nodeIsTupleType(node.object) &&\n                        // Exception: literal index into a tuple - will have a sound type\n                        node.property.type !== utils_1.AST_NODE_TYPES.Literal)));\n        }\n        // Conditional is always necessary if it involves:\n        //    `any` or `unknown` or a naked type variable\n        function isConditionalAlwaysNecessary(type) {\n            return tsutils\n                .unionTypeParts(type)\n                .some(part => (0, util_1.isTypeAnyType)(part) ||\n                (0, util_1.isTypeUnknownType)(part) ||\n                (0, util_1.isTypeFlagSet)(part, ts.TypeFlags.TypeVariable));\n        }\n        function isNullableMemberExpression(node) {\n            const objectType = services.getTypeAtLocation(node.object);\n            if (node.computed) {\n                const propertyType = services.getTypeAtLocation(node.property);\n                return isNullablePropertyType(objectType, propertyType);\n            }\n            const property = node.property;\n            // Get the actual property name, to account for private properties (this.#prop).\n            const propertyName = context.sourceCode.getText(property);\n            const propertyType = objectType\n                .getProperties()\n                .find(prop => prop.name === propertyName);\n            if (propertyType &&\n                tsutils.isSymbolFlagSet(propertyType, ts.SymbolFlags.Optional)) {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Checks if a conditional node is necessary:\n         * if the type of the node is always true or always false, it's not necessary.\n         */\n        function checkNode(expression, isUnaryNotArgument = false, node = expression) {\n            // Check if the node is Unary Negation expression and handle it\n            if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                expression.operator === '!') {\n                return checkNode(expression.argument, !isUnaryNotArgument, node);\n            }\n            // Since typescript array index signature types don't represent the\n            //  possibility of out-of-bounds access, if we're indexing into an array\n            //  just skip the check, to avoid false positives\n            if (isArrayIndexExpression(expression)) {\n                return;\n            }\n            // When checking logical expressions, only check the right side\n            //  as the left side has been checked by checkLogicalExpressionForUnnecessaryConditionals\n            //\n            // Unless the node is nullish coalescing, as it's common to use patterns like `nullBool ?? true` to to strict\n            //  boolean checks if we inspect the right here, it'll usually be a constant condition on purpose.\n            // In this case it's better to inspect the type of the expression as a whole.\n            if (expression.type === utils_1.AST_NODE_TYPES.LogicalExpression &&\n                expression.operator !== '??') {\n                return checkNode(expression.right);\n            }\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, expression);\n            if (isConditionalAlwaysNecessary(type)) {\n                return;\n            }\n            let messageId = null;\n            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {\n                messageId = 'never';\n            }\n            else if (!(0, util_1.isPossiblyTruthy)(type)) {\n                messageId = !isUnaryNotArgument ? 'alwaysFalsy' : 'alwaysTruthy';\n            }\n            else if (!(0, util_1.isPossiblyFalsy)(type)) {\n                messageId = !isUnaryNotArgument ? 'alwaysTruthy' : 'alwaysFalsy';\n            }\n            if (messageId) {\n                context.report({ node, messageId });\n            }\n        }\n        function checkNodeForNullish(node) {\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);\n            // Conditional is always necessary if it involves `any`, `unknown` or a naked type parameter\n            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Any |\n                ts.TypeFlags.Unknown |\n                ts.TypeFlags.TypeParameter |\n                ts.TypeFlags.TypeVariable)) {\n                return;\n            }\n            let messageId = null;\n            if ((0, util_1.isTypeFlagSet)(type, ts.TypeFlags.Never)) {\n                messageId = 'never';\n            }\n            else if (!(0, util_1.isPossiblyNullish)(type) &&\n                !(node.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                    isNullableMemberExpression(node))) {\n                // Since typescript array index signature types don't represent the\n                //  possibility of out-of-bounds access, if we're indexing into an array\n                //  just skip the check, to avoid false positives\n                if (!isArrayIndexExpression(node) &&\n                    !(node.type === utils_1.AST_NODE_TYPES.ChainExpression &&\n                        node.expression.type !== utils_1.AST_NODE_TYPES.TSNonNullExpression &&\n                        optionChainContainsOptionArrayIndex(node.expression))) {\n                    messageId = 'neverNullish';\n                }\n            }\n            else if ((0, util_1.isAlwaysNullish)(type)) {\n                messageId = 'alwaysNullish';\n            }\n            if (messageId) {\n                context.report({ node, messageId });\n            }\n        }\n        /**\n         * Checks that a binary expression is necessarily conditional, reports otherwise.\n         * If both sides of the binary expression are literal values, it's not a necessary condition.\n         *\n         * NOTE: It's also unnecessary if the types that don't overlap at all\n         *    but that case is handled by the Typescript compiler itself.\n         *    Known exceptions:\n         *      - https://github.com/microsoft/TypeScript/issues/32627\n         *      - https://github.com/microsoft/TypeScript/issues/37160 (handled)\n         */\n        function checkIfBoolExpressionIsNecessaryConditional(node, left, right, operator) {\n            const leftType = (0, util_1.getConstrainedTypeAtLocation)(services, left);\n            const rightType = (0, util_1.getConstrainedTypeAtLocation)(services, right);\n            const leftStaticValue = toStaticValue(leftType);\n            const rightStaticValue = toStaticValue(rightType);\n            if (leftStaticValue != null && rightStaticValue != null) {\n                const conditionIsTrue = booleanComparison(leftStaticValue.value, operator, rightStaticValue.value);\n                context.report({\n                    node,\n                    messageId: 'comparisonBetweenLiteralTypes',\n                    data: {\n                        left: checker.typeToString(leftType),\n                        operator,\n                        right: checker.typeToString(rightType),\n                        trueOrFalse: conditionIsTrue ? 'true' : 'false',\n                    },\n                });\n                return;\n            }\n            // Workaround for https://github.com/microsoft/TypeScript/issues/37160\n            if (isStrictNullChecks) {\n                const UNDEFINED = ts.TypeFlags.Undefined;\n                const NULL = ts.TypeFlags.Null;\n                const VOID = ts.TypeFlags.Void;\n                const isComparable = (type, flag) => {\n                    // Allow comparison to `any`, `unknown` or a naked type parameter.\n                    flag |=\n                        ts.TypeFlags.Any |\n                            ts.TypeFlags.Unknown |\n                            ts.TypeFlags.TypeParameter |\n                            ts.TypeFlags.TypeVariable;\n                    // Allow loose comparison to nullish values.\n                    if (operator === '==' || operator === '!=') {\n                        flag |= NULL | UNDEFINED | VOID;\n                    }\n                    return (0, util_1.isTypeFlagSet)(type, flag);\n                };\n                if ((leftType.flags === UNDEFINED &&\n                    !isComparable(rightType, UNDEFINED | VOID)) ||\n                    (rightType.flags === UNDEFINED &&\n                        !isComparable(leftType, UNDEFINED | VOID)) ||\n                    (leftType.flags === NULL && !isComparable(rightType, NULL)) ||\n                    (rightType.flags === NULL && !isComparable(leftType, NULL))) {\n                    context.report({ node, messageId: 'noOverlapBooleanExpression' });\n                    return;\n                }\n            }\n        }\n        /**\n         * Checks that a logical expression contains a boolean, reports otherwise.\n         */\n        function checkLogicalExpressionForUnnecessaryConditionals(node) {\n            if (node.operator === '??') {\n                checkNodeForNullish(node.left);\n                return;\n            }\n            // Only checks the left side, since the right side might not be \"conditional\" at all.\n            // The right side will be checked if the LogicalExpression is used in a conditional context\n            checkNode(node.left);\n        }\n        function checkIfWhileLoopIsNecessaryConditional(node) {\n            if (allowConstantLoopConditionsOption === 'only-allowed-literals' &&\n                node.test.type === utils_1.AST_NODE_TYPES.Literal &&\n                constantLoopConditionsAllowedLiterals.has(node.test.value)) {\n                return;\n            }\n            checkIfLoopIsNecessaryConditional(node);\n        }\n        /**\n         * Checks that a testable expression of a loop is necessarily conditional, reports otherwise.\n         */\n        function checkIfLoopIsNecessaryConditional(node) {\n            if (node.test == null) {\n                // e.g. `for(;;)`\n                return;\n            }\n            if (allowConstantLoopConditionsOption === 'always' &&\n                tsutils.isTrueLiteralType((0, util_1.getConstrainedTypeAtLocation)(services, node.test))) {\n                return;\n            }\n            checkNode(node.test);\n        }\n        function checkCallExpression(node) {\n            if (checkTypePredicates) {\n                const truthinessAssertedArgument = (0, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);\n                if (truthinessAssertedArgument != null) {\n                    checkNode(truthinessAssertedArgument);\n                }\n                const typeGuardAssertedArgument = (0, assertionFunctionUtils_1.findTypeGuardAssertedArgument)(services, node);\n                if (typeGuardAssertedArgument != null) {\n                    const typeOfArgument = (0, util_1.getConstrainedTypeAtLocation)(services, typeGuardAssertedArgument.argument);\n                    if (typeOfArgument === typeGuardAssertedArgument.type) {\n                        context.report({\n                            node: typeGuardAssertedArgument.argument,\n                            messageId: 'typeGuardAlreadyIsType',\n                            data: {\n                                typeGuardOrAssertionFunction: typeGuardAssertedArgument.asserts\n                                    ? 'assertion function'\n                                    : 'type guard',\n                            },\n                        });\n                    }\n                }\n            }\n            // If this is something like arr.filter(x => /*condition*/), check `condition`\n            if ((0, util_1.isArrayMethodCallWithPredicate)(context, services, node) &&\n                node.arguments.length) {\n                const callback = node.arguments[0];\n                // Inline defined functions\n                if (callback.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||\n                    callback.type === utils_1.AST_NODE_TYPES.FunctionExpression) {\n                    // Two special cases, where we can directly check the node that's returned:\n                    // () => something\n                    if (callback.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                        return checkNode(callback.body);\n                    }\n                    // () => { return something; }\n                    const callbackBody = callback.body.body;\n                    if (callbackBody.length === 1 &&\n                        callbackBody[0].type === utils_1.AST_NODE_TYPES.ReturnStatement &&\n                        callbackBody[0].argument) {\n                        return checkNode(callbackBody[0].argument);\n                    }\n                    // Potential enhancement: could use code-path analysis to check\n                    //   any function with a single return statement\n                    // (Value to complexity ratio is dubious however)\n                }\n                // Otherwise just do type analysis on the function as a whole.\n                const returnTypes = tsutils\n                    .getCallSignaturesOfType((0, util_1.getConstrainedTypeAtLocation)(services, callback))\n                    .map(sig => sig.getReturnType());\n                if (returnTypes.length === 0) {\n                    // Not a callable function, e.g. `any`\n                    return;\n                }\n                let hasFalsyReturnTypes = false;\n                let hasTruthyReturnTypes = false;\n                for (const type of returnTypes) {\n                    const { constraintType } = (0, util_1.getConstraintInfo)(checker, type);\n                    // Predicate is always necessary if it involves `any` or `unknown`\n                    if (!constraintType ||\n                        (0, util_1.isTypeAnyType)(constraintType) ||\n                        (0, util_1.isTypeUnknownType)(constraintType)) {\n                        return;\n                    }\n                    if ((0, util_1.isPossiblyFalsy)(constraintType)) {\n                        hasFalsyReturnTypes = true;\n                    }\n                    if ((0, util_1.isPossiblyTruthy)(constraintType)) {\n                        hasTruthyReturnTypes = true;\n                    }\n                    // bail early if both a possibly-truthy and a possibly-falsy have been detected\n                    if (hasFalsyReturnTypes && hasTruthyReturnTypes) {\n                        return;\n                    }\n                }\n                if (!hasFalsyReturnTypes) {\n                    return context.report({\n                        node: callback,\n                        messageId: 'alwaysTruthyFunc',\n                    });\n                }\n                if (!hasTruthyReturnTypes) {\n                    return context.report({\n                        node: callback,\n                        messageId: 'alwaysFalsyFunc',\n                    });\n                }\n            }\n        }\n        // Recursively searches an optional chain for an array index expression\n        //  Has to search the entire chain, because an array index will \"infect\" the rest of the types\n        //  Example:\n        //  ```\n        //  [{x: {y: \"z\"} }][n] // type is {x: {y: \"z\"}}\n        //    ?.x // type is {y: \"z\"}\n        //    ?.y // This access is considered \"unnecessary\" according to the types\n        //  ```\n        function optionChainContainsOptionArrayIndex(node) {\n            const lhsNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;\n            if (node.optional && isArrayIndexExpression(lhsNode)) {\n                return true;\n            }\n            if (lhsNode.type === utils_1.AST_NODE_TYPES.MemberExpression ||\n                lhsNode.type === utils_1.AST_NODE_TYPES.CallExpression) {\n                return optionChainContainsOptionArrayIndex(lhsNode);\n            }\n            return false;\n        }\n        function isNullablePropertyType(objType, propertyType) {\n            if (propertyType.isUnion()) {\n                return propertyType.types.some(type => isNullablePropertyType(objType, type));\n            }\n            if (propertyType.isNumberLiteral() || propertyType.isStringLiteral()) {\n                const propType = (0, util_1.getTypeOfPropertyOfName)(checker, objType, propertyType.value.toString());\n                if (propType) {\n                    return (0, util_1.isNullableType)(propType);\n                }\n            }\n            const typeName = (0, util_1.getTypeName)(checker, propertyType);\n            return checker\n                .getIndexInfosOfType(objType)\n                .some(info => (0, util_1.getTypeName)(checker, info.keyType) === typeName);\n        }\n        // Checks whether a member expression is nullable or not regardless of it's previous node.\n        //  Example:\n        //  ```\n        //  // 'bar' is nullable if 'foo' is null.\n        //  // but this function checks regardless of 'foo' type, so returns 'true'.\n        //  declare const foo: { bar : { baz: string } } | null\n        //  foo?.bar;\n        //  ```\n        function isMemberExpressionNullableOriginFromObject(node) {\n            const prevType = (0, util_1.getConstrainedTypeAtLocation)(services, node.object);\n            const property = node.property;\n            if (prevType.isUnion() && (0, util_1.isIdentifier)(property)) {\n                const isOwnNullable = prevType.types.some(type => {\n                    if (node.computed) {\n                        const propertyType = (0, util_1.getConstrainedTypeAtLocation)(services, node.property);\n                        return isNullablePropertyType(type, propertyType);\n                    }\n                    const propType = (0, util_1.getTypeOfPropertyOfName)(checker, type, property.name);\n                    if (propType) {\n                        return (0, util_1.isNullableType)(propType);\n                    }\n                    const indexInfo = checker.getIndexInfosOfType(type);\n                    return indexInfo.some(info => {\n                        const isStringTypeName = (0, util_1.getTypeName)(checker, info.keyType) === 'string';\n                        return (isStringTypeName &&\n                            (isNoUncheckedIndexedAccess || (0, util_1.isNullableType)(info.type)));\n                    });\n                });\n                return !isOwnNullable && (0, util_1.isNullableType)(prevType);\n            }\n            return false;\n        }\n        function isCallExpressionNullableOriginFromCallee(node) {\n            const prevType = (0, util_1.getConstrainedTypeAtLocation)(services, node.callee);\n            if (prevType.isUnion()) {\n                const isOwnNullable = prevType.types.some(type => {\n                    const signatures = type.getCallSignatures();\n                    return signatures.some(sig => (0, util_1.isNullableType)(sig.getReturnType()));\n                });\n                return !isOwnNullable && (0, util_1.isNullableType)(prevType);\n            }\n            return false;\n        }\n        function isOptionableExpression(node) {\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);\n            const isOwnNullable = node.type === utils_1.AST_NODE_TYPES.MemberExpression\n                ? !isMemberExpressionNullableOriginFromObject(node)\n                : node.type === utils_1.AST_NODE_TYPES.CallExpression\n                    ? !isCallExpressionNullableOriginFromCallee(node)\n                    : true;\n            return (isConditionalAlwaysNecessary(type) ||\n                (isOwnNullable && (0, util_1.isNullableType)(type)));\n        }\n        function checkOptionalChain(node, beforeOperator, fix) {\n            // We only care if this step in the chain is optional. If just descend\n            // from an optional chain, then that's fine.\n            if (!node.optional) {\n                return;\n            }\n            // Since typescript array index signature types don't represent the\n            //  possibility of out-of-bounds access, if we're indexing into an array\n            //  just skip the check, to avoid false positives\n            if (optionChainContainsOptionArrayIndex(node)) {\n                return;\n            }\n            const nodeToCheck = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node.object;\n            if (isOptionableExpression(nodeToCheck)) {\n                return;\n            }\n            const questionDotOperator = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(beforeOperator, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === '?.'), util_1.NullThrowsReasons.MissingToken('operator', node.type));\n            context.report({\n                loc: questionDotOperator.loc,\n                node,\n                messageId: 'neverOptionalChain',\n                fix(fixer) {\n                    return fixer.replaceText(questionDotOperator, fix);\n                },\n            });\n        }\n        function checkOptionalMemberExpression(node) {\n            checkOptionalChain(node, node.object, node.computed ? '' : '.');\n        }\n        function checkOptionalCallExpression(node) {\n            checkOptionalChain(node, node.callee, '');\n        }\n        function checkAssignmentExpression(node) {\n            // Similar to checkLogicalExpressionForUnnecessaryConditionals, since\n            // a ||= b is equivalent to a || (a = b)\n            if (['&&=', '||='].includes(node.operator)) {\n                checkNode(node.left);\n            }\n            else if (node.operator === '??=') {\n                checkNodeForNullish(node.left);\n            }\n        }\n        return {\n            AssignmentExpression: checkAssignmentExpression,\n            BinaryExpression(node) {\n                const { operator } = node;\n                if (isBoolOperator(operator)) {\n                    checkIfBoolExpressionIsNecessaryConditional(node, node.left, node.right, operator);\n                }\n            },\n            CallExpression: checkCallExpression,\n            'CallExpression[optional = true]': checkOptionalCallExpression,\n            ConditionalExpression: (node) => checkNode(node.test),\n            DoWhileStatement: checkIfLoopIsNecessaryConditional,\n            ForStatement: checkIfLoopIsNecessaryConditional,\n            IfStatement: (node) => checkNode(node.test),\n            LogicalExpression: checkLogicalExpressionForUnnecessaryConditionals,\n            'MemberExpression[optional = true]': checkOptionalMemberExpression,\n            SwitchCase({ parent, test }) {\n                // only check `case ...:`, not `default:`\n                if (test) {\n                    checkIfBoolExpressionIsNecessaryConditional(test, parent.discriminant, test, '===');\n                }\n            },\n            WhileStatement: checkIfWhileLoopIsNecessaryConditional,\n        };\n    },\n});\nfunction normalizeAllowConstantLoopConditions(allowConstantLoopConditions) {\n    if (allowConstantLoopConditions === true) {\n        return 'always';\n    }\n    if (allowConstantLoopConditions === false) {\n        return 'never';\n    }\n    return allowConstantLoopConditions;\n}\n"
        }
    ]
}