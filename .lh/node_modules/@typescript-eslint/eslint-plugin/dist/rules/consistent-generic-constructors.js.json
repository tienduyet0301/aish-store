{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/consistent-generic-constructors.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891960059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'consistent-generic-constructors',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce specifying generic type arguments on type annotation or constructor name of a constructor call',\n            recommended: 'stylistic',\n        },\n        fixable: 'code',\n        messages: {\n            preferConstructor: 'The generic type arguments should be specified as part of the constructor type arguments.',\n            preferTypeAnnotation: 'The generic type arguments should be specified as part of the type annotation.',\n        },\n        schema: [\n            {\n                type: 'string',\n                description: 'Which constructor call syntax to prefer.',\n                enum: ['type-annotation', 'constructor'],\n            },\n        ],\n    },\n    defaultOptions: ['constructor'],\n    create(context, [mode]) {\n        return {\n            'VariableDeclarator,PropertyDefinition,AccessorProperty,:matches(FunctionDeclaration,FunctionExpression) > AssignmentPattern'(node) {\n                function getLHSRHS() {\n                    switch (node.type) {\n                        case utils_1.AST_NODE_TYPES.VariableDeclarator:\n                            return [node.id, node.init];\n                        case utils_1.AST_NODE_TYPES.PropertyDefinition:\n                        case utils_1.AST_NODE_TYPES.AccessorProperty:\n                            return [node, node.value];\n                        case utils_1.AST_NODE_TYPES.AssignmentPattern:\n                            return [node.left, node.right];\n                        default:\n                            throw new Error(`Unhandled node type: ${node.type}`);\n                    }\n                }\n                const [lhsName, rhs] = getLHSRHS();\n                const lhs = lhsName.typeAnnotation?.typeAnnotation;\n                if (!rhs ||\n                    rhs.type !== utils_1.AST_NODE_TYPES.NewExpression ||\n                    rhs.callee.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                    return;\n                }\n                if (lhs &&\n                    (lhs.type !== utils_1.AST_NODE_TYPES.TSTypeReference ||\n                        lhs.typeName.type !== utils_1.AST_NODE_TYPES.Identifier ||\n                        lhs.typeName.name !== rhs.callee.name)) {\n                    return;\n                }\n                if (mode === 'type-annotation') {\n                    if (!lhs && rhs.typeArguments) {\n                        const { callee, typeArguments } = rhs;\n                        const typeAnnotation = context.sourceCode.getText(callee) +\n                            context.sourceCode.getText(typeArguments);\n                        context.report({\n                            node,\n                            messageId: 'preferTypeAnnotation',\n                            fix(fixer) {\n                                function getIDToAttachAnnotation() {\n                                    if (node.type !== utils_1.AST_NODE_TYPES.PropertyDefinition &&\n                                        node.type !== utils_1.AST_NODE_TYPES.AccessorProperty) {\n                                        return lhsName;\n                                    }\n                                    if (!node.computed) {\n                                        return node.key;\n                                    }\n                                    // If the property's computed, we have to attach the\n                                    // annotation after the square bracket, not the enclosed expression\n                                    return (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.key), util_1.NullThrowsReasons.MissingToken(']', 'key'));\n                                }\n                                return [\n                                    fixer.remove(typeArguments),\n                                    fixer.insertTextAfter(getIDToAttachAnnotation(), `: ${typeAnnotation}`),\n                                ];\n                            },\n                        });\n                    }\n                    return;\n                }\n                if (lhs?.typeArguments && !rhs.typeArguments) {\n                    const hasParens = context.sourceCode.getTokenAfter(rhs.callee)?.value === '(';\n                    const extraComments = new Set(context.sourceCode.getCommentsInside(lhs.parent));\n                    context.sourceCode\n                        .getCommentsInside(lhs.typeArguments)\n                        .forEach(c => extraComments.delete(c));\n                    context.report({\n                        node,\n                        messageId: 'preferConstructor',\n                        *fix(fixer) {\n                            yield fixer.remove(lhs.parent);\n                            for (const comment of extraComments) {\n                                yield fixer.insertTextAfter(rhs.callee, context.sourceCode.getText(comment));\n                            }\n                            yield fixer.insertTextAfter(rhs.callee, context.sourceCode.getText(lhs.typeArguments));\n                            if (!hasParens) {\n                                yield fixer.insertTextAfter(rhs.callee, '()');\n                            }\n                        },\n                    });\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}