{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/require-array-sort-compare.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891974736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'require-array-sort-compare',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Require `Array#sort` and `Array#toSorted` calls to always provide a `compareFunction`',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            requireCompare: \"Require 'compare' argument.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ignoreStringArrays: {\n                        type: 'boolean',\n                        description: 'Whether to ignore arrays in which all elements are strings.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            ignoreStringArrays: true,\n        },\n    ],\n    create(context, [options]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        /**\n         * Check if a given node is an array which all elements are string.\n         */\n        function isStringArrayNode(node) {\n            const type = services.getTypeAtLocation(node);\n            if (checker.isArrayType(type) || checker.isTupleType(type)) {\n                const typeArgs = checker.getTypeArguments(type);\n                return typeArgs.every(arg => (0, util_1.getTypeName)(checker, arg) === 'string');\n            }\n            return false;\n        }\n        function checkSortArgument(callee) {\n            if (!(0, util_1.isStaticMemberAccessOfValue)(callee, context, 'sort', 'toSorted')) {\n                return;\n            }\n            const calleeObjType = (0, util_1.getConstrainedTypeAtLocation)(services, callee.object);\n            if (options.ignoreStringArrays && isStringArrayNode(callee.object)) {\n                return;\n            }\n            if ((0, util_1.isTypeArrayTypeOrUnionOfArrayTypes)(calleeObjType, checker)) {\n                context.report({ node: callee.parent, messageId: 'requireCompare' });\n            }\n        }\n        return {\n            'CallExpression[arguments.length=0] > MemberExpression': checkSortArgument,\n        };\n    },\n});\n"
        }
    ]
}