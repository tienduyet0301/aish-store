{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-loop-func.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891966071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-loop-func');\nexports.default = (0, util_1.createRule)({\n    name: 'no-loop-func',\n    meta: {\n        type: 'suggestion',\n        // defaultOptions, -- base rule does not use defaultOptions\n        docs: {\n            description: 'Disallow function declarations that contain unsafe references inside loop statements',\n            extendsBaseRule: true,\n        },\n        hasSuggestions: baseRule.meta.hasSuggestions,\n        messages: baseRule.meta.messages,\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const SKIPPED_IIFE_NODES = new Set();\n        /**\n         * Gets the containing loop node of a specified node.\n         *\n         * We don't need to check nested functions, so this ignores those.\n         * `Scope.through` contains references of nested functions.\n         *\n         * @param node An AST node to get.\n         * @returns The containing loop node of the specified node, or `null`.\n         */\n        function getContainingLoopNode(node) {\n            for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n                const parent = currentNode.parent;\n                switch (parent.type) {\n                    case utils_1.AST_NODE_TYPES.WhileStatement:\n                    case utils_1.AST_NODE_TYPES.DoWhileStatement:\n                        return parent;\n                    case utils_1.AST_NODE_TYPES.ForStatement:\n                        // `init` is outside of the loop.\n                        if (parent.init !== currentNode) {\n                            return parent;\n                        }\n                        break;\n                    case utils_1.AST_NODE_TYPES.ForInStatement:\n                    case utils_1.AST_NODE_TYPES.ForOfStatement:\n                        // `right` is outside of the loop.\n                        if (parent.right !== currentNode) {\n                            return parent;\n                        }\n                        break;\n                    case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n                    case utils_1.AST_NODE_TYPES.FunctionExpression:\n                    case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n                        // We don't need to check nested functions.\n                        // We need to check nested functions only in case of IIFE.\n                        if (SKIPPED_IIFE_NODES.has(parent)) {\n                            break;\n                        }\n                        return null;\n                    default:\n                        break;\n                }\n            }\n            return null;\n        }\n        /**\n         * Gets the containing loop node of a given node.\n         * If the loop was nested, this returns the most outer loop.\n         * @param node A node to get. This is a loop node.\n         * @param excludedNode A node that the result node should not include.\n         * @returns The most outer loop node.\n         */\n        function getTopLoopNode(node, excludedNode) {\n            const border = excludedNode ? excludedNode.range[1] : 0;\n            let retv = node;\n            let containingLoopNode = node;\n            while (containingLoopNode && containingLoopNode.range[0] >= border) {\n                retv = containingLoopNode;\n                containingLoopNode = getContainingLoopNode(containingLoopNode);\n            }\n            return retv;\n        }\n        /**\n         * Checks whether a given reference which refers to an upper scope's variable is\n         * safe or not.\n         * @param loopNode A containing loop node.\n         * @param reference A reference to check.\n         * @returns `true` if the reference is safe or not.\n         */\n        function isSafe(loopNode, reference) {\n            const variable = reference.resolved;\n            const definition = variable?.defs[0];\n            const declaration = definition?.parent;\n            const kind = declaration?.type === utils_1.AST_NODE_TYPES.VariableDeclaration\n                ? declaration.kind\n                : '';\n            // type references are all safe\n            // this only really matters for global types that haven't been configured\n            if (reference.isTypeReference) {\n                return true;\n            }\n            // Variables which are declared by `const` is safe.\n            if (kind === 'const') {\n                return true;\n            }\n            /*\n             * Variables which are declared by `let` in the loop is safe.\n             * It's a different instance from the next loop step's.\n             */\n            if (kind === 'let' &&\n                declaration &&\n                declaration.range[0] > loopNode.range[0] &&\n                declaration.range[1] < loopNode.range[1]) {\n                return true;\n            }\n            /*\n             * WriteReferences which exist after this border are unsafe because those\n             * can modify the variable.\n             */\n            const border = getTopLoopNode(loopNode, kind === 'let' ? declaration : null).range[0];\n            /**\n             * Checks whether a given reference is safe or not.\n             * The reference is every reference of the upper scope's variable we are\n             * looking now.\n             *\n             * It's safe if the reference matches one of the following condition.\n             * - is readonly.\n             * - doesn't exist inside a local function and after the border.\n             *\n             * @param upperRef A reference to check.\n             * @returns `true` if the reference is safe.\n             */\n            function isSafeReference(upperRef) {\n                const id = upperRef.identifier;\n                return (!upperRef.isWrite() ||\n                    (variable?.scope.variableScope === upperRef.from.variableScope &&\n                        id.range[0] < border));\n            }\n            return variable?.references.every(isSafeReference) ?? false;\n        }\n        /**\n         * Reports functions which match the following condition:\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         *\n         * @param node The AST node to check.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n            if (!loopNode) {\n                return;\n            }\n            const references = context.sourceCode.getScope(node).through;\n            if (!(node.async || node.generator) && isIIFE(node)) {\n                const isFunctionExpression = node.type === utils_1.AST_NODE_TYPES.FunctionExpression;\n                // Check if the function is referenced elsewhere in the code\n                const isFunctionReferenced = isFunctionExpression && node.id\n                    ? references.some(r => r.identifier.name === node.id?.name)\n                    : false;\n                if (!isFunctionReferenced) {\n                    SKIPPED_IIFE_NODES.add(node);\n                    return;\n                }\n            }\n            const unsafeRefs = references\n                .filter(r => r.resolved && !isSafe(loopNode, r))\n                .map(r => r.identifier.name);\n            if (unsafeRefs.length > 0) {\n                context.report({\n                    node,\n                    messageId: 'unsafeRefs',\n                    data: { varNames: `'${unsafeRefs.join(\"', '\")}'` },\n                });\n            }\n        }\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops,\n            FunctionExpression: checkForLoops,\n        };\n    },\n});\nfunction isIIFE(node) {\n    return (node.parent.type === utils_1.AST_NODE_TYPES.CallExpression &&\n        node.parent.callee === node);\n}\n"
        }
    ]
}