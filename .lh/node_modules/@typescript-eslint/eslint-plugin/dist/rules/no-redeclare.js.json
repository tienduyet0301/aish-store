{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-redeclare.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891967936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-redeclare',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow variable redeclaration',\n            extendsBaseRule: true,\n        },\n        messages: {\n            redeclared: \"'{{id}}' is already defined.\",\n            redeclaredAsBuiltin: \"'{{id}}' is already defined as a built-in global variable.\",\n            redeclaredBySyntax: \"'{{id}}' is already defined by a variable declaration.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    builtinGlobals: {\n                        type: 'boolean',\n                        description: 'Whether to report shadowing of built-in global variables.',\n                    },\n                    ignoreDeclarationMerge: {\n                        type: 'boolean',\n                        description: 'Whether to ignore declaration merges between certain TypeScript declaration types.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            builtinGlobals: true,\n            ignoreDeclarationMerge: true,\n        },\n    ],\n    create(context, [options]) {\n        const CLASS_DECLARATION_MERGE_NODES = new Set([\n            utils_1.AST_NODE_TYPES.ClassDeclaration,\n            utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n            utils_1.AST_NODE_TYPES.TSModuleDeclaration,\n        ]);\n        const FUNCTION_DECLARATION_MERGE_NODES = new Set([\n            utils_1.AST_NODE_TYPES.FunctionDeclaration,\n            utils_1.AST_NODE_TYPES.TSModuleDeclaration,\n        ]);\n        const ENUM_DECLARATION_MERGE_NODES = new Set([\n            utils_1.AST_NODE_TYPES.TSEnumDeclaration,\n            utils_1.AST_NODE_TYPES.TSModuleDeclaration,\n        ]);\n        function* iterateDeclarations(variable) {\n            if (options.builtinGlobals &&\n                'eslintImplicitGlobalSetting' in variable &&\n                (variable.eslintImplicitGlobalSetting === 'readonly' ||\n                    variable.eslintImplicitGlobalSetting === 'writable')) {\n                yield { type: 'builtin' };\n            }\n            if ('eslintExplicitGlobalComments' in variable &&\n                variable.eslintExplicitGlobalComments) {\n                for (const comment of variable.eslintExplicitGlobalComments) {\n                    yield {\n                        loc: (0, util_1.getNameLocationInGlobalDirectiveComment)(context.sourceCode, comment, variable.name),\n                        node: comment,\n                        type: 'comment',\n                    };\n                }\n            }\n            const identifiers = variable.identifiers\n                .map(id => ({\n                identifier: id,\n                parent: id.parent,\n            }))\n                // ignore function declarations because TS will treat them as an overload\n                .filter(({ parent }) => parent.type !== utils_1.AST_NODE_TYPES.TSDeclareFunction);\n            if (options.ignoreDeclarationMerge && identifiers.length > 1) {\n                if (\n                // interfaces merging\n                identifiers.every(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration)) {\n                    return;\n                }\n                if (\n                // namespace/module merging\n                identifiers.every(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration)) {\n                    return;\n                }\n                if (\n                // class + interface/namespace merging\n                identifiers.every(({ parent }) => CLASS_DECLARATION_MERGE_NODES.has(parent.type))) {\n                    const classDecls = identifiers.filter(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration);\n                    if (classDecls.length === 1) {\n                        // safe declaration merging\n                        return;\n                    }\n                    // there's more than one class declaration, which needs to be reported\n                    for (const { identifier } of classDecls) {\n                        yield { loc: identifier.loc, node: identifier, type: 'syntax' };\n                    }\n                    return;\n                }\n                if (\n                // class + interface/namespace merging\n                identifiers.every(({ parent }) => FUNCTION_DECLARATION_MERGE_NODES.has(parent.type))) {\n                    const functionDecls = identifiers.filter(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.FunctionDeclaration);\n                    if (functionDecls.length === 1) {\n                        // safe declaration merging\n                        return;\n                    }\n                    // there's more than one function declaration, which needs to be reported\n                    for (const { identifier } of functionDecls) {\n                        yield { loc: identifier.loc, node: identifier, type: 'syntax' };\n                    }\n                    return;\n                }\n                if (\n                // enum + namespace merging\n                identifiers.every(({ parent }) => ENUM_DECLARATION_MERGE_NODES.has(parent.type))) {\n                    const enumDecls = identifiers.filter(({ parent }) => parent.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration);\n                    if (enumDecls.length === 1) {\n                        // safe declaration merging\n                        return;\n                    }\n                    // there's more than one enum declaration, which needs to be reported\n                    for (const { identifier } of enumDecls) {\n                        yield { loc: identifier.loc, node: identifier, type: 'syntax' };\n                    }\n                    return;\n                }\n            }\n            for (const { identifier } of identifiers) {\n                yield { loc: identifier.loc, node: identifier, type: 'syntax' };\n            }\n        }\n        function findVariablesInScope(scope) {\n            for (const variable of scope.variables) {\n                const [declaration, ...extraDeclarations] = iterateDeclarations(variable);\n                if (extraDeclarations.length === 0) {\n                    continue;\n                }\n                /*\n                 * If the type of a declaration is different from the type of\n                 * the first declaration, it shows the location of the first\n                 * declaration.\n                 */\n                const detailMessageId = declaration.type === 'builtin'\n                    ? 'redeclaredAsBuiltin'\n                    : 'redeclaredBySyntax';\n                const data = { id: variable.name };\n                // Report extra declarations.\n                for (const { loc, node, type } of extraDeclarations) {\n                    const messageId = type === declaration.type ? 'redeclared' : detailMessageId;\n                    if (node) {\n                        context.report({ loc, node, messageId, data });\n                    }\n                    else if (loc) {\n                        context.report({ loc, messageId, data });\n                    }\n                }\n            }\n        }\n        /**\n         * Find variables in the current scope.\n         */\n        function checkForBlock(node) {\n            const scope = context.sourceCode.getScope(node);\n            /*\n             * In ES5, some node type such as `BlockStatement` doesn't have that scope.\n             * `scope.block` is a different node in such a case.\n             */\n            if (scope.block === node) {\n                findVariablesInScope(scope);\n            }\n        }\n        return {\n            ArrowFunctionExpression: checkForBlock,\n            BlockStatement: checkForBlock,\n            ForInStatement: checkForBlock,\n            ForOfStatement: checkForBlock,\n            ForStatement: checkForBlock,\n            FunctionDeclaration: checkForBlock,\n            FunctionExpression: checkForBlock,\n            Program(node) {\n                const scope = context.sourceCode.getScope(node);\n                findVariablesInScope(scope);\n                // Node.js or ES modules has a special scope.\n                if (scope.type === scope_manager_1.ScopeType.global &&\n                    scope.childScopes[0] &&\n                    // The special scope's block is the Program node.\n                    scope.block === scope.childScopes[0].block) {\n                    findVariablesInScope(scope.childScopes[0]);\n                }\n            },\n            SwitchStatement: checkForBlock,\n        };\n    },\n});\n"
        }
    ]
}