{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/typedef.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OptionKeys = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nvar OptionKeys;\n(function (OptionKeys) {\n    OptionKeys[\"ArrayDestructuring\"] = \"arrayDestructuring\";\n    OptionKeys[\"ArrowParameter\"] = \"arrowParameter\";\n    OptionKeys[\"MemberVariableDeclaration\"] = \"memberVariableDeclaration\";\n    OptionKeys[\"ObjectDestructuring\"] = \"objectDestructuring\";\n    OptionKeys[\"Parameter\"] = \"parameter\";\n    OptionKeys[\"PropertyDeclaration\"] = \"propertyDeclaration\";\n    OptionKeys[\"VariableDeclaration\"] = \"variableDeclaration\";\n    OptionKeys[\"VariableDeclarationIgnoreFunction\"] = \"variableDeclarationIgnoreFunction\";\n})(OptionKeys || (exports.OptionKeys = OptionKeys = {}));\nexports.default = (0, util_1.createRule)({\n    name: 'typedef',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require type annotations in certain places',\n        },\n        messages: {\n            expectedTypedef: 'Expected a type annotation.',\n            expectedTypedefNamed: 'Expected {{name}} to have a type annotation.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    [OptionKeys.ArrayDestructuring]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations on variables declared using array destructuring.',\n                    },\n                    [OptionKeys.ArrowParameter]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations for parameters of arrow functions.',\n                    },\n                    [OptionKeys.MemberVariableDeclaration]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations on member variables of classes.',\n                    },\n                    [OptionKeys.ObjectDestructuring]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations on variables declared using object destructuring.',\n                    },\n                    [OptionKeys.Parameter]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations for parameters of functions and methods.',\n                    },\n                    [OptionKeys.PropertyDeclaration]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations for properties of interfaces and types.',\n                    },\n                    [OptionKeys.VariableDeclaration]: {\n                        type: 'boolean',\n                        description: 'Whether to enforce type annotations for variable declarations, excluding array and object destructuring.',\n                    },\n                    [OptionKeys.VariableDeclarationIgnoreFunction]: {\n                        type: 'boolean',\n                        description: 'Whether to ignore variable declarations for non-arrow and arrow functions.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            [OptionKeys.ArrayDestructuring]: false,\n            [OptionKeys.ArrowParameter]: false,\n            [OptionKeys.MemberVariableDeclaration]: false,\n            [OptionKeys.ObjectDestructuring]: false,\n            [OptionKeys.Parameter]: false,\n            [OptionKeys.PropertyDeclaration]: false,\n            [OptionKeys.VariableDeclaration]: false,\n            [OptionKeys.VariableDeclarationIgnoreFunction]: false,\n        },\n    ],\n    create(context, [{ arrayDestructuring, arrowParameter, memberVariableDeclaration, objectDestructuring, parameter, propertyDeclaration, variableDeclaration, variableDeclarationIgnoreFunction, },]) {\n        function report(location, name) {\n            context.report({\n                node: location,\n                messageId: name ? 'expectedTypedefNamed' : 'expectedTypedef',\n                data: { name },\n            });\n        }\n        function getNodeName(node) {\n            return node.type === utils_1.AST_NODE_TYPES.Identifier ? node.name : undefined;\n        }\n        function isForOfStatementContext(node) {\n            let current = node.parent;\n            while (current) {\n                switch (current.type) {\n                    case utils_1.AST_NODE_TYPES.VariableDeclarator:\n                    case utils_1.AST_NODE_TYPES.VariableDeclaration:\n                    case utils_1.AST_NODE_TYPES.ObjectPattern:\n                    case utils_1.AST_NODE_TYPES.ArrayPattern:\n                    case utils_1.AST_NODE_TYPES.Property:\n                        current = current.parent;\n                        break;\n                    case utils_1.AST_NODE_TYPES.ForOfStatement:\n                        return true;\n                    default:\n                        current = undefined;\n                }\n            }\n            return false;\n        }\n        function checkParameters(params) {\n            for (const param of params) {\n                let annotationNode;\n                switch (param.type) {\n                    case utils_1.AST_NODE_TYPES.AssignmentPattern:\n                        annotationNode = param.left;\n                        break;\n                    case utils_1.AST_NODE_TYPES.TSParameterProperty:\n                        annotationNode = param.parameter;\n                        // Check TS parameter property with default value like `constructor(private param: string = 'something') {}`\n                        if (annotationNode.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n                            annotationNode = annotationNode.left;\n                        }\n                        break;\n                    default:\n                        annotationNode = param;\n                        break;\n                }\n                if (!annotationNode.typeAnnotation) {\n                    report(param, getNodeName(param));\n                }\n            }\n        }\n        function isVariableDeclarationIgnoreFunction(node) {\n            return (variableDeclarationIgnoreFunction === true &&\n                (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||\n                    node.type === utils_1.AST_NODE_TYPES.FunctionExpression));\n        }\n        function isAncestorHasTypeAnnotation(node) {\n            let ancestor = node.parent;\n            while (ancestor) {\n                if ((ancestor.type === utils_1.AST_NODE_TYPES.ObjectPattern ||\n                    ancestor.type === utils_1.AST_NODE_TYPES.ArrayPattern) &&\n                    ancestor.typeAnnotation) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n        return {\n            ...(arrayDestructuring && {\n                ArrayPattern(node) {\n                    if (node.parent.type === utils_1.AST_NODE_TYPES.RestElement &&\n                        node.parent.typeAnnotation) {\n                        return;\n                    }\n                    if (!node.typeAnnotation &&\n                        !isForOfStatementContext(node) &&\n                        !isAncestorHasTypeAnnotation(node) &&\n                        node.parent.type !== utils_1.AST_NODE_TYPES.AssignmentExpression) {\n                        report(node);\n                    }\n                },\n            }),\n            ...(arrowParameter && {\n                ArrowFunctionExpression(node) {\n                    checkParameters(node.params);\n                },\n            }),\n            ...(memberVariableDeclaration && {\n                PropertyDefinition(node) {\n                    if (!(node.value && isVariableDeclarationIgnoreFunction(node.value)) &&\n                        !node.typeAnnotation) {\n                        report(node, node.key.type === utils_1.AST_NODE_TYPES.Identifier\n                            ? node.key.name\n                            : undefined);\n                    }\n                },\n            }),\n            ...(parameter && {\n                'FunctionDeclaration, FunctionExpression'(node) {\n                    checkParameters(node.params);\n                },\n            }),\n            ...(objectDestructuring && {\n                ObjectPattern(node) {\n                    if (!node.typeAnnotation &&\n                        !isForOfStatementContext(node) &&\n                        !isAncestorHasTypeAnnotation(node)) {\n                        report(node);\n                    }\n                },\n            }),\n            ...(propertyDeclaration && {\n                'TSIndexSignature, TSPropertySignature'(node) {\n                    if (!node.typeAnnotation) {\n                        report(node, node.type === utils_1.AST_NODE_TYPES.TSPropertySignature\n                            ? getNodeName(node.key)\n                            : undefined);\n                    }\n                },\n            }),\n            VariableDeclarator(node) {\n                if (!variableDeclaration ||\n                    node.id.typeAnnotation ||\n                    (node.id.type === utils_1.AST_NODE_TYPES.ArrayPattern &&\n                        !arrayDestructuring) ||\n                    (node.id.type === utils_1.AST_NODE_TYPES.ObjectPattern &&\n                        !objectDestructuring) ||\n                    (node.init && isVariableDeclarationIgnoreFunction(node.init))) {\n                    return;\n                }\n                let current = node.parent;\n                while (current) {\n                    switch (current.type) {\n                        case utils_1.AST_NODE_TYPES.VariableDeclaration:\n                            // Keep looking upwards\n                            current = current.parent;\n                            break;\n                        case utils_1.AST_NODE_TYPES.ForOfStatement:\n                        case utils_1.AST_NODE_TYPES.ForInStatement:\n                            // Stop traversing and don't report an error\n                            return;\n                        default:\n                            // Stop traversing\n                            current = undefined;\n                            break;\n                    }\n                }\n                report(node, getNodeName(node.id));\n            },\n        };\n    },\n});\n"
        }
    ]
}