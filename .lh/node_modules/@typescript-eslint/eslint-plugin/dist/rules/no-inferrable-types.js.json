{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-inferrable-types.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891965618,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-inferrable-types',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow explicit type declarations for variables or parameters initialized to a number, string, or boolean',\n            recommended: 'stylistic',\n        },\n        fixable: 'code',\n        messages: {\n            noInferrableType: 'Type {{type}} trivially inferred from a {{type}} literal, remove type annotation.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ignoreParameters: {\n                        type: 'boolean',\n                        description: 'Whether to ignore function parameters.',\n                    },\n                    ignoreProperties: {\n                        type: 'boolean',\n                        description: 'Whether to ignore class properties.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            ignoreParameters: false,\n            ignoreProperties: false,\n        },\n    ],\n    create(context, [{ ignoreParameters, ignoreProperties }]) {\n        function isFunctionCall(init, callName) {\n            const node = (0, util_1.skipChainExpression)(init);\n            return (node.type === utils_1.AST_NODE_TYPES.CallExpression &&\n                node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&\n                node.callee.name === callName);\n        }\n        function isLiteral(init, typeName) {\n            return (init.type === utils_1.AST_NODE_TYPES.Literal && typeof init.value === typeName);\n        }\n        function isIdentifier(init, ...names) {\n            return (init.type === utils_1.AST_NODE_TYPES.Identifier && names.includes(init.name));\n        }\n        function hasUnaryPrefix(init, ...operators) {\n            return (init.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                operators.includes(init.operator));\n        }\n        const keywordMap = {\n            [utils_1.AST_NODE_TYPES.TSBigIntKeyword]: 'bigint',\n            [utils_1.AST_NODE_TYPES.TSBooleanKeyword]: 'boolean',\n            [utils_1.AST_NODE_TYPES.TSNullKeyword]: 'null',\n            [utils_1.AST_NODE_TYPES.TSNumberKeyword]: 'number',\n            [utils_1.AST_NODE_TYPES.TSStringKeyword]: 'string',\n            [utils_1.AST_NODE_TYPES.TSSymbolKeyword]: 'symbol',\n            [utils_1.AST_NODE_TYPES.TSUndefinedKeyword]: 'undefined',\n        };\n        /**\n         * Returns whether a node has an inferrable value or not\n         */\n        function isInferrable(annotation, init) {\n            switch (annotation.type) {\n                case utils_1.AST_NODE_TYPES.TSBigIntKeyword: {\n                    // note that bigint cannot have + prefixed to it\n                    const unwrappedInit = hasUnaryPrefix(init, '-')\n                        ? init.argument\n                        : init;\n                    return (isFunctionCall(unwrappedInit, 'BigInt') ||\n                        unwrappedInit.type === utils_1.AST_NODE_TYPES.Literal);\n                }\n                case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n                    return (hasUnaryPrefix(init, '!') ||\n                        isFunctionCall(init, 'Boolean') ||\n                        isLiteral(init, 'boolean'));\n                case utils_1.AST_NODE_TYPES.TSNumberKeyword: {\n                    const unwrappedInit = hasUnaryPrefix(init, '+', '-')\n                        ? init.argument\n                        : init;\n                    return (isIdentifier(unwrappedInit, 'Infinity', 'NaN') ||\n                        isFunctionCall(unwrappedInit, 'Number') ||\n                        isLiteral(unwrappedInit, 'number'));\n                }\n                case utils_1.AST_NODE_TYPES.TSNullKeyword:\n                    return init.type === utils_1.AST_NODE_TYPES.Literal && init.value == null;\n                case utils_1.AST_NODE_TYPES.TSStringKeyword:\n                    return (isFunctionCall(init, 'String') ||\n                        isLiteral(init, 'string') ||\n                        init.type === utils_1.AST_NODE_TYPES.TemplateLiteral);\n                case utils_1.AST_NODE_TYPES.TSSymbolKeyword:\n                    return isFunctionCall(init, 'Symbol');\n                case utils_1.AST_NODE_TYPES.TSTypeReference: {\n                    if (annotation.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&\n                        annotation.typeName.name === 'RegExp') {\n                        const isRegExpLiteral = init.type === utils_1.AST_NODE_TYPES.Literal &&\n                            init.value instanceof RegExp;\n                        const isRegExpNewCall = init.type === utils_1.AST_NODE_TYPES.NewExpression &&\n                            init.callee.type === utils_1.AST_NODE_TYPES.Identifier &&\n                            init.callee.name === 'RegExp';\n                        const isRegExpCall = isFunctionCall(init, 'RegExp');\n                        return isRegExpLiteral || isRegExpCall || isRegExpNewCall;\n                    }\n                    return false;\n                }\n                case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:\n                    return (hasUnaryPrefix(init, 'void') || isIdentifier(init, 'undefined'));\n            }\n            return false;\n        }\n        /**\n         * Reports an inferrable type declaration, if any\n         */\n        function reportInferrableType(node, typeNode, initNode) {\n            if (!typeNode || !initNode) {\n                return;\n            }\n            if (!isInferrable(typeNode.typeAnnotation, initNode)) {\n                return;\n            }\n            const type = typeNode.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference\n                ? // TODO - if we add more references\n                    'RegExp'\n                : keywordMap[typeNode.typeAnnotation.type];\n            context.report({\n                node,\n                messageId: 'noInferrableType',\n                data: {\n                    type,\n                },\n                *fix(fixer) {\n                    if ((node.type === utils_1.AST_NODE_TYPES.AssignmentPattern &&\n                        node.left.optional) ||\n                        (node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && node.definite)) {\n                        yield fixer.remove((0, util_1.nullThrows)(context.sourceCode.getTokenBefore(typeNode), util_1.NullThrowsReasons.MissingToken('token before', 'type node')));\n                    }\n                    yield fixer.remove(typeNode);\n                },\n            });\n        }\n        function inferrableVariableVisitor(node) {\n            reportInferrableType(node, node.id.typeAnnotation, node.init);\n        }\n        function inferrableParameterVisitor(node) {\n            if (ignoreParameters) {\n                return;\n            }\n            node.params.forEach(param => {\n                if (param.type === utils_1.AST_NODE_TYPES.TSParameterProperty) {\n                    param = param.parameter;\n                }\n                if (param.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n                    reportInferrableType(param, param.left.typeAnnotation, param.right);\n                }\n            });\n        }\n        function inferrablePropertyVisitor(node) {\n            // We ignore `readonly` because of Microsoft/TypeScript#14416\n            // Essentially a readonly property without a type\n            // will result in its value being the type, leading to\n            // compile errors if the type is stripped.\n            if (ignoreProperties || node.readonly || node.optional) {\n                return;\n            }\n            reportInferrableType(node, node.typeAnnotation, node.value);\n        }\n        return {\n            AccessorProperty: inferrablePropertyVisitor,\n            ArrowFunctionExpression: inferrableParameterVisitor,\n            FunctionDeclaration: inferrableParameterVisitor,\n            FunctionExpression: inferrableParameterVisitor,\n            PropertyDefinition: inferrablePropertyVisitor,\n            VariableDeclarator: inferrableVariableVisitor,\n        };\n    },\n});\n"
        }
    ]
}