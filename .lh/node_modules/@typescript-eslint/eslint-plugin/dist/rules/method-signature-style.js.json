{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/method-signature-style.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891961975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'method-signature-style',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce using a particular method signature syntax',\n        },\n        fixable: 'code',\n        messages: {\n            errorMethod: 'Shorthand method signature is forbidden. Use a function property instead.',\n            errorProperty: 'Function property signature is forbidden. Use a method shorthand instead.',\n        },\n        schema: [\n            {\n                type: 'string',\n                enum: ['property', 'method'],\n            },\n        ],\n    },\n    defaultOptions: ['property'],\n    create(context, [mode]) {\n        function getMethodKey(node) {\n            let key = context.sourceCode.getText(node.key);\n            if (node.computed) {\n                key = `[${key}]`;\n            }\n            if (node.optional) {\n                key = `${key}?`;\n            }\n            if (node.readonly) {\n                key = `readonly ${key}`;\n            }\n            return key;\n        }\n        function getMethodParams(node) {\n            let params = '()';\n            if (node.params.length > 0) {\n                const openingParen = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.params[0], util_1.isOpeningParenToken), 'Missing opening paren before first parameter');\n                const closingParen = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.params[node.params.length - 1], util_1.isClosingParenToken), 'Missing closing paren after last parameter');\n                params = context.sourceCode.text.substring(openingParen.range[0], closingParen.range[1]);\n            }\n            if (node.typeParameters != null) {\n                const typeParams = context.sourceCode.getText(node.typeParameters);\n                params = `${typeParams}${params}`;\n            }\n            return params;\n        }\n        function getMethodReturnType(node) {\n            return node.returnType == null\n                ? // if the method has no return type, it implicitly has an `any` return type\n                    // we just make it explicit here so we can do the fix\n                    'any'\n                : context.sourceCode.getText(node.returnType.typeAnnotation);\n        }\n        function getDelimiter(node) {\n            const lastToken = context.sourceCode.getLastToken(node);\n            if (lastToken &&\n                ((0, util_1.isSemicolonToken)(lastToken) || (0, util_1.isCommaToken)(lastToken))) {\n                return lastToken.value;\n            }\n            return '';\n        }\n        function isNodeParentModuleDeclaration(node) {\n            if (!node.parent) {\n                return false;\n            }\n            if (node.parent.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {\n                return true;\n            }\n            if (node.parent.type === utils_1.AST_NODE_TYPES.Program) {\n                return false;\n            }\n            return isNodeParentModuleDeclaration(node.parent);\n        }\n        return {\n            ...(mode === 'property' && {\n                TSMethodSignature(methodNode) {\n                    if (methodNode.kind !== 'method') {\n                        return;\n                    }\n                    const parent = methodNode.parent;\n                    const members = parent.type === utils_1.AST_NODE_TYPES.TSInterfaceBody\n                        ? parent.body\n                        : parent.members;\n                    const duplicatedKeyMethodNodes = members.filter((element) => element.type === utils_1.AST_NODE_TYPES.TSMethodSignature &&\n                        element !== methodNode &&\n                        getMethodKey(element) === getMethodKey(methodNode));\n                    const isParentModule = isNodeParentModuleDeclaration(methodNode);\n                    if (duplicatedKeyMethodNodes.length > 0) {\n                        if (isParentModule) {\n                            context.report({\n                                node: methodNode,\n                                messageId: 'errorMethod',\n                            });\n                        }\n                        else {\n                            context.report({\n                                node: methodNode,\n                                messageId: 'errorMethod',\n                                *fix(fixer) {\n                                    const methodNodes = [\n                                        methodNode,\n                                        ...duplicatedKeyMethodNodes,\n                                    ].sort((a, b) => (a.range[0] < b.range[0] ? -1 : 1));\n                                    const typeString = methodNodes\n                                        .map(node => {\n                                        const params = getMethodParams(node);\n                                        const returnType = getMethodReturnType(node);\n                                        return `(${params} => ${returnType})`;\n                                    })\n                                        .join(' & ');\n                                    const key = getMethodKey(methodNode);\n                                    const delimiter = getDelimiter(methodNode);\n                                    yield fixer.replaceText(methodNode, `${key}: ${typeString}${delimiter}`);\n                                    for (const node of duplicatedKeyMethodNodes) {\n                                        const lastToken = context.sourceCode.getLastToken(node);\n                                        if (lastToken) {\n                                            const nextToken = context.sourceCode.getTokenAfter(lastToken);\n                                            if (nextToken) {\n                                                yield fixer.remove(node);\n                                                yield fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], '');\n                                            }\n                                        }\n                                    }\n                                },\n                            });\n                        }\n                        return;\n                    }\n                    if (isParentModule) {\n                        context.report({\n                            node: methodNode,\n                            messageId: 'errorMethod',\n                        });\n                    }\n                    else {\n                        context.report({\n                            node: methodNode,\n                            messageId: 'errorMethod',\n                            fix: fixer => {\n                                const key = getMethodKey(methodNode);\n                                const params = getMethodParams(methodNode);\n                                const returnType = getMethodReturnType(methodNode);\n                                const delimiter = getDelimiter(methodNode);\n                                return fixer.replaceText(methodNode, `${key}: ${params} => ${returnType}${delimiter}`);\n                            },\n                        });\n                    }\n                },\n            }),\n            ...(mode === 'method' && {\n                TSPropertySignature(propertyNode) {\n                    const typeNode = propertyNode.typeAnnotation?.typeAnnotation;\n                    if (typeNode?.type !== utils_1.AST_NODE_TYPES.TSFunctionType) {\n                        return;\n                    }\n                    context.report({\n                        node: propertyNode,\n                        messageId: 'errorProperty',\n                        fix: fixer => {\n                            const key = getMethodKey(propertyNode);\n                            const params = getMethodParams(typeNode);\n                            const returnType = getMethodReturnType(typeNode);\n                            const delimiter = getDelimiter(propertyNode);\n                            return fixer.replaceText(propertyNode, `${key}${params}: ${returnType}${delimiter}`);\n                        },\n                    });\n                },\n            }),\n        };\n    },\n});\n"
        }
    ]
}