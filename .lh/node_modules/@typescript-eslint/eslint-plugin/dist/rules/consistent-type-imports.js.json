{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/consistent-type-imports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891960832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'consistent-type-imports',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce consistent usage of type imports',\n        },\n        fixable: 'code',\n        messages: {\n            avoidImportType: 'Use an `import` instead of an `import type`.',\n            noImportTypeAnnotations: '`import()` type annotations are forbidden.',\n            someImportsAreOnlyTypes: 'Imports {{typeImports}} are only used as type.',\n            typeOverValue: 'All imports in the declaration are only used as types. Use `import type`.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    disallowTypeAnnotations: {\n                        type: 'boolean',\n                        description: 'Whether to disallow type imports in type annotations (`import()`).',\n                    },\n                    fixStyle: {\n                        type: 'string',\n                        description: 'The expected type modifier to be added when an import is detected as used only in the type position.',\n                        enum: ['separate-type-imports', 'inline-type-imports'],\n                    },\n                    prefer: {\n                        type: 'string',\n                        description: 'The expected import kind for type-only imports.',\n                        enum: ['type-imports', 'no-type-imports'],\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            disallowTypeAnnotations: true,\n            fixStyle: 'separate-type-imports',\n            prefer: 'type-imports',\n        },\n    ],\n    create(context, [option]) {\n        const prefer = option.prefer ?? 'type-imports';\n        const disallowTypeAnnotations = option.disallowTypeAnnotations !== false;\n        const selectors = {};\n        if (disallowTypeAnnotations) {\n            selectors.TSImportType = (node) => {\n                context.report({\n                    node,\n                    messageId: 'noImportTypeAnnotations',\n                });\n            };\n        }\n        if (prefer === 'no-type-imports') {\n            return {\n                ...selectors,\n                'ImportDeclaration[importKind = \"type\"]'(node) {\n                    context.report({\n                        node,\n                        messageId: 'avoidImportType',\n                        fix(fixer) {\n                            return fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n                        },\n                    });\n                },\n                'ImportSpecifier[importKind = \"type\"]'(node) {\n                    context.report({\n                        node,\n                        messageId: 'avoidImportType',\n                        fix(fixer) {\n                            return fixRemoveTypeSpecifierFromImportSpecifier(fixer, node);\n                        },\n                    });\n                },\n            };\n        }\n        // prefer type imports\n        const fixStyle = option.fixStyle ?? 'separate-type-imports';\n        let hasDecoratorMetadata = false;\n        const sourceImportsMap = {};\n        const emitDecoratorMetadata = (0, util_1.getParserServices)(context, true).emitDecoratorMetadata ?? false;\n        const experimentalDecorators = (0, util_1.getParserServices)(context, true).experimentalDecorators ?? false;\n        if (experimentalDecorators && emitDecoratorMetadata) {\n            selectors.Decorator = () => {\n                hasDecoratorMetadata = true;\n            };\n        }\n        return {\n            ...selectors,\n            ImportDeclaration(node) {\n                const source = node.source.value;\n                // sourceImports is the object containing all the specifics for a particular import source, type or value\n                sourceImportsMap[source] ??= {\n                    reportValueImports: [], // if there is a mismatch where type importKind but value specifiers\n                    source,\n                    typeOnlyNamedImport: null, // if only type imports\n                    valueImport: null, // if only value imports\n                    valueOnlyNamedImport: null, // if only value imports with named specifiers\n                };\n                const sourceImports = sourceImportsMap[source];\n                if (node.importKind === 'type') {\n                    if (!sourceImports.typeOnlyNamedImport &&\n                        node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {\n                        // definitely import type { TypeX }\n                        sourceImports.typeOnlyNamedImport = node;\n                    }\n                }\n                else if (!sourceImports.valueOnlyNamedImport &&\n                    node.specifiers.length &&\n                    node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {\n                    sourceImports.valueOnlyNamedImport = node;\n                    sourceImports.valueImport = node;\n                }\n                else if (!sourceImports.valueImport &&\n                    node.specifiers.some(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier)) {\n                    sourceImports.valueImport = node;\n                }\n                const typeSpecifiers = [];\n                const inlineTypeSpecifiers = [];\n                const valueSpecifiers = [];\n                const unusedSpecifiers = [];\n                for (const specifier of node.specifiers) {\n                    if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&\n                        specifier.importKind === 'type') {\n                        inlineTypeSpecifiers.push(specifier);\n                        continue;\n                    }\n                    const [variable] = context.sourceCode.getDeclaredVariables(specifier);\n                    if (variable.references.length === 0) {\n                        unusedSpecifiers.push(specifier);\n                    }\n                    else {\n                        const onlyHasTypeReferences = variable.references.every(ref => {\n                            /**\n                             * keep origin import kind when export\n                             * export { Type }\n                             * export default Type;\n                             * export = Type;\n                             */\n                            if ((ref.identifier.parent.type ===\n                                utils_1.AST_NODE_TYPES.ExportSpecifier ||\n                                ref.identifier.parent.type ===\n                                    utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||\n                                ref.identifier.parent.type ===\n                                    utils_1.AST_NODE_TYPES.TSExportAssignment) &&\n                                ref.isValueReference &&\n                                ref.isTypeReference) {\n                                return node.importKind === 'type';\n                            }\n                            if (ref.isValueReference) {\n                                let parent = ref.identifier.parent;\n                                let child = ref.identifier;\n                                while (parent) {\n                                    switch (parent.type) {\n                                        // CASE 1:\n                                        // `type T = typeof foo` will create a value reference because \"foo\" must be a value type\n                                        // however this value reference is safe to use with type-only imports\n                                        case utils_1.AST_NODE_TYPES.TSTypeQuery:\n                                            return true;\n                                        case utils_1.AST_NODE_TYPES.TSQualifiedName:\n                                            // TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early\n                                            if (parent.left !== child) {\n                                                return false;\n                                            }\n                                            child = parent;\n                                            parent = parent.parent;\n                                            continue;\n                                        // END CASE 1\n                                        //////////////\n                                        // CASE 2:\n                                        // `type T = { [foo]: string }` will create a value reference because \"foo\" must be a value type\n                                        // however this value reference is safe to use with type-only imports.\n                                        // Also this is represented as a non-type AST - hence it uses MemberExpression\n                                        case utils_1.AST_NODE_TYPES.TSPropertySignature:\n                                            return parent.key === child;\n                                        case utils_1.AST_NODE_TYPES.MemberExpression:\n                                            if (parent.object !== child) {\n                                                return false;\n                                            }\n                                            child = parent;\n                                            parent = parent.parent;\n                                            continue;\n                                        // END CASE 2\n                                        default:\n                                            return false;\n                                    }\n                                }\n                            }\n                            return ref.isTypeReference;\n                        });\n                        if (onlyHasTypeReferences) {\n                            typeSpecifiers.push(specifier);\n                        }\n                        else {\n                            valueSpecifiers.push(specifier);\n                        }\n                    }\n                }\n                if (node.importKind === 'value' && typeSpecifiers.length) {\n                    sourceImports.reportValueImports.push({\n                        node,\n                        inlineTypeSpecifiers,\n                        typeSpecifiers,\n                        unusedSpecifiers,\n                        valueSpecifiers,\n                    });\n                }\n            },\n            'Program:exit'() {\n                if (hasDecoratorMetadata) {\n                    // Experimental decorator metadata is bowl of poop that cannot be\n                    // supported based on pure syntactic analysis.\n                    //\n                    // So we can do one of two things:\n                    // 1) add type-information to the rule in a breaking change and\n                    //    prevent users from using it so that we can fully support this\n                    //    case.\n                    // 2) make the rule ignore all imports that are used in a file that\n                    //    might have decorator metadata.\n                    //\n                    // (1) is has huge impact and prevents the rule from being used by 99%\n                    // of users Frankly - it's a straight-up bad option. So instead we\n                    // choose with option (2) and just avoid reporting on any imports in a\n                    // file with both emitDecoratorMetadata AND decorators\n                    //\n                    // For more context see the discussion in this issue and its linked\n                    // issues:\n                    // https://github.com/typescript-eslint/typescript-eslint/issues/5468\n                    //\n                    //\n                    // NOTE - in TS 5.0 `experimentalDecorators` became the legacy option,\n                    // replaced with un-flagged, stable decorators and thus the type-aware\n                    // emitDecoratorMetadata implementation also became legacy. in TS 5.2\n                    // support for the new, stable decorator metadata proposal was added -\n                    // however this proposal does not include type information\n                    //\n                    //\n                    // PHEW. So TL;DR what does all this mean?\n                    // - if you use experimentalDecorators:true,\n                    //   emitDecoratorMetadata:true, and have a decorator in the file -\n                    //   the rule will do nothing in the file out of an abundance of\n                    //   caution.\n                    // - else the rule will work as normal.\n                    return;\n                }\n                for (const sourceImports of Object.values(sourceImportsMap)) {\n                    if (sourceImports.reportValueImports.length === 0) {\n                        // nothing to fix. value specifiers and type specifiers are correctly written\n                        continue;\n                    }\n                    for (const report of sourceImports.reportValueImports) {\n                        if (report.valueSpecifiers.length === 0 &&\n                            report.unusedSpecifiers.length === 0 &&\n                            report.node.importKind !== 'type') {\n                            /**\n                             * checks if import has type assertions\n                             * @example\n                             * ```ts\n                             * import * as type from 'mod' assert \\{ type: 'json' \\};\n                             * ```\n                             * https://github.com/typescript-eslint/typescript-eslint/issues/7527\n                             */\n                            if (report.node.attributes.length === 0) {\n                                context.report({\n                                    node: report.node,\n                                    messageId: 'typeOverValue',\n                                    *fix(fixer) {\n                                        yield* fixToTypeImportDeclaration(fixer, report, sourceImports);\n                                    },\n                                });\n                            }\n                        }\n                        else {\n                            // we have a mixed type/value import or just value imports, so we need to split them out into multiple imports if separate-type-imports is configured\n                            const importNames = report.typeSpecifiers.map(specifier => `\"${specifier.local.name}\"`);\n                            const message = (() => {\n                                const typeImports = (0, util_1.formatWordList)(importNames);\n                                if (importNames.length === 1) {\n                                    return {\n                                        messageId: 'someImportsAreOnlyTypes',\n                                        data: {\n                                            typeImports,\n                                        },\n                                    };\n                                }\n                                return {\n                                    messageId: 'someImportsAreOnlyTypes',\n                                    data: {\n                                        typeImports,\n                                    },\n                                };\n                            })();\n                            context.report({\n                                node: report.node,\n                                ...message,\n                                *fix(fixer) {\n                                    // take all the typeSpecifiers and put them on a new line\n                                    yield* fixToTypeImportDeclaration(fixer, report, sourceImports);\n                                },\n                            });\n                        }\n                    }\n                }\n            },\n        };\n        function classifySpecifier(node) {\n            const defaultSpecifier = node.specifiers[0].type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier\n                ? node.specifiers[0]\n                : null;\n            const namespaceSpecifier = node.specifiers.find((specifier) => specifier.type === utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier) ?? null;\n            const namedSpecifiers = node.specifiers.filter((specifier) => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier);\n            return {\n                defaultSpecifier,\n                namedSpecifiers,\n                namespaceSpecifier,\n            };\n        }\n        /**\n         * Returns information for fixing named specifiers, type or value\n         */\n        function getFixesNamedSpecifiers(fixer, node, subsetNamedSpecifiers, allNamedSpecifiers) {\n            if (allNamedSpecifiers.length === 0) {\n                return {\n                    removeTypeNamedSpecifiers: [],\n                    typeNamedSpecifiersText: '',\n                };\n            }\n            const typeNamedSpecifiersTexts = [];\n            const removeTypeNamedSpecifiers = [];\n            if (subsetNamedSpecifiers.length === allNamedSpecifiers.length) {\n                // import Foo, {Type1, Type2} from 'foo'\n                // import DefType, {Type1, Type2} from 'foo'\n                const openingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(subsetNamedSpecifiers[0], util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken('{', node.type));\n                const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(openingBraceToken, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', node.type));\n                const closingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', node.type));\n                // import DefType, {...} from 'foo'\n                //               ^^^^^^^ remove\n                removeTypeNamedSpecifiers.push(fixer.removeRange([commaToken.range[0], closingBraceToken.range[1]]));\n                typeNamedSpecifiersTexts.push(context.sourceCode.text.slice(openingBraceToken.range[1], closingBraceToken.range[0]));\n            }\n            else {\n                const namedSpecifierGroups = [];\n                let group = [];\n                for (const namedSpecifier of allNamedSpecifiers) {\n                    if (subsetNamedSpecifiers.includes(namedSpecifier)) {\n                        group.push(namedSpecifier);\n                    }\n                    else if (group.length) {\n                        namedSpecifierGroups.push(group);\n                        group = [];\n                    }\n                }\n                if (group.length) {\n                    namedSpecifierGroups.push(group);\n                }\n                for (const namedSpecifiers of namedSpecifierGroups) {\n                    const { removeRange, textRange } = getNamedSpecifierRanges(namedSpecifiers, allNamedSpecifiers);\n                    removeTypeNamedSpecifiers.push(fixer.removeRange(removeRange));\n                    typeNamedSpecifiersTexts.push(context.sourceCode.text.slice(...textRange));\n                }\n            }\n            return {\n                removeTypeNamedSpecifiers,\n                typeNamedSpecifiersText: typeNamedSpecifiersTexts.join(','),\n            };\n        }\n        /**\n         * Returns ranges for fixing named specifier.\n         */\n        function getNamedSpecifierRanges(namedSpecifierGroup, allNamedSpecifiers) {\n            const first = namedSpecifierGroup[0];\n            const last = namedSpecifierGroup[namedSpecifierGroup.length - 1];\n            const removeRange = [first.range[0], last.range[1]];\n            const textRange = [...removeRange];\n            const before = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(first), util_1.NullThrowsReasons.MissingToken('token', 'first specifier'));\n            textRange[0] = before.range[1];\n            if ((0, util_1.isCommaToken)(before)) {\n                removeRange[0] = before.range[0];\n            }\n            else {\n                removeRange[0] = before.range[1];\n            }\n            const isFirst = allNamedSpecifiers[0] === first;\n            const isLast = allNamedSpecifiers[allNamedSpecifiers.length - 1] === last;\n            const after = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(last), util_1.NullThrowsReasons.MissingToken('token', 'last specifier'));\n            textRange[1] = after.range[0];\n            if ((isFirst || isLast) && (0, util_1.isCommaToken)(after)) {\n                removeRange[1] = after.range[1];\n            }\n            return {\n                removeRange,\n                textRange,\n            };\n        }\n        /**\n         * insert specifiers to named import node.\n         * e.g.\n         * import type { Already, Type1, Type2 } from 'foo'\n         *                        ^^^^^^^^^^^^^ insert\n         */\n        function fixInsertNamedSpecifiersInNamedSpecifierList(fixer, target, insertText) {\n            const closingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween((0, util_1.nullThrows)(context.sourceCode.getFirstToken(target), util_1.NullThrowsReasons.MissingToken('token before', 'import')), target.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', target.type));\n            const before = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(closingBraceToken), util_1.NullThrowsReasons.MissingToken('token before', 'closing brace'));\n            if (!(0, util_1.isCommaToken)(before) && !(0, util_1.isOpeningBraceToken)(before)) {\n                insertText = `,${insertText}`;\n            }\n            return fixer.insertTextBefore(closingBraceToken, insertText);\n        }\n        /**\n         * insert type keyword to named import node.\n         * e.g.\n         * import ADefault, { Already, type Type1, type Type2 } from 'foo'\n         *                             ^^^^ insert\n         */\n        function* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeSpecifiers) {\n            for (const spec of typeSpecifiers) {\n                const insertText = context.sourceCode.text.slice(...spec.range);\n                yield fixer.replaceTextRange(spec.range, `type ${insertText}`);\n            }\n        }\n        function* fixInlineTypeImportDeclaration(fixer, report, sourceImports) {\n            const { node } = report;\n            // For a value import, will only add an inline type to named specifiers\n            const { namedSpecifiers } = classifySpecifier(node);\n            const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));\n            if (sourceImports.valueImport) {\n                // add import named type specifiers to its value import\n                // import ValueA, { type A }\n                //                  ^^^^ insert\n                const { namedSpecifiers: valueImportNamedSpecifiers } = classifySpecifier(sourceImports.valueImport);\n                if (sourceImports.valueOnlyNamedImport ||\n                    valueImportNamedSpecifiers.length) {\n                    yield* fixInsertTypeKeywordInNamedSpecifierList(fixer, typeNamedSpecifiers);\n                }\n            }\n        }\n        function* fixToTypeImportDeclaration(fixer, report, sourceImports) {\n            const { node } = report;\n            const { defaultSpecifier, namedSpecifiers, namespaceSpecifier } = classifySpecifier(node);\n            if (namespaceSpecifier && !defaultSpecifier) {\n                // import * as types from 'foo'\n                // checks for presence of import assertions\n                if (node.attributes.length === 0) {\n                    yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);\n                }\n                return;\n            }\n            if (defaultSpecifier) {\n                if (report.typeSpecifiers.includes(defaultSpecifier) &&\n                    namedSpecifiers.length === 0 &&\n                    !namespaceSpecifier) {\n                    // import Type from 'foo'\n                    yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, true);\n                    return;\n                }\n                if (fixStyle === 'inline-type-imports' &&\n                    !report.typeSpecifiers.includes(defaultSpecifier) &&\n                    namedSpecifiers.length > 0 &&\n                    !namespaceSpecifier) {\n                    // if there is a default specifier but it isn't a type specifier, then just add the inline type modifier to the named specifiers\n                    // import AValue, {BValue, Type1, Type2} from 'foo'\n                    yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);\n                    return;\n                }\n            }\n            else if (!namespaceSpecifier) {\n                if (fixStyle === 'inline-type-imports' &&\n                    namedSpecifiers.some(specifier => report.typeSpecifiers.includes(specifier))) {\n                    // import {AValue, Type1, Type2} from 'foo'\n                    yield* fixInlineTypeImportDeclaration(fixer, report, sourceImports);\n                    return;\n                }\n                if (namedSpecifiers.every(specifier => report.typeSpecifiers.includes(specifier))) {\n                    // import {Type1, Type2} from 'foo'\n                    yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);\n                    return;\n                }\n            }\n            const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));\n            const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, namedSpecifiers);\n            const afterFixes = [];\n            if (typeNamedSpecifiers.length) {\n                if (sourceImports.typeOnlyNamedImport) {\n                    const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.typeOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);\n                    if (sourceImports.typeOnlyNamedImport.range[1] <= node.range[0]) {\n                        yield insertTypeNamedSpecifiers;\n                    }\n                    else {\n                        afterFixes.push(insertTypeNamedSpecifiers);\n                    }\n                }\n                else {\n                    // The import is both default and named.  Insert named on new line because can't mix default type import and named type imports\n                    // eslint-disable-next-line no-lonely-if\n                    if (fixStyle === 'inline-type-imports') {\n                        yield fixer.insertTextBefore(node, `import {${typeNamedSpecifiers\n                            .map(spec => {\n                            const insertText = context.sourceCode.text.slice(...spec.range);\n                            return `type ${insertText}`;\n                        })\n                            .join(', ')}} from ${context.sourceCode.getText(node.source)};\\n`);\n                    }\n                    else {\n                        yield fixer.insertTextBefore(node, `import type {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${context.sourceCode.getText(node.source)};\\n`);\n                    }\n                }\n            }\n            const fixesRemoveTypeNamespaceSpecifier = [];\n            if (namespaceSpecifier &&\n                report.typeSpecifiers.includes(namespaceSpecifier)) {\n                // import Foo, * as Type from 'foo'\n                // import DefType, * as Type from 'foo'\n                // import DefType, * as Type from 'foo'\n                const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(namespaceSpecifier, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', node.type));\n                // import Def, * as Ns from 'foo'\n                //           ^^^^^^^^^ remove\n                fixesRemoveTypeNamespaceSpecifier.push(fixer.removeRange([commaToken.range[0], namespaceSpecifier.range[1]]));\n                // import type * as Ns from 'foo'\n                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ insert\n                yield fixer.insertTextBefore(node, `import type ${context.sourceCode.getText(namespaceSpecifier)} from ${context.sourceCode.getText(node.source)};\\n`);\n            }\n            if (defaultSpecifier &&\n                report.typeSpecifiers.includes(defaultSpecifier)) {\n                if (report.typeSpecifiers.length === node.specifiers.length) {\n                    const importToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import', node.type));\n                    // import type Type from 'foo'\n                    //        ^^^^ insert\n                    yield fixer.insertTextAfter(importToken, ' type');\n                }\n                else {\n                    const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(defaultSpecifier, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', defaultSpecifier.type));\n                    // import Type , {...} from 'foo'\n                    //        ^^^^^ pick\n                    const defaultText = context.sourceCode.text\n                        .slice(defaultSpecifier.range[0], commaToken.range[0])\n                        .trim();\n                    yield fixer.insertTextBefore(node, `import type ${defaultText} from ${context.sourceCode.getText(node.source)};\\n`);\n                    const afterToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(commaToken, {\n                        includeComments: true,\n                    }), util_1.NullThrowsReasons.MissingToken('any token', node.type));\n                    // import Type , {...} from 'foo'\n                    //        ^^^^^^^ remove\n                    yield fixer.removeRange([\n                        defaultSpecifier.range[0],\n                        afterToken.range[0],\n                    ]);\n                }\n            }\n            yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;\n            yield* fixesRemoveTypeNamespaceSpecifier;\n            yield* afterFixes;\n        }\n        function* fixInsertTypeSpecifierForImportDeclaration(fixer, node, isDefaultImport) {\n            // import type Foo from 'foo'\n            //       ^^^^^ insert\n            const importToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import', node.type));\n            yield fixer.insertTextAfter(importToken, ' type');\n            if (isDefaultImport) {\n                // Has default import\n                const openingBraceToken = context.sourceCode.getFirstTokenBetween(importToken, node.source, util_1.isOpeningBraceToken);\n                if (openingBraceToken) {\n                    // Only braces. e.g. import Foo, {} from 'foo'\n                    const commaToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(openingBraceToken, util_1.isCommaToken), util_1.NullThrowsReasons.MissingToken(',', node.type));\n                    const closingBraceToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', node.type));\n                    // import type Foo, {} from 'foo'\n                    //                  ^^ remove\n                    yield fixer.removeRange([\n                        commaToken.range[0],\n                        closingBraceToken.range[1],\n                    ]);\n                    const specifiersText = context.sourceCode.text.slice(commaToken.range[1], closingBraceToken.range[1]);\n                    if (node.specifiers.length > 1) {\n                        yield fixer.insertTextAfter(node, `\\nimport type${specifiersText} from ${context.sourceCode.getText(node.source)};`);\n                    }\n                }\n            }\n            // make sure we don't do anything like `import type {type T} from 'foo';`\n            for (const specifier of node.specifiers) {\n                if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&\n                    specifier.importKind === 'type') {\n                    yield* fixRemoveTypeSpecifierFromImportSpecifier(fixer, specifier);\n                }\n            }\n        }\n        function* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node) {\n            // import type Foo from 'foo'\n            //        ^^^^ remove\n            const importToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isImportKeyword), util_1.NullThrowsReasons.MissingToken('import', node.type));\n            const typeToken = (0, util_1.nullThrows)(context.sourceCode.getFirstTokenBetween(importToken, node.specifiers[0]?.local ?? node.source, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken('type', node.type));\n            const afterToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(typeToken, { includeComments: true }), util_1.NullThrowsReasons.MissingToken('any token', node.type));\n            yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);\n        }\n        function* fixRemoveTypeSpecifierFromImportSpecifier(fixer, node) {\n            // import { type Foo } from 'foo'\n            //          ^^^^ remove\n            const typeToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, util_1.isTypeKeyword), util_1.NullThrowsReasons.MissingToken('type', node.type));\n            const afterToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(typeToken, { includeComments: true }), util_1.NullThrowsReasons.MissingToken('any token', node.type));\n            yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);\n        }\n    },\n});\n"
        }
    ]
}