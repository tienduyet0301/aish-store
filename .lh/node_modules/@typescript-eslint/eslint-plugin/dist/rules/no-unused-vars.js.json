{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unused-vars.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891970817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst referenceContainsTypeQuery_1 = require(\"../util/referenceContainsTypeQuery\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-unused-vars',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow unused variables',\n            extendsBaseRule: true,\n            recommended: 'recommended',\n        },\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\",\n            usedIgnoredVar: \"'{{varName}}' is marked as ignored but is used{{additional}}.\",\n            usedOnlyAsType: \"'{{varName}}' is {{action}} but only used as a type{{additional}}.\",\n        },\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: 'string',\n                        enum: ['all', 'local'],\n                    },\n                    {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                            args: {\n                                type: 'string',\n                                description: 'Whether to check all, some, or no arguments.',\n                                enum: ['all', 'after-used', 'none'],\n                            },\n                            argsIgnorePattern: {\n                                type: 'string',\n                                description: 'Regular expressions of argument names to not check for usage.',\n                            },\n                            caughtErrors: {\n                                type: 'string',\n                                description: 'Whether to check catch block arguments.',\n                                enum: ['all', 'none'],\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: 'string',\n                                description: 'Regular expressions of catch block argument names to not check for usage.',\n                            },\n                            destructuredArrayIgnorePattern: {\n                                type: 'string',\n                                description: 'Regular expressions of destructured array variable names to not check for usage.',\n                            },\n                            ignoreClassWithStaticInitBlock: {\n                                type: 'boolean',\n                                description: 'Whether to ignore classes with at least one static initialization block.',\n                            },\n                            ignoreRestSiblings: {\n                                type: 'boolean',\n                                description: 'Whether to ignore sibling properties in `...` destructurings.',\n                            },\n                            reportUsedIgnorePattern: {\n                                type: 'boolean',\n                                description: 'Whether to report variables that match any of the valid ignore pattern options if they have been used.',\n                            },\n                            vars: {\n                                type: 'string',\n                                description: 'Whether to check all variables or only locally-declared variables.',\n                                enum: ['all', 'local'],\n                            },\n                            varsIgnorePattern: {\n                                type: 'string',\n                                description: 'Regular expressions of variable names to not check for usage.',\n                            },\n                        },\n                    },\n                ],\n            },\n        ],\n    },\n    defaultOptions: [{}],\n    create(context, [firstOption]) {\n        const MODULE_DECL_CACHE = new Map();\n        const options = (() => {\n            const options = {\n                args: 'after-used',\n                caughtErrors: 'all',\n                ignoreClassWithStaticInitBlock: false,\n                ignoreRestSiblings: false,\n                reportUsedIgnorePattern: false,\n                vars: 'all',\n            };\n            if (typeof firstOption === 'string') {\n                options.vars = firstOption;\n            }\n            else {\n                options.vars = firstOption.vars ?? options.vars;\n                options.args = firstOption.args ?? options.args;\n                options.ignoreRestSiblings =\n                    firstOption.ignoreRestSiblings ?? options.ignoreRestSiblings;\n                options.caughtErrors = firstOption.caughtErrors ?? options.caughtErrors;\n                options.ignoreClassWithStaticInitBlock =\n                    firstOption.ignoreClassWithStaticInitBlock ??\n                        options.ignoreClassWithStaticInitBlock;\n                options.reportUsedIgnorePattern =\n                    firstOption.reportUsedIgnorePattern ??\n                        options.reportUsedIgnorePattern;\n                if (firstOption.varsIgnorePattern) {\n                    options.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, 'u');\n                }\n                if (firstOption.argsIgnorePattern) {\n                    options.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, 'u');\n                }\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    options.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, 'u');\n                }\n                if (firstOption.destructuredArrayIgnorePattern) {\n                    options.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, 'u');\n                }\n            }\n            return options;\n        })();\n        /**\n         * Determines what variable type a def is.\n         * @param def the declaration to check\n         * @returns a simple name for the types of variables that this rule supports\n         */\n        function defToVariableType(def) {\n            /*\n             * This `destructuredArrayIgnorePattern` error report works differently from the catch\n             * clause and parameter error reports. _Both_ the `varsIgnorePattern` and the\n             * `destructuredArrayIgnorePattern` will be checked for array destructuring. However,\n             * for the purposes of the report, the currently defined behavior is to only inform the\n             * user of the `destructuredArrayIgnorePattern` if it's present (regardless of the fact\n             * that the `varsIgnorePattern` would also apply). If it's not present, the user will be\n             * informed of the `varsIgnorePattern`, assuming that's present.\n             */\n            if (options.destructuredArrayIgnorePattern &&\n                def.name.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n                return 'array-destructure';\n            }\n            switch (def.type) {\n                case scope_manager_1.DefinitionType.CatchClause:\n                    return 'catch-clause';\n                case scope_manager_1.DefinitionType.Parameter:\n                    return 'parameter';\n                default:\n                    return 'variable';\n            }\n        }\n        /**\n         * Gets a given variable's description and configured ignore pattern\n         * based on the provided variableType\n         * @param variableType a simple name for the types of variables that this rule supports\n         * @returns the given variable's description and\n         * ignore pattern\n         */\n        function getVariableDescription(variableType) {\n            switch (variableType) {\n                case 'array-destructure':\n                    return {\n                        pattern: options.destructuredArrayIgnorePattern?.toString(),\n                        variableDescription: 'elements of array destructuring',\n                    };\n                case 'catch-clause':\n                    return {\n                        pattern: options.caughtErrorsIgnorePattern?.toString(),\n                        variableDescription: 'caught errors',\n                    };\n                case 'parameter':\n                    return {\n                        pattern: options.argsIgnorePattern?.toString(),\n                        variableDescription: 'args',\n                    };\n                case 'variable':\n                    return {\n                        pattern: options.varsIgnorePattern?.toString(),\n                        variableDescription: 'vars',\n                    };\n            }\n        }\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param unusedVar eslint-scope variable object.\n         * @returns The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const def = unusedVar.defs.at(0);\n            let additionalMessageData = '';\n            if (def) {\n                const { pattern, variableDescription } = getVariableDescription(defToVariableType(def));\n                if (pattern && variableDescription) {\n                    additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern}`;\n                }\n            }\n            return {\n                action: 'defined',\n                additional: additionalMessageData,\n                varName: unusedVar.name,\n            };\n        }\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param unusedVar eslint-scope variable object.\n         * @returns The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const def = unusedVar.defs.at(0);\n            let additionalMessageData = '';\n            if (def) {\n                const { pattern, variableDescription } = getVariableDescription(defToVariableType(def));\n                if (pattern && variableDescription) {\n                    additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern}`;\n                }\n            }\n            return {\n                action: 'assigned a value',\n                additional: additionalMessageData,\n                varName: unusedVar.name,\n            };\n        }\n        /**\n         * Generate the warning message about a variable being used even though\n         * it is marked as being ignored.\n         * @param variable eslint-scope variable object\n         * @param variableType a simple name for the types of variables that this rule supports\n         * @returns The message data to be used with this used ignored variable.\n         */\n        function getUsedIgnoredMessageData(variable, variableType) {\n            const { pattern, variableDescription } = getVariableDescription(variableType);\n            let additionalMessageData = '';\n            if (pattern && variableDescription) {\n                additionalMessageData = `. Used ${variableDescription} must not match ${pattern}`;\n            }\n            return {\n                additional: additionalMessageData,\n                varName: variable.name,\n            };\n        }\n        function collectUnusedVariables() {\n            /**\n             * Checks whether a node is a sibling of the rest property or not.\n             * @param node a node to check\n             * @returns True if the node is a sibling of the rest property, otherwise false.\n             */\n            function hasRestSibling(node) {\n                return (node.type === utils_1.AST_NODE_TYPES.Property &&\n                    node.parent.type === utils_1.AST_NODE_TYPES.ObjectPattern &&\n                    node.parent.properties[node.parent.properties.length - 1].type ===\n                        utils_1.AST_NODE_TYPES.RestElement);\n            }\n            /**\n             * Determines if a variable has a sibling rest property\n             * @param variable eslint-scope variable object.\n             * @returns True if the variable is exported, false if not.\n             */\n            function hasRestSpreadSibling(variable) {\n                if (options.ignoreRestSiblings) {\n                    const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n                    const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n                    return hasRestSiblingDefinition || hasRestSiblingReference;\n                }\n                return false;\n            }\n            /**\n             * Checks whether the given variable is after the last used parameter.\n             * @param variable The variable to check.\n             * @returns `true` if the variable is defined after the last used parameter.\n             */\n            function isAfterLastUsedArg(variable) {\n                const def = variable.defs[0];\n                const params = context.sourceCode.getDeclaredVariables(def.node);\n                const posteriorParams = params.slice(params.indexOf(variable) + 1);\n                // If any used parameters occur after this parameter, do not report.\n                return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n            }\n            const analysisResults = (0, util_1.collectVariables)(context);\n            const variables = [\n                ...Array.from(analysisResults.unusedVariables, variable => ({\n                    used: false,\n                    variable,\n                })),\n                ...Array.from(analysisResults.usedVariables, variable => ({\n                    used: true,\n                    variable,\n                })),\n            ];\n            const unusedVariablesReturn = [];\n            for (const { used, variable } of variables) {\n                // explicit global variables don't have definitions.\n                if (variable.defs.length === 0) {\n                    if (!used) {\n                        unusedVariablesReturn.push(variable);\n                    }\n                    continue;\n                }\n                const def = variable.defs[0];\n                if (variable.scope.type === utils_1.TSESLint.Scope.ScopeType.global &&\n                    options.vars === 'local') {\n                    // skip variables in the global scope if configured to\n                    continue;\n                }\n                const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern);\n                // skip elements of array destructuring patterns\n                if ((def.name.parent.type === utils_1.AST_NODE_TYPES.ArrayPattern ||\n                    refUsedInArrayPatterns) &&\n                    def.name.type === utils_1.AST_NODE_TYPES.Identifier &&\n                    options.destructuredArrayIgnorePattern?.test(def.name.name)) {\n                    if (options.reportUsedIgnorePattern && used) {\n                        context.report({\n                            node: def.name,\n                            messageId: 'usedIgnoredVar',\n                            data: getUsedIgnoredMessageData(variable, 'array-destructure'),\n                        });\n                    }\n                    continue;\n                }\n                if (def.type === utils_1.TSESLint.Scope.DefinitionType.ClassName) {\n                    const hasStaticBlock = def.node.body.body.some(node => node.type === utils_1.AST_NODE_TYPES.StaticBlock);\n                    if (options.ignoreClassWithStaticInitBlock && hasStaticBlock) {\n                        continue;\n                    }\n                }\n                // skip catch variables\n                if (def.type === utils_1.TSESLint.Scope.DefinitionType.CatchClause) {\n                    if (options.caughtErrors === 'none') {\n                        continue;\n                    }\n                    // skip ignored parameters\n                    if (def.name.type === utils_1.AST_NODE_TYPES.Identifier &&\n                        options.caughtErrorsIgnorePattern?.test(def.name.name)) {\n                        if (options.reportUsedIgnorePattern && used) {\n                            context.report({\n                                node: def.name,\n                                messageId: 'usedIgnoredVar',\n                                data: getUsedIgnoredMessageData(variable, 'catch-clause'),\n                            });\n                        }\n                        continue;\n                    }\n                }\n                else if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n                    // if \"args\" option is \"none\", skip any parameter\n                    if (options.args === 'none') {\n                        continue;\n                    }\n                    // skip ignored parameters\n                    if (def.name.type === utils_1.AST_NODE_TYPES.Identifier &&\n                        options.argsIgnorePattern?.test(def.name.name)) {\n                        if (options.reportUsedIgnorePattern && used) {\n                            context.report({\n                                node: def.name,\n                                messageId: 'usedIgnoredVar',\n                                data: getUsedIgnoredMessageData(variable, 'parameter'),\n                            });\n                        }\n                        continue;\n                    }\n                    // if \"args\" option is \"after-used\", skip used variables\n                    if (options.args === 'after-used' &&\n                        (0, util_1.isFunction)(def.name.parent) &&\n                        !isAfterLastUsedArg(variable)) {\n                        continue;\n                    }\n                }\n                // skip ignored variables\n                else if (def.name.type === utils_1.AST_NODE_TYPES.Identifier &&\n                    options.varsIgnorePattern?.test(def.name.name)) {\n                    if (options.reportUsedIgnorePattern &&\n                        used &&\n                        /* enum members are always marked as 'used' by `collectVariables`, but in reality they may be used or\n                           unused. either way, don't complain about their naming. */\n                        def.type !== utils_1.TSESLint.Scope.DefinitionType.TSEnumMember) {\n                        context.report({\n                            node: def.name,\n                            messageId: 'usedIgnoredVar',\n                            data: getUsedIgnoredMessageData(variable, 'variable'),\n                        });\n                    }\n                    continue;\n                }\n                if (hasRestSpreadSibling(variable)) {\n                    continue;\n                }\n                // in case another rule has run and used the collectUnusedVariables,\n                // we want to ensure our selectors that marked variables as used are respected\n                if (variable.eslintUsed) {\n                    continue;\n                }\n                if (!used) {\n                    unusedVariablesReturn.push(variable);\n                }\n            }\n            return unusedVariablesReturn;\n        }\n        return {\n            // top-level declaration file handling\n            [ambientDeclarationSelector(utils_1.AST_NODE_TYPES.Program)](node) {\n                if (!(0, util_1.isDefinitionFile)(context.filename)) {\n                    return;\n                }\n                const moduleDecl = (0, util_1.nullThrows)(node.parent, util_1.NullThrowsReasons.MissingParent);\n                if (checkForOverridingExportStatements(moduleDecl)) {\n                    return;\n                }\n                markDeclarationChildAsUsed(node);\n            },\n            // children of a namespace that is a child of a declared namespace are auto-exported\n            [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock TSModuleDeclaration > TSModuleBlock')](node) {\n                const moduleDecl = (0, util_1.nullThrows)(node.parent.parent, util_1.NullThrowsReasons.MissingParent);\n                if (checkForOverridingExportStatements(moduleDecl)) {\n                    return;\n                }\n                markDeclarationChildAsUsed(node);\n            },\n            // declared namespace handling\n            [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock')](node) {\n                const moduleDecl = (0, util_1.nullThrows)(node.parent.parent, util_1.NullThrowsReasons.MissingParent);\n                if (checkForOverridingExportStatements(moduleDecl)) {\n                    return;\n                }\n                markDeclarationChildAsUsed(node);\n            },\n            // namespace handling in definition files\n            [ambientDeclarationSelector('TSModuleDeclaration > TSModuleBlock')](node) {\n                if (!(0, util_1.isDefinitionFile)(context.filename)) {\n                    return;\n                }\n                const moduleDecl = (0, util_1.nullThrows)(node.parent.parent, util_1.NullThrowsReasons.MissingParent);\n                if (checkForOverridingExportStatements(moduleDecl)) {\n                    return;\n                }\n                markDeclarationChildAsUsed(node);\n            },\n            // collect\n            'Program:exit'(programNode) {\n                const unusedVars = collectUnusedVariables();\n                for (const unusedVar of unusedVars) {\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n                        const usedOnlyAsType = unusedVar.references.some(ref => (0, referenceContainsTypeQuery_1.referenceContainsTypeQuery)(ref.identifier));\n                        const isImportUsedOnlyAsType = usedOnlyAsType &&\n                            unusedVar.defs.some(def => def.type === scope_manager_1.DefinitionType.ImportBinding);\n                        if (isImportUsedOnlyAsType) {\n                            continue;\n                        }\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() &&\n                            ref.from.variableScope === unusedVar.scope.variableScope);\n                        const id = writeReferences.length\n                            ? writeReferences[writeReferences.length - 1].identifier\n                            : unusedVar.identifiers[0];\n                        const messageId = usedOnlyAsType ? 'usedOnlyAsType' : 'unusedVar';\n                        const { start } = id.loc;\n                        const idLength = id.name.length;\n                        const loc = {\n                            start,\n                            end: {\n                                column: start.column + idLength,\n                                line: start.line,\n                            },\n                        };\n                        context.report({\n                            loc,\n                            messageId,\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar),\n                        });\n                        // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    }\n                    else if ('eslintExplicitGlobalComments' in unusedVar &&\n                        unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n                        context.report({\n                            loc: (0, util_1.getNameLocationInGlobalDirectiveComment)(context.sourceCode, directiveComment, unusedVar.name),\n                            node: programNode,\n                            messageId: 'unusedVar',\n                            data: getDefinedMessageData(unusedVar),\n                        });\n                    }\n                }\n            },\n        };\n        function checkForOverridingExportStatements(node) {\n            const cached = MODULE_DECL_CACHE.get(node);\n            if (cached != null) {\n                return cached;\n            }\n            const body = getStatementsOfNode(node);\n            if (hasOverridingExportStatement(body)) {\n                MODULE_DECL_CACHE.set(node, true);\n                return true;\n            }\n            MODULE_DECL_CACHE.set(node, false);\n            return false;\n        }\n        function ambientDeclarationSelector(parent) {\n            return [\n                // Types are ambiently exported\n                `${parent} > :matches(${[\n                    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n                    utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n                ].join(', ')})`,\n                // Value things are ambiently exported if they are \"declare\"d\n                `${parent} > :matches(${[\n                    utils_1.AST_NODE_TYPES.ClassDeclaration,\n                    utils_1.AST_NODE_TYPES.TSDeclareFunction,\n                    utils_1.AST_NODE_TYPES.TSEnumDeclaration,\n                    utils_1.AST_NODE_TYPES.TSModuleDeclaration,\n                    utils_1.AST_NODE_TYPES.VariableDeclaration,\n                ].join(', ')})`,\n            ].join(', ');\n        }\n        function markDeclarationChildAsUsed(node) {\n            const identifiers = [];\n            switch (node.type) {\n                case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:\n                case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:\n                case utils_1.AST_NODE_TYPES.ClassDeclaration:\n                case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n                case utils_1.AST_NODE_TYPES.TSDeclareFunction:\n                case utils_1.AST_NODE_TYPES.TSEnumDeclaration:\n                case utils_1.AST_NODE_TYPES.TSModuleDeclaration:\n                    if (node.id?.type === utils_1.AST_NODE_TYPES.Identifier) {\n                        identifiers.push(node.id);\n                    }\n                    break;\n                case utils_1.AST_NODE_TYPES.VariableDeclaration:\n                    for (const declaration of node.declarations) {\n                        visitPattern(declaration, pattern => {\n                            identifiers.push(pattern);\n                        });\n                    }\n                    break;\n            }\n            let scope = context.sourceCode.getScope(node);\n            const shouldUseUpperScope = [\n                utils_1.AST_NODE_TYPES.TSDeclareFunction,\n                utils_1.AST_NODE_TYPES.TSModuleDeclaration,\n            ].includes(node.type);\n            if (scope.variableScope !== scope) {\n                scope = scope.variableScope;\n            }\n            else if (shouldUseUpperScope && scope.upper) {\n                scope = scope.upper;\n            }\n            for (const id of identifiers) {\n                const superVar = scope.set.get(id.name);\n                if (superVar) {\n                    superVar.eslintUsed = true;\n                }\n            }\n        }\n        function visitPattern(node, cb) {\n            const visitor = new scope_manager_1.PatternVisitor({}, node, cb);\n            visitor.visit(node);\n        }\n    },\n});\nfunction hasOverridingExportStatement(body) {\n    for (const statement of body) {\n        if ((statement.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration &&\n            statement.declaration == null) ||\n            statement.type === utils_1.AST_NODE_TYPES.ExportAllDeclaration ||\n            statement.type === utils_1.AST_NODE_TYPES.TSExportAssignment) {\n            return true;\n        }\n        if (statement.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration &&\n            statement.declaration.type === utils_1.AST_NODE_TYPES.Identifier) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getStatementsOfNode(block) {\n    if (block.type === utils_1.AST_NODE_TYPES.Program) {\n        return block.body;\n    }\n    return block.body.body;\n}\n/*\n\n###### TODO ######\n\nEdge cases that aren't currently handled due to laziness and them being super edgy edge cases\n\n\n--- function params referenced in typeof type refs in the function declaration ---\n--- NOTE - TS gets these cases wrong\n\nfunction _foo(\n  arg: number // arg should be unused\n): typeof arg {\n  return 1 as any;\n}\n\nfunction _bar(\n  arg: number, // arg should be unused\n  _arg2: typeof arg,\n) {}\n\n\n--- function names referenced in typeof type refs in the function declaration ---\n--- NOTE - TS gets these cases right\n\nfunction foo( // foo should be unused\n): typeof foo {\n    return 1 as any;\n}\n\nfunction bar( // bar should be unused\n  _arg: typeof bar\n) {}\n\n\n--- if an interface is merged into a namespace  ---\n--- NOTE - TS gets these cases wrong\n\nnamespace Test {\n    interface Foo { // Foo should be unused here\n        a: string;\n    }\n    export namespace Foo {\n       export type T = 'b';\n    }\n}\ntype T = Test.Foo; // Error: Namespace 'Test' has no exported member 'Foo'.\n\n\nnamespace Test {\n    export interface Foo {\n        a: string;\n    }\n    namespace Foo { // Foo should be unused here\n       export type T = 'b';\n    }\n}\ntype T = Test.Foo.T; // Error: Namespace 'Test' has no exported member 'Foo'.\n\n---\n\nThese cases are mishandled because the base rule assumes that each variable has one def, but type-value shadowing\ncreates a variable with two defs\n\n--- type-only or value-only references to type/value shadowed variables ---\n--- NOTE - TS gets these cases wrong\n\ntype T = 1;\nconst T = 2; // this T should be unused\n\ntype U = T; // this U should be unused\nconst U = 3;\n\nconst _V = U;\n\n\n--- partially exported type/value shadowed variables ---\n--- NOTE - TS gets these cases wrong\n\nexport interface Foo {}\nconst Foo = 1; // this Foo should be unused\n\ninterface Bar {} // this Bar should be unused\nexport const Bar = 1;\n\n*/\n"
        }
    ]
}