{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/consistent-type-exports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891960749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'consistent-type-exports',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce consistent usage of type exports',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            multipleExportsAreTypes: 'Type exports {{exportNames}} are not values and should be exported using `export type`.',\n            singleExportIsType: 'Type export {{exportNames}} is not a value and should be exported using `export type`.',\n            typeOverValue: 'All exports in the declaration are only used as types. Use `export type`.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    fixMixedExportsWithInlineTypeSpecifier: {\n                        type: 'boolean',\n                        description: 'Whether the rule will autofix \"mixed\" export cases using TS inline type specifiers.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            fixMixedExportsWithInlineTypeSpecifier: false,\n        },\n    ],\n    create(context, [{ fixMixedExportsWithInlineTypeSpecifier }]) {\n        const sourceExportsMap = {};\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        /**\n         * Helper for identifying if a symbol resolves to a\n         * JavaScript value or a TypeScript type.\n         *\n         * @returns True/false if is a type or not, or undefined if the specifier\n         * can't be resolved.\n         */\n        function isSymbolTypeBased(symbol) {\n            if (!symbol) {\n                return undefined;\n            }\n            const aliasedSymbol = tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)\n                ? checker.getAliasedSymbol(symbol)\n                : symbol;\n            if (checker.isUnknownSymbol(aliasedSymbol)) {\n                return undefined;\n            }\n            return !(aliasedSymbol.flags & ts.SymbolFlags.Value);\n        }\n        return {\n            ExportAllDeclaration(node) {\n                if (node.exportKind === 'type') {\n                    return;\n                }\n                const sourceModule = ts.resolveModuleName(node.source.value, context.filename, services.program.getCompilerOptions(), ts.sys);\n                if (sourceModule.resolvedModule == null) {\n                    return;\n                }\n                const sourceFile = services.program.getSourceFile(sourceModule.resolvedModule.resolvedFileName);\n                if (sourceFile == null) {\n                    return;\n                }\n                const sourceFileSymbol = checker.getSymbolAtLocation(sourceFile);\n                if (sourceFileSymbol == null) {\n                    return;\n                }\n                const sourceFileType = checker.getTypeOfSymbol(sourceFileSymbol);\n                // Module can explicitly export types or values, and it's not difficult\n                // to distinguish one from the other, since we can get the flags of\n                // the exported symbols or check if symbol export declaration has\n                // the \"type\" keyword in it.\n                //\n                // Things get a lot more complicated when we're dealing with\n                // export * from './module-with-type-only-exports'\n                // export type * from './module-with-type-and-value-exports'\n                //\n                // TS checker has an internal function getExportsOfModuleWorker that\n                // recursively visits all module exports, including \"export *\". It then\n                // puts type-only-star-exported symbols into the typeOnlyExportStarMap\n                // property of sourceFile's SymbolLinks. Since symbol links aren't\n                // exposed outside the checker, we cannot access it directly.\n                //\n                // Therefore, to filter out value properties, we use the following hack:\n                // checker.getPropertiesOfType returns all exports that were originally\n                // values, but checker.getPropertyOfType returns undefined for\n                // properties that are mentioned in the typeOnlyExportStarMap.\n                const isThereAnyExportedValue = checker\n                    .getPropertiesOfType(sourceFileType)\n                    .some(propertyTypeSymbol => checker.getPropertyOfType(sourceFileType, propertyTypeSymbol.escapedName.toString()) != null);\n                if (isThereAnyExportedValue) {\n                    return;\n                }\n                context.report({\n                    node,\n                    messageId: 'typeOverValue',\n                    fix(fixer) {\n                        const asteriskToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator &&\n                            token.value === '*'), util_1.NullThrowsReasons.MissingToken('asterisk', 'export all declaration'));\n                        return fixer.insertTextBefore(asteriskToken, 'type ');\n                    },\n                });\n            },\n            ExportNamedDeclaration(node) {\n                // Coerce the source into a string for use as a lookup entry.\n                const source = getSourceFromExport(node) ?? 'undefined';\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                const sourceExports = (sourceExportsMap[source] ||= {\n                    reportValueExports: [],\n                    source,\n                    typeOnlyNamedExport: null,\n                    valueOnlyNamedExport: null,\n                });\n                // Cache the first encountered exports for the package. We will need to come\n                // back to these later when fixing the problems.\n                if (node.exportKind === 'type') {\n                    if (sourceExports.typeOnlyNamedExport == null) {\n                        // The export is a type export\n                        sourceExports.typeOnlyNamedExport = node;\n                    }\n                }\n                else if (sourceExports.valueOnlyNamedExport == null) {\n                    // The export is a value export\n                    sourceExports.valueOnlyNamedExport = node;\n                }\n                // Next for the current export, we will separate type/value specifiers.\n                const typeBasedSpecifiers = [];\n                const inlineTypeSpecifiers = [];\n                const valueSpecifiers = [];\n                // Note: it is valid to export values as types. We will avoid reporting errors\n                // when this is encountered.\n                if (node.exportKind !== 'type') {\n                    for (const specifier of node.specifiers) {\n                        if (specifier.exportKind === 'type') {\n                            inlineTypeSpecifiers.push(specifier);\n                            continue;\n                        }\n                        const isTypeBased = isSymbolTypeBased(services.getSymbolAtLocation(specifier.exported));\n                        if (isTypeBased === true) {\n                            typeBasedSpecifiers.push(specifier);\n                        }\n                        else if (isTypeBased === false) {\n                            // When isTypeBased is undefined, we should avoid reporting them.\n                            valueSpecifiers.push(specifier);\n                        }\n                    }\n                }\n                if ((node.exportKind === 'value' && typeBasedSpecifiers.length) ||\n                    (node.exportKind === 'type' && valueSpecifiers.length)) {\n                    sourceExports.reportValueExports.push({\n                        node,\n                        inlineTypeSpecifiers,\n                        typeBasedSpecifiers,\n                        valueSpecifiers,\n                    });\n                }\n            },\n            'Program:exit'() {\n                for (const sourceExports of Object.values(sourceExportsMap)) {\n                    // If this export has no issues, move on.\n                    if (sourceExports.reportValueExports.length === 0) {\n                        continue;\n                    }\n                    for (const report of sourceExports.reportValueExports) {\n                        if (report.valueSpecifiers.length === 0) {\n                            // Export is all type-only with no type specifiers; convert the entire export to `export type`.\n                            context.report({\n                                node: report.node,\n                                messageId: 'typeOverValue',\n                                *fix(fixer) {\n                                    yield* fixExportInsertType(fixer, context.sourceCode, report.node);\n                                },\n                            });\n                            continue;\n                        }\n                        // We have both type and value violations.\n                        const allExportNames = report.typeBasedSpecifiers.map(specifier => specifier.local.type === utils_1.AST_NODE_TYPES.Identifier\n                            ? specifier.local.name\n                            : specifier.local.value);\n                        if (allExportNames.length === 1) {\n                            const exportNames = allExportNames[0];\n                            context.report({\n                                node: report.node,\n                                messageId: 'singleExportIsType',\n                                data: { exportNames },\n                                *fix(fixer) {\n                                    if (fixMixedExportsWithInlineTypeSpecifier) {\n                                        yield* fixAddTypeSpecifierToNamedExports(fixer, report);\n                                    }\n                                    else {\n                                        yield* fixSeparateNamedExports(fixer, context.sourceCode, report);\n                                    }\n                                },\n                            });\n                        }\n                        else {\n                            const exportNames = (0, util_1.formatWordList)(allExportNames);\n                            context.report({\n                                node: report.node,\n                                messageId: 'multipleExportsAreTypes',\n                                data: { exportNames },\n                                *fix(fixer) {\n                                    if (fixMixedExportsWithInlineTypeSpecifier) {\n                                        yield* fixAddTypeSpecifierToNamedExports(fixer, report);\n                                    }\n                                    else {\n                                        yield* fixSeparateNamedExports(fixer, context.sourceCode, report);\n                                    }\n                                },\n                            });\n                        }\n                    }\n                }\n            },\n        };\n    },\n});\n/**\n * Inserts \"type\" into an export.\n *\n * Example:\n *\n * export type { Foo } from 'foo';\n *        ^^^^\n */\nfunction* fixExportInsertType(fixer, sourceCode, node) {\n    const exportToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(node), util_1.NullThrowsReasons.MissingToken('export', node.type));\n    yield fixer.insertTextAfter(exportToken, ' type');\n    for (const specifier of node.specifiers) {\n        if (specifier.exportKind === 'type') {\n            const kindToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(specifier), util_1.NullThrowsReasons.MissingToken('export', specifier.type));\n            const firstTokenAfter = (0, util_1.nullThrows)(sourceCode.getTokenAfter(kindToken, {\n                includeComments: true,\n            }), 'Missing token following the export kind.');\n            yield fixer.removeRange([kindToken.range[0], firstTokenAfter.range[0]]);\n        }\n    }\n}\n/**\n * Separates the exports which mismatch the kind of export the given\n * node represents. For example, a type export's named specifiers which\n * represent values will be inserted in a separate `export` statement.\n */\nfunction* fixSeparateNamedExports(fixer, sourceCode, report) {\n    const { node, inlineTypeSpecifiers, typeBasedSpecifiers, valueSpecifiers } = report;\n    const typeSpecifiers = [...typeBasedSpecifiers, ...inlineTypeSpecifiers];\n    const source = getSourceFromExport(node);\n    const specifierNames = typeSpecifiers.map(getSpecifierText).join(', ');\n    const exportToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(node), util_1.NullThrowsReasons.MissingToken('export', node.type));\n    // Filter the bad exports from the current line.\n    const filteredSpecifierNames = valueSpecifiers\n        .map(getSpecifierText)\n        .join(', ');\n    const openToken = (0, util_1.nullThrows)(sourceCode.getFirstToken(node, util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken('{', node.type));\n    const closeToken = (0, util_1.nullThrows)(sourceCode.getLastToken(node, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', node.type));\n    // Remove exports from the current line which we're going to re-insert.\n    yield fixer.replaceTextRange([openToken.range[1], closeToken.range[0]], ` ${filteredSpecifierNames} `);\n    // Insert the bad exports into a new export line above.\n    yield fixer.insertTextBefore(exportToken, `export type { ${specifierNames} }${source ? ` from '${source}'` : ''};\\n`);\n}\nfunction* fixAddTypeSpecifierToNamedExports(fixer, report) {\n    if (report.node.exportKind === 'type') {\n        return;\n    }\n    for (const specifier of report.typeBasedSpecifiers) {\n        yield fixer.insertTextBefore(specifier, 'type ');\n    }\n}\n/**\n * Returns the source of the export, or undefined if the named export has no source.\n */\nfunction getSourceFromExport(node) {\n    if (node.source?.type === utils_1.AST_NODE_TYPES.Literal &&\n        typeof node.source.value === 'string') {\n        return node.source.value;\n    }\n    return undefined;\n}\n/**\n * Returns the specifier text for the export. If it is aliased, we take care to return\n * the proper formatting.\n */\nfunction getSpecifierText(specifier) {\n    const exportedName = specifier.exported.type === utils_1.AST_NODE_TYPES.Literal\n        ? specifier.exported.raw\n        : specifier.exported.name;\n    const localName = specifier.local.type === utils_1.AST_NODE_TYPES.Literal\n        ? specifier.local.raw\n        : specifier.local.name;\n    return `${localName}${exportedName !== localName ? ` as ${exportedName}` : ''}`;\n}\n"
        }
    ]
}