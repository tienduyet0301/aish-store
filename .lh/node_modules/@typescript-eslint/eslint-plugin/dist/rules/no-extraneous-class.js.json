{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-extraneous-class.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891964851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-extraneous-class',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow classes used as namespaces',\n            recommended: 'strict',\n        },\n        messages: {\n            empty: 'Unexpected empty class.',\n            onlyConstructor: 'Unexpected class with only a constructor.',\n            onlyStatic: 'Unexpected class with only static properties.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowConstructorOnly: {\n                        type: 'boolean',\n                        description: 'Whether to allow extraneous classes that contain only a constructor.',\n                    },\n                    allowEmpty: {\n                        type: 'boolean',\n                        description: 'Whether to allow extraneous classes that have no body (i.e. are empty).',\n                    },\n                    allowStaticOnly: {\n                        type: 'boolean',\n                        description: 'Whether to allow extraneous classes that only contain static members.',\n                    },\n                    allowWithDecorator: {\n                        type: 'boolean',\n                        description: 'Whether to allow extraneous classes that include a decorator.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowConstructorOnly: false,\n            allowEmpty: false,\n            allowStaticOnly: false,\n            allowWithDecorator: false,\n        },\n    ],\n    create(context, [{ allowConstructorOnly, allowEmpty, allowStaticOnly, allowWithDecorator }]) {\n        const isAllowWithDecorator = (node) => {\n            return !!(allowWithDecorator &&\n                node?.decorators &&\n                node.decorators.length !== 0);\n        };\n        return {\n            ClassBody(node) {\n                const parent = node.parent;\n                if (parent.superClass || isAllowWithDecorator(parent)) {\n                    return;\n                }\n                const reportNode = parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration && parent.id\n                    ? parent.id\n                    : parent;\n                if (node.body.length === 0) {\n                    if (allowEmpty) {\n                        return;\n                    }\n                    context.report({\n                        node: reportNode,\n                        messageId: 'empty',\n                    });\n                    return;\n                }\n                let onlyStatic = true;\n                let onlyConstructor = true;\n                for (const prop of node.body) {\n                    if (prop.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n                        prop.kind === 'constructor') {\n                        if (prop.value.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSParameterProperty)) {\n                            onlyConstructor = false;\n                            onlyStatic = false;\n                        }\n                    }\n                    else {\n                        onlyConstructor = false;\n                        if (((prop.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||\n                            prop.type === utils_1.AST_NODE_TYPES.MethodDefinition ||\n                            prop.type === utils_1.AST_NODE_TYPES.AccessorProperty) &&\n                            !prop.static) ||\n                            prop.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||\n                            prop.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition || // `static abstract` methods and properties are currently not supported. See: https://github.com/microsoft/TypeScript/issues/34516\n                            prop.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty) {\n                            onlyStatic = false;\n                        }\n                    }\n                    if (!(onlyStatic || onlyConstructor)) {\n                        break;\n                    }\n                }\n                if (onlyConstructor) {\n                    if (!allowConstructorOnly) {\n                        context.report({\n                            node: reportNode,\n                            messageId: 'onlyConstructor',\n                        });\n                    }\n                    return;\n                }\n                if (onlyStatic && !allowStaticOnly) {\n                    context.report({\n                        node: reportNode,\n                        messageId: 'onlyStatic',\n                    });\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}