{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-floating-promises.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891965028,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst messageBase = 'Promises must be awaited, end with a call to .catch, or end with a call to .then with a rejection handler.';\nconst messageBaseVoid = 'Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler' +\n    ' or be explicitly marked as ignored with the `void` operator.';\nconst messageRejectionHandler = 'A rejection handler that is not a function will be ignored.';\nconst messagePromiseArray = \"An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar.\";\nconst messagePromiseArrayVoid = \"An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar,\" +\n    ' or explicitly marking the expression as ignored with the `void` operator.';\nexports.default = (0, util_1.createRule)({\n    name: 'no-floating-promises',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Require Promise-like statements to be handled appropriately',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            floating: messageBase,\n            floatingFixAwait: 'Add await operator.',\n            floatingFixVoid: 'Add void operator to ignore.',\n            floatingPromiseArray: messagePromiseArray,\n            floatingPromiseArrayVoid: messagePromiseArrayVoid,\n            floatingUselessRejectionHandler: `${messageBase} ${messageRejectionHandler}`,\n            floatingUselessRejectionHandlerVoid: `${messageBaseVoid} ${messageRejectionHandler}`,\n            floatingVoid: messageBaseVoid,\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowForKnownSafeCalls: {\n                        ...util_1.readonlynessOptionsSchema.properties.allow,\n                        description: 'Type specifiers of functions whose calls are safe to float.',\n                    },\n                    allowForKnownSafePromises: {\n                        ...util_1.readonlynessOptionsSchema.properties.allow,\n                        description: 'Type specifiers that are known to be safe to float.',\n                    },\n                    checkThenables: {\n                        type: 'boolean',\n                        description: 'Whether to check all \"Thenable\"s, not just the built-in Promise type.',\n                    },\n                    ignoreIIFE: {\n                        type: 'boolean',\n                        description: 'Whether to ignore async IIFEs (Immediately Invoked Function Expressions).',\n                    },\n                    ignoreVoid: {\n                        type: 'boolean',\n                        description: 'Whether to ignore `void` expressions.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowForKnownSafeCalls: util_1.readonlynessOptionsDefaults.allow,\n            allowForKnownSafePromises: util_1.readonlynessOptionsDefaults.allow,\n            checkThenables: false,\n            ignoreIIFE: false,\n            ignoreVoid: true,\n        },\n    ],\n    create(context, [options]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const { checkThenables } = options;\n        // TODO: #5439\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        const allowForKnownSafePromises = options.allowForKnownSafePromises;\n        const allowForKnownSafeCalls = options.allowForKnownSafeCalls;\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        return {\n            ExpressionStatement(node) {\n                if (options.ignoreIIFE && isAsyncIife(node)) {\n                    return;\n                }\n                const expression = (0, util_1.skipChainExpression)(node.expression);\n                if (isKnownSafePromiseReturn(expression)) {\n                    return;\n                }\n                const { isUnhandled, nonFunctionHandler, promiseArray } = isUnhandledPromise(checker, expression);\n                if (isUnhandled) {\n                    if (promiseArray) {\n                        context.report({\n                            node,\n                            messageId: options.ignoreVoid\n                                ? 'floatingPromiseArrayVoid'\n                                : 'floatingPromiseArray',\n                        });\n                    }\n                    else if (options.ignoreVoid) {\n                        context.report({\n                            node,\n                            messageId: nonFunctionHandler\n                                ? 'floatingUselessRejectionHandlerVoid'\n                                : 'floatingVoid',\n                            suggest: [\n                                {\n                                    messageId: 'floatingFixVoid',\n                                    fix(fixer) {\n                                        const tsNode = services.esTreeNodeToTSNodeMap.get(node.expression);\n                                        if (isHigherPrecedenceThanUnary(tsNode)) {\n                                            return fixer.insertTextBefore(node, 'void ');\n                                        }\n                                        return [\n                                            fixer.insertTextBefore(node, 'void ('),\n                                            fixer.insertTextAfterRange([expression.range[1], expression.range[1]], ')'),\n                                        ];\n                                    },\n                                },\n                                {\n                                    messageId: 'floatingFixAwait',\n                                    fix: (fixer) => addAwait(fixer, expression, node),\n                                },\n                            ],\n                        });\n                    }\n                    else {\n                        context.report({\n                            node,\n                            messageId: nonFunctionHandler\n                                ? 'floatingUselessRejectionHandler'\n                                : 'floating',\n                            suggest: [\n                                {\n                                    messageId: 'floatingFixAwait',\n                                    fix: (fixer) => addAwait(fixer, expression, node),\n                                },\n                            ],\n                        });\n                    }\n                }\n            },\n        };\n        function addAwait(fixer, expression, node) {\n            if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                expression.operator === 'void') {\n                return fixer.replaceTextRange([expression.range[0], expression.range[0] + 4], 'await');\n            }\n            const tsNode = services.esTreeNodeToTSNodeMap.get(node.expression);\n            if (isHigherPrecedenceThanUnary(tsNode)) {\n                return fixer.insertTextBefore(node, 'await ');\n            }\n            return [\n                fixer.insertTextBefore(node, 'await ('),\n                fixer.insertTextAfterRange([expression.range[1], expression.range[1]], ')'),\n            ];\n        }\n        function isKnownSafePromiseReturn(node) {\n            if (node.type !== utils_1.AST_NODE_TYPES.CallExpression) {\n                return false;\n            }\n            const type = services.getTypeAtLocation(node.callee);\n            return (0, util_1.typeMatchesSomeSpecifier)(type, allowForKnownSafeCalls, services.program);\n        }\n        function isHigherPrecedenceThanUnary(node) {\n            const operator = ts.isBinaryExpression(node)\n                ? node.operatorToken.kind\n                : ts.SyntaxKind.Unknown;\n            const nodePrecedence = (0, util_1.getOperatorPrecedence)(node.kind, operator);\n            return nodePrecedence > util_1.OperatorPrecedence.Unary;\n        }\n        function isAsyncIife(node) {\n            if (node.expression.type !== utils_1.AST_NODE_TYPES.CallExpression) {\n                return false;\n            }\n            return (node.expression.callee.type ===\n                utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||\n                node.expression.callee.type === utils_1.AST_NODE_TYPES.FunctionExpression);\n        }\n        function isValidRejectionHandler(rejectionHandler) {\n            return (services.program\n                .getTypeChecker()\n                .getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(rejectionHandler))\n                .getCallSignatures().length > 0);\n        }\n        function isUnhandledPromise(checker, node) {\n            if (node.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {\n                return { isUnhandled: false };\n            }\n            // First, check expressions whose resulting types may not be promise-like\n            if (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n                // Any child in a comma expression could return a potentially unhandled\n                // promise, so we check them all regardless of whether the final returned\n                // value is promise-like.\n                return (node.expressions\n                    .map(item => isUnhandledPromise(checker, item))\n                    .find(result => result.isUnhandled) ?? { isUnhandled: false });\n            }\n            if (!options.ignoreVoid &&\n                node.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                node.operator === 'void') {\n                // Similarly, a `void` expression always returns undefined, so we need to\n                // see what's inside it without checking the type of the overall expression.\n                return isUnhandledPromise(checker, node.argument);\n            }\n            const tsNode = services.esTreeNodeToTSNodeMap.get(node);\n            // Check the type. At this point it can't be unhandled if it isn't a promise\n            // or array thereof.\n            if (isPromiseArray(tsNode)) {\n                return { isUnhandled: true, promiseArray: true };\n            }\n            // await expression addresses promises, but not promise arrays.\n            if (node.type === utils_1.AST_NODE_TYPES.AwaitExpression) {\n                // you would think this wouldn't be strictly necessary, since we're\n                // anyway checking the type of the expression, but, unfortunately TS\n                // reports the result of `await (promise as Promise<number> & number)`\n                // as `Promise<number> & number` instead of `number`.\n                return { isUnhandled: false };\n            }\n            if (!isPromiseLike(tsNode)) {\n                return { isUnhandled: false };\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n                // If the outer expression is a call, a `.catch()` or `.then()` with\n                // rejection handler handles the promise.\n                const { callee } = node;\n                if (callee.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n                    const methodName = (0, util_1.getStaticMemberAccessValue)(callee, context);\n                    const catchRejectionHandler = methodName === 'catch' && node.arguments.length >= 1\n                        ? node.arguments[0]\n                        : undefined;\n                    if (catchRejectionHandler) {\n                        if (isValidRejectionHandler(catchRejectionHandler)) {\n                            return { isUnhandled: false };\n                        }\n                        return { isUnhandled: true, nonFunctionHandler: true };\n                    }\n                    const thenRejectionHandler = methodName === 'then' && node.arguments.length >= 2\n                        ? node.arguments[1]\n                        : undefined;\n                    if (thenRejectionHandler) {\n                        if (isValidRejectionHandler(thenRejectionHandler)) {\n                            return { isUnhandled: false };\n                        }\n                        return { isUnhandled: true, nonFunctionHandler: true };\n                    }\n                    // `x.finally()` is transparent to resolution of the promise, so check `x`.\n                    // (\"object\" in this context is the `x` in `x.finally()`)\n                    const promiseFinallyObject = methodName === 'finally' ? callee.object : undefined;\n                    if (promiseFinallyObject) {\n                        return isUnhandledPromise(checker, promiseFinallyObject);\n                    }\n                }\n                // All other cases are unhandled.\n                return { isUnhandled: true };\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n                // We must be getting the promise-like value from one of the branches of the\n                // ternary. Check them directly.\n                const alternateResult = isUnhandledPromise(checker, node.alternate);\n                if (alternateResult.isUnhandled) {\n                    return alternateResult;\n                }\n                return isUnhandledPromise(checker, node.consequent);\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n                const leftResult = isUnhandledPromise(checker, node.left);\n                if (leftResult.isUnhandled) {\n                    return leftResult;\n                }\n                return isUnhandledPromise(checker, node.right);\n            }\n            // Anything else is unhandled.\n            return { isUnhandled: true };\n        }\n        function isPromiseArray(node) {\n            const type = checker.getTypeAtLocation(node);\n            for (const ty of tsutils\n                .unionTypeParts(type)\n                .map(t => checker.getApparentType(t))) {\n                if (checker.isArrayType(ty)) {\n                    const arrayType = checker.getTypeArguments(ty)[0];\n                    if (isPromiseLike(node, arrayType)) {\n                        return true;\n                    }\n                }\n                if (checker.isTupleType(ty)) {\n                    for (const tupleElementType of checker.getTypeArguments(ty)) {\n                        if (isPromiseLike(node, tupleElementType)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        function isPromiseLike(node, type) {\n            type ??= checker.getTypeAtLocation(node);\n            // The highest priority is to allow anything allowlisted\n            if ((0, util_1.typeMatchesSomeSpecifier)(type, allowForKnownSafePromises, services.program)) {\n                return false;\n            }\n            // Otherwise, we always consider the built-in Promise to be Promise-like...\n            const typeParts = tsutils.unionTypeParts(checker.getApparentType(type));\n            if (typeParts.some(typePart => (0, util_1.isBuiltinSymbolLike)(services.program, typePart, 'Promise'))) {\n                return true;\n            }\n            // ...and only check all Thenables if explicitly told to\n            if (!checkThenables) {\n                return false;\n            }\n            // Modified from tsutils.isThenable() to only consider thenables which can be\n            // rejected/caught via a second parameter. Original source (MIT licensed):\n            //\n            //   https://github.com/ajafff/tsutils/blob/49d0d31050b44b81e918eae4fbaf1dfe7b7286af/util/type.ts#L95-L125\n            for (const ty of typeParts) {\n                const then = ty.getProperty('then');\n                if (then == null) {\n                    continue;\n                }\n                const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n                if (hasMatchingSignature(thenType, signature => signature.parameters.length >= 2 &&\n                    isFunctionParam(checker, signature.parameters[0], node) &&\n                    isFunctionParam(checker, signature.parameters[1], node))) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n});\nfunction hasMatchingSignature(type, matcher) {\n    for (const t of tsutils.unionTypeParts(type)) {\n        if (t.getCallSignatures().some(matcher)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isFunctionParam(checker, param, node) {\n    const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n    for (const t of tsutils.unionTypeParts(type)) {\n        if (t.getCallSignatures().length !== 0) {\n            return true;\n        }\n    }\n    return false;\n}\n"
        }
    ]
}