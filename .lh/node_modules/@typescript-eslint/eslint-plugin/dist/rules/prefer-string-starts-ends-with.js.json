{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-string-starts-ends-with.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891974337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst regexpp_1 = require(\"@eslint-community/regexpp\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst EQ_OPERATORS = /^[=!]=/;\nconst regexpp = new regexpp_1.RegExpParser();\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-string-starts-ends-with',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings',\n            recommended: 'stylistic',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            preferEndsWith: \"Use the 'String#endsWith' method instead.\",\n            preferStartsWith: \"Use 'String#startsWith' method instead.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowSingleElementEquality: {\n                        type: 'string',\n                        description: 'Whether to allow equality checks against the first or last element of a string.',\n                        enum: ['always', 'never'],\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [{ allowSingleElementEquality: 'never' }],\n    create(context, [{ allowSingleElementEquality }]) {\n        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        /**\n         * Check if a given node is a string.\n         * @param node The node to check.\n         */\n        function isStringType(node) {\n            const objectType = services.getTypeAtLocation(node);\n            return (0, util_1.getTypeName)(checker, objectType) === 'string';\n        }\n        /**\n         * Check if a given node is a `Literal` node that is null.\n         * @param node The node to check.\n         */\n        function isNull(node) {\n            const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n            return evaluated != null && evaluated.value == null;\n        }\n        /**\n         * Check if a given node is a `Literal` node that is a given value.\n         * @param node The node to check.\n         * @param value The expected value of the `Literal` node.\n         */\n        function isNumber(node, value) {\n            const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n            return evaluated != null && evaluated.value === value;\n        }\n        /**\n         * Check if a given node is a `Literal` node that is a character.\n         * @param node The node to check.\n         */\n        function isCharacter(node) {\n            const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n            return (evaluated != null &&\n                typeof evaluated.value === 'string' &&\n                // checks if the string is a character long\n                evaluated.value[0] === evaluated.value);\n        }\n        /**\n         * Check if a given node is `==`, `===`, `!=`, or `!==`.\n         * @param node The node to check.\n         */\n        function isEqualityComparison(node) {\n            return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &&\n                EQ_OPERATORS.test(node.operator));\n        }\n        /**\n         * Check if two given nodes are the same meaning.\n         * @param node1 A node to compare.\n         * @param node2 Another node to compare.\n         */\n        function isSameTokens(node1, node2) {\n            const tokens1 = context.sourceCode.getTokens(node1);\n            const tokens2 = context.sourceCode.getTokens(node2);\n            if (tokens1.length !== tokens2.length) {\n                return false;\n            }\n            for (let i = 0; i < tokens1.length; ++i) {\n                const token1 = tokens1[i];\n                const token2 = tokens2[i];\n                if (token1.type !== token2.type || token1.value !== token2.value) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Check if a given node is the expression of the length of a string.\n         *\n         * - If `length` property access of `expectedObjectNode`, it's `true`.\n         *   E.g., `foo` → `foo.length` / `\"foo\"` → `\"foo\".length`\n         * - If `expectedObjectNode` is a string literal, `node` can be a number.\n         *   E.g., `\"foo\"` → `3`\n         *\n         * @param node The node to check.\n         * @param expectedObjectNode The node which is expected as the receiver of `length` property.\n         */\n        function isLengthExpression(node, expectedObjectNode) {\n            if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n                return ((0, util_1.getPropertyName)(node, globalScope) === 'length' &&\n                    isSameTokens(node.object, expectedObjectNode));\n            }\n            const evaluatedLength = (0, util_1.getStaticValue)(node, globalScope);\n            const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, globalScope);\n            return (evaluatedLength != null &&\n                evaluatedString != null &&\n                typeof evaluatedLength.value === 'number' &&\n                typeof evaluatedString.value === 'string' &&\n                evaluatedLength.value === evaluatedString.value.length);\n        }\n        /**\n         * Returns true if `node` is `-substring.length` or\n         * `parentString.length - substring.length`\n         */\n        function isLengthAheadOfEnd(node, substring, parentString) {\n            return ((node.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                node.operator === '-' &&\n                isLengthExpression(node.argument, substring)) ||\n                (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &&\n                    node.operator === '-' &&\n                    isLengthExpression(node.left, parentString) &&\n                    isLengthExpression(node.right, substring)));\n        }\n        /**\n         * Check if a given node is the expression of the last index.\n         *\n         * E.g. `foo.length - 1`\n         *\n         * @param node The node to check.\n         * @param expectedObjectNode The node which is expected as the receiver of `length` property.\n         */\n        function isLastIndexExpression(node, expectedObjectNode) {\n            return (node.type === utils_1.AST_NODE_TYPES.BinaryExpression &&\n                node.operator === '-' &&\n                isLengthExpression(node.left, expectedObjectNode) &&\n                isNumber(node.right, 1));\n        }\n        /**\n         * Get the range of the property of a given `MemberExpression` node.\n         *\n         * - `obj[foo]` → the range of `[foo]`\n         * - `obf.foo` → the range of `.foo`\n         * - `(obj).foo` → the range of `.foo`\n         *\n         * @param node The member expression node to get.\n         */\n        function getPropertyRange(node) {\n            const dotOrOpenBracket = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken), util_1.NullThrowsReasons.MissingToken('closing parenthesis', 'member'));\n            return [dotOrOpenBracket.range[0], node.range[1]];\n        }\n        /**\n         * Parse a given `RegExp` pattern to that string if it's a static string.\n         * @param pattern The RegExp pattern text to parse.\n         * @param unicode Whether the RegExp is unicode.\n         */\n        function parseRegExpText(pattern, unicode) {\n            // Parse it.\n            const ast = regexpp.parsePattern(pattern, undefined, undefined, {\n                unicode,\n            });\n            if (ast.alternatives.length !== 1) {\n                return null;\n            }\n            // Drop `^`/`$` assertion.\n            const chars = ast.alternatives[0].elements;\n            const first = chars[0];\n            if (first.type === 'Assertion' && first.kind === 'start') {\n                chars.shift();\n            }\n            else {\n                chars.pop();\n            }\n            // Check if it can determine a unique string.\n            if (!chars.every(c => c.type === 'Character')) {\n                return null;\n            }\n            // To string.\n            return String.fromCodePoint(...chars.map(c => c.value));\n        }\n        /**\n         * Parse a given node if it's a `RegExp` instance.\n         * @param node The node to parse.\n         */\n        function parseRegExp(node) {\n            const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n            if (evaluated == null || !(evaluated.value instanceof RegExp)) {\n                return null;\n            }\n            const { flags, source } = evaluated.value;\n            const isStartsWith = source.startsWith('^');\n            const isEndsWith = source.endsWith('$');\n            if (isStartsWith === isEndsWith ||\n                flags.includes('i') ||\n                flags.includes('m')) {\n                return null;\n            }\n            const text = parseRegExpText(source, flags.includes('u'));\n            if (text == null) {\n                return null;\n            }\n            return { isEndsWith, isStartsWith, text };\n        }\n        function getLeftNode(init) {\n            const node = (0, util_1.skipChainExpression)(init);\n            const leftNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node;\n            if (leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n                throw new Error(`Expected a MemberExpression, got ${leftNode.type}`);\n            }\n            return leftNode;\n        }\n        /**\n         * Fix code with using the right operand as the search string.\n         * For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')`\n         * @param fixer The rule fixer.\n         * @param node The node which was reported.\n         * @param kind The kind of the report.\n         * @param isNegative The flag to fix to negative condition.\n         */\n        function* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {\n            // left is CallExpression or MemberExpression.\n            const leftNode = getLeftNode(node.left);\n            const propertyRange = getPropertyRange(leftNode);\n            if (isNegative) {\n                yield fixer.insertTextBefore(node, '!');\n            }\n            yield fixer.replaceTextRange([propertyRange[0], node.right.range[0]], `${isOptional ? '?.' : '.'}${kind}sWith(`);\n            yield fixer.replaceTextRange([node.right.range[1], node.range[1]], ')');\n        }\n        /**\n         * Fix code with using the first argument as the search string.\n         * For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')`\n         * @param fixer The rule fixer.\n         * @param node The node which was reported.\n         * @param kind The kind of the report.\n         * @param negative The flag to fix to negative condition.\n         */\n        function* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {\n            if (negative) {\n                yield fixer.insertTextBefore(node, '!');\n            }\n            yield fixer.replaceTextRange(getPropertyRange(calleeNode), `${isOptional ? '?.' : '.'}${kind}sWith`);\n            yield fixer.removeRange([callNode.range[1], node.range[1]]);\n        }\n        function getParent(node) {\n            return (0, util_1.nullThrows)(node.parent?.type === utils_1.AST_NODE_TYPES.ChainExpression\n                ? node.parent.parent\n                : node.parent, util_1.NullThrowsReasons.MissingParent);\n        }\n        return {\n            // foo[0] === \"a\"\n            // foo.charAt(0) === \"a\"\n            // foo[foo.length - 1] === \"a\"\n            // foo.charAt(foo.length - 1) === \"a\"\n            [[\n                'BinaryExpression > MemberExpression.left[computed=true]',\n                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"charAt\"][computed=false]',\n                'BinaryExpression > ChainExpression.left > MemberExpression[computed=true]',\n                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"charAt\"][computed=false]',\n            ].join(', ')](node) {\n                let parentNode = getParent(node);\n                let indexNode = null;\n                if (parentNode.type === utils_1.AST_NODE_TYPES.CallExpression) {\n                    if (parentNode.arguments.length === 1) {\n                        indexNode = parentNode.arguments[0];\n                    }\n                    parentNode = getParent(parentNode);\n                }\n                else {\n                    indexNode = node.property;\n                }\n                if (indexNode == null ||\n                    !isEqualityComparison(parentNode) ||\n                    !isStringType(node.object)) {\n                    return;\n                }\n                const isEndsWith = isLastIndexExpression(indexNode, node.object);\n                if (allowSingleElementEquality === 'always' && isEndsWith) {\n                    return;\n                }\n                const isStartsWith = !isEndsWith && isNumber(indexNode, 0);\n                if ((allowSingleElementEquality === 'always' && isStartsWith) ||\n                    (!isStartsWith && !isEndsWith)) {\n                    return;\n                }\n                const eqNode = parentNode;\n                context.report({\n                    node: parentNode,\n                    messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n                    fix(fixer) {\n                        // Don't fix if it can change the behavior.\n                        if (!isCharacter(eqNode.right)) {\n                            return null;\n                        }\n                        return fixWithRightOperand(fixer, eqNode, isStartsWith ? 'start' : 'end', eqNode.operator.startsWith('!'), node.optional);\n                    },\n                });\n            },\n            // foo.indexOf('bar') === 0\n            [[\n                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"indexOf\"][computed=false]',\n                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"indexOf\"][computed=false]',\n            ].join(', ')](node) {\n                const callNode = getParent(node);\n                const parentNode = getParent(callNode);\n                if (callNode.arguments.length !== 1 ||\n                    !isEqualityComparison(parentNode) ||\n                    !isNumber(parentNode.right, 0) ||\n                    !isStringType(node.object)) {\n                    return;\n                }\n                context.report({\n                    node: parentNode,\n                    messageId: 'preferStartsWith',\n                    fix(fixer) {\n                        return fixWithArgument(fixer, parentNode, callNode, node, 'start', parentNode.operator.startsWith('!'), node.optional);\n                    },\n                });\n            },\n            // foo.lastIndexOf('bar') === foo.length - 3\n            // foo.lastIndexOf(bar) === foo.length - bar.length\n            [[\n                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"lastIndexOf\"][computed=false]',\n                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"lastIndexOf\"][computed=false]',\n            ].join(', ')](node) {\n                const callNode = getParent(node);\n                const parentNode = getParent(callNode);\n                if (callNode.arguments.length !== 1 ||\n                    !isEqualityComparison(parentNode) ||\n                    parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression ||\n                    parentNode.right.operator !== '-' ||\n                    !isLengthExpression(parentNode.right.left, node.object) ||\n                    !isLengthExpression(parentNode.right.right, callNode.arguments[0]) ||\n                    !isStringType(node.object)) {\n                    return;\n                }\n                context.report({\n                    node: parentNode,\n                    messageId: 'preferEndsWith',\n                    fix(fixer) {\n                        return fixWithArgument(fixer, parentNode, callNode, node, 'end', parentNode.operator.startsWith('!'), node.optional);\n                    },\n                });\n            },\n            // foo.match(/^bar/) === null\n            // foo.match(/bar$/) === null\n            [[\n                'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"match\"][computed=false]',\n                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"match\"][computed=false]',\n            ].join(', ')](node) {\n                const callNode = getParent(node);\n                const parentNode = getParent(callNode);\n                if (!isNull(parentNode.right) || !isStringType(node.object)) {\n                    return;\n                }\n                const parsed = callNode.arguments.length === 1\n                    ? parseRegExp(callNode.arguments[0])\n                    : null;\n                if (parsed == null) {\n                    return;\n                }\n                const { isStartsWith, text } = parsed;\n                context.report({\n                    node: callNode,\n                    messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n                    *fix(fixer) {\n                        if (!parentNode.operator.startsWith('!')) {\n                            yield fixer.insertTextBefore(parentNode, '!');\n                        }\n                        yield fixer.replaceTextRange(getPropertyRange(node), `${node.optional ? '?.' : '.'}${isStartsWith ? 'start' : 'end'}sWith`);\n                        yield fixer.replaceText(callNode.arguments[0], JSON.stringify(text));\n                        yield fixer.removeRange([callNode.range[1], parentNode.range[1]]);\n                    },\n                });\n            },\n            // foo.slice(0, 3) === 'bar'\n            // foo.slice(-3) === 'bar'\n            // foo.slice(-3, foo.length) === 'bar'\n            // foo.substring(0, 3) === 'bar'\n            // foo.substring(foo.length - 3) === 'bar'\n            // foo.substring(foo.length - 3, foo.length) === 'bar'\n            [[\n                'BinaryExpression > CallExpression.left > MemberExpression',\n                'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression',\n            ].join(', ')](node) {\n                if (!(0, util_1.isStaticMemberAccessOfValue)(node, context, 'slice', 'substring')) {\n                    return;\n                }\n                const callNode = getParent(node);\n                const parentNode = getParent(callNode);\n                if (!isEqualityComparison(parentNode) || !isStringType(node.object)) {\n                    return;\n                }\n                let isEndsWith = false;\n                let isStartsWith = false;\n                if (callNode.arguments.length === 1) {\n                    if (\n                    // foo.slice(-bar.length) === bar\n                    // foo.slice(foo.length - bar.length) === bar\n                    isLengthAheadOfEnd(callNode.arguments[0], parentNode.right, node.object)) {\n                        isEndsWith = true;\n                    }\n                }\n                else if (callNode.arguments.length === 2) {\n                    if (\n                    // foo.slice(0, bar.length) === bar\n                    isNumber(callNode.arguments[0], 0) &&\n                        isLengthExpression(callNode.arguments[1], parentNode.right)) {\n                        isStartsWith = true;\n                    }\n                    else if (\n                    // foo.slice(foo.length - bar.length, foo.length) === bar\n                    // foo.slice(foo.length - bar.length, 0) === bar\n                    // foo.slice(-bar.length, foo.length) === bar\n                    // foo.slice(-bar.length, 0) === bar\n                    (isLengthExpression(callNode.arguments[1], node.object) ||\n                        isNumber(callNode.arguments[1], 0)) &&\n                        isLengthAheadOfEnd(callNode.arguments[0], parentNode.right, node.object)) {\n                        isEndsWith = true;\n                    }\n                }\n                if (!isStartsWith && !isEndsWith) {\n                    return;\n                }\n                const eqNode = parentNode;\n                const negativeIndexSupported = node.property.name === 'slice';\n                context.report({\n                    node: parentNode,\n                    messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n                    fix(fixer) {\n                        // Don't fix if it can change the behavior.\n                        if (eqNode.operator.length === 2 &&\n                            (eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal ||\n                                typeof eqNode.right.value !== 'string')) {\n                            return null;\n                        }\n                        // code being checked is likely mistake:\n                        // unequal length of strings being checked for equality\n                        // or reliant on behavior of substring (negative indices interpreted as 0)\n                        if (isStartsWith) {\n                            if (!isLengthExpression(callNode.arguments[1], eqNode.right)) {\n                                return null;\n                            }\n                        }\n                        else {\n                            const posNode = callNode.arguments[0];\n                            const posNodeIsAbsolutelyValid = (posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression &&\n                                posNode.operator === '-' &&\n                                isLengthExpression(posNode.left, node.object) &&\n                                isLengthExpression(posNode.right, eqNode.right)) ||\n                                (negativeIndexSupported &&\n                                    posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                                    posNode.operator === '-' &&\n                                    isLengthExpression(posNode.argument, eqNode.right));\n                            if (!posNodeIsAbsolutelyValid) {\n                                return null;\n                            }\n                        }\n                        return fixWithRightOperand(fixer, parentNode, isStartsWith ? 'start' : 'end', parentNode.operator.startsWith('!'), node.optional);\n                    },\n                });\n            },\n            // /^bar/.test(foo)\n            // /bar$/.test(foo)\n            'CallExpression > MemberExpression.callee[property.name=\"test\"][computed=false]'(node) {\n                const callNode = getParent(node);\n                const parsed = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;\n                if (parsed == null) {\n                    return;\n                }\n                const { isStartsWith, text } = parsed;\n                const messageId = isStartsWith ? 'preferStartsWith' : 'preferEndsWith';\n                const methodName = isStartsWith ? 'startsWith' : 'endsWith';\n                context.report({\n                    node: callNode,\n                    messageId,\n                    *fix(fixer) {\n                        const argNode = callNode.arguments[0];\n                        const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.Identifier &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;\n                        yield fixer.removeRange([callNode.range[0], argNode.range[0]]);\n                        if (needsParen) {\n                            yield fixer.insertTextBefore(argNode, '(');\n                            yield fixer.insertTextAfter(argNode, ')');\n                        }\n                        yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}${methodName}(${JSON.stringify(text)}`);\n                    },\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}