{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/explicit-function-return-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891961287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst explicitReturnTypeUtils_1 = require(\"../util/explicitReturnTypeUtils\");\nexports.default = (0, util_1.createRule)({\n    name: 'explicit-function-return-type',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Require explicit return types on functions and class methods',\n        },\n        messages: {\n            missingReturnType: 'Missing return type on function.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowConciseArrowFunctionExpressionsStartingWithVoid: {\n                        type: 'boolean',\n                        description: 'Whether to allow arrow functions that start with the `void` keyword.',\n                    },\n                    allowDirectConstAssertionInArrowFunctions: {\n                        type: 'boolean',\n                        description: 'Whether to ignore arrow functions immediately returning a `as const` value.',\n                    },\n                    allowedNames: {\n                        type: 'array',\n                        description: 'An array of function/method names that will not have their arguments or return values checked.',\n                        items: {\n                            type: 'string',\n                        },\n                    },\n                    allowExpressions: {\n                        type: 'boolean',\n                        description: 'Whether to ignore function expressions (functions which are not part of a declaration).',\n                    },\n                    allowFunctionsWithoutTypeParameters: {\n                        type: 'boolean',\n                        description: \"Whether to ignore functions that don't have generic type parameters.\",\n                    },\n                    allowHigherOrderFunctions: {\n                        type: 'boolean',\n                        description: 'Whether to ignore functions immediately returning another function expression.',\n                    },\n                    allowIIFEs: {\n                        type: 'boolean',\n                        description: 'Whether to ignore immediately invoked function expressions (IIFEs).',\n                    },\n                    allowTypedFunctionExpressions: {\n                        type: 'boolean',\n                        description: 'Whether to ignore type annotations on the variable of function expressions.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowConciseArrowFunctionExpressionsStartingWithVoid: false,\n            allowDirectConstAssertionInArrowFunctions: true,\n            allowedNames: [],\n            allowExpressions: false,\n            allowFunctionsWithoutTypeParameters: false,\n            allowHigherOrderFunctions: true,\n            allowIIFEs: false,\n            allowTypedFunctionExpressions: true,\n        },\n    ],\n    create(context, [options]) {\n        const functionInfoStack = [];\n        function enterFunction(node) {\n            functionInfoStack.push({\n                node,\n                returns: [],\n            });\n        }\n        function popFunctionInfo(exitNodeType) {\n            return (0, util_1.nullThrows)(functionInfoStack.pop(), `Stack should exist on ${exitNodeType} exit`);\n        }\n        function isAllowedFunction(node) {\n            if (options.allowFunctionsWithoutTypeParameters && !node.typeParameters) {\n                return true;\n            }\n            if (options.allowIIFEs && isIIFE(node)) {\n                return true;\n            }\n            if (!options.allowedNames?.length) {\n                return false;\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||\n                node.type === utils_1.AST_NODE_TYPES.FunctionExpression) {\n                const parent = node.parent;\n                let funcName;\n                if (node.id?.name) {\n                    funcName = node.id.name;\n                }\n                else {\n                    switch (parent.type) {\n                        case utils_1.AST_NODE_TYPES.VariableDeclarator: {\n                            if (parent.id.type === utils_1.AST_NODE_TYPES.Identifier) {\n                                funcName = parent.id.name;\n                            }\n                            break;\n                        }\n                        case utils_1.AST_NODE_TYPES.MethodDefinition:\n                        case utils_1.AST_NODE_TYPES.PropertyDefinition:\n                        case utils_1.AST_NODE_TYPES.Property: {\n                            if (parent.key.type === utils_1.AST_NODE_TYPES.Identifier &&\n                                !parent.computed) {\n                                funcName = parent.key.name;\n                            }\n                            break;\n                        }\n                    }\n                }\n                if (!!funcName && !!options.allowedNames.includes(funcName)) {\n                    return true;\n                }\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.FunctionDeclaration &&\n                node.id &&\n                !!options.allowedNames.includes(node.id.name)) {\n                return true;\n            }\n            return false;\n        }\n        function isIIFE(node) {\n            return node.parent.type === utils_1.AST_NODE_TYPES.CallExpression;\n        }\n        function exitFunctionExpression(node) {\n            const info = popFunctionInfo('function expression');\n            if (options.allowConciseArrowFunctionExpressionsStartingWithVoid &&\n                node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n                node.expression &&\n                node.body.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                node.body.operator === 'void') {\n                return;\n            }\n            if (isAllowedFunction(node)) {\n                return;\n            }\n            if (options.allowTypedFunctionExpressions &&\n                ((0, explicitReturnTypeUtils_1.isValidFunctionExpressionReturnType)(node, options) ||\n                    (0, explicitReturnTypeUtils_1.ancestorHasReturnType)(node))) {\n                return;\n            }\n            (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(info, options, context.sourceCode, loc => context.report({\n                loc,\n                node,\n                messageId: 'missingReturnType',\n            }));\n        }\n        return {\n            'ArrowFunctionExpression, FunctionExpression, FunctionDeclaration': enterFunction,\n            'ArrowFunctionExpression:exit': exitFunctionExpression,\n            'FunctionDeclaration:exit'(node) {\n                const info = popFunctionInfo('function declaration');\n                if (isAllowedFunction(node)) {\n                    return;\n                }\n                if (options.allowTypedFunctionExpressions && node.returnType) {\n                    return;\n                }\n                (0, explicitReturnTypeUtils_1.checkFunctionReturnType)(info, options, context.sourceCode, loc => context.report({\n                    loc,\n                    node,\n                    messageId: 'missingReturnType',\n                }));\n            },\n            'FunctionExpression:exit': exitFunctionExpression,\n            ReturnStatement(node) {\n                functionInfoStack.at(-1)?.returns.push(node);\n            },\n        };\n    },\n});\n"
        }
    ]
}