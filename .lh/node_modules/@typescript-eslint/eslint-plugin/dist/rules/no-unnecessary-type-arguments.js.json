{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unnecessary-type-arguments.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891969275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-unnecessary-type-arguments',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow type arguments that are equal to the default',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            unnecessaryTypeParameter: 'This is the default value for this type parameter, so it can be omitted.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function getTypeForComparison(type) {\n            if ((0, util_1.isTypeReferenceType)(type)) {\n                return {\n                    type: type.target,\n                    typeArguments: checker.getTypeArguments(type),\n                };\n            }\n            return {\n                type,\n                typeArguments: [],\n            };\n        }\n        function checkTSArgsAndParameters(esParameters, typeParameters) {\n            // Just check the last one. Must specify previous type parameters if the last one is specified.\n            const i = esParameters.params.length - 1;\n            const arg = esParameters.params[i];\n            const param = typeParameters.at(i);\n            if (!param?.default) {\n                return;\n            }\n            // TODO: would like checker.areTypesEquivalent. https://github.com/Microsoft/TypeScript/issues/13502\n            const defaultType = checker.getTypeAtLocation(param.default);\n            const argType = services.getTypeAtLocation(arg);\n            // this check should handle some of the most simple cases of like strings, numbers, etc\n            if (defaultType !== argType) {\n                // For more complex types (like aliases to generic object types) - TS won't always create a\n                // global shared type object for the type - so we need to resort to manually comparing the\n                // reference type and the passed type arguments.\n                // Also - in case there are aliases - we need to resolve them before we do checks\n                const defaultTypeResolved = getTypeForComparison(defaultType);\n                const argTypeResolved = getTypeForComparison(argType);\n                if (\n                // ensure the resolved type AND all the parameters are the same\n                defaultTypeResolved.type !== argTypeResolved.type ||\n                    defaultTypeResolved.typeArguments.length !==\n                        argTypeResolved.typeArguments.length ||\n                    defaultTypeResolved.typeArguments.some((t, i) => t !== argTypeResolved.typeArguments[i])) {\n                    return;\n                }\n            }\n            context.report({\n                node: arg,\n                messageId: 'unnecessaryTypeParameter',\n                fix: fixer => fixer.removeRange(i === 0\n                    ? esParameters.range\n                    : [esParameters.params[i - 1].range[1], arg.range[1]]),\n            });\n        }\n        return {\n            TSTypeParameterInstantiation(node) {\n                const expression = services.esTreeNodeToTSNodeMap.get(node);\n                const typeParameters = getTypeParametersFromNode(node, expression, checker);\n                if (typeParameters) {\n                    checkTSArgsAndParameters(node, typeParameters);\n                }\n            },\n        };\n    },\n});\nfunction getTypeParametersFromNode(node, tsNode, checker) {\n    if (ts.isExpressionWithTypeArguments(tsNode)) {\n        return getTypeParametersFromType(node, tsNode.expression, checker);\n    }\n    if (ts.isTypeReferenceNode(tsNode)) {\n        return getTypeParametersFromType(node, tsNode.typeName, checker);\n    }\n    if (ts.isCallExpression(tsNode) ||\n        ts.isNewExpression(tsNode) ||\n        ts.isTaggedTemplateExpression(tsNode) ||\n        ts.isJsxOpeningElement(tsNode) ||\n        ts.isJsxSelfClosingElement(tsNode)) {\n        return getTypeParametersFromCall(node, tsNode, checker);\n    }\n    return undefined;\n}\nfunction getTypeParametersFromType(node, type, checker) {\n    const symAtLocation = checker.getSymbolAtLocation(type);\n    if (!symAtLocation) {\n        return undefined;\n    }\n    const sym = getAliasedSymbol(symAtLocation, checker);\n    const declarations = sym.getDeclarations();\n    if (!declarations) {\n        return undefined;\n    }\n    const sortedDeclaraions = sortDeclarationsByTypeValueContext(node, declarations);\n    return (0, util_1.findFirstResult)(sortedDeclaraions, decl => {\n        if (ts.isTypeAliasDeclaration(decl) ||\n            ts.isInterfaceDeclaration(decl) ||\n            ts.isClassLike(decl)) {\n            return decl.typeParameters;\n        }\n        if (ts.isVariableDeclaration(decl)) {\n            return getConstructSignatureDeclaration(symAtLocation, checker)\n                ?.typeParameters;\n        }\n        return undefined;\n    });\n}\nfunction getTypeParametersFromCall(node, tsNode, checker) {\n    const sig = checker.getResolvedSignature(tsNode);\n    const sigDecl = sig?.getDeclaration();\n    if (!sigDecl) {\n        return ts.isNewExpression(tsNode)\n            ? getTypeParametersFromType(node, tsNode.expression, checker)\n            : undefined;\n    }\n    return sigDecl.typeParameters;\n}\nfunction getAliasedSymbol(symbol, checker) {\n    return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)\n        ? checker.getAliasedSymbol(symbol)\n        : symbol;\n}\nfunction isInTypeContext(node) {\n    return (node.parent.type === utils_1.AST_NODE_TYPES.TSInterfaceHeritage ||\n        node.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference ||\n        node.parent.type === utils_1.AST_NODE_TYPES.TSClassImplements);\n}\nfunction isTypeContextDeclaration(decl) {\n    return ts.isTypeAliasDeclaration(decl) || ts.isInterfaceDeclaration(decl);\n}\nfunction typeFirstCompare(declA, declB) {\n    const aIsType = isTypeContextDeclaration(declA);\n    const bIsType = isTypeContextDeclaration(declB);\n    return Number(bIsType) - Number(aIsType);\n}\nfunction sortDeclarationsByTypeValueContext(node, declarations) {\n    const sorted = [...declarations].sort(typeFirstCompare);\n    if (isInTypeContext(node)) {\n        return sorted;\n    }\n    return sorted.reverse();\n}\nfunction getConstructSignatureDeclaration(symbol, checker) {\n    const type = checker.getTypeOfSymbol(symbol);\n    const sig = type.getConstructSignatures();\n    return sig.at(0)?.getDeclaration();\n}\n"
        }
    ]
}