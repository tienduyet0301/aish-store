{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-promise-reject-errors.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891973257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-promise-reject-errors',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require using Error objects as Promise rejection reasons',\n            extendsBaseRule: true,\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            rejectAnError: 'Expected the Promise rejection reason to be an Error.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowEmptyReject: {\n                        type: 'boolean',\n                        description: 'Whether to allow calls to `Promise.reject()` with no arguments.',\n                    },\n                    allowThrowingAny: {\n                        type: 'boolean',\n                        description: 'Whether to always allow throwing values typed as `any`.',\n                    },\n                    allowThrowingUnknown: {\n                        type: 'boolean',\n                        description: 'Whether to always allow throwing values typed as `unknown`.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowEmptyReject: false,\n            allowThrowingAny: false,\n            allowThrowingUnknown: false,\n        },\n    ],\n    create(context, [options]) {\n        const services = (0, util_1.getParserServices)(context);\n        function checkRejectCall(callExpression) {\n            const argument = callExpression.arguments.at(0);\n            if (argument) {\n                const type = services.getTypeAtLocation(argument);\n                if (options.allowThrowingAny && (0, util_1.isTypeAnyType)(type)) {\n                    return;\n                }\n                if (options.allowThrowingUnknown && (0, util_1.isTypeUnknownType)(type)) {\n                    return;\n                }\n                if ((0, util_1.isErrorLike)(services.program, type) ||\n                    (0, util_1.isReadonlyErrorLike)(services.program, type)) {\n                    return;\n                }\n            }\n            else if (options.allowEmptyReject) {\n                return;\n            }\n            context.report({\n                node: callExpression,\n                messageId: 'rejectAnError',\n            });\n        }\n        function typeAtLocationIsLikePromise(node) {\n            const type = services.getTypeAtLocation(node);\n            return ((0, util_1.isPromiseConstructorLike)(services.program, type) ||\n                (0, util_1.isPromiseLike)(services.program, type));\n        }\n        return {\n            CallExpression(node) {\n                const callee = (0, util_1.skipChainExpression)(node.callee);\n                if (callee.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n                    return;\n                }\n                if (!(0, util_1.isStaticMemberAccessOfValue)(callee, context, 'reject') ||\n                    !typeAtLocationIsLikePromise(callee.object)) {\n                    return;\n                }\n                checkRejectCall(node);\n            },\n            NewExpression(node) {\n                const callee = (0, util_1.skipChainExpression)(node.callee);\n                if (!(0, util_1.isPromiseConstructorLike)(services.program, services.getTypeAtLocation(callee))) {\n                    return;\n                }\n                const executor = node.arguments.at(0);\n                if (!executor || !(0, util_1.isFunction)(executor)) {\n                    return;\n                }\n                const rejectParamNode = executor.params.at(1);\n                if (!rejectParamNode || !(0, util_1.isIdentifier)(rejectParamNode)) {\n                    return;\n                }\n                // reject param is always present in variables declared by executor\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const rejectVariable = context.sourceCode\n                    .getDeclaredVariables(executor)\n                    .find(variable => variable.identifiers.includes(rejectParamNode));\n                rejectVariable.references.forEach(ref => {\n                    if (ref.identifier.parent.type !== utils_1.AST_NODE_TYPES.CallExpression ||\n                        ref.identifier !== ref.identifier.parent.callee) {\n                        return;\n                    }\n                    checkRejectCall(ref.identifier.parent);\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}