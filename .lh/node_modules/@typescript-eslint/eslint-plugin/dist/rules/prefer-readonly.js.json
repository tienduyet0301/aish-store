{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-readonly.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891973561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst getMemberHeadLoc_1 = require(\"../util/getMemberHeadLoc\");\nconst functionScopeBoundaries = [\n    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,\n    utils_1.AST_NODE_TYPES.FunctionDeclaration,\n    utils_1.AST_NODE_TYPES.FunctionExpression,\n    utils_1.AST_NODE_TYPES.MethodDefinition,\n].join(', ');\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-readonly',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: \"Require private members to be marked as `readonly` if they're never modified outside of the constructor\",\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            preferReadonly: \"Member '{{name}}' is never reassigned; mark it as `readonly`.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    onlyInlineLambdas: {\n                        type: 'boolean',\n                        description: 'Whether to restrict checking only to members immediately assigned a lambda value.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [{ onlyInlineLambdas: false }],\n    create(context, [{ onlyInlineLambdas }]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const classScopeStack = [];\n        function handlePropertyAccessExpression(node, parent, classScope) {\n            if (ts.isBinaryExpression(parent)) {\n                handleParentBinaryExpression(node, parent, classScope);\n                return;\n            }\n            if (ts.isDeleteExpression(parent) || isDestructuringAssignment(node)) {\n                classScope.addVariableModification(node);\n                return;\n            }\n            if (ts.isPostfixUnaryExpression(parent) ||\n                ts.isPrefixUnaryExpression(parent)) {\n                handleParentPostfixOrPrefixUnaryExpression(parent, classScope);\n            }\n        }\n        function handleParentBinaryExpression(node, parent, classScope) {\n            if (parent.left === node &&\n                tsutils.isAssignmentKind(parent.operatorToken.kind)) {\n                classScope.addVariableModification(node);\n            }\n        }\n        function handleParentPostfixOrPrefixUnaryExpression(node, classScope) {\n            if (node.operator === ts.SyntaxKind.PlusPlusToken ||\n                node.operator === ts.SyntaxKind.MinusMinusToken) {\n                classScope.addVariableModification(node.operand);\n            }\n        }\n        function isDestructuringAssignment(node) {\n            let current = node.parent;\n            while (current) {\n                const parent = current.parent;\n                if (ts.isObjectLiteralExpression(parent) ||\n                    ts.isArrayLiteralExpression(parent) ||\n                    ts.isSpreadAssignment(parent) ||\n                    (ts.isSpreadElement(parent) &&\n                        ts.isArrayLiteralExpression(parent.parent))) {\n                    current = parent;\n                }\n                else if (ts.isBinaryExpression(parent) &&\n                    !ts.isPropertyAccessExpression(current)) {\n                    return (parent.left === current &&\n                        parent.operatorToken.kind === ts.SyntaxKind.EqualsToken);\n                }\n                else {\n                    break;\n                }\n            }\n            return false;\n        }\n        function isFunctionScopeBoundaryInStack(node) {\n            if (classScopeStack.length === 0) {\n                return false;\n            }\n            const tsNode = services.esTreeNodeToTSNodeMap.get(node);\n            if (ts.isConstructorDeclaration(tsNode)) {\n                return false;\n            }\n            return tsutils.isFunctionScopeBoundary(tsNode);\n        }\n        function getEsNodesFromViolatingNode(violatingNode) {\n            return {\n                esNode: services.tsNodeToESTreeNodeMap.get(violatingNode),\n                nameNode: services.tsNodeToESTreeNodeMap.get(violatingNode.name),\n            };\n        }\n        function getTypeAnnotationForViolatingNode(node, type, initializerType) {\n            const annotation = checker.typeToString(type);\n            // verify the about-to-be-added type annotation is in-scope\n            if (tsutils.isTypeFlagSet(initializerType, ts.TypeFlags.EnumLiteral)) {\n                const scope = context.sourceCode.getScope(node);\n                const variable = utils_1.ASTUtils.findVariable(scope, annotation);\n                if (variable == null) {\n                    return null;\n                }\n                const definition = variable.defs.find(def => def.isTypeDefinition);\n                if (definition == null) {\n                    return null;\n                }\n                const definitionType = services.getTypeAtLocation(definition.node);\n                if (definitionType !== type) {\n                    return null;\n                }\n            }\n            return annotation;\n        }\n        return {\n            [`${functionScopeBoundaries}:exit`](node) {\n                if (utils_1.ASTUtils.isConstructor(node)) {\n                    classScopeStack[classScopeStack.length - 1].exitConstructor();\n                }\n                else if (isFunctionScopeBoundaryInStack(node)) {\n                    classScopeStack[classScopeStack.length - 1].exitNonConstructor();\n                }\n            },\n            'ClassDeclaration, ClassExpression'(node) {\n                classScopeStack.push(new ClassScope(checker, services.esTreeNodeToTSNodeMap.get(node), onlyInlineLambdas));\n            },\n            'ClassDeclaration, ClassExpression:exit'() {\n                const finalizedClassScope = (0, util_1.nullThrows)(classScopeStack.pop(), 'Stack should exist on class exit');\n                for (const violatingNode of finalizedClassScope.finalizeUnmodifiedPrivateNonReadonlys()) {\n                    const { esNode, nameNode } = getEsNodesFromViolatingNode(violatingNode);\n                    const reportNodeOrLoc = (() => {\n                        switch (esNode.type) {\n                            case utils_1.AST_NODE_TYPES.MethodDefinition:\n                            case utils_1.AST_NODE_TYPES.PropertyDefinition:\n                            case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n                                return { loc: (0, getMemberHeadLoc_1.getMemberHeadLoc)(context.sourceCode, esNode) };\n                            case utils_1.AST_NODE_TYPES.TSParameterProperty:\n                                return {\n                                    loc: (0, getMemberHeadLoc_1.getParameterPropertyHeadLoc)(context.sourceCode, esNode, nameNode.name),\n                                };\n                            default:\n                                return { node: esNode };\n                        }\n                    })();\n                    const typeAnnotation = (() => {\n                        if (esNode.type !== utils_1.AST_NODE_TYPES.PropertyDefinition) {\n                            return null;\n                        }\n                        if (esNode.typeAnnotation || !esNode.value) {\n                            return null;\n                        }\n                        if (nameNode.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                            return null;\n                        }\n                        const hasConstructorModifications = finalizedClassScope.memberHasConstructorModifications(nameNode.name);\n                        if (!hasConstructorModifications) {\n                            return null;\n                        }\n                        const violatingType = services.getTypeAtLocation(esNode);\n                        const initializerType = services.getTypeAtLocation(esNode.value);\n                        // if the RHS is a literal, its type would be narrowed, while the\n                        // type of the initializer (which isn't `readonly`) would be the\n                        // widened type\n                        if (initializerType === violatingType) {\n                            return null;\n                        }\n                        if (!tsutils.isLiteralType(initializerType)) {\n                            return null;\n                        }\n                        return getTypeAnnotationForViolatingNode(esNode, violatingType, initializerType);\n                    })();\n                    context.report({\n                        ...reportNodeOrLoc,\n                        messageId: 'preferReadonly',\n                        data: {\n                            name: context.sourceCode.getText(nameNode),\n                        },\n                        *fix(fixer) {\n                            yield fixer.insertTextBefore(nameNode, 'readonly ');\n                            if (typeAnnotation) {\n                                yield fixer.insertTextAfter(nameNode, `: ${typeAnnotation}`);\n                            }\n                        },\n                    });\n                }\n            },\n            [functionScopeBoundaries](node) {\n                if (utils_1.ASTUtils.isConstructor(node)) {\n                    classScopeStack[classScopeStack.length - 1].enterConstructor(services.esTreeNodeToTSNodeMap.get(node));\n                }\n                else if (isFunctionScopeBoundaryInStack(node)) {\n                    classScopeStack[classScopeStack.length - 1].enterNonConstructor();\n                }\n            },\n            MemberExpression(node) {\n                if (classScopeStack.length !== 0 && !node.computed) {\n                    const tsNode = services.esTreeNodeToTSNodeMap.get(node);\n                    handlePropertyAccessExpression(tsNode, tsNode.parent, classScopeStack[classScopeStack.length - 1]);\n                }\n            },\n        };\n    },\n});\nconst OUTSIDE_CONSTRUCTOR = -1;\nconst DIRECTLY_INSIDE_CONSTRUCTOR = 0;\nvar TypeToClassRelation;\n(function (TypeToClassRelation) {\n    TypeToClassRelation[TypeToClassRelation[\"ClassAndInstance\"] = 0] = \"ClassAndInstance\";\n    TypeToClassRelation[TypeToClassRelation[\"Class\"] = 1] = \"Class\";\n    TypeToClassRelation[TypeToClassRelation[\"Instance\"] = 2] = \"Instance\";\n    TypeToClassRelation[TypeToClassRelation[\"None\"] = 3] = \"None\";\n})(TypeToClassRelation || (TypeToClassRelation = {}));\nclass ClassScope {\n    checker;\n    onlyInlineLambdas;\n    classType;\n    constructorScopeDepth = OUTSIDE_CONSTRUCTOR;\n    memberVariableModifications = new Set();\n    memberVariableWithConstructorModifications = new Set();\n    privateModifiableMembers = new Map();\n    privateModifiableStatics = new Map();\n    staticVariableModifications = new Set();\n    constructor(checker, classNode, onlyInlineLambdas) {\n        this.checker = checker;\n        this.onlyInlineLambdas = onlyInlineLambdas;\n        const classType = checker.getTypeAtLocation(classNode);\n        if (tsutils.isIntersectionType(classType)) {\n            this.classType = classType.types[0];\n        }\n        else {\n            this.classType = classType;\n        }\n        for (const member of classNode.members) {\n            if (ts.isPropertyDeclaration(member)) {\n                this.addDeclaredVariable(member);\n            }\n        }\n    }\n    addDeclaredVariable(node) {\n        if (!(tsutils.isModifierFlagSet(node, ts.ModifierFlags.Private) ||\n            node.name.kind === ts.SyntaxKind.PrivateIdentifier) ||\n            tsutils.isModifierFlagSet(node, ts.ModifierFlags.Accessor | ts.ModifierFlags.Readonly) ||\n            ts.isComputedPropertyName(node.name)) {\n            return;\n        }\n        if (this.onlyInlineLambdas &&\n            node.initializer != null &&\n            !ts.isArrowFunction(node.initializer)) {\n            return;\n        }\n        (tsutils.isModifierFlagSet(node, ts.ModifierFlags.Static)\n            ? this.privateModifiableStatics\n            : this.privateModifiableMembers).set(node.name.getText(), node);\n    }\n    addVariableModification(node) {\n        const modifierType = this.checker.getTypeAtLocation(node.expression);\n        const relationOfModifierTypeToClass = this.getTypeToClassRelation(modifierType);\n        if (relationOfModifierTypeToClass === TypeToClassRelation.Instance &&\n            this.constructorScopeDepth === DIRECTLY_INSIDE_CONSTRUCTOR) {\n            this.memberVariableWithConstructorModifications.add(node.name.text);\n            return;\n        }\n        if (relationOfModifierTypeToClass === TypeToClassRelation.Instance ||\n            relationOfModifierTypeToClass === TypeToClassRelation.ClassAndInstance) {\n            this.memberVariableModifications.add(node.name.text);\n        }\n        if (relationOfModifierTypeToClass === TypeToClassRelation.Class ||\n            relationOfModifierTypeToClass === TypeToClassRelation.ClassAndInstance) {\n            this.staticVariableModifications.add(node.name.text);\n        }\n    }\n    enterConstructor(node) {\n        this.constructorScopeDepth = DIRECTLY_INSIDE_CONSTRUCTOR;\n        for (const parameter of node.parameters) {\n            if (tsutils.isModifierFlagSet(parameter, ts.ModifierFlags.Private)) {\n                this.addDeclaredVariable(parameter);\n            }\n        }\n    }\n    enterNonConstructor() {\n        if (this.constructorScopeDepth !== OUTSIDE_CONSTRUCTOR) {\n            this.constructorScopeDepth += 1;\n        }\n    }\n    exitConstructor() {\n        this.constructorScopeDepth = OUTSIDE_CONSTRUCTOR;\n    }\n    exitNonConstructor() {\n        if (this.constructorScopeDepth !== OUTSIDE_CONSTRUCTOR) {\n            this.constructorScopeDepth -= 1;\n        }\n    }\n    finalizeUnmodifiedPrivateNonReadonlys() {\n        this.memberVariableModifications.forEach(variableName => {\n            this.privateModifiableMembers.delete(variableName);\n        });\n        this.staticVariableModifications.forEach(variableName => {\n            this.privateModifiableStatics.delete(variableName);\n        });\n        return [\n            ...this.privateModifiableMembers.values(),\n            ...this.privateModifiableStatics.values(),\n        ];\n    }\n    getTypeToClassRelation(type) {\n        if (type.isIntersection()) {\n            let result = TypeToClassRelation.None;\n            for (const subType of type.types) {\n                const subTypeResult = this.getTypeToClassRelation(subType);\n                switch (subTypeResult) {\n                    case TypeToClassRelation.Class:\n                        if (result === TypeToClassRelation.Instance) {\n                            return TypeToClassRelation.ClassAndInstance;\n                        }\n                        result = TypeToClassRelation.Class;\n                        break;\n                    case TypeToClassRelation.Instance:\n                        if (result === TypeToClassRelation.Class) {\n                            return TypeToClassRelation.ClassAndInstance;\n                        }\n                        result = TypeToClassRelation.Instance;\n                        break;\n                }\n            }\n            return result;\n        }\n        if (type.isUnion()) {\n            // any union of class/instance and something else will prevent access to\n            // private members, so we assume that union consists only of classes\n            // or class instances, because otherwise tsc will report an error\n            return this.getTypeToClassRelation(type.types[0]);\n        }\n        if (!type.getSymbol() || !(0, util_1.typeIsOrHasBaseType)(type, this.classType)) {\n            return TypeToClassRelation.None;\n        }\n        const typeIsClass = tsutils.isObjectType(type) &&\n            tsutils.isObjectFlagSet(type, ts.ObjectFlags.Anonymous);\n        if (typeIsClass) {\n            return TypeToClassRelation.Class;\n        }\n        return TypeToClassRelation.Instance;\n    }\n    memberHasConstructorModifications(name) {\n        return this.memberVariableWithConstructorModifications.has(name);\n    }\n}\n"
        }
    ]
}