{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-use-before-define.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891970929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst referenceContainsTypeQuery_1 = require(\"../util/referenceContainsTypeQuery\");\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;\n/**\n * Parses a given value as options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let enums = true;\n    let variables = true;\n    let typedefs = true;\n    let ignoreTypeReferences = true;\n    let allowNamedExports = false;\n    if (typeof options === 'string') {\n        functions = options !== 'nofunc';\n    }\n    else if (typeof options === 'object' && options != null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        enums = options.enums !== false;\n        variables = options.variables !== false;\n        typedefs = options.typedefs !== false;\n        ignoreTypeReferences = options.ignoreTypeReferences !== false;\n        allowNamedExports = options.allowNamedExports !== false;\n    }\n    return {\n        allowNamedExports,\n        classes,\n        enums,\n        functions,\n        ignoreTypeReferences,\n        typedefs,\n        variables,\n    };\n}\n/**\n * Checks whether or not a given variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === scope_manager_1.DefinitionType.FunctionName;\n}\n/**\n * Checks whether or not a given variable is a type declaration.\n */\nfunction isTypedef(variable) {\n    return variable.defs[0].type === scope_manager_1.DefinitionType.Type;\n}\n/**\n * Checks whether or not a given variable is a enum declaration.\n */\nfunction isOuterEnum(variable, reference) {\n    return (variable.defs[0].type === scope_manager_1.DefinitionType.TSEnumName &&\n        variable.scope.variableScope !== reference.from.variableScope);\n}\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n */\nfunction isOuterClass(variable, reference) {\n    return (variable.defs[0].type === scope_manager_1.DefinitionType.ClassName &&\n        variable.scope.variableScope !== reference.from.variableScope);\n}\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n */\nfunction isOuterVariable(variable, reference) {\n    return (variable.defs[0].type === scope_manager_1.DefinitionType.Variable &&\n        variable.scope.variableScope !== reference.from.variableScope);\n}\n/**\n * Checks whether or not a given reference is a export reference.\n */\nfunction isNamedExports(reference) {\n    const { identifier } = reference;\n    return (identifier.parent.type === utils_1.AST_NODE_TYPES.ExportSpecifier &&\n        identifier.parent.local === identifier);\n}\n/**\n * Checks whether or not a given reference is a type reference.\n */\nfunction isTypeReference(reference) {\n    return (reference.isTypeReference ||\n        (0, referenceContainsTypeQuery_1.referenceContainsTypeQuery)(reference.identifier));\n}\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n */\nfunction isInRange(node, location) {\n    return !!node && node.range[0] <= location && location <= node.range[1];\n}\n/**\n * Decorators are transpiled such that the decorator is placed after the class declaration\n * So it is considered safe\n */\nfunction isClassRefInClassDecorator(variable, reference) {\n    if (variable.defs[0].type !== scope_manager_1.DefinitionType.ClassName ||\n        variable.defs[0].node.decorators.length === 0) {\n        return false;\n    }\n    for (const deco of variable.defs[0].node.decorators) {\n        if (reference.identifier.range[0] >= deco.range[0] &&\n            reference.identifier.range[1] <= deco.range[1]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * @returns `true` in the following cases:\n * - var a = a\n * - var [a = a] = list\n * - var {a = a} = obj\n * - for (var a in a) {}\n * - for (var a of a) {}\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n    while (node) {\n        if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if ((node.parent.parent.type === utils_1.AST_NODE_TYPES.ForInStatement ||\n                node.parent.parent.type === utils_1.AST_NODE_TYPES.ForOfStatement) &&\n                isInRange(node.parent.parent.right, location)) {\n                return true;\n            }\n            break;\n        }\n        else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        }\n        else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n        node = node.parent;\n    }\n    return false;\n}\nexports.default = (0, util_1.createRule)({\n    name: 'no-use-before-define',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow the use of variables before they are defined',\n            extendsBaseRule: true,\n        },\n        messages: {\n            noUseBeforeDefine: \"'{{name}}' was used before it was defined.\",\n        },\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: 'string',\n                        enum: ['nofunc'],\n                    },\n                    {\n                        type: 'object',\n                        additionalProperties: false,\n                        properties: {\n                            allowNamedExports: {\n                                type: 'boolean',\n                                description: 'Whether to ignore named exports.',\n                            },\n                            classes: {\n                                type: 'boolean',\n                                description: 'Whether to ignore references to class declarations.',\n                            },\n                            enums: {\n                                type: 'boolean',\n                                description: 'Whether to check references to enums.',\n                            },\n                            functions: {\n                                type: 'boolean',\n                                description: 'Whether to ignore references to function declarations.',\n                            },\n                            ignoreTypeReferences: {\n                                type: 'boolean',\n                                description: 'Whether to ignore type references, such as in type annotations and assertions.',\n                            },\n                            typedefs: {\n                                type: 'boolean',\n                                description: 'Whether to check references to types.',\n                            },\n                            variables: {\n                                type: 'boolean',\n                                description: 'Whether to ignore references to variables.',\n                            },\n                        },\n                    },\n                ],\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowNamedExports: false,\n            classes: true,\n            enums: true,\n            functions: true,\n            ignoreTypeReferences: true,\n            typedefs: true,\n            variables: true,\n        },\n    ],\n    create(context, optionsWithDefault) {\n        const options = parseOptions(optionsWithDefault[0]);\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param variable The variable that gets used before being defined\n         * @param reference The reference to the variable\n         */\n        function isForbidden(variable, reference) {\n            if (options.ignoreTypeReferences && isTypeReference(reference)) {\n                return false;\n            }\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            if (isOuterEnum(variable, reference)) {\n                return options.enums;\n            }\n            if (isTypedef(variable)) {\n                return options.typedefs;\n            }\n            return true;\n        }\n        function isDefinedBeforeUse(variable, reference) {\n            return (variable.identifiers[0].range[1] <= reference.identifier.range[1] &&\n                !(reference.isValueReference && isInInitializer(variable, reference)));\n        }\n        /**\n         * Finds and validates all variables in a given scope.\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n                function report() {\n                    context.report({\n                        node: reference.identifier,\n                        messageId: 'noUseBeforeDefine',\n                        data: {\n                            name: reference.identifier.name,\n                        },\n                    });\n                }\n                // Skips when the reference is:\n                // - initializations.\n                // - referring to an undefined variable.\n                // - referring to a global environment variable (there're no identifiers).\n                // - located preceded by the variable (except in initializers).\n                // - allowed by options.\n                if (reference.init) {\n                    return;\n                }\n                if (!options.allowNamedExports && isNamedExports(reference)) {\n                    if (!variable || !isDefinedBeforeUse(variable, reference)) {\n                        report();\n                    }\n                    return;\n                }\n                if (!variable) {\n                    return;\n                }\n                if (variable.identifiers.length === 0 ||\n                    isDefinedBeforeUse(variable, reference) ||\n                    !isForbidden(variable, reference) ||\n                    isClassRefInClassDecorator(variable, reference) ||\n                    reference.from.type === utils_1.TSESLint.Scope.ScopeType.functionType) {\n                    return;\n                }\n                // Reports.\n                report();\n            });\n            scope.childScopes.forEach(findVariablesInScope);\n        }\n        return {\n            Program(node) {\n                findVariablesInScope(context.sourceCode.getScope(node));\n            },\n        };\n    },\n});\n"
        }
    ]
}