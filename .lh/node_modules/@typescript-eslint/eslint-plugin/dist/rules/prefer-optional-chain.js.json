{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-optional-chain.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891973105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst analyzeChain_1 = require(\"./prefer-optional-chain-utils/analyzeChain\");\nconst checkNullishAndReport_1 = require(\"./prefer-optional-chain-utils/checkNullishAndReport\");\nconst gatherLogicalOperands_1 = require(\"./prefer-optional-chain-utils/gatherLogicalOperands\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-optional-chain',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce using concise optional chain expressions instead of chained logical ands, negated logical ors, or empty objects',\n            recommended: 'stylistic',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        hasSuggestions: true,\n        messages: {\n            optionalChainSuggest: 'Change to an optional chain.',\n            preferOptionalChain: \"Prefer using an optional chain expression instead, as it's more concise and easier to read.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing: {\n                        type: 'boolean',\n                        description: 'Allow autofixers that will change the return type of the expression. This option is considered unsafe as it may break the build.',\n                    },\n                    checkAny: {\n                        type: 'boolean',\n                        description: 'Check operands that are typed as `any` when inspecting \"loose boolean\" operands.',\n                    },\n                    checkBigInt: {\n                        type: 'boolean',\n                        description: 'Check operands that are typed as `bigint` when inspecting \"loose boolean\" operands.',\n                    },\n                    checkBoolean: {\n                        type: 'boolean',\n                        description: 'Check operands that are typed as `boolean` when inspecting \"loose boolean\" operands.',\n                    },\n                    checkNumber: {\n                        type: 'boolean',\n                        description: 'Check operands that are typed as `number` when inspecting \"loose boolean\" operands.',\n                    },\n                    checkString: {\n                        type: 'boolean',\n                        description: 'Check operands that are typed as `string` when inspecting \"loose boolean\" operands.',\n                    },\n                    checkUnknown: {\n                        type: 'boolean',\n                        description: 'Check operands that are typed as `unknown` when inspecting \"loose boolean\" operands.',\n                    },\n                    requireNullish: {\n                        type: 'boolean',\n                        description: 'Skip operands that are not typed with `null` and/or `undefined` when inspecting \"loose boolean\" operands.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing: false,\n            checkAny: true,\n            checkBigInt: true,\n            checkBoolean: true,\n            checkNumber: true,\n            checkString: true,\n            checkUnknown: true,\n            requireNullish: false,\n        },\n    ],\n    create(context, [options]) {\n        const parserServices = (0, util_1.getParserServices)(context);\n        const seenLogicals = new Set();\n        return {\n            // specific handling for `(foo ?? {}).bar` / `(foo || {}).bar`\n            'LogicalExpression[operator!=\"??\"]'(node) {\n                if (seenLogicals.has(node)) {\n                    return;\n                }\n                const { newlySeenLogicals, operands } = (0, gatherLogicalOperands_1.gatherLogicalOperands)(node, parserServices, context.sourceCode, options);\n                for (const logical of newlySeenLogicals) {\n                    seenLogicals.add(logical);\n                }\n                let currentChain = [];\n                for (const operand of operands) {\n                    if (operand.type === gatherLogicalOperands_1.OperandValidity.Invalid) {\n                        (0, analyzeChain_1.analyzeChain)(context, parserServices, options, node, node.operator, currentChain);\n                        currentChain = [];\n                    }\n                    else {\n                        currentChain.push(operand);\n                    }\n                }\n                // make sure to check whatever's left\n                if (currentChain.length > 0) {\n                    (0, analyzeChain_1.analyzeChain)(context, parserServices, options, node, node.operator, currentChain);\n                }\n            },\n            'LogicalExpression[operator=\"||\"], LogicalExpression[operator=\"??\"]'(node) {\n                const leftNode = node.left;\n                const rightNode = node.right;\n                const parentNode = node.parent;\n                const isRightNodeAnEmptyObjectLiteral = rightNode.type === utils_1.AST_NODE_TYPES.ObjectExpression &&\n                    rightNode.properties.length === 0;\n                if (!isRightNodeAnEmptyObjectLiteral ||\n                    parentNode.type !== utils_1.AST_NODE_TYPES.MemberExpression ||\n                    parentNode.optional) {\n                    return;\n                }\n                seenLogicals.add(node);\n                function isLeftSideLowerPrecedence() {\n                    const logicalTsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n                    const leftTsNode = parserServices.esTreeNodeToTSNodeMap.get(leftNode);\n                    const leftPrecedence = (0, util_1.getOperatorPrecedence)(leftTsNode.kind, logicalTsNode.operatorToken.kind);\n                    return leftPrecedence < util_1.OperatorPrecedence.LeftHandSide;\n                }\n                (0, checkNullishAndReport_1.checkNullishAndReport)(context, parserServices, options, [leftNode], {\n                    node: parentNode,\n                    messageId: 'preferOptionalChain',\n                    suggest: [\n                        {\n                            messageId: 'optionalChainSuggest',\n                            fix: (fixer) => {\n                                const leftNodeText = context.sourceCode.getText(leftNode);\n                                // Any node that is made of an operator with higher or equal precedence,\n                                const maybeWrappedLeftNode = isLeftSideLowerPrecedence()\n                                    ? `(${leftNodeText})`\n                                    : leftNodeText;\n                                const propertyToBeOptionalText = context.sourceCode.getText(parentNode.property);\n                                const maybeWrappedProperty = parentNode.computed\n                                    ? `[${propertyToBeOptionalText}]`\n                                    : propertyToBeOptionalText;\n                                return fixer.replaceTextRange(parentNode.range, `${maybeWrappedLeftNode}?.${maybeWrappedProperty}`);\n                            },\n                        },\n                    ],\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}