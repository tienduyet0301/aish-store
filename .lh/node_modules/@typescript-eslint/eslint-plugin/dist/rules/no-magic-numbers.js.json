{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-magic-numbers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891966358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-magic-numbers');\n// Extend base schema with additional property to ignore TS numeric literal types\nconst schema = (0, util_1.deepMerge)(\n// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- https://github.com/microsoft/TypeScript/issues/17002\nArray.isArray(baseRule.meta.schema)\n    ? baseRule.meta.schema[0]\n    : baseRule.meta.schema, {\n    properties: {\n        ignoreEnums: {\n            type: 'boolean',\n            description: 'Whether enums used in TypeScript are considered okay.',\n        },\n        ignoreNumericLiteralTypes: {\n            type: 'boolean',\n            description: 'Whether numbers used in TypeScript numeric literal types are considered okay.',\n        },\n        ignoreReadonlyClassProperties: {\n            type: 'boolean',\n            description: 'Whether `readonly` class properties are considered okay.',\n        },\n        ignoreTypeIndexes: {\n            type: 'boolean',\n            description: 'Whether numbers used to index types are okay.',\n        },\n    },\n});\nexports.default = (0, util_1.createRule)({\n    name: 'no-magic-numbers',\n    meta: {\n        type: 'suggestion',\n        // defaultOptions, -- base rule does not use defaultOptions\n        docs: {\n            description: 'Disallow magic numbers',\n            extendsBaseRule: true,\n        },\n        messages: baseRule.meta.messages,\n        schema: [schema],\n    },\n    defaultOptions: [\n        {\n            detectObjects: false,\n            enforceConst: false,\n            ignore: [],\n            ignoreArrayIndexes: false,\n            ignoreEnums: false,\n            ignoreNumericLiteralTypes: false,\n            ignoreReadonlyClassProperties: false,\n            ignoreTypeIndexes: false,\n        },\n    ],\n    create(context, [options]) {\n        const rules = baseRule.create(context);\n        const ignored = new Set((options.ignore ?? []).map(normalizeIgnoreValue));\n        return {\n            Literal(node) {\n                // If it’s not a numeric literal we’re not interested\n                if (typeof node.value !== 'number' && typeof node.value !== 'bigint') {\n                    return;\n                }\n                // This will be `true` if we’re configured to ignore this case (eg. it’s\n                // an enum and `ignoreEnums` is `true`). It will be `false` if we’re not\n                // configured to ignore this case. It will remain `undefined` if this is\n                // not one of our exception cases, and we’ll fall back to the base rule.\n                let isAllowed;\n                // Check if the node is ignored\n                if (ignored.has(normalizeLiteralValue(node, node.value))) {\n                    isAllowed = true;\n                }\n                // Check if the node is a TypeScript enum declaration\n                else if (isParentTSEnumDeclaration(node)) {\n                    isAllowed = options.ignoreEnums === true;\n                }\n                // Check TypeScript specific nodes for Numeric Literal\n                else if (isTSNumericLiteralType(node)) {\n                    isAllowed = options.ignoreNumericLiteralTypes === true;\n                }\n                // Check if the node is a type index\n                else if (isAncestorTSIndexedAccessType(node)) {\n                    isAllowed = options.ignoreTypeIndexes === true;\n                }\n                // Check if the node is a readonly class property\n                else if (isParentTSReadonlyPropertyDefinition(node)) {\n                    isAllowed = options.ignoreReadonlyClassProperties === true;\n                }\n                // If we’ve hit a case where the ignore option is true we can return now\n                if (isAllowed === true) {\n                    return;\n                }\n                // If the ignore option is *not* set we can report it now\n                if (isAllowed === false) {\n                    let fullNumberNode = node;\n                    let raw = node.raw;\n                    if (node.parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                        // the base rule only shows the operator for negative numbers\n                        // https://github.com/eslint/eslint/blob/9dfc8501fb1956c90dc11e6377b4cb38a6bea65d/lib/rules/no-magic-numbers.js#L126\n                        node.parent.operator === '-') {\n                        fullNumberNode = node.parent;\n                        raw = `${node.parent.operator}${node.raw}`;\n                    }\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: 'noMagic',\n                        data: { raw },\n                    });\n                    return;\n                }\n                // Let the base rule deal with the rest\n                rules.Literal(node);\n            },\n        };\n    },\n});\n/**\n * Convert the value to bigint if it's a string. Otherwise, return the value as-is.\n * @param value The value to normalize.\n * @returns The normalized value.\n */\nfunction normalizeIgnoreValue(value) {\n    if (typeof value === 'string') {\n        return BigInt(value.slice(0, -1));\n    }\n    return value;\n}\n/**\n * Converts the node to its numeric value, handling prefixed numbers (-1 / +1)\n * @param node the node to normalize.\n * @param value the node's value.\n */\nfunction normalizeLiteralValue(node, value) {\n    if (node.parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n        ['-', '+'].includes(node.parent.operator) &&\n        node.parent.operator === '-') {\n        return -value;\n    }\n    return value;\n}\n/**\n * Gets the true parent of the literal, handling prefixed numbers (-1 / +1)\n */\nfunction getLiteralParent(node) {\n    if (node.parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n        ['-', '+'].includes(node.parent.operator)) {\n        return node.parent.parent;\n    }\n    return node.parent;\n}\n/**\n * Checks if the node grandparent is a Typescript type alias declaration\n * @param node the node to be validated.\n * @returns true if the node grandparent is a Typescript type alias declaration\n * @private\n */\nfunction isGrandparentTSTypeAliasDeclaration(node) {\n    return node.parent?.parent?.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n}\n/**\n * Checks if the node grandparent is a Typescript union type and its parent is a type alias declaration\n * @param node the node to be validated.\n * @returns true if the node grandparent is a Typescript union type and its parent is a type alias declaration\n * @private\n */\nfunction isGrandparentTSUnionType(node) {\n    if (node.parent?.parent?.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n        return isGrandparentTSTypeAliasDeclaration(node.parent);\n    }\n    return false;\n}\n/**\n * Checks if the node parent is a Typescript enum member\n * @param node the node to be validated.\n * @returns true if the node parent is a Typescript enum member\n * @private\n */\nfunction isParentTSEnumDeclaration(node) {\n    const parent = getLiteralParent(node);\n    return parent?.type === utils_1.AST_NODE_TYPES.TSEnumMember;\n}\n/**\n * Checks if the node parent is a Typescript literal type\n * @param node the node to be validated.\n * @returns true if the node parent is a Typescript literal type\n * @private\n */\nfunction isParentTSLiteralType(node) {\n    return node.parent?.type === utils_1.AST_NODE_TYPES.TSLiteralType;\n}\n/**\n * Checks if the node is a valid TypeScript numeric literal type.\n * @param node the node to be validated.\n * @returns true if the node is a TypeScript numeric literal type.\n * @private\n */\nfunction isTSNumericLiteralType(node) {\n    // For negative numbers, use the parent node\n    if (node.parent?.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n        node.parent.operator === '-') {\n        node = node.parent;\n    }\n    // If the parent node is not a TSLiteralType, early return\n    if (!isParentTSLiteralType(node)) {\n        return false;\n    }\n    // If the grandparent is a TSTypeAliasDeclaration, ignore\n    if (isGrandparentTSTypeAliasDeclaration(node)) {\n        return true;\n    }\n    // If the grandparent is a TSUnionType and it's parent is a TSTypeAliasDeclaration, ignore\n    if (isGrandparentTSUnionType(node)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Checks if the node parent is a readonly class property\n * @param node the node to be validated.\n * @returns true if the node parent is a readonly class property\n * @private\n */\nfunction isParentTSReadonlyPropertyDefinition(node) {\n    const parent = getLiteralParent(node);\n    if (parent?.type === utils_1.AST_NODE_TYPES.PropertyDefinition && parent.readonly) {\n        return true;\n    }\n    return false;\n}\n/**\n * Checks if the node is part of a type indexed access (eg. Foo[4])\n * @param node the node to be validated.\n * @returns true if the node is part of an indexed access\n * @private\n */\nfunction isAncestorTSIndexedAccessType(node) {\n    // Handle unary expressions (eg. -4)\n    let ancestor = getLiteralParent(node);\n    // Go up another level while we’re part of a type union (eg. 1 | 2) or\n    // intersection (eg. 1 & 2)\n    while (ancestor?.parent?.type === utils_1.AST_NODE_TYPES.TSUnionType ||\n        ancestor?.parent?.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n        ancestor = ancestor.parent;\n    }\n    return ancestor?.parent?.type === utils_1.AST_NODE_TYPES.TSIndexedAccessType;\n}\n"
        }
    ]
}