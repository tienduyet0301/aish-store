{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/naming-convention.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891962841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n// This rule was feature-frozen before we enabled no-property-in-node.\n/* eslint-disable eslint-plugin/no-property-in-node */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst naming_convention_utils_1 = require(\"./naming-convention-utils\");\n// This essentially mirrors ESLint's `camelcase` rule\n// note that that rule ignores leading and trailing underscores and only checks those in the middle of a variable name\nconst defaultCamelCaseAllTheThingsConfig = [\n    {\n        format: ['camelCase'],\n        leadingUnderscore: 'allow',\n        selector: 'default',\n        trailingUnderscore: 'allow',\n    },\n    {\n        format: ['camelCase', 'PascalCase'],\n        selector: 'import',\n    },\n    {\n        format: ['camelCase', 'UPPER_CASE'],\n        leadingUnderscore: 'allow',\n        selector: 'variable',\n        trailingUnderscore: 'allow',\n    },\n    {\n        format: ['PascalCase'],\n        selector: 'typeLike',\n    },\n];\nexports.default = (0, util_1.createRule)({\n    name: 'naming-convention',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce naming conventions for everything across a codebase',\n            // technically only requires type checking if the user uses \"type\" modifiers\n            requiresTypeChecking: true,\n        },\n        messages: {\n            doesNotMatchFormat: '{{type}} name `{{name}}` must match one of the following formats: {{formats}}',\n            doesNotMatchFormatTrimmed: '{{type}} name `{{name}}` trimmed as `{{processedName}}` must match one of the following formats: {{formats}}',\n            missingAffix: '{{type}} name `{{name}}` must have one of the following {{position}}es: {{affixes}}',\n            missingUnderscore: '{{type}} name `{{name}}` must have {{count}} {{position}} underscore(s).',\n            satisfyCustom: '{{type}} name `{{name}}` must {{regexMatch}} the RegExp: {{regex}}',\n            unexpectedUnderscore: '{{type}} name `{{name}}` must not have a {{position}} underscore.',\n        },\n        schema: naming_convention_utils_1.SCHEMA,\n    },\n    defaultOptions: defaultCamelCaseAllTheThingsConfig,\n    create(contextWithoutDefaults) {\n        const context = contextWithoutDefaults.options.length > 0\n            ? contextWithoutDefaults\n            : // only apply the defaults when the user provides no config\n                Object.setPrototypeOf({\n                    options: defaultCamelCaseAllTheThingsConfig,\n                }, contextWithoutDefaults);\n        const validators = (0, naming_convention_utils_1.parseOptions)(context);\n        const compilerOptions = (0, util_1.getParserServices)(context, true).program?.getCompilerOptions() ?? {};\n        function handleMember(validator, node, modifiers) {\n            const key = node.key;\n            if (requiresQuoting(key, compilerOptions.target)) {\n                modifiers.add(naming_convention_utils_1.Modifiers.requiresQuotes);\n            }\n            validator(key, modifiers);\n        }\n        function getMemberModifiers(node) {\n            const modifiers = new Set();\n            if ('key' in node && node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n                modifiers.add(naming_convention_utils_1.Modifiers['#private']);\n            }\n            else if (node.accessibility) {\n                modifiers.add(naming_convention_utils_1.Modifiers[node.accessibility]);\n            }\n            else {\n                modifiers.add(naming_convention_utils_1.Modifiers.public);\n            }\n            if (node.static) {\n                modifiers.add(naming_convention_utils_1.Modifiers.static);\n            }\n            if ('readonly' in node && node.readonly) {\n                modifiers.add(naming_convention_utils_1.Modifiers.readonly);\n            }\n            if ('override' in node && node.override) {\n                modifiers.add(naming_convention_utils_1.Modifiers.override);\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||\n                node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||\n                node.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty) {\n                modifiers.add(naming_convention_utils_1.Modifiers.abstract);\n            }\n            return modifiers;\n        }\n        const { unusedVariables } = (0, util_1.collectVariables)(context);\n        function isUnused(name, initialScope) {\n            let variable = null;\n            let scope = initialScope;\n            while (scope) {\n                variable = scope.set.get(name) ?? null;\n                if (variable) {\n                    break;\n                }\n                scope = scope.upper;\n            }\n            if (!variable) {\n                return false;\n            }\n            return unusedVariables.has(variable);\n        }\n        function isDestructured(id) {\n            return (\n            // `const { x }`\n            // does not match `const { x: y }`\n            (id.parent.type === utils_1.AST_NODE_TYPES.Property && id.parent.shorthand) ||\n                // `const { x = 2 }`\n                // does not match const `{ x: y = 2 }`\n                (id.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern &&\n                    id.parent.parent.type === utils_1.AST_NODE_TYPES.Property &&\n                    id.parent.parent.shorthand));\n        }\n        function isAsyncMemberOrProperty(propertyOrMemberNode) {\n            return Boolean('value' in propertyOrMemberNode &&\n                propertyOrMemberNode.value &&\n                'async' in propertyOrMemberNode.value &&\n                propertyOrMemberNode.value.async);\n        }\n        function isAsyncVariableIdentifier(id) {\n            return Boolean(('async' in id.parent && id.parent.async) ||\n                ('init' in id.parent &&\n                    id.parent.init &&\n                    'async' in id.parent.init &&\n                    id.parent.init.async));\n        }\n        const selectors = {\n            // #region import\n            'FunctionDeclaration, TSDeclareFunction, FunctionExpression': {\n                handler: (node, validator) => {\n                    if (node.id == null) {\n                        return;\n                    }\n                    const modifiers = new Set();\n                    // functions create their own nested scope\n                    const scope = context.sourceCode.getScope(node).upper;\n                    if (isGlobal(scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.global);\n                    }\n                    if (isExported(node, node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.exported);\n                    }\n                    if (isUnused(node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                    }\n                    if (node.async) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.async);\n                    }\n                    validator(node.id, modifiers);\n                },\n                validator: validators.function,\n            },\n            // #endregion\n            // #region variable\n            'ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier': {\n                handler: (node, validator) => {\n                    const modifiers = new Set();\n                    switch (node.type) {\n                        case utils_1.AST_NODE_TYPES.ImportDefaultSpecifier:\n                            modifiers.add(naming_convention_utils_1.Modifiers.default);\n                            break;\n                        case utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier:\n                            modifiers.add(naming_convention_utils_1.Modifiers.namespace);\n                            break;\n                        case utils_1.AST_NODE_TYPES.ImportSpecifier:\n                            // Handle `import { default as Foo }`\n                            if (node.imported.type === utils_1.AST_NODE_TYPES.Identifier &&\n                                node.imported.name !== 'default') {\n                                return;\n                            }\n                            modifiers.add(naming_convention_utils_1.Modifiers.default);\n                            break;\n                    }\n                    validator(node.local, modifiers);\n                },\n                validator: validators.import,\n            },\n            // #endregion\n            // #region function\n            VariableDeclarator: {\n                handler: (node, validator) => {\n                    const identifiers = getIdentifiersFromPattern(node.id);\n                    const baseModifiers = new Set();\n                    const parent = node.parent;\n                    if (parent.kind === 'const') {\n                        baseModifiers.add(naming_convention_utils_1.Modifiers.const);\n                    }\n                    if (isGlobal(context.sourceCode.getScope(node))) {\n                        baseModifiers.add(naming_convention_utils_1.Modifiers.global);\n                    }\n                    identifiers.forEach(id => {\n                        const modifiers = new Set(baseModifiers);\n                        if (isDestructured(id)) {\n                            modifiers.add(naming_convention_utils_1.Modifiers.destructured);\n                        }\n                        const scope = context.sourceCode.getScope(id);\n                        if (isExported(parent, id.name, scope)) {\n                            modifiers.add(naming_convention_utils_1.Modifiers.exported);\n                        }\n                        if (isUnused(id.name, scope)) {\n                            modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                        }\n                        if (isAsyncVariableIdentifier(id)) {\n                            modifiers.add(naming_convention_utils_1.Modifiers.async);\n                        }\n                        validator(id, modifiers);\n                    });\n                },\n                validator: validators.variable,\n            },\n            // #endregion function\n            // #region parameter\n            ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type != \"ArrowFunctionExpression\"][value.type != \"FunctionExpression\"][value.type != \"TSEmptyBodyFunctionExpression\"]': {\n                handler: (node, validator) => {\n                    const modifiers = getMemberModifiers(node);\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.classProperty,\n            },\n            // #endregion parameter\n            // #region parameterProperty\n            ':not(ObjectPattern) > Property[computed = false][kind = \"init\"][value.type != \"ArrowFunctionExpression\"][value.type != \"FunctionExpression\"][value.type != \"TSEmptyBodyFunctionExpression\"]': {\n                handler: (node, validator) => {\n                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.objectLiteralProperty,\n            },\n            // #endregion parameterProperty\n            // #region property\n            [[\n                ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = \"ArrowFunctionExpression\"]',\n                ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = \"FunctionExpression\"]',\n                ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = \"TSEmptyBodyFunctionExpression\"]',\n                ':matches(MethodDefinition, TSAbstractMethodDefinition)[computed = false][kind = \"method\"]',\n            ].join(', ')]: {\n                handler: (node, validator) => {\n                    const modifiers = getMemberModifiers(node);\n                    if (isAsyncMemberOrProperty(node)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.async);\n                    }\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.classMethod,\n            },\n            [[\n                'MethodDefinition[computed = false]:matches([kind = \"get\"], [kind = \"set\"])',\n                'TSAbstractMethodDefinition[computed = false]:matches([kind=\"get\"], [kind=\"set\"])',\n            ].join(', ')]: {\n                handler: (node, validator) => {\n                    const modifiers = getMemberModifiers(node);\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.classicAccessor,\n            },\n            [[\n                'Property[computed = false][kind = \"init\"][value.type = \"ArrowFunctionExpression\"]',\n                'Property[computed = false][kind = \"init\"][value.type = \"FunctionExpression\"]',\n                'Property[computed = false][kind = \"init\"][value.type = \"TSEmptyBodyFunctionExpression\"]',\n            ].join(', ')]: {\n                handler: (node, validator) => {\n                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n                    if (isAsyncMemberOrProperty(node)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.async);\n                    }\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.objectLiteralMethod,\n            },\n            // #endregion property\n            // #region method\n            [[\n                'TSMethodSignature[computed = false]',\n                'TSPropertySignature[computed = false][typeAnnotation.typeAnnotation.type = \"TSFunctionType\"]',\n            ].join(', ')]: {\n                handler: (node, validator) => {\n                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.typeMethod,\n            },\n            [[\n                utils_1.AST_NODE_TYPES.AccessorProperty,\n                utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty,\n            ].join(', ')]: {\n                handler: (node, validator) => {\n                    const modifiers = getMemberModifiers(node);\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.autoAccessor,\n            },\n            'FunctionDeclaration, TSDeclareFunction, TSEmptyBodyFunctionExpression, FunctionExpression, ArrowFunctionExpression': {\n                handler: (node, validator) => {\n                    node.params.forEach(param => {\n                        if (param.type === utils_1.AST_NODE_TYPES.TSParameterProperty) {\n                            return;\n                        }\n                        const identifiers = getIdentifiersFromPattern(param);\n                        identifiers.forEach(i => {\n                            const modifiers = new Set();\n                            if (isDestructured(i)) {\n                                modifiers.add(naming_convention_utils_1.Modifiers.destructured);\n                            }\n                            if (isUnused(i.name, context.sourceCode.getScope(i))) {\n                                modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                            }\n                            validator(i, modifiers);\n                        });\n                    });\n                },\n                validator: validators.parameter,\n            },\n            // #endregion method\n            // #region accessor\n            'Property[computed = false]:matches([kind = \"get\"], [kind = \"set\"])': {\n                handler: (node, validator) => {\n                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.classicAccessor,\n            },\n            TSParameterProperty: {\n                handler: (node, validator) => {\n                    const modifiers = getMemberModifiers(node);\n                    const identifiers = getIdentifiersFromPattern(node.parameter);\n                    identifiers.forEach(i => {\n                        validator(i, modifiers);\n                    });\n                },\n                validator: validators.parameterProperty,\n            },\n            // #endregion accessor\n            // #region autoAccessor\n            'TSPropertySignature[computed = false][typeAnnotation.typeAnnotation.type != \"TSFunctionType\"]': {\n                handler: (node, validator) => {\n                    const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n                    if (node.readonly) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.readonly);\n                    }\n                    handleMember(validator, node, modifiers);\n                },\n                validator: validators.typeProperty,\n            },\n            // #endregion autoAccessor\n            // #region enumMember\n            // computed is optional, so can't do [computed = false]\n            'ClassDeclaration, ClassExpression': {\n                handler: (node, validator) => {\n                    const id = node.id;\n                    if (id == null) {\n                        return;\n                    }\n                    const modifiers = new Set();\n                    // classes create their own nested scope\n                    const scope = context.sourceCode.getScope(node).upper;\n                    if (node.abstract) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.abstract);\n                    }\n                    if (isExported(node, id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.exported);\n                    }\n                    if (isUnused(id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                    }\n                    validator(id, modifiers);\n                },\n                validator: validators.class,\n            },\n            // #endregion enumMember\n            // #region class\n            TSEnumDeclaration: {\n                handler: (node, validator) => {\n                    const modifiers = new Set();\n                    // enums create their own nested scope\n                    const scope = context.sourceCode.getScope(node).upper;\n                    if (isExported(node, node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.exported);\n                    }\n                    if (isUnused(node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                    }\n                    validator(node.id, modifiers);\n                },\n                validator: validators.enum,\n            },\n            // #endregion class\n            // #region interface\n            'TSEnumMember[computed != true]': {\n                handler: (node, validator) => {\n                    const id = node.id;\n                    const modifiers = new Set();\n                    if (requiresQuoting(id, compilerOptions.target)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.requiresQuotes);\n                    }\n                    validator(id, modifiers);\n                },\n                validator: validators.enumMember,\n            },\n            // #endregion interface\n            // #region typeAlias\n            TSInterfaceDeclaration: {\n                handler: (node, validator) => {\n                    const modifiers = new Set();\n                    const scope = context.sourceCode.getScope(node);\n                    if (isExported(node, node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.exported);\n                    }\n                    if (isUnused(node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                    }\n                    validator(node.id, modifiers);\n                },\n                validator: validators.interface,\n            },\n            // #endregion typeAlias\n            // #region enum\n            TSTypeAliasDeclaration: {\n                handler: (node, validator) => {\n                    const modifiers = new Set();\n                    const scope = context.sourceCode.getScope(node);\n                    if (isExported(node, node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.exported);\n                    }\n                    if (isUnused(node.id.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                    }\n                    validator(node.id, modifiers);\n                },\n                validator: validators.typeAlias,\n            },\n            // #endregion enum\n            // #region typeParameter\n            'TSTypeParameterDeclaration > TSTypeParameter': {\n                handler: (node, validator) => {\n                    const modifiers = new Set();\n                    const scope = context.sourceCode.getScope(node);\n                    if (isUnused(node.name.name, scope)) {\n                        modifiers.add(naming_convention_utils_1.Modifiers.unused);\n                    }\n                    validator(node.name, modifiers);\n                },\n                validator: validators.typeParameter,\n            },\n            // #endregion typeParameter\n        };\n        return Object.fromEntries(Object.entries(selectors).map(([selector, { handler, validator }]) => {\n            return [\n                selector,\n                (node) => {\n                    handler(node, validator);\n                },\n            ];\n        }));\n    },\n});\nfunction getIdentifiersFromPattern(pattern) {\n    const identifiers = [];\n    const visitor = new scope_manager_1.PatternVisitor({}, pattern, id => identifiers.push(id));\n    visitor.visit(pattern);\n    return identifiers;\n}\nfunction isExported(node, name, scope) {\n    if (node?.parent?.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||\n        node?.parent?.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration) {\n        return true;\n    }\n    if (scope == null) {\n        return false;\n    }\n    const variable = scope.set.get(name);\n    if (variable) {\n        for (const ref of variable.references) {\n            const refParent = ref.identifier.parent;\n            if (refParent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration ||\n                refParent.type === utils_1.AST_NODE_TYPES.ExportSpecifier) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction isGlobal(scope) {\n    if (scope == null) {\n        return false;\n    }\n    return (scope.type === utils_1.TSESLint.Scope.ScopeType.global ||\n        scope.type === utils_1.TSESLint.Scope.ScopeType.module);\n}\nfunction requiresQuoting(node, target) {\n    const name = node.type === utils_1.AST_NODE_TYPES.Identifier ||\n        node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier\n        ? node.name\n        : `${node.value}`;\n    return (0, util_1.requiresQuoting)(name, target);\n}\n"
        }
    ]
}