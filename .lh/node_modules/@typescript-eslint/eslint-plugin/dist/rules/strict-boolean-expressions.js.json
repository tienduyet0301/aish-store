{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/strict-boolean-expressions.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst assertionFunctionUtils_1 = require(\"../util/assertionFunctionUtils\");\nexports.default = (0, util_1.createRule)({\n    name: 'strict-boolean-expressions',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow certain types in boolean expressions',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            conditionErrorAny: 'Unexpected any value in {{context}}. ' +\n                'An explicit comparison or type conversion is required.',\n            conditionErrorNullableBoolean: 'Unexpected nullable boolean value in {{context}}. ' +\n                'Please handle the nullish case explicitly.',\n            conditionErrorNullableEnum: 'Unexpected nullable enum value in {{context}}. ' +\n                'Please handle the nullish/zero/NaN cases explicitly.',\n            conditionErrorNullableNumber: 'Unexpected nullable number value in {{context}}. ' +\n                'Please handle the nullish/zero/NaN cases explicitly.',\n            conditionErrorNullableObject: 'Unexpected nullable object value in {{context}}. ' +\n                'An explicit null check is required.',\n            conditionErrorNullableString: 'Unexpected nullable string value in {{context}}. ' +\n                'Please handle the nullish/empty cases explicitly.',\n            conditionErrorNullish: 'Unexpected nullish value in conditional. ' +\n                'The condition is always false.',\n            conditionErrorNumber: 'Unexpected number value in {{context}}. ' +\n                'An explicit zero/NaN check is required.',\n            conditionErrorObject: 'Unexpected object value in {{context}}. ' +\n                'The condition is always true.',\n            conditionErrorOther: 'Unexpected value in conditional. ' +\n                'A boolean expression is required.',\n            conditionErrorString: 'Unexpected string value in {{context}}. ' +\n                'An explicit empty string check is required.',\n            conditionFixCastBoolean: 'Explicitly convert value to a boolean (`Boolean(value)`)',\n            conditionFixCompareArrayLengthNonzero: \"Change condition to check array's length (`value.length > 0`)\",\n            conditionFixCompareArrayLengthZero: \"Change condition to check array's length (`value.length === 0`)\",\n            conditionFixCompareEmptyString: 'Change condition to check for empty string (`value !== \"\"`)',\n            conditionFixCompareFalse: 'Change condition to check if false (`value === false`)',\n            conditionFixCompareNaN: 'Change condition to check for NaN (`!Number.isNaN(value)`)',\n            conditionFixCompareNullish: 'Change condition to check for null/undefined (`value != null`)',\n            conditionFixCompareStringLength: \"Change condition to check string's length (`value.length !== 0`)\",\n            conditionFixCompareTrue: 'Change condition to check if true (`value === true`)',\n            conditionFixCompareZero: 'Change condition to check for 0 (`value !== 0`)',\n            conditionFixDefaultEmptyString: 'Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)',\n            conditionFixDefaultFalse: 'Explicitly treat nullish value the same as false (`value ?? false`)',\n            conditionFixDefaultZero: 'Explicitly treat nullish value the same as 0 (`value ?? 0`)',\n            explicitBooleanReturnType: 'Add an explicit `boolean` return type annotation.',\n            noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',\n            predicateCannotBeAsync: \"Predicate function should not be 'async'; expected a boolean return type.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowAny: {\n                        type: 'boolean',\n                        description: 'Whether to allow `any`s in a boolean context.',\n                    },\n                    allowNullableBoolean: {\n                        type: 'boolean',\n                        description: 'Whether to allow nullable `boolean`s in a boolean context.',\n                    },\n                    allowNullableEnum: {\n                        type: 'boolean',\n                        description: 'Whether to allow nullable `enum`s in a boolean context.',\n                    },\n                    allowNullableNumber: {\n                        type: 'boolean',\n                        description: 'Whether to allow nullable `number`s in a boolean context.',\n                    },\n                    allowNullableObject: {\n                        type: 'boolean',\n                        description: 'Whether to allow nullable `object`s, `symbol`s, and functions in a boolean context.',\n                    },\n                    allowNullableString: {\n                        type: 'boolean',\n                        description: 'Whether to allow nullable `string`s in a boolean context.',\n                    },\n                    allowNumber: {\n                        type: 'boolean',\n                        description: 'Whether to allow `number`s in a boolean context.',\n                    },\n                    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n                        type: 'boolean',\n                        description: 'Unless this is set to `true`, the rule will error on every file whose `tsconfig.json` does _not_ have the `strictNullChecks` compiler option (or `strict`) set to `true`.',\n                    },\n                    allowString: {\n                        type: 'boolean',\n                        description: 'Whether to allow `string`s in a boolean context.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowAny: false,\n            allowNullableBoolean: false,\n            allowNullableEnum: false,\n            allowNullableNumber: false,\n            allowNullableObject: true,\n            allowNullableString: false,\n            allowNumber: true,\n            allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false,\n            allowString: true,\n        },\n    ],\n    create(context, [options]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const compilerOptions = services.program.getCompilerOptions();\n        const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');\n        if (!isStrictNullChecks &&\n            options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n            context.report({\n                loc: {\n                    start: { column: 0, line: 0 },\n                    end: { column: 0, line: 0 },\n                },\n                messageId: 'noStrictNullCheck',\n            });\n        }\n        const traversedNodes = new Set();\n        return {\n            CallExpression: traverseCallExpression,\n            ConditionalExpression: traverseTestExpression,\n            DoWhileStatement: traverseTestExpression,\n            ForStatement: traverseTestExpression,\n            IfStatement: traverseTestExpression,\n            'LogicalExpression[operator!=\"??\"]': traverseLogicalExpression,\n            'UnaryExpression[operator=\"!\"]': traverseUnaryLogicalExpression,\n            WhileStatement: traverseTestExpression,\n        };\n        /**\n         * Inspects condition of a test expression. (`if`, `while`, `for`, etc.)\n         */\n        function traverseTestExpression(node) {\n            if (node.test == null) {\n                return;\n            }\n            traverseNode(node.test, true);\n        }\n        /**\n         * Inspects the argument of a unary logical expression (`!`).\n         */\n        function traverseUnaryLogicalExpression(node) {\n            traverseNode(node.argument, true);\n        }\n        /**\n         * Inspects the arguments of a logical expression (`&&`, `||`).\n         *\n         * If the logical expression is a descendant of a test expression,\n         * the `isCondition` flag should be set to true.\n         * Otherwise, if the logical expression is there on it's own,\n         * it's used for control flow and is not a condition itself.\n         */\n        function traverseLogicalExpression(node, isCondition = false) {\n            // left argument is always treated as a condition\n            traverseNode(node.left, true);\n            // if the logical expression is used for control flow,\n            // then its right argument is used for its side effects only\n            traverseNode(node.right, isCondition);\n        }\n        function traverseCallExpression(node) {\n            const assertedArgument = (0, assertionFunctionUtils_1.findTruthinessAssertedArgument)(services, node);\n            if (assertedArgument != null) {\n                traverseNode(assertedArgument, true);\n            }\n            if ((0, util_1.isArrayMethodCallWithPredicate)(context, services, node)) {\n                const predicate = node.arguments.at(0);\n                if (predicate) {\n                    checkArrayMethodCallPredicate(predicate);\n                }\n            }\n        }\n        /**\n         * Dedicated function to check array method predicate calls. Reports predicate\n         * arguments that don't return a boolean value.\n         */\n        function checkArrayMethodCallPredicate(predicateNode) {\n            const isFunctionExpression = utils_1.ASTUtils.isFunction(predicateNode);\n            // custom message for accidental `async` function expressions\n            if (isFunctionExpression && predicateNode.async) {\n                return context.report({\n                    node: predicateNode,\n                    messageId: 'predicateCannotBeAsync',\n                });\n            }\n            const returnTypes = services\n                .getTypeAtLocation(predicateNode)\n                .getCallSignatures()\n                .map(signature => {\n                const type = signature.getReturnType();\n                if (tsutils.isTypeParameter(type)) {\n                    return checker.getBaseConstraintOfType(type) ?? type;\n                }\n                return type;\n            });\n            const flattenTypes = [\n                ...new Set(returnTypes.flatMap(type => tsutils.unionTypeParts(type))),\n            ];\n            const types = inspectVariantTypes(flattenTypes);\n            const reportType = determineReportType(types);\n            if (reportType == null) {\n                return;\n            }\n            const suggestions = [];\n            if (isFunctionExpression &&\n                predicateNode.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                suggestions.push(...getSuggestionsForConditionError(predicateNode.body, reportType));\n            }\n            if (isFunctionExpression && !predicateNode.returnType) {\n                suggestions.push({\n                    messageId: 'explicitBooleanReturnType',\n                    fix: fixer => {\n                        if (predicateNode.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n                            (0, util_1.isParenlessArrowFunction)(predicateNode, context.sourceCode)) {\n                            return [\n                                fixer.insertTextBefore(predicateNode.params[0], '('),\n                                fixer.insertTextAfter(predicateNode.params[0], '): boolean'),\n                            ];\n                        }\n                        if (predicateNode.params.length === 0) {\n                            const closingBracket = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(predicateNode, token => token.value === ')'), 'function expression has to have a closing parenthesis.');\n                            return fixer.insertTextAfter(closingBracket, ': boolean');\n                        }\n                        const lastClosingParenthesis = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(predicateNode.params[predicateNode.params.length - 1], token => token.value === ')'), 'function expression has to have a closing parenthesis.');\n                        return fixer.insertTextAfter(lastClosingParenthesis, ': boolean');\n                    },\n                });\n            }\n            return context.report({\n                node: predicateNode,\n                messageId: reportType,\n                data: {\n                    context: 'array predicate return type',\n                },\n                suggest: suggestions,\n            });\n        }\n        /**\n         * Inspects any node.\n         *\n         * If it's a logical expression then it recursively traverses its arguments.\n         * If it's any other kind of node then it's type is finally checked against the rule,\n         * unless `isCondition` flag is set to false, in which case\n         * it's assumed to be used for side effects only and is skipped.\n         */\n        function traverseNode(node, isCondition) {\n            // prevent checking the same node multiple times\n            if (traversedNodes.has(node)) {\n                return;\n            }\n            traversedNodes.add(node);\n            // for logical operator, we check its operands\n            if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression &&\n                node.operator !== '??') {\n                traverseLogicalExpression(node, isCondition);\n                return;\n            }\n            // skip if node is not a condition\n            if (!isCondition) {\n                return;\n            }\n            checkNode(node);\n        }\n        function determineReportType(types) {\n            const is = (...wantedTypes) => types.size === wantedTypes.length &&\n                wantedTypes.every(type => types.has(type));\n            // boolean\n            if (is('boolean') || is('truthy boolean')) {\n                // boolean is always ok\n                return undefined;\n            }\n            // never\n            if (is('never')) {\n                // never is always okay\n                return undefined;\n            }\n            // nullish\n            if (is('nullish')) {\n                // condition is always false\n                return 'conditionErrorNullish';\n            }\n            // Known edge case: boolean `true` and nullish values are always valid boolean expressions\n            if (is('nullish', 'truthy boolean')) {\n                return;\n            }\n            // nullable boolean\n            if (is('nullish', 'boolean')) {\n                return !options.allowNullableBoolean\n                    ? 'conditionErrorNullableBoolean'\n                    : undefined;\n            }\n            // Known edge case: truthy primitives and nullish values are always valid boolean expressions\n            if ((options.allowNumber && is('nullish', 'truthy number')) ||\n                (options.allowString && is('nullish', 'truthy string'))) {\n                return;\n            }\n            // string\n            if (is('string') || is('truthy string')) {\n                return !options.allowString ? 'conditionErrorString' : undefined;\n            }\n            // nullable string\n            if (is('nullish', 'string')) {\n                return !options.allowNullableString\n                    ? 'conditionErrorNullableString'\n                    : undefined;\n            }\n            // number\n            if (is('number') || is('truthy number')) {\n                return !options.allowNumber ? 'conditionErrorNumber' : undefined;\n            }\n            // nullable number\n            if (is('nullish', 'number')) {\n                return !options.allowNullableNumber\n                    ? 'conditionErrorNullableNumber'\n                    : undefined;\n            }\n            // object\n            if (is('object')) {\n                return 'conditionErrorObject';\n            }\n            // nullable object\n            if (is('nullish', 'object')) {\n                return !options.allowNullableObject\n                    ? 'conditionErrorNullableObject'\n                    : undefined;\n            }\n            // nullable enum\n            if (is('nullish', 'number', 'enum') ||\n                is('nullish', 'string', 'enum') ||\n                is('nullish', 'truthy number', 'enum') ||\n                is('nullish', 'truthy string', 'enum') ||\n                // mixed enums\n                is('nullish', 'truthy number', 'truthy string', 'enum') ||\n                is('nullish', 'truthy number', 'string', 'enum') ||\n                is('nullish', 'truthy string', 'number', 'enum') ||\n                is('nullish', 'number', 'string', 'enum')) {\n                return !options.allowNullableEnum\n                    ? 'conditionErrorNullableEnum'\n                    : undefined;\n            }\n            // any\n            if (is('any')) {\n                return !options.allowAny ? 'conditionErrorAny' : undefined;\n            }\n            return 'conditionErrorOther';\n        }\n        function getSuggestionsForConditionError(node, conditionError) {\n            switch (conditionError) {\n                case 'conditionErrorAny':\n                    return [\n                        {\n                            messageId: 'conditionFixCastBoolean',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `Boolean(${code})`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorNullableBoolean':\n                    if (isLogicalNegationExpression(node.parent)) {\n                        // if (!nullableBoolean)\n                        return [\n                            {\n                                messageId: 'conditionFixDefaultFalse',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} ?? false`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixCompareFalse',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} === false`,\n                                }),\n                            },\n                        ];\n                    }\n                    // if (nullableBoolean)\n                    return [\n                        {\n                            messageId: 'conditionFixDefaultFalse',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} ?? false`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCompareTrue',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} === true`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorNullableEnum':\n                    if (isLogicalNegationExpression(node.parent)) {\n                        return [\n                            {\n                                messageId: 'conditionFixCompareNullish',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} == null`,\n                                }),\n                            },\n                        ];\n                    }\n                    return [\n                        {\n                            messageId: 'conditionFixCompareNullish',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} != null`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorNullableNumber':\n                    if (isLogicalNegationExpression(node.parent)) {\n                        // if (!nullableNumber)\n                        return [\n                            {\n                                messageId: 'conditionFixCompareNullish',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} == null`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixDefaultZero',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} ?? 0`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixCastBoolean',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `!Boolean(${code})`,\n                                }),\n                            },\n                        ];\n                    }\n                    // if (nullableNumber)\n                    return [\n                        {\n                            messageId: 'conditionFixCompareNullish',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} != null`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixDefaultZero',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} ?? 0`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCastBoolean',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `Boolean(${code})`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorNullableObject':\n                    if (isLogicalNegationExpression(node.parent)) {\n                        // if (!nullableObject)\n                        return [\n                            {\n                                messageId: 'conditionFixCompareNullish',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} == null`,\n                                }),\n                            },\n                        ];\n                    }\n                    // if (nullableObject)\n                    return [\n                        {\n                            messageId: 'conditionFixCompareNullish',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} != null`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorNullableString':\n                    if (isLogicalNegationExpression(node.parent)) {\n                        // if (!nullableString)\n                        return [\n                            {\n                                messageId: 'conditionFixCompareNullish',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} == null`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixDefaultEmptyString',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} ?? \"\"`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixCastBoolean',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `!Boolean(${code})`,\n                                }),\n                            },\n                        ];\n                    }\n                    // if (nullableString)\n                    return [\n                        {\n                            messageId: 'conditionFixCompareNullish',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} != null`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixDefaultEmptyString',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} ?? \"\"`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCastBoolean',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `Boolean(${code})`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorNumber':\n                    if (isArrayLengthExpression(node, checker, services)) {\n                        if (isLogicalNegationExpression(node.parent)) {\n                            // if (!array.length)\n                            return [\n                                {\n                                    messageId: 'conditionFixCompareArrayLengthZero',\n                                    fix: (0, util_1.getWrappingFixer)({\n                                        node: node.parent,\n                                        innerNode: node,\n                                        sourceCode: context.sourceCode,\n                                        wrap: code => `${code} === 0`,\n                                    }),\n                                },\n                            ];\n                        }\n                        // if (array.length)\n                        return [\n                            {\n                                messageId: 'conditionFixCompareArrayLengthNonzero',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} > 0`,\n                                }),\n                            },\n                        ];\n                    }\n                    if (isLogicalNegationExpression(node.parent)) {\n                        // if (!number)\n                        return [\n                            {\n                                messageId: 'conditionFixCompareZero',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    // TODO: we have to compare to 0n if the type is bigint\n                                    wrap: code => `${code} === 0`,\n                                }),\n                            },\n                            {\n                                // TODO: don't suggest this for bigint because it can't be NaN\n                                messageId: 'conditionFixCompareNaN',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `Number.isNaN(${code})`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixCastBoolean',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `!Boolean(${code})`,\n                                }),\n                            },\n                        ];\n                    }\n                    // if (number)\n                    return [\n                        {\n                            messageId: 'conditionFixCompareZero',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} !== 0`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCompareNaN',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `!Number.isNaN(${code})`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCastBoolean',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `Boolean(${code})`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorString':\n                    if (isLogicalNegationExpression(node.parent)) {\n                        // if (!string)\n                        return [\n                            {\n                                messageId: 'conditionFixCompareStringLength',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code}.length === 0`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixCompareEmptyString',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `${code} === \"\"`,\n                                }),\n                            },\n                            {\n                                messageId: 'conditionFixCastBoolean',\n                                fix: (0, util_1.getWrappingFixer)({\n                                    node: node.parent,\n                                    innerNode: node,\n                                    sourceCode: context.sourceCode,\n                                    wrap: code => `!Boolean(${code})`,\n                                }),\n                            },\n                        ];\n                    }\n                    // if (string)\n                    return [\n                        {\n                            messageId: 'conditionFixCompareStringLength',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code}.length > 0`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCompareEmptyString',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `${code} !== \"\"`,\n                            }),\n                        },\n                        {\n                            messageId: 'conditionFixCastBoolean',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node,\n                                sourceCode: context.sourceCode,\n                                wrap: code => `Boolean(${code})`,\n                            }),\n                        },\n                    ];\n                case 'conditionErrorObject':\n                case 'conditionErrorNullish':\n                case 'conditionErrorOther':\n                    return [];\n                default:\n                    conditionError;\n                    throw new Error('Unreachable');\n            }\n        }\n        /**\n         * This function does the actual type check on a node.\n         * It analyzes the type of a node and checks if it is allowed in a boolean context.\n         */\n        function checkNode(node) {\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);\n            const types = inspectVariantTypes(tsutils.unionTypeParts(type));\n            const reportType = determineReportType(types);\n            if (reportType != null) {\n                context.report({\n                    node,\n                    messageId: reportType,\n                    data: {\n                        context: 'conditional',\n                    },\n                    suggest: getSuggestionsForConditionError(node, reportType),\n                });\n            }\n        }\n        /**\n         * Check union variants for the types we care about\n         */\n        function inspectVariantTypes(types) {\n            const variantTypes = new Set();\n            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {\n                variantTypes.add('nullish');\n            }\n            const booleans = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike));\n            // If incoming type is either \"true\" or \"false\", there will be one type\n            // object with intrinsicName set accordingly\n            // If incoming type is boolean, there will be two type objects with\n            // intrinsicName set \"true\" and \"false\" each because of ts-api-utils.unionTypeParts()\n            if (booleans.length === 1) {\n                variantTypes.add(tsutils.isTrueLiteralType(booleans[0]) ? 'truthy boolean' : 'boolean');\n            }\n            else if (booleans.length === 2) {\n                variantTypes.add('boolean');\n            }\n            const strings = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));\n            if (strings.length) {\n                if (strings.every(type => type.isStringLiteral() && type.value !== '')) {\n                    variantTypes.add('truthy string');\n                }\n                else {\n                    variantTypes.add('string');\n                }\n            }\n            const numbers = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));\n            if (numbers.length) {\n                if (numbers.every(type => type.isNumberLiteral() && type.value !== 0)) {\n                    variantTypes.add('truthy number');\n                }\n                else {\n                    variantTypes.add('number');\n                }\n            }\n            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))) {\n                variantTypes.add('enum');\n            }\n            if (types.some(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null |\n                ts.TypeFlags.Undefined |\n                ts.TypeFlags.VoidLike |\n                ts.TypeFlags.BooleanLike |\n                ts.TypeFlags.StringLike |\n                ts.TypeFlags.NumberLike |\n                ts.TypeFlags.BigIntLike |\n                ts.TypeFlags.TypeParameter |\n                ts.TypeFlags.Any |\n                ts.TypeFlags.Unknown |\n                ts.TypeFlags.Never))) {\n                variantTypes.add(types.some(isBrandedBoolean) ? 'boolean' : 'object');\n            }\n            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.TypeParameter |\n                ts.TypeFlags.Any |\n                ts.TypeFlags.Unknown))) {\n                variantTypes.add('any');\n            }\n            if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {\n                variantTypes.add('never');\n            }\n            return variantTypes;\n        }\n    },\n});\nfunction isLogicalNegationExpression(node) {\n    return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '!';\n}\nfunction isArrayLengthExpression(node, typeChecker, services) {\n    if (node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n        return false;\n    }\n    if (node.computed) {\n        return false;\n    }\n    if (node.property.name !== 'length') {\n        return false;\n    }\n    const objectType = (0, util_1.getConstrainedTypeAtLocation)(services, node.object);\n    return (0, util_1.isTypeArrayTypeOrUnionOfArrayTypes)(objectType, typeChecker);\n}\n/**\n * Verify is the type is a branded boolean (e.g. `type Foo = boolean & { __brand: 'Foo' }`)\n *\n * @param type The type checked\n */\nfunction isBrandedBoolean(type) {\n    return (type.isIntersection() &&\n        type.types.some(childType => isBooleanType(childType)));\n}\nfunction isBooleanType(expressionType) {\n    return tsutils.isTypeFlagSet(expressionType, ts.TypeFlags.Boolean | ts.TypeFlags.BooleanLiteral);\n}\n"
        }
    ]
}