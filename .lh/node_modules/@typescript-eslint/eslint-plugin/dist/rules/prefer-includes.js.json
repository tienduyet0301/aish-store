{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-includes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst regexpp_1 = require(\"@eslint-community/regexpp\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-includes',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce `includes` method over `indexOf` method',\n            recommended: 'stylistic',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            preferIncludes: \"Use 'includes()' method instead.\",\n            preferStringIncludes: 'Use `String#includes()` method with a string instead.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function isNumber(node, value) {\n            const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n            return evaluated != null && evaluated.value === value;\n        }\n        function isPositiveCheck(node) {\n            switch (node.operator) {\n                case '!==':\n                case '!=':\n                case '>':\n                    return isNumber(node.right, -1);\n                case '>=':\n                    return isNumber(node.right, 0);\n                default:\n                    return false;\n            }\n        }\n        function isNegativeCheck(node) {\n            switch (node.operator) {\n                case '===':\n                case '==':\n                case '<=':\n                    return isNumber(node.right, -1);\n                case '<':\n                    return isNumber(node.right, 0);\n                default:\n                    return false;\n            }\n        }\n        function hasSameParameters(nodeA, nodeB) {\n            if (!ts.isFunctionLike(nodeA) || !ts.isFunctionLike(nodeB)) {\n                return false;\n            }\n            const paramsA = nodeA.parameters;\n            const paramsB = nodeB.parameters;\n            if (paramsA.length !== paramsB.length) {\n                return false;\n            }\n            for (let i = 0; i < paramsA.length; ++i) {\n                const paramA = paramsA[i];\n                const paramB = paramsB[i];\n                // Check name, type, and question token once.\n                if (paramA.getText() !== paramB.getText()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Parse a given node if it's a `RegExp` instance.\n         * @param node The node to parse.\n         */\n        function parseRegExp(node) {\n            const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n            if (evaluated == null || !(evaluated.value instanceof RegExp)) {\n                return null;\n            }\n            const { flags, pattern } = (0, regexpp_1.parseRegExpLiteral)(evaluated.value);\n            if (pattern.alternatives.length !== 1 ||\n                flags.ignoreCase ||\n                flags.global) {\n                return null;\n            }\n            // Check if it can determine a unique string.\n            const chars = pattern.alternatives[0].elements;\n            if (!chars.every(c => c.type === 'Character')) {\n                return null;\n            }\n            // To string.\n            return String.fromCodePoint(...chars.map(c => c.value));\n        }\n        function escapeString(str) {\n            const EscapeMap = {\n                '\\0': '\\\\0',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\v': '\\\\v',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                \"'\": \"\\\\'\",\n                '\\\\': '\\\\\\\\',\n                // \"\\b\" cause unexpected replacements\n                // '\\b': '\\\\b',\n            };\n            const replaceRegex = new RegExp(Object.values(EscapeMap).join('|'), 'g');\n            return str.replaceAll(replaceRegex, char => EscapeMap[char]);\n        }\n        function checkArrayIndexOf(node, allowFixing) {\n            if (!(0, util_1.isStaticMemberAccessOfValue)(node, context, 'indexOf')) {\n                return;\n            }\n            // Check if the comparison is equivalent to `includes()`.\n            const callNode = node.parent;\n            const compareNode = (callNode.parent.type === utils_1.AST_NODE_TYPES.ChainExpression\n                ? callNode.parent.parent\n                : callNode.parent);\n            const negative = isNegativeCheck(compareNode);\n            if (!negative && !isPositiveCheck(compareNode)) {\n                return;\n            }\n            // Get the symbol of `indexOf` method.\n            const indexofMethodDeclarations = services\n                .getSymbolAtLocation(node.property)\n                ?.getDeclarations();\n            if (indexofMethodDeclarations == null ||\n                indexofMethodDeclarations.length === 0) {\n                return;\n            }\n            // Check if every declaration of `indexOf` method has `includes` method\n            // and the two methods have the same parameters.\n            for (const instanceofMethodDecl of indexofMethodDeclarations) {\n                const typeDecl = instanceofMethodDecl.parent;\n                const type = checker.getTypeAtLocation(typeDecl);\n                const includesMethodDecl = type\n                    .getProperty('includes')\n                    ?.getDeclarations();\n                if (!includesMethodDecl?.some(includesMethodDecl => hasSameParameters(includesMethodDecl, instanceofMethodDecl))) {\n                    return;\n                }\n            }\n            // Report it.\n            context.report({\n                node: compareNode,\n                messageId: 'preferIncludes',\n                ...(allowFixing && {\n                    *fix(fixer) {\n                        if (negative) {\n                            yield fixer.insertTextBefore(callNode, '!');\n                        }\n                        yield fixer.replaceText(node.property, 'includes');\n                        yield fixer.removeRange([callNode.range[1], compareNode.range[1]]);\n                    },\n                }),\n            });\n        }\n        return {\n            // a.indexOf(b) !== 1\n            'BinaryExpression > CallExpression.left > MemberExpression'(node) {\n                checkArrayIndexOf(node, /* allowFixing */ true);\n            },\n            // a?.indexOf(b) !== 1\n            'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression'(node) {\n                checkArrayIndexOf(node, /* allowFixing */ false);\n            },\n            // /bar/.test(foo)\n            'CallExpression[arguments.length=1] > MemberExpression.callee[property.name=\"test\"][computed=false]'(node) {\n                const callNode = node.parent;\n                const text = parseRegExp(node.object);\n                if (text == null) {\n                    return;\n                }\n                //check the argument type of test methods\n                const argument = callNode.arguments[0];\n                const type = (0, util_1.getConstrainedTypeAtLocation)(services, argument);\n                const includesMethodDecl = type\n                    .getProperty('includes')\n                    ?.getDeclarations();\n                if (includesMethodDecl == null) {\n                    return;\n                }\n                context.report({\n                    node: callNode,\n                    messageId: 'preferStringIncludes',\n                    *fix(fixer) {\n                        const argNode = callNode.arguments[0];\n                        const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.Identifier &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &&\n                            argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;\n                        yield fixer.removeRange([callNode.range[0], argNode.range[0]]);\n                        yield fixer.removeRange([argNode.range[1], callNode.range[1]]);\n                        if (needsParen) {\n                            yield fixer.insertTextBefore(argNode, '(');\n                            yield fixer.insertTextAfter(argNode, ')');\n                        }\n                        yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}includes('${escapeString(text)}')`);\n                    },\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}