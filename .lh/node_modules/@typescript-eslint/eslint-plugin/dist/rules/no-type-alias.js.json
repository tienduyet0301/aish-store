{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-type-alias.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891968644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-type-alias',\n    meta: {\n        type: 'suggestion',\n        deprecated: true,\n        docs: {\n            description: 'Disallow type aliases',\n            // too opinionated to be recommended\n        },\n        messages: {\n            noCompositionAlias: '{{typeName}} in {{compositionType}} types are not allowed.',\n            noTypeAlias: 'Type {{alias}} are not allowed.',\n        },\n        schema: [\n            {\n                type: 'object',\n                $defs: {\n                    expandedOptions: {\n                        type: 'string',\n                        enum: [\n                            'always',\n                            'never',\n                            'in-unions',\n                            'in-intersections',\n                            'in-unions-and-intersections',\n                        ],\n                    },\n                    simpleOptions: {\n                        type: 'string',\n                        enum: ['always', 'never'],\n                    },\n                },\n                additionalProperties: false,\n                properties: {\n                    allowAliases: {\n                        $ref: '#/items/0/$defs/expandedOptions',\n                        description: 'Whether to allow direct one-to-one type aliases.',\n                    },\n                    allowCallbacks: {\n                        $ref: '#/items/0/$defs/simpleOptions',\n                        description: 'Whether to allow type aliases for callbacks.',\n                    },\n                    allowConditionalTypes: {\n                        $ref: '#/items/0/$defs/simpleOptions',\n                        description: 'Whether to allow type aliases for conditional types.',\n                    },\n                    allowConstructors: {\n                        $ref: '#/items/0/$defs/simpleOptions',\n                        description: 'Whether to allow type aliases with constructors.',\n                    },\n                    allowGenerics: {\n                        $ref: '#/items/0/$defs/simpleOptions',\n                        description: 'Whether to allow type aliases with generic types.',\n                    },\n                    allowLiterals: {\n                        $ref: '#/items/0/$defs/expandedOptions',\n                        description: 'Whether to allow type aliases with object literal types.',\n                    },\n                    allowMappedTypes: {\n                        $ref: '#/items/0/$defs/expandedOptions',\n                        description: 'Whether to allow type aliases with mapped types.',\n                    },\n                    allowTupleTypes: {\n                        $ref: '#/items/0/$defs/expandedOptions',\n                        description: 'Whether to allow type aliases with tuple types.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowAliases: 'never',\n            allowCallbacks: 'never',\n            allowConditionalTypes: 'never',\n            allowConstructors: 'never',\n            allowGenerics: 'never',\n            allowLiterals: 'never',\n            allowMappedTypes: 'never',\n            allowTupleTypes: 'never',\n        },\n    ],\n    create(context, [{ allowAliases, allowCallbacks, allowConditionalTypes, allowConstructors, allowGenerics, allowLiterals, allowMappedTypes, allowTupleTypes, },]) {\n        const unions = ['always', 'in-unions', 'in-unions-and-intersections'];\n        const intersections = [\n            'always',\n            'in-intersections',\n            'in-unions-and-intersections',\n        ];\n        const compositions = [\n            'in-unions',\n            'in-intersections',\n            'in-unions-and-intersections',\n        ];\n        const aliasTypes = new Set([\n            utils_1.AST_NODE_TYPES.TSArrayType,\n            utils_1.AST_NODE_TYPES.TSImportType,\n            utils_1.AST_NODE_TYPES.TSIndexedAccessType,\n            utils_1.AST_NODE_TYPES.TSLiteralType,\n            utils_1.AST_NODE_TYPES.TSTemplateLiteralType,\n            utils_1.AST_NODE_TYPES.TSTypeQuery,\n            utils_1.AST_NODE_TYPES.TSTypeReference,\n        ]);\n        /**\n         * Determines if the composition type is supported by the allowed flags.\n         * @param isTopLevel a flag indicating this is the top level node.\n         * @param compositionType the composition type (either TSUnionType or TSIntersectionType)\n         * @param allowed the currently allowed flags.\n         */\n        function isSupportedComposition(isTopLevel, compositionType, allowed) {\n            return (!compositions.includes(allowed) ||\n                (!isTopLevel &&\n                    ((compositionType === utils_1.AST_NODE_TYPES.TSUnionType &&\n                        unions.includes(allowed)) ||\n                        (compositionType === utils_1.AST_NODE_TYPES.TSIntersectionType &&\n                            intersections.includes(allowed)))));\n        }\n        /**\n         * Gets the message to be displayed based on the node type and whether the node is a top level declaration.\n         * @param node the location\n         * @param compositionType the type of composition this alias is part of (undefined if not\n         *                                  part of a composition)\n         * @param isRoot a flag indicating we are dealing with the top level declaration.\n         * @param type the kind of type alias being validated.\n         */\n        function reportError(node, compositionType, isRoot, type) {\n            if (isRoot) {\n                return context.report({\n                    node,\n                    messageId: 'noTypeAlias',\n                    data: {\n                        alias: type.toLowerCase(),\n                    },\n                });\n            }\n            return context.report({\n                node,\n                messageId: 'noCompositionAlias',\n                data: {\n                    compositionType: compositionType === utils_1.AST_NODE_TYPES.TSUnionType\n                        ? 'union'\n                        : 'intersection',\n                    typeName: type,\n                },\n            });\n        }\n        const isValidTupleType = (type) => {\n            if (type.node.type === utils_1.AST_NODE_TYPES.TSTupleType) {\n                return true;\n            }\n            if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&\n                ['keyof', 'readonly'].includes(type.node.operator) &&\n                type.node.typeAnnotation &&\n                type.node.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTupleType) {\n                return true;\n            }\n            return false;\n        };\n        const isValidGeneric = (type) => {\n            return (type.node.type === utils_1.AST_NODE_TYPES.TSTypeReference &&\n                type.node.typeArguments != null);\n        };\n        const checkAndReport = (optionValue, isTopLevel, type, label) => {\n            if (optionValue === 'never' ||\n                !isSupportedComposition(isTopLevel, type.compositionType, optionValue)) {\n                reportError(type.node, type.compositionType, isTopLevel, label);\n            }\n        };\n        /**\n         * Validates the node looking for aliases, callbacks and literals.\n         * @param type the type of composition this alias is part of (null if not\n         *                                  part of a composition)\n         * @param isTopLevel a flag indicating this is the top level node.\n         */\n        function validateTypeAliases(type, isTopLevel = false) {\n            // https://github.com/typescript-eslint/typescript-eslint/issues/5439\n            /* eslint-disable @typescript-eslint/no-non-null-assertion */\n            if (type.node.type === utils_1.AST_NODE_TYPES.TSFunctionType) {\n                // callback\n                if (allowCallbacks === 'never') {\n                    reportError(type.node, type.compositionType, isTopLevel, 'Callbacks');\n                }\n            }\n            else if (type.node.type === utils_1.AST_NODE_TYPES.TSConditionalType) {\n                // conditional type\n                if (allowConditionalTypes === 'never') {\n                    reportError(type.node, type.compositionType, isTopLevel, 'Conditional types');\n                }\n            }\n            else if (type.node.type === utils_1.AST_NODE_TYPES.TSConstructorType) {\n                if (allowConstructors === 'never') {\n                    reportError(type.node, type.compositionType, isTopLevel, 'Constructors');\n                }\n            }\n            else if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeLiteral) {\n                // literal object type\n                checkAndReport(allowLiterals, isTopLevel, type, 'Literals');\n            }\n            else if (type.node.type === utils_1.AST_NODE_TYPES.TSMappedType) {\n                // mapped type\n                checkAndReport(allowMappedTypes, isTopLevel, type, 'Mapped types');\n            }\n            else if (isValidTupleType(type)) {\n                // tuple types\n                checkAndReport(allowTupleTypes, isTopLevel, type, 'Tuple Types');\n            }\n            else if (isValidGeneric(type)) {\n                if (allowGenerics === 'never') {\n                    reportError(type.node, type.compositionType, isTopLevel, 'Generics');\n                }\n            }\n            else if (type.node.type.endsWith(utils_1.AST_TOKEN_TYPES.Keyword) ||\n                aliasTypes.has(type.node.type) ||\n                (type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&\n                    (type.node.operator === 'keyof' ||\n                        (type.node.operator === 'readonly' &&\n                            type.node.typeAnnotation &&\n                            aliasTypes.has(type.node.typeAnnotation.type))))) {\n                // alias / keyword\n                checkAndReport(allowAliases, isTopLevel, type, 'Aliases');\n            }\n            else {\n                // unhandled type - shouldn't happen\n                reportError(type.node, type.compositionType, isTopLevel, 'Unhandled');\n            }\n            /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        }\n        /**\n         * Flatten the given type into an array of its dependencies\n         */\n        function getTypes(node, compositionType = null) {\n            if (node.type === utils_1.AST_NODE_TYPES.TSUnionType ||\n                node.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n                return node.types.flatMap(type => getTypes(type, node.type));\n            }\n            return [{ node, compositionType }];\n        }\n        return {\n            TSTypeAliasDeclaration(node) {\n                const types = getTypes(node.typeAnnotation);\n                if (types.length === 1) {\n                    // is a top level type annotation\n                    validateTypeAliases(types[0], true);\n                }\n                else {\n                    // is a composition type\n                    types.forEach(type => {\n                        validateTypeAliases(type);\n                    });\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}