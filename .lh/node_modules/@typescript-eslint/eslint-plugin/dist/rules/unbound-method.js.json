{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/unbound-method.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\n/**\n * Static methods on these globals are either not `this`-aware or supported being\n * called without `this`.\n *\n * - `Promise` is not in the list because it supports subclassing by using `this`\n * - `Array` is in the list because although it supports subclassing, the `this`\n *   value defaults to `Array` when unbound\n *\n * This is now a language-design invariant: static methods are never `this`-aware\n * because TC39 wants to make `array.map(Class.method)` work!\n */\nconst SUPPORTED_GLOBALS = [\n    'Number',\n    'Object',\n    'String', // eslint-disable-line @typescript-eslint/internal/prefer-ast-types-enum\n    'RegExp',\n    'Symbol',\n    'Array',\n    'Proxy',\n    'Date',\n    'Atomics',\n    'Reflect',\n    'console',\n    'Math',\n    'JSON',\n    'Intl',\n];\nconst nativelyBoundMembers = new Set(SUPPORTED_GLOBALS.flatMap(namespace => {\n    if (!(namespace in global)) {\n        // node.js might not have namespaces like Intl depending on compilation options\n        // https://nodejs.org/api/intl.html#intl_options_for_building_node_js\n        return [];\n    }\n    const object = global[namespace];\n    return Object.getOwnPropertyNames(object)\n        .filter(name => !name.startsWith('_') &&\n        typeof object[name] === 'function')\n        .map(name => `${namespace}.${name}`);\n}));\nconst SUPPORTED_GLOBAL_TYPES = [\n    'NumberConstructor',\n    'ObjectConstructor',\n    'StringConstructor',\n    'SymbolConstructor',\n    'ArrayConstructor',\n    'Array',\n    'ProxyConstructor',\n    'Console',\n    'DateConstructor',\n    'Atomics',\n    'Math',\n    'JSON',\n];\nconst isNotImported = (symbol, currentSourceFile) => {\n    const { valueDeclaration } = symbol;\n    if (!valueDeclaration) {\n        // working around https://github.com/microsoft/TypeScript/issues/31294\n        return false;\n    }\n    return (!!currentSourceFile &&\n        currentSourceFile !== valueDeclaration.getSourceFile());\n};\nconst BASE_MESSAGE = 'Avoid referencing unbound methods which may cause unintentional scoping of `this`.';\nexports.default = (0, util_1.createRule)({\n    name: 'unbound-method',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Enforce unbound methods are called with their expected scope',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            unbound: BASE_MESSAGE,\n            unboundWithoutThisAnnotation: `${BASE_MESSAGE}\\nIf your function does not access \\`this\\`, you can annotate it with \\`this: void\\`, or consider using an arrow function instead.`,\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ignoreStatic: {\n                        type: 'boolean',\n                        description: 'Whether to skip checking whether `static` methods are correctly bound.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            ignoreStatic: false,\n        },\n    ],\n    create(context, [{ ignoreStatic }]) {\n        const services = (0, util_1.getParserServices)(context);\n        const currentSourceFile = services.program.getSourceFile(context.filename);\n        function checkIfMethodAndReport(node, symbol) {\n            if (!symbol) {\n                return false;\n            }\n            const { dangerous, firstParamIsThis } = checkIfMethod(symbol, ignoreStatic);\n            if (dangerous) {\n                context.report({\n                    node,\n                    messageId: firstParamIsThis === false\n                        ? 'unboundWithoutThisAnnotation'\n                        : 'unbound',\n                });\n                return true;\n            }\n            return false;\n        }\n        function isNativelyBound(object, property) {\n            // We can't rely entirely on the type-level checks made at the end of this\n            // function, because sometimes type declarations don't come from the\n            // default library, but come from, for example, \"@types/node\". And we can't\n            // tell if a method is unbound just by looking at its signature declared in\n            // the interface.\n            //\n            // See related discussion https://github.com/typescript-eslint/typescript-eslint/pull/8952#discussion_r1576543310\n            if (object.type === utils_1.AST_NODE_TYPES.Identifier &&\n                property.type === utils_1.AST_NODE_TYPES.Identifier) {\n                const objectSymbol = services.getSymbolAtLocation(object);\n                const notImported = objectSymbol != null &&\n                    isNotImported(objectSymbol, currentSourceFile);\n                if (notImported &&\n                    nativelyBoundMembers.has(`${object.name}.${property.name}`)) {\n                    return true;\n                }\n            }\n            // if `${object.name}.${property.name}` doesn't match any of\n            // the nativelyBoundMembers, then we fallback to type-level checks\n            return ((0, util_1.isBuiltinSymbolLike)(services.program, services.getTypeAtLocation(object), SUPPORTED_GLOBAL_TYPES) &&\n                (0, util_1.isSymbolFromDefaultLibrary)(services.program, services.getTypeAtLocation(property).getSymbol()));\n        }\n        return {\n            MemberExpression(node) {\n                if (isSafeUse(node) || isNativelyBound(node.object, node.property)) {\n                    return;\n                }\n                checkIfMethodAndReport(node, services.getSymbolAtLocation(node));\n            },\n            ObjectPattern(node) {\n                if (isNodeInsideTypeDeclaration(node)) {\n                    return;\n                }\n                let initNode = null;\n                if (node.parent.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n                    initNode = node.parent.init;\n                }\n                else if (node.parent.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||\n                    node.parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {\n                    initNode = node.parent.right;\n                }\n                for (const property of node.properties) {\n                    if (property.type !== utils_1.AST_NODE_TYPES.Property ||\n                        property.key.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                        continue;\n                    }\n                    if (initNode) {\n                        if (!isNativelyBound(initNode, property.key)) {\n                            const reported = checkIfMethodAndReport(property.key, services\n                                .getTypeAtLocation(initNode)\n                                .getProperty(property.key.name));\n                            if (reported) {\n                                continue;\n                            }\n                            // In assignment patterns, we should also check the type of\n                            // Foo's nativelyBound method because initNode might be used as\n                            // default value:\n                            //   function ({ nativelyBound }: Foo = NativeObject) {}\n                        }\n                        else if (node.parent.type !== utils_1.AST_NODE_TYPES.AssignmentPattern) {\n                            continue;\n                        }\n                    }\n                    for (const intersectionPart of tsutils\n                        .unionTypeParts(services.getTypeAtLocation(node))\n                        .flatMap(unionPart => tsutils.intersectionTypeParts(unionPart))) {\n                        const reported = checkIfMethodAndReport(property.key, intersectionPart.getProperty(property.key.name));\n                        if (reported) {\n                            break;\n                        }\n                    }\n                }\n            },\n        };\n    },\n});\nfunction isNodeInsideTypeDeclaration(node) {\n    let parent = node;\n    while ((parent = parent.parent)) {\n        if ((parent.type === utils_1.AST_NODE_TYPES.ClassDeclaration && parent.declare) ||\n            parent.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition ||\n            parent.type === utils_1.AST_NODE_TYPES.TSDeclareFunction ||\n            parent.type === utils_1.AST_NODE_TYPES.TSFunctionType ||\n            parent.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||\n            parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration ||\n            (parent.type === utils_1.AST_NODE_TYPES.VariableDeclaration && parent.declare)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction checkIfMethod(symbol, ignoreStatic) {\n    const { valueDeclaration } = symbol;\n    if (!valueDeclaration) {\n        // working around https://github.com/microsoft/TypeScript/issues/31294\n        return { dangerous: false };\n    }\n    switch (valueDeclaration.kind) {\n        case ts.SyntaxKind.PropertyDeclaration:\n            return {\n                dangerous: valueDeclaration.initializer?.kind ===\n                    ts.SyntaxKind.FunctionExpression,\n            };\n        case ts.SyntaxKind.PropertyAssignment: {\n            const assignee = valueDeclaration.initializer;\n            if (assignee.kind !== ts.SyntaxKind.FunctionExpression) {\n                return {\n                    dangerous: false,\n                };\n            }\n            return checkMethod(assignee, ignoreStatic);\n        }\n        case ts.SyntaxKind.MethodDeclaration:\n        case ts.SyntaxKind.MethodSignature: {\n            return checkMethod(valueDeclaration, ignoreStatic);\n        }\n    }\n    return { dangerous: false };\n}\nfunction checkMethod(valueDeclaration, ignoreStatic) {\n    const firstParam = valueDeclaration.parameters.at(0);\n    const firstParamIsThis = firstParam?.name.kind === ts.SyntaxKind.Identifier &&\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        firstParam.name.escapedText === 'this';\n    const thisArgIsVoid = firstParamIsThis && firstParam.type?.kind === ts.SyntaxKind.VoidKeyword;\n    return {\n        dangerous: !thisArgIsVoid &&\n            !(ignoreStatic &&\n                tsutils.includesModifier((0, util_1.getModifiers)(valueDeclaration), ts.SyntaxKind.StaticKeyword)),\n        firstParamIsThis,\n    };\n}\nfunction isSafeUse(node) {\n    const parent = node.parent;\n    switch (parent?.type) {\n        case utils_1.AST_NODE_TYPES.IfStatement:\n        case utils_1.AST_NODE_TYPES.ForStatement:\n        case utils_1.AST_NODE_TYPES.MemberExpression:\n        case utils_1.AST_NODE_TYPES.SwitchStatement:\n        case utils_1.AST_NODE_TYPES.UpdateExpression:\n        case utils_1.AST_NODE_TYPES.WhileStatement:\n            return true;\n        case utils_1.AST_NODE_TYPES.CallExpression:\n            return parent.callee === node;\n        case utils_1.AST_NODE_TYPES.ConditionalExpression:\n            return parent.test === node;\n        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n            return parent.tag === node;\n        case utils_1.AST_NODE_TYPES.UnaryExpression:\n            // the first case is safe for obvious\n            // reasons. The second one is also fine\n            // since we're returning something falsy\n            return ['!', 'delete', 'typeof', 'void'].includes(parent.operator);\n        case utils_1.AST_NODE_TYPES.BinaryExpression:\n            return ['!=', '!==', '==', '===', 'instanceof'].includes(parent.operator);\n        case utils_1.AST_NODE_TYPES.AssignmentExpression:\n            return (parent.operator === '=' &&\n                (node === parent.left ||\n                    (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                        node.object.type === utils_1.AST_NODE_TYPES.Super &&\n                        parent.left.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                        parent.left.object.type === utils_1.AST_NODE_TYPES.ThisExpression)));\n        case utils_1.AST_NODE_TYPES.ChainExpression:\n        case utils_1.AST_NODE_TYPES.TSNonNullExpression:\n        case utils_1.AST_NODE_TYPES.TSAsExpression:\n        case utils_1.AST_NODE_TYPES.TSTypeAssertion:\n            return isSafeUse(parent);\n        case utils_1.AST_NODE_TYPES.LogicalExpression:\n            if (parent.operator === '&&' && parent.left === node) {\n                // this is safe, as && will return the left if and only if it's falsy\n                return true;\n            }\n            // in all other cases, it's likely the logical expression will return the method ref\n            // so make sure the parent is a safe usage\n            return isSafeUse(parent);\n    }\n    return false;\n}\n"
        }
    ]
}