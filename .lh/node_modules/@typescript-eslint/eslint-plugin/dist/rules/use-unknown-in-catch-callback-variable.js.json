{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/use-unknown-in-catch-callback-variable.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst util_1 = require(\"../util\");\nconst useUnknownMessageBase = 'Prefer the safe `: unknown` for a `{{method}}`{{append}} callback variable.';\nexports.default = (0, util_1.createRule)({\n    name: 'use-unknown-in-catch-callback-variable',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce typing arguments in Promise rejection callbacks as `unknown`',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        hasSuggestions: true,\n        messages: {\n            addUnknownRestTypeAnnotationSuggestion: 'Add an explicit `: [unknown]` type annotation to the rejection callback rest variable.',\n            addUnknownTypeAnnotationSuggestion: 'Add an explicit `: unknown` type annotation to the rejection callback variable.',\n            useUnknown: useUnknownMessageBase,\n            useUnknownArrayDestructuringPattern: `${useUnknownMessageBase} The thrown error may not be iterable.`,\n            useUnknownObjectDestructuringPattern: `${useUnknownMessageBase} The thrown error may be nullable, or may not have the expected shape.`,\n            wrongRestTypeAnnotationSuggestion: 'Change existing type annotation to `: [unknown]`.',\n            wrongTypeAnnotationSuggestion: 'Change existing type annotation to `: unknown`.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const { esTreeNodeToTSNodeMap, program } = (0, util_1.getParserServices)(context);\n        const checker = program.getTypeChecker();\n        function isFlaggableHandlerType(type) {\n            for (const unionPart of tsutils.unionTypeParts(type)) {\n                const callSignatures = tsutils.getCallSignaturesOfType(unionPart);\n                if (callSignatures.length === 0) {\n                    // Ignore any non-function components to the type. Those are not this rule's problem.\n                    continue;\n                }\n                for (const callSignature of callSignatures) {\n                    const firstParam = callSignature.parameters.at(0);\n                    if (!firstParam) {\n                        // it's not an issue if there's no catch variable at all.\n                        continue;\n                    }\n                    let firstParamType = checker.getTypeOfSymbol(firstParam);\n                    const decl = firstParam.valueDeclaration;\n                    if (decl != null && (0, util_1.isRestParameterDeclaration)(decl)) {\n                        if (checker.isArrayType(firstParamType)) {\n                            firstParamType = checker.getTypeArguments(firstParamType)[0];\n                        }\n                        else if (checker.isTupleType(firstParamType)) {\n                            firstParamType = checker.getTypeArguments(firstParamType)[0];\n                        }\n                        else {\n                            // a rest arg that's not an array or tuple should definitely be flagged.\n                            return true;\n                        }\n                    }\n                    if (!tsutils.isIntrinsicUnknownType(firstParamType)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        function collectFlaggedNodes(node) {\n            switch (node.type) {\n                case utils_1.AST_NODE_TYPES.LogicalExpression:\n                    return [\n                        ...collectFlaggedNodes(node.left),\n                        ...collectFlaggedNodes(node.right),\n                    ];\n                case utils_1.AST_NODE_TYPES.SequenceExpression:\n                    return collectFlaggedNodes((0, util_1.nullThrows)(node.expressions.at(-1), 'sequence expression must have multiple expressions'));\n                case utils_1.AST_NODE_TYPES.ConditionalExpression:\n                    return [\n                        ...collectFlaggedNodes(node.consequent),\n                        ...collectFlaggedNodes(node.alternate),\n                    ];\n                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n                case utils_1.AST_NODE_TYPES.FunctionExpression:\n                    {\n                        const argument = esTreeNodeToTSNodeMap.get(node);\n                        const typeOfArgument = checker.getTypeAtLocation(argument);\n                        if (isFlaggableHandlerType(typeOfArgument)) {\n                            return [node];\n                        }\n                    }\n                    break;\n                default:\n                    break;\n            }\n            return [];\n        }\n        /**\n         * Analyzes the syntax of the catch argument and makes a best effort to pinpoint\n         * why it's reporting, and to come up with a suggested fix if possible.\n         *\n         * This function is explicitly operating under the assumption that the\n         * rule _is reporting_, so it is not guaranteed to be sound to call otherwise.\n         */\n        function refineReportIfPossible(argument) {\n            const catchVariableOuterWithIncorrectTypes = (0, util_1.nullThrows)(argument.params.at(0), 'There should have been at least one parameter for the rule to have flagged.');\n            // Function expressions can't have parameter properties; those only exist in constructors.\n            const catchVariableOuter = catchVariableOuterWithIncorrectTypes;\n            const catchVariableInner = catchVariableOuter.type === utils_1.AST_NODE_TYPES.AssignmentPattern\n                ? catchVariableOuter.left\n                : catchVariableOuter;\n            switch (catchVariableInner.type) {\n                case utils_1.AST_NODE_TYPES.Identifier: {\n                    const catchVariableTypeAnnotation = catchVariableInner.typeAnnotation;\n                    if (catchVariableTypeAnnotation == null) {\n                        return {\n                            node: catchVariableOuter,\n                            suggest: [\n                                {\n                                    messageId: 'addUnknownTypeAnnotationSuggestion',\n                                    fix: (fixer) => {\n                                        if (argument.type ===\n                                            utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n                                            (0, util_1.isParenlessArrowFunction)(argument, context.sourceCode)) {\n                                            return [\n                                                fixer.insertTextBefore(catchVariableInner, '('),\n                                                fixer.insertTextAfter(catchVariableInner, ': unknown)'),\n                                            ];\n                                        }\n                                        return [\n                                            fixer.insertTextAfter(catchVariableInner, ': unknown'),\n                                        ];\n                                    },\n                                },\n                            ],\n                        };\n                    }\n                    return {\n                        node: catchVariableOuter,\n                        suggest: [\n                            {\n                                messageId: 'wrongTypeAnnotationSuggestion',\n                                fix: (fixer) => fixer.replaceText(catchVariableTypeAnnotation, ': unknown'),\n                            },\n                        ],\n                    };\n                }\n                case utils_1.AST_NODE_TYPES.ArrayPattern: {\n                    return {\n                        node: catchVariableOuter,\n                        messageId: 'useUnknownArrayDestructuringPattern',\n                    };\n                }\n                case utils_1.AST_NODE_TYPES.ObjectPattern: {\n                    return {\n                        node: catchVariableOuter,\n                        messageId: 'useUnknownObjectDestructuringPattern',\n                    };\n                }\n                case utils_1.AST_NODE_TYPES.RestElement: {\n                    const catchVariableTypeAnnotation = catchVariableInner.typeAnnotation;\n                    if (catchVariableTypeAnnotation == null) {\n                        return {\n                            node: catchVariableOuter,\n                            suggest: [\n                                {\n                                    messageId: 'addUnknownRestTypeAnnotationSuggestion',\n                                    fix: (fixer) => fixer.insertTextAfter(catchVariableInner, ': [unknown]'),\n                                },\n                            ],\n                        };\n                    }\n                    return {\n                        node: catchVariableOuter,\n                        suggest: [\n                            {\n                                messageId: 'wrongRestTypeAnnotationSuggestion',\n                                fix: (fixer) => fixer.replaceText(catchVariableTypeAnnotation, ': [unknown]'),\n                            },\n                        ],\n                    };\n                }\n            }\n        }\n        return {\n            CallExpression({ arguments: args, callee }) {\n                if (callee.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n                    return;\n                }\n                const staticMemberAccessKey = (0, util_1.getStaticMemberAccessValue)(callee, context);\n                if (!staticMemberAccessKey) {\n                    return;\n                }\n                const promiseMethodInfo = [\n                    { append: '', argIndexToCheck: 0, method: 'catch' },\n                    { append: ' rejection', argIndexToCheck: 1, method: 'then' },\n                ].find(({ method }) => staticMemberAccessKey === method);\n                if (!promiseMethodInfo) {\n                    return;\n                }\n                // Need to be enough args to check\n                const { argIndexToCheck, ...data } = promiseMethodInfo;\n                if (args.length < argIndexToCheck + 1) {\n                    return;\n                }\n                // Argument to check, and all arguments before it, must be \"ordinary\" arguments (i.e. no spread arguments)\n                // promise.catch(f), promise.catch(() => {}), promise.catch(<expression>, <<other-args>>)\n                const argsToCheck = args.slice(0, argIndexToCheck + 1);\n                if (argsToCheck.some(({ type }) => type === utils_1.AST_NODE_TYPES.SpreadElement)) {\n                    return;\n                }\n                if (!tsutils.isThenableType(checker, esTreeNodeToTSNodeMap.get(callee), checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(callee.object)))) {\n                    return;\n                }\n                // the `some` check above has already excluded `SpreadElement`, so we are safe to assert the same\n                const argToCheck = argsToCheck[argIndexToCheck];\n                for (const node of collectFlaggedNodes(argToCheck)) {\n                    // We are now guaranteed to report, but we have a bit of work to do\n                    // to determine exactly where, and whether we can fix it.\n                    const overrides = refineReportIfPossible(node);\n                    context.report({\n                        node,\n                        messageId: 'useUnknown',\n                        data,\n                        ...overrides,\n                    });\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}