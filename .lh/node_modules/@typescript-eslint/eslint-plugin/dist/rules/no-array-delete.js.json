{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-array-delete.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891963016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-array-delete',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow using the `delete` operator on array values',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            noArrayDelete: 'Using the `delete` operator with an array expression is unsafe.',\n            useSplice: 'Use `array.splice()` instead.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function isUnderlyingTypeArray(type) {\n            const predicate = (t) => checker.isArrayType(t) || checker.isTupleType(t);\n            if (type.isUnion()) {\n                return type.types.every(predicate);\n            }\n            if (type.isIntersection()) {\n                return type.types.some(predicate);\n            }\n            return predicate(type);\n        }\n        return {\n            'UnaryExpression[operator=\"delete\"]'(node) {\n                const { argument } = node;\n                if (argument.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n                    return;\n                }\n                const type = (0, util_1.getConstrainedTypeAtLocation)(services, argument.object);\n                if (!isUnderlyingTypeArray(type)) {\n                    return;\n                }\n                context.report({\n                    node,\n                    messageId: 'noArrayDelete',\n                    suggest: [\n                        {\n                            messageId: 'useSplice',\n                            fix(fixer) {\n                                const { object, property } = argument;\n                                const shouldHaveParentheses = property.type === utils_1.AST_NODE_TYPES.SequenceExpression;\n                                const nodeMap = services.esTreeNodeToTSNodeMap;\n                                const target = nodeMap.get(object).getText();\n                                const rawKey = nodeMap.get(property).getText();\n                                const key = shouldHaveParentheses ? `(${rawKey})` : rawKey;\n                                let suggestion = `${target}.splice(${key}, 1)`;\n                                const comments = context.sourceCode.getCommentsInside(node);\n                                if (comments.length > 0) {\n                                    const indentationCount = node.loc.start.column;\n                                    const indentation = ' '.repeat(indentationCount);\n                                    const commentsText = comments\n                                        .map(comment => {\n                                        return comment.type === utils_1.AST_TOKEN_TYPES.Line\n                                            ? `//${comment.value}`\n                                            : `/*${comment.value}*/`;\n                                    })\n                                        .join(`\\n${indentation}`);\n                                    suggestion = `${commentsText}\\n${indentation}${suggestion}`;\n                                }\n                                return fixer.replaceText(node, suggestion);\n                            },\n                        },\n                    ],\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}