{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unsafe-return.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891970445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst getParentFunctionNode_1 = require(\"../util/getParentFunctionNode\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-unsafe-return',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow returning a value with type `any` from a function',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            unsafeReturn: 'Unsafe return of a value of type {{type}}.',\n            unsafeReturnAssignment: 'Unsafe return of type `{{sender}}` from function with return type `{{receiver}}`.',\n            unsafeReturnThis: [\n                'Unsafe return of a value of type `{{type}}`. `this` is typed as `any`.',\n                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',\n            ].join('\\n'),\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const compilerOptions = services.program.getCompilerOptions();\n        const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');\n        function checkReturn(returnNode, reportingNode = returnNode) {\n            const tsNode = services.esTreeNodeToTSNodeMap.get(returnNode);\n            const type = checker.getTypeAtLocation(tsNode);\n            const anyType = (0, util_1.discriminateAnyType)(type, checker, services.program, tsNode);\n            const functionNode = (0, getParentFunctionNode_1.getParentFunctionNode)(returnNode);\n            /* istanbul ignore if */ if (!functionNode) {\n                return;\n            }\n            // function has an explicit return type, so ensure it's a safe return\n            const returnNodeType = (0, util_1.getConstrainedTypeAtLocation)(services, returnNode);\n            const functionTSNode = services.esTreeNodeToTSNodeMap.get(functionNode);\n            // function expressions will not have their return type modified based on receiver typing\n            // so we have to use the contextual typing in these cases, i.e.\n            // const foo1: () => Set<string> = () => new Set<any>();\n            // the return type of the arrow function is Set<any> even though the variable is typed as Set<string>\n            let functionType = ts.isFunctionExpression(functionTSNode) ||\n                ts.isArrowFunction(functionTSNode)\n                ? (0, util_1.getContextualType)(checker, functionTSNode)\n                : services.getTypeAtLocation(functionNode);\n            if (!functionType) {\n                functionType = services.getTypeAtLocation(functionNode);\n            }\n            const callSignatures = tsutils.getCallSignaturesOfType(functionType);\n            // If there is an explicit type annotation *and* that type matches the actual\n            // function return type, we shouldn't complain (it's intentional, even if unsafe)\n            if (functionTSNode.type) {\n                for (const signature of callSignatures) {\n                    const signatureReturnType = signature.getReturnType();\n                    if (returnNodeType === signatureReturnType ||\n                        (0, util_1.isTypeFlagSet)(signatureReturnType, ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n                        return;\n                    }\n                    if (functionNode.async) {\n                        const awaitedSignatureReturnType = checker.getAwaitedType(signatureReturnType);\n                        const awaitedReturnNodeType = checker.getAwaitedType(returnNodeType);\n                        if (awaitedReturnNodeType === awaitedSignatureReturnType ||\n                            (awaitedSignatureReturnType &&\n                                (0, util_1.isTypeFlagSet)(awaitedSignatureReturnType, ts.TypeFlags.Any | ts.TypeFlags.Unknown))) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if (anyType !== util_1.AnyType.Safe) {\n                // Allow cases when the declared return type of the function is either unknown or unknown[]\n                // and the function is returning any or any[].\n                for (const signature of callSignatures) {\n                    const functionReturnType = signature.getReturnType();\n                    if (anyType === util_1.AnyType.Any &&\n                        (0, util_1.isTypeUnknownType)(functionReturnType)) {\n                        return;\n                    }\n                    if (anyType === util_1.AnyType.AnyArray &&\n                        (0, util_1.isTypeUnknownArrayType)(functionReturnType, checker)) {\n                        return;\n                    }\n                    const awaitedType = checker.getAwaitedType(functionReturnType);\n                    if (awaitedType &&\n                        anyType === util_1.AnyType.PromiseAny &&\n                        (0, util_1.isTypeUnknownType)(awaitedType)) {\n                        return;\n                    }\n                }\n                if (anyType === util_1.AnyType.PromiseAny && !functionNode.async) {\n                    return;\n                }\n                let messageId = 'unsafeReturn';\n                const isErrorType = tsutils.isIntrinsicErrorType(returnNodeType);\n                if (!isNoImplicitThis) {\n                    // `return this`\n                    const thisExpression = (0, util_1.getThisExpression)(returnNode);\n                    if (thisExpression &&\n                        (0, util_1.isTypeAnyType)((0, util_1.getConstrainedTypeAtLocation)(services, thisExpression))) {\n                        messageId = 'unsafeReturnThis';\n                    }\n                }\n                // If the function return type was not unknown/unknown[], mark usage as unsafeReturn.\n                return context.report({\n                    node: reportingNode,\n                    messageId,\n                    data: {\n                        type: isErrorType\n                            ? 'error'\n                            : anyType === util_1.AnyType.Any\n                                ? '`any`'\n                                : anyType === util_1.AnyType.PromiseAny\n                                    ? '`Promise<any>`'\n                                    : '`any[]`',\n                    },\n                });\n            }\n            const signature = functionType.getCallSignatures().at(0);\n            if (signature) {\n                const functionReturnType = signature.getReturnType();\n                const result = (0, util_1.isUnsafeAssignment)(returnNodeType, functionReturnType, checker, returnNode);\n                if (!result) {\n                    return;\n                }\n                const { receiver, sender } = result;\n                return context.report({\n                    node: reportingNode,\n                    messageId: 'unsafeReturnAssignment',\n                    data: {\n                        receiver: checker.typeToString(receiver),\n                        sender: checker.typeToString(sender),\n                    },\n                });\n            }\n        }\n        return {\n            'ArrowFunctionExpression > :not(BlockStatement).body': checkReturn,\n            ReturnStatement(node) {\n                const argument = node.argument;\n                if (!argument) {\n                    return;\n                }\n                checkReturn(argument, node);\n            },\n        };\n    },\n});\n"
        }
    ]
}