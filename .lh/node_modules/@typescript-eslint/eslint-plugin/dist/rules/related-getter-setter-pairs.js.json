{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/related-getter-setter-pairs.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891974661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'related-getter-setter-pairs',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Enforce that `get()` types should be assignable to their equivalent `set()` type',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            mismatch: '`get()` type should be assignable to its equivalent `set()` type.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const methodPairsStack = [];\n        function addPropertyNode(member, inner, kind) {\n            const methodPairs = methodPairsStack[methodPairsStack.length - 1];\n            const { name } = (0, util_1.getNameFromMember)(member, context.sourceCode);\n            methodPairs.set(name, {\n                ...methodPairs.get(name),\n                [kind]: inner,\n            });\n        }\n        return {\n            ':matches(ClassBody, TSInterfaceBody, TSTypeLiteral):exit'() {\n                const methodPairs = methodPairsStack[methodPairsStack.length - 1];\n                for (const pair of methodPairs.values()) {\n                    if (!pair.get || !pair.set) {\n                        continue;\n                    }\n                    const getter = pair.get;\n                    const getType = services.getTypeAtLocation(getter);\n                    const setType = services.getTypeAtLocation(pair.set.params[0]);\n                    if (!checker.isTypeAssignableTo(getType, setType)) {\n                        context.report({\n                            node: getter.returnType.typeAnnotation,\n                            messageId: 'mismatch',\n                        });\n                    }\n                }\n                methodPairsStack.pop();\n            },\n            ':matches(MethodDefinition, TSMethodSignature)[kind=get]'(node) {\n                const getter = getMethodFromNode(node);\n                if (getter.returnType) {\n                    addPropertyNode(node, getter, 'get');\n                }\n            },\n            ':matches(MethodDefinition, TSMethodSignature)[kind=set]'(node) {\n                const setter = getMethodFromNode(node);\n                if (setter.params.length === 1) {\n                    addPropertyNode(node, setter, 'set');\n                }\n            },\n            'ClassBody, TSInterfaceBody, TSTypeLiteral'() {\n                methodPairsStack.push(new Map());\n            },\n        };\n    },\n});\nfunction getMethodFromNode(node) {\n    return node.type === utils_1.AST_NODE_TYPES.TSMethodSignature ? node : node.value;\n}\n"
        }
    ]
}