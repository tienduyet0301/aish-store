{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-shadow.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891968471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst isTypeImport_1 = require(\"../util/isTypeImport\");\nconst allowedFunctionVariableDefTypes = new Set([\n    utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration,\n    utils_1.AST_NODE_TYPES.TSFunctionType,\n    utils_1.AST_NODE_TYPES.TSMethodSignature,\n    utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,\n    utils_1.AST_NODE_TYPES.TSDeclareFunction,\n    utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,\n    utils_1.AST_NODE_TYPES.TSConstructorType,\n]);\nconst functionsHoistedNodes = new Set([utils_1.AST_NODE_TYPES.FunctionDeclaration]);\nconst typesHoistedNodes = new Set([\n    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n    utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n]);\nexports.default = (0, util_1.createRule)({\n    name: 'no-shadow',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow variable declarations from shadowing variables declared in the outer scope',\n            extendsBaseRule: true,\n        },\n        messages: {\n            noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n            noShadowGlobal: \"'{{name}}' is already a global variable.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allow: {\n                        type: 'array',\n                        description: 'Identifier names for which shadowing is allowed.',\n                        items: {\n                            type: 'string',\n                        },\n                    },\n                    builtinGlobals: {\n                        type: 'boolean',\n                        description: 'Whether to report shadowing of built-in global variables.',\n                    },\n                    hoist: {\n                        type: 'string',\n                        description: 'Whether to report shadowing before outer functions or variables are defined.',\n                        enum: ['all', 'functions', 'functions-and-types', 'never', 'types'],\n                    },\n                    ignoreFunctionTypeParameterNameValueShadow: {\n                        type: 'boolean',\n                        description: 'Whether to ignore function parameters named the same as a variable.',\n                    },\n                    ignoreOnInitialization: {\n                        type: 'boolean',\n                        description: 'Whether to ignore the variable initializers when the shadowed variable is presumably still unitialized.',\n                    },\n                    ignoreTypeValueShadow: {\n                        type: 'boolean',\n                        description: 'Whether to ignore types named the same as a variable.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allow: [],\n            builtinGlobals: false,\n            hoist: 'functions-and-types',\n            ignoreFunctionTypeParameterNameValueShadow: true,\n            ignoreOnInitialization: false,\n            ignoreTypeValueShadow: true,\n        },\n    ],\n    create(context, [options]) {\n        /**\n         * Check if a scope is a TypeScript module augmenting the global namespace.\n         */\n        function isGlobalAugmentation(scope) {\n            return ((scope.type === scope_manager_1.ScopeType.tsModule && scope.block.kind === 'global') ||\n                (!!scope.upper && isGlobalAugmentation(scope.upper)));\n        }\n        /**\n         * Check if variable is a `this` parameter.\n         */\n        function isThisParam(variable) {\n            return (variable.defs[0].type === scope_manager_1.DefinitionType.Parameter &&\n                variable.name === 'this');\n        }\n        function isTypeValueShadow(variable, shadowed) {\n            if (options.ignoreTypeValueShadow !== true) {\n                return false;\n            }\n            if (!('isValueVariable' in variable)) {\n                // this shouldn't happen...\n                return false;\n            }\n            const firstDefinition = shadowed.defs.at(0);\n            const isShadowedValue = !('isValueVariable' in shadowed) ||\n                !firstDefinition ||\n                (!(0, isTypeImport_1.isTypeImport)(firstDefinition) && shadowed.isValueVariable);\n            return variable.isValueVariable !== isShadowedValue;\n        }\n        function isFunctionTypeParameterNameValueShadow(variable, shadowed) {\n            if (options.ignoreFunctionTypeParameterNameValueShadow !== true) {\n                return false;\n            }\n            if (!('isValueVariable' in variable)) {\n                // this shouldn't happen...\n                return false;\n            }\n            const isShadowedValue = 'isValueVariable' in shadowed ? shadowed.isValueVariable : true;\n            if (!isShadowedValue) {\n                return false;\n            }\n            return variable.defs.every(def => allowedFunctionVariableDefTypes.has(def.node.type));\n        }\n        function isGenericOfStaticMethod(variable) {\n            if (!('isTypeVariable' in variable)) {\n                // this shouldn't happen...\n                return false;\n            }\n            if (!variable.isTypeVariable) {\n                return false;\n            }\n            if (variable.identifiers.length === 0) {\n                return false;\n            }\n            const typeParameter = variable.identifiers[0].parent;\n            if (typeParameter.type !== utils_1.AST_NODE_TYPES.TSTypeParameter) {\n                return false;\n            }\n            const typeParameterDecl = typeParameter.parent;\n            if (typeParameterDecl.type !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {\n                return false;\n            }\n            const functionExpr = typeParameterDecl.parent;\n            if (functionExpr.type !== utils_1.AST_NODE_TYPES.FunctionExpression &&\n                functionExpr.type !== utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n                return false;\n            }\n            const methodDefinition = functionExpr.parent;\n            if (methodDefinition.type !== utils_1.AST_NODE_TYPES.MethodDefinition) {\n                return false;\n            }\n            return methodDefinition.static;\n        }\n        function isGenericOfClass(variable) {\n            if (!('isTypeVariable' in variable)) {\n                // this shouldn't happen...\n                return false;\n            }\n            if (!variable.isTypeVariable) {\n                return false;\n            }\n            if (variable.identifiers.length === 0) {\n                return false;\n            }\n            const typeParameter = variable.identifiers[0].parent;\n            if (typeParameter.type !== utils_1.AST_NODE_TYPES.TSTypeParameter) {\n                return false;\n            }\n            const typeParameterDecl = typeParameter.parent;\n            if (typeParameterDecl.type !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {\n                return false;\n            }\n            const classDecl = typeParameterDecl.parent;\n            return (classDecl.type === utils_1.AST_NODE_TYPES.ClassDeclaration ||\n                classDecl.type === utils_1.AST_NODE_TYPES.ClassExpression);\n        }\n        function isGenericOfAStaticMethodShadow(variable, shadowed) {\n            return isGenericOfStaticMethod(variable) && isGenericOfClass(shadowed);\n        }\n        function isImportDeclaration(definition) {\n            return definition.type === utils_1.AST_NODE_TYPES.ImportDeclaration;\n        }\n        function isExternalModuleDeclarationWithName(scope, name) {\n            return (scope.type === scope_manager_1.ScopeType.tsModule &&\n                scope.block.id.type === utils_1.AST_NODE_TYPES.Literal &&\n                scope.block.id.value === name);\n        }\n        function isExternalDeclarationMerging(scope, variable, shadowed) {\n            const [firstDefinition] = shadowed.defs;\n            const [secondDefinition] = variable.defs;\n            return ((0, isTypeImport_1.isTypeImport)(firstDefinition) &&\n                isImportDeclaration(firstDefinition.parent) &&\n                isExternalModuleDeclarationWithName(scope, firstDefinition.parent.source.value) &&\n                (secondDefinition.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration ||\n                    secondDefinition.node.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration));\n        }\n        /**\n         * Check if variable name is allowed.\n         * @param variable The variable to check.\n         * @returns Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return options.allow.includes(variable.name);\n        }\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         * @param variable The variable to check.\n         * @returns Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n            return (block.type === utils_1.AST_NODE_TYPES.ClassDeclaration &&\n                block.id === variable.identifiers[0]);\n        }\n        /**\n         * Checks if a variable of the class name in the class scope of TSEnumDeclaration.\n         *\n         * TSEnumDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         * @param variable The variable to check.\n         * @returns Whether or not the variable of the class name in the class scope of TSEnumDeclaration.\n         */\n        function isDuplicatedEnumNameVariable(variable) {\n            const block = variable.scope.block;\n            return (block.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration &&\n                block.id === variable.identifiers[0]);\n        }\n        /**\n         * Checks whether or not a given location is inside of the range of a given node.\n         * @param node An node to check.\n         * @param location A location to check.\n         * @returns `true` if the location is inside of the range of the node.\n         */\n        function isInRange(node, location) {\n            return node && node.range[0] <= location && location <= node.range[1];\n        }\n        /**\n         * Searches from the current node through its ancestry to find a matching node.\n         * @param node a node to get.\n         * @param match a callback that checks whether or not the node verifies its condition or not.\n         * @returns the matching node.\n         */\n        function findSelfOrAncestor(node, match) {\n            let currentNode = node;\n            while (currentNode && !match(currentNode)) {\n                currentNode = currentNode.parent;\n            }\n            return currentNode;\n        }\n        /**\n         * Finds function's outer scope.\n         * @param scope Function's own scope.\n         * @returns Function's outer scope.\n         */\n        function getOuterScope(scope) {\n            const upper = scope.upper;\n            if (upper?.type === scope_manager_1.ScopeType.functionExpressionName) {\n                return upper.upper;\n            }\n            return upper;\n        }\n        /**\n         * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\n         * @param variable a variable to check.\n         * @param shadowedVariable a shadowedVariable to check.\n         * @returns Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\n         */\n        function isInitPatternNode(variable, shadowedVariable) {\n            const outerDef = shadowedVariable.defs.at(0);\n            if (!outerDef) {\n                return false;\n            }\n            const { variableScope } = variable.scope;\n            if (!((variableScope.block.type ===\n                utils_1.AST_NODE_TYPES.ArrowFunctionExpression ||\n                variableScope.block.type === utils_1.AST_NODE_TYPES.FunctionExpression) &&\n                getOuterScope(variableScope) === shadowedVariable.scope)) {\n                return false;\n            }\n            const fun = variableScope.block;\n            const { parent } = fun;\n            const callExpression = findSelfOrAncestor(parent, node => node.type === utils_1.AST_NODE_TYPES.CallExpression);\n            if (!callExpression) {\n                return false;\n            }\n            let node = outerDef.name;\n            const location = callExpression.range[1];\n            while (node) {\n                if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n                    if (isInRange(node.init, location)) {\n                        return true;\n                    }\n                    if ((node.parent.parent.type === utils_1.AST_NODE_TYPES.ForInStatement ||\n                        node.parent.parent.type === utils_1.AST_NODE_TYPES.ForOfStatement) &&\n                        isInRange(node.parent.parent.right, location)) {\n                        return true;\n                    }\n                    break;\n                }\n                else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n                    if (isInRange(node.right, location)) {\n                        return true;\n                    }\n                }\n                else if ([\n                    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,\n                    utils_1.AST_NODE_TYPES.CatchClause,\n                    utils_1.AST_NODE_TYPES.ClassDeclaration,\n                    utils_1.AST_NODE_TYPES.ClassExpression,\n                    utils_1.AST_NODE_TYPES.ExportNamedDeclaration,\n                    utils_1.AST_NODE_TYPES.FunctionDeclaration,\n                    utils_1.AST_NODE_TYPES.FunctionExpression,\n                    utils_1.AST_NODE_TYPES.ImportDeclaration,\n                ].includes(node.type)) {\n                    break;\n                }\n                node = node.parent;\n            }\n            return false;\n        }\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         * @param variable The variable to check.\n         * @param scopeVar The scope variable to look for.\n         * @returns Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs.at(0);\n            const outer = outerDef?.parent?.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs.at(0);\n            const inner = innerDef?.name.range;\n            return !!(outer &&\n                inner &&\n                outer[0] < inner[0] &&\n                inner[1] < outer[1] &&\n                ((innerDef.type === scope_manager_1.DefinitionType.FunctionName &&\n                    innerDef.node.type === utils_1.AST_NODE_TYPES.FunctionExpression) ||\n                    innerDef.node.type === utils_1.AST_NODE_TYPES.ClassExpression) &&\n                outerScope === innerScope.upper);\n        }\n        /**\n         * Get a range of a variable's identifier node.\n         * @param variable The variable to get.\n         * @returns The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs.at(0);\n            return def?.name.range;\n        }\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param variable The variable to check.\n         * @param scopeVar The variable of TDZ.\n         * @returns Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs.at(0);\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n            if (!inner || !outer || inner[1] >= outer[0]) {\n                return false;\n            }\n            if (!outerDef) {\n                return true;\n            }\n            if (options.hoist === 'functions') {\n                return !functionsHoistedNodes.has(outerDef.node.type);\n            }\n            if (options.hoist === 'types') {\n                return !typesHoistedNodes.has(outerDef.node.type);\n            }\n            if (options.hoist === 'functions-and-types') {\n                return (!functionsHoistedNodes.has(outerDef.node.type) &&\n                    !typesHoistedNodes.has(outerDef.node.type));\n            }\n            return true;\n        }\n        /**\n         * Get declared line and column of a variable.\n         * @param  variable The variable to get.\n         * @returns The declared line and column of the variable.\n         */\n        function getDeclaredLocation(variable) {\n            const identifier = variable.identifiers.at(0);\n            if (identifier) {\n                return {\n                    column: identifier.loc.start.column + 1,\n                    global: false,\n                    line: identifier.loc.start.line,\n                };\n            }\n            return {\n                global: true,\n            };\n        }\n        /**\n         * Checks if the initialization of a variable has the declare modifier in a\n         * definition file.\n         */\n        function isDeclareInDTSFile(variable) {\n            const fileName = context.filename;\n            if (!(0, util_1.isDefinitionFile)(fileName)) {\n                return false;\n            }\n            return variable.defs.some(def => {\n                return ((def.type === scope_manager_1.DefinitionType.Variable && def.parent.declare) ||\n                    (def.type === scope_manager_1.DefinitionType.ClassName && def.node.declare) ||\n                    (def.type === scope_manager_1.DefinitionType.TSEnumName && def.node.declare) ||\n                    (def.type === scope_manager_1.DefinitionType.TSModuleName && def.node.declare));\n            });\n        }\n        /**\n         * Checks the current context for shadowed variables.\n         * @param scope Fixme\n         */\n        function checkForShadows(scope) {\n            // ignore global augmentation\n            if (isGlobalAugmentation(scope)) {\n                return;\n            }\n            const variables = scope.variables;\n            for (const variable of variables) {\n                // ignore \"arguments\"\n                if (variable.identifiers.length === 0) {\n                    continue;\n                }\n                // this params are pseudo-params that cannot be shadowed\n                if (isThisParam(variable)) {\n                    continue;\n                }\n                // ignore variables of a class name in the class scope of ClassDeclaration\n                if (isDuplicatedClassNameVariable(variable)) {\n                    continue;\n                }\n                // ignore variables of a class name in the class scope of ClassDeclaration\n                if (isDuplicatedEnumNameVariable(variable)) {\n                    continue;\n                }\n                // ignore configured allowed names\n                if (isAllowed(variable)) {\n                    continue;\n                }\n                // ignore variables with the declare keyword in .d.ts files\n                if (isDeclareInDTSFile(variable)) {\n                    continue;\n                }\n                // Gets shadowed variable.\n                const shadowed = scope.upper\n                    ? utils_1.ASTUtils.findVariable(scope.upper, variable.name)\n                    : null;\n                if (!shadowed) {\n                    continue;\n                }\n                // ignore type value variable shadowing if configured\n                if (isTypeValueShadow(variable, shadowed)) {\n                    continue;\n                }\n                // ignore function type parameter name shadowing if configured\n                if (isFunctionTypeParameterNameValueShadow(variable, shadowed)) {\n                    continue;\n                }\n                // ignore static class method generic shadowing class generic\n                // this is impossible for the scope analyser to understand\n                // so we have to handle this manually in this rule\n                if (isGenericOfAStaticMethodShadow(variable, shadowed)) {\n                    continue;\n                }\n                if (isExternalDeclarationMerging(scope, variable, shadowed)) {\n                    continue;\n                }\n                const isESLintGlobal = 'writeable' in shadowed;\n                if ((shadowed.identifiers.length > 0 ||\n                    (options.builtinGlobals && isESLintGlobal)) &&\n                    !isOnInitializer(variable, shadowed) &&\n                    !(options.ignoreOnInitialization &&\n                        isInitPatternNode(variable, shadowed)) &&\n                    !(options.hoist !== 'all' && isInTdz(variable, shadowed))) {\n                    const location = getDeclaredLocation(shadowed);\n                    context.report({\n                        node: variable.identifiers[0],\n                        ...(location.global\n                            ? {\n                                messageId: 'noShadowGlobal',\n                                data: {\n                                    name: variable.name,\n                                },\n                            }\n                            : {\n                                messageId: 'noShadow',\n                                data: {\n                                    name: variable.name,\n                                    shadowedColumn: location.column,\n                                    shadowedLine: location.line,\n                                },\n                            }),\n                    });\n                }\n            }\n        }\n        return {\n            'Program:exit'(node) {\n                const globalScope = context.sourceCode.getScope(node);\n                const stack = [...globalScope.childScopes];\n                while (stack.length) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const scope = stack.pop();\n                    stack.push(...scope.childScopes);\n                    checkForShadows(scope);\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}