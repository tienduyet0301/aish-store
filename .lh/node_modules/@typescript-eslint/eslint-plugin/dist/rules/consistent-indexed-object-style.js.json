{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/consistent-indexed-object-style.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891960163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'consistent-indexed-object-style',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require or disallow the `Record` type',\n            recommended: 'stylistic',\n        },\n        fixable: 'code',\n        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- suggestions are exposed through a helper.\n        hasSuggestions: true,\n        messages: {\n            preferIndexSignature: 'An index signature is preferred over a record.',\n            preferIndexSignatureSuggestion: 'Change into an index signature instead of a record.',\n            preferRecord: 'A record is preferred over an index signature.',\n        },\n        schema: [\n            {\n                type: 'string',\n                description: 'Which indexed object syntax to prefer.',\n                enum: ['record', 'index-signature'],\n            },\n        ],\n    },\n    defaultOptions: ['record'],\n    create(context, [mode]) {\n        function checkMembers(members, node, parentId, prefix, postfix, safeFix = true) {\n            if (members.length !== 1) {\n                return;\n            }\n            const [member] = members;\n            if (member.type !== utils_1.AST_NODE_TYPES.TSIndexSignature) {\n                return;\n            }\n            const parameter = member.parameters.at(0);\n            if (parameter?.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                return;\n            }\n            const keyType = parameter.typeAnnotation;\n            if (!keyType) {\n                return;\n            }\n            const valueType = member.typeAnnotation;\n            if (!valueType) {\n                return;\n            }\n            if (parentId) {\n                const scope = context.sourceCode.getScope(parentId);\n                const superVar = utils_1.ASTUtils.findVariable(scope, parentId.name);\n                if (superVar &&\n                    isDeeplyReferencingType(node, superVar, new Set([parentId]))) {\n                    return;\n                }\n            }\n            context.report({\n                node,\n                messageId: 'preferRecord',\n                fix: safeFix\n                    ? (fixer) => {\n                        const key = context.sourceCode.getText(keyType.typeAnnotation);\n                        const value = context.sourceCode.getText(valueType.typeAnnotation);\n                        const record = member.readonly\n                            ? `Readonly<Record<${key}, ${value}>>`\n                            : `Record<${key}, ${value}>`;\n                        return fixer.replaceText(node, `${prefix}${record}${postfix}`);\n                    }\n                    : null,\n            });\n        }\n        return {\n            ...(mode === 'index-signature' && {\n                TSTypeReference(node) {\n                    const typeName = node.typeName;\n                    if (typeName.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                        return;\n                    }\n                    if (typeName.name !== 'Record') {\n                        return;\n                    }\n                    const params = node.typeArguments?.params;\n                    if (params?.length !== 2) {\n                        return;\n                    }\n                    const indexParam = params[0];\n                    const shouldFix = indexParam.type === utils_1.AST_NODE_TYPES.TSStringKeyword ||\n                        indexParam.type === utils_1.AST_NODE_TYPES.TSNumberKeyword ||\n                        indexParam.type === utils_1.AST_NODE_TYPES.TSSymbolKeyword;\n                    context.report({\n                        node,\n                        messageId: 'preferIndexSignature',\n                        ...(0, util_1.getFixOrSuggest)({\n                            fixOrSuggest: shouldFix ? 'fix' : 'suggest',\n                            suggestion: {\n                                messageId: 'preferIndexSignatureSuggestion',\n                                fix: fixer => {\n                                    const key = context.sourceCode.getText(params[0]);\n                                    const type = context.sourceCode.getText(params[1]);\n                                    return fixer.replaceText(node, `{ [key: ${key}]: ${type} }`);\n                                },\n                            },\n                        }),\n                    });\n                },\n            }),\n            ...(mode === 'record' && {\n                TSInterfaceDeclaration(node) {\n                    let genericTypes = '';\n                    if (node.typeParameters?.params.length) {\n                        genericTypes = `<${node.typeParameters.params\n                            .map(p => context.sourceCode.getText(p))\n                            .join(', ')}>`;\n                    }\n                    checkMembers(node.body.body, node, node.id, `type ${node.id.name}${genericTypes} = `, ';', !node.extends.length);\n                },\n                TSMappedType(node) {\n                    const key = node.key;\n                    const scope = context.sourceCode.getScope(key);\n                    const scopeManagerKey = (0, util_1.nullThrows)(scope.variables.find(value => value.name === key.name && value.isTypeVariable), 'key type parameter must be a defined type variable in its scope');\n                    // If the key is used to compute the value, we can't convert to a Record.\n                    if (scopeManagerKey.references.some(reference => reference.isTypeReference)) {\n                        return;\n                    }\n                    const constraint = node.constraint;\n                    if (constraint.type === utils_1.AST_NODE_TYPES.TSTypeOperator &&\n                        constraint.operator === 'keyof' &&\n                        !(0, util_1.isParenthesized)(constraint, context.sourceCode)) {\n                        // This is a weird special case, since modifiers are preserved by\n                        // the mapped type, but not by the Record type. So this type is not,\n                        // in general, equivalent to a Record type.\n                        return;\n                    }\n                    // If the mapped type is circular, we can't convert it to a Record.\n                    const parentId = findParentDeclaration(node)?.id;\n                    if (parentId) {\n                        const scope = context.sourceCode.getScope(key);\n                        const superVar = utils_1.ASTUtils.findVariable(scope, parentId.name);\n                        if (superVar) {\n                            const isCircular = superVar.references.some(item => item.isTypeReference &&\n                                node.range[0] <= item.identifier.range[0] &&\n                                node.range[1] >= item.identifier.range[1]);\n                            if (isCircular) {\n                                return;\n                            }\n                        }\n                    }\n                    // There's no builtin Mutable<T> type, so we can't autofix it really.\n                    const canFix = node.readonly !== '-';\n                    context.report({\n                        node,\n                        messageId: 'preferRecord',\n                        ...(canFix && {\n                            fix: (fixer) => {\n                                const keyType = context.sourceCode.getText(constraint);\n                                const valueType = context.sourceCode.getText(node.typeAnnotation);\n                                let recordText = `Record<${keyType}, ${valueType}>`;\n                                if (node.optional === '+' || node.optional === true) {\n                                    recordText = `Partial<${recordText}>`;\n                                }\n                                else if (node.optional === '-') {\n                                    recordText = `Required<${recordText}>`;\n                                }\n                                if (node.readonly === '+' || node.readonly === true) {\n                                    recordText = `Readonly<${recordText}>`;\n                                }\n                                return fixer.replaceText(node, recordText);\n                            },\n                        }),\n                    });\n                },\n                TSTypeLiteral(node) {\n                    const parent = findParentDeclaration(node);\n                    checkMembers(node.members, node, parent?.id, '', '');\n                },\n            }),\n        };\n    },\n});\nfunction findParentDeclaration(node) {\n    if (node.parent && node.parent.type !== utils_1.AST_NODE_TYPES.TSTypeAnnotation) {\n        if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {\n            return node.parent;\n        }\n        return findParentDeclaration(node.parent);\n    }\n    return undefined;\n}\nfunction isDeeplyReferencingType(node, superVar, visited) {\n    if (visited.has(node)) {\n        // something on the chain is circular but it's not the reference being checked\n        return false;\n    }\n    visited.add(node);\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSTypeLiteral:\n            return node.members.some(member => isDeeplyReferencingType(member, superVar, visited));\n        case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:\n            return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);\n        case utils_1.AST_NODE_TYPES.TSIndexedAccessType:\n            return [node.indexType, node.objectType].some(type => isDeeplyReferencingType(type, superVar, visited));\n        case utils_1.AST_NODE_TYPES.TSConditionalType:\n            return [\n                node.checkType,\n                node.extendsType,\n                node.falseType,\n                node.trueType,\n            ].some(type => isDeeplyReferencingType(type, superVar, visited));\n        case utils_1.AST_NODE_TYPES.TSUnionType:\n        case utils_1.AST_NODE_TYPES.TSIntersectionType:\n            return node.types.some(type => isDeeplyReferencingType(type, superVar, visited));\n        case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:\n            return node.body.body.some(type => isDeeplyReferencingType(type, superVar, visited));\n        case utils_1.AST_NODE_TYPES.TSTypeAnnotation:\n            return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);\n        case utils_1.AST_NODE_TYPES.TSIndexSignature: {\n            if (node.typeAnnotation) {\n                return isDeeplyReferencingType(node.typeAnnotation, superVar, visited);\n            }\n            break;\n        }\n        case utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation: {\n            return node.params.some(param => isDeeplyReferencingType(param, superVar, visited));\n        }\n        case utils_1.AST_NODE_TYPES.TSTypeReference: {\n            if (isDeeplyReferencingType(node.typeName, superVar, visited)) {\n                return true;\n            }\n            if (node.typeArguments &&\n                isDeeplyReferencingType(node.typeArguments, superVar, visited)) {\n                return true;\n            }\n            break;\n        }\n        case utils_1.AST_NODE_TYPES.Identifier: {\n            // check if the identifier is a reference of the type being checked\n            if (superVar.references.some(ref => (0, util_1.isNodeEqual)(ref.identifier, node))) {\n                return true;\n            }\n            // otherwise, follow its definition(s)\n            const refVar = utils_1.ASTUtils.findVariable(superVar.scope, node.name);\n            if (refVar) {\n                return refVar.defs.some(def => isDeeplyReferencingType(def.node, superVar, visited));\n            }\n        }\n    }\n    return false;\n}\n"
        }
    ]
}