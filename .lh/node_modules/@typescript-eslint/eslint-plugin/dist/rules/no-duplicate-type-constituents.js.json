{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-duplicate-type-constituents.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891963976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst astIgnoreKeys = new Set(['loc', 'parent', 'range']);\nconst isSameAstNode = (actualNode, expectedNode) => {\n    if (actualNode === expectedNode) {\n        return true;\n    }\n    if (actualNode &&\n        expectedNode &&\n        typeof actualNode === 'object' &&\n        typeof expectedNode === 'object') {\n        if (Array.isArray(actualNode) && Array.isArray(expectedNode)) {\n            if (actualNode.length !== expectedNode.length) {\n                return false;\n            }\n            return !actualNode.some((nodeEle, index) => !isSameAstNode(nodeEle, expectedNode[index]));\n        }\n        const actualNodeKeys = Object.keys(actualNode).filter(key => !astIgnoreKeys.has(key));\n        const expectedNodeKeys = Object.keys(expectedNode).filter(key => !astIgnoreKeys.has(key));\n        if (actualNodeKeys.length !== expectedNodeKeys.length) {\n            return false;\n        }\n        if (actualNodeKeys.some(actualNodeKey => !Object.hasOwn(expectedNode, actualNodeKey))) {\n            return false;\n        }\n        if (actualNodeKeys.some(actualNodeKey => !isSameAstNode(actualNode[actualNodeKey], expectedNode[actualNodeKey]))) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n};\nexports.default = (0, util_1.createRule)({\n    name: 'no-duplicate-type-constituents',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow duplicate constituents of union or intersection types',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            duplicate: '{{type}} type constituent is duplicated with {{previous}}.',\n            unnecessary: 'Explicit undefined is unnecessary on an optional parameter.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ignoreIntersections: {\n                        type: 'boolean',\n                        description: 'Whether to ignore `&` intersections.',\n                    },\n                    ignoreUnions: {\n                        type: 'boolean',\n                        description: 'Whether to ignore `|` unions.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            ignoreIntersections: false,\n            ignoreUnions: false,\n        },\n    ],\n    create(context, [{ ignoreIntersections, ignoreUnions }]) {\n        const parserServices = (0, util_1.getParserServices)(context);\n        const { sourceCode } = context;\n        function report(messageId, constituentNode, data) {\n            const getUnionOrIntersectionToken = (where, at) => sourceCode[`getTokens${where}`](constituentNode, {\n                filter: token => ['&', '|'].includes(token.value) &&\n                    constituentNode.parent.range[0] <= token.range[0] &&\n                    token.range[1] <= constituentNode.parent.range[1],\n            }).at(at);\n            const beforeUnionOrIntersectionToken = getUnionOrIntersectionToken('Before', -1);\n            let afterUnionOrIntersectionToken;\n            let bracketBeforeTokens;\n            let bracketAfterTokens;\n            if (beforeUnionOrIntersectionToken) {\n                bracketBeforeTokens = sourceCode.getTokensBetween(beforeUnionOrIntersectionToken, constituentNode);\n                bracketAfterTokens = sourceCode.getTokensAfter(constituentNode, {\n                    count: bracketBeforeTokens.length,\n                });\n            }\n            else {\n                afterUnionOrIntersectionToken = (0, util_1.nullThrows)(getUnionOrIntersectionToken('After', 0), util_1.NullThrowsReasons.MissingToken('union or intersection token', 'duplicate type constituent'));\n                bracketAfterTokens = sourceCode.getTokensBetween(constituentNode, afterUnionOrIntersectionToken);\n                bracketBeforeTokens = sourceCode.getTokensBefore(constituentNode, {\n                    count: bracketAfterTokens.length,\n                });\n            }\n            context.report({\n                loc: {\n                    start: constituentNode.loc.start,\n                    end: (bracketAfterTokens.at(-1) ?? constituentNode).loc.end,\n                },\n                node: constituentNode,\n                messageId,\n                data,\n                fix: fixer => [\n                    beforeUnionOrIntersectionToken,\n                    ...bracketBeforeTokens,\n                    constituentNode,\n                    ...bracketAfterTokens,\n                    afterUnionOrIntersectionToken,\n                ].flatMap(token => (token ? fixer.remove(token) : [])),\n            });\n        }\n        function checkDuplicateRecursively(unionOrIntersection, constituentNode, uniqueConstituents, cachedTypeMap, forEachNodeType) {\n            const type = parserServices.getTypeAtLocation(constituentNode);\n            if (tsutils.isIntrinsicErrorType(type)) {\n                return;\n            }\n            const duplicatedPrevious = uniqueConstituents.find(ele => isSameAstNode(ele, constituentNode)) ??\n                cachedTypeMap.get(type);\n            if (duplicatedPrevious) {\n                report('duplicate', constituentNode, {\n                    type: unionOrIntersection,\n                    previous: sourceCode.getText(duplicatedPrevious),\n                });\n                return;\n            }\n            forEachNodeType?.(type, constituentNode);\n            cachedTypeMap.set(type, constituentNode);\n            uniqueConstituents.push(constituentNode);\n            if ((unionOrIntersection === 'Union' &&\n                constituentNode.type === utils_1.AST_NODE_TYPES.TSUnionType) ||\n                (unionOrIntersection === 'Intersection' &&\n                    constituentNode.type === utils_1.AST_NODE_TYPES.TSIntersectionType)) {\n                for (const constituent of constituentNode.types) {\n                    checkDuplicateRecursively(unionOrIntersection, constituent, uniqueConstituents, cachedTypeMap, forEachNodeType);\n                }\n            }\n        }\n        function checkDuplicate(node, forEachNodeType) {\n            const cachedTypeMap = new Map();\n            const uniqueConstituents = [];\n            const unionOrIntersection = node.type === utils_1.AST_NODE_TYPES.TSIntersectionType\n                ? 'Intersection'\n                : 'Union';\n            for (const type of node.types) {\n                checkDuplicateRecursively(unionOrIntersection, type, uniqueConstituents, cachedTypeMap, forEachNodeType);\n            }\n        }\n        return {\n            ...(!ignoreIntersections && {\n                TSIntersectionType(node) {\n                    if (node.parent.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n                        return;\n                    }\n                    checkDuplicate(node);\n                },\n            }),\n            ...(!ignoreUnions && {\n                TSUnionType: (node) => {\n                    if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n                        return;\n                    }\n                    checkDuplicate(node, (constituentNodeType, constituentNode) => {\n                        const maybeTypeAnnotation = node.parent;\n                        if (maybeTypeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation) {\n                            const maybeIdentifier = maybeTypeAnnotation.parent;\n                            if (maybeIdentifier.type === utils_1.AST_NODE_TYPES.Identifier &&\n                                maybeIdentifier.optional) {\n                                const maybeFunction = maybeIdentifier.parent;\n                                if ((0, util_1.isFunctionOrFunctionType)(maybeFunction) &&\n                                    maybeFunction.params.includes(maybeIdentifier) &&\n                                    tsutils.isTypeFlagSet(constituentNodeType, ts.TypeFlags.Undefined)) {\n                                    report('unnecessary', constituentNode);\n                                }\n                            }\n                        }\n                    });\n                },\n            }),\n        };\n    },\n});\n"
        }
    ]
}