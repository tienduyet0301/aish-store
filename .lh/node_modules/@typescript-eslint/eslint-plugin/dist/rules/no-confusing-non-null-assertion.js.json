{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-confusing-non-null-assertion.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891963229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst confusingOperators = new Set([\n    '=',\n    '==',\n    '===',\n    'in',\n    'instanceof',\n]);\nfunction isConfusingOperator(operator) {\n    return confusingOperators.has(operator);\n}\nexports.default = (0, util_1.createRule)({\n    name: 'no-confusing-non-null-assertion',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow non-null assertion in locations that may be confusing',\n            recommended: 'stylistic',\n        },\n        hasSuggestions: true,\n        messages: {\n            confusingAssign: 'Confusing combination of non-null assertion and assignment like `a! = b`, which looks very similar to `a != b`.',\n            confusingEqual: 'Confusing combination of non-null assertion and equality test like `a! == b`, which looks very similar to `a !== b`.',\n            confusingOperator: 'Confusing combination of non-null assertion and `{{operator}}` operator like `a! {{operator}} b`, which might be misinterpreted as `!(a {{operator}} b)`.',\n            notNeedInAssign: 'Remove unnecessary non-null assertion (!) in assignment left-hand side.',\n            notNeedInEqualTest: 'Remove unnecessary non-null assertion (!) in equality test.',\n            notNeedInOperator: 'Remove possibly unnecessary non-null assertion (!) in the left operand of the `{{operator}}` operator.',\n            wrapUpLeft: 'Wrap the left-hand side in parentheses to avoid confusion with \"{{operator}}\" operator.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        function confusingOperatorToMessageData(operator) {\n            switch (operator) {\n                case '=':\n                    return {\n                        messageId: 'confusingAssign',\n                    };\n                case '==':\n                case '===':\n                    return {\n                        messageId: 'confusingEqual',\n                    };\n                case 'in':\n                case 'instanceof':\n                    return {\n                        messageId: 'confusingOperator',\n                        data: { operator },\n                    };\n                // istanbul ignore next\n                default:\n                    operator;\n                    throw new Error(`Unexpected operator ${operator}`);\n            }\n        }\n        return {\n            'BinaryExpression, AssignmentExpression'(node) {\n                const operator = node.operator;\n                if (isConfusingOperator(operator)) {\n                    // Look for a non-null assertion as the last token on the left hand side.\n                    // That way, we catch things like `1 + two! === 3`, even though the left\n                    // hand side isn't a non-null assertion AST node.\n                    const leftHandFinalToken = context.sourceCode.getLastToken(node.left);\n                    const tokenAfterLeft = context.sourceCode.getTokenAfter(node.left);\n                    if (leftHandFinalToken?.type === utils_1.AST_TOKEN_TYPES.Punctuator &&\n                        leftHandFinalToken.value === '!' &&\n                        tokenAfterLeft?.value !== ')') {\n                        if (node.left.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {\n                            let suggestions;\n                            switch (operator) {\n                                case '=':\n                                    suggestions = [\n                                        {\n                                            messageId: 'notNeedInAssign',\n                                            fix: (fixer) => fixer.remove(leftHandFinalToken),\n                                        },\n                                    ];\n                                    break;\n                                case '==':\n                                case '===':\n                                    suggestions = [\n                                        {\n                                            messageId: 'notNeedInEqualTest',\n                                            fix: (fixer) => fixer.remove(leftHandFinalToken),\n                                        },\n                                    ];\n                                    break;\n                                case 'in':\n                                case 'instanceof':\n                                    suggestions = [\n                                        {\n                                            messageId: 'notNeedInOperator',\n                                            data: { operator },\n                                            fix: (fixer) => fixer.remove(leftHandFinalToken),\n                                        },\n                                        {\n                                            messageId: 'wrapUpLeft',\n                                            data: { operator },\n                                            fix: wrapUpLeftFixer(node),\n                                        },\n                                    ];\n                                    break;\n                                // istanbul ignore next\n                                default:\n                                    operator;\n                                    return;\n                            }\n                            context.report({\n                                node,\n                                ...confusingOperatorToMessageData(operator),\n                                suggest: suggestions,\n                            });\n                        }\n                        else {\n                            context.report({\n                                node,\n                                ...confusingOperatorToMessageData(operator),\n                                suggest: [\n                                    {\n                                        messageId: 'wrapUpLeft',\n                                        data: { operator },\n                                        fix: wrapUpLeftFixer(node),\n                                    },\n                                ],\n                            });\n                        }\n                    }\n                }\n            },\n        };\n    },\n});\nfunction wrapUpLeftFixer(node) {\n    return (fixer) => [\n        fixer.insertTextBefore(node.left, '('),\n        fixer.insertTextAfter(node.left, ')'),\n    ];\n}\n"
        }
    ]
}