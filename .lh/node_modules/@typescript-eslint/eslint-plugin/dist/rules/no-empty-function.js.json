{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-empty-function.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891964175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-empty-function');\nconst defaultOptions = [\n    {\n        allow: [],\n    },\n];\nconst schema = (0, util_1.deepMerge)(\n// eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- https://github.com/microsoft/TypeScript/issues/17002\nArray.isArray(baseRule.meta.schema)\n    ? baseRule.meta.schema[0]\n    : baseRule.meta.schema, {\n    properties: {\n        allow: {\n            description: 'Locations and kinds of functions that are allowed to be empty.',\n            items: {\n                type: 'string',\n                enum: [\n                    'functions',\n                    'arrowFunctions',\n                    'generatorFunctions',\n                    'methods',\n                    'generatorMethods',\n                    'getters',\n                    'setters',\n                    'constructors',\n                    'private-constructors',\n                    'protected-constructors',\n                    'asyncFunctions',\n                    'asyncMethods',\n                    'decoratedFunctions',\n                    'overrideMethods',\n                ],\n            },\n        },\n    },\n});\nexports.default = (0, util_1.createRule)({\n    name: 'no-empty-function',\n    meta: {\n        type: 'suggestion',\n        defaultOptions,\n        docs: {\n            description: 'Disallow empty functions',\n            extendsBaseRule: true,\n            recommended: 'stylistic',\n        },\n        hasSuggestions: baseRule.meta.hasSuggestions,\n        messages: baseRule.meta.messages,\n        schema: [schema],\n    },\n    defaultOptions,\n    create(context, [{ allow = [] }]) {\n        const rules = baseRule.create(context);\n        const isAllowedProtectedConstructors = allow.includes('protected-constructors');\n        const isAllowedPrivateConstructors = allow.includes('private-constructors');\n        const isAllowedDecoratedFunctions = allow.includes('decoratedFunctions');\n        const isAllowedOverrideMethods = allow.includes('overrideMethods');\n        /**\n         * Check if the method body is empty\n         * @param node the node to be validated\n         * @returns true if the body is empty\n         * @private\n         */\n        function isBodyEmpty(node) {\n            return node.body.body.length === 0;\n        }\n        /**\n         * Check if method has parameter properties\n         * @param node the node to be validated\n         * @returns true if the body has parameter properties\n         * @private\n         */\n        function hasParameterProperties(node) {\n            return node.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSParameterProperty);\n        }\n        /**\n         * @param node the node to be validated\n         * @returns true if the constructor is allowed to be empty\n         * @private\n         */\n        function isAllowedEmptyConstructor(node) {\n            const parent = node.parent;\n            if (isBodyEmpty(node) &&\n                parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n                parent.kind === 'constructor') {\n                const { accessibility } = parent;\n                return (\n                // allow protected constructors\n                (accessibility === 'protected' && isAllowedProtectedConstructors) ||\n                    // allow private constructors\n                    (accessibility === 'private' && isAllowedPrivateConstructors) ||\n                    // allow constructors which have parameter properties\n                    hasParameterProperties(node));\n            }\n            return false;\n        }\n        /**\n         * @param node the node to be validated\n         * @returns true if a function has decorators\n         * @private\n         */\n        function isAllowedEmptyDecoratedFunctions(node) {\n            if (isAllowedDecoratedFunctions && isBodyEmpty(node)) {\n                const decorators = node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition\n                    ? node.parent.decorators\n                    : undefined;\n                return !!decorators && !!decorators.length;\n            }\n            return false;\n        }\n        function isAllowedEmptyOverrideMethod(node) {\n            return (isAllowedOverrideMethods &&\n                isBodyEmpty(node) &&\n                node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n                node.parent.override);\n        }\n        return {\n            ...rules,\n            FunctionExpression(node) {\n                if (isAllowedEmptyConstructor(node) ||\n                    isAllowedEmptyDecoratedFunctions(node) ||\n                    isAllowedEmptyOverrideMethod(node)) {\n                    return;\n                }\n                rules.FunctionExpression(node);\n            },\n        };\n    },\n});\n"
        }
    ]
}