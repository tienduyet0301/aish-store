{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-deprecated.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891963575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-deprecated',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow using code marked as `@deprecated`',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            deprecated: `\\`{{name}}\\` is deprecated.`,\n            deprecatedWithReason: `\\`{{name}}\\` is deprecated. {{reason}}`,\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allow: {\n                        ...util_1.typeOrValueSpecifiersSchema,\n                        description: 'Type specifiers that can be allowed.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allow: [],\n        },\n    ],\n    create(context, [options]) {\n        const { jsDocParsingMode } = context.parserOptions;\n        const allow = options.allow;\n        if (jsDocParsingMode === 'none' || jsDocParsingMode === 'type-info') {\n            throw new Error(`Cannot be used with jsDocParsingMode: '${jsDocParsingMode}'.`);\n        }\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        // Deprecated jsdoc tags can be added on some symbol alias, e.g.\n        //\n        // export { /** @deprecated */ foo }\n        //\n        // When we import foo, its symbol is an alias of the exported foo (the one\n        // with the deprecated tag), which is itself an alias of the original foo.\n        // Therefore, we carefully go through the chain of aliases and check each\n        // immediate alias for deprecated tags\n        function searchForDeprecationInAliasesChain(symbol, checkDeprecationsOfAliasedSymbol) {\n            if (!symbol || !tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {\n                return checkDeprecationsOfAliasedSymbol\n                    ? getJsDocDeprecation(symbol)\n                    : undefined;\n            }\n            const targetSymbol = checker.getAliasedSymbol(symbol);\n            while (tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {\n                const reason = getJsDocDeprecation(symbol);\n                if (reason != null) {\n                    return reason;\n                }\n                const immediateAliasedSymbol = symbol.getDeclarations() && checker.getImmediateAliasedSymbol(symbol);\n                if (!immediateAliasedSymbol) {\n                    break;\n                }\n                symbol = immediateAliasedSymbol;\n                if (checkDeprecationsOfAliasedSymbol && symbol === targetSymbol) {\n                    return getJsDocDeprecation(symbol);\n                }\n            }\n            return undefined;\n        }\n        function isDeclaration(node) {\n            const { parent } = node;\n            switch (parent.type) {\n                case utils_1.AST_NODE_TYPES.ArrayPattern:\n                    return parent.elements.includes(node);\n                case utils_1.AST_NODE_TYPES.ClassExpression:\n                case utils_1.AST_NODE_TYPES.ClassDeclaration:\n                case utils_1.AST_NODE_TYPES.VariableDeclarator:\n                case utils_1.AST_NODE_TYPES.TSEnumMember:\n                    return parent.id === node;\n                case utils_1.AST_NODE_TYPES.MethodDefinition:\n                case utils_1.AST_NODE_TYPES.PropertyDefinition:\n                case utils_1.AST_NODE_TYPES.AccessorProperty:\n                    return parent.key === node;\n                case utils_1.AST_NODE_TYPES.Property:\n                    // foo in \"const { foo } = bar\" will be processed twice, as parent.key\n                    // and parent.value. The second is treated as a declaration.\n                    if (parent.shorthand && parent.value === node) {\n                        return parent.parent.type === utils_1.AST_NODE_TYPES.ObjectPattern;\n                    }\n                    if (parent.value === node) {\n                        return false;\n                    }\n                    return parent.parent.type === utils_1.AST_NODE_TYPES.ObjectExpression;\n                case utils_1.AST_NODE_TYPES.AssignmentPattern:\n                    // foo in \"const { foo = \"\" } = bar\" will be processed twice, as parent.parent.key\n                    // and parent.left. The second is treated as a declaration.\n                    return parent.left === node;\n                case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n                case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n                case utils_1.AST_NODE_TYPES.FunctionExpression:\n                case utils_1.AST_NODE_TYPES.TSDeclareFunction:\n                case utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression:\n                case utils_1.AST_NODE_TYPES.TSEnumDeclaration:\n                case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:\n                case utils_1.AST_NODE_TYPES.TSMethodSignature:\n                case utils_1.AST_NODE_TYPES.TSModuleDeclaration:\n                case utils_1.AST_NODE_TYPES.TSParameterProperty:\n                case utils_1.AST_NODE_TYPES.TSPropertySignature:\n                case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:\n                case utils_1.AST_NODE_TYPES.TSTypeParameter:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        function isInsideExportOrImport(node) {\n            let current = node;\n            while (true) {\n                switch (current.type) {\n                    case utils_1.AST_NODE_TYPES.ExportAllDeclaration:\n                    case utils_1.AST_NODE_TYPES.ExportNamedDeclaration:\n                    case utils_1.AST_NODE_TYPES.ImportDeclaration:\n                        return true;\n                    case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n                    case utils_1.AST_NODE_TYPES.BlockStatement:\n                    case utils_1.AST_NODE_TYPES.ClassDeclaration:\n                    case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:\n                    case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n                    case utils_1.AST_NODE_TYPES.FunctionExpression:\n                    case utils_1.AST_NODE_TYPES.Program:\n                    case utils_1.AST_NODE_TYPES.TSUnionType:\n                    case utils_1.AST_NODE_TYPES.VariableDeclarator:\n                        return false;\n                    default:\n                        current = current.parent;\n                }\n            }\n        }\n        function getJsDocDeprecation(symbol) {\n            let jsDocTags;\n            try {\n                jsDocTags = symbol?.getJsDocTags(checker);\n            }\n            catch {\n                // workaround for https://github.com/microsoft/TypeScript/issues/60024\n                return;\n            }\n            const tag = jsDocTags?.find(tag => tag.name === 'deprecated');\n            if (!tag) {\n                return undefined;\n            }\n            const displayParts = tag.text;\n            return displayParts ? ts.displayPartsToString(displayParts) : '';\n        }\n        function isNodeCalleeOfParent(node) {\n            switch (node.parent?.type) {\n                case utils_1.AST_NODE_TYPES.NewExpression:\n                case utils_1.AST_NODE_TYPES.CallExpression:\n                    return node.parent.callee === node;\n                case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n                    return node.parent.tag === node;\n                case utils_1.AST_NODE_TYPES.JSXOpeningElement:\n                    return node.parent.name === node;\n                default:\n                    return false;\n            }\n        }\n        function getCallLikeNode(node) {\n            let callee = node;\n            while (callee.parent?.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                callee.parent.property === callee) {\n                callee = callee.parent;\n            }\n            return isNodeCalleeOfParent(callee) ? callee : undefined;\n        }\n        function getCallLikeDeprecation(node) {\n            const tsNode = services.esTreeNodeToTSNodeMap.get(node.parent);\n            // If the node is a direct function call, we look for its signature.\n            const signature = (0, util_1.nullThrows)(checker.getResolvedSignature(tsNode), 'Expected call like node to have signature');\n            const symbol = services.getSymbolAtLocation(node);\n            const aliasedSymbol = symbol != null && tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)\n                ? checker.getAliasedSymbol(symbol)\n                : symbol;\n            const symbolDeclarationKind = aliasedSymbol?.declarations?.[0].kind;\n            // Properties with function-like types have \"deprecated\" jsdoc\n            // on their symbols, not on their signatures:\n            //\n            // interface Props {\n            //   /** @deprecated */\n            //   property: () => 'foo'\n            //   ^symbol^  ^signature^\n            // }\n            if (symbolDeclarationKind !== ts.SyntaxKind.MethodDeclaration &&\n                symbolDeclarationKind !== ts.SyntaxKind.FunctionDeclaration &&\n                symbolDeclarationKind !== ts.SyntaxKind.MethodSignature) {\n                return (searchForDeprecationInAliasesChain(symbol, true) ??\n                    getJsDocDeprecation(signature) ??\n                    getJsDocDeprecation(aliasedSymbol));\n            }\n            return (searchForDeprecationInAliasesChain(symbol, \n            // Here we're working with a function declaration or method.\n            // Both can have 1 or more overloads, each overload creates one\n            // ts.Declaration which is placed in symbol.declarations.\n            //\n            // Imagine the following code:\n            //\n            // function foo(): void\n            // /** @deprecated Some Reason */\n            // function foo(arg: string): void\n            // function foo(arg?: string): void {}\n            //\n            // foo()    // <- foo is our symbol\n            //\n            // If we call getJsDocDeprecation(checker.getAliasedSymbol(symbol)),\n            // we get 'Some Reason', but after all, we are calling foo with\n            // a signature that is not deprecated!\n            // It works this way because symbol.getJsDocTags returns tags from\n            // all symbol declarations combined into one array. And AFAIK there is\n            // no publicly exported TS function that can tell us if a particular\n            // declaration is deprecated or not.\n            //\n            // So, in case of function and method declarations, we don't check original\n            // aliased symbol, but rely on the getJsDocDeprecation(signature) call below.\n            false) ?? getJsDocDeprecation(signature));\n        }\n        function getJSXAttributeDeprecation(openingElement, propertyName) {\n            const tsNode = services.esTreeNodeToTSNodeMap.get(openingElement.name);\n            const contextualType = (0, util_1.nullThrows)(checker.getContextualType(tsNode), 'Expected JSX opening element name to have contextualType');\n            const symbol = contextualType.getProperty(propertyName);\n            return getJsDocDeprecation(symbol);\n        }\n        function getDeprecationReason(node) {\n            const callLikeNode = getCallLikeNode(node);\n            if (callLikeNode) {\n                return getCallLikeDeprecation(callLikeNode);\n            }\n            if (node.parent.type === utils_1.AST_NODE_TYPES.JSXAttribute &&\n                node.type !== utils_1.AST_NODE_TYPES.Super) {\n                return getJSXAttributeDeprecation(node.parent.parent, node.name);\n            }\n            if (node.parent.type === utils_1.AST_NODE_TYPES.Property &&\n                node.type !== utils_1.AST_NODE_TYPES.Super) {\n                const property = services\n                    .getTypeAtLocation(node.parent.parent)\n                    .getProperty(node.name);\n                const propertySymbol = services.getSymbolAtLocation(node);\n                const valueSymbol = checker.getShorthandAssignmentValueSymbol(propertySymbol?.valueDeclaration);\n                return (getJsDocDeprecation(property) ??\n                    getJsDocDeprecation(propertySymbol) ??\n                    getJsDocDeprecation(valueSymbol));\n            }\n            return searchForDeprecationInAliasesChain(services.getSymbolAtLocation(node), true);\n        }\n        function checkIdentifier(node) {\n            if (isDeclaration(node) || isInsideExportOrImport(node)) {\n                return;\n            }\n            const reason = getDeprecationReason(node);\n            if (reason == null) {\n                return;\n            }\n            const type = services.getTypeAtLocation(node);\n            if ((0, util_1.typeMatchesSomeSpecifier)(type, allow, services.program)) {\n                return;\n            }\n            const name = getReportedNodeName(node);\n            context.report({\n                ...(reason\n                    ? {\n                        messageId: 'deprecatedWithReason',\n                        data: { name, reason },\n                    }\n                    : {\n                        messageId: 'deprecated',\n                        data: { name },\n                    }),\n                node,\n            });\n        }\n        return {\n            Identifier: checkIdentifier,\n            JSXIdentifier(node) {\n                if (node.parent.type !== utils_1.AST_NODE_TYPES.JSXClosingElement) {\n                    checkIdentifier(node);\n                }\n            },\n            PrivateIdentifier: checkIdentifier,\n            Super: checkIdentifier,\n        };\n    },\n});\nfunction getReportedNodeName(node) {\n    if (node.type === utils_1.AST_NODE_TYPES.Super) {\n        return 'super';\n    }\n    if (node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n        return `#${node.name}`;\n    }\n    return node.name;\n}\n"
        }
    ]
}