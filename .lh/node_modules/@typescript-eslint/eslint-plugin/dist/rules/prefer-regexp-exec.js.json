{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-regexp-exec.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891973868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst util_1 = require(\"../util\");\nvar ArgumentType;\n(function (ArgumentType) {\n    ArgumentType[ArgumentType[\"Other\"] = 0] = \"Other\";\n    ArgumentType[ArgumentType[\"String\"] = 1] = \"String\";\n    ArgumentType[ArgumentType[\"RegExp\"] = 2] = \"RegExp\";\n    ArgumentType[ArgumentType[\"Both\"] = 3] = \"Both\";\n})(ArgumentType || (ArgumentType = {}));\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-regexp-exec',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce `RegExp#exec` over `String#match` if no global flag is provided',\n            recommended: 'stylistic',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            regExpExecOverStringMatch: 'Use the `RegExp#exec()` method instead.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        /**\n         * Check if a given node type is a string.\n         * @param type The node type to check.\n         */\n        function isStringType(type) {\n            return (0, util_1.getTypeName)(checker, type) === 'string';\n        }\n        /**\n         * Check if a given node type is a RegExp.\n         * @param type The node type to check.\n         */\n        function isRegExpType(type) {\n            return (0, util_1.getTypeName)(checker, type) === 'RegExp';\n        }\n        function collectArgumentTypes(types) {\n            let result = ArgumentType.Other;\n            for (const type of types) {\n                if (isRegExpType(type)) {\n                    result |= ArgumentType.RegExp;\n                }\n                else if (isStringType(type)) {\n                    result |= ArgumentType.String;\n                }\n            }\n            return result;\n        }\n        /**\n         * Returns true if and only if we have syntactic proof that the /g flag is\n         * absent. Returns false in all other cases (i.e. it still might or might\n         * not contain the global flag).\n         */\n        function definitelyDoesNotContainGlobalFlag(node) {\n            if ((node.type === utils_1.AST_NODE_TYPES.CallExpression ||\n                node.type === utils_1.AST_NODE_TYPES.NewExpression) &&\n                node.callee.type === utils_1.AST_NODE_TYPES.Identifier &&\n                node.callee.name === 'RegExp') {\n                const flags = node.arguments.at(1);\n                return !(flags?.type === utils_1.AST_NODE_TYPES.Literal &&\n                    typeof flags.value === 'string' &&\n                    flags.value.includes('g'));\n            }\n            return false;\n        }\n        return {\n            'CallExpression[arguments.length=1] > MemberExpression'(memberNode) {\n                if (!(0, util_1.isStaticMemberAccessOfValue)(memberNode, context, 'match')) {\n                    return;\n                }\n                const objectNode = memberNode.object;\n                const callNode = memberNode.parent;\n                const [argumentNode] = callNode.arguments;\n                const argumentValue = (0, util_1.getStaticValue)(argumentNode, globalScope);\n                if (!isStringType(services.getTypeAtLocation(objectNode))) {\n                    return;\n                }\n                // Don't report regular expressions with global flag.\n                if ((!argumentValue &&\n                    !definitelyDoesNotContainGlobalFlag(argumentNode)) ||\n                    (argumentValue &&\n                        argumentValue.value instanceof RegExp &&\n                        argumentValue.value.flags.includes('g'))) {\n                    return;\n                }\n                if (argumentNode.type === utils_1.AST_NODE_TYPES.Literal &&\n                    typeof argumentNode.value === 'string') {\n                    let regExp;\n                    try {\n                        regExp = RegExp(argumentNode.value);\n                    }\n                    catch {\n                        return;\n                    }\n                    return context.report({\n                        node: memberNode.property,\n                        messageId: 'regExpExecOverStringMatch',\n                        fix: (0, util_1.getWrappingFixer)({\n                            node: callNode,\n                            innerNode: [objectNode],\n                            sourceCode: context.sourceCode,\n                            wrap: objectCode => `${regExp.toString()}.exec(${objectCode})`,\n                        }),\n                    });\n                }\n                const argumentType = services.getTypeAtLocation(argumentNode);\n                const argumentTypes = collectArgumentTypes(tsutils.unionTypeParts(argumentType));\n                switch (argumentTypes) {\n                    case ArgumentType.RegExp:\n                        return context.report({\n                            node: memberNode.property,\n                            messageId: 'regExpExecOverStringMatch',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node: callNode,\n                                innerNode: [objectNode, argumentNode],\n                                sourceCode: context.sourceCode,\n                                wrap: (objectCode, argumentCode) => `${argumentCode}.exec(${objectCode})`,\n                            }),\n                        });\n                    case ArgumentType.String:\n                        return context.report({\n                            node: memberNode.property,\n                            messageId: 'regExpExecOverStringMatch',\n                            fix: (0, util_1.getWrappingFixer)({\n                                node: callNode,\n                                innerNode: [objectNode, argumentNode],\n                                sourceCode: context.sourceCode,\n                                wrap: (objectCode, argumentCode) => `RegExp(${argumentCode}).exec(${objectCode})`,\n                            }),\n                        });\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}