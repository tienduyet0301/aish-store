{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/class-literal-property-style.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891959807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst printNodeModifiers = (node, final) => `${node.accessibility ?? ''}${node.static ? ' static' : ''} ${final} `.trimStart();\nconst isSupportedLiteral = (node) => {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.Literal:\n            return true;\n        case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n            return node.quasi.quasis.length === 1;\n        case utils_1.AST_NODE_TYPES.TemplateLiteral:\n            return node.quasis.length === 1;\n        default:\n            return false;\n    }\n};\nexports.default = (0, util_1.createRule)({\n    name: 'class-literal-property-style',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Enforce that literals on classes are exposed in a consistent style',\n            recommended: 'stylistic',\n        },\n        hasSuggestions: true,\n        messages: {\n            preferFieldStyle: 'Literals should be exposed using readonly fields.',\n            preferFieldStyleSuggestion: 'Replace the literals with readonly fields.',\n            preferGetterStyle: 'Literals should be exposed using getters.',\n            preferGetterStyleSuggestion: 'Replace the literals with getters.',\n        },\n        schema: [\n            {\n                type: 'string',\n                description: 'Which literal class member syntax to prefer.',\n                enum: ['fields', 'getters'],\n            },\n        ],\n    },\n    defaultOptions: ['fields'],\n    create(context, [style]) {\n        const propertiesInfoStack = [];\n        function enterClassBody() {\n            propertiesInfoStack.push({\n                excludeSet: new Set(),\n                properties: [],\n            });\n        }\n        function exitClassBody() {\n            const { excludeSet, properties } = (0, util_1.nullThrows)(propertiesInfoStack.pop(), 'Stack should exist on class exit');\n            properties.forEach(node => {\n                const { value } = node;\n                if (!value || !isSupportedLiteral(value)) {\n                    return;\n                }\n                const name = (0, util_1.getStaticMemberAccessValue)(node, context);\n                if (name && excludeSet.has(name)) {\n                    return;\n                }\n                context.report({\n                    node: node.key,\n                    messageId: 'preferGetterStyle',\n                    suggest: [\n                        {\n                            messageId: 'preferGetterStyleSuggestion',\n                            fix(fixer) {\n                                const name = context.sourceCode.getText(node.key);\n                                let text = '';\n                                text += printNodeModifiers(node, 'get');\n                                text += node.computed ? `[${name}]` : name;\n                                text += `() { return ${context.sourceCode.getText(value)}; }`;\n                                return fixer.replaceText(node, text);\n                            },\n                        },\n                    ],\n                });\n            });\n        }\n        function excludeAssignedProperty(node) {\n            if ((0, util_1.isAssignee)(node)) {\n                const { excludeSet } = propertiesInfoStack[propertiesInfoStack.length - 1];\n                const name = (0, util_1.getStaticMemberAccessValue)(node, context);\n                if (name) {\n                    excludeSet.add(name);\n                }\n            }\n        }\n        return {\n            ...(style === 'fields' && {\n                MethodDefinition(node) {\n                    if (node.kind !== 'get' ||\n                        node.override ||\n                        !node.value.body ||\n                        node.value.body.body.length === 0) {\n                        return;\n                    }\n                    const [statement] = node.value.body.body;\n                    if (statement.type !== utils_1.AST_NODE_TYPES.ReturnStatement) {\n                        return;\n                    }\n                    const { argument } = statement;\n                    if (!argument || !isSupportedLiteral(argument)) {\n                        return;\n                    }\n                    const name = (0, util_1.getStaticMemberAccessValue)(node, context);\n                    const hasDuplicateKeySetter = name &&\n                        node.parent.body.some(element => {\n                            return (element.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n                                element.kind === 'set' &&\n                                (0, util_1.isStaticMemberAccessOfValue)(element, context, name));\n                        });\n                    if (hasDuplicateKeySetter) {\n                        return;\n                    }\n                    context.report({\n                        node: node.key,\n                        messageId: 'preferFieldStyle',\n                        suggest: [\n                            {\n                                messageId: 'preferFieldStyleSuggestion',\n                                fix(fixer) {\n                                    const name = context.sourceCode.getText(node.key);\n                                    let text = '';\n                                    text += printNodeModifiers(node, 'readonly');\n                                    text += node.computed ? `[${name}]` : name;\n                                    text += ` = ${context.sourceCode.getText(argument)};`;\n                                    return fixer.replaceText(node, text);\n                                },\n                            },\n                        ],\n                    });\n                },\n            }),\n            ...(style === 'getters' && {\n                ClassBody: enterClassBody,\n                'ClassBody:exit': exitClassBody,\n                'MethodDefinition[kind=\"constructor\"] ThisExpression'(node) {\n                    if (node.parent.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n                        let parent = node.parent;\n                        while (!(0, util_1.isFunction)(parent)) {\n                            parent = parent.parent;\n                        }\n                        if (parent.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n                            parent.parent.kind === 'constructor') {\n                            excludeAssignedProperty(node.parent);\n                        }\n                    }\n                },\n                PropertyDefinition(node) {\n                    if (!node.readonly || node.declare || node.override) {\n                        return;\n                    }\n                    const { properties } = propertiesInfoStack[propertiesInfoStack.length - 1];\n                    properties.push(node);\n                },\n            }),\n        };\n    },\n});\n"
        }
    ]
}