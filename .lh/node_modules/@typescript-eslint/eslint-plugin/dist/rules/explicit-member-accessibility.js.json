{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/explicit-member-accessibility.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891961401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst getMemberHeadLoc_1 = require(\"../util/getMemberHeadLoc\");\nconst rangeToLoc_1 = require(\"../util/rangeToLoc\");\nexports.default = (0, util_1.createRule)({\n    name: 'explicit-member-accessibility',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Require explicit accessibility modifiers on class properties and methods',\n            // too opinionated to be recommended\n        },\n        fixable: 'code',\n        hasSuggestions: true,\n        messages: {\n            addExplicitAccessibility: \"Add '{{ type }}' accessibility modifier\",\n            missingAccessibility: 'Missing accessibility modifier on {{type}} {{name}}.',\n            unwantedPublicAccessibility: 'Public accessibility modifier on {{type}} {{name}}.',\n        },\n        schema: [\n            {\n                type: 'object',\n                $defs: {\n                    accessibilityLevel: {\n                        oneOf: [\n                            {\n                                type: 'string',\n                                description: 'Always require an accessor.',\n                                enum: ['explicit'],\n                            },\n                            {\n                                type: 'string',\n                                description: 'Require an accessor except when public.',\n                                enum: ['no-public'],\n                            },\n                            {\n                                type: 'string',\n                                description: 'Never check whether there is an accessor.',\n                                enum: ['off'],\n                            },\n                        ],\n                    },\n                },\n                additionalProperties: false,\n                properties: {\n                    accessibility: {\n                        $ref: '#/items/0/$defs/accessibilityLevel',\n                        description: 'Which accessibility modifier is required to exist or not exist.',\n                    },\n                    ignoredMethodNames: {\n                        type: 'array',\n                        description: 'Specific method names that may be ignored.',\n                        items: {\n                            type: 'string',\n                        },\n                    },\n                    overrides: {\n                        type: 'object',\n                        additionalProperties: false,\n                        description: 'Changes to required accessibility modifiers for specific kinds of class members.',\n                        properties: {\n                            accessors: { $ref: '#/items/0/$defs/accessibilityLevel' },\n                            constructors: { $ref: '#/items/0/$defs/accessibilityLevel' },\n                            methods: { $ref: '#/items/0/$defs/accessibilityLevel' },\n                            parameterProperties: {\n                                $ref: '#/items/0/$defs/accessibilityLevel',\n                            },\n                            properties: { $ref: '#/items/0/$defs/accessibilityLevel' },\n                        },\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [{ accessibility: 'explicit' }],\n    create(context, [option]) {\n        const baseCheck = option.accessibility ?? 'explicit';\n        const overrides = option.overrides ?? {};\n        const ctorCheck = overrides.constructors ?? baseCheck;\n        const accessorCheck = overrides.accessors ?? baseCheck;\n        const methodCheck = overrides.methods ?? baseCheck;\n        const propCheck = overrides.properties ?? baseCheck;\n        const paramPropCheck = overrides.parameterProperties ?? baseCheck;\n        const ignoredMethodNames = new Set(option.ignoredMethodNames ?? []);\n        /**\n         * Checks if a method declaration has an accessibility modifier.\n         * @param methodDefinition The node representing a MethodDefinition.\n         */\n        function checkMethodAccessibilityModifier(methodDefinition) {\n            if (methodDefinition.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n                return;\n            }\n            let nodeType = 'method definition';\n            let check = baseCheck;\n            switch (methodDefinition.kind) {\n                case 'method':\n                    check = methodCheck;\n                    break;\n                case 'constructor':\n                    check = ctorCheck;\n                    break;\n                case 'get':\n                case 'set':\n                    check = accessorCheck;\n                    nodeType = `${methodDefinition.kind} property accessor`;\n                    break;\n            }\n            const { name: methodName } = (0, util_1.getNameFromMember)(methodDefinition, context.sourceCode);\n            if (check === 'off' || ignoredMethodNames.has(methodName)) {\n                return;\n            }\n            if (check === 'no-public' &&\n                methodDefinition.accessibility === 'public') {\n                const publicKeyword = findPublicKeyword(methodDefinition);\n                context.report({\n                    loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, publicKeyword.range),\n                    messageId: 'unwantedPublicAccessibility',\n                    data: {\n                        name: methodName,\n                        type: nodeType,\n                    },\n                    fix: fixer => fixer.removeRange(publicKeyword.rangeToRemove),\n                });\n            }\n            else if (check === 'explicit' && !methodDefinition.accessibility) {\n                context.report({\n                    loc: (0, getMemberHeadLoc_1.getMemberHeadLoc)(context.sourceCode, methodDefinition),\n                    messageId: 'missingAccessibility',\n                    data: {\n                        name: methodName,\n                        type: nodeType,\n                    },\n                    suggest: getMissingAccessibilitySuggestions(methodDefinition),\n                });\n            }\n        }\n        /**\n         * Returns an object containing a range that corresponds to the \"public\"\n         * keyword for a node, and the range that would need to be removed to\n         * remove the \"public\" keyword (including associated whitespace).\n         */\n        function findPublicKeyword(node) {\n            const tokens = context.sourceCode.getTokens(node);\n            let rangeToRemove;\n            let keywordRange;\n            for (let i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                if (token.type === utils_1.AST_TOKEN_TYPES.Keyword &&\n                    token.value === 'public') {\n                    keywordRange = structuredClone(token.range);\n                    const commensAfterPublicKeyword = context.sourceCode.getCommentsAfter(token);\n                    if (commensAfterPublicKeyword.length) {\n                        // public /* Hi there! */ static foo()\n                        // ^^^^^^^\n                        rangeToRemove = [\n                            token.range[0],\n                            commensAfterPublicKeyword[0].range[0],\n                        ];\n                        break;\n                    }\n                    else {\n                        // public static foo()\n                        // ^^^^^^^\n                        rangeToRemove = [token.range[0], tokens[i + 1].range[0]];\n                        break;\n                    }\n                }\n            }\n            return { range: keywordRange, rangeToRemove };\n        }\n        /**\n         * Creates a fixer that adds an accessibility modifier keyword\n         */\n        function getMissingAccessibilitySuggestions(node) {\n            function fix(accessibility, fixer) {\n                if (node.decorators.length) {\n                    const lastDecorator = node.decorators[node.decorators.length - 1];\n                    const nextToken = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(lastDecorator), util_1.NullThrowsReasons.MissingToken('token', 'last decorator'));\n                    return fixer.insertTextBefore(nextToken, `${accessibility} `);\n                }\n                return fixer.insertTextBefore(node, `${accessibility} `);\n            }\n            return [\n                {\n                    messageId: 'addExplicitAccessibility',\n                    data: { type: 'public' },\n                    fix: fixer => fix('public', fixer),\n                },\n                {\n                    messageId: 'addExplicitAccessibility',\n                    data: { type: 'private' },\n                    fix: fixer => fix('private', fixer),\n                },\n                {\n                    messageId: 'addExplicitAccessibility',\n                    data: { type: 'protected' },\n                    fix: fixer => fix('protected', fixer),\n                },\n            ];\n        }\n        /**\n         * Checks if property has an accessibility modifier.\n         * @param propertyDefinition The node representing a PropertyDefinition.\n         */\n        function checkPropertyAccessibilityModifier(propertyDefinition) {\n            if (propertyDefinition.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n                return;\n            }\n            const nodeType = 'class property';\n            const { name: propertyName } = (0, util_1.getNameFromMember)(propertyDefinition, context.sourceCode);\n            if (propCheck === 'no-public' &&\n                propertyDefinition.accessibility === 'public') {\n                const publicKeywordRange = findPublicKeyword(propertyDefinition);\n                context.report({\n                    loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, publicKeywordRange.range),\n                    messageId: 'unwantedPublicAccessibility',\n                    data: {\n                        name: propertyName,\n                        type: nodeType,\n                    },\n                    fix: fixer => fixer.removeRange(publicKeywordRange.rangeToRemove),\n                });\n            }\n            else if (propCheck === 'explicit' &&\n                !propertyDefinition.accessibility) {\n                context.report({\n                    loc: (0, getMemberHeadLoc_1.getMemberHeadLoc)(context.sourceCode, propertyDefinition),\n                    messageId: 'missingAccessibility',\n                    data: {\n                        name: propertyName,\n                        type: nodeType,\n                    },\n                    suggest: getMissingAccessibilitySuggestions(propertyDefinition),\n                });\n            }\n        }\n        /**\n         * Checks that the parameter property has the desired accessibility modifiers set.\n         * @param node The node representing a Parameter Property\n         */\n        function checkParameterPropertyAccessibilityModifier(node) {\n            const nodeType = 'parameter property';\n            // HAS to be an identifier or assignment or TSC will throw\n            if (node.parameter.type !== utils_1.AST_NODE_TYPES.Identifier &&\n                node.parameter.type !== utils_1.AST_NODE_TYPES.AssignmentPattern) {\n                return;\n            }\n            const nodeName = node.parameter.type === utils_1.AST_NODE_TYPES.Identifier\n                ? node.parameter.name\n                : // has to be an Identifier or TSC will throw an error\n                    node.parameter.left.name;\n            switch (paramPropCheck) {\n                case 'explicit': {\n                    if (!node.accessibility) {\n                        context.report({\n                            loc: (0, getMemberHeadLoc_1.getParameterPropertyHeadLoc)(context.sourceCode, node, nodeName),\n                            messageId: 'missingAccessibility',\n                            data: {\n                                name: nodeName,\n                                type: nodeType,\n                            },\n                            suggest: getMissingAccessibilitySuggestions(node),\n                        });\n                    }\n                    break;\n                }\n                case 'no-public': {\n                    if (node.accessibility === 'public' && node.readonly) {\n                        const publicKeyword = findPublicKeyword(node);\n                        context.report({\n                            loc: (0, rangeToLoc_1.rangeToLoc)(context.sourceCode, publicKeyword.range),\n                            messageId: 'unwantedPublicAccessibility',\n                            data: {\n                                name: nodeName,\n                                type: nodeType,\n                            },\n                            fix: fixer => fixer.removeRange(publicKeyword.rangeToRemove),\n                        });\n                    }\n                    break;\n                }\n            }\n        }\n        return {\n            'MethodDefinition, TSAbstractMethodDefinition': checkMethodAccessibilityModifier,\n            'PropertyDefinition, TSAbstractPropertyDefinition, AccessorProperty, TSAbstractAccessorProperty': checkPropertyAccessibilityModifier,\n            TSParameterProperty: checkParameterPropertyAccessibilityModifier,\n        };\n    },\n});\n"
        }
    ]
}