{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-for-of.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972226,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-for-of',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce the use of `for-of` loop over the standard `for` loop where possible',\n            recommended: 'stylistic',\n        },\n        messages: {\n            preferForOf: 'Expected a `for-of` loop instead of a `for` loop with this simple iteration.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        function isSingleVariableDeclaration(node) {\n            return (node?.type === utils_1.AST_NODE_TYPES.VariableDeclaration &&\n                node.kind !== 'const' &&\n                node.declarations.length === 1);\n        }\n        function isLiteral(node, value) {\n            return node.type === utils_1.AST_NODE_TYPES.Literal && node.value === value;\n        }\n        function isZeroInitialized(node) {\n            return node.init != null && isLiteral(node.init, 0);\n        }\n        function isMatchingIdentifier(node, name) {\n            return node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === name;\n        }\n        function isLessThanLengthExpression(node, name) {\n            if (node?.type === utils_1.AST_NODE_TYPES.BinaryExpression &&\n                node.operator === '<' &&\n                isMatchingIdentifier(node.left, name) &&\n                node.right.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                isMatchingIdentifier(node.right.property, 'length')) {\n                return node.right.object;\n            }\n            return null;\n        }\n        function isIncrement(node, name) {\n            if (!node) {\n                return false;\n            }\n            switch (node.type) {\n                case utils_1.AST_NODE_TYPES.UpdateExpression:\n                    // x++ or ++x\n                    return (node.operator === '++' && isMatchingIdentifier(node.argument, name));\n                case utils_1.AST_NODE_TYPES.AssignmentExpression:\n                    if (isMatchingIdentifier(node.left, name)) {\n                        if (node.operator === '+=') {\n                            // x += 1\n                            return isLiteral(node.right, 1);\n                        }\n                        if (node.operator === '=') {\n                            // x = x + 1 or x = 1 + x\n                            const expr = node.right;\n                            return (expr.type === utils_1.AST_NODE_TYPES.BinaryExpression &&\n                                expr.operator === '+' &&\n                                ((isMatchingIdentifier(expr.left, name) &&\n                                    isLiteral(expr.right, 1)) ||\n                                    (isLiteral(expr.left, 1) &&\n                                        isMatchingIdentifier(expr.right, name))));\n                        }\n                    }\n            }\n            return false;\n        }\n        function contains(outer, inner) {\n            return (outer.range[0] <= inner.range[0] && outer.range[1] >= inner.range[1]);\n        }\n        function isIndexOnlyUsedWithArray(body, indexVar, arrayExpression) {\n            const arrayText = context.sourceCode.getText(arrayExpression);\n            return indexVar.references.every(reference => {\n                const id = reference.identifier;\n                const node = id.parent;\n                return (!contains(body, id) ||\n                    (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                        node.object.type !== utils_1.AST_NODE_TYPES.ThisExpression &&\n                        node.property === id &&\n                        context.sourceCode.getText(node.object) === arrayText &&\n                        !(0, util_1.isAssignee)(node)));\n            });\n        }\n        return {\n            'ForStatement:exit'(node) {\n                if (!isSingleVariableDeclaration(node.init)) {\n                    return;\n                }\n                const declarator = node.init.declarations[0];\n                if (!declarator ||\n                    !isZeroInitialized(declarator) ||\n                    declarator.id.type !== utils_1.AST_NODE_TYPES.Identifier) {\n                    return;\n                }\n                const indexName = declarator.id.name;\n                const arrayExpression = isLessThanLengthExpression(node.test, indexName);\n                if (!arrayExpression) {\n                    return;\n                }\n                const [indexVar] = context.sourceCode.getDeclaredVariables(node.init);\n                if (isIncrement(node.update, indexName) &&\n                    isIndexOnlyUsedWithArray(node.body, indexVar, arrayExpression)) {\n                    context.report({\n                        node,\n                        messageId: 'preferForOf',\n                    });\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}