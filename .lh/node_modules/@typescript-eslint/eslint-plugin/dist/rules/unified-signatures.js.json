{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/unified-signatures.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'unified-signatures',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow two overloads that could be unified into one with a union or an optional/rest parameter',\n            // too opinionated to be recommended\n            recommended: 'strict',\n        },\n        messages: {\n            omittingRestParameter: '{{failureStringStart}} with a rest parameter.',\n            omittingSingleParameter: '{{failureStringStart}} with an optional parameter.',\n            singleParameterDifference: '{{failureStringStart}} taking `{{type1}} | {{type2}}`.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ignoreDifferentlyNamedParameters: {\n                        type: 'boolean',\n                        description: 'Whether two parameters with different names at the same index should be considered different even if their types are the same.',\n                    },\n                    ignoreOverloadsWithDifferentJSDoc: {\n                        type: 'boolean',\n                        description: 'Whether two overloads with different JSDoc comments should be considered different even if their parameter and return types are the same.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            ignoreDifferentlyNamedParameters: false,\n            ignoreOverloadsWithDifferentJSDoc: false,\n        },\n    ],\n    create(context, [{ ignoreDifferentlyNamedParameters, ignoreOverloadsWithDifferentJSDoc }]) {\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n        function failureStringStart(otherLine) {\n            // For only 2 overloads we don't need to specify which is the other one.\n            const overloads = otherLine == null\n                ? 'These overloads'\n                : `This overload and the one on line ${otherLine}`;\n            return `${overloads} can be combined into one signature`;\n        }\n        function addFailures(failures) {\n            for (const failure of failures) {\n                const { only2, unify } = failure;\n                switch (unify.kind) {\n                    case 'single-parameter-difference': {\n                        const { p0, p1 } = unify;\n                        const lineOfOtherOverload = only2 ? undefined : p0.loc.start.line;\n                        const typeAnnotation0 = isTSParameterProperty(p0)\n                            ? p0.parameter.typeAnnotation\n                            : p0.typeAnnotation;\n                        const typeAnnotation1 = isTSParameterProperty(p1)\n                            ? p1.parameter.typeAnnotation\n                            : p1.typeAnnotation;\n                        context.report({\n                            loc: p1.loc,\n                            node: p1,\n                            messageId: 'singleParameterDifference',\n                            data: {\n                                failureStringStart: failureStringStart(lineOfOtherOverload),\n                                type1: context.sourceCode.getText(typeAnnotation0?.typeAnnotation),\n                                type2: context.sourceCode.getText(typeAnnotation1?.typeAnnotation),\n                            },\n                        });\n                        break;\n                    }\n                    case 'extra-parameter': {\n                        const { extraParameter, otherSignature } = unify;\n                        const lineOfOtherOverload = only2\n                            ? undefined\n                            : otherSignature.loc.start.line;\n                        context.report({\n                            loc: extraParameter.loc,\n                            node: extraParameter,\n                            messageId: extraParameter.type === utils_1.AST_NODE_TYPES.RestElement\n                                ? 'omittingRestParameter'\n                                : 'omittingSingleParameter',\n                            data: {\n                                failureStringStart: failureStringStart(lineOfOtherOverload),\n                            },\n                        });\n                    }\n                }\n            }\n        }\n        function checkOverloads(signatures, typeParameters) {\n            const result = [];\n            const isTypeParameter = getIsTypeParameter(typeParameters);\n            for (const overloads of signatures) {\n                forEachPair(overloads, (a, b) => {\n                    const signature0 = a.value ?? a;\n                    const signature1 = b.value ?? b;\n                    const unify = compareSignatures(signature0, signature1, isTypeParameter);\n                    if (unify != null) {\n                        result.push({ only2: overloads.length === 2, unify });\n                    }\n                });\n            }\n            return result;\n        }\n        function compareSignatures(a, b, isTypeParameter) {\n            if (!signaturesCanBeUnified(a, b, isTypeParameter)) {\n                return undefined;\n            }\n            return a.params.length === b.params.length\n                ? signaturesDifferBySingleParameter(a.params, b.params)\n                : signaturesDifferByOptionalOrRestParameter(a, b);\n        }\n        function signaturesCanBeUnified(a, b, isTypeParameter) {\n            // Must return the same type.\n            const aTypeParams = a.typeParameters != null ? a.typeParameters.params : undefined;\n            const bTypeParams = b.typeParameters != null ? b.typeParameters.params : undefined;\n            if (ignoreDifferentlyNamedParameters) {\n                const commonParamsLength = Math.min(a.params.length, b.params.length);\n                for (let i = 0; i < commonParamsLength; i += 1) {\n                    if (a.params[i].type === b.params[i].type &&\n                        getStaticParameterName(a.params[i]) !==\n                            getStaticParameterName(b.params[i])) {\n                        return false;\n                    }\n                }\n            }\n            if (ignoreOverloadsWithDifferentJSDoc) {\n                const aComment = getBlockCommentForNode(getExportingNode(a) ?? a);\n                const bComment = getBlockCommentForNode(getExportingNode(b) ?? b);\n                if (aComment?.value !== bComment?.value) {\n                    return false;\n                }\n            }\n            return (typesAreEqual(a.returnType, b.returnType) &&\n                // Must take the same type parameters.\n                // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.\n                (0, util_1.arraysAreEqual)(aTypeParams, bTypeParams, typeParametersAreEqual) &&\n                signatureUsesTypeParameter(a, isTypeParameter) ===\n                    signatureUsesTypeParameter(b, isTypeParameter));\n        }\n        /** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */\n        function signaturesDifferBySingleParameter(types1, types2) {\n            const index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);\n            if (index == null) {\n                return undefined;\n            }\n            // If remaining arrays are equal, the signatures differ by just one parameter type\n            if (!(0, util_1.arraysAreEqual)(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {\n                return undefined;\n            }\n            const a = types1[index];\n            const b = types2[index];\n            // Can unify `a?: string` and `b?: number`. Can't unify `...args: string[]` and `...args: number[]`.\n            // See https://github.com/Microsoft/TypeScript/issues/5077\n            return parametersHaveEqualSigils(a, b) &&\n                a.type !== utils_1.AST_NODE_TYPES.RestElement\n                ? { kind: 'single-parameter-difference', p0: a, p1: b }\n                : undefined;\n        }\n        /**\n         * Detect `a(): void` and `a(x: number): void`.\n         * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.\n         */\n        function signaturesDifferByOptionalOrRestParameter(a, b) {\n            const sig1 = a.params;\n            const sig2 = b.params;\n            const minLength = Math.min(sig1.length, sig2.length);\n            const longer = sig1.length < sig2.length ? sig2 : sig1;\n            const shorter = sig1.length < sig2.length ? sig1 : sig2;\n            const shorterSig = sig1.length < sig2.length ? a : b;\n            // If one is has 2+ parameters more than the other, they must all be optional/rest.\n            // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)\n            // Not allowed: f() and f(x, y)\n            for (let i = minLength + 1; i < longer.length; i++) {\n                if (!parameterMayBeMissing(longer[i])) {\n                    return undefined;\n                }\n            }\n            for (let i = 0; i < minLength; i++) {\n                const sig1i = sig1[i];\n                const sig2i = sig2[i];\n                const typeAnnotation1 = isTSParameterProperty(sig1i)\n                    ? sig1i.parameter.typeAnnotation\n                    : sig1i.typeAnnotation;\n                const typeAnnotation2 = isTSParameterProperty(sig2i)\n                    ? sig2i.parameter.typeAnnotation\n                    : sig2i.typeAnnotation;\n                if (!typesAreEqual(typeAnnotation1, typeAnnotation2)) {\n                    return undefined;\n                }\n            }\n            if (minLength > 0 &&\n                shorter[minLength - 1].type === utils_1.AST_NODE_TYPES.RestElement) {\n                return undefined;\n            }\n            return {\n                extraParameter: longer[longer.length - 1],\n                kind: 'extra-parameter',\n                otherSignature: shorterSig,\n            };\n        }\n        /** Given type parameters, returns a function to test whether a type is one of those parameters. */\n        function getIsTypeParameter(typeParameters) {\n            if (typeParameters == null) {\n                return (() => false);\n            }\n            const set = new Set();\n            for (const t of typeParameters.params) {\n                set.add(t.name.name);\n            }\n            return (typeName => set.has(typeName));\n        }\n        /** True if any of the outer type parameters are used in a signature. */\n        function signatureUsesTypeParameter(sig, isTypeParameter) {\n            return sig.params.some((p) => typeContainsTypeParameter(isTSParameterProperty(p)\n                ? p.parameter.typeAnnotation\n                : p.typeAnnotation));\n            function typeContainsTypeParameter(type) {\n                if (!type) {\n                    return false;\n                }\n                if (type.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n                    const typeName = type.typeName;\n                    if (isIdentifier(typeName) && isTypeParameter(typeName.name)) {\n                        return true;\n                    }\n                }\n                return typeContainsTypeParameter(type.typeAnnotation ??\n                    type.elementType);\n            }\n        }\n        function isTSParameterProperty(node) {\n            return node.type === utils_1.AST_NODE_TYPES.TSParameterProperty;\n        }\n        function parametersAreEqual(a, b) {\n            const typeAnnotationA = isTSParameterProperty(a)\n                ? a.parameter.typeAnnotation\n                : a.typeAnnotation;\n            const typeAnnotationB = isTSParameterProperty(b)\n                ? b.parameter.typeAnnotation\n                : b.typeAnnotation;\n            return (parametersHaveEqualSigils(a, b) &&\n                typesAreEqual(typeAnnotationA, typeAnnotationB));\n        }\n        /** True for optional/rest parameters. */\n        function parameterMayBeMissing(p) {\n            const optional = isTSParameterProperty(p)\n                ? p.parameter.optional\n                : p.optional;\n            return p.type === utils_1.AST_NODE_TYPES.RestElement || optional;\n        }\n        /** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */\n        function parametersHaveEqualSigils(a, b) {\n            const optionalA = isTSParameterProperty(a)\n                ? a.parameter.optional\n                : a.optional;\n            const optionalB = isTSParameterProperty(b)\n                ? b.parameter.optional\n                : b.optional;\n            return ((a.type === utils_1.AST_NODE_TYPES.RestElement) ===\n                (b.type === utils_1.AST_NODE_TYPES.RestElement) && optionalA === optionalB);\n        }\n        function typeParametersAreEqual(a, b) {\n            return (a.name.name === b.name.name &&\n                constraintsAreEqual(a.constraint, b.constraint));\n        }\n        function typesAreEqual(a, b) {\n            return (a === b ||\n                (a != null &&\n                    b != null &&\n                    context.sourceCode.getText(a.typeAnnotation) ===\n                        context.sourceCode.getText(b.typeAnnotation)));\n        }\n        function constraintsAreEqual(a, b) {\n            return a === b || (a != null && b != null && a.type === b.type);\n        }\n        /* Returns the first index where `a` and `b` differ. */\n        function getIndexOfFirstDifference(a, b, equal) {\n            for (let i = 0; i < a.length && i < b.length; i++) {\n                if (!equal(a[i], b[i])) {\n                    return i;\n                }\n            }\n            return undefined;\n        }\n        /** Calls `action` for every pair of values in `values`. */\n        function forEachPair(values, action) {\n            for (let i = 0; i < values.length; i++) {\n                for (let j = i + 1; j < values.length; j++) {\n                    action(values[i], values[j]);\n                }\n            }\n        }\n        const scopes = [];\n        let currentScope = {\n            overloads: new Map(),\n        };\n        function createScope(parent, typeParameters) {\n            if (currentScope) {\n                scopes.push(currentScope);\n            }\n            currentScope = {\n                overloads: new Map(),\n                parent,\n                typeParameters,\n            };\n        }\n        function checkScope() {\n            const scope = (0, util_1.nullThrows)(currentScope, 'checkScope() called without a current scope');\n            const failures = checkOverloads([...scope.overloads.values()], scope.typeParameters);\n            addFailures(failures);\n            currentScope = scopes.pop();\n        }\n        /**\n         * @returns the first valid JSDoc comment annotating `node`\n         */\n        function getBlockCommentForNode(node) {\n            return context.sourceCode\n                .getCommentsBefore(node)\n                .reverse()\n                .find(comment => comment.type === utils_1.AST_TOKEN_TYPES.Block);\n        }\n        function addOverload(signature, key, containingNode) {\n            key ??= getOverloadKey(signature);\n            if (currentScope &&\n                (containingNode ?? signature).parent === currentScope.parent) {\n                const overloads = currentScope.overloads.get(key);\n                if (overloads != null) {\n                    overloads.push(signature);\n                }\n                else {\n                    currentScope.overloads.set(key, [signature]);\n                }\n            }\n        }\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ClassDeclaration(node) {\n                createScope(node.body, node.typeParameters);\n            },\n            Program: createScope,\n            TSInterfaceDeclaration(node) {\n                createScope(node.body, node.typeParameters);\n            },\n            TSModuleBlock: createScope,\n            TSTypeLiteral: createScope,\n            // collect overloads\n            MethodDefinition(node) {\n                if (!node.value.body && !isGetterOrSetter(node)) {\n                    addOverload(node);\n                }\n            },\n            TSAbstractMethodDefinition(node) {\n                if (!node.value.body && !isGetterOrSetter(node)) {\n                    addOverload(node);\n                }\n            },\n            TSCallSignatureDeclaration: addOverload,\n            TSConstructSignatureDeclaration: addOverload,\n            TSDeclareFunction(node) {\n                const exportingNode = getExportingNode(node);\n                addOverload(node, node.id?.name ?? exportingNode?.type, exportingNode);\n            },\n            TSMethodSignature(node) {\n                if (!isGetterOrSetter(node)) {\n                    addOverload(node);\n                }\n            },\n            // validate scopes\n            'ClassDeclaration:exit': checkScope,\n            'Program:exit': checkScope,\n            'TSInterfaceDeclaration:exit': checkScope,\n            'TSModuleBlock:exit': checkScope,\n            'TSTypeLiteral:exit': checkScope,\n        };\n    },\n});\nfunction getExportingNode(node) {\n    return node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration ||\n        node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration\n        ? node.parent\n        : undefined;\n}\nfunction getOverloadKey(node) {\n    const info = getOverloadInfo(node);\n    return ((node.computed ? '0' : '1') +\n        (node.static ? '0' : '1') +\n        info);\n}\nfunction getOverloadInfo(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n            return 'constructor';\n        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n            return '()';\n        default: {\n            const { key } = node;\n            if (isPrivateIdentifier(key)) {\n                return `private_identifier_${key.name}`;\n            }\n            if (isIdentifier(key)) {\n                return `identifier_${key.name}`;\n            }\n            return key.raw;\n        }\n    }\n}\nfunction getStaticParameterName(param) {\n    switch (param.type) {\n        case utils_1.AST_NODE_TYPES.Identifier:\n            return param.name;\n        case utils_1.AST_NODE_TYPES.RestElement:\n            return getStaticParameterName(param.argument);\n        default:\n            return undefined;\n    }\n}\nfunction isIdentifier(node) {\n    return node.type === utils_1.AST_NODE_TYPES.Identifier;\n}\nfunction isPrivateIdentifier(node) {\n    return node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier;\n}\nfunction isGetterOrSetter(node) {\n    return node.kind === 'get' || node.kind === 'set';\n}\n"
        }
    ]
}