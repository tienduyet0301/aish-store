{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-optional-chain-utils/gatherLogicalOperands.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NullishComparisonType = exports.OperandValidity = void 0;\nexports.gatherLogicalOperands = gatherLogicalOperands;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts_api_utils_1 = require(\"ts-api-utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../../util\");\nvar ComparisonValueType;\n(function (ComparisonValueType) {\n    ComparisonValueType[\"Null\"] = \"Null\";\n    ComparisonValueType[\"Undefined\"] = \"Undefined\";\n    ComparisonValueType[\"UndefinedStringLiteral\"] = \"UndefinedStringLiteral\";\n})(ComparisonValueType || (ComparisonValueType = {}));\nvar OperandValidity;\n(function (OperandValidity) {\n    OperandValidity[\"Valid\"] = \"Valid\";\n    OperandValidity[\"Invalid\"] = \"Invalid\";\n})(OperandValidity || (exports.OperandValidity = OperandValidity = {}));\nvar NullishComparisonType;\n(function (NullishComparisonType) {\n    /** `x != null`, `x != undefined` */\n    NullishComparisonType[\"NotEqualNullOrUndefined\"] = \"NotEqualNullOrUndefined\";\n    /** `x == null`, `x == undefined` */\n    NullishComparisonType[\"EqualNullOrUndefined\"] = \"EqualNullOrUndefined\";\n    /** `x !== null` */\n    NullishComparisonType[\"NotStrictEqualNull\"] = \"NotStrictEqualNull\";\n    /** `x === null` */\n    NullishComparisonType[\"StrictEqualNull\"] = \"StrictEqualNull\";\n    /** `x !== undefined`, `typeof x !== 'undefined'` */\n    NullishComparisonType[\"NotStrictEqualUndefined\"] = \"NotStrictEqualUndefined\";\n    /** `x === undefined`, `typeof x === 'undefined'` */\n    NullishComparisonType[\"StrictEqualUndefined\"] = \"StrictEqualUndefined\";\n    /** `!x` */\n    NullishComparisonType[\"NotBoolean\"] = \"NotBoolean\";\n    /** `x` */\n    NullishComparisonType[\"Boolean\"] = \"Boolean\";\n})(NullishComparisonType || (exports.NullishComparisonType = NullishComparisonType = {}));\nconst NULLISH_FLAGS = ts.TypeFlags.Null | ts.TypeFlags.Undefined;\nfunction isValidFalseBooleanCheckType(node, disallowFalseyLiteral, parserServices, options) {\n    const type = parserServices.getTypeAtLocation(node);\n    const types = (0, ts_api_utils_1.unionTypeParts)(type);\n    if (disallowFalseyLiteral &&\n        /*\n        ```\n        declare const x: false | {a: string};\n        x && x.a;\n        !x || x.a;\n        ```\n    \n        We don't want to consider these two cases because the boolean expression\n        narrows out the non-nullish falsy cases - so converting the chain to `x?.a`\n        would introduce a build error\n        */ (types.some(t => (0, ts_api_utils_1.isBooleanLiteralType)(t) && t.intrinsicName === 'false') ||\n            types.some(t => (0, ts_api_utils_1.isStringLiteralType)(t) && t.value === '') ||\n            types.some(t => (0, ts_api_utils_1.isNumberLiteralType)(t) && t.value === 0) ||\n            types.some(t => (0, ts_api_utils_1.isBigIntLiteralType)(t) && t.value.base10Value === '0'))) {\n        return false;\n    }\n    let allowedFlags = NULLISH_FLAGS | ts.TypeFlags.Object;\n    if (options.checkAny === true) {\n        allowedFlags |= ts.TypeFlags.Any;\n    }\n    if (options.checkUnknown === true) {\n        allowedFlags |= ts.TypeFlags.Unknown;\n    }\n    if (options.checkString === true) {\n        allowedFlags |= ts.TypeFlags.StringLike;\n    }\n    if (options.checkNumber === true) {\n        allowedFlags |= ts.TypeFlags.NumberLike;\n    }\n    if (options.checkBoolean === true) {\n        allowedFlags |= ts.TypeFlags.BooleanLike;\n    }\n    if (options.checkBigInt === true) {\n        allowedFlags |= ts.TypeFlags.BigIntLike;\n    }\n    return types.every(t => (0, util_1.isTypeFlagSet)(t, allowedFlags));\n}\nfunction gatherLogicalOperands(node, parserServices, sourceCode, options) {\n    const result = [];\n    const { newlySeenLogicals, operands } = flattenLogicalOperands(node);\n    for (const operand of operands) {\n        const areMoreOperands = operand !== operands.at(-1);\n        switch (operand.type) {\n            case utils_1.AST_NODE_TYPES.BinaryExpression: {\n                // check for \"yoda\" style logical: null != x\n                const { comparedExpression, comparedValue, isYoda } = (() => {\n                    // non-yoda checks are by far the most common, so check for them first\n                    const comparedValueRight = getComparisonValueType(operand.right);\n                    if (comparedValueRight) {\n                        return {\n                            comparedExpression: operand.left,\n                            comparedValue: comparedValueRight,\n                            isYoda: false,\n                        };\n                    }\n                    return {\n                        comparedExpression: operand.right,\n                        comparedValue: getComparisonValueType(operand.left),\n                        isYoda: true,\n                    };\n                })();\n                if (comparedValue === ComparisonValueType.UndefinedStringLiteral) {\n                    if (comparedExpression.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                        comparedExpression.operator === 'typeof') {\n                        const argument = comparedExpression.argument;\n                        if (argument.type === utils_1.AST_NODE_TYPES.Identifier &&\n                            // typeof window === 'undefined'\n                            (0, util_1.isReferenceToGlobalFunction)(argument.name, argument, sourceCode)) {\n                            result.push({ type: OperandValidity.Invalid });\n                            continue;\n                        }\n                        // typeof x.y === 'undefined'\n                        result.push({\n                            comparedName: comparedExpression.argument,\n                            comparisonType: operand.operator.startsWith('!')\n                                ? NullishComparisonType.NotStrictEqualUndefined\n                                : NullishComparisonType.StrictEqualUndefined,\n                            isYoda,\n                            node: operand,\n                            type: OperandValidity.Valid,\n                        });\n                        continue;\n                    }\n                    // y === 'undefined'\n                    result.push({ type: OperandValidity.Invalid });\n                    continue;\n                }\n                switch (operand.operator) {\n                    case '!=':\n                    case '==':\n                        if (comparedValue === ComparisonValueType.Null ||\n                            comparedValue === ComparisonValueType.Undefined) {\n                            // x == null, x == undefined\n                            result.push({\n                                comparedName: comparedExpression,\n                                comparisonType: operand.operator.startsWith('!')\n                                    ? NullishComparisonType.NotEqualNullOrUndefined\n                                    : NullishComparisonType.EqualNullOrUndefined,\n                                isYoda,\n                                node: operand,\n                                type: OperandValidity.Valid,\n                            });\n                            continue;\n                        }\n                        // x == something :(\n                        result.push({ type: OperandValidity.Invalid });\n                        continue;\n                    case '!==':\n                    case '===': {\n                        const comparedName = comparedExpression;\n                        switch (comparedValue) {\n                            case ComparisonValueType.Null:\n                                result.push({\n                                    comparedName,\n                                    comparisonType: operand.operator.startsWith('!')\n                                        ? NullishComparisonType.NotStrictEqualNull\n                                        : NullishComparisonType.StrictEqualNull,\n                                    isYoda,\n                                    node: operand,\n                                    type: OperandValidity.Valid,\n                                });\n                                continue;\n                            case ComparisonValueType.Undefined:\n                                result.push({\n                                    comparedName,\n                                    comparisonType: operand.operator.startsWith('!')\n                                        ? NullishComparisonType.NotStrictEqualUndefined\n                                        : NullishComparisonType.StrictEqualUndefined,\n                                    isYoda,\n                                    node: operand,\n                                    type: OperandValidity.Valid,\n                                });\n                                continue;\n                            default:\n                                // x === something :(\n                                result.push({ type: OperandValidity.Invalid });\n                                continue;\n                        }\n                    }\n                }\n                result.push({ type: OperandValidity.Invalid });\n                continue;\n            }\n            case utils_1.AST_NODE_TYPES.UnaryExpression:\n                if (operand.operator === '!' &&\n                    isValidFalseBooleanCheckType(operand.argument, areMoreOperands && node.operator === '||', parserServices, options)) {\n                    result.push({\n                        comparedName: operand.argument,\n                        comparisonType: NullishComparisonType.NotBoolean,\n                        isYoda: false,\n                        node: operand,\n                        type: OperandValidity.Valid,\n                    });\n                    continue;\n                }\n                result.push({ type: OperandValidity.Invalid });\n                continue;\n            case utils_1.AST_NODE_TYPES.LogicalExpression:\n                // explicitly ignore the mixed logical expression cases\n                result.push({ type: OperandValidity.Invalid });\n                continue;\n            default:\n                if (isValidFalseBooleanCheckType(operand, areMoreOperands && node.operator === '&&', parserServices, options)) {\n                    result.push({\n                        comparedName: operand,\n                        comparisonType: NullishComparisonType.Boolean,\n                        isYoda: false,\n                        node: operand,\n                        type: OperandValidity.Valid,\n                    });\n                }\n                else {\n                    result.push({ type: OperandValidity.Invalid });\n                }\n                continue;\n        }\n    }\n    return {\n        newlySeenLogicals,\n        operands: result,\n    };\n    /*\n    The AST is always constructed such the first element is always the deepest element.\n    I.e. for this code: `foo && foo.bar && foo.bar.baz && foo.bar.baz.buzz`\n    The AST will look like this:\n    {\n      left: {\n        left: {\n          left: foo\n          right: foo.bar\n        }\n        right: foo.bar.baz\n      }\n      right: foo.bar.baz.buzz\n    }\n  \n    So given any logical expression, we can perform a depth-first traversal to get\n    the operands in order.\n  \n    Note that this function purposely does not inspect mixed logical expressions\n    like `foo || foo.bar && foo.bar.baz` - separate selector\n    */\n    function flattenLogicalOperands(node) {\n        const operands = [];\n        const newlySeenLogicals = new Set([node]);\n        const stack = [node.right, node.left];\n        let current;\n        while ((current = stack.pop())) {\n            if (current.type === utils_1.AST_NODE_TYPES.LogicalExpression &&\n                current.operator === node.operator) {\n                newlySeenLogicals.add(current);\n                stack.push(current.right);\n                stack.push(current.left);\n            }\n            else {\n                operands.push(current);\n            }\n        }\n        return {\n            newlySeenLogicals,\n            operands,\n        };\n    }\n    function getComparisonValueType(node) {\n        switch (node.type) {\n            case utils_1.AST_NODE_TYPES.Literal:\n                // eslint-disable-next-line eqeqeq, @typescript-eslint/internal/eqeq-nullish -- intentional exact comparison against null\n                if (node.value === null && node.raw === 'null') {\n                    return ComparisonValueType.Null;\n                }\n                if (node.value === 'undefined') {\n                    return ComparisonValueType.UndefinedStringLiteral;\n                }\n                return null;\n            case utils_1.AST_NODE_TYPES.Identifier:\n                if (node.name === 'undefined') {\n                    return ComparisonValueType.Undefined;\n                }\n                return null;\n        }\n        return null;\n    }\n}\n"
        }
    ]
}