{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-optional-chain-utils/compareNodes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeComparisonResult = void 0;\nexports.compareNodes = compareNodes;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst visitor_keys_1 = require(\"@typescript-eslint/visitor-keys\");\nvar NodeComparisonResult;\n(function (NodeComparisonResult) {\n    /** the two nodes are comparably the same */\n    NodeComparisonResult[\"Equal\"] = \"Equal\";\n    /** the left node is a subset of the right node */\n    NodeComparisonResult[\"Subset\"] = \"Subset\";\n    /** the left node is not the same or is a superset of the right node */\n    NodeComparisonResult[\"Invalid\"] = \"Invalid\";\n})(NodeComparisonResult || (exports.NodeComparisonResult = NodeComparisonResult = {}));\nfunction compareArrays(arrayA, arrayB) {\n    if (arrayA.length !== arrayB.length) {\n        return NodeComparisonResult.Invalid;\n    }\n    const result = arrayA.every((elA, idx) => {\n        const elB = arrayB[idx];\n        if (elA == null || elB == null) {\n            return elA === elB;\n        }\n        return compareUnknownValues(elA, elB) === NodeComparisonResult.Equal;\n    });\n    if (result) {\n        return NodeComparisonResult.Equal;\n    }\n    return NodeComparisonResult.Invalid;\n}\nfunction isValidNode(x) {\n    return (typeof x === 'object' &&\n        x != null &&\n        'type' in x &&\n        typeof x.type === 'string');\n}\nfunction isValidChainExpressionToLookThrough(node) {\n    return (!(node.parent?.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n        node.parent.object === node) &&\n        !(node.parent?.type === utils_1.AST_NODE_TYPES.CallExpression &&\n            node.parent.callee === node) &&\n        node.type === utils_1.AST_NODE_TYPES.ChainExpression);\n}\nfunction compareUnknownValues(valueA, valueB) {\n    /* istanbul ignore if -- not possible for us to test this - it's just a sanity safeguard */\n    if (valueA == null || valueB == null) {\n        if (valueA !== valueB) {\n            return NodeComparisonResult.Invalid;\n        }\n        return NodeComparisonResult.Equal;\n    }\n    /* istanbul ignore if -- not possible for us to test this - it's just a sanity safeguard */\n    if (!isValidNode(valueA) || !isValidNode(valueB)) {\n        return NodeComparisonResult.Invalid;\n    }\n    return compareNodes(valueA, valueB);\n}\nfunction compareByVisiting(nodeA, nodeB) {\n    const currentVisitorKeys = visitor_keys_1.visitorKeys[nodeA.type];\n    /* istanbul ignore if -- not possible for us to test this - it's just a sanity safeguard */\n    if (currentVisitorKeys == null) {\n        // we don't know how to visit this node, so assume it's invalid to avoid false-positives / broken fixers\n        return NodeComparisonResult.Invalid;\n    }\n    if (currentVisitorKeys.length === 0) {\n        // assume nodes with no keys are constant things like keywords\n        return NodeComparisonResult.Equal;\n    }\n    for (const key of currentVisitorKeys) {\n        // @ts-expect-error - dynamic access but it's safe\n        const nodeAChildOrChildren = nodeA[key];\n        // @ts-expect-error - dynamic access but it's safe\n        const nodeBChildOrChildren = nodeB[key];\n        if (Array.isArray(nodeAChildOrChildren)) {\n            const arrayA = nodeAChildOrChildren;\n            const arrayB = nodeBChildOrChildren;\n            const result = compareArrays(arrayA, arrayB);\n            if (result !== NodeComparisonResult.Equal) {\n                return NodeComparisonResult.Invalid;\n            }\n            // fallthrough to the next key as the key was \"equal\"\n        }\n        else {\n            const result = compareUnknownValues(nodeAChildOrChildren, nodeBChildOrChildren);\n            if (result !== NodeComparisonResult.Equal) {\n                return NodeComparisonResult.Invalid;\n            }\n            // fallthrough to the next key as the key was \"equal\"\n        }\n    }\n    return NodeComparisonResult.Equal;\n}\nfunction compareNodesUncached(nodeA, nodeB) {\n    if (nodeA.type !== nodeB.type) {\n        // special cases where nodes are allowed to be non-equal\n        // look through a chain expression node at the top-level because it only\n        // exists to delimit the end of an optional chain\n        //\n        // a?.b && a.b.c\n        // ^^^^ ChainExpression, MemberExpression\n        //         ^^^^^ MemberExpression\n        //\n        // except for in this class of cases\n        // (a?.b).c && a.b.c\n        // because the parentheses have runtime meaning (sad face)\n        if (isValidChainExpressionToLookThrough(nodeA)) {\n            return compareNodes(nodeA.expression, nodeB);\n        }\n        if (isValidChainExpressionToLookThrough(nodeB)) {\n            return compareNodes(nodeA, nodeB.expression);\n        }\n        // look through the type-only non-null assertion because its existence could\n        // possibly be replaced by an optional chain instead\n        //\n        // a.b! && a.b.c\n        // ^^^^ TSNonNullExpression\n        if (nodeA.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {\n            return compareNodes(nodeA.expression, nodeB);\n        }\n        if (nodeB.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {\n            return compareNodes(nodeA, nodeB.expression);\n        }\n        // special case for subset optional chains where the node types don't match,\n        // but we want to try comparing by discarding the \"extra\" code\n        //\n        // a && a.b\n        //      ^ compare this\n        // a && a()\n        //      ^ compare this\n        // a.b && a.b()\n        //        ^^^ compare this\n        // a() && a().b\n        //        ^^^ compare this\n        // import.meta && import.meta.b\n        //                ^^^^^^^^^^^ compare this\n        if (nodeA.type === utils_1.AST_NODE_TYPES.CallExpression ||\n            nodeA.type === utils_1.AST_NODE_TYPES.Identifier ||\n            nodeA.type === utils_1.AST_NODE_TYPES.MemberExpression ||\n            nodeA.type === utils_1.AST_NODE_TYPES.MetaProperty) {\n            switch (nodeB.type) {\n                case utils_1.AST_NODE_TYPES.MemberExpression:\n                    if (nodeB.property.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n                        // Private identifiers in optional chaining is not currently allowed\n                        // TODO - handle this once TS supports it (https://github.com/microsoft/TypeScript/issues/42734)\n                        return NodeComparisonResult.Invalid;\n                    }\n                    if (compareNodes(nodeA, nodeB.object) !== NodeComparisonResult.Invalid) {\n                        return NodeComparisonResult.Subset;\n                    }\n                    return NodeComparisonResult.Invalid;\n                case utils_1.AST_NODE_TYPES.CallExpression:\n                    if (compareNodes(nodeA, nodeB.callee) !== NodeComparisonResult.Invalid) {\n                        return NodeComparisonResult.Subset;\n                    }\n                    return NodeComparisonResult.Invalid;\n                default:\n                    return NodeComparisonResult.Invalid;\n            }\n        }\n        return NodeComparisonResult.Invalid;\n    }\n    switch (nodeA.type) {\n        // these expressions create a new instance each time - so it makes no sense to compare the chain\n        case utils_1.AST_NODE_TYPES.ArrayExpression:\n        case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n        case utils_1.AST_NODE_TYPES.ClassExpression:\n        case utils_1.AST_NODE_TYPES.FunctionExpression:\n        case utils_1.AST_NODE_TYPES.JSXElement:\n        case utils_1.AST_NODE_TYPES.JSXFragment:\n        case utils_1.AST_NODE_TYPES.NewExpression:\n        case utils_1.AST_NODE_TYPES.ObjectExpression:\n            return NodeComparisonResult.Invalid;\n        // chaining from assignments could change the value irrevocably - so it makes no sense to compare the chain\n        case utils_1.AST_NODE_TYPES.AssignmentExpression:\n            return NodeComparisonResult.Invalid;\n        case utils_1.AST_NODE_TYPES.CallExpression: {\n            const nodeBCall = nodeB;\n            // check for cases like\n            // foo() && foo()(bar)\n            // ^^^^^ nodeA\n            //          ^^^^^^^^^^ nodeB\n            // we don't want to check the arguments in this case\n            const aSubsetOfB = compareNodes(nodeA, nodeBCall.callee);\n            if (aSubsetOfB !== NodeComparisonResult.Invalid) {\n                return NodeComparisonResult.Subset;\n            }\n            const calleeCompare = compareNodes(nodeA.callee, nodeBCall.callee);\n            if (calleeCompare !== NodeComparisonResult.Equal) {\n                return NodeComparisonResult.Invalid;\n            }\n            // NOTE - we purposely ignore optional flag because for our purposes\n            // foo?.bar() && foo.bar?.()?.baz\n            // or\n            // foo.bar() && foo?.bar?.()?.baz\n            // are going to be exactly the same\n            const argumentCompare = compareArrays(nodeA.arguments, nodeBCall.arguments);\n            if (argumentCompare !== NodeComparisonResult.Equal) {\n                return NodeComparisonResult.Invalid;\n            }\n            const typeParamCompare = compareNodes(nodeA.typeArguments, nodeBCall.typeArguments);\n            if (typeParamCompare === NodeComparisonResult.Equal) {\n                return NodeComparisonResult.Equal;\n            }\n            return NodeComparisonResult.Invalid;\n        }\n        case utils_1.AST_NODE_TYPES.ChainExpression:\n            // special case handling for ChainExpression because it's allowed to be a subset\n            return compareNodes(nodeA, nodeB.expression);\n        case utils_1.AST_NODE_TYPES.Identifier:\n        case utils_1.AST_NODE_TYPES.PrivateIdentifier:\n            if (nodeA.name === nodeB.name) {\n                return NodeComparisonResult.Equal;\n            }\n            return NodeComparisonResult.Invalid;\n        case utils_1.AST_NODE_TYPES.Literal: {\n            const nodeBLiteral = nodeB;\n            if (nodeA.raw === nodeBLiteral.raw &&\n                nodeA.value === nodeBLiteral.value) {\n                return NodeComparisonResult.Equal;\n            }\n            return NodeComparisonResult.Invalid;\n        }\n        case utils_1.AST_NODE_TYPES.MemberExpression: {\n            const nodeBMember = nodeB;\n            if (nodeBMember.property.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n                // Private identifiers in optional chaining is not currently allowed\n                // TODO - handle this once TS supports it (https://github.com/microsoft/TypeScript/issues/42734)\n                return NodeComparisonResult.Invalid;\n            }\n            // check for cases like\n            // foo.bar && foo.bar.baz\n            // ^^^^^^^ nodeA\n            //            ^^^^^^^^^^^ nodeB\n            // result === Equal\n            //\n            // foo.bar && foo.bar.baz.bam\n            // ^^^^^^^ nodeA\n            //            ^^^^^^^^^^^^^^^ nodeB\n            // result === Subset\n            //\n            // we don't want to check the property in this case\n            const aSubsetOfB = compareNodes(nodeA, nodeBMember.object);\n            if (aSubsetOfB !== NodeComparisonResult.Invalid) {\n                return NodeComparisonResult.Subset;\n            }\n            if (nodeA.computed !== nodeBMember.computed) {\n                return NodeComparisonResult.Invalid;\n            }\n            // NOTE - we purposely ignore optional flag because for our purposes\n            // foo?.bar && foo.bar?.baz\n            // or\n            // foo.bar && foo?.bar?.baz\n            // are going to be exactly the same\n            const objectCompare = compareNodes(nodeA.object, nodeBMember.object);\n            if (objectCompare !== NodeComparisonResult.Equal) {\n                return NodeComparisonResult.Invalid;\n            }\n            return compareNodes(nodeA.property, nodeBMember.property);\n        }\n        case utils_1.AST_NODE_TYPES.TSTemplateLiteralType:\n        case utils_1.AST_NODE_TYPES.TemplateLiteral: {\n            const nodeBTemplate = nodeB;\n            const areQuasisEqual = nodeA.quasis.length === nodeBTemplate.quasis.length &&\n                nodeA.quasis.every((elA, idx) => {\n                    const elB = nodeBTemplate.quasis[idx];\n                    return elA.value.cooked === elB.value.cooked;\n                });\n            if (!areQuasisEqual) {\n                return NodeComparisonResult.Invalid;\n            }\n            return NodeComparisonResult.Equal;\n        }\n        case utils_1.AST_NODE_TYPES.TemplateElement: {\n            const nodeBElement = nodeB;\n            if (nodeA.value.cooked === nodeBElement.value.cooked) {\n                return NodeComparisonResult.Equal;\n            }\n            return NodeComparisonResult.Invalid;\n        }\n        // these aren't actually valid expressions.\n        // https://github.com/typescript-eslint/typescript-eslint/blob/20d7caee35ab84ae6381fdf04338c9e2b9e2bc48/packages/ast-spec/src/unions/Expression.ts#L37-L43\n        case utils_1.AST_NODE_TYPES.ArrayPattern:\n        case utils_1.AST_NODE_TYPES.ObjectPattern:\n            /* istanbul ignore next */\n            return NodeComparisonResult.Invalid;\n        // update expression returns a number and also changes the value each time - so it makes no sense to compare the chain\n        case utils_1.AST_NODE_TYPES.UpdateExpression:\n            return NodeComparisonResult.Invalid;\n        // yield returns the value passed to the `next` function, so it may not be the same each time - so it makes no sense to compare the chain\n        case utils_1.AST_NODE_TYPES.YieldExpression:\n            return NodeComparisonResult.Invalid;\n        // general-case automatic handling of nodes to save us implementing every\n        // single case by hand. This just iterates the visitor keys to recursively\n        // check the children.\n        //\n        // Any specific logic cases or short-circuits should be listed as separate\n        // cases so that they don't fall into this generic handling\n        default:\n            return compareByVisiting(nodeA, nodeB);\n    }\n}\nconst COMPARE_NODES_CACHE = new WeakMap();\n/**\n * Compares two nodes' ASTs to determine if the A is equal to or a subset of B\n */\nfunction compareNodes(nodeA, nodeB) {\n    if (nodeA == null || nodeB == null) {\n        if (nodeA !== nodeB) {\n            return NodeComparisonResult.Invalid;\n        }\n        return NodeComparisonResult.Equal;\n    }\n    const cached = COMPARE_NODES_CACHE.get(nodeA)?.get(nodeB);\n    if (cached) {\n        return cached;\n    }\n    const result = compareNodesUncached(nodeA, nodeB);\n    let mapA = COMPARE_NODES_CACHE.get(nodeA);\n    if (mapA == null) {\n        mapA = new WeakMap();\n        COMPARE_NODES_CACHE.set(nodeA, mapA);\n    }\n    mapA.set(nodeB, result);\n    return result;\n}\n"
        }
    ]
}