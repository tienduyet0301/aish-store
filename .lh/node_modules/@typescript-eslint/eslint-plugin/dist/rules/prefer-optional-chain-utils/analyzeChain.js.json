{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-optional-chain-utils/analyzeChain.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.analyzeChain = analyzeChain;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts_api_utils_1 = require(\"ts-api-utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../../util\");\nconst checkNullishAndReport_1 = require(\"./checkNullishAndReport\");\nconst compareNodes_1 = require(\"./compareNodes\");\nconst gatherLogicalOperands_1 = require(\"./gatherLogicalOperands\");\nfunction includesType(parserServices, node, typeFlagIn) {\n    const typeFlag = typeFlagIn | ts.TypeFlags.Any | ts.TypeFlags.Unknown;\n    const types = (0, ts_api_utils_1.unionTypeParts)(parserServices.getTypeAtLocation(node));\n    for (const type of types) {\n        if ((0, util_1.isTypeFlagSet)(type, typeFlag)) {\n            return true;\n        }\n    }\n    return false;\n}\nconst analyzeAndChainOperand = (parserServices, operand, index, chain) => {\n    switch (operand.comparisonType) {\n        case gatherLogicalOperands_1.NullishComparisonType.Boolean: {\n            const nextOperand = chain.at(index + 1);\n            if (nextOperand?.comparisonType ===\n                gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull &&\n                operand.comparedName.type === utils_1.AST_NODE_TYPES.Identifier) {\n                return null;\n            }\n            return [operand];\n        }\n        case gatherLogicalOperands_1.NullishComparisonType.NotEqualNullOrUndefined:\n            return [operand];\n        case gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull: {\n            // handle `x !== null && x !== undefined`\n            const nextOperand = chain.at(index + 1);\n            if (nextOperand?.comparisonType ===\n                gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined &&\n                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===\n                    compareNodes_1.NodeComparisonResult.Equal) {\n                return [operand, nextOperand];\n            }\n            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Undefined)) {\n                // we know the next operand is not an `undefined` check and that this\n                // operand includes `undefined` - which means that making this an\n                // optional chain would change the runtime behavior of the expression\n                return null;\n            }\n            return [operand];\n        }\n        case gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined: {\n            // handle `x !== undefined && x !== null`\n            const nextOperand = chain.at(index + 1);\n            if (nextOperand?.comparisonType ===\n                gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualNull &&\n                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===\n                    compareNodes_1.NodeComparisonResult.Equal) {\n                return [operand, nextOperand];\n            }\n            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Null)) {\n                // we know the next operand is not a `null` check and that this\n                // operand includes `null` - which means that making this an\n                // optional chain would change the runtime behavior of the expression\n                return null;\n            }\n            return [operand];\n        }\n        default:\n            return null;\n    }\n};\nconst analyzeOrChainOperand = (parserServices, operand, index, chain) => {\n    switch (operand.comparisonType) {\n        case gatherLogicalOperands_1.NullishComparisonType.NotBoolean:\n        case gatherLogicalOperands_1.NullishComparisonType.EqualNullOrUndefined:\n            return [operand];\n        case gatherLogicalOperands_1.NullishComparisonType.StrictEqualNull: {\n            // handle `x === null || x === undefined`\n            const nextOperand = chain.at(index + 1);\n            if (nextOperand?.comparisonType ===\n                gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined &&\n                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===\n                    compareNodes_1.NodeComparisonResult.Equal) {\n                return [operand, nextOperand];\n            }\n            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Undefined)) {\n                // we know the next operand is not an `undefined` check and that this\n                // operand includes `undefined` - which means that making this an\n                // optional chain would change the runtime behavior of the expression\n                return null;\n            }\n            return [operand];\n        }\n        case gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined: {\n            // handle `x === undefined || x === null`\n            const nextOperand = chain.at(index + 1);\n            if (nextOperand?.comparisonType === gatherLogicalOperands_1.NullishComparisonType.StrictEqualNull &&\n                (0, compareNodes_1.compareNodes)(operand.comparedName, nextOperand.comparedName) ===\n                    compareNodes_1.NodeComparisonResult.Equal) {\n                return [operand, nextOperand];\n            }\n            if (includesType(parserServices, operand.comparedName, ts.TypeFlags.Null)) {\n                // we know the next operand is not a `null` check and that this\n                // operand includes `null` - which means that making this an\n                // optional chain would change the runtime behavior of the expression\n                return null;\n            }\n            return [operand];\n        }\n        default:\n            return null;\n    }\n};\n/**\n * Returns the range that needs to be reported from the chain.\n * @param chain The chain of logical expressions.\n * @param boundary The boundary range that the range to report cannot fall outside.\n * @param sourceCode The source code to get tokens.\n * @returns The range to report.\n */\nfunction getReportRange(chain, boundary, sourceCode) {\n    const leftNode = chain[0].node;\n    const rightNode = chain[chain.length - 1].node;\n    let leftMost = (0, util_1.nullThrows)(sourceCode.getFirstToken(leftNode), util_1.NullThrowsReasons.MissingToken('any token', leftNode.type));\n    let rightMost = (0, util_1.nullThrows)(sourceCode.getLastToken(rightNode), util_1.NullThrowsReasons.MissingToken('any token', rightNode.type));\n    while (leftMost.range[0] > boundary[0]) {\n        const token = sourceCode.getTokenBefore(leftMost);\n        if (!token || !(0, util_1.isOpeningParenToken)(token) || token.range[0] < boundary[0]) {\n            break;\n        }\n        leftMost = token;\n    }\n    while (rightMost.range[1] < boundary[1]) {\n        const token = sourceCode.getTokenAfter(rightMost);\n        if (!token || !(0, util_1.isClosingParenToken)(token) || token.range[1] > boundary[1]) {\n            break;\n        }\n        rightMost = token;\n    }\n    return [leftMost.range[0], rightMost.range[1]];\n}\nfunction getReportDescriptor(sourceCode, parserServices, node, operator, options, chain) {\n    const lastOperand = chain[chain.length - 1];\n    let useSuggestionFixer;\n    if (options.allowPotentiallyUnsafeFixesThatModifyTheReturnTypeIKnowWhatImDoing ===\n        true) {\n        // user has opted-in to the unsafe behavior\n        useSuggestionFixer = false;\n    }\n    // optional chain specifically will union `undefined` into the final type\n    // so we need to make sure that there is at least one operand that includes\n    // `undefined`, or else we're going to change the final type - which is\n    // unsafe and might cause downstream type errors.\n    else if (lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.EqualNullOrUndefined ||\n        lastOperand.comparisonType ===\n            gatherLogicalOperands_1.NullishComparisonType.NotEqualNullOrUndefined ||\n        lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.StrictEqualUndefined ||\n        lastOperand.comparisonType ===\n            gatherLogicalOperands_1.NullishComparisonType.NotStrictEqualUndefined ||\n        (operator === '||' &&\n            lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.NotBoolean)) {\n        // we know the last operand is an equality check - so the change in types\n        // DOES NOT matter and will not change the runtime result or cause a type\n        // check error\n        useSuggestionFixer = false;\n    }\n    else {\n        useSuggestionFixer = true;\n        for (const operand of chain) {\n            if (includesType(parserServices, operand.node, ts.TypeFlags.Undefined)) {\n                useSuggestionFixer = false;\n                break;\n            }\n        }\n        // TODO - we could further reduce the false-positive rate of this check by\n        //        checking for cases where the change in types don't matter like\n        //        the test location of an if/while/etc statement.\n        //        but it's quite complex to do this without false-negatives, so\n        //        for now we'll just be over-eager with our matching.\n        //\n        //        it's MUCH better to false-positive here and only provide a\n        //        suggestion fixer, rather than false-negative and autofix to\n        //        broken code.\n    }\n    // In its most naive form we could just slap `?.` for every single part of the\n    // chain. However this would be undesirable because it'd create unnecessary\n    // conditions in the user's code where there were none before - and it would\n    // cause errors with rules like our `no-unnecessary-condition`.\n    //\n    // Instead we want to include the minimum number of `?.` required to correctly\n    // unify the code into a single chain. Naively you might think that we can\n    // just take the final operand add `?.` after the locations from the previous\n    // operands - however this won't be correct either because earlier operands\n    // can include a necessary `?.` that's not needed or included in a later\n    // operand.\n    //\n    // So instead what we need to do is to start at the first operand and\n    // iteratively diff it against the next operand, and add the difference to the\n    // first operand.\n    //\n    // eg\n    // `foo && foo.bar && foo.bar.baz?.bam && foo.bar.baz.bam()`\n    // 1) `foo`\n    // 2) diff(`foo`, `foo.bar`) = `.bar`\n    // 3) result = `foo?.bar`\n    // 4) diff(`foo.bar`, `foo.bar.baz?.bam`) = `.baz?.bam`\n    // 5) result = `foo?.bar?.baz?.bam`\n    // 6) diff(`foo.bar.baz?.bam`, `foo.bar.baz.bam()`) = `()`\n    // 7) result = `foo?.bar?.baz?.bam?.()`\n    const parts = [];\n    for (const current of chain) {\n        const nextOperand = flattenChainExpression(sourceCode, current.comparedName);\n        const diff = nextOperand.slice(parts.length);\n        if (diff.length > 0) {\n            if (parts.length > 0) {\n                // we need to make the first operand of the diff optional so it matches the\n                // logic before merging\n                // foo.bar && foo.bar.baz\n                // diff = .baz\n                // result = foo.bar?.baz\n                diff[0].optional = true;\n            }\n            parts.push(...diff);\n        }\n    }\n    let newCode = parts\n        .map(part => {\n        let str = '';\n        if (part.optional) {\n            str += '?.';\n        }\n        else {\n            if (part.nonNull) {\n                str += '!';\n            }\n            if (part.requiresDot) {\n                str += '.';\n            }\n        }\n        if (part.precedence !== util_1.OperatorPrecedence.Invalid &&\n            part.precedence < util_1.OperatorPrecedence.Member) {\n            str += `(${part.text})`;\n        }\n        else {\n            str += part.text;\n        }\n        return str;\n    })\n        .join('');\n    if (lastOperand.node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n        // retain the ending comparison for cases like\n        // x && x.a != null\n        // x && typeof x.a !== 'undefined'\n        const operator = lastOperand.node.operator;\n        const { left, right } = (() => {\n            if (lastOperand.isYoda) {\n                const unaryOperator = lastOperand.node.right.type === utils_1.AST_NODE_TYPES.UnaryExpression\n                    ? `${lastOperand.node.right.operator} `\n                    : '';\n                return {\n                    left: sourceCode.getText(lastOperand.node.left),\n                    right: unaryOperator + newCode,\n                };\n            }\n            const unaryOperator = lastOperand.node.left.type === utils_1.AST_NODE_TYPES.UnaryExpression\n                ? `${lastOperand.node.left.operator} `\n                : '';\n            return {\n                left: unaryOperator + newCode,\n                right: sourceCode.getText(lastOperand.node.right),\n            };\n        })();\n        newCode = `${left} ${operator} ${right}`;\n    }\n    else if (lastOperand.comparisonType === gatherLogicalOperands_1.NullishComparisonType.NotBoolean) {\n        newCode = `!${newCode}`;\n    }\n    const reportRange = getReportRange(chain, node.range, sourceCode);\n    const fix = fixer => fixer.replaceTextRange(reportRange, newCode);\n    return {\n        loc: {\n            end: sourceCode.getLocFromIndex(reportRange[1]),\n            start: sourceCode.getLocFromIndex(reportRange[0]),\n        },\n        messageId: 'preferOptionalChain',\n        ...(0, util_1.getFixOrSuggest)({\n            fixOrSuggest: useSuggestionFixer ? 'suggest' : 'fix',\n            suggestion: {\n                fix,\n                messageId: 'optionalChainSuggest',\n            },\n        }),\n    };\n    function flattenChainExpression(sourceCode, node) {\n        switch (node.type) {\n            case utils_1.AST_NODE_TYPES.ChainExpression:\n                return flattenChainExpression(sourceCode, node.expression);\n            case utils_1.AST_NODE_TYPES.CallExpression: {\n                const argumentsText = (() => {\n                    const closingParenToken = (0, util_1.nullThrows)(sourceCode.getLastToken(node), util_1.NullThrowsReasons.MissingToken('closing parenthesis', node.type));\n                    const openingParenToken = (0, util_1.nullThrows)(sourceCode.getFirstTokenBetween(node.typeArguments ?? node.callee, closingParenToken, util_1.isOpeningParenToken), util_1.NullThrowsReasons.MissingToken('opening parenthesis', node.type));\n                    return sourceCode.text.substring(openingParenToken.range[0], closingParenToken.range[1]);\n                })();\n                const typeArgumentsText = (() => {\n                    if (node.typeArguments == null) {\n                        return '';\n                    }\n                    return sourceCode.getText(node.typeArguments);\n                })();\n                return [\n                    ...flattenChainExpression(sourceCode, node.callee),\n                    {\n                        nonNull: false,\n                        optional: node.optional,\n                        // no precedence for this\n                        precedence: util_1.OperatorPrecedence.Invalid,\n                        requiresDot: false,\n                        text: typeArgumentsText + argumentsText,\n                    },\n                ];\n            }\n            case utils_1.AST_NODE_TYPES.MemberExpression: {\n                const propertyText = sourceCode.getText(node.property);\n                return [\n                    ...flattenChainExpression(sourceCode, node.object),\n                    {\n                        nonNull: node.object.type === utils_1.AST_NODE_TYPES.TSNonNullExpression,\n                        optional: node.optional,\n                        precedence: node.computed\n                            ? // computed is already wrapped in [] so no need to wrap in () as well\n                                util_1.OperatorPrecedence.Invalid\n                            : (0, util_1.getOperatorPrecedenceForNode)(node.property),\n                        requiresDot: !node.computed,\n                        text: node.computed ? `[${propertyText}]` : propertyText,\n                    },\n                ];\n            }\n            case utils_1.AST_NODE_TYPES.TSNonNullExpression:\n                return flattenChainExpression(sourceCode, node.expression);\n            default:\n                return [\n                    {\n                        nonNull: false,\n                        optional: false,\n                        precedence: (0, util_1.getOperatorPrecedenceForNode)(node),\n                        requiresDot: false,\n                        text: sourceCode.getText(node),\n                    },\n                ];\n        }\n    }\n}\nfunction analyzeChain(context, parserServices, options, node, operator, chain) {\n    // need at least 2 operands in a chain for it to be a chain\n    if (chain.length <= 1 ||\n        /* istanbul ignore next -- previous checks make this unreachable, but keep it for exhaustiveness check */\n        operator === '??') {\n        return;\n    }\n    const analyzeOperand = (() => {\n        switch (operator) {\n            case '&&':\n                return analyzeAndChainOperand;\n            case '||':\n                return analyzeOrChainOperand;\n        }\n    })();\n    // Things like x !== null && x !== undefined have two nodes, but they are\n    // one logical unit here, so we'll allow them to be grouped.\n    let subChain = [];\n    const maybeReportThenReset = (newChainSeed) => {\n        if (subChain.length > 1) {\n            const subChainFlat = subChain.flat();\n            (0, checkNullishAndReport_1.checkNullishAndReport)(context, parserServices, options, subChainFlat.slice(0, -1).map(({ node }) => node), getReportDescriptor(context.sourceCode, parserServices, node, operator, options, subChainFlat));\n        }\n        // we've reached the end of a chain of logical expressions\n        // i.e. the current operand doesn't belong to the previous chain.\n        //\n        // we don't want to throw away the current operand otherwise we will skip it\n        // and that can cause us to miss chains. So instead we seed the new chain\n        // with the current operand\n        //\n        // eg this means we can catch cases like:\n        //     unrelated != null && foo != null && foo.bar != null;\n        //     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ first \"chain\"\n        //                          ^^^^^^^^^^^ newChainSeed\n        //                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ second chain\n        subChain = newChainSeed ? [newChainSeed] : [];\n    };\n    for (let i = 0; i < chain.length; i += 1) {\n        const lastOperand = subChain.flat().at(-1);\n        const operand = chain[i];\n        const validatedOperands = analyzeOperand(parserServices, operand, i, chain);\n        if (!validatedOperands) {\n            // TODO - #7170\n            // check if the name is a superset/equal - if it is, then it likely\n            // intended to be part of the chain and something we should include in the\n            // report, eg\n            //     foo == null || foo.bar;\n            //     ^^^^^^^^^^^ valid OR chain\n            //                    ^^^^^^^ invalid OR chain logical, but still part of\n            //                            the chain for combination purposes\n            maybeReportThenReset();\n            continue;\n        }\n        // in case multiple operands were consumed - make sure to correctly increment the index\n        i += validatedOperands.length - 1;\n        const currentOperand = validatedOperands[0];\n        if (lastOperand) {\n            const comparisonResult = (0, compareNodes_1.compareNodes)(lastOperand.comparedName, \n            // purposely inspect and push the last operand because the prior operands don't matter\n            // this also means we won't false-positive in cases like\n            // foo !== null && foo !== undefined\n            validatedOperands[validatedOperands.length - 1].comparedName);\n            if (comparisonResult === compareNodes_1.NodeComparisonResult.Subset) {\n                // the operands are comparable, so we can continue searching\n                subChain.push(currentOperand);\n            }\n            else if (comparisonResult === compareNodes_1.NodeComparisonResult.Invalid) {\n                maybeReportThenReset(validatedOperands);\n            }\n            else {\n                // purposely don't push this case because the node is a no-op and if\n                // we consider it then we might report on things like\n                // foo && foo\n            }\n        }\n        else {\n            subChain.push(currentOperand);\n        }\n    }\n    // check the leftovers\n    maybeReportThenReset();\n}\n"
        }
    ]
}