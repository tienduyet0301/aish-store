{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-invalid-void-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891965927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-invalid-void-type',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow `void` type outside of generic or return types',\n            recommended: 'strict',\n        },\n        messages: {\n            invalidVoidForGeneric: '{{ generic }} may not have void as a type argument.',\n            invalidVoidNotReturn: 'void is only valid as a return type.',\n            invalidVoidNotReturnOrGeneric: 'void is only valid as a return type or generic type argument.',\n            invalidVoidNotReturnOrThisParam: 'void is only valid as return type or type of `this` parameter.',\n            invalidVoidNotReturnOrThisParamOrGeneric: 'void is only valid as a return type or generic type argument or the type of a `this` parameter.',\n            invalidVoidUnionConstituent: 'void is not valid as a constituent in a union type',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowAsThisParameter: {\n                        type: 'boolean',\n                        description: 'Whether a `this` parameter of a function may be `void`.',\n                    },\n                    allowInGenericTypeArguments: {\n                        description: 'Whether `void` can be used as a valid value for generic type parameters.',\n                        oneOf: [\n                            {\n                                type: 'boolean',\n                                description: 'Whether `void` can be used as a valid value for all generic type parameters.',\n                            },\n                            {\n                                type: 'array',\n                                description: 'Allowlist of types that may accept `void` as a generic type parameter.',\n                                items: { type: 'string' },\n                                minItems: 1,\n                            },\n                        ],\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        { allowAsThisParameter: false, allowInGenericTypeArguments: true },\n    ],\n    create(context, [{ allowAsThisParameter, allowInGenericTypeArguments }]) {\n        const validParents = [\n            utils_1.AST_NODE_TYPES.TSTypeAnnotation, //\n        ];\n        const invalidGrandParents = [\n            utils_1.AST_NODE_TYPES.TSPropertySignature,\n            utils_1.AST_NODE_TYPES.CallExpression,\n            utils_1.AST_NODE_TYPES.PropertyDefinition,\n            utils_1.AST_NODE_TYPES.AccessorProperty,\n            utils_1.AST_NODE_TYPES.Identifier,\n        ];\n        const validUnionMembers = [\n            utils_1.AST_NODE_TYPES.TSVoidKeyword,\n            utils_1.AST_NODE_TYPES.TSNeverKeyword,\n        ];\n        if (allowInGenericTypeArguments === true) {\n            validParents.push(utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation);\n        }\n        /**\n         * @brief check if the given void keyword is used as a valid generic type\n         *\n         * reports if the type parametrized by void is not in the allowlist, or\n         * allowInGenericTypeArguments is false.\n         * no-op if the given void keyword is not used as generic type\n         */\n        function checkGenericTypeArgument(node) {\n            // only matches T<..., void, ...>\n            // extra check for precaution\n            /* istanbul ignore next */\n            if (node.parent.type !== utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation ||\n                node.parent.parent.type !== utils_1.AST_NODE_TYPES.TSTypeReference) {\n                return;\n            }\n            // check allowlist\n            if (Array.isArray(allowInGenericTypeArguments)) {\n                const fullyQualifiedName = context.sourceCode\n                    .getText(node.parent.parent.typeName)\n                    .replaceAll(' ', '');\n                if (!allowInGenericTypeArguments\n                    .map(s => s.replaceAll(' ', ''))\n                    .includes(fullyQualifiedName)) {\n                    context.report({\n                        node,\n                        messageId: 'invalidVoidForGeneric',\n                        data: { generic: fullyQualifiedName },\n                    });\n                }\n                return;\n            }\n            if (!allowInGenericTypeArguments) {\n                context.report({\n                    node,\n                    messageId: allowAsThisParameter\n                        ? 'invalidVoidNotReturnOrThisParam'\n                        : 'invalidVoidNotReturn',\n                });\n            }\n        }\n        /**\n         * @brief checks if the generic type parameter defaults to void\n         */\n        function checkDefaultVoid(node, parentNode) {\n            if (parentNode.default !== node) {\n                context.report({\n                    node,\n                    messageId: getNotReturnOrGenericMessageId(node),\n                });\n            }\n        }\n        /**\n         * @brief checks that a union containing void is valid\n         * @return true if every member of the union is specified as a valid type in\n         * validUnionMembers, or is a valid generic type parametrized by void\n         */\n        function isValidUnionType(node) {\n            return node.types.every(member => validUnionMembers.includes(member.type) ||\n                // allows any T<..., void, ...> here, checked by checkGenericTypeArgument\n                (member.type === utils_1.AST_NODE_TYPES.TSTypeReference &&\n                    member.typeArguments?.type ===\n                        utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation &&\n                    member.typeArguments.params\n                        .map(param => param.type)\n                        .includes(utils_1.AST_NODE_TYPES.TSVoidKeyword)));\n        }\n        return {\n            TSVoidKeyword(node) {\n                // checks T<..., void, ...> against specification of allowInGenericArguments option\n                if (node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation &&\n                    node.parent.parent.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n                    checkGenericTypeArgument(node);\n                    return;\n                }\n                // allow <T = void> if allowInGenericTypeArguments is specified, and report if the generic type parameter extends void\n                if (allowInGenericTypeArguments &&\n                    node.parent.type === utils_1.AST_NODE_TYPES.TSTypeParameter &&\n                    node.parent.default?.type === utils_1.AST_NODE_TYPES.TSVoidKeyword) {\n                    checkDefaultVoid(node, node.parent);\n                    return;\n                }\n                // union w/ void must contain types from validUnionMembers, or a valid generic void type\n                if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType &&\n                    isValidUnionType(node.parent)) {\n                    return;\n                }\n                // using `void` as part of the return type of function overloading implementation\n                if (node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n                    const declaringFunction = getParentFunctionDeclarationNode(node.parent);\n                    if (declaringFunction &&\n                        (0, util_1.hasOverloadSignatures)(declaringFunction, context)) {\n                        return;\n                    }\n                }\n                // this parameter is ok to be void.\n                if (allowAsThisParameter &&\n                    node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAnnotation &&\n                    node.parent.parent.type === utils_1.AST_NODE_TYPES.Identifier &&\n                    node.parent.parent.name === 'this') {\n                    return;\n                }\n                // default cases\n                if (validParents.includes(node.parent.type) &&\n                    // https://github.com/typescript-eslint/typescript-eslint/issues/6225\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    !invalidGrandParents.includes(node.parent.parent.type)) {\n                    return;\n                }\n                context.report({\n                    node,\n                    messageId: allowInGenericTypeArguments && allowAsThisParameter\n                        ? 'invalidVoidNotReturnOrThisParamOrGeneric'\n                        : allowInGenericTypeArguments\n                            ? getNotReturnOrGenericMessageId(node)\n                            : allowAsThisParameter\n                                ? 'invalidVoidNotReturnOrThisParam'\n                                : 'invalidVoidNotReturn',\n                });\n            },\n        };\n    },\n});\nfunction getNotReturnOrGenericMessageId(node) {\n    return node.parent.type === utils_1.AST_NODE_TYPES.TSUnionType\n        ? 'invalidVoidUnionConstituent'\n        : 'invalidVoidNotReturnOrGeneric';\n}\nfunction getParentFunctionDeclarationNode(node) {\n    let current = node.parent;\n    while (current) {\n        if (current.type === utils_1.AST_NODE_TYPES.FunctionDeclaration) {\n            return current;\n        }\n        if (current.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n            current.value.body != null) {\n            return current;\n        }\n        current = current.parent;\n    }\n    return null;\n}\n"
        }
    ]
}