{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/adjacent-overload-signatures.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891959314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'adjacent-overload-signatures',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require that function overload signatures be consecutive',\n            recommended: 'stylistic',\n        },\n        messages: {\n            adjacentSignature: 'All {{name}} signatures should be adjacent.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        /**\n         * Gets the name and attribute of the member being processed.\n         * @param member the member being processed.\n         * @returns the name and attribute of the member or null if it's a member not relevant to the rule.\n         */\n        function getMemberMethod(member) {\n            switch (member.type) {\n                case utils_1.AST_NODE_TYPES.ExportDefaultDeclaration:\n                case utils_1.AST_NODE_TYPES.ExportNamedDeclaration: {\n                    // export statements (e.g. export { a };)\n                    // have no declarations, so ignore them\n                    if (!member.declaration) {\n                        return null;\n                    }\n                    return getMemberMethod(member.declaration);\n                }\n                case utils_1.AST_NODE_TYPES.TSDeclareFunction:\n                case utils_1.AST_NODE_TYPES.FunctionDeclaration: {\n                    const name = member.id?.name ?? null;\n                    if (name == null) {\n                        return null;\n                    }\n                    return {\n                        name,\n                        type: util_1.MemberNameType.Normal,\n                        callSignature: false,\n                    };\n                }\n                case utils_1.AST_NODE_TYPES.TSMethodSignature:\n                case utils_1.AST_NODE_TYPES.MethodDefinition:\n                    return {\n                        ...(0, util_1.getNameFromMember)(member, context.sourceCode),\n                        callSignature: false,\n                        static: !!member.static,\n                    };\n                case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n                    return {\n                        name: 'call',\n                        type: util_1.MemberNameType.Normal,\n                        callSignature: true,\n                    };\n                case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n                    return {\n                        name: 'new',\n                        type: util_1.MemberNameType.Normal,\n                        callSignature: false,\n                    };\n            }\n            return null;\n        }\n        function isSameMethod(method1, method2) {\n            return (!!method2 &&\n                method1.name === method2.name &&\n                method1.static === method2.static &&\n                method1.callSignature === method2.callSignature &&\n                method1.type === method2.type);\n        }\n        function getMembers(node) {\n            switch (node.type) {\n                case utils_1.AST_NODE_TYPES.ClassBody:\n                case utils_1.AST_NODE_TYPES.Program:\n                case utils_1.AST_NODE_TYPES.TSModuleBlock:\n                case utils_1.AST_NODE_TYPES.TSInterfaceBody:\n                case utils_1.AST_NODE_TYPES.BlockStatement:\n                    return node.body;\n                case utils_1.AST_NODE_TYPES.TSTypeLiteral:\n                    return node.members;\n            }\n        }\n        function checkBodyForOverloadMethods(node) {\n            const members = getMembers(node);\n            let lastMethod = null;\n            const seenMethods = [];\n            members.forEach(member => {\n                const method = getMemberMethod(member);\n                if (method == null) {\n                    lastMethod = null;\n                    return;\n                }\n                const index = seenMethods.findIndex(seenMethod => isSameMethod(method, seenMethod));\n                if (index > -1 && !isSameMethod(method, lastMethod)) {\n                    context.report({\n                        node: member,\n                        messageId: 'adjacentSignature',\n                        data: {\n                            name: `${method.static ? 'static ' : ''}${method.name}`,\n                        },\n                    });\n                }\n                else if (index === -1) {\n                    seenMethods.push(method);\n                }\n                lastMethod = method;\n            });\n        }\n        return {\n            BlockStatement: checkBodyForOverloadMethods,\n            ClassBody: checkBodyForOverloadMethods,\n            Program: checkBodyForOverloadMethods,\n            TSInterfaceBody: checkBodyForOverloadMethods,\n            TSModuleBlock: checkBodyForOverloadMethods,\n            TSTypeLiteral: checkBodyForOverloadMethods,\n        };\n    },\n});\n"
        }
    ]
}