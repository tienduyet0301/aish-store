{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/consistent-type-definitions.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891960669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'consistent-type-definitions',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce type definitions to consistently use either `interface` or `type`',\n            recommended: 'stylistic',\n        },\n        fixable: 'code',\n        messages: {\n            interfaceOverType: 'Use an `interface` instead of a `type`.',\n            typeOverInterface: 'Use a `type` instead of an `interface`.',\n        },\n        schema: [\n            {\n                type: 'string',\n                description: 'Which type definition syntax to prefer.',\n                enum: ['interface', 'type'],\n            },\n        ],\n    },\n    defaultOptions: ['interface'],\n    create(context, [option]) {\n        /**\n         * Iterates from the highest parent to the currently traversed node\n         * to determine whether any node in tree is globally declared module declaration\n         */\n        function isCurrentlyTraversedNodeWithinModuleDeclaration(node) {\n            return context.sourceCode\n                .getAncestors(node)\n                .some(node => node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration &&\n                node.declare &&\n                node.kind === 'global');\n        }\n        return {\n            ...(option === 'interface' && {\n                \"TSTypeAliasDeclaration[typeAnnotation.type='TSTypeLiteral']\"(node) {\n                    context.report({\n                        node: node.id,\n                        messageId: 'interfaceOverType',\n                        fix(fixer) {\n                            const typeToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.id, token => token.value === 'type'), util_1.NullThrowsReasons.MissingToken('type keyword', 'type alias'));\n                            const equalsToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(node.typeAnnotation, token => token.value === '='), util_1.NullThrowsReasons.MissingToken('=', 'type alias'));\n                            const beforeEqualsToken = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(equalsToken, {\n                                includeComments: true,\n                            }), util_1.NullThrowsReasons.MissingToken('before =', 'type alias'));\n                            return [\n                                // replace 'type' with 'interface'.\n                                fixer.replaceText(typeToken, 'interface'),\n                                // delete from the = to the { of the type, and put a space to be pretty.\n                                fixer.replaceTextRange([beforeEqualsToken.range[1], node.typeAnnotation.range[0]], ' '),\n                                // remove from the closing } through the end of the statement.\n                                fixer.removeRange([\n                                    node.typeAnnotation.range[1],\n                                    node.range[1],\n                                ]),\n                            ];\n                        },\n                    });\n                },\n            }),\n            ...(option === 'type' && {\n                TSInterfaceDeclaration(node) {\n                    const fix = isCurrentlyTraversedNodeWithinModuleDeclaration(node)\n                        ? null\n                        : (fixer) => {\n                            const typeNode = node.typeParameters ?? node.id;\n                            const fixes = [];\n                            const firstToken = context.sourceCode.getTokenBefore(node.id);\n                            if (firstToken) {\n                                fixes.push(fixer.replaceText(firstToken, 'type'));\n                                fixes.push(fixer.replaceTextRange([typeNode.range[1], node.body.range[0]], ' = '));\n                            }\n                            node.extends.forEach(heritage => {\n                                const typeIdentifier = context.sourceCode.getText(heritage);\n                                fixes.push(fixer.insertTextAfter(node.body, ` & ${typeIdentifier}`));\n                            });\n                            if (node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n                                fixes.push(fixer.removeRange([node.parent.range[0], node.range[0]]), fixer.insertTextAfter(node.body, `\\nexport default ${node.id.name}`));\n                            }\n                            return fixes;\n                        };\n                    context.report({\n                        node: node.id,\n                        messageId: 'typeOverInterface',\n                        /**\n                         * remove automatically fix when the interface is within a declare global\n                         * @see {@link https://github.com/typescript-eslint/typescript-eslint/issues/2707}\n                         */\n                        fix,\n                    });\n                },\n            }),\n        };\n    },\n});\n"
        }
    ]
}