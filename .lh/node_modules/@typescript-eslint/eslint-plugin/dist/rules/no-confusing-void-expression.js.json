{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-confusing-void-expression.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891963344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst getParentFunctionNode_1 = require(\"../util/getParentFunctionNode\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-confusing-void-expression',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Require expressions of type void to appear in statement position',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        hasSuggestions: true,\n        messages: {\n            invalidVoidExpr: 'Placing a void expression inside another expression is forbidden. ' +\n                'Move it to its own statement instead.',\n            invalidVoidExprArrow: 'Returning a void expression from an arrow function shorthand is forbidden. ' +\n                'Please add braces to the arrow function.',\n            invalidVoidExprArrowWrapVoid: 'Void expressions returned from an arrow function shorthand ' +\n                'must be marked explicitly with the `void` operator.',\n            invalidVoidExprReturn: 'Returning a void expression from a function is forbidden. ' +\n                'Please move it before the `return` statement.',\n            invalidVoidExprReturnLast: 'Returning a void expression from a function is forbidden. ' +\n                'Please remove the `return` statement.',\n            invalidVoidExprReturnWrapVoid: 'Void expressions returned from a function ' +\n                'must be marked explicitly with the `void` operator.',\n            invalidVoidExprWrapVoid: 'Void expressions used inside another expression ' +\n                'must be moved to its own statement ' +\n                'or marked explicitly with the `void` operator.',\n            voidExprWrapVoid: 'Mark with an explicit `void` operator.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ignoreArrowShorthand: {\n                        type: 'boolean',\n                        description: 'Whether to ignore \"shorthand\" `() =>` arrow functions: those without `{ ... }` braces.',\n                    },\n                    ignoreVoidOperator: {\n                        type: 'boolean',\n                        description: 'Whether to ignore returns that start with the `void` operator.',\n                    },\n                    ignoreVoidReturningFunctions: {\n                        type: 'boolean',\n                        description: 'Whether to ignore returns from functions with explicit `void` return types and functions with contextual `void` return types.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            ignoreArrowShorthand: false,\n            ignoreVoidOperator: false,\n            ignoreVoidReturningFunctions: false,\n        },\n    ],\n    create(context, [options]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        return {\n            'AwaitExpression, CallExpression, TaggedTemplateExpression'(node) {\n                const type = (0, util_1.getConstrainedTypeAtLocation)(services, node);\n                if (!tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike)) {\n                    // not a void expression\n                    return;\n                }\n                const invalidAncestor = findInvalidAncestor(node);\n                if (invalidAncestor == null) {\n                    // void expression is in valid position\n                    return;\n                }\n                const wrapVoidFix = (fixer) => {\n                    const nodeText = context.sourceCode.getText(node);\n                    const newNodeText = `void ${nodeText}`;\n                    return fixer.replaceText(node, newNodeText);\n                };\n                if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n                    // handle arrow function shorthand\n                    if (options.ignoreVoidReturningFunctions) {\n                        const returnsVoid = isVoidReturningFunctionNode(invalidAncestor);\n                        if (returnsVoid) {\n                            return;\n                        }\n                    }\n                    if (options.ignoreVoidOperator) {\n                        // handle wrapping with `void`\n                        return context.report({\n                            node,\n                            messageId: 'invalidVoidExprArrowWrapVoid',\n                            fix: wrapVoidFix,\n                        });\n                    }\n                    // handle wrapping with braces\n                    const arrowFunction = invalidAncestor;\n                    return context.report({\n                        node,\n                        messageId: 'invalidVoidExprArrow',\n                        fix(fixer) {\n                            if (!canFix(arrowFunction)) {\n                                return null;\n                            }\n                            const arrowBody = arrowFunction.body;\n                            const arrowBodyText = context.sourceCode.getText(arrowBody);\n                            const newArrowBodyText = `{ ${arrowBodyText}; }`;\n                            if ((0, util_1.isParenthesized)(arrowBody, context.sourceCode)) {\n                                const bodyOpeningParen = (0, util_1.nullThrows)(context.sourceCode.getTokenBefore(arrowBody, util_1.isOpeningParenToken), util_1.NullThrowsReasons.MissingToken('opening parenthesis', 'arrow body'));\n                                const bodyClosingParen = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(arrowBody, util_1.isClosingParenToken), util_1.NullThrowsReasons.MissingToken('closing parenthesis', 'arrow body'));\n                                return fixer.replaceTextRange([bodyOpeningParen.range[0], bodyClosingParen.range[1]], newArrowBodyText);\n                            }\n                            return fixer.replaceText(arrowBody, newArrowBodyText);\n                        },\n                    });\n                }\n                if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ReturnStatement) {\n                    // handle return statement\n                    if (options.ignoreVoidReturningFunctions) {\n                        const functionNode = (0, getParentFunctionNode_1.getParentFunctionNode)(invalidAncestor);\n                        if (functionNode) {\n                            const returnsVoid = isVoidReturningFunctionNode(functionNode);\n                            if (returnsVoid) {\n                                return;\n                            }\n                        }\n                    }\n                    if (options.ignoreVoidOperator) {\n                        // handle wrapping with `void`\n                        return context.report({\n                            node,\n                            messageId: 'invalidVoidExprReturnWrapVoid',\n                            fix: wrapVoidFix,\n                        });\n                    }\n                    if (isFinalReturn(invalidAncestor)) {\n                        // remove the `return` keyword\n                        return context.report({\n                            node,\n                            messageId: 'invalidVoidExprReturnLast',\n                            fix(fixer) {\n                                if (!canFix(invalidAncestor)) {\n                                    return null;\n                                }\n                                const returnValue = invalidAncestor.argument;\n                                const returnValueText = context.sourceCode.getText(returnValue);\n                                let newReturnStmtText = `${returnValueText};`;\n                                if (isPreventingASI(returnValue)) {\n                                    // put a semicolon at the beginning of the line\n                                    newReturnStmtText = `;${newReturnStmtText}`;\n                                }\n                                return fixer.replaceText(invalidAncestor, newReturnStmtText);\n                            },\n                        });\n                    }\n                    // move before the `return` keyword\n                    return context.report({\n                        node,\n                        messageId: 'invalidVoidExprReturn',\n                        fix(fixer) {\n                            const returnValue = invalidAncestor.argument;\n                            const returnValueText = context.sourceCode.getText(returnValue);\n                            let newReturnStmtText = `${returnValueText}; return;`;\n                            if (isPreventingASI(returnValue)) {\n                                // put a semicolon at the beginning of the line\n                                newReturnStmtText = `;${newReturnStmtText}`;\n                            }\n                            if (invalidAncestor.parent.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                                // e.g. `if (cond) return console.error();`\n                                // add braces if not inside a block\n                                newReturnStmtText = `{ ${newReturnStmtText} }`;\n                            }\n                            return fixer.replaceText(invalidAncestor, newReturnStmtText);\n                        },\n                    });\n                }\n                // handle generic case\n                if (options.ignoreVoidOperator) {\n                    // this would be reported by this rule btw. such irony\n                    return context.report({\n                        node,\n                        messageId: 'invalidVoidExprWrapVoid',\n                        suggest: [{ messageId: 'voidExprWrapVoid', fix: wrapVoidFix }],\n                    });\n                }\n                context.report({\n                    node,\n                    messageId: 'invalidVoidExpr',\n                });\n            },\n        };\n        /**\n         * Inspects the void expression's ancestors and finds closest invalid one.\n         * By default anything other than an ExpressionStatement is invalid.\n         * Parent expressions which can be used for their short-circuiting behavior\n         * are ignored and their parents are checked instead.\n         * @param node The void expression node to check.\n         * @returns Invalid ancestor node if it was found. `null` otherwise.\n         */\n        function findInvalidAncestor(node) {\n            const parent = (0, util_1.nullThrows)(node.parent, util_1.NullThrowsReasons.MissingParent);\n            if (parent.type === utils_1.AST_NODE_TYPES.SequenceExpression &&\n                node !== parent.expressions[parent.expressions.length - 1]) {\n                return null;\n            }\n            if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n                // e.g. `{ console.log(\"foo\"); }`\n                // this is always valid\n                return null;\n            }\n            if (parent.type === utils_1.AST_NODE_TYPES.LogicalExpression &&\n                parent.right === node) {\n                // e.g. `x && console.log(x)`\n                // this is valid only if the next ancestor is valid\n                return findInvalidAncestor(parent);\n            }\n            if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression &&\n                (parent.consequent === node || parent.alternate === node)) {\n                // e.g. `cond ? console.log(true) : console.log(false)`\n                // this is valid only if the next ancestor is valid\n                return findInvalidAncestor(parent);\n            }\n            if (parent.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression &&\n                // e.g. `() => console.log(\"foo\")`\n                // this is valid with an appropriate option\n                options.ignoreArrowShorthand) {\n                return null;\n            }\n            if (parent.type === utils_1.AST_NODE_TYPES.UnaryExpression &&\n                parent.operator === 'void' &&\n                // e.g. `void console.log(\"foo\")`\n                // this is valid with an appropriate option\n                options.ignoreVoidOperator) {\n                return null;\n            }\n            if (parent.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n                // e.g. `console?.log('foo')`\n                return findInvalidAncestor(parent);\n            }\n            // Any other parent is invalid.\n            // We can assume a return statement will have an argument.\n            return parent;\n        }\n        /** Checks whether the return statement is the last statement in a function body. */\n        function isFinalReturn(node) {\n            // the parent must be a block\n            const block = (0, util_1.nullThrows)(node.parent, util_1.NullThrowsReasons.MissingParent);\n            if (block.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                // e.g. `if (cond) return;` (not in a block)\n                return false;\n            }\n            // the block's parent must be a function\n            const blockParent = (0, util_1.nullThrows)(block.parent, util_1.NullThrowsReasons.MissingParent);\n            if (![\n                utils_1.AST_NODE_TYPES.ArrowFunctionExpression,\n                utils_1.AST_NODE_TYPES.FunctionDeclaration,\n                utils_1.AST_NODE_TYPES.FunctionExpression,\n            ].includes(blockParent.type)) {\n                // e.g. `if (cond) { return; }`\n                // not in a top-level function block\n                return false;\n            }\n            // must be the last child of the block\n            if (block.body.indexOf(node) < block.body.length - 1) {\n                // not the last statement in the block\n                return false;\n            }\n            return true;\n        }\n        /**\n         * Checks whether the given node, if placed on its own line,\n         * would prevent automatic semicolon insertion on the line before.\n         *\n         * This happens if the line begins with `(`, `[` or `` ` ``\n         */\n        function isPreventingASI(node) {\n            const startToken = (0, util_1.nullThrows)(context.sourceCode.getFirstToken(node), util_1.NullThrowsReasons.MissingToken('first token', node.type));\n            return ['(', '[', '`'].includes(startToken.value);\n        }\n        function canFix(node) {\n            const targetNode = node.type === utils_1.AST_NODE_TYPES.ReturnStatement\n                ? node.argument\n                : node.body;\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, targetNode);\n            return tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike);\n        }\n        function isFunctionReturnTypeIncludesVoid(functionType) {\n            const callSignatures = tsutils.getCallSignaturesOfType(functionType);\n            return callSignatures.some(signature => {\n                const returnType = signature.getReturnType();\n                return tsutils\n                    .unionTypeParts(returnType)\n                    .some(tsutils.isIntrinsicVoidType);\n            });\n        }\n        function isVoidReturningFunctionNode(functionNode) {\n            // Game plan:\n            //   - If the function node has a type annotation, check if it includes `void`.\n            //     - If it does then the function is safe to return `void` expressions in.\n            //   - Otherwise, check if the function is a function-expression or an arrow-function.\n            //   -   If it is, get its contextual type and bail if we cannot.\n            //   - Return based on whether the contextual type includes `void` or not\n            const functionTSNode = services.esTreeNodeToTSNodeMap.get(functionNode);\n            if (functionTSNode.type) {\n                const returnType = checker.getTypeFromTypeNode(functionTSNode.type);\n                return tsutils\n                    .unionTypeParts(returnType)\n                    .some(tsutils.isIntrinsicVoidType);\n            }\n            if (ts.isExpression(functionTSNode)) {\n                const functionType = checker.getContextualType(functionTSNode);\n                if (functionType) {\n                    return tsutils\n                        .unionTypeParts(functionType)\n                        .some(isFunctionReturnTypeIncludesVoid);\n                }\n            }\n            return false;\n        }\n    },\n});\n"
        }
    ]
}