{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/class-methods-use-this.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891959941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'class-methods-use-this',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce that class methods utilize `this`',\n            extendsBaseRule: true,\n            requiresTypeChecking: false,\n        },\n        messages: {\n            missingThis: \"Expected 'this' to be used by class {{name}}.\",\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    enforceForClassFields: {\n                        type: 'boolean',\n                        default: true,\n                        description: 'Enforces that functions used as instance field initializers utilize `this`.',\n                    },\n                    exceptMethods: {\n                        type: 'array',\n                        description: 'Allows specified method names to be ignored with this rule.',\n                        items: {\n                            type: 'string',\n                        },\n                    },\n                    ignoreClassesThatImplementAnInterface: {\n                        description: 'Whether to ignore class members that are defined within a class that `implements` a type.',\n                        oneOf: [\n                            {\n                                type: 'boolean',\n                                description: 'Ignore all classes that implement an interface',\n                            },\n                            {\n                                type: 'string',\n                                description: 'Ignore only the public fields of classes that implement an interface',\n                                enum: ['public-fields'],\n                            },\n                        ],\n                    },\n                    ignoreOverrideMethods: {\n                        type: 'boolean',\n                        description: 'Whether to ignore members marked with the `override` modifier.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            enforceForClassFields: true,\n            exceptMethods: [],\n            ignoreClassesThatImplementAnInterface: false,\n            ignoreOverrideMethods: false,\n        },\n    ],\n    create(context, [{ enforceForClassFields, exceptMethods: exceptMethodsRaw, ignoreClassesThatImplementAnInterface, ignoreOverrideMethods, },]) {\n        const exceptMethods = new Set(exceptMethodsRaw);\n        let stack;\n        function pushContext(member) {\n            if (member?.parent.type === utils_1.AST_NODE_TYPES.ClassBody) {\n                stack = {\n                    class: member.parent.parent,\n                    member,\n                    parent: stack,\n                    usesThis: false,\n                };\n            }\n            else {\n                stack = {\n                    class: null,\n                    member: null,\n                    parent: stack,\n                    usesThis: false,\n                };\n            }\n        }\n        function enterFunction(node) {\n            if (node.parent.type === utils_1.AST_NODE_TYPES.MethodDefinition ||\n                node.parent.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||\n                node.parent.type === utils_1.AST_NODE_TYPES.AccessorProperty) {\n                pushContext(node.parent);\n            }\n            else {\n                pushContext();\n            }\n        }\n        /**\n         * Pop `this` used flag from the stack.\n         */\n        function popContext() {\n            const oldStack = stack;\n            stack = stack?.parent;\n            return oldStack;\n        }\n        function isPublicField(accessibility) {\n            if (!accessibility || accessibility === 'public') {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Check if the node is an instance method not excluded by config\n         */\n        function isIncludedInstanceMethod(node) {\n            if (node.static ||\n                (node.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n                    node.kind === 'constructor') ||\n                ((node.type === utils_1.AST_NODE_TYPES.PropertyDefinition ||\n                    node.type === utils_1.AST_NODE_TYPES.AccessorProperty) &&\n                    !enforceForClassFields)) {\n                return false;\n            }\n            if (node.computed || exceptMethods.size === 0) {\n                return true;\n            }\n            const hashIfNeeded = node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier ? '#' : '';\n            const name = (0, util_1.getStaticMemberAccessValue)(node, context);\n            return (typeof name !== 'string' || !exceptMethods.has(hashIfNeeded + name));\n        }\n        /**\n         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.\n         * Static methods and the constructor are exempt.\n         * Then pops the context off the stack.\n         */\n        function exitFunction(node) {\n            const stackContext = popContext();\n            if (stackContext?.member == null ||\n                stackContext.usesThis ||\n                (ignoreOverrideMethods && stackContext.member.override) ||\n                (ignoreClassesThatImplementAnInterface === true &&\n                    stackContext.class.implements.length > 0) ||\n                (ignoreClassesThatImplementAnInterface === 'public-fields' &&\n                    stackContext.class.implements.length > 0 &&\n                    isPublicField(stackContext.member.accessibility))) {\n                return;\n            }\n            if (isIncludedInstanceMethod(stackContext.member)) {\n                context.report({\n                    loc: (0, util_1.getFunctionHeadLoc)(node, context.sourceCode),\n                    node,\n                    messageId: 'missingThis',\n                    data: {\n                        name: (0, util_1.getFunctionNameWithKind)(node),\n                    },\n                });\n            }\n        }\n        return {\n            // function declarations have their own `this` context\n            FunctionDeclaration() {\n                pushContext();\n            },\n            'FunctionDeclaration:exit'() {\n                popContext();\n            },\n            FunctionExpression(node) {\n                enterFunction(node);\n            },\n            'FunctionExpression:exit'(node) {\n                exitFunction(node);\n            },\n            ...(enforceForClassFields\n                ? {\n                    'AccessorProperty > ArrowFunctionExpression.value'(node) {\n                        enterFunction(node);\n                    },\n                    'AccessorProperty > ArrowFunctionExpression.value:exit'(node) {\n                        exitFunction(node);\n                    },\n                    'PropertyDefinition > ArrowFunctionExpression.value'(node) {\n                        enterFunction(node);\n                    },\n                    'PropertyDefinition > ArrowFunctionExpression.value:exit'(node) {\n                        exitFunction(node);\n                    },\n                }\n                : {}),\n            /*\n             * Class field value are implicit functions.\n             */\n            'AccessorProperty:exit'() {\n                popContext();\n            },\n            'AccessorProperty > *.key:exit'() {\n                pushContext();\n            },\n            'PropertyDefinition:exit'() {\n                popContext();\n            },\n            'PropertyDefinition > *.key:exit'() {\n                pushContext();\n            },\n            /*\n             * Class static blocks are implicit functions. They aren't required to use `this`,\n             * but we have to push context so that it captures any use of `this` in the static block\n             * separately from enclosing contexts, because static blocks have their own `this` and it\n             * shouldn't count as used `this` in enclosing contexts.\n             */\n            StaticBlock() {\n                pushContext();\n            },\n            'StaticBlock:exit'() {\n                popContext();\n            },\n            'ThisExpression, Super'() {\n                if (stack) {\n                    stack.usesThis = true;\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}