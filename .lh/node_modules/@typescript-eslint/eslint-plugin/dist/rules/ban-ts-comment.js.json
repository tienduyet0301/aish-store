{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/ban-ts-comment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891959605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst defaultMinimumDescriptionLength = 3;\nexports.default = (0, util_1.createRule)({\n    name: 'ban-ts-comment',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow `@ts-<directive>` comments or require descriptions after directives',\n            recommended: {\n                recommended: true,\n                strict: [{ minimumDescriptionLength: 10 }],\n            },\n        },\n        hasSuggestions: true,\n        messages: {\n            replaceTsIgnoreWithTsExpectError: 'Replace \"@ts-ignore\" with \"@ts-expect-error\".',\n            tsDirectiveComment: 'Do not use \"@ts-{{directive}}\" because it alters compilation errors.',\n            tsDirectiveCommentDescriptionNotMatchPattern: 'The description for the \"@ts-{{directive}}\" directive must match the {{format}} format.',\n            tsDirectiveCommentRequiresDescription: 'Include a description after the \"@ts-{{directive}}\" directive to explain why the @ts-{{directive}} is necessary. The description must be {{minimumDescriptionLength}} characters or longer.',\n            tsIgnoreInsteadOfExpectError: 'Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.',\n        },\n        schema: [\n            {\n                type: 'object',\n                $defs: {\n                    directiveConfigSchema: {\n                        oneOf: [\n                            {\n                                type: 'boolean',\n                                default: true,\n                            },\n                            {\n                                type: 'string',\n                                enum: ['allow-with-description'],\n                            },\n                            {\n                                type: 'object',\n                                additionalProperties: false,\n                                properties: {\n                                    descriptionFormat: { type: 'string' },\n                                },\n                            },\n                        ],\n                    },\n                },\n                additionalProperties: false,\n                properties: {\n                    minimumDescriptionLength: {\n                        type: 'number',\n                        default: defaultMinimumDescriptionLength,\n                        description: 'A minimum character length for descriptions when `allow-with-description` is enabled.',\n                    },\n                    'ts-check': { $ref: '#/items/0/$defs/directiveConfigSchema' },\n                    'ts-expect-error': { $ref: '#/items/0/$defs/directiveConfigSchema' },\n                    'ts-ignore': { $ref: '#/items/0/$defs/directiveConfigSchema' },\n                    'ts-nocheck': { $ref: '#/items/0/$defs/directiveConfigSchema' },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            minimumDescriptionLength: defaultMinimumDescriptionLength,\n            'ts-check': false,\n            'ts-expect-error': 'allow-with-description',\n            'ts-ignore': true,\n            'ts-nocheck': true,\n        },\n    ],\n    create(context, [options]) {\n        // https://github.com/microsoft/TypeScript/blob/6f1ad5ad8bec5671f7e951a3524b62d82ec4be68/src/compiler/parser.ts#L10591\n        const singleLinePragmaRegEx = /^\\/\\/\\/?\\s*@ts-(?<directive>check|nocheck)(?<description>.*)$/;\n        /*\n          The regex used are taken from the ones used in the official TypeScript repo -\n          https://github.com/microsoft/TypeScript/blob/6f1ad5ad8bec5671f7e951a3524b62d82ec4be68/src/compiler/scanner.ts#L340-L348\n        */\n        const commentDirectiveRegExSingleLine = /^\\/*\\s*@ts-(?<directive>expect-error|ignore)(?<description>.*)/;\n        const commentDirectiveRegExMultiLine = /^\\s*(?:\\/|\\*)*\\s*@ts-(?<directive>expect-error|ignore)(?<description>.*)/;\n        const descriptionFormats = new Map();\n        for (const directive of [\n            'ts-expect-error',\n            'ts-ignore',\n            'ts-nocheck',\n            'ts-check',\n        ]) {\n            const option = options[directive];\n            if (typeof option === 'object' && option.descriptionFormat) {\n                descriptionFormats.set(directive, new RegExp(option.descriptionFormat));\n            }\n        }\n        function execDirectiveRegEx(regex, str) {\n            const match = regex.exec(str);\n            if (!match) {\n                return null;\n            }\n            const { description, directive } = (0, util_1.nullThrows)(match.groups, 'RegExp should contain groups');\n            return {\n                description: (0, util_1.nullThrows)(description, 'RegExp should contain \"description\" group'),\n                directive: (0, util_1.nullThrows)(directive, 'RegExp should contain \"directive\" group'),\n            };\n        }\n        function findDirectiveInComment(comment) {\n            if (comment.type === utils_1.AST_TOKEN_TYPES.Line) {\n                const matchedPragma = execDirectiveRegEx(singleLinePragmaRegEx, `//${comment.value}`);\n                if (matchedPragma) {\n                    return matchedPragma;\n                }\n                return execDirectiveRegEx(commentDirectiveRegExSingleLine, comment.value);\n            }\n            const commentLines = comment.value.split('\\n');\n            return execDirectiveRegEx(commentDirectiveRegExMultiLine, commentLines[commentLines.length - 1]);\n        }\n        return {\n            Program(node) {\n                const firstStatement = node.body.at(0);\n                const comments = context.sourceCode.getAllComments();\n                comments.forEach(comment => {\n                    const match = findDirectiveInComment(comment);\n                    if (!match) {\n                        return;\n                    }\n                    const { description, directive } = match;\n                    if (directive === 'nocheck' &&\n                        firstStatement &&\n                        firstStatement.loc.start.line <= comment.loc.start.line) {\n                        return;\n                    }\n                    const fullDirective = `ts-${directive}`;\n                    const option = options[fullDirective];\n                    if (option === true) {\n                        if (directive === 'ignore') {\n                            // Special case to suggest @ts-expect-error instead of @ts-ignore\n                            context.report({\n                                node: comment,\n                                messageId: 'tsIgnoreInsteadOfExpectError',\n                                suggest: [\n                                    {\n                                        messageId: 'replaceTsIgnoreWithTsExpectError',\n                                        fix(fixer) {\n                                            const commentText = comment.value.replace(/@ts-ignore/, '@ts-expect-error');\n                                            return fixer.replaceText(comment, comment.type === utils_1.AST_TOKEN_TYPES.Line\n                                                ? `//${commentText}`\n                                                : `/*${commentText}*/`);\n                                        },\n                                    },\n                                ],\n                            });\n                        }\n                        else {\n                            context.report({\n                                node: comment,\n                                messageId: 'tsDirectiveComment',\n                                data: { directive },\n                            });\n                        }\n                    }\n                    if (option === 'allow-with-description' ||\n                        (typeof option === 'object' && option.descriptionFormat)) {\n                        const { minimumDescriptionLength } = options;\n                        const format = descriptionFormats.get(fullDirective);\n                        if ((0, util_1.getStringLength)(description.trim()) <\n                            (0, util_1.nullThrows)(minimumDescriptionLength, 'Expected minimumDescriptionLength to be set')) {\n                            context.report({\n                                node: comment,\n                                messageId: 'tsDirectiveCommentRequiresDescription',\n                                data: { directive, minimumDescriptionLength },\n                            });\n                        }\n                        else if (format && !format.test(description)) {\n                            context.report({\n                                node: comment,\n                                messageId: 'tsDirectiveCommentDescriptionNotMatchPattern',\n                                data: { directive, format: format.source },\n                            });\n                        }\n                    }\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}