{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-find.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972110,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-find',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce the use of Array.prototype.find() over Array.prototype.filter() followed by [0] when looking for a single result',\n            recommended: 'stylistic',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            preferFind: 'Prefer .find(...) instead of .filter(...)[0].',\n            preferFindSuggestion: 'Use .find(...) instead of .filter(...)[0].',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const globalScope = context.sourceCode.getScope(context.sourceCode.ast);\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function parseArrayFilterExpressions(expression) {\n            const node = (0, util_1.skipChainExpression)(expression);\n            if (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n                // Only the last expression in (a, b, [1, 2, 3].filter(condition))[0] matters\n                const lastExpression = (0, util_1.nullThrows)(node.expressions.at(-1), 'Expected to have more than zero expressions in a sequence expression');\n                return parseArrayFilterExpressions(lastExpression);\n            }\n            // This is the only reason we're returning a list rather than a single value.\n            if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n                // Both branches of the ternary _must_ return results.\n                const consequentResult = parseArrayFilterExpressions(node.consequent);\n                if (consequentResult.length === 0) {\n                    return [];\n                }\n                const alternateResult = parseArrayFilterExpressions(node.alternate);\n                if (alternateResult.length === 0) {\n                    return [];\n                }\n                // Accumulate the results from both sides and pass up the chain.\n                return [...consequentResult, ...alternateResult];\n            }\n            // Check if it looks like <<stuff>>(...), but not <<stuff>>?.(...)\n            if (node.type === utils_1.AST_NODE_TYPES.CallExpression && !node.optional) {\n                const callee = node.callee;\n                // Check if it looks like <<stuff>>.filter(...) or <<stuff>>['filter'](...),\n                // or the optional chaining variants.\n                if (callee.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n                    const isBracketSyntaxForFilter = callee.computed;\n                    if ((0, util_1.isStaticMemberAccessOfValue)(callee, context, 'filter')) {\n                        const filterNode = callee.property;\n                        const filteredObjectType = (0, util_1.getConstrainedTypeAtLocation)(services, callee.object);\n                        // As long as the object is a (possibly nullable) array,\n                        // this is an Array.prototype.filter expression.\n                        if (isArrayish(filteredObjectType)) {\n                            return [\n                                {\n                                    filterNode,\n                                    isBracketSyntaxForFilter,\n                                },\n                            ];\n                        }\n                    }\n                }\n            }\n            // not a filter expression.\n            return [];\n        }\n        /**\n         * Tells whether the type is a possibly nullable array/tuple or union thereof.\n         */\n        function isArrayish(type) {\n            let isAtLeastOneArrayishComponent = false;\n            for (const unionPart of tsutils.unionTypeParts(type)) {\n                if (tsutils.isIntrinsicNullType(unionPart) ||\n                    tsutils.isIntrinsicUndefinedType(unionPart)) {\n                    continue;\n                }\n                // apparently checker.isArrayType(T[] & S[]) => false.\n                // so we need to check the intersection parts individually.\n                const isArrayOrIntersectionThereof = tsutils\n                    .intersectionTypeParts(unionPart)\n                    .every(intersectionPart => checker.isArrayType(intersectionPart) ||\n                    checker.isTupleType(intersectionPart));\n                if (!isArrayOrIntersectionThereof) {\n                    // There is a non-array, non-nullish type component,\n                    // so it's not an array.\n                    return false;\n                }\n                isAtLeastOneArrayishComponent = true;\n            }\n            return isAtLeastOneArrayishComponent;\n        }\n        function getObjectIfArrayAtZeroExpression(node) {\n            // .at() should take exactly one argument.\n            if (node.arguments.length !== 1) {\n                return undefined;\n            }\n            const callee = node.callee;\n            if (callee.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                !callee.optional &&\n                (0, util_1.isStaticMemberAccessOfValue)(callee, context, 'at')) {\n                const atArgument = (0, util_1.getStaticValue)(node.arguments[0], globalScope);\n                if (atArgument != null && isTreatedAsZeroByArrayAt(atArgument.value)) {\n                    return callee.object;\n                }\n            }\n            return undefined;\n        }\n        /**\n         * Implements the algorithm for array indexing by `.at()` method.\n         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at#parameters\n         */\n        function isTreatedAsZeroByArrayAt(value) {\n            // This would cause the number constructor coercion to throw. Other static\n            // values are safe.\n            if (typeof value === 'symbol') {\n                return false;\n            }\n            const asNumber = Number(value);\n            if (isNaN(asNumber)) {\n                return true;\n            }\n            return Math.trunc(asNumber) === 0;\n        }\n        function isMemberAccessOfZero(node) {\n            const property = (0, util_1.getStaticValue)(node.property, globalScope);\n            // Check if it looks like <<stuff>>[0] or <<stuff>>['0'], but not <<stuff>>?.[0]\n            return (!node.optional &&\n                property != null &&\n                isTreatedAsZeroByMemberAccess(property.value));\n        }\n        /**\n         * Implements the algorithm for array indexing by member operator.\n         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array_indices\n         */\n        function isTreatedAsZeroByMemberAccess(value) {\n            return String(value) === '0';\n        }\n        function generateFixToRemoveArrayElementAccess(fixer, arrayNode, wholeExpressionBeingFlagged) {\n            const tokenToStartDeletingFrom = (0, util_1.nullThrows)(\n            // The next `.` or `[` is what we're looking for.\n            // think of (...).at(0) or (...)[0] or even (...)[\"at\"](0).\n            context.sourceCode.getTokenAfter(arrayNode, token => token.value === '.' || token.value === '['), 'Expected to find a member access token!');\n            return fixer.removeRange([\n                tokenToStartDeletingFrom.range[0],\n                wholeExpressionBeingFlagged.range[1],\n            ]);\n        }\n        function generateFixToReplaceFilterWithFind(fixer, filterExpression) {\n            return fixer.replaceText(filterExpression.filterNode, filterExpression.isBracketSyntaxForFilter ? '\"find\"' : 'find');\n        }\n        return {\n            // This query will be used to find things like `filteredResults.at(0)`.\n            CallExpression(node) {\n                const object = getObjectIfArrayAtZeroExpression(node);\n                if (object) {\n                    const filterExpressions = parseArrayFilterExpressions(object);\n                    if (filterExpressions.length !== 0) {\n                        context.report({\n                            node,\n                            messageId: 'preferFind',\n                            suggest: [\n                                {\n                                    messageId: 'preferFindSuggestion',\n                                    fix: (fixer) => {\n                                        return [\n                                            ...filterExpressions.map(filterExpression => generateFixToReplaceFilterWithFind(fixer, filterExpression)),\n                                            // Get rid of the .at(0) or ['at'](0).\n                                            generateFixToRemoveArrayElementAccess(fixer, object, node),\n                                        ];\n                                    },\n                                },\n                            ],\n                        });\n                    }\n                }\n            },\n            // This query will be used to find things like `filteredResults[0]`.\n            //\n            // Note: we're always looking for array member access to be \"computed\",\n            // i.e. `filteredResults[0]`, since `filteredResults.0` isn't a thing.\n            'MemberExpression[computed=true]'(node) {\n                if (isMemberAccessOfZero(node)) {\n                    const object = node.object;\n                    const filterExpressions = parseArrayFilterExpressions(object);\n                    if (filterExpressions.length !== 0) {\n                        context.report({\n                            node,\n                            messageId: 'preferFind',\n                            suggest: [\n                                {\n                                    messageId: 'preferFindSuggestion',\n                                    fix: (fixer) => {\n                                        return [\n                                            ...filterExpressions.map(filterExpression => generateFixToReplaceFilterWithFind(fixer, filterExpression)),\n                                            // Get rid of the [0].\n                                            generateFixToRemoveArrayElementAccess(fixer, object, node),\n                                        ];\n                                    },\n                                },\n                            ],\n                        });\n                    }\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}