{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-restricted-imports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891968294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ignore_1 = __importDefault(require(\"ignore\"));\nconst util_1 = require(\"../util\");\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-restricted-imports');\n// In some versions of eslint, the base rule has a completely incompatible schema\n// This helper function is to safely try to get parts of the schema. If it's not\n// possible, we'll fallback to less strict checks.\nconst tryAccess = (getter, fallback) => {\n    try {\n        return getter();\n    }\n    catch {\n        return fallback;\n    }\n};\nconst baseSchema = baseRule.meta.schema;\nconst allowTypeImportsOptionSchema = {\n    allowTypeImports: {\n        type: 'boolean',\n        description: 'Whether to allow type-only imports for a path.',\n    },\n};\nconst arrayOfStringsOrObjects = {\n    type: 'array',\n    items: {\n        anyOf: [\n            { type: 'string' },\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ...tryAccess(() => baseSchema.anyOf[1].items[0].properties.paths.items.anyOf[1]\n                        .properties, undefined),\n                    ...allowTypeImportsOptionSchema,\n                },\n                required: tryAccess(() => baseSchema.anyOf[1].items[0].properties.paths.items.anyOf[1]\n                    .required, undefined),\n            },\n        ],\n    },\n    uniqueItems: true,\n};\nconst arrayOfStringsOrObjectPatterns = {\n    anyOf: [\n        {\n            type: 'array',\n            items: {\n                type: 'string',\n            },\n            uniqueItems: true,\n        },\n        {\n            type: 'array',\n            items: {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ...tryAccess(() => baseSchema.anyOf[1].items[0].properties.patterns.anyOf[1].items\n                        .properties, undefined),\n                    ...allowTypeImportsOptionSchema,\n                },\n                required: tryAccess(() => baseSchema.anyOf[1].items[0].properties.patterns.anyOf[1].items\n                    .required, []),\n            },\n            uniqueItems: true,\n        },\n    ],\n};\nconst schema = {\n    anyOf: [\n        arrayOfStringsOrObjects,\n        {\n            type: 'array',\n            additionalItems: false,\n            items: [\n                {\n                    type: 'object',\n                    additionalProperties: false,\n                    properties: {\n                        paths: arrayOfStringsOrObjects,\n                        patterns: arrayOfStringsOrObjectPatterns,\n                    },\n                },\n            ],\n        },\n    ],\n};\nfunction isObjectOfPaths(obj) {\n    return !!obj && Object.hasOwn(obj, 'paths');\n}\nfunction isObjectOfPatterns(obj) {\n    return !!obj && Object.hasOwn(obj, 'patterns');\n}\nfunction isOptionsArrayOfStringOrObject(options) {\n    if (isObjectOfPaths(options[0])) {\n        return false;\n    }\n    if (isObjectOfPatterns(options[0])) {\n        return false;\n    }\n    return true;\n}\nfunction getRestrictedPaths(options) {\n    if (isOptionsArrayOfStringOrObject(options)) {\n        return options;\n    }\n    if (isObjectOfPaths(options[0])) {\n        return options[0].paths;\n    }\n    return [];\n}\nfunction getRestrictedPatterns(options) {\n    if (isObjectOfPatterns(options[0])) {\n        return options[0].patterns;\n    }\n    return [];\n}\nfunction shouldCreateRule(baseRules, options) {\n    if (Object.keys(baseRules).length === 0 || options.length === 0) {\n        return false;\n    }\n    if (!isOptionsArrayOfStringOrObject(options)) {\n        return !!(options[0].paths?.length || options[0].patterns?.length);\n    }\n    return true;\n}\nexports.default = (0, util_1.createRule)({\n    name: 'no-restricted-imports',\n    meta: {\n        type: 'suggestion',\n        // defaultOptions, -- base rule does not use defaultOptions\n        docs: {\n            description: 'Disallow specified modules when loaded by `import`',\n            extendsBaseRule: true,\n        },\n        fixable: baseRule.meta.fixable,\n        messages: baseRule.meta.messages,\n        schema,\n    },\n    defaultOptions: [],\n    create(context) {\n        const rules = baseRule.create(context);\n        const { options } = context;\n        if (!shouldCreateRule(rules, options)) {\n            return {};\n        }\n        const restrictedPaths = getRestrictedPaths(options);\n        const allowedTypeImportPathNameSet = new Set();\n        for (const restrictedPath of restrictedPaths) {\n            if (typeof restrictedPath === 'object' &&\n                restrictedPath.allowTypeImports) {\n                allowedTypeImportPathNameSet.add(restrictedPath.name);\n            }\n        }\n        function isAllowedTypeImportPath(importSource) {\n            return allowedTypeImportPathNameSet.has(importSource);\n        }\n        const restrictedPatterns = getRestrictedPatterns(options);\n        const allowedImportTypeMatchers = [];\n        const allowedImportTypeRegexMatchers = [];\n        for (const restrictedPattern of restrictedPatterns) {\n            if (typeof restrictedPattern === 'object' &&\n                restrictedPattern.allowTypeImports) {\n                // Following how ignore is configured in the base rule\n                if (restrictedPattern.group) {\n                    allowedImportTypeMatchers.push((0, ignore_1.default)({\n                        allowRelativePaths: true,\n                        ignoreCase: !restrictedPattern.caseSensitive,\n                    }).add(restrictedPattern.group));\n                }\n                if (restrictedPattern.regex) {\n                    allowedImportTypeRegexMatchers.push(new RegExp(restrictedPattern.regex, restrictedPattern.caseSensitive ? 'u' : 'iu'));\n                }\n            }\n        }\n        function isAllowedTypeImportPattern(importSource) {\n            return (\n            // As long as there's one matching pattern that allows type import\n            allowedImportTypeMatchers.some(matcher => matcher.ignores(importSource)) ||\n                allowedImportTypeRegexMatchers.some(regex => regex.test(importSource)));\n        }\n        function checkImportNode(node) {\n            if (node.importKind === 'type' ||\n                (node.specifiers.length > 0 &&\n                    node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier &&\n                        specifier.importKind === 'type'))) {\n                const importSource = node.source.value.trim();\n                if (!isAllowedTypeImportPath(importSource) &&\n                    !isAllowedTypeImportPattern(importSource)) {\n                    return rules.ImportDeclaration(node);\n                }\n            }\n            else {\n                return rules.ImportDeclaration(node);\n            }\n        }\n        return {\n            ExportAllDeclaration: rules.ExportAllDeclaration,\n            'ExportNamedDeclaration[source]'(node) {\n                if (node.exportKind === 'type' ||\n                    (node.specifiers.length > 0 &&\n                        node.specifiers.every(specifier => specifier.exportKind === 'type'))) {\n                    const importSource = node.source.value.trim();\n                    if (!isAllowedTypeImportPath(importSource) &&\n                        !isAllowedTypeImportPattern(importSource)) {\n                        return rules.ExportNamedDeclaration(node);\n                    }\n                }\n                else {\n                    return rules.ExportNamedDeclaration(node);\n                }\n            },\n            ImportDeclaration: checkImportNode,\n            TSImportEqualsDeclaration(node) {\n                if (node.moduleReference.type === utils_1.AST_NODE_TYPES.TSExternalModuleReference) {\n                    const synthesizedImport = {\n                        ...node,\n                        type: utils_1.AST_NODE_TYPES.ImportDeclaration,\n                        assertions: [],\n                        attributes: [],\n                        source: node.moduleReference.expression,\n                        specifiers: [\n                            {\n                                ...node.id,\n                                type: utils_1.AST_NODE_TYPES.ImportDefaultSpecifier,\n                                local: node.id,\n                                // @ts-expect-error -- parent types are incompatible but it's fine for the purposes of this extension\n                                parent: node.id.parent,\n                            },\n                        ],\n                    };\n                    return checkImportNode(synthesizedImport);\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}