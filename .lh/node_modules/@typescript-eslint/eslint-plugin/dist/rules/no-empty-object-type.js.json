{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-empty-object-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891964428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst noEmptyMessage = (emptyType) => [\n    `${emptyType} allows any non-nullish value, including literals like \\`0\\` and \\`\"\"\\`.`,\n    \"- If that's what you want, disable this lint rule with an inline comment or configure the '{{ option }}' rule option.\",\n    '- If you want a type meaning \"any object\", you probably want `object` instead.',\n    '- If you want a type meaning \"any value\", you probably want `unknown` instead.',\n].join('\\n');\nexports.default = (0, util_1.createRule)({\n    name: 'no-empty-object-type',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Disallow accidentally using the \"empty object\" type',\n            recommended: 'recommended',\n        },\n        hasSuggestions: true,\n        messages: {\n            noEmptyInterface: noEmptyMessage('An empty interface declaration'),\n            noEmptyInterfaceWithSuper: 'An interface declaring no members is equivalent to its supertype.',\n            noEmptyObject: noEmptyMessage('The `{}` (\"empty object\") type'),\n            replaceEmptyInterface: 'Replace empty interface with `{{replacement}}`.',\n            replaceEmptyInterfaceWithSuper: 'Replace empty interface with a type alias.',\n            replaceEmptyObjectType: 'Replace `{}` with `{{replacement}}`.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowInterfaces: {\n                        type: 'string',\n                        description: 'Whether to allow empty interfaces.',\n                        enum: ['always', 'never', 'with-single-extends'],\n                    },\n                    allowObjectTypes: {\n                        type: 'string',\n                        description: 'Whether to allow empty object type literals.',\n                        enum: ['always', 'never'],\n                    },\n                    allowWithName: {\n                        type: 'string',\n                        description: 'A stringified regular expression to allow interfaces and object type aliases with the configured name.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowInterfaces: 'never',\n            allowObjectTypes: 'never',\n        },\n    ],\n    create(context, [{ allowInterfaces, allowObjectTypes, allowWithName }]) {\n        const allowWithNameTester = allowWithName\n            ? new RegExp(allowWithName, 'u')\n            : undefined;\n        return {\n            ...(allowInterfaces !== 'always' && {\n                TSInterfaceDeclaration(node) {\n                    if (allowWithNameTester?.test(node.id.name)) {\n                        return;\n                    }\n                    const extend = node.extends;\n                    if (node.body.body.length !== 0 ||\n                        (extend.length === 1 &&\n                            allowInterfaces === 'with-single-extends') ||\n                        extend.length > 1) {\n                        return;\n                    }\n                    const scope = context.sourceCode.getScope(node);\n                    const mergedWithClassDeclaration = scope.set\n                        .get(node.id.name)\n                        ?.defs.some(def => def.node.type === utils_1.AST_NODE_TYPES.ClassDeclaration);\n                    if (extend.length === 0) {\n                        context.report({\n                            node: node.id,\n                            messageId: 'noEmptyInterface',\n                            data: { option: 'allowInterfaces' },\n                            ...(!mergedWithClassDeclaration && {\n                                suggest: ['object', 'unknown'].map(replacement => ({\n                                    messageId: 'replaceEmptyInterface',\n                                    data: { replacement },\n                                    fix(fixer) {\n                                        const id = context.sourceCode.getText(node.id);\n                                        const typeParam = node.typeParameters\n                                            ? context.sourceCode.getText(node.typeParameters)\n                                            : '';\n                                        return fixer.replaceText(node, `type ${id}${typeParam} = ${replacement}`);\n                                    },\n                                })),\n                            }),\n                        });\n                        return;\n                    }\n                    context.report({\n                        node: node.id,\n                        messageId: 'noEmptyInterfaceWithSuper',\n                        ...(!mergedWithClassDeclaration && {\n                            suggest: [\n                                {\n                                    messageId: 'replaceEmptyInterfaceWithSuper',\n                                    fix(fixer) {\n                                        const extended = context.sourceCode.getText(extend[0]);\n                                        const id = context.sourceCode.getText(node.id);\n                                        const typeParam = node.typeParameters\n                                            ? context.sourceCode.getText(node.typeParameters)\n                                            : '';\n                                        return fixer.replaceText(node, `type ${id}${typeParam} = ${extended}`);\n                                    },\n                                },\n                            ],\n                        }),\n                    });\n                },\n            }),\n            ...(allowObjectTypes !== 'always' && {\n                TSTypeLiteral(node) {\n                    if (node.members.length ||\n                        node.parent.type === utils_1.AST_NODE_TYPES.TSIntersectionType ||\n                        (allowWithNameTester &&\n                            node.parent.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration &&\n                            allowWithNameTester.test(node.parent.id.name))) {\n                        return;\n                    }\n                    context.report({\n                        node,\n                        messageId: 'noEmptyObject',\n                        data: { option: 'allowObjectTypes' },\n                        suggest: ['object', 'unknown'].map(replacement => ({\n                            messageId: 'replaceEmptyObjectType',\n                            data: { replacement },\n                            fix: (fixer) => fixer.replaceText(node, replacement),\n                        })),\n                    });\n                },\n            }),\n        };\n    },\n});\n"
        }
    ]
}