{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/restrict-template-expressions.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst type_utils_1 = require(\"@typescript-eslint/type-utils\");\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst typescript_1 = require(\"typescript\");\nconst util_1 = require(\"../util\");\nconst testTypeFlag = (flagsToCheck) => type => (0, util_1.isTypeFlagSet)(type, flagsToCheck);\nconst optionTesters = [\n    ['Any', util_1.isTypeAnyType],\n    [\n        'Array',\n        (type, checker, recursivelyCheckType) => (checker.isArrayType(type) || checker.isTupleType(type)) &&\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            recursivelyCheckType(type.getNumberIndexType()),\n    ],\n    // eslint-disable-next-line @typescript-eslint/internal/prefer-ast-types-enum\n    ['Boolean', testTypeFlag(typescript_1.TypeFlags.BooleanLike)],\n    ['Nullish', testTypeFlag(typescript_1.TypeFlags.Null | typescript_1.TypeFlags.Undefined)],\n    ['Number', testTypeFlag(typescript_1.TypeFlags.NumberLike | typescript_1.TypeFlags.BigIntLike)],\n    [\n        'RegExp',\n        (type, checker) => (0, util_1.getTypeName)(checker, type) === 'RegExp',\n    ],\n    ['Never', util_1.isTypeNeverType],\n].map(([type, tester]) => ({\n    type,\n    option: `allow${type}`,\n    tester,\n}));\nexports.default = (0, util_1.createRule)({\n    name: 'restrict-template-expressions',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Enforce template literal expressions to be of `string` type',\n            recommended: {\n                recommended: true,\n                strict: [\n                    {\n                        allowAny: false,\n                        allowBoolean: false,\n                        allowNever: false,\n                        allowNullish: false,\n                        allowNumber: false,\n                        allowRegExp: false,\n                    },\n                ],\n            },\n            requiresTypeChecking: true,\n        },\n        messages: {\n            invalidType: 'Invalid type \"{{type}}\" of template literal expression.',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    ...Object.fromEntries(optionTesters.map(({ type, option }) => [\n                        option,\n                        {\n                            type: 'boolean',\n                            description: `Whether to allow \\`${type.toLowerCase()}\\` typed values in template expressions.`,\n                        },\n                    ])),\n                    allow: {\n                        description: `Types to allow in template expressions.`,\n                        ...type_utils_1.typeOrValueSpecifiersSchema,\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allow: [{ name: ['Error', 'URL', 'URLSearchParams'], from: 'lib' }],\n            allowAny: true,\n            allowBoolean: true,\n            allowNullish: true,\n            allowNumber: true,\n            allowRegExp: true,\n        },\n    ],\n    create(context, [{ allow, ...options }]) {\n        const services = (0, util_1.getParserServices)(context);\n        const { program } = services;\n        const checker = program.getTypeChecker();\n        const enabledOptionTesters = optionTesters.filter(({ option }) => options[option]);\n        return {\n            TemplateLiteral(node) {\n                // don't check tagged template literals\n                if (node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {\n                    return;\n                }\n                for (const expression of node.expressions) {\n                    const expressionType = (0, util_1.getConstrainedTypeAtLocation)(services, expression);\n                    if (!recursivelyCheckType(expressionType)) {\n                        context.report({\n                            node: expression,\n                            messageId: 'invalidType',\n                            data: { type: checker.typeToString(expressionType) },\n                        });\n                    }\n                }\n            },\n        };\n        function recursivelyCheckType(innerType) {\n            if (innerType.isUnion()) {\n                return innerType.types.every(recursivelyCheckType);\n            }\n            if (innerType.isIntersection()) {\n                return innerType.types.some(recursivelyCheckType);\n            }\n            return ((0, util_1.isTypeFlagSet)(innerType, typescript_1.TypeFlags.StringLike) ||\n                (0, type_utils_1.typeMatchesSomeSpecifier)(innerType, allow, program) ||\n                enabledOptionTesters.some(({ tester }) => tester(innerType, checker, recursivelyCheckType)));\n        }\n    },\n});\n"
        }
    ]
}