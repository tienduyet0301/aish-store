{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-literal-enum-member.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-literal-enum-member',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require all enum members to be literal values',\n            recommended: 'strict',\n            requiresTypeChecking: false,\n        },\n        messages: {\n            notLiteral: `Explicit enum value must only be a literal value (string or number).`,\n            notLiteralOrBitwiseExpression: `Explicit enum value must only be a literal value (string or number) or a bitwise expression.`,\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowBitwiseExpressions: {\n                        type: 'boolean',\n                        description: 'Whether to allow using bitwise expressions in enum initializers.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowBitwiseExpressions: false,\n        },\n    ],\n    create(context, [{ allowBitwiseExpressions }]) {\n        function isIdentifierWithName(node, name) {\n            return node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === name;\n        }\n        function hasEnumMember(decl, name) {\n            return decl.body.members.some(member => isIdentifierWithName(member.id, name) ||\n                (member.id.type === utils_1.AST_NODE_TYPES.Literal &&\n                    (0, util_1.getStaticStringValue)(member.id) === name));\n        }\n        function isSelfEnumMember(decl, node) {\n            if (node.type === utils_1.AST_NODE_TYPES.Identifier) {\n                return hasEnumMember(decl, node.name);\n            }\n            if (node.type === utils_1.AST_NODE_TYPES.MemberExpression &&\n                isIdentifierWithName(node.object, decl.id.name)) {\n                if (node.property.type === utils_1.AST_NODE_TYPES.Identifier) {\n                    return hasEnumMember(decl, node.property.name);\n                }\n                if (node.computed) {\n                    const propertyName = (0, util_1.getStaticStringValue)(node.property);\n                    if (propertyName) {\n                        return hasEnumMember(decl, propertyName);\n                    }\n                }\n            }\n            return false;\n        }\n        return {\n            TSEnumMember(node) {\n                // If there is no initializer, then this node is just the name of the member, so ignore.\n                if (node.initializer == null) {\n                    return;\n                }\n                const declaration = node.parent.parent;\n                function isAllowedInitializerExpressionRecursive(node, partOfBitwiseComputation) {\n                    // You can only refer to an enum member if it's part of a bitwise computation.\n                    // so C = B isn't allowed (special case), but C = A | B is.\n                    if (partOfBitwiseComputation && isSelfEnumMember(declaration, node)) {\n                        return true;\n                    }\n                    switch (node.type) {\n                        // any old literal\n                        case utils_1.AST_NODE_TYPES.Literal:\n                            return true;\n                        // TemplateLiteral without expressions\n                        case utils_1.AST_NODE_TYPES.TemplateLiteral:\n                            return node.expressions.length === 0;\n                        case utils_1.AST_NODE_TYPES.UnaryExpression:\n                            // +123, -123, etc.\n                            if (['-', '+'].includes(node.operator)) {\n                                return isAllowedInitializerExpressionRecursive(node.argument, partOfBitwiseComputation);\n                            }\n                            if (allowBitwiseExpressions) {\n                                return (node.operator === '~' &&\n                                    isAllowedInitializerExpressionRecursive(node.argument, true));\n                            }\n                            return false;\n                        case utils_1.AST_NODE_TYPES.BinaryExpression:\n                            if (allowBitwiseExpressions) {\n                                return (['&', '^', '<<', '>>', '>>>', '|'].includes(node.operator) &&\n                                    isAllowedInitializerExpressionRecursive(node.left, true) &&\n                                    isAllowedInitializerExpressionRecursive(node.right, true));\n                            }\n                            return false;\n                        default:\n                            return false;\n                    }\n                }\n                if (isAllowedInitializerExpressionRecursive(node.initializer, false)) {\n                    return;\n                }\n                context.report({\n                    node: node.id,\n                    messageId: allowBitwiseExpressions\n                        ? 'notLiteralOrBitwiseExpression'\n                        : 'notLiteral',\n                });\n            },\n        };\n    },\n});\n"
        }
    ]
}