{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-var-requires.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891971276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-var-requires',\n    meta: {\n        type: 'problem',\n        deprecated: true,\n        docs: {\n            description: 'Disallow `require` statements except in import statements',\n        },\n        messages: {\n            noVarReqs: 'Require statement not part of import statement.',\n        },\n        replacedBy: ['@typescript-eslint/no-require-imports'],\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allow: {\n                        type: 'array',\n                        description: 'Patterns of import paths to allow requiring from.',\n                        items: { type: 'string' },\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [{ allow: [] }],\n    create(context, options) {\n        const allowPatterns = options[0].allow.map(pattern => new RegExp(pattern, 'u'));\n        function isImportPathAllowed(importPath) {\n            return allowPatterns.some(pattern => importPath.match(pattern));\n        }\n        function isStringOrTemplateLiteral(node) {\n            return ((node.type === utils_1.AST_NODE_TYPES.Literal &&\n                typeof node.value === 'string') ||\n                node.type === utils_1.AST_NODE_TYPES.TemplateLiteral);\n        }\n        return {\n            'CallExpression[callee.name=\"require\"]'(node) {\n                if (node.arguments[0] && isStringOrTemplateLiteral(node.arguments[0])) {\n                    const argValue = (0, util_1.getStaticStringValue)(node.arguments[0]);\n                    if (typeof argValue === 'string' && isImportPathAllowed(argValue)) {\n                        return;\n                    }\n                }\n                const parent = node.parent.type === utils_1.AST_NODE_TYPES.ChainExpression\n                    ? node.parent.parent\n                    : node.parent;\n                if ([\n                    utils_1.AST_NODE_TYPES.CallExpression,\n                    utils_1.AST_NODE_TYPES.MemberExpression,\n                    utils_1.AST_NODE_TYPES.NewExpression,\n                    utils_1.AST_NODE_TYPES.TSAsExpression,\n                    utils_1.AST_NODE_TYPES.TSTypeAssertion,\n                    utils_1.AST_NODE_TYPES.VariableDeclarator,\n                ].includes(parent.type)) {\n                    const variable = utils_1.ASTUtils.findVariable(context.sourceCode.getScope(node), 'require');\n                    if (!variable?.identifiers.length) {\n                        context.report({\n                            node,\n                            messageId: 'noVarReqs',\n                        });\n                    }\n                }\n            },\n        };\n    },\n});\n"
        }
    ]
}