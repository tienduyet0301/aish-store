{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-misused-spread.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891966939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'no-misused-spread',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow using the spread operator when it might cause unexpected behavior',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            addAwait: 'Add await operator.',\n            noArraySpreadInObject: 'Using the spread operator on an array in an object will result in a list of indices.',\n            noClassDeclarationSpreadInObject: 'Using the spread operator on class declarations will spread only their static properties, and will lose their class prototype.',\n            noClassInstanceSpreadInObject: 'Using the spread operator on class instances will lose their class prototype.',\n            noFunctionSpreadInObject: 'Using the spread operator on a function without additional properties can cause unexpected behavior. Did you forget to call the function?',\n            noIterableSpreadInObject: 'Using the spread operator on an Iterable in an object can cause unexpected behavior.',\n            noMapSpreadInObject: 'Using the spread operator on a Map in an object will result in an empty object. Did you mean to use `Object.fromEntries(map)` instead?',\n            noPromiseSpreadInObject: 'Using the spread operator on Promise in an object can cause unexpected behavior. Did you forget to await the promise?',\n            noStringSpread: [\n                'Using the spread operator on a string can mishandle special characters, as can `.split(\"\")`.',\n                '- `...` produces Unicode code points, which will decompose complex emojis into individual emojis',\n                '- .split(\"\") produces UTF-16 code units, which breaks rich characters in many languages',\n                'Consider using `Intl.Segmenter` for locale-aware string decomposition.',\n                \"Otherwise, if you don't need to preserve emojis or other non-Ascii characters, disable this lint rule on this line or configure the 'allow' rule option.\",\n            ].join('\\n'),\n            replaceMapSpreadInObject: 'Replace map spread in object with `Object.fromEntries()`',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allow: {\n                        ...util_1.readonlynessOptionsSchema.properties.allow,\n                        description: 'An array of type specifiers that are known to be safe to spread.',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allow: [],\n        },\n    ],\n    create(context, [options]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function checkArrayOrCallSpread(node) {\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node.argument);\n            if (!(0, util_1.typeMatchesSomeSpecifier)(type, options.allow, services.program) &&\n                isString(type)) {\n                context.report({\n                    node,\n                    messageId: 'noStringSpread',\n                });\n            }\n        }\n        function getMapSpreadSuggestions(node, type) {\n            const types = tsutils.unionTypeParts(type);\n            if (types.some(t => !isMap(services.program, t))) {\n                return null;\n            }\n            if (node.parent.type === utils_1.AST_NODE_TYPES.ObjectExpression &&\n                node.parent.properties.length === 1) {\n                return [\n                    {\n                        messageId: 'replaceMapSpreadInObject',\n                        fix: (0, util_1.getWrappingFixer)({\n                            node: node.parent,\n                            innerNode: node.argument,\n                            sourceCode: context.sourceCode,\n                            wrap: code => `Object.fromEntries(${code})`,\n                        }),\n                    },\n                ];\n            }\n            return [\n                {\n                    messageId: 'replaceMapSpreadInObject',\n                    fix: (0, util_1.getWrappingFixer)({\n                        node: node.argument,\n                        sourceCode: context.sourceCode,\n                        wrap: code => `Object.fromEntries(${code})`,\n                    }),\n                },\n            ];\n        }\n        function getPromiseSpreadSuggestions(node) {\n            const isHighPrecendence = (0, util_1.isHigherPrecedenceThanAwait)(services.esTreeNodeToTSNodeMap.get(node));\n            return [\n                {\n                    messageId: 'addAwait',\n                    fix: fixer => isHighPrecendence\n                        ? fixer.insertTextBefore(node, 'await ')\n                        : [\n                            fixer.insertTextBefore(node, 'await ('),\n                            fixer.insertTextAfter(node, ')'),\n                        ],\n                },\n            ];\n        }\n        function checkObjectSpread(node) {\n            const type = (0, util_1.getConstrainedTypeAtLocation)(services, node.argument);\n            if ((0, util_1.typeMatchesSomeSpecifier)(type, options.allow, services.program)) {\n                return;\n            }\n            if (isPromise(services.program, type)) {\n                context.report({\n                    node,\n                    messageId: 'noPromiseSpreadInObject',\n                    suggest: getPromiseSpreadSuggestions(node.argument),\n                });\n                return;\n            }\n            if (isFunctionWithoutProps(type)) {\n                context.report({\n                    node,\n                    messageId: 'noFunctionSpreadInObject',\n                });\n                return;\n            }\n            if (isMap(services.program, type)) {\n                context.report({\n                    node,\n                    messageId: 'noMapSpreadInObject',\n                    suggest: getMapSpreadSuggestions(node, type),\n                });\n                return;\n            }\n            if (isArray(checker, type)) {\n                context.report({\n                    node,\n                    messageId: 'noArraySpreadInObject',\n                });\n                return;\n            }\n            if (isIterable(type, checker) &&\n                // Don't report when the type is string, since TS will flag it already\n                !isString(type)) {\n                context.report({\n                    node,\n                    messageId: 'noIterableSpreadInObject',\n                });\n                return;\n            }\n            if (isClassInstance(checker, type)) {\n                context.report({\n                    node,\n                    messageId: 'noClassInstanceSpreadInObject',\n                });\n                return;\n            }\n            if (isClassDeclaration(type)) {\n                context.report({\n                    node,\n                    messageId: 'noClassDeclarationSpreadInObject',\n                });\n            }\n        }\n        return {\n            'ArrayExpression > SpreadElement': checkArrayOrCallSpread,\n            'CallExpression > SpreadElement': checkArrayOrCallSpread,\n            JSXSpreadAttribute: checkObjectSpread,\n            'ObjectExpression > SpreadElement': checkObjectSpread,\n        };\n    },\n});\nfunction isIterable(type, checker) {\n    return tsutils\n        .typeParts(type)\n        .some(t => !!tsutils.getWellKnownSymbolPropertyOfType(t, 'iterator', checker));\n}\nfunction isArray(checker, type) {\n    return isTypeRecurser(type, t => checker.isArrayType(t) || checker.isTupleType(t));\n}\nfunction isString(type) {\n    return isTypeRecurser(type, t => (0, util_1.isTypeFlagSet)(t, ts.TypeFlags.StringLike));\n}\nfunction isFunctionWithoutProps(type) {\n    return isTypeRecurser(type, t => t.getCallSignatures().length > 0 && t.getProperties().length === 0);\n}\nfunction isPromise(program, type) {\n    return isTypeRecurser(type, t => (0, util_1.isPromiseLike)(program, t));\n}\nfunction isClassInstance(checker, type) {\n    return isTypeRecurser(type, t => {\n        // If the type itself has a construct signature, it's a class(-like)\n        if (t.getConstructSignatures().length) {\n            return false;\n        }\n        const symbol = t.getSymbol();\n        // If the type's symbol has a construct signature, the type is an instance\n        return !!symbol\n            ?.getDeclarations()\n            ?.some(declaration => checker\n            .getTypeOfSymbolAtLocation(symbol, declaration)\n            .getConstructSignatures().length);\n    });\n}\nfunction isClassDeclaration(type) {\n    return isTypeRecurser(type, t => {\n        if (tsutils.isObjectType(t) &&\n            tsutils.isObjectFlagSet(t, ts.ObjectFlags.InstantiationExpressionType)) {\n            return true;\n        }\n        const kind = t.getSymbol()?.valueDeclaration?.kind;\n        return (kind === ts.SyntaxKind.ClassDeclaration ||\n            kind === ts.SyntaxKind.ClassExpression);\n    });\n}\nfunction isMap(program, type) {\n    return isTypeRecurser(type, t => (0, util_1.isBuiltinSymbolLike)(program, t, ['Map', 'ReadonlyMap', 'WeakMap']));\n}\nfunction isTypeRecurser(type, predicate) {\n    if (type.isUnionOrIntersection()) {\n        return type.types.some(t => isTypeRecurser(t, predicate));\n    }\n    return predicate(type);\n}\n"
        }
    ]
}