{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-function-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891972323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.phrases = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nexports.phrases = {\n    [utils_1.AST_NODE_TYPES.TSInterfaceDeclaration]: 'Interface',\n    [utils_1.AST_NODE_TYPES.TSTypeLiteral]: 'Type literal',\n};\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-function-type',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce using function types instead of interfaces with call signatures',\n            recommended: 'stylistic',\n        },\n        fixable: 'code',\n        messages: {\n            functionTypeOverCallableType: '{{ literalOrInterface }} only has a call signature, you should use a function type instead.',\n            unexpectedThisOnFunctionOnlyInterface: \"`this` refers to the function type '{{ interfaceName }}', did you intend to use a generic `this` parameter like `<Self>(this: Self, ...) => Self` instead?\",\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        /**\n         * Checks if there the interface has exactly one supertype that isn't named 'Function'\n         * @param node The node being checked\n         */\n        function hasOneSupertype(node) {\n            if (node.extends.length === 0) {\n                return false;\n            }\n            if (node.extends.length !== 1) {\n                return true;\n            }\n            const expr = node.extends[0].expression;\n            return (expr.type !== utils_1.AST_NODE_TYPES.Identifier || expr.name !== 'Function');\n        }\n        /**\n         * @param parent The parent of the call signature causing the diagnostic\n         */\n        function shouldWrapSuggestion(parent) {\n            if (!parent) {\n                return false;\n            }\n            switch (parent.type) {\n                case utils_1.AST_NODE_TYPES.TSUnionType:\n                case utils_1.AST_NODE_TYPES.TSIntersectionType:\n                case utils_1.AST_NODE_TYPES.TSArrayType:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        /**\n         * @param member The TypeElement being checked\n         * @param node The parent of member being checked\n         */\n        function checkMember(member, node, tsThisTypes = null) {\n            if ((member.type === utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration ||\n                member.type === utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration) &&\n                member.returnType != null) {\n                if (tsThisTypes?.length &&\n                    node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {\n                    // the message can be confusing if we don't point directly to the `this` node instead of the whole member\n                    // and in favour of generating at most one error we'll only report the first occurrence of `this` if there are multiple\n                    context.report({\n                        node: tsThisTypes[0],\n                        messageId: 'unexpectedThisOnFunctionOnlyInterface',\n                        data: {\n                            interfaceName: node.id.name,\n                        },\n                    });\n                    return;\n                }\n                const fixable = node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration;\n                const fix = fixable\n                    ? null\n                    : (fixer) => {\n                        const fixes = [];\n                        const start = member.range[0];\n                        // https://github.com/microsoft/TypeScript/pull/56908\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        const colonPos = member.returnType.range[0] - start;\n                        const text = context.sourceCode\n                            .getText()\n                            .slice(start, member.range[1]);\n                        const comments = [\n                            ...context.sourceCode.getCommentsBefore(member),\n                            ...context.sourceCode.getCommentsAfter(member),\n                        ];\n                        let suggestion = `${text.slice(0, colonPos)} =>${text.slice(colonPos + 1)}`;\n                        const lastChar = suggestion.endsWith(';') ? ';' : '';\n                        if (lastChar) {\n                            suggestion = suggestion.slice(0, -1);\n                        }\n                        if (shouldWrapSuggestion(node.parent)) {\n                            suggestion = `(${suggestion})`;\n                        }\n                        if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration) {\n                            if (node.typeParameters != null) {\n                                suggestion = `type ${context.sourceCode\n                                    .getText()\n                                    .slice(node.id.range[0], node.typeParameters.range[1])} = ${suggestion}${lastChar}`;\n                            }\n                            else {\n                                suggestion = `type ${node.id.name} = ${suggestion}${lastChar}`;\n                            }\n                        }\n                        const isParentExported = node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration;\n                        if (node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration &&\n                            isParentExported) {\n                            const commentsText = comments\n                                .map(({ type, value }) => type === utils_1.AST_TOKEN_TYPES.Line\n                                ? `//${value}\\n`\n                                : `/*${value}*/\\n`)\n                                .join('');\n                            // comments should move before export and not between export and interface declaration\n                            fixes.push(fixer.insertTextBefore(node.parent, commentsText));\n                        }\n                        else {\n                            comments.forEach(comment => {\n                                let commentText = comment.type === utils_1.AST_TOKEN_TYPES.Line\n                                    ? `//${comment.value}`\n                                    : `/*${comment.value}*/`;\n                                const isCommentOnTheSameLine = comment.loc.start.line === member.loc.start.line;\n                                if (!isCommentOnTheSameLine) {\n                                    commentText += '\\n';\n                                }\n                                else {\n                                    commentText += ' ';\n                                }\n                                suggestion = commentText + suggestion;\n                            });\n                        }\n                        const fixStart = node.range[0];\n                        fixes.push(fixer.replaceTextRange([fixStart, node.range[1]], suggestion));\n                        return fixes;\n                    };\n                context.report({\n                    node: member,\n                    messageId: 'functionTypeOverCallableType',\n                    data: {\n                        literalOrInterface: exports.phrases[node.type],\n                    },\n                    fix,\n                });\n            }\n        }\n        let tsThisTypes = null;\n        let literalNesting = 0;\n        return {\n            TSInterfaceDeclaration() {\n                // when entering an interface reset the count of `this`s to empty.\n                tsThisTypes = [];\n            },\n            'TSInterfaceDeclaration:exit'(node) {\n                if (!hasOneSupertype(node) && node.body.body.length === 1) {\n                    checkMember(node.body.body[0], node, tsThisTypes);\n                }\n                // on exit check member and reset the array to nothing.\n                tsThisTypes = null;\n            },\n            'TSInterfaceDeclaration TSThisType'(node) {\n                // inside an interface keep track of all ThisType references.\n                // unless it's inside a nested type literal in which case it's invalid code anyway\n                // we don't want to incorrectly say \"it refers to name\" while typescript says it's completely invalid.\n                if (literalNesting === 0 && tsThisTypes != null) {\n                    tsThisTypes.push(node);\n                }\n            },\n            // keep track of nested literals to avoid complaining about invalid `this` uses\n            'TSInterfaceDeclaration TSTypeLiteral'() {\n                literalNesting += 1;\n            },\n            'TSInterfaceDeclaration TSTypeLiteral:exit'() {\n                literalNesting -= 1;\n            },\n            'TSTypeLiteral[members.length = 1]'(node) {\n                checkMember(node.members[0], node);\n            },\n        };\n    },\n});\n"
        }
    ]
}