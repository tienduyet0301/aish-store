{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/switch-exhaustiveness-check.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891975456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nconst DEFAULT_COMMENT_PATTERN = /^no default$/iu;\nexports.default = (0, util_1.createRule)({\n    name: 'switch-exhaustiveness-check',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require switch-case statements to be exhaustive',\n            requiresTypeChecking: true,\n        },\n        hasSuggestions: true,\n        messages: {\n            addMissingCases: 'Add branches for missing cases.',\n            dangerousDefaultCase: 'The switch statement is exhaustive, so the default case is unnecessary.',\n            switchIsNotExhaustive: 'Switch is not exhaustive. Cases not matched: {{missingBranches}}',\n        },\n        schema: [\n            {\n                type: 'object',\n                additionalProperties: false,\n                properties: {\n                    allowDefaultCaseForExhaustiveSwitch: {\n                        type: 'boolean',\n                        description: `If 'true', allow 'default' cases on switch statements with exhaustive cases.`,\n                    },\n                    considerDefaultExhaustiveForUnions: {\n                        type: 'boolean',\n                        description: `If 'true', the 'default' clause is used to determine whether the switch statement is exhaustive for union type`,\n                    },\n                    defaultCaseCommentPattern: {\n                        type: 'string',\n                        description: `Regular expression for a comment that can indicate an intentionally omitted default case.`,\n                    },\n                    requireDefaultForNonUnion: {\n                        type: 'boolean',\n                        description: `If 'true', require a 'default' clause for switches on non-union types.`,\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            allowDefaultCaseForExhaustiveSwitch: true,\n            considerDefaultExhaustiveForUnions: false,\n            requireDefaultForNonUnion: false,\n        },\n    ],\n    create(context, [{ allowDefaultCaseForExhaustiveSwitch, considerDefaultExhaustiveForUnions, defaultCaseCommentPattern, requireDefaultForNonUnion, },]) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const compilerOptions = services.program.getCompilerOptions();\n        const commentRegExp = defaultCaseCommentPattern != null\n            ? new RegExp(defaultCaseCommentPattern, 'u')\n            : DEFAULT_COMMENT_PATTERN;\n        function getCommentDefaultCase(node) {\n            const lastCase = node.cases.at(-1);\n            const commentsAfterLastCase = lastCase\n                ? context.sourceCode.getCommentsAfter(lastCase)\n                : [];\n            const defaultCaseComment = commentsAfterLastCase.at(-1);\n            if (commentRegExp.test(defaultCaseComment?.value.trim() || '')) {\n                return defaultCaseComment;\n            }\n            return;\n        }\n        function typeToString(type) {\n            return checker.typeToString(type, undefined, ts.TypeFormatFlags.AllowUniqueESSymbolType |\n                ts.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope |\n                ts.TypeFormatFlags.UseFullyQualifiedType);\n        }\n        function getSwitchMetadata(node) {\n            const defaultCase = node.cases.find(switchCase => switchCase.test == null);\n            const discriminantType = (0, util_1.getConstrainedTypeAtLocation)(services, node.discriminant);\n            const symbolName = discriminantType.getSymbol()?.escapedName;\n            const containsNonLiteralType = doesTypeContainNonLiteralType(discriminantType);\n            const caseTypes = new Set();\n            for (const switchCase of node.cases) {\n                // If the `test` property of the switch case is `null`, then we are on a\n                // `default` case.\n                if (switchCase.test == null) {\n                    continue;\n                }\n                const caseType = (0, util_1.getConstrainedTypeAtLocation)(services, switchCase.test);\n                caseTypes.add(caseType);\n            }\n            const missingLiteralBranchTypes = [];\n            for (const unionPart of tsutils.unionTypeParts(discriminantType)) {\n                for (const intersectionPart of tsutils.intersectionTypeParts(unionPart)) {\n                    if (caseTypes.has(intersectionPart) ||\n                        !isTypeLiteralLikeType(intersectionPart)) {\n                        continue;\n                    }\n                    // \"missing\", \"optional\" and \"undefined\" types are different runtime objects,\n                    // but all of them have TypeFlags.Undefined type flag\n                    if ([...caseTypes].some(tsutils.isIntrinsicUndefinedType) &&\n                        tsutils.isIntrinsicUndefinedType(intersectionPart)) {\n                        continue;\n                    }\n                    missingLiteralBranchTypes.push(intersectionPart);\n                }\n            }\n            return {\n                containsNonLiteralType,\n                defaultCase: defaultCase ?? getCommentDefaultCase(node),\n                missingLiteralBranchTypes,\n                symbolName,\n            };\n        }\n        function checkSwitchExhaustive(node, switchMetadata) {\n            const { defaultCase, missingLiteralBranchTypes, symbolName } = switchMetadata;\n            // If considerDefaultExhaustiveForUnions is enabled, the presence of a default case\n            // always makes the switch exhaustive.\n            if (considerDefaultExhaustiveForUnions && defaultCase != null) {\n                return;\n            }\n            if (missingLiteralBranchTypes.length > 0) {\n                context.report({\n                    node: node.discriminant,\n                    messageId: 'switchIsNotExhaustive',\n                    data: {\n                        missingBranches: missingLiteralBranchTypes\n                            .map(missingType => tsutils.isTypeFlagSet(missingType, ts.TypeFlags.ESSymbolLike)\n                            ? `typeof ${missingType.getSymbol()?.escapedName}`\n                            : typeToString(missingType))\n                            .join(' | '),\n                    },\n                    suggest: [\n                        {\n                            messageId: 'addMissingCases',\n                            fix(fixer) {\n                                return fixSwitch(fixer, node, missingLiteralBranchTypes, defaultCase, symbolName?.toString());\n                            },\n                        },\n                    ],\n                });\n            }\n        }\n        function fixSwitch(fixer, node, missingBranchTypes, // null means default branch\n        defaultCase, symbolName) {\n            const lastCase = node.cases.length > 0 ? node.cases[node.cases.length - 1] : null;\n            const caseIndent = lastCase\n                ? ' '.repeat(lastCase.loc.start.column)\n                : // If there are no cases, use indentation of the switch statement and\n                    // leave it to the user to format it correctly.\n                    ' '.repeat(node.loc.start.column);\n            const missingCases = [];\n            for (const missingBranchType of missingBranchTypes) {\n                if (missingBranchType == null) {\n                    missingCases.push(`default: { throw new Error('default case') }`);\n                    continue;\n                }\n                const missingBranchName = missingBranchType.getSymbol()?.escapedName;\n                let caseTest = tsutils.isTypeFlagSet(missingBranchType, ts.TypeFlags.ESSymbolLike)\n                    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        missingBranchName\n                    : typeToString(missingBranchType);\n                if (symbolName &&\n                    (missingBranchName || missingBranchName === '') &&\n                    (0, util_1.requiresQuoting)(missingBranchName.toString(), compilerOptions.target)) {\n                    const escapedBranchName = missingBranchName\n                        .replaceAll(\"'\", \"\\\\'\")\n                        .replaceAll('\\n', '\\\\n')\n                        .replaceAll('\\r', '\\\\r');\n                    caseTest = `${symbolName}['${escapedBranchName}']`;\n                }\n                missingCases.push(`case ${caseTest}: { throw new Error('Not implemented yet: ${caseTest\n                    .replaceAll('\\\\', '\\\\\\\\')\n                    .replaceAll(\"'\", \"\\\\'\")} case') }`);\n            }\n            const fixString = missingCases\n                .map(code => `${caseIndent}${code}`)\n                .join('\\n');\n            if (lastCase) {\n                if (defaultCase) {\n                    const beforeFixString = missingCases\n                        .map(code => `${code}\\n${caseIndent}`)\n                        .join('');\n                    return fixer.insertTextBefore(defaultCase, beforeFixString);\n                }\n                return fixer.insertTextAfter(lastCase, `\\n${fixString}`);\n            }\n            // There were no existing cases.\n            const openingBrace = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.discriminant, util_1.isOpeningBraceToken), util_1.NullThrowsReasons.MissingToken('{', 'discriminant'));\n            const closingBrace = (0, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.discriminant, util_1.isClosingBraceToken), util_1.NullThrowsReasons.MissingToken('}', 'discriminant'));\n            return fixer.replaceTextRange([openingBrace.range[0], closingBrace.range[1]], ['{', fixString, `${caseIndent}}`].join('\\n'));\n        }\n        function checkSwitchUnnecessaryDefaultCase(switchMetadata) {\n            if (allowDefaultCaseForExhaustiveSwitch) {\n                return;\n            }\n            const { containsNonLiteralType, defaultCase, missingLiteralBranchTypes } = switchMetadata;\n            if (missingLiteralBranchTypes.length === 0 &&\n                defaultCase != null &&\n                !containsNonLiteralType) {\n                context.report({\n                    node: defaultCase,\n                    messageId: 'dangerousDefaultCase',\n                });\n            }\n        }\n        function checkSwitchNoUnionDefaultCase(node, switchMetadata) {\n            if (!requireDefaultForNonUnion) {\n                return;\n            }\n            const { containsNonLiteralType, defaultCase } = switchMetadata;\n            if (containsNonLiteralType && defaultCase == null) {\n                context.report({\n                    node: node.discriminant,\n                    messageId: 'switchIsNotExhaustive',\n                    data: { missingBranches: 'default' },\n                    suggest: [\n                        {\n                            messageId: 'addMissingCases',\n                            fix(fixer) {\n                                return fixSwitch(fixer, node, [null], defaultCase);\n                            },\n                        },\n                    ],\n                });\n            }\n        }\n        return {\n            SwitchStatement(node) {\n                const switchMetadata = getSwitchMetadata(node);\n                checkSwitchExhaustive(node, switchMetadata);\n                checkSwitchUnnecessaryDefaultCase(switchMetadata);\n                checkSwitchNoUnionDefaultCase(node, switchMetadata);\n            },\n        };\n    },\n});\nfunction isTypeLiteralLikeType(type) {\n    return tsutils.isTypeFlagSet(type, ts.TypeFlags.Literal |\n        ts.TypeFlags.Undefined |\n        ts.TypeFlags.Null |\n        ts.TypeFlags.UniqueESSymbol);\n}\n/**\n * For example:\n *\n * - `\"foo\" | \"bar\"` is a type with all literal types.\n * - `\"foo\" | number` is a type that contains non-literal types.\n * - `\"foo\" & { bar: 1 }` is a type that contains non-literal types.\n *\n * Default cases are never superfluous in switches with non-literal types.\n */\nfunction doesTypeContainNonLiteralType(type) {\n    return tsutils\n        .unionTypeParts(type)\n        .some(type => tsutils\n        .intersectionTypeParts(type)\n        .every(subType => !isTypeLiteralLikeType(subType)));\n}\n"
        }
    ]
}