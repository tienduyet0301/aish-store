{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-invalid-this.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891965765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst util_1 = require(\"../util\");\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-invalid-this');\nconst defaultOptions = [{ capIsConstructor: true }];\nexports.default = (0, util_1.createRule)({\n    name: 'no-invalid-this',\n    meta: {\n        type: 'suggestion',\n        defaultOptions,\n        docs: {\n            description: 'Disallow `this` keywords outside of classes or class-like objects',\n            extendsBaseRule: true,\n        },\n        hasSuggestions: baseRule.meta.hasSuggestions,\n        messages: baseRule.meta.messages,\n        schema: baseRule.meta.schema,\n    },\n    defaultOptions,\n    create(context) {\n        const rules = baseRule.create(context);\n        /**\n         * Since function definitions can be nested we use a stack storing if \"this\" is valid in the current context.\n         *\n         * Example:\n         *\n         * function a(this: number) { // valid \"this\"\n         *     function b() {\n         *         console.log(this); // invalid \"this\"\n         *     }\n         * }\n         *\n         * When parsing the function declaration of \"a\" the stack will be: [true]\n         * When parsing the function declaration of \"b\" the stack will be: [true, false]\n         */\n        const thisIsValidStack = [];\n        return {\n            ...rules,\n            AccessorProperty() {\n                thisIsValidStack.push(true);\n            },\n            'AccessorProperty:exit'() {\n                thisIsValidStack.pop();\n            },\n            FunctionDeclaration(node) {\n                thisIsValidStack.push(node.params.some(param => param.type === utils_1.AST_NODE_TYPES.Identifier && param.name === 'this'));\n            },\n            'FunctionDeclaration:exit'() {\n                thisIsValidStack.pop();\n            },\n            FunctionExpression(node) {\n                thisIsValidStack.push(node.params.some(param => param.type === utils_1.AST_NODE_TYPES.Identifier && param.name === 'this'));\n            },\n            'FunctionExpression:exit'() {\n                thisIsValidStack.pop();\n            },\n            PropertyDefinition() {\n                thisIsValidStack.push(true);\n            },\n            'PropertyDefinition:exit'() {\n                thisIsValidStack.pop();\n            },\n            ThisExpression(node) {\n                const thisIsValidHere = thisIsValidStack[thisIsValidStack.length - 1];\n                if (thisIsValidHere) {\n                    return;\n                }\n                // baseRule's work\n                rules.ThisExpression(node);\n            },\n        };\n    },\n});\n"
        }
    ]
}