{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/no-unsafe-assignment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891969836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst util_1 = require(\"../util\");\nvar ComparisonType;\n(function (ComparisonType) {\n    /** Do no assignment comparison */\n    ComparisonType[ComparisonType[\"None\"] = 0] = \"None\";\n    /** Use the receiver's type for comparison */\n    ComparisonType[ComparisonType[\"Basic\"] = 1] = \"Basic\";\n    /** Use the sender's contextual type for comparison */\n    ComparisonType[ComparisonType[\"Contextual\"] = 2] = \"Contextual\";\n})(ComparisonType || (ComparisonType = {}));\nexports.default = (0, util_1.createRule)({\n    name: 'no-unsafe-assignment',\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Disallow assigning a value with type `any` to variables and properties',\n            recommended: 'recommended',\n            requiresTypeChecking: true,\n        },\n        messages: {\n            anyAssignment: 'Unsafe assignment of an {{sender}} value.',\n            anyAssignmentThis: [\n                'Unsafe assignment of an {{sender}} value. `this` is typed as `any`.',\n                'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.',\n            ].join('\\n'),\n            unsafeArrayPattern: 'Unsafe array destructuring of an {{sender}} array value.',\n            unsafeArrayPatternFromTuple: 'Unsafe array destructuring of a tuple element with an {{sender}} value.',\n            unsafeArraySpread: 'Unsafe spread of an {{sender}} value in an array.',\n            unsafeAssignment: 'Unsafe assignment of type {{sender}} to a variable of type {{receiver}}.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        const compilerOptions = services.program.getCompilerOptions();\n        const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');\n        // returns true if the assignment reported\n        function checkArrayDestructureHelper(receiverNode, senderNode) {\n            if (receiverNode.type !== utils_1.AST_NODE_TYPES.ArrayPattern) {\n                return false;\n            }\n            const senderTsNode = services.esTreeNodeToTSNodeMap.get(senderNode);\n            const senderType = services.getTypeAtLocation(senderNode);\n            return checkArrayDestructure(receiverNode, senderType, senderTsNode);\n        }\n        // returns true if the assignment reported\n        function checkArrayDestructure(receiverNode, senderType, senderNode) {\n            // any array\n            // const [x] = ([] as any[]);\n            if ((0, util_1.isTypeAnyArrayType)(senderType, checker)) {\n                context.report({\n                    node: receiverNode,\n                    messageId: 'unsafeArrayPattern',\n                    data: createData(senderType),\n                });\n                return false;\n            }\n            if (!checker.isTupleType(senderType)) {\n                return true;\n            }\n            const tupleElements = checker.getTypeArguments(senderType);\n            // tuple with any\n            // const [x] = [1 as any];\n            let didReport = false;\n            for (let receiverIndex = 0; receiverIndex < receiverNode.elements.length; receiverIndex += 1) {\n                const receiverElement = receiverNode.elements[receiverIndex];\n                if (!receiverElement) {\n                    continue;\n                }\n                if (receiverElement.type === utils_1.AST_NODE_TYPES.RestElement) {\n                    // don't handle rests as they're not a 1:1 assignment\n                    continue;\n                }\n                const senderType = tupleElements[receiverIndex];\n                if (!senderType) {\n                    continue;\n                }\n                // check for the any type first so we can handle [[[x]]] = [any]\n                if ((0, util_1.isTypeAnyType)(senderType)) {\n                    context.report({\n                        node: receiverElement,\n                        messageId: 'unsafeArrayPatternFromTuple',\n                        data: createData(senderType),\n                    });\n                    // we want to report on every invalid element in the tuple\n                    didReport = true;\n                }\n                else if (receiverElement.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n                    didReport = checkArrayDestructure(receiverElement, senderType, senderNode);\n                }\n                else if (receiverElement.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n                    didReport = checkObjectDestructure(receiverElement, senderType, senderNode);\n                }\n            }\n            return didReport;\n        }\n        // returns true if the assignment reported\n        function checkObjectDestructureHelper(receiverNode, senderNode) {\n            if (receiverNode.type !== utils_1.AST_NODE_TYPES.ObjectPattern) {\n                return false;\n            }\n            const senderTsNode = services.esTreeNodeToTSNodeMap.get(senderNode);\n            const senderType = services.getTypeAtLocation(senderNode);\n            return checkObjectDestructure(receiverNode, senderType, senderTsNode);\n        }\n        // returns true if the assignment reported\n        function checkObjectDestructure(receiverNode, senderType, senderNode) {\n            const properties = new Map(senderType\n                .getProperties()\n                .map(property => [\n                property.getName(),\n                checker.getTypeOfSymbolAtLocation(property, senderNode),\n            ]));\n            let didReport = false;\n            for (const receiverProperty of receiverNode.properties) {\n                if (receiverProperty.type === utils_1.AST_NODE_TYPES.RestElement) {\n                    // don't bother checking rest\n                    continue;\n                }\n                let key;\n                if (!receiverProperty.computed) {\n                    key =\n                        receiverProperty.key.type === utils_1.AST_NODE_TYPES.Identifier\n                            ? receiverProperty.key.name\n                            : String(receiverProperty.key.value);\n                }\n                else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.Literal) {\n                    key = String(receiverProperty.key.value);\n                }\n                else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.TemplateLiteral &&\n                    receiverProperty.key.quasis.length === 1) {\n                    key = String(receiverProperty.key.quasis[0].value.cooked);\n                }\n                else {\n                    // can't figure out the name, so skip it\n                    continue;\n                }\n                const senderType = properties.get(key);\n                if (!senderType) {\n                    continue;\n                }\n                // check for the any type first so we can handle {x: {y: z}} = {x: any}\n                if ((0, util_1.isTypeAnyType)(senderType)) {\n                    context.report({\n                        node: receiverProperty.value,\n                        messageId: 'unsafeArrayPatternFromTuple',\n                        data: createData(senderType),\n                    });\n                    didReport = true;\n                }\n                else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n                    didReport = checkArrayDestructure(receiverProperty.value, senderType, senderNode);\n                }\n                else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n                    didReport = checkObjectDestructure(receiverProperty.value, senderType, senderNode);\n                }\n            }\n            return didReport;\n        }\n        // returns true if the assignment reported\n        function checkAssignment(receiverNode, senderNode, reportingNode, comparisonType) {\n            const receiverTsNode = services.esTreeNodeToTSNodeMap.get(receiverNode);\n            const receiverType = comparisonType === ComparisonType.Contextual\n                ? ((0, util_1.getContextualType)(checker, receiverTsNode) ??\n                    services.getTypeAtLocation(receiverNode))\n                : services.getTypeAtLocation(receiverNode);\n            const senderType = services.getTypeAtLocation(senderNode);\n            if ((0, util_1.isTypeAnyType)(senderType)) {\n                // handle cases when we assign any ==> unknown.\n                if ((0, util_1.isTypeUnknownType)(receiverType)) {\n                    return false;\n                }\n                let messageId = 'anyAssignment';\n                if (!isNoImplicitThis) {\n                    // `var foo = this`\n                    const thisExpression = (0, util_1.getThisExpression)(senderNode);\n                    if (thisExpression &&\n                        (0, util_1.isTypeAnyType)((0, util_1.getConstrainedTypeAtLocation)(services, thisExpression))) {\n                        messageId = 'anyAssignmentThis';\n                    }\n                }\n                context.report({\n                    node: reportingNode,\n                    messageId,\n                    data: createData(senderType),\n                });\n                return true;\n            }\n            if (comparisonType === ComparisonType.None) {\n                return false;\n            }\n            const result = (0, util_1.isUnsafeAssignment)(senderType, receiverType, checker, senderNode);\n            if (!result) {\n                return false;\n            }\n            const { receiver, sender } = result;\n            context.report({\n                node: reportingNode,\n                messageId: 'unsafeAssignment',\n                data: createData(sender, receiver),\n            });\n            return true;\n        }\n        function getComparisonType(typeAnnotation) {\n            return typeAnnotation\n                ? // if there's a type annotation, we can do a comparison\n                    ComparisonType.Basic\n                : // no type annotation means the variable's type will just be inferred, thus equal\n                    ComparisonType.None;\n        }\n        function createData(senderType, receiverType) {\n            if (receiverType) {\n                return {\n                    receiver: `\\`${checker.typeToString(receiverType)}\\``,\n                    sender: `\\`${checker.typeToString(senderType)}\\``,\n                };\n            }\n            return {\n                sender: tsutils.isIntrinsicErrorType(senderType)\n                    ? 'error typed'\n                    : '`any`',\n            };\n        }\n        return {\n            'AccessorProperty[value != null]'(node) {\n                checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));\n            },\n            'AssignmentExpression[operator = \"=\"], AssignmentPattern'(node) {\n                let didReport = checkAssignment(node.left, node.right, node, \n                // the variable already has some form of a type to compare against\n                ComparisonType.Basic);\n                if (!didReport) {\n                    didReport = checkArrayDestructureHelper(node.left, node.right);\n                }\n                if (!didReport) {\n                    checkObjectDestructureHelper(node.left, node.right);\n                }\n            },\n            'PropertyDefinition[value != null]'(node) {\n                checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));\n            },\n            'VariableDeclarator[init != null]'(node) {\n                const init = (0, util_1.nullThrows)(node.init, util_1.NullThrowsReasons.MissingToken(node.type, 'init'));\n                let didReport = checkAssignment(node.id, init, node, getComparisonType(node.id.typeAnnotation));\n                if (!didReport) {\n                    didReport = checkArrayDestructureHelper(node.id, init);\n                }\n                if (!didReport) {\n                    checkObjectDestructureHelper(node.id, init);\n                }\n            },\n            // object pattern props are checked via assignments\n            ':not(ObjectPattern) > Property'(node) {\n                if (node.value.type === utils_1.AST_NODE_TYPES.AssignmentPattern ||\n                    node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n                    // handled by other selector\n                    return;\n                }\n                checkAssignment(node.key, node.value, node, ComparisonType.Contextual);\n            },\n            'ArrayExpression > SpreadElement'(node) {\n                const restType = services.getTypeAtLocation(node.argument);\n                if ((0, util_1.isTypeAnyType)(restType) || (0, util_1.isTypeAnyArrayType)(restType, checker)) {\n                    context.report({\n                        node,\n                        messageId: 'unsafeArraySpread',\n                        data: createData(restType),\n                    });\n                }\n            },\n            'JSXAttribute[value != null]'(node) {\n                const value = (0, util_1.nullThrows)(node.value, util_1.NullThrowsReasons.MissingToken(node.type, 'value'));\n                if (value.type !== utils_1.AST_NODE_TYPES.JSXExpressionContainer ||\n                    value.expression.type === utils_1.AST_NODE_TYPES.JSXEmptyExpression) {\n                    return;\n                }\n                checkAssignment(node.name, value.expression, value.expression, ComparisonType.Contextual);\n            },\n        };\n    },\n});\n"
        }
    ]
}