{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/member-ordering.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891961883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n// This rule was feature-frozen before we enabled no-property-in-node.\n/* eslint-disable eslint-plugin/no-property-in-node */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOrder = void 0;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst natural_compare_1 = __importDefault(require(\"natural-compare\"));\nconst util_1 = require(\"../util\");\nconst neverConfig = {\n    type: 'string',\n    enum: ['never'],\n};\nconst arrayConfig = (memberTypes) => ({\n    type: 'array',\n    items: {\n        oneOf: [\n            {\n                $ref: memberTypes,\n            },\n            {\n                type: 'array',\n                items: {\n                    $ref: memberTypes,\n                },\n            },\n        ],\n    },\n});\nconst objectConfig = (memberTypes) => ({\n    type: 'object',\n    additionalProperties: false,\n    properties: {\n        memberTypes: {\n            oneOf: [arrayConfig(memberTypes), neverConfig],\n        },\n        optionalityOrder: {\n            $ref: '#/items/0/$defs/optionalityOrderOptions',\n        },\n        order: {\n            $ref: '#/items/0/$defs/orderOptions',\n        },\n    },\n});\nexports.defaultOrder = [\n    // Index signature\n    'signature',\n    'call-signature',\n    // Fields\n    'public-static-field',\n    'protected-static-field',\n    'private-static-field',\n    '#private-static-field',\n    'public-decorated-field',\n    'protected-decorated-field',\n    'private-decorated-field',\n    'public-instance-field',\n    'protected-instance-field',\n    'private-instance-field',\n    '#private-instance-field',\n    'public-abstract-field',\n    'protected-abstract-field',\n    'public-field',\n    'protected-field',\n    'private-field',\n    '#private-field',\n    'static-field',\n    'instance-field',\n    'abstract-field',\n    'decorated-field',\n    'field',\n    // Static initialization\n    'static-initialization',\n    // Constructors\n    'public-constructor',\n    'protected-constructor',\n    'private-constructor',\n    'constructor',\n    // Accessors\n    'public-static-accessor',\n    'protected-static-accessor',\n    'private-static-accessor',\n    '#private-static-accessor',\n    'public-decorated-accessor',\n    'protected-decorated-accessor',\n    'private-decorated-accessor',\n    'public-instance-accessor',\n    'protected-instance-accessor',\n    'private-instance-accessor',\n    '#private-instance-accessor',\n    'public-abstract-accessor',\n    'protected-abstract-accessor',\n    'public-accessor',\n    'protected-accessor',\n    'private-accessor',\n    '#private-accessor',\n    'static-accessor',\n    'instance-accessor',\n    'abstract-accessor',\n    'decorated-accessor',\n    'accessor',\n    // Getters\n    'public-static-get',\n    'protected-static-get',\n    'private-static-get',\n    '#private-static-get',\n    'public-decorated-get',\n    'protected-decorated-get',\n    'private-decorated-get',\n    'public-instance-get',\n    'protected-instance-get',\n    'private-instance-get',\n    '#private-instance-get',\n    'public-abstract-get',\n    'protected-abstract-get',\n    'public-get',\n    'protected-get',\n    'private-get',\n    '#private-get',\n    'static-get',\n    'instance-get',\n    'abstract-get',\n    'decorated-get',\n    'get',\n    // Setters\n    'public-static-set',\n    'protected-static-set',\n    'private-static-set',\n    '#private-static-set',\n    'public-decorated-set',\n    'protected-decorated-set',\n    'private-decorated-set',\n    'public-instance-set',\n    'protected-instance-set',\n    'private-instance-set',\n    '#private-instance-set',\n    'public-abstract-set',\n    'protected-abstract-set',\n    'public-set',\n    'protected-set',\n    'private-set',\n    '#private-set',\n    'static-set',\n    'instance-set',\n    'abstract-set',\n    'decorated-set',\n    'set',\n    // Methods\n    'public-static-method',\n    'protected-static-method',\n    'private-static-method',\n    '#private-static-method',\n    'public-decorated-method',\n    'protected-decorated-method',\n    'private-decorated-method',\n    'public-instance-method',\n    'protected-instance-method',\n    'private-instance-method',\n    '#private-instance-method',\n    'public-abstract-method',\n    'protected-abstract-method',\n    'public-method',\n    'protected-method',\n    'private-method',\n    '#private-method',\n    'static-method',\n    'instance-method',\n    'abstract-method',\n    'decorated-method',\n    'method',\n];\nconst allMemberTypes = [\n    ...new Set([\n        'readonly-signature',\n        'signature',\n        'readonly-field',\n        'field',\n        'method',\n        'call-signature',\n        'constructor',\n        'accessor',\n        'get',\n        'set',\n        'static-initialization',\n    ].flatMap(type => [\n        type,\n        ...['public', 'protected', 'private', '#private']\n            .flatMap(accessibility => [\n            type !== 'readonly-signature' &&\n                type !== 'signature' &&\n                type !== 'static-initialization' &&\n                type !== 'call-signature' &&\n                !(type === 'constructor' && accessibility === '#private')\n                ? `${accessibility}-${type}` // e.g. `public-field`\n                : [],\n            // Only class instance fields, methods, accessors, get and set can have decorators attached to them\n            accessibility !== '#private' &&\n                (type === 'readonly-field' ||\n                    type === 'field' ||\n                    type === 'method' ||\n                    type === 'accessor' ||\n                    type === 'get' ||\n                    type === 'set')\n                ? [`${accessibility}-decorated-${type}`, `decorated-${type}`]\n                : [],\n            type !== 'constructor' &&\n                type !== 'readonly-signature' &&\n                type !== 'signature' &&\n                type !== 'call-signature'\n                ? [\n                    'static',\n                    'instance',\n                    // There is no `static-constructor` or `instance-constructor` or `abstract-constructor`\n                    ...(accessibility === '#private' ||\n                        accessibility === 'private'\n                        ? []\n                        : ['abstract']),\n                ].flatMap(scope => [\n                    `${scope}-${type}`,\n                    `${accessibility}-${scope}-${type}`,\n                ])\n                : [],\n        ])\n            .flat(),\n    ])),\n];\nconst functionExpressions = [\n    utils_1.AST_NODE_TYPES.FunctionExpression,\n    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,\n];\n/**\n * Gets the node type.\n *\n * @param node the node to be evaluated.\n */\nfunction getNodeType(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n        case utils_1.AST_NODE_TYPES.MethodDefinition:\n        case utils_1.AST_NODE_TYPES.TSMethodSignature:\n            return node.kind;\n        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n            return 'call-signature';\n        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n            return 'constructor';\n        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:\n        case utils_1.AST_NODE_TYPES.TSPropertySignature:\n            return node.readonly ? 'readonly-field' : 'field';\n        case utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:\n        case utils_1.AST_NODE_TYPES.AccessorProperty:\n            return 'accessor';\n        case utils_1.AST_NODE_TYPES.PropertyDefinition:\n            return node.value && functionExpressions.includes(node.value.type)\n                ? 'method'\n                : node.readonly\n                    ? 'readonly-field'\n                    : 'field';\n        case utils_1.AST_NODE_TYPES.TSIndexSignature:\n            return node.readonly ? 'readonly-signature' : 'signature';\n        case utils_1.AST_NODE_TYPES.StaticBlock:\n            return 'static-initialization';\n        default:\n            return null;\n    }\n}\n/**\n * Gets the raw string value of a member's name\n */\nfunction getMemberRawName(member, sourceCode) {\n    const { name, type } = (0, util_1.getNameFromMember)(member, sourceCode);\n    if (type === util_1.MemberNameType.Quoted) {\n        return name.slice(1, -1);\n    }\n    if (type === util_1.MemberNameType.Private) {\n        return name.slice(1);\n    }\n    return name;\n}\n/**\n * Gets the member name based on the member type.\n *\n * @param node the node to be evaluated.\n */\nfunction getMemberName(node, sourceCode) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSPropertySignature:\n        case utils_1.AST_NODE_TYPES.TSMethodSignature:\n        case utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:\n        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:\n        case utils_1.AST_NODE_TYPES.AccessorProperty:\n        case utils_1.AST_NODE_TYPES.PropertyDefinition:\n            return getMemberRawName(node, sourceCode);\n        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n        case utils_1.AST_NODE_TYPES.MethodDefinition:\n            return node.kind === 'constructor'\n                ? 'constructor'\n                : getMemberRawName(node, sourceCode);\n        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n            return 'new';\n        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n            return 'call';\n        case utils_1.AST_NODE_TYPES.TSIndexSignature:\n            return (0, util_1.getNameFromIndexSignature)(node);\n        case utils_1.AST_NODE_TYPES.StaticBlock:\n            return 'static block';\n        default:\n            return null;\n    }\n}\n/**\n * Returns true if the member is optional based on the member type.\n *\n * @param node the node to be evaluated.\n *\n * @returns Whether the member is optional, or false if it cannot be optional at all.\n */\nfunction isMemberOptional(node) {\n    switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSPropertySignature:\n        case utils_1.AST_NODE_TYPES.TSMethodSignature:\n        case utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty:\n        case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:\n        case utils_1.AST_NODE_TYPES.AccessorProperty:\n        case utils_1.AST_NODE_TYPES.PropertyDefinition:\n        case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n        case utils_1.AST_NODE_TYPES.MethodDefinition:\n            return !!node.optional;\n    }\n    return false;\n}\n/**\n * Gets the calculated rank using the provided method definition.\n * The algorithm is as follows:\n * - Get the rank based on the accessibility-scope-type name, e.g. public-instance-field\n * - If there is no order for accessibility-scope-type, then strip out the accessibility.\n * - If there is no order for scope-type, then strip out the scope.\n * - If there is no order for type, then return -1\n * @param memberGroups the valid names to be validated.\n * @param orderConfig the current order to be validated.\n *\n * @return Index of the matching member type in the order configuration.\n */\nfunction getRankOrder(memberGroups, orderConfig) {\n    let rank = -1;\n    const stack = [...memberGroups]; // Get a copy of the member groups\n    while (stack.length > 0 && rank === -1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const memberGroup = stack.shift();\n        rank = orderConfig.findIndex(memberType => Array.isArray(memberType)\n            ? memberType.includes(memberGroup)\n            : memberType === memberGroup);\n    }\n    return rank;\n}\nfunction getAccessibility(node) {\n    if ('accessibility' in node && node.accessibility) {\n        return node.accessibility;\n    }\n    if ('key' in node && node.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n        return '#private';\n    }\n    return 'public';\n}\n/**\n * Gets the rank of the node given the order.\n * @param node the node to be evaluated.\n * @param orderConfig the current order to be validated.\n * @param supportsModifiers a flag indicating whether the type supports modifiers (scope or accessibility) or not.\n */\nfunction getRank(node, orderConfig, supportsModifiers) {\n    const type = getNodeType(node);\n    if (node.type === utils_1.AST_NODE_TYPES.MethodDefinition &&\n        node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n        return -1;\n    }\n    if (type == null) {\n        // shouldn't happen but just in case, put it on the end\n        return orderConfig.length - 1;\n    }\n    const abstract = node.type === utils_1.AST_NODE_TYPES.TSAbstractAccessorProperty ||\n        node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition ||\n        node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition;\n    const scope = 'static' in node && node.static\n        ? 'static'\n        : abstract\n            ? 'abstract'\n            : 'instance';\n    const accessibility = getAccessibility(node);\n    // Collect all existing member groups that apply to this node...\n    // (e.g. 'public-instance-field', 'instance-field', 'public-field', 'constructor' etc.)\n    const memberGroups = [];\n    if (supportsModifiers) {\n        const decorated = 'decorators' in node && node.decorators.length > 0;\n        if (decorated &&\n            (type === 'readonly-field' ||\n                type === 'field' ||\n                type === 'method' ||\n                type === 'accessor' ||\n                type === 'get' ||\n                type === 'set')) {\n            memberGroups.push(`${accessibility}-decorated-${type}`);\n            memberGroups.push(`decorated-${type}`);\n            if (type === 'readonly-field') {\n                memberGroups.push(`${accessibility}-decorated-field`);\n                memberGroups.push(`decorated-field`);\n            }\n        }\n        if (type !== 'readonly-signature' &&\n            type !== 'signature' &&\n            type !== 'static-initialization') {\n            if (type !== 'constructor') {\n                // Constructors have no scope\n                memberGroups.push(`${accessibility}-${scope}-${type}`);\n                memberGroups.push(`${scope}-${type}`);\n                if (type === 'readonly-field') {\n                    memberGroups.push(`${accessibility}-${scope}-field`);\n                    memberGroups.push(`${scope}-field`);\n                }\n            }\n            memberGroups.push(`${accessibility}-${type}`);\n            if (type === 'readonly-field') {\n                memberGroups.push(`${accessibility}-field`);\n            }\n        }\n    }\n    memberGroups.push(type);\n    if (type === 'readonly-signature') {\n        memberGroups.push('signature');\n    }\n    else if (type === 'readonly-field') {\n        memberGroups.push('field');\n    }\n    // ...then get the rank order for those member groups based on the node\n    return getRankOrder(memberGroups, orderConfig);\n}\n/**\n * Groups members into arrays of consecutive members with the same rank.\n * If, for example, the memberSet parameter looks like the following...\n * @example\n * ```\n * interface Foo {\n *   [a: string]: number;\n *\n *   a: x;\n *   B: x;\n *   c: x;\n *\n *   c(): void;\n *   B(): void;\n *   a(): void;\n *\n *   (): Baz;\n *\n *   new (): Bar;\n * }\n * ```\n * ...the resulting array will look like: [[a, B, c], [c, B, a]].\n * @param memberSet The members to be grouped.\n * @param memberType The configured order of member types.\n * @param supportsModifiers It'll get passed to getRank().\n * @returns The array of groups of members.\n */\nfunction groupMembersByType(members, memberTypes, supportsModifiers) {\n    const groupedMembers = [];\n    const memberRanks = members.map(member => getRank(member, memberTypes, supportsModifiers));\n    let previousRank = undefined;\n    members.forEach((member, index) => {\n        if (index === members.length - 1) {\n            return;\n        }\n        const rankOfCurrentMember = memberRanks[index];\n        const rankOfNextMember = memberRanks[index + 1];\n        if (rankOfCurrentMember === previousRank) {\n            groupedMembers.at(-1)?.push(member);\n        }\n        else if (rankOfCurrentMember === rankOfNextMember) {\n            groupedMembers.push([member]);\n            previousRank = rankOfCurrentMember;\n        }\n    });\n    return groupedMembers;\n}\n/**\n * Gets the lowest possible rank(s) higher than target.\n * e.g. given the following order:\n *   ...\n *   public-static-method\n *   protected-static-method\n *   private-static-method\n *   public-instance-method\n *   protected-instance-method\n *   private-instance-method\n *   ...\n * and considering that a public-instance-method has already been declared, so ranks contains\n * public-instance-method, then the lowest possible rank for public-static-method is\n * public-instance-method.\n * If a lowest possible rank is a member group, a comma separated list of ranks is returned.\n * @param ranks the existing ranks in the object.\n * @param target the minimum target rank to filter on.\n * @param order the current order to be validated.\n * @returns the name(s) of the lowest possible rank without dashes (-).\n */\nfunction getLowestRank(ranks, target, order) {\n    let lowest = ranks[ranks.length - 1];\n    ranks.forEach(rank => {\n        if (rank > target) {\n            lowest = Math.min(lowest, rank);\n        }\n    });\n    const lowestRank = order[lowest];\n    const lowestRanks = Array.isArray(lowestRank) ? lowestRank : [lowestRank];\n    return lowestRanks.map(rank => rank.replaceAll('-', ' ')).join(', ');\n}\nexports.default = (0, util_1.createRule)({\n    name: 'member-ordering',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Require a consistent member declaration order',\n        },\n        messages: {\n            incorrectGroupOrder: 'Member {{name}} should be declared before all {{rank}} definitions.',\n            incorrectOrder: 'Member {{member}} should be declared before member {{beforeMember}}.',\n            incorrectRequiredMembersOrder: `Member {{member}} should be declared after all {{optionalOrRequired}} members.`,\n        },\n        schema: [\n            {\n                type: 'object',\n                $defs: {\n                    allItems: {\n                        type: 'string',\n                        enum: allMemberTypes,\n                    },\n                    optionalityOrderOptions: {\n                        type: 'string',\n                        enum: ['optional-first', 'required-first'],\n                    },\n                    orderOptions: {\n                        type: 'string',\n                        enum: [\n                            'alphabetically',\n                            'alphabetically-case-insensitive',\n                            'as-written',\n                            'natural',\n                            'natural-case-insensitive',\n                        ],\n                    },\n                    typeItems: {\n                        type: 'string',\n                        enum: [\n                            'readonly-signature',\n                            'signature',\n                            'readonly-field',\n                            'field',\n                            'method',\n                            'constructor',\n                        ],\n                    },\n                    // ajv is order-dependent; these configs must come last\n                    baseConfig: {\n                        oneOf: [\n                            neverConfig,\n                            arrayConfig('#/items/0/$defs/allItems'),\n                            objectConfig('#/items/0/$defs/allItems'),\n                        ],\n                    },\n                    typesConfig: {\n                        oneOf: [\n                            neverConfig,\n                            arrayConfig('#/items/0/$defs/typeItems'),\n                            objectConfig('#/items/0/$defs/typeItems'),\n                        ],\n                    },\n                },\n                additionalProperties: false,\n                properties: {\n                    classes: {\n                        $ref: '#/items/0/$defs/baseConfig',\n                    },\n                    classExpressions: {\n                        $ref: '#/items/0/$defs/baseConfig',\n                    },\n                    default: {\n                        $ref: '#/items/0/$defs/baseConfig',\n                    },\n                    interfaces: {\n                        $ref: '#/items/0/$defs/typesConfig',\n                    },\n                    typeLiterals: {\n                        $ref: '#/items/0/$defs/typesConfig',\n                    },\n                },\n            },\n        ],\n    },\n    defaultOptions: [\n        {\n            default: {\n                memberTypes: exports.defaultOrder,\n            },\n        },\n    ],\n    create(context, [options]) {\n        /**\n         * Checks if the member groups are correctly sorted.\n         *\n         * @param members Members to be validated.\n         * @param groupOrder Group order to be validated.\n         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.\n         *\n         * @return Array of member groups or null if one of the groups is not correctly sorted.\n         */\n        function checkGroupSort(members, groupOrder, supportsModifiers) {\n            const previousRanks = [];\n            const memberGroups = [];\n            let isCorrectlySorted = true;\n            // Find first member which isn't correctly sorted\n            for (const member of members) {\n                const rank = getRank(member, groupOrder, supportsModifiers);\n                const name = getMemberName(member, context.sourceCode);\n                const rankLastMember = previousRanks[previousRanks.length - 1];\n                if (rank === -1) {\n                    continue;\n                }\n                // Works for 1st item because x < undefined === false for any x (typeof string)\n                if (rank < rankLastMember) {\n                    context.report({\n                        node: member,\n                        messageId: 'incorrectGroupOrder',\n                        data: {\n                            name,\n                            rank: getLowestRank(previousRanks, rank, groupOrder),\n                        },\n                    });\n                    isCorrectlySorted = false;\n                }\n                else if (rank === rankLastMember) {\n                    // Same member group --> Push to existing member group array\n                    memberGroups[memberGroups.length - 1].push(member);\n                }\n                else {\n                    // New member group --> Create new member group array\n                    previousRanks.push(rank);\n                    memberGroups.push([member]);\n                }\n            }\n            return isCorrectlySorted ? memberGroups : null;\n        }\n        /**\n         * Checks if the members are alphabetically sorted.\n         *\n         * @param members Members to be validated.\n         * @param order What order the members should be sorted in.\n         *\n         * @return True if all members are correctly sorted.\n         */\n        function checkAlphaSort(members, order) {\n            let previousName = '';\n            let isCorrectlySorted = true;\n            // Find first member which isn't correctly sorted\n            members.forEach(member => {\n                const name = getMemberName(member, context.sourceCode);\n                // Note: Not all members have names\n                if (name) {\n                    if (naturalOutOfOrder(name, previousName, order)) {\n                        context.report({\n                            node: member,\n                            messageId: 'incorrectOrder',\n                            data: {\n                                beforeMember: previousName,\n                                member: name,\n                            },\n                        });\n                        isCorrectlySorted = false;\n                    }\n                    previousName = name;\n                }\n            });\n            return isCorrectlySorted;\n        }\n        function naturalOutOfOrder(name, previousName, order) {\n            if (name === previousName) {\n                return false;\n            }\n            switch (order) {\n                case 'alphabetically':\n                    return name < previousName;\n                case 'alphabetically-case-insensitive':\n                    return name.toLowerCase() < previousName.toLowerCase();\n                case 'natural':\n                    return (0, natural_compare_1.default)(name, previousName) !== 1;\n                case 'natural-case-insensitive':\n                    return ((0, natural_compare_1.default)(name.toLowerCase(), previousName.toLowerCase()) !== 1);\n            }\n        }\n        /**\n         * Checks if the order of optional and required members is correct based\n         * on the given 'required' parameter.\n         *\n         * @param members Members to be validated.\n         * @param optionalityOrder Where to place optional members, if not intermixed.\n         *\n         * @return True if all required and optional members are correctly sorted.\n         */\n        function checkRequiredOrder(members, optionalityOrder) {\n            const switchIndex = members.findIndex((member, i) => i && isMemberOptional(member) !== isMemberOptional(members[i - 1]));\n            const report = (member) => context.report({\n                loc: member.loc,\n                messageId: 'incorrectRequiredMembersOrder',\n                data: {\n                    member: getMemberName(member, context.sourceCode),\n                    optionalOrRequired: optionalityOrder === 'required-first' ? 'required' : 'optional',\n                },\n            });\n            // if the optionality of the first item is correct (based on optionalityOrder)\n            // then the first 0 inclusive to switchIndex exclusive members all\n            // have the correct optionality\n            if (isMemberOptional(members[0]) !==\n                (optionalityOrder === 'optional-first')) {\n                report(members[0]);\n                return false;\n            }\n            for (let i = switchIndex + 1; i < members.length; i++) {\n                if (isMemberOptional(members[i]) !==\n                    isMemberOptional(members[switchIndex])) {\n                    report(members[switchIndex]);\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Validates if all members are correctly sorted.\n         *\n         * @param members Members to be validated.\n         * @param orderConfig Order config to be validated.\n         * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.\n         */\n        function validateMembersOrder(members, orderConfig, supportsModifiers) {\n            if (orderConfig === 'never') {\n                return;\n            }\n            // Standardize config\n            let order;\n            let memberTypes;\n            let optionalityOrder;\n            /**\n             * It runs an alphabetic sort on the groups of the members of the class in the source code.\n             * @param memberSet The members in the class of the source code on which the grouping operation will be performed.\n             */\n            const checkAlphaSortForAllMembers = (memberSet) => {\n                const hasAlphaSort = !!(order && order !== 'as-written');\n                if (hasAlphaSort && Array.isArray(memberTypes)) {\n                    groupMembersByType(memberSet, memberTypes, supportsModifiers).forEach(members => {\n                        checkAlphaSort(members, order);\n                    });\n                }\n            };\n            // returns true if everything is good and false if an error was reported\n            const checkOrder = (memberSet) => {\n                const hasAlphaSort = !!(order && order !== 'as-written');\n                // Check order\n                if (Array.isArray(memberTypes)) {\n                    const grouped = checkGroupSort(memberSet, memberTypes, supportsModifiers);\n                    if (grouped == null) {\n                        checkAlphaSortForAllMembers(members);\n                        return false;\n                    }\n                    if (hasAlphaSort) {\n                        grouped.map(groupMember => checkAlphaSort(groupMember, order));\n                    }\n                }\n                else if (hasAlphaSort) {\n                    return checkAlphaSort(memberSet, order);\n                }\n                return false;\n            };\n            if (Array.isArray(orderConfig)) {\n                memberTypes = orderConfig;\n            }\n            else {\n                order = orderConfig.order;\n                memberTypes = orderConfig.memberTypes;\n                optionalityOrder = orderConfig.optionalityOrder;\n            }\n            if (!optionalityOrder) {\n                checkOrder(members);\n                return;\n            }\n            const switchIndex = members.findIndex((member, i) => i && isMemberOptional(member) !== isMemberOptional(members[i - 1]));\n            if (switchIndex !== -1) {\n                if (!checkRequiredOrder(members, optionalityOrder)) {\n                    return;\n                }\n                checkOrder(members.slice(0, switchIndex));\n                checkOrder(members.slice(switchIndex));\n            }\n            else {\n                checkOrder(members);\n            }\n        }\n        // https://github.com/typescript-eslint/typescript-eslint/issues/5439\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        return {\n            ClassDeclaration(node) {\n                validateMembersOrder(node.body.body, options.classes ?? options.default, true);\n            },\n            'ClassDeclaration, FunctionDeclaration'(node) {\n                if ('superClass' in node) {\n                    // ...\n                }\n            },\n            ClassExpression(node) {\n                validateMembersOrder(node.body.body, options.classExpressions ?? options.default, true);\n            },\n            TSInterfaceDeclaration(node) {\n                validateMembersOrder(node.body.body, options.interfaces ?? options.default, false);\n            },\n            TSTypeLiteral(node) {\n                validateMembersOrder(node.members, options.typeLiterals ?? options.default, false);\n            },\n        };\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    },\n});\n"
        }
    ]
}