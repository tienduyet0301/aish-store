{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/dist/rules/prefer-return-this-type.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891974174,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst ts = __importStar(require(\"typescript\"));\nconst util_1 = require(\"../util\");\nexports.default = (0, util_1.createRule)({\n    name: 'prefer-return-this-type',\n    meta: {\n        type: 'suggestion',\n        docs: {\n            description: 'Enforce that `this` is used when only `this` type is returned',\n            recommended: 'strict',\n            requiresTypeChecking: true,\n        },\n        fixable: 'code',\n        messages: {\n            useThisType: 'Use `this` type instead.',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context) {\n        const services = (0, util_1.getParserServices)(context);\n        const checker = services.program.getTypeChecker();\n        function tryGetNameInType(name, typeNode) {\n            if (typeNode.type === utils_1.AST_NODE_TYPES.TSTypeReference &&\n                typeNode.typeName.type === utils_1.AST_NODE_TYPES.Identifier &&\n                typeNode.typeName.name === name) {\n                return typeNode;\n            }\n            if (typeNode.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n                for (const type of typeNode.types) {\n                    const found = tryGetNameInType(name, type);\n                    if (found) {\n                        return found;\n                    }\n                }\n            }\n            return undefined;\n        }\n        function isThisSpecifiedInParameters(originalFunc) {\n            const firstArg = originalFunc.params.at(0);\n            return !!(firstArg?.type === utils_1.AST_NODE_TYPES.Identifier && firstArg.name === 'this');\n        }\n        function isFunctionReturningThis(originalFunc, originalClass) {\n            if (isThisSpecifiedInParameters(originalFunc)) {\n                return false;\n            }\n            const func = services.esTreeNodeToTSNodeMap.get(originalFunc);\n            if (!func.body) {\n                return false;\n            }\n            const classType = services.getTypeAtLocation(originalClass);\n            if (func.body.kind !== ts.SyntaxKind.Block) {\n                const type = checker.getTypeAtLocation(func.body);\n                return classType.thisType === type;\n            }\n            let hasReturnThis = false;\n            let hasReturnClassType = false;\n            (0, util_1.forEachReturnStatement)(func.body, stmt => {\n                const expr = stmt.expression;\n                if (!expr) {\n                    return;\n                }\n                // fast check\n                if (expr.kind === ts.SyntaxKind.ThisKeyword) {\n                    hasReturnThis = true;\n                    return;\n                }\n                const type = checker.getTypeAtLocation(expr);\n                if (classType === type) {\n                    hasReturnClassType = true;\n                    return true;\n                }\n                if (classType.thisType === type) {\n                    hasReturnThis = true;\n                    return;\n                }\n                return;\n            });\n            return !hasReturnClassType && hasReturnThis;\n        }\n        function checkFunction(originalFunc, originalClass) {\n            const className = originalClass.id?.name;\n            if (!className || !originalFunc.returnType) {\n                return;\n            }\n            const node = tryGetNameInType(className, originalFunc.returnType.typeAnnotation);\n            if (!node) {\n                return;\n            }\n            if (isFunctionReturningThis(originalFunc, originalClass)) {\n                context.report({\n                    node,\n                    messageId: 'useThisType',\n                    fix: fixer => fixer.replaceText(node, 'this'),\n                });\n            }\n        }\n        function checkProperty(node) {\n            if (!(node.value?.type === utils_1.AST_NODE_TYPES.FunctionExpression ||\n                node.value?.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {\n                return;\n            }\n            checkFunction(node.value, node.parent.parent);\n        }\n        return {\n            'ClassBody > AccessorProperty': checkProperty,\n            'ClassBody > MethodDefinition'(node) {\n                checkFunction(node.value, node.parent.parent);\n            },\n            'ClassBody > PropertyDefinition': checkProperty,\n        };\n    },\n});\n"
        }
    ]
}