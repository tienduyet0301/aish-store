{
    "sourceFile": "node_modules/@typescript-eslint/eslint-plugin/rules.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891983132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\nWe purposely don't generate types for our plugin because TL;DR:\n1) there's no real reason that anyone should do a typed import of our rules,\n2) it would require us to change our code so there aren't as many inferred types\n\nThis type declaration exists as a hacky way to add a type to the export for our\ninternal packages that require it.\n\n*** Long reason ***\n\nWhen you turn on declaration files, TS requires all types to be \"fully resolvable\"\nwithout changes to the code.\nAll of our lint rules `export default createRule(...)`, which means they all\nimplicitly reference the `TSESLint.Rule` type for the export.\n\nTS wants to transpile each rule file to this `.d.ts` file:\n\n```ts\nimport type { TSESLint } from '@typescript-eslint/utils';\ndeclare const _default: TSESLint.RuleModule<TMessageIds, TOptions, TSESLint.RuleListener>;\nexport default _default;\n```\n\nBecause we don't import `TSESLint` in most files, it means that TS would have to\ninsert a new import during the declaration emit to make this work.\nHowever TS wants to avoid adding new imports to the file because a new module\ncould have type side-effects (like global augmentation) which could cause weird\ntype side-effects in the decl file that wouldn't exist in source TS file.\n\nSo TS errors on most of our rules with the following error:\n```\nThe inferred type of 'default' cannot be named without a reference to\n'../../../../node_modules/@typescript-eslint/utils/src/ts-eslint/Rule'.\nThis is likely not portable. A type annotation is necessary. ts(2742)\n```\n*/\n/* eslint-disable no-restricted-syntax */\n\nimport type {\n  RuleModuleWithMetaDocs,\n  RuleRecommendation,\n  RuleRecommendationAcrossConfigs,\n} from '@typescript-eslint/utils/ts-eslint';\n\ninterface ESLintPluginDocs {\n  /**\n   * Does the rule extend (or is it based off of) an ESLint code rule?\n   * Alternately accepts the name of the base rule, in case the rule has been renamed.\n   * This is only used for documentation purposes.\n   */\n  extendsBaseRule?: boolean | string;\n\n  /**\n   * If a string config name, which starting config this rule is enabled in.\n   * If an object, which settings it has enabled in each of those configs.\n   */\n  recommended?: RuleRecommendation | RuleRecommendationAcrossConfigs<unknown[]>;\n\n  /**\n   * Does the rule require us to create a full TypeScript Program in order for it\n   * to type-check code. This is only used for documentation purposes.\n   */\n  requiresTypeChecking?: boolean;\n}\n\ntype ESLintPluginRuleModule = RuleModuleWithMetaDocs<\n  string,\n  readonly unknown[],\n  ESLintPluginDocs\n>;\n\ntype TypeScriptESLintRules = Record<\n  string,\n  RuleModuleWithMetaDocs<string, unknown[], ESLintPluginDocs>\n>;\n\ndeclare const rules: TypeScriptESLintRules;\n\ndeclare namespace rules {\n  export type {\n    ESLintPluginDocs,\n    ESLintPluginRuleModule,\n    TypeScriptESLintRules,\n  };\n}\n\nexport = rules;\n"
        }
    ]
}