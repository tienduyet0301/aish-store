{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/eslint-utils/getParserServices.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892009001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getParserServices = getParserServices;\nconst parserSeemsToBeTSESLint_1 = require(\"./parserSeemsToBeTSESLint\");\nconst ERROR_MESSAGE_REQUIRES_PARSER_SERVICES = \"You have used a rule which requires type information, but don't have parserOptions set to generate type information for this file. See https://typescript-eslint.io/getting-started/typed-linting for enabling linting with type information.\";\nconst ERROR_MESSAGE_UNKNOWN_PARSER = 'Note: detected a parser other than @typescript-eslint/parser. Make sure the parser is configured to forward \"parserOptions.project\" to @typescript-eslint/parser.';\nfunction getParserServices(context, allowWithoutFullTypeInformation = false) {\n    const parser = context.parserPath || context.languageOptions.parser?.meta?.name;\n    // This check is unnecessary if the user is using the latest version of our parser.\n    //\n    // However the world isn't perfect:\n    // - Users often use old parser versions.\n    //   Old versions of the parser would not return any parserServices unless parserOptions.project was set.\n    // - Users sometimes use parsers that aren't @typescript-eslint/parser\n    //   Other parsers won't return the parser services we expect (if they return any at all).\n    //\n    // This check allows us to handle bad user setups whilst providing a nice user-facing\n    // error message explaining the problem.\n    if (context.sourceCode.parserServices?.esTreeNodeToTSNodeMap == null ||\n        context.sourceCode.parserServices.tsNodeToESTreeNodeMap == null) {\n        throwError(parser);\n    }\n    // if a rule requires full type information, then hard fail if it doesn't exist\n    // this forces the user to supply parserOptions.project\n    if (context.sourceCode.parserServices.program == null &&\n        !allowWithoutFullTypeInformation) {\n        throwError(parser);\n    }\n    return context.sourceCode.parserServices;\n}\n/* eslint-enable @typescript-eslint/unified-signatures */\nfunction throwError(parser) {\n    const messages = [\n        ERROR_MESSAGE_REQUIRES_PARSER_SERVICES,\n        `Parser: ${parser || '(unknown)'}`,\n        !(0, parserSeemsToBeTSESLint_1.parserSeemsToBeTSESLint)(parser) && ERROR_MESSAGE_UNKNOWN_PARSER,\n    ].filter(Boolean);\n    throw new Error(messages.join('\\n'));\n}\n"
        }
    ]
}