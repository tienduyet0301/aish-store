{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/ts-eslint/eslint/ESLintShared.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892009922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { Linter } from '../Linter';\nimport type { RuleMetaData } from '../Rule';\nexport declare class ESLintBase<Config extends Linter.ConfigType, Options extends ESLintOptions<Config>> {\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param options The options for this instance.\n     */\n    constructor(options?: Options);\n    /**\n     * This method calculates the configuration for a given file, which can be useful for debugging purposes.\n     * - It resolves and merges extends and overrides settings into the top level configuration.\n     * - It resolves the parser setting to absolute paths.\n     * - It normalizes the plugins setting to align short names. (e.g., eslint-plugin-foo â†’ foo)\n     * - It adds the processor setting if a legacy file extension processor is matched.\n     * - It doesn't interpret the env setting to the globals and parserOptions settings, so the result object contains\n     *   the env setting as is.\n     * @param filePath The path to the file whose configuration you would like to calculate. Directory paths are forbidden\n     *                 because ESLint cannot handle the overrides setting.\n     * @returns The promise that will be fulfilled with a configuration object.\n     */\n    calculateConfigForFile(filePath: string): Promise<Config>;\n    getRulesMetaForResults(results: LintResult[]): Record<string, RuleMetaData<string, Record<string, unknown>>>;\n    /**\n     * This method checks if a given file is ignored by your configuration.\n     * @param filePath The path to the file you want to check.\n     * @returns The promise that will be fulfilled with whether the file is ignored or not. If the file is ignored, then\n     *          it will return true.\n     */\n    isPathIgnored(filePath: string): Promise<boolean>;\n    /**\n     * This method lints the files that match the glob patterns and then returns the results.\n     * @param patterns The lint target files. This can contain any of file paths, directory paths, and glob patterns.\n     * @returns The promise that will be fulfilled with an array of LintResult objects.\n     */\n    lintFiles(patterns: string | string[]): Promise<LintResult[]>;\n    /**\n     * This method lints the given source code text and then returns the results.\n     *\n     * By default, this method uses the configuration that applies to files in the current working directory (the cwd\n     * constructor option). If you want to use a different configuration, pass options.filePath, and ESLint will load the\n     * same configuration that eslint.lintFiles() would use for a file at options.filePath.\n     *\n     * If the options.filePath value is configured to be ignored, this method returns an empty array. If the\n     * options.warnIgnored option is set along with the options.filePath option, this method returns a LintResult object.\n     * In that case, the result may contain a warning that indicates the file was ignored.\n     * @param code The source code text to check.\n     * @returns The promise that will be fulfilled with an array of LintResult objects. This is an array (despite there\n     *          being only one lint result) in order to keep the interfaces between this and the eslint.lintFiles()\n     *          method similar.\n     */\n    lintText(code: string, options?: LintTextOptions): Promise<LintResult[]>;\n    /**\n     * This method loads a formatter. Formatters convert lint results to a human- or machine-readable string.\n     * @param name TThe path to the file you want to check.\n     * The following values are allowed:\n     * - undefined. In this case, loads the \"stylish\" built-in formatter.\n     * - A name of built-in formatters.\n     * - A name of third-party formatters. For examples:\n     * -- `foo` will load eslint-formatter-foo.\n     * -- `@foo` will load `@foo/eslint-formatter`.\n     * -- `@foo/bar` will load `@foo/eslint-formatter-bar`.\n     * - A path to the file that defines a formatter. The path must contain one or more path separators (/) in order to distinguish if it's a path or not. For example, start with ./.\n     * @returns The promise that will be fulfilled with a Formatter object.\n     */\n    loadFormatter(name?: string): Promise<Formatter>;\n    /**\n     * This method copies the given results and removes warnings. The returned value contains only errors.\n     * @param results The LintResult objects to filter.\n     * @returns The filtered LintResult objects.\n     */\n    static getErrorResults(results: LintResult): LintResult;\n    /**\n     * This method writes code modified by ESLint's autofix feature into its respective file. If any of the modified\n     * files don't exist, this method does nothing.\n     * @param results The LintResult objects to write.\n     * @returns The promise that will be fulfilled after all files are written.\n     */\n    static outputFixes(results: LintResult[]): Promise<void>;\n    /**\n     * The version text.\n     */\n    static readonly version: string;\n    /**\n     * The type of configuration used by this class.\n     */\n    static readonly configType: Linter.ConfigTypeSpecifier;\n}\nexport interface ESLintOptions<Config extends Linter.ConfigType> {\n    /**\n     * If false is present, ESLint suppresses directive comments in source code.\n     * If this option is false, it overrides the noInlineConfig setting in your configurations.\n     * @default true\n     */\n    allowInlineConfig?: boolean;\n    /**\n     * Configuration object, extended by all configurations used with this instance.\n     * You can use this option to define the default settings that will be used if your configuration files don't\n     * configure it.\n     * @default null\n     */\n    baseConfig?: Config | null;\n    /**\n     * If `true` is present, the `eslint.lintFiles()` method caches lint results and uses it if each target file is not\n     * changed. Please mind that ESLint doesn't clear the cache when you upgrade ESLint plugins. In that case, you have\n     * to remove the cache file manually. The `eslint.lintText()` method doesn't use caches even if you pass the\n     * options.filePath to the method.\n     * @default false\n     */\n    cache?: boolean;\n    /**\n     * The eslint.lintFiles() method writes caches into this file.\n     * @default '.eslintcache'\n     */\n    cacheLocation?: string;\n    /**\n     * Strategy for the cache to use for detecting changed files.\n     * @default 'metadata'\n     */\n    cacheStrategy?: 'content' | 'metadata';\n    /**\n     * The working directory. This must be an absolute path.\n     * @default process.cwd()\n     */\n    cwd?: string;\n    /**\n     * Unless set to false, the `eslint.lintFiles()` method will throw an error when no target files are found.\n     * @default true\n     */\n    errorOnUnmatchedPattern?: boolean;\n    /**\n     * If `true` is present, the `eslint.lintFiles()` and `eslint.lintText()` methods work in autofix mode.\n     * If a predicate function is present, the methods pass each lint message to the function, then use only the\n     * lint messages for which the function returned true.\n     * @default false\n     */\n    fix?: boolean | ((message: LintMessage) => boolean);\n    /**\n     * The types of the rules that the `eslint.lintFiles()` and `eslint.lintText()` methods use for autofix.\n     * @default null\n     */\n    fixTypes?: ('directive' | 'problem' | 'suggestion')[] | null;\n    /**\n     * If false is present, the `eslint.lintFiles()` method doesn't interpret glob patterns.\n     * @default true\n     */\n    globInputPaths?: boolean;\n    /**\n     * Configuration object, overrides all configurations used with this instance.\n     * You can use this option to define the settings that will be used even if your configuration files configure it.\n     * @default null\n     */\n    overrideConfig?: Config | null;\n    /**\n     * When set to true, missing patterns cause the linting operation to short circuit and not report any failures.\n     * @default false\n     */\n    passOnNoPatterns?: boolean;\n    /**\n     * The plugin implementations that ESLint uses for the plugins setting of your configuration.\n     * This is a map-like object. Those keys are plugin IDs and each value is implementation.\n     * @default null\n     */\n    plugins?: Record<string, Linter.Plugin> | null;\n}\nexport interface DeprecatedRuleInfo {\n    /**\n     *  The rule IDs that replace this deprecated rule.\n     */\n    replacedBy: string[];\n    /**\n     *  The rule ID.\n     */\n    ruleId: string;\n}\n/**\n * The LintResult value is the information of the linting result of each file.\n */\nexport interface LintResult {\n    /**\n     * The number of errors. This includes fixable errors.\n     */\n    errorCount: number;\n    /**\n     * The number of fatal errors.\n     */\n    fatalErrorCount: number;\n    /**\n     * The absolute path to the file of this result. This is the string \"<text>\" if the file path is unknown (when you\n     * didn't pass the options.filePath option to the eslint.lintText() method).\n     */\n    filePath: string;\n    /**\n     * The number of errors that can be fixed automatically by the fix constructor option.\n     */\n    fixableErrorCount: number;\n    /**\n     * The number of warnings that can be fixed automatically by the fix constructor option.\n     */\n    fixableWarningCount: number;\n    /**\n     * The array of LintMessage objects.\n     */\n    messages: LintMessage[];\n    /**\n     * The source code of the file that was linted, with as many fixes applied as possible.\n     */\n    output?: string;\n    /**\n     * The original source code text. This property is undefined if any messages didn't exist or the output\n     * property exists.\n     */\n    source?: string;\n    /**\n     * Timing information of the lint run.\n     * This exists if and only if the `--stats` CLI flag was added or the `stats: true`\n     * option was passed to the ESLint class\n     * @since 9.0.0\n     */\n    stats?: LintStats;\n    /**\n     * The array of SuppressedLintMessage objects.\n     */\n    suppressedMessages: SuppressedLintMessage[];\n    /**\n     * The information about the deprecated rules that were used to check this file.\n     */\n    usedDeprecatedRules: DeprecatedRuleInfo[];\n    /**\n     * The number of warnings. This includes fixable warnings.\n     */\n    warningCount: number;\n}\nexport interface LintStats {\n    /**\n     * The number of times ESLint has applied at least one fix after linting.\n     */\n    fixPasses: number;\n    /**\n     * The times spent on (parsing, fixing, linting) a file, where the linting refers to the timing information for each rule.\n     */\n    times: {\n        passes: LintStatsTimePass[];\n    };\n}\nexport interface LintStatsTimePass {\n    /**\n     * The total time that is spent on applying fixes to the code.\n     */\n    fix: LintStatsFixTime;\n    /**\n     * The total time that is spent when parsing a file.\n     */\n    parse: LintStatsParseTime;\n    /**\n     * The total time that is spent on a rule.\n     */\n    rules?: Record<string, LintStatsRuleTime>;\n    /**\n     * The cumulative total\n     */\n    total: number;\n}\nexport interface LintStatsParseTime {\n    total: number;\n}\nexport interface LintStatsRuleTime {\n    total: number;\n}\nexport interface LintStatsFixTime {\n    total: number;\n}\nexport interface LintTextOptions {\n    /**\n     * The path to the file of the source code text. If omitted, the result.filePath becomes the string \"<text>\".\n     */\n    filePath?: string;\n    /**\n     * If true is present and the options.filePath is a file ESLint should ignore, this method returns a lint result\n     * contains a warning message.\n     */\n    warnIgnored?: boolean;\n}\n/**\n * The LintMessage value is the information of each linting error.\n */\nexport interface LintMessage {\n    /**\n     * The 1-based column number of the begin point of this message.\n     */\n    column: number | undefined;\n    /**\n     * The 1-based column number of the end point of this message. This property is undefined if this message\n     * is not a range.\n     */\n    endColumn: number | undefined;\n    /**\n     * The 1-based line number of the end point of this message. This property is undefined if this\n     * message is not a range.\n     */\n    endLine: number | undefined;\n    /**\n     * `true` if this is a fatal error unrelated to a rule, like a parsing error.\n     */\n    fatal?: boolean | undefined;\n    /**\n     * The EditInfo object of autofix. This property is undefined if this message is not fixable.\n     */\n    fix: EditInfo | undefined;\n    /**\n     * The 1-based line number of the begin point of this message.\n     */\n    line: number | undefined;\n    /**\n     * The error message\n     */\n    message: string;\n    /**\n     * The rule name that generates this lint message. If this message is generated by the ESLint core rather than\n     * rules, this is null.\n     */\n    ruleId: string | null;\n    /**\n     * The severity of this message. 1 means warning and 2 means error.\n     */\n    severity: 1 | 2;\n    /**\n     * The list of suggestions. Each suggestion is the pair of a description and an EditInfo object to fix code. API\n     * users such as editor integrations can choose one of them to fix the problem of this message. This property is\n     * undefined if this message doesn't have any suggestions.\n     */\n    suggestions: {\n        desc: string;\n        fix: EditInfo;\n    }[] | undefined;\n}\n/**\n * The SuppressedLintMessage value is the information of each suppressed linting error.\n */\nexport interface SuppressedLintMessage extends LintMessage {\n    /**\n     * The list of suppressions.\n     */\n    suppressions?: {\n        /**\n         * The free text description added after the `--` in the comment\n         */\n        justification: string;\n        /**\n         * Right now, this is always `directive`\n         */\n        kind: string;\n    }[];\n}\n/**\n * The EditInfo value is information to edit text.\n *\n * This edit information means replacing the range of the range property by the text property value. It's like\n * sourceCodeText.slice(0, edit.range[0]) + edit.text + sourceCodeText.slice(edit.range[1]). Therefore, it's an add\n * if the range[0] and range[1] property values are the same value, and it's removal if the text property value is\n * empty string.\n */\nexport interface EditInfo {\n    /**\n     * The pair of 0-based indices in source code text to remove.\n     */\n    range: [number, number];\n    /**\n     * The text to add.\n     */\n    text: string;\n}\n/**\n * The Formatter value is the object to convert the LintResult objects to text.\n */\nexport interface Formatter {\n    /**\n     * The method to convert the LintResult objects to text.\n     * Promise return supported since 8.4.0\n     */\n    format(results: LintResult[]): string | Promise<string>;\n}\n//# sourceMappingURL=ESLintShared.d.ts.map"
        }
    ]
}