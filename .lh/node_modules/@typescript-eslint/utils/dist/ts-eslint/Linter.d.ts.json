{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/ts-eslint/Linter.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892010316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { ClassicConfig, FlatConfig, SharedConfig } from './Config';\nimport type { Parser } from './Parser';\nimport type { Processor as ProcessorType } from './Processor';\nimport type { AnyRuleCreateFunction, AnyRuleModule, RuleCreateFunction, RuleFix, RuleModule } from './Rule';\nimport type { SourceCode } from './SourceCode';\nexport type MinimalRuleModule<MessageIds extends string = string, Options extends readonly unknown[] = []> = Partial<Omit<RuleModule<MessageIds, Options>, 'create'>> & Pick<RuleModule<MessageIds, Options>, 'create'>;\ndeclare class LinterBase {\n    /**\n     * The version from package.json.\n     */\n    readonly version: string;\n    /**\n     * Initialize the Linter.\n     * @param config the config object\n     */\n    constructor(config?: Linter.LinterOptions);\n    /**\n     * Define a new parser module\n     * @param parserId Name of the parser\n     * @param parserModule The parser object\n     */\n    defineParser(parserId: string, parserModule: Parser.LooseParserModule): void;\n    /**\n     * Defines a new linting rule.\n     * @param ruleId A unique rule identifier\n     * @param ruleModule Function from context to object mapping AST node types to event handlers\n     */\n    defineRule<MessageIds extends string, Options extends readonly unknown[]>(ruleId: string, ruleModule: MinimalRuleModule<MessageIds, Options> | RuleCreateFunction): void;\n    /**\n     * Defines many new linting rules.\n     * @param rulesToDefine map from unique rule identifier to rule\n     */\n    defineRules<MessageIds extends string, Options extends readonly unknown[]>(rulesToDefine: Record<string, MinimalRuleModule<MessageIds, Options> | RuleCreateFunction<MessageIds, Options>>): void;\n    /**\n     * Gets an object with all loaded rules.\n     * @returns All loaded rules\n     */\n    getRules(): Map<string, MinimalRuleModule<string, unknown[]>>;\n    /**\n     * Gets the `SourceCode` object representing the parsed source.\n     * @returns The `SourceCode` object.\n     */\n    getSourceCode(): SourceCode;\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param textOrSourceCode The text to parse or a SourceCode object.\n     * @param config An ESLintConfig instance to configure everything.\n     * @param filenameOrOptions The optional filename of the file being checked.\n     *        If this is not set, the filename will default to '<input>' in the rule context.\n     *        If this is an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns The results as an array of messages or an empty array if no messages.\n     */\n    verify(textOrSourceCode: string | SourceCode, config: Linter.ConfigType, filenameOrOptions?: string | Linter.VerifyOptions): Linter.LintMessage[];\n    /**\n     * The version from package.json.\n     */\n    static readonly version: string;\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible have been applied.\n     * @param code The source text to apply fixes to.\n     * @param config The ESLint config object to use.\n     * @param options The ESLint options object to use.\n     * @returns The result of the fix operation as returned from the SourceCodeFixer.\n     */\n    verifyAndFix(code: string, config: Linter.ConfigType, options: Linter.FixOptions): Linter.FixReport;\n}\ndeclare namespace Linter {\n    interface LinterOptions {\n        /**\n         * Which config format to use.\n         * @default 'flat'\n         */\n        configType?: ConfigTypeSpecifier;\n        /**\n         * path to a directory that should be considered as the current working directory.\n         */\n        cwd?: string;\n    }\n    type ConfigTypeSpecifier = 'eslintrc' | 'flat';\n    type EnvironmentConfig = SharedConfig.EnvironmentConfig;\n    type GlobalsConfig = SharedConfig.GlobalsConfig;\n    type GlobalVariableOption = SharedConfig.GlobalVariableOption;\n    type GlobalVariableOptionBase = SharedConfig.GlobalVariableOptionBase;\n    type ParserOptions = SharedConfig.ParserOptions;\n    type PluginMeta = SharedConfig.PluginMeta;\n    type RuleEntry = SharedConfig.RuleEntry;\n    type RuleLevel = SharedConfig.RuleLevel;\n    type RuleLevelAndOptions = SharedConfig.RuleLevelAndOptions;\n    type RulesRecord = SharedConfig.RulesRecord;\n    type Severity = SharedConfig.Severity;\n    type SeverityString = SharedConfig.SeverityString;\n    /** @deprecated use {@link Linter.ConfigType} instead */\n    type Config = ClassicConfig.Config;\n    type ConfigType = ClassicConfig.Config | FlatConfig.Config | FlatConfig.ConfigArray;\n    /** @deprecated use {@link ClassicConfig.ConfigOverride} instead */\n    type ConfigOverride = ClassicConfig.ConfigOverride;\n    interface VerifyOptions {\n        /**\n         * Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n         * Useful if you want to validate JS without comments overriding rules.\n         */\n        allowInlineConfig?: boolean;\n        /**\n         * if `true` then the linter doesn't make `fix` properties into the lint result.\n         */\n        disableFixes?: boolean;\n        /**\n         * the filename of the source code.\n         */\n        filename?: string;\n        /**\n         * the predicate function that selects adopt code blocks.\n         */\n        filterCodeBlock?: (filename: string, text: string) => boolean;\n        /**\n         * postprocessor for report messages.\n         * If provided, this should accept an array of the message lists\n         * for each code block returned from the preprocessor, apply a mapping to\n         * the messages as appropriate, and return a one-dimensional array of\n         * messages.\n         */\n        postprocess?: ProcessorType.PostProcess;\n        /**\n         * preprocessor for source text.\n         * If provided, this should accept a string of source text, and return an array of code blocks to lint.\n         */\n        preprocess?: ProcessorType.PreProcess;\n        /**\n         * Adds reported errors for unused `eslint-disable` directives.\n         */\n        reportUnusedDisableDirectives?: boolean | SeverityString;\n    }\n    interface FixOptions extends VerifyOptions {\n        /**\n         * Determines whether fixes should be applied.\n         */\n        fix?: boolean;\n    }\n    interface LintSuggestion {\n        desc: string;\n        fix: RuleFix;\n        messageId?: string;\n    }\n    interface LintMessage {\n        /**\n         * The 1-based column number.\n         */\n        column: number;\n        /**\n         * The 1-based column number of the end location.\n         */\n        endColumn?: number;\n        /**\n         * The 1-based line number of the end location.\n         */\n        endLine?: number;\n        /**\n         * If `true` then this is a fatal error.\n         */\n        fatal?: true;\n        /**\n         * Information for autofix.\n         */\n        fix?: RuleFix;\n        /**\n         * The 1-based line number.\n         */\n        line: number;\n        /**\n         * The error message.\n         */\n        message: string;\n        messageId?: string;\n        nodeType: string;\n        /**\n         * The ID of the rule which makes this message.\n         */\n        ruleId: string | null;\n        /**\n         * The severity of this message.\n         */\n        severity: Severity;\n        source: string | null;\n        /**\n         * Information for suggestions\n         */\n        suggestions?: LintSuggestion[];\n    }\n    interface FixReport {\n        /**\n         * True, if the code was fixed\n         */\n        fixed: boolean;\n        /**\n         * Collection of all messages for the given code\n         */\n        messages: LintMessage[];\n        /**\n         * Fixed code text (might be the same as input if no fixes were applied).\n         */\n        output: string;\n    }\n    /** @deprecated use {@link Parser.ParserModule} */\n    type ParserModule = Parser.LooseParserModule;\n    /** @deprecated use {@link Parser.ParseResult} */\n    type ESLintParseResult = Parser.ParseResult;\n    /** @deprecated use {@link ProcessorType.ProcessorModule} */\n    type Processor = ProcessorType.ProcessorModule;\n    interface Environment {\n        /**\n         * The definition of global variables.\n         */\n        globals?: GlobalsConfig;\n        /**\n         * The parser options that will be enabled under this environment.\n         */\n        parserOptions?: ParserOptions;\n    }\n    type LegacyPluginRules = Record<string, AnyRuleCreateFunction | AnyRuleModule>;\n    type PluginRules = Record<string, AnyRuleModule>;\n    interface Plugin {\n        /**\n         * The definition of plugin configs.\n         */\n        configs?: Record<string, ClassicConfig.Config>;\n        /**\n         * The definition of plugin environments.\n         */\n        environments?: Record<string, Environment>;\n        /**\n         * Metadata about your plugin for easier debugging and more effective caching of plugins.\n         */\n        meta?: PluginMeta;\n        /**\n         * The definition of plugin processors.\n         */\n        processors?: Record<string, ProcessorType.ProcessorModule>;\n        /**\n         * The definition of plugin rules.\n         */\n        rules?: LegacyPluginRules;\n    }\n}\ndeclare const Linter_base: typeof LinterBase;\n/**\n * The Linter object does the actual evaluation of the JavaScript code. It doesn't do any filesystem operations, it\n * simply parses and reports on the code. In particular, the Linter object does not process configuration objects\n * or files.\n */\ndeclare class Linter extends Linter_base {\n}\nexport { Linter };\n//# sourceMappingURL=Linter.d.ts.map"
        }
    ]
}