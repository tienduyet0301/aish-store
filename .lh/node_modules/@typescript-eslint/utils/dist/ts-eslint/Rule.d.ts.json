{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/ts-eslint/Rule.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892010698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { JSONSchema4 } from '../json-schema';\nimport type { ParserServices, TSESTree } from '../ts-estree';\nimport type { AST } from './AST';\nimport type { FlatConfig } from './Config';\nimport type { Linter } from './Linter';\nimport type { Scope } from './Scope';\nimport type { SourceCode } from './SourceCode';\nexport type RuleRecommendation = 'recommended' | 'strict' | 'stylistic';\nexport interface RuleRecommendationAcrossConfigs<Options extends readonly unknown[]> {\n    recommended?: true;\n    strict: Partial<Options>;\n}\nexport interface RuleMetaDataDocs {\n    /**\n     * Concise description of the rule.\n     */\n    description: string;\n    /**\n     * The URL of the rule's docs.\n     */\n    url?: string;\n}\nexport interface RuleMetaData<MessageIds extends string, PluginDocs = unknown, Options extends readonly unknown[] = []> {\n    /**\n     * True if the rule is deprecated, false otherwise\n     */\n    deprecated?: boolean;\n    /**\n     * Documentation for the rule\n     */\n    docs?: PluginDocs & RuleMetaDataDocs;\n    /**\n     * The fixer category. Omit if there is no fixer\n     */\n    fixable?: 'code' | 'whitespace';\n    /**\n     * Specifies whether rules can return suggestions. Omit if there is no suggestions\n     */\n    hasSuggestions?: boolean;\n    /**\n     * A map of messages which the rule can report.\n     * The key is the messageId, and the string is the parameterised error string.\n     * See: https://eslint.org/docs/developer-guide/working-with-rules#messageids\n     */\n    messages: Record<MessageIds, string>;\n    /**\n     * The name of the rule this rule was replaced by, if it was deprecated.\n     */\n    replacedBy?: readonly string[];\n    /**\n     * The options schema. Supply an empty array if there are no options.\n     */\n    schema: JSONSchema4 | readonly JSONSchema4[];\n    /**\n     * The type of rule.\n     * - `\"problem\"` means the rule is identifying code that either will cause an error or may cause a confusing behavior. Developers should consider this a high priority to resolve.\n     * - `\"suggestion\"` means the rule is identifying something that could be done in a better way but no errors will occur if the code isn’t changed.\n     * - `\"layout\"` means the rule cares primarily about whitespace, semicolons, commas, and parentheses, all the parts of the program that determine how the code looks rather than how it executes. These rules work on parts of the code that aren’t specified in the AST.\n     */\n    type: 'layout' | 'problem' | 'suggestion';\n    /**\n     * Specifies default options for the rule. If present, any user-provided options in their config will be merged on top of them recursively.\n     * This merging will be applied directly to `context.options`.\n     * If you want backwards-compatible support for earlier ESLint version; consider using the top-level `defaultOptions` instead.\n     *\n     * since ESLint 9.15.0\n     */\n    defaultOptions?: Options;\n}\nexport interface RuleMetaDataWithDocs<MessageIds extends string, PluginDocs = unknown, Options extends readonly unknown[] = []> extends RuleMetaData<MessageIds, PluginDocs, Options> {\n    /**\n     * Documentation for the rule\n     */\n    docs: PluginDocs & RuleMetaDataDocs;\n}\nexport interface RuleFix {\n    range: Readonly<AST.Range>;\n    text: string;\n}\nexport interface RuleFixer {\n    insertTextAfter(nodeOrToken: TSESTree.Node | TSESTree.Token, text: string): RuleFix;\n    insertTextAfterRange(range: Readonly<AST.Range>, text: string): RuleFix;\n    insertTextBefore(nodeOrToken: TSESTree.Node | TSESTree.Token, text: string): RuleFix;\n    insertTextBeforeRange(range: Readonly<AST.Range>, text: string): RuleFix;\n    remove(nodeOrToken: TSESTree.Node | TSESTree.Token): RuleFix;\n    removeRange(range: Readonly<AST.Range>): RuleFix;\n    replaceText(nodeOrToken: TSESTree.Node | TSESTree.Token, text: string): RuleFix;\n    replaceTextRange(range: Readonly<AST.Range>, text: string): RuleFix;\n}\nexport interface SuggestionReportDescriptor<MessageIds extends string> extends Omit<ReportDescriptorBase<MessageIds>, 'fix'> {\n    readonly fix: ReportFixFunction;\n}\nexport type ReportFixFunction = (fixer: RuleFixer) => IterableIterator<RuleFix> | readonly RuleFix[] | RuleFix | null;\nexport type ReportSuggestionArray<MessageIds extends string> = SuggestionReportDescriptor<MessageIds>[];\nexport type ReportDescriptorMessageData = Readonly<Record<string, unknown>>;\ninterface ReportDescriptorBase<MessageIds extends string> {\n    /**\n     * The parameters for the message string associated with `messageId`.\n     */\n    readonly data?: ReportDescriptorMessageData;\n    /**\n     * The fixer function.\n     */\n    readonly fix?: ReportFixFunction | null;\n    /**\n     * The messageId which is being reported.\n     */\n    readonly messageId: MessageIds;\n}\ninterface ReportDescriptorWithSuggestion<MessageIds extends string> extends ReportDescriptorBase<MessageIds> {\n    /**\n     * 6.7's Suggestions API\n     */\n    readonly suggest?: Readonly<ReportSuggestionArray<MessageIds>> | null;\n}\ninterface ReportDescriptorNodeOptionalLoc {\n    /**\n     * An override of the location of the report\n     */\n    readonly loc?: Readonly<TSESTree.Position> | Readonly<TSESTree.SourceLocation>;\n    /**\n     * The Node or AST Token which the report is being attached to\n     */\n    readonly node: TSESTree.Node | TSESTree.Token;\n}\ninterface ReportDescriptorLocOnly {\n    /**\n     * An override of the location of the report\n     */\n    loc: Readonly<TSESTree.Position> | Readonly<TSESTree.SourceLocation>;\n}\nexport type ReportDescriptor<MessageIds extends string> = (ReportDescriptorLocOnly | ReportDescriptorNodeOptionalLoc) & ReportDescriptorWithSuggestion<MessageIds>;\n/**\n * Plugins can add their settings using declaration\n * merging against this interface.\n */\nexport interface SharedConfigurationSettings {\n    [name: string]: unknown;\n}\nexport interface RuleContext<MessageIds extends string, Options extends readonly unknown[]> {\n    /**\n     * The rule ID.\n     */\n    id: string;\n    /**\n     * The language options configured for this run\n     */\n    languageOptions: FlatConfig.LanguageOptions;\n    /**\n     * An array of the configured options for this rule.\n     * This array does not include the rule severity.\n     */\n    options: Options;\n    /**\n     * The parser options configured for this run\n     */\n    parserOptions: Linter.ParserOptions;\n    /**\n     * The name of the parser from configuration, if in eslintrc (legacy) config.\n     */\n    parserPath: string | undefined;\n    /**\n     * An object containing parser-provided services for rules\n     *\n     * @deprecated in favor of `SourceCode#parserServices`\n     */\n    parserServices?: ParserServices;\n    /**\n     * The shared settings from configuration.\n     * We do not have any shared settings in this plugin.\n     */\n    settings: SharedConfigurationSettings;\n    /**\n     * Returns an array of the ancestors of the currently-traversed node, starting at\n     * the root of the AST and continuing through the direct parent of the current node.\n     * This array does not include the currently-traversed node itself.\n     *\n     * @deprecated in favor of `SourceCode#getAncestors`\n     */\n    getAncestors(): TSESTree.Node[];\n    /**\n     * Returns a list of variables declared by the given node.\n     * This information can be used to track references to variables.\n     *\n     * @deprecated in favor of `SourceCode#getDeclaredVariables`\n     */\n    getDeclaredVariables(node: TSESTree.Node): readonly Scope.Variable[];\n    /**\n     * Returns the current working directory passed to Linter.\n     * It is a path to a directory that should be considered as the current working directory.\n     * @deprecated in favor of `RuleContext#cwd`\n     */\n    getCwd(): string;\n    /**\n     * The current working directory passed to Linter.\n     * It is a path to a directory that should be considered as the current working directory.\n     */\n    cwd: string;\n    /**\n     * Returns the filename associated with the source.\n     *\n     * @deprecated in favor of `RuleContext#filename`\n     */\n    getFilename(): string;\n    /**\n     * The filename associated with the source.\n     */\n    filename: string;\n    /**\n     * Returns the full path of the file on disk without any code block information (unlike `getFilename()`).\n     * @deprecated in favor of `RuleContext#physicalFilename`\n     */\n    getPhysicalFilename(): string;\n    /**\n     * The full path of the file on disk without any code block information (unlike `filename`).\n     */\n    physicalFilename: string;\n    /**\n     * Returns the scope of the currently-traversed node.\n     * This information can be used track references to variables.\n     *\n     * @deprecated in favor of `SourceCode#getScope`\n     */\n    getScope(): Scope.Scope;\n    /**\n     * Returns a SourceCode object that you can use to work with the source that\n     * was passed to ESLint.\n     *\n     * @deprecated in favor of `RuleContext#sourceCode`\n     */\n    getSourceCode(): Readonly<SourceCode>;\n    /**\n     * A SourceCode object that you can use to work with the source that\n     * was passed to ESLint.\n     */\n    sourceCode: Readonly<SourceCode>;\n    /**\n     * Marks a variable with the given name in the current scope as used.\n     * This affects the no-unused-vars rule.\n     *\n     * @deprecated in favor of `SourceCode#markVariableAsUsed`\n     */\n    markVariableAsUsed(name: string): boolean;\n    /**\n     * Reports a problem in the code.\n     */\n    report(descriptor: ReportDescriptor<MessageIds>): void;\n}\n/**\n * Part of the code path analysis feature of ESLint:\n * https://eslint.org/docs/latest/extend/code-path-analysis\n *\n * These are used in the `onCodePath*` methods. (Note that the `node` parameter\n * of these methods is intentionally omitted.)\n *\n * @see https://github.com/typescript-eslint/typescript-eslint/issues/6993\n */\nexport interface CodePath {\n    /** Code paths of functions this code path contains. */\n    childCodePaths: CodePath[];\n    /**\n     * Segments of the current traversal position.\n     *\n     * @deprecated\n     */\n    currentSegments: CodePathSegment[];\n    /** The final segments which includes both returned and thrown. */\n    finalSegments: CodePathSegment[];\n    /**\n     * A unique string. Respective rules can use `id` to save additional\n     * information for each code path.\n     */\n    id: string;\n    initialSegment: CodePathSegment;\n    /** The final segments which includes only returned. */\n    returnedSegments: CodePathSegment[];\n    /** The final segments which includes only thrown. */\n    thrownSegments: CodePathSegment[];\n    /** The code path of the upper function/global scope. */\n    upper: CodePath | null;\n}\n/**\n * Part of the code path analysis feature of ESLint:\n * https://eslint.org/docs/latest/extend/code-path-analysis\n *\n * These are used in the `onCodePath*` methods. (Note that the `node` parameter\n * of these methods is intentionally omitted.)\n *\n * @see https://github.com/typescript-eslint/typescript-eslint/issues/6993\n */\nexport interface CodePathSegment {\n    /**\n     * A unique string. Respective rules can use `id` to save additional\n     * information for each segment.\n     */\n    id: string;\n    /**\n     * The next segments. If forking, there are two or more. If final, there is\n     * nothing.\n     */\n    nextSegments: CodePathSegment[];\n    /**\n     * The previous segments. If merging, there are two or more. If initial, there\n     * is nothing.\n     */\n    prevSegments: CodePathSegment[];\n    /**\n     * A flag which shows whether it is reachable. This becomes `false` when\n     * preceded by `return`, `throw`, `break`, or `continue`.\n     */\n    reachable: boolean;\n}\n/**\n * Part of the code path analysis feature of ESLint:\n * https://eslint.org/docs/latest/extend/code-path-analysis\n *\n * This type is unused in the `typescript-eslint` codebase since putting it on\n * the `nodeSelector` for `RuleListener` would break the existing definition.\n * However, it is exported here for the purposes of manual type-assertion.\n *\n * @see https://github.com/typescript-eslint/typescript-eslint/issues/6993\n */\nexport type CodePathFunction = ((codePath: CodePath, node: TSESTree.Node) => void) | ((fromSegment: CodePathSegment, toSegment: CodePathSegment, node: TSESTree.Node) => void) | ((segment: CodePathSegment, node: TSESTree.Node) => void);\nexport type RuleFunction<T extends TSESTree.NodeOrTokenData = never> = (node: T) => void;\ninterface RuleListenerBaseSelectors {\n    AccessorProperty?: RuleFunction<TSESTree.AccessorProperty>;\n    ArrayExpression?: RuleFunction<TSESTree.ArrayExpression>;\n    ArrayPattern?: RuleFunction<TSESTree.ArrayPattern>;\n    ArrowFunctionExpression?: RuleFunction<TSESTree.ArrowFunctionExpression>;\n    AssignmentExpression?: RuleFunction<TSESTree.AssignmentExpression>;\n    AssignmentPattern?: RuleFunction<TSESTree.AssignmentPattern>;\n    AwaitExpression?: RuleFunction<TSESTree.AwaitExpression>;\n    BinaryExpression?: RuleFunction<TSESTree.BinaryExpression>;\n    BlockStatement?: RuleFunction<TSESTree.BlockStatement>;\n    BreakStatement?: RuleFunction<TSESTree.BreakStatement>;\n    CallExpression?: RuleFunction<TSESTree.CallExpression>;\n    CatchClause?: RuleFunction<TSESTree.CatchClause>;\n    ChainExpression?: RuleFunction<TSESTree.ChainExpression>;\n    ClassBody?: RuleFunction<TSESTree.ClassBody>;\n    ClassDeclaration?: RuleFunction<TSESTree.ClassDeclaration>;\n    ClassExpression?: RuleFunction<TSESTree.ClassExpression>;\n    ConditionalExpression?: RuleFunction<TSESTree.ConditionalExpression>;\n    ContinueStatement?: RuleFunction<TSESTree.ContinueStatement>;\n    DebuggerStatement?: RuleFunction<TSESTree.DebuggerStatement>;\n    Decorator?: RuleFunction<TSESTree.Decorator>;\n    DoWhileStatement?: RuleFunction<TSESTree.DoWhileStatement>;\n    EmptyStatement?: RuleFunction<TSESTree.EmptyStatement>;\n    ExportAllDeclaration?: RuleFunction<TSESTree.ExportAllDeclaration>;\n    ExportDefaultDeclaration?: RuleFunction<TSESTree.ExportDefaultDeclaration>;\n    ExportNamedDeclaration?: RuleFunction<TSESTree.ExportNamedDeclaration>;\n    ExportSpecifier?: RuleFunction<TSESTree.ExportSpecifier>;\n    ExpressionStatement?: RuleFunction<TSESTree.ExpressionStatement>;\n    ForInStatement?: RuleFunction<TSESTree.ForInStatement>;\n    ForOfStatement?: RuleFunction<TSESTree.ForOfStatement>;\n    ForStatement?: RuleFunction<TSESTree.ForStatement>;\n    FunctionDeclaration?: RuleFunction<TSESTree.FunctionDeclaration>;\n    FunctionExpression?: RuleFunction<TSESTree.FunctionExpression>;\n    Identifier?: RuleFunction<TSESTree.Identifier>;\n    IfStatement?: RuleFunction<TSESTree.IfStatement>;\n    ImportAttribute?: RuleFunction<TSESTree.ImportAttribute>;\n    ImportDeclaration?: RuleFunction<TSESTree.ImportDeclaration>;\n    ImportDefaultSpecifier?: RuleFunction<TSESTree.ImportDefaultSpecifier>;\n    ImportExpression?: RuleFunction<TSESTree.ImportExpression>;\n    ImportNamespaceSpecifier?: RuleFunction<TSESTree.ImportNamespaceSpecifier>;\n    ImportSpecifier?: RuleFunction<TSESTree.ImportSpecifier>;\n    JSXAttribute?: RuleFunction<TSESTree.JSXAttribute>;\n    JSXClosingElement?: RuleFunction<TSESTree.JSXClosingElement>;\n    JSXClosingFragment?: RuleFunction<TSESTree.JSXClosingFragment>;\n    JSXElement?: RuleFunction<TSESTree.JSXElement>;\n    JSXEmptyExpression?: RuleFunction<TSESTree.JSXEmptyExpression>;\n    JSXExpressionContainer?: RuleFunction<TSESTree.JSXExpressionContainer>;\n    JSXFragment?: RuleFunction<TSESTree.JSXFragment>;\n    JSXIdentifier?: RuleFunction<TSESTree.JSXIdentifier>;\n    JSXMemberExpression?: RuleFunction<TSESTree.JSXMemberExpression>;\n    JSXNamespacedName?: RuleFunction<TSESTree.JSXNamespacedName>;\n    JSXOpeningElement?: RuleFunction<TSESTree.JSXOpeningElement>;\n    JSXOpeningFragment?: RuleFunction<TSESTree.JSXOpeningFragment>;\n    JSXSpreadAttribute?: RuleFunction<TSESTree.JSXSpreadAttribute>;\n    JSXSpreadChild?: RuleFunction<TSESTree.JSXSpreadChild>;\n    JSXText?: RuleFunction<TSESTree.JSXText>;\n    LabeledStatement?: RuleFunction<TSESTree.LabeledStatement>;\n    Literal?: RuleFunction<TSESTree.Literal>;\n    LogicalExpression?: RuleFunction<TSESTree.LogicalExpression>;\n    MemberExpression?: RuleFunction<TSESTree.MemberExpression>;\n    MetaProperty?: RuleFunction<TSESTree.MetaProperty>;\n    MethodDefinition?: RuleFunction<TSESTree.MethodDefinition>;\n    NewExpression?: RuleFunction<TSESTree.NewExpression>;\n    ObjectExpression?: RuleFunction<TSESTree.ObjectExpression>;\n    ObjectPattern?: RuleFunction<TSESTree.ObjectPattern>;\n    PrivateIdentifier?: RuleFunction<TSESTree.PrivateIdentifier>;\n    Program?: RuleFunction<TSESTree.Program>;\n    Property?: RuleFunction<TSESTree.Property>;\n    PropertyDefinition?: RuleFunction<TSESTree.PropertyDefinition>;\n    RestElement?: RuleFunction<TSESTree.RestElement>;\n    ReturnStatement?: RuleFunction<TSESTree.ReturnStatement>;\n    SequenceExpression?: RuleFunction<TSESTree.SequenceExpression>;\n    SpreadElement?: RuleFunction<TSESTree.SpreadElement>;\n    StaticBlock?: RuleFunction<TSESTree.StaticBlock>;\n    Super?: RuleFunction<TSESTree.Super>;\n    SwitchCase?: RuleFunction<TSESTree.SwitchCase>;\n    SwitchStatement?: RuleFunction<TSESTree.SwitchStatement>;\n    TaggedTemplateExpression?: RuleFunction<TSESTree.TaggedTemplateExpression>;\n    TemplateElement?: RuleFunction<TSESTree.TemplateElement>;\n    TemplateLiteral?: RuleFunction<TSESTree.TemplateLiteral>;\n    ThisExpression?: RuleFunction<TSESTree.ThisExpression>;\n    ThrowStatement?: RuleFunction<TSESTree.ThrowStatement>;\n    TryStatement?: RuleFunction<TSESTree.TryStatement>;\n    TSAbstractAccessorProperty?: RuleFunction<TSESTree.TSAbstractAccessorProperty>;\n    TSAbstractKeyword?: RuleFunction<TSESTree.TSAbstractKeyword>;\n    TSAbstractMethodDefinition?: RuleFunction<TSESTree.TSAbstractMethodDefinition>;\n    TSAbstractPropertyDefinition?: RuleFunction<TSESTree.TSAbstractPropertyDefinition>;\n    TSAnyKeyword?: RuleFunction<TSESTree.TSAnyKeyword>;\n    TSArrayType?: RuleFunction<TSESTree.TSArrayType>;\n    TSAsExpression?: RuleFunction<TSESTree.TSAsExpression>;\n    TSAsyncKeyword?: RuleFunction<TSESTree.TSAsyncKeyword>;\n    TSBigIntKeyword?: RuleFunction<TSESTree.TSBigIntKeyword>;\n    TSBooleanKeyword?: RuleFunction<TSESTree.TSBooleanKeyword>;\n    TSCallSignatureDeclaration?: RuleFunction<TSESTree.TSCallSignatureDeclaration>;\n    TSClassImplements?: RuleFunction<TSESTree.TSClassImplements>;\n    TSConditionalType?: RuleFunction<TSESTree.TSConditionalType>;\n    TSConstructorType?: RuleFunction<TSESTree.TSConstructorType>;\n    TSConstructSignatureDeclaration?: RuleFunction<TSESTree.TSConstructSignatureDeclaration>;\n    TSDeclareFunction?: RuleFunction<TSESTree.TSDeclareFunction>;\n    TSDeclareKeyword?: RuleFunction<TSESTree.TSDeclareKeyword>;\n    TSEmptyBodyFunctionExpression?: RuleFunction<TSESTree.TSEmptyBodyFunctionExpression>;\n    TSEnumBody?: RuleFunction<TSESTree.TSEnumBody>;\n    TSEnumDeclaration?: RuleFunction<TSESTree.TSEnumDeclaration>;\n    TSEnumMember?: RuleFunction<TSESTree.TSEnumMember>;\n    TSExportAssignment?: RuleFunction<TSESTree.TSExportAssignment>;\n    TSExportKeyword?: RuleFunction<TSESTree.TSExportKeyword>;\n    TSExternalModuleReference?: RuleFunction<TSESTree.TSExternalModuleReference>;\n    TSFunctionType?: RuleFunction<TSESTree.TSFunctionType>;\n    TSImportEqualsDeclaration?: RuleFunction<TSESTree.TSImportEqualsDeclaration>;\n    TSImportType?: RuleFunction<TSESTree.TSImportType>;\n    TSIndexedAccessType?: RuleFunction<TSESTree.TSIndexedAccessType>;\n    TSIndexSignature?: RuleFunction<TSESTree.TSIndexSignature>;\n    TSInferType?: RuleFunction<TSESTree.TSInferType>;\n    TSInstantiationExpression?: RuleFunction<TSESTree.TSInstantiationExpression>;\n    TSInterfaceBody?: RuleFunction<TSESTree.TSInterfaceBody>;\n    TSInterfaceDeclaration?: RuleFunction<TSESTree.TSInterfaceDeclaration>;\n    TSInterfaceHeritage?: RuleFunction<TSESTree.TSInterfaceHeritage>;\n    TSIntersectionType?: RuleFunction<TSESTree.TSIntersectionType>;\n    TSIntrinsicKeyword?: RuleFunction<TSESTree.TSIntrinsicKeyword>;\n    TSLiteralType?: RuleFunction<TSESTree.TSLiteralType>;\n    TSMappedType?: RuleFunction<TSESTree.TSMappedType>;\n    TSMethodSignature?: RuleFunction<TSESTree.TSMethodSignature>;\n    TSModuleBlock?: RuleFunction<TSESTree.TSModuleBlock>;\n    TSModuleDeclaration?: RuleFunction<TSESTree.TSModuleDeclaration>;\n    TSNamedTupleMember?: RuleFunction<TSESTree.TSNamedTupleMember>;\n    TSNamespaceExportDeclaration?: RuleFunction<TSESTree.TSNamespaceExportDeclaration>;\n    TSNeverKeyword?: RuleFunction<TSESTree.TSNeverKeyword>;\n    TSNonNullExpression?: RuleFunction<TSESTree.TSNonNullExpression>;\n    TSNullKeyword?: RuleFunction<TSESTree.TSNullKeyword>;\n    TSNumberKeyword?: RuleFunction<TSESTree.TSNumberKeyword>;\n    TSObjectKeyword?: RuleFunction<TSESTree.TSObjectKeyword>;\n    TSOptionalType?: RuleFunction<TSESTree.TSOptionalType>;\n    TSParameterProperty?: RuleFunction<TSESTree.TSParameterProperty>;\n    TSPrivateKeyword?: RuleFunction<TSESTree.TSPrivateKeyword>;\n    TSPropertySignature?: RuleFunction<TSESTree.TSPropertySignature>;\n    TSProtectedKeyword?: RuleFunction<TSESTree.TSProtectedKeyword>;\n    TSPublicKeyword?: RuleFunction<TSESTree.TSPublicKeyword>;\n    TSQualifiedName?: RuleFunction<TSESTree.TSQualifiedName>;\n    TSReadonlyKeyword?: RuleFunction<TSESTree.TSReadonlyKeyword>;\n    TSRestType?: RuleFunction<TSESTree.TSRestType>;\n    TSSatisfiesExpression?: RuleFunction<TSESTree.TSSatisfiesExpression>;\n    TSStaticKeyword?: RuleFunction<TSESTree.TSStaticKeyword>;\n    TSStringKeyword?: RuleFunction<TSESTree.TSStringKeyword>;\n    TSSymbolKeyword?: RuleFunction<TSESTree.TSSymbolKeyword>;\n    TSTemplateLiteralType?: RuleFunction<TSESTree.TSTemplateLiteralType>;\n    TSThisType?: RuleFunction<TSESTree.TSThisType>;\n    TSTupleType?: RuleFunction<TSESTree.TSTupleType>;\n    TSTypeAliasDeclaration?: RuleFunction<TSESTree.TSTypeAliasDeclaration>;\n    TSTypeAnnotation?: RuleFunction<TSESTree.TSTypeAnnotation>;\n    TSTypeAssertion?: RuleFunction<TSESTree.TSTypeAssertion>;\n    TSTypeLiteral?: RuleFunction<TSESTree.TSTypeLiteral>;\n    TSTypeOperator?: RuleFunction<TSESTree.TSTypeOperator>;\n    TSTypeParameter?: RuleFunction<TSESTree.TSTypeParameter>;\n    TSTypeParameterDeclaration?: RuleFunction<TSESTree.TSTypeParameterDeclaration>;\n    TSTypeParameterInstantiation?: RuleFunction<TSESTree.TSTypeParameterInstantiation>;\n    TSTypePredicate?: RuleFunction<TSESTree.TSTypePredicate>;\n    TSTypeQuery?: RuleFunction<TSESTree.TSTypeQuery>;\n    TSTypeReference?: RuleFunction<TSESTree.TSTypeReference>;\n    TSUndefinedKeyword?: RuleFunction<TSESTree.TSUndefinedKeyword>;\n    TSUnionType?: RuleFunction<TSESTree.TSUnionType>;\n    TSUnknownKeyword?: RuleFunction<TSESTree.TSUnknownKeyword>;\n    TSVoidKeyword?: RuleFunction<TSESTree.TSVoidKeyword>;\n    UnaryExpression?: RuleFunction<TSESTree.UnaryExpression>;\n    UpdateExpression?: RuleFunction<TSESTree.UpdateExpression>;\n    VariableDeclaration?: RuleFunction<TSESTree.VariableDeclaration>;\n    VariableDeclarator?: RuleFunction<TSESTree.VariableDeclarator>;\n    WhileStatement?: RuleFunction<TSESTree.WhileStatement>;\n    WithStatement?: RuleFunction<TSESTree.WithStatement>;\n    YieldExpression?: RuleFunction<TSESTree.YieldExpression>;\n}\ntype RuleListenerExitSelectors = {\n    [K in keyof RuleListenerBaseSelectors as `${K}:exit`]: RuleListenerBaseSelectors[K];\n};\ntype RuleListenerCatchAllBaseCase = Record<string, RuleFunction | undefined>;\nexport interface RuleListenerExtension {\n}\nexport type RuleListener = RuleListenerBaseSelectors & RuleListenerCatchAllBaseCase & RuleListenerExitSelectors;\nexport interface RuleModule<MessageIds extends string, Options extends readonly unknown[] = [], Docs = unknown, ExtendedRuleListener extends RuleListener = RuleListener> {\n    /**\n     * Function which returns an object with methods that ESLint calls to “visit”\n     * nodes while traversing the abstract syntax tree.\n     */\n    create(context: Readonly<RuleContext<MessageIds, Options>>): ExtendedRuleListener;\n    /**\n     * Default options the rule will be run with\n     */\n    defaultOptions: Options;\n    /**\n     * Metadata about the rule\n     */\n    meta: RuleMetaData<MessageIds, Docs, Options>;\n}\nexport type AnyRuleModule = RuleModule<string, readonly unknown[]>;\nexport interface RuleModuleWithMetaDocs<MessageIds extends string, Options extends readonly unknown[] = [], Docs = unknown, ExtendedRuleListener extends RuleListener = RuleListener> extends RuleModule<MessageIds, Options, Docs, ExtendedRuleListener> {\n    /**\n     * Metadata about the rule\n     */\n    meta: RuleMetaDataWithDocs<MessageIds, Docs, Options>;\n}\nexport type AnyRuleModuleWithMetaDocs = RuleModuleWithMetaDocs<string, unknown[]>;\n/**\n * A loose definition of the RuleModule type for use with configs. This type is\n * intended to relax validation of types so that we can have basic validation\n * without being overly strict about nitty gritty details matching.\n *\n * For example the plugin might be declared using an old version of our types or\n * they might use the DefinitelyTyped eslint types. Ultimately we don't need\n * super strict validation in a config - a loose shape match is \"good enough\" to\n * help validate the config is correct.\n *\n * @see {@link LooseParserModule}, {@link LooseProcessorModule}\n */\nexport type LooseRuleDefinition = {\n    create: LooseRuleCreateFunction;\n    meta?: object | undefined;\n} | LooseRuleCreateFunction;\nexport type LooseRuleCreateFunction = (context: any) => Record<string, Function | undefined>;\nexport type RuleCreateFunction<MessageIds extends string = never, Options extends readonly unknown[] = unknown[]> = (context: Readonly<RuleContext<MessageIds, Options>>) => RuleListener;\nexport type AnyRuleCreateFunction = RuleCreateFunction<string, readonly unknown[]>;\nexport {};\n//# sourceMappingURL=Rule.d.ts.map"
        }
    ]
}