{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/ts-eslint/SourceCode.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892010904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { ParserServices, TSESTree } from '../ts-estree';\nimport type { Parser } from './Parser';\nimport type { Scope } from './Scope';\ndeclare class TokenStore {\n    /**\n     * Checks whether any comments exist or not between the given 2 nodes.\n     * @param left The node to check.\n     * @param right The node to check.\n     * @returns `true` if one or more comments exist.\n     */\n    commentsExistBetween(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token): boolean;\n    /**\n     * Gets all comment tokens directly after the given node or token.\n     * @param nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns An array of comments in occurrence order.\n     */\n    getCommentsAfter(nodeOrToken: TSESTree.Node | TSESTree.Token): TSESTree.Comment[];\n    /**\n     * Gets all comment tokens directly before the given node or token.\n     * @param nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns An array of comments in occurrence order.\n     */\n    getCommentsBefore(nodeOrToken: TSESTree.Node | TSESTree.Token): TSESTree.Comment[];\n    /**\n     * Gets all comment tokens inside the given node.\n     * @param node The AST node to get the comments for.\n     * @returns An array of comments in occurrence order.\n     */\n    getCommentsInside(node: TSESTree.Node): TSESTree.Comment[];\n    /**\n     * Gets the first token of the given node.\n     * @param node The AST node.\n     * @param options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @returns An object representing the token.\n     */\n    getFirstToken<T extends SourceCode.CursorWithSkipOptions>(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param left Node before the desired token range.\n     * @param right Node after the desired token range.\n     * @param options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @returns An object representing the token.\n     */\n    getFirstTokenBetween<T extends SourceCode.CursorWithSkipOptions>(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param node The AST node.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     */\n    getFirstTokens<T extends SourceCode.CursorWithCountOptions>(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param left Node before the desired token range.\n     * @param right Node after the desired token range.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @returns Tokens between left and right.\n     */\n    getFirstTokensBetween<T extends SourceCode.CursorWithCountOptions>(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets the last token of the given node.\n     * @param node The AST node.\n     * @param options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @returns An object representing the token.\n     */\n    getLastToken<T extends SourceCode.CursorWithSkipOptions>(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param left Node before the desired token range.\n     * @param right Node after the desired token range.\n     * @param options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @returns An object representing the token.\n     */\n    getLastTokenBetween<T extends SourceCode.CursorWithSkipOptions>(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param node The AST node.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     */\n    getLastTokens<T extends SourceCode.CursorWithCountOptions>(node: TSESTree.Node, options?: T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param left Node before the desired token range.\n     * @param right Node after the desired token range.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @returns Tokens between left and right.\n     */\n    getLastTokensBetween<T extends SourceCode.CursorWithCountOptions>(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets the token that follows a given node or token.\n     * @param node The AST node or token.\n     * @param options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @returns An object representing the token.\n     */\n    getTokenAfter<T extends SourceCode.CursorWithSkipOptions>(node: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param node The AST node or token.\n     * @param options The option object\n     * @returns An object representing the token.\n     */\n    getTokenBefore<T extends SourceCode.CursorWithSkipOptions>(node: TSESTree.Node | TSESTree.Token, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets the token starting at the specified index.\n     * @param offset Index of the start of the token's range.\n     * @param options The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @returns The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart<T extends {\n        includeComments?: boolean;\n    }>(offset: number, options?: T): SourceCode.ReturnTypeFromOptions<T> | null;\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param node The AST node.\n     * @param beforeCount The number of tokens before the node to retrieve.\n     * @param afterCount The number of tokens after the node to retrieve.\n     * @returns Array of objects representing tokens.\n     */\n    getTokens(node: TSESTree.Node, beforeCount?: number, afterCount?: number): TSESTree.Token[];\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param node The AST node.\n     * @param options The option object. If this is a function then it's `options.filter`.\n     * @returns Array of objects representing tokens.\n     */\n    getTokens<T extends SourceCode.CursorWithCountOptions>(node: TSESTree.Node, options: T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param node The AST node.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     */\n    getTokensAfter<T extends SourceCode.CursorWithCountOptions>(node: TSESTree.Node | TSESTree.Token, options?: number | T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param node The AST node.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     */\n    getTokensBefore<T extends SourceCode.CursorWithCountOptions>(node: TSESTree.Node | TSESTree.Token, options?: number | T): SourceCode.ReturnTypeFromOptions<T>[];\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param left Node before the desired token range.\n     * @param right Node after the desired token range.\n     * @param options The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @returns Tokens between left and right.\n     */\n    getTokensBetween<T extends SourceCode.CursorWithCountOptions>(left: TSESTree.Node | TSESTree.Token, right: TSESTree.Node | TSESTree.Token, options?: number | T): SourceCode.ReturnTypeFromOptions<T>[];\n}\ndeclare class SourceCodeBase extends TokenStore {\n    /**\n     * Represents parsed source code.\n     * @param ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(text: string, ast: SourceCode.Program);\n    /**\n     * Represents parsed source code.\n     * @param config The config object.\n     */\n    constructor(config: SourceCode.SourceCodeConfig);\n    /**\n     * The parsed AST for the source code.\n     */\n    ast: SourceCode.Program;\n    applyInlineConfig(): void;\n    applyLanguageOptions(): void;\n    finalize(): void;\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns An array of comment nodes.\n     */\n    getAllComments(): TSESTree.Comment[];\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param location A line/column location\n     * @returns The range index of the location in the file.\n     */\n    getIndexFromLoc(location: TSESTree.Position): number;\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns The source text as an array of lines.\n     */\n    getLines(): string[];\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param index The index of a character in a file\n     * @returns A {line, column} location object with a 0-indexed column\n     */\n    getLocFromIndex(index: number): TSESTree.Position;\n    /**\n     * Gets the deepest node containing a range index.\n     * @param index Range index of the desired node.\n     * @returns The node if found or `null` if not found.\n     */\n    getNodeByRangeIndex(index: number): TSESTree.Node | null;\n    /**\n     * Gets the source code for the given node.\n     * @param node The AST node to get the text for.\n     * @param beforeCount The number of characters before the node to retrieve.\n     * @param afterCount The number of characters after the node to retrieve.\n     * @returns The text representing the AST node.\n     */\n    getText(node?: TSESTree.Node | TSESTree.Token, beforeCount?: number, afterCount?: number): string;\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     */\n    hasBOM: boolean;\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param first The first node or token to check between.\n     * @param second The second node or token to check between.\n     * @returns True if there is a whitespace character between any of the tokens found between the two given nodes or tokens.\n     */\n    isSpaceBetween(first: TSESTree.Node | TSESTree.Token, second: TSESTree.Node | TSESTree.Token): boolean;\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespace between the two.\n     * @param first The first node or token to check between.\n     * @param second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween\n     */\n    isSpaceBetweenTokens(first: TSESTree.Token, second: TSESTree.Token): boolean;\n    /**\n     * Returns the scope of the given node.\n     * This information can be used track references to variables.\n     */\n    getScope(node: TSESTree.Node): Scope.Scope;\n    /**\n     * Returns an array of the ancestors of the given node, starting at\n     * the root of the AST and continuing through the direct parent of the current node.\n     * This array does not include the currently-traversed node itself.\n     */\n    getAncestors(node: TSESTree.Node): TSESTree.Node[];\n    /**\n     * Returns a list of variables declared by the given node.\n     * This information can be used to track references to variables.\n     */\n    getDeclaredVariables(node: TSESTree.Node): readonly Scope.Variable[];\n    /**\n     * Marks a variable with the given name in the current scope as used.\n     * This affects the no-unused-vars rule.\n     */\n    markVariableAsUsed(name: string, node: TSESTree.Node): boolean;\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     */\n    lines: string[];\n    /**\n     * The indexes in `text` that each line starts\n     */\n    lineStartIndices: number[];\n    /**\n     * The parser services of this source code.\n     */\n    parserServices?: Partial<ParserServices>;\n    /**\n     * The scope of this source code.\n     */\n    scopeManager: Scope.ScopeManager | null;\n    /**\n     * The original text source code. BOM was stripped from this text.\n     */\n    text: string;\n    /**\n     * All of the tokens and comments in the AST.\n     *\n     * TODO: rename to 'tokens'\n     */\n    tokensAndComments: TSESTree.Token[];\n    /**\n     * The visitor keys to traverse AST.\n     */\n    visitorKeys: SourceCode.VisitorKeys;\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param text Source code as a string.\n     * @returns Array of source code lines.\n     */\n    static splitLines(text: string): string[];\n}\ndeclare namespace SourceCode {\n    interface Program extends TSESTree.Program {\n        comments: TSESTree.Comment[];\n        tokens: TSESTree.Token[];\n    }\n    interface SourceCodeConfig {\n        /**\n         * The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n         */\n        ast: Program;\n        /**\n         * The parser services.\n         */\n        parserServices: ParserServices | null;\n        /**\n         * The scope of this source code.\n         */\n        scopeManager: Scope.ScopeManager | null;\n        /**\n         * The source code text.\n         */\n        text: string;\n        /**\n         * The visitor keys to traverse AST.\n         */\n        visitorKeys: VisitorKeys | null;\n    }\n    type VisitorKeys = Parser.VisitorKeys;\n    type FilterPredicate = (token: TSESTree.Token) => boolean;\n    type GetFilterPredicate<Filter, Default> = Filter extends ((token: TSESTree.Token) => token is infer U extends TSESTree.Token) ? U : Default;\n    type GetFilterPredicateFromOptions<Options, Default> = Options extends {\n        filter?: FilterPredicate;\n    } ? GetFilterPredicate<Options['filter'], Default> : GetFilterPredicate<Options, Default>;\n    type ReturnTypeFromOptions<T> = T extends {\n        includeComments: true;\n    } ? GetFilterPredicateFromOptions<T, TSESTree.Token> : GetFilterPredicateFromOptions<T, Exclude<TSESTree.Token, TSESTree.Comment>>;\n    type CursorWithSkipOptions = number | {\n        /**\n         * The predicate function to choose tokens.\n         */\n        filter?: FilterPredicate;\n        /**\n         * The flag to iterate comments as well.\n         */\n        includeComments?: boolean;\n        /**\n         * The count of tokens the cursor skips.\n         */\n        skip?: number;\n    } | FilterPredicate;\n    type CursorWithCountOptions = number | {\n        /**\n         * The maximum count of tokens the cursor iterates.\n         */\n        count?: number;\n        /**\n         * The predicate function to choose tokens.\n         */\n        filter?: FilterPredicate;\n        /**\n         * The flag to iterate comments as well.\n         */\n        includeComments?: boolean;\n    } | FilterPredicate;\n}\ndeclare const SourceCode_base: typeof SourceCodeBase;\ndeclare class SourceCode extends SourceCode_base {\n}\nexport { SourceCode };\n//# sourceMappingURL=SourceCode.d.ts.map"
        }
    ]
}