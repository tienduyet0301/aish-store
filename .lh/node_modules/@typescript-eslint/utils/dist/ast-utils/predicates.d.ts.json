{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/ast-utils/predicates.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892008065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { TSESTree } from '../ts-estree';\nexport declare const isOptionalChainPunctuator: (token: TSESTree.Token | null | undefined) => token is {\n    value: \"?.\";\n} & TSESTree.PunctuatorToken;\nexport declare const isNotOptionalChainPunctuator: (token: TSESTree.Token | null | undefined) => token is TSESTree.BooleanToken | TSESTree.BlockComment | TSESTree.LineComment | TSESTree.IdentifierToken | TSESTree.JSXIdentifierToken | TSESTree.JSXTextToken | TSESTree.KeywordToken | TSESTree.NullToken | TSESTree.NumericToken | TSESTree.PunctuatorToken | TSESTree.RegularExpressionToken | TSESTree.StringToken | TSESTree.TemplateToken;\nexport declare const isNonNullAssertionPunctuator: (token: TSESTree.Token | null | undefined) => token is {\n    value: \"!\";\n} & TSESTree.PunctuatorToken;\nexport declare const isNotNonNullAssertionPunctuator: (token: TSESTree.Token | null | undefined) => token is TSESTree.BooleanToken | TSESTree.BlockComment | TSESTree.LineComment | TSESTree.IdentifierToken | TSESTree.JSXIdentifierToken | TSESTree.JSXTextToken | TSESTree.KeywordToken | TSESTree.NullToken | TSESTree.NumericToken | TSESTree.PunctuatorToken | TSESTree.RegularExpressionToken | TSESTree.StringToken | TSESTree.TemplateToken;\n/**\n * Returns true if and only if the node represents: foo?.() or foo.bar?.()\n */\nexport declare const isOptionalCallExpression: (node: TSESTree.Node | null | undefined) => node is {\n    optional: boolean;\n} & TSESTree.CallExpression;\n/**\n * Returns true if and only if the node represents logical OR\n */\nexport declare const isLogicalOrOperator: (node: TSESTree.Node | null | undefined) => node is Partial<TSESTree.LogicalExpression> & TSESTree.LogicalExpression;\n/**\n * Checks if a node is a type assertion:\n * ```\n * x as foo\n * <foo>x\n * ```\n */\nexport declare const isTypeAssertion: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSAsExpression | TSESTree.TSTypeAssertion;\nexport declare const isVariableDeclarator: (node: TSESTree.Node | null | undefined) => node is TSESTree.VariableDeclaratorDefiniteAssignment | TSESTree.VariableDeclaratorMaybeInit | TSESTree.VariableDeclaratorNoInit | TSESTree.UsingInForOfDeclarator | TSESTree.UsingInNormalContextDeclarator;\nexport declare const isFunction: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression;\nexport declare const isFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructorType | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;\nexport declare const isFunctionOrFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.ArrowFunctionExpression | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName | TSESTree.FunctionExpression | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructorType | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSDeclareFunctionNoDeclare | TSESTree.TSDeclareFunctionWithDeclare | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSFunctionType | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName;\nexport declare const isTSFunctionType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSFunctionType;\nexport declare const isTSConstructorType: (node: TSESTree.Node | null | undefined) => node is TSESTree.TSConstructorType;\nexport declare const isClassOrTypeElement: (node: TSESTree.Node | null | undefined) => node is TSESTree.FunctionExpression | TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName | TSESTree.PropertyDefinitionComputedName | TSESTree.PropertyDefinitionNonComputedName | TSESTree.TSAbstractMethodDefinitionComputedName | TSESTree.TSAbstractMethodDefinitionNonComputedName | TSESTree.TSAbstractPropertyDefinitionComputedName | TSESTree.TSAbstractPropertyDefinitionNonComputedName | TSESTree.TSCallSignatureDeclaration | TSESTree.TSConstructSignatureDeclaration | TSESTree.TSEmptyBodyFunctionExpression | TSESTree.TSIndexSignature | TSESTree.TSMethodSignatureComputedName | TSESTree.TSMethodSignatureNonComputedName | TSESTree.TSPropertySignatureComputedName | TSESTree.TSPropertySignatureNonComputedName;\n/**\n * Checks if a node is a constructor method.\n */\nexport declare const isConstructor: (node: TSESTree.Node | null | undefined) => node is Partial<TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName> & (TSESTree.MethodDefinitionComputedName | TSESTree.MethodDefinitionNonComputedName);\n/**\n * Checks if a node is a setter method.\n */\nexport declare function isSetter(node: TSESTree.Node | undefined): node is {\n    kind: 'set';\n} & (TSESTree.MethodDefinition | TSESTree.Property);\nexport declare const isIdentifier: (node: TSESTree.Node | null | undefined) => node is TSESTree.Identifier;\n/**\n * Checks if a node represents an `await â€¦` expression.\n */\nexport declare const isAwaitExpression: (node: TSESTree.Node | null | undefined) => node is TSESTree.AwaitExpression;\n/**\n * Checks if a possible token is the `await` keyword.\n */\nexport declare const isAwaitKeyword: (token: TSESTree.Token | null | undefined) => token is {\n    value: \"await\";\n} & TSESTree.IdentifierToken;\n/**\n * Checks if a possible token is the `type` keyword.\n */\nexport declare const isTypeKeyword: (token: TSESTree.Token | null | undefined) => token is {\n    value: \"type\";\n} & TSESTree.IdentifierToken;\n/**\n * Checks if a possible token is the `import` keyword.\n */\nexport declare const isImportKeyword: (token: TSESTree.Token | null | undefined) => token is {\n    value: \"import\";\n} & TSESTree.KeywordToken;\nexport declare const isLoop: (node: TSESTree.Node | null | undefined) => node is TSESTree.DoWhileStatement | TSESTree.ForInStatement | TSESTree.ForOfStatement | TSESTree.ForStatement | TSESTree.WhileStatement;\n//# sourceMappingURL=predicates.d.ts.map"
        }
    ]
}