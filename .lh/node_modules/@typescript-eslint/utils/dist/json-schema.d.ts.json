{
    "sourceFile": "node_modules/@typescript-eslint/utils/dist/json-schema.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892009600,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * This is a fork of https://github.com/DefinitelyTyped/DefinitelyTyped/blob/13f63c2eb8d7479caf01ab8d72f9e3683368a8f5/types/json-schema/index.d.ts\n * We intentionally fork this because:\n * - ESLint ***ONLY*** supports JSONSchema v4\n * - We want to provide stricter types\n */\n/**\n * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.1\n */\nexport type JSONSchema4TypeName = 'any' | 'array' | 'boolean' | 'integer' | 'null' | 'number' | 'object' | 'string';\n/**\n * @see https://tools.ietf.org/html/draft-zyp-json-schema-04#section-3.5\n */\nexport type JSONSchema4Type = boolean | number | string | null;\nexport type JSONSchema4TypeExtended = JSONSchema4Array | JSONSchema4Object | JSONSchema4Type;\nexport interface JSONSchema4Object {\n    [key: string]: JSONSchema4TypeExtended;\n}\nexport interface JSONSchema4Array extends Array<JSONSchema4TypeExtended> {\n}\n/**\n * Meta schema\n *\n * Recommended values:\n * - 'http://json-schema.org/schema#'\n * - 'http://json-schema.org/hyper-schema#'\n * - 'http://json-schema.org/draft-04/schema#'\n * - 'http://json-schema.org/draft-04/hyper-schema#'\n * - 'http://json-schema.org/draft-03/schema#'\n * - 'http://json-schema.org/draft-03/hyper-schema#'\n *\n * @see https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-5\n */\nexport type JSONSchema4Version = string;\n/**\n * JSON Schema V4\n * @see https://tools.ietf.org/html/draft-zyp-json-schema-04\n */\nexport type JSONSchema4 = JSONSchema4AllOfSchema | JSONSchema4AnyOfSchema | JSONSchema4AnySchema | JSONSchema4ArraySchema | JSONSchema4BooleanSchema | JSONSchema4MultiSchema | JSONSchema4NullSchema | JSONSchema4NumberSchema | JSONSchema4ObjectSchema | JSONSchema4OneOfSchema | JSONSchema4RefSchema | JSONSchema4StringSchema;\ninterface JSONSchema4Base {\n    /**\n     * Reusable definitions that can be referenced via `$ref`\n     */\n    $defs?: Record<string, JSONSchema4> | undefined;\n    /**\n     * Path to a schema defined in `definitions`/`$defs` that will form the base\n     * for this schema.\n     *\n     * If you are defining an \"array\" schema (`schema: [ ... ]`) for your rule\n     * then you should prefix this with `items/0` so that the validator can find\n     * your definitions.\n     *\n     * eg: `'#/items/0/definitions/myDef'`\n     *\n     * Otherwise if you are defining an \"object\" schema (`schema: { ... }`) for\n     * your rule you can directly reference your definitions\n     *\n     * eg: `'#/definitions/myDef'`\n     */\n    $ref?: string | undefined;\n    $schema?: JSONSchema4Version | undefined;\n    /**\n     * (AND) Must be valid against all of the sub-schemas\n     */\n    allOf?: JSONSchema4[] | undefined;\n    /**\n     * (OR) Must be valid against any of the sub-schemas\n     */\n    anyOf?: JSONSchema4[] | undefined;\n    /**\n     * The default value for the item if not present\n     */\n    default?: JSONSchema4TypeExtended | undefined;\n    /**\n     * Reusable definitions that can be referenced via `$ref`\n     */\n    definitions?: Record<string, JSONSchema4> | undefined;\n    /**\n     * This attribute is a string that provides a full description of the of\n     * purpose the instance property.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.22\n     */\n    description?: string | undefined;\n    /**\n     * The value of this property MUST be another schema which will provide\n     * a base schema which the current schema will inherit from.  The\n     * inheritance rules are such that any instance that is valid according\n     * to the current schema MUST be valid according to the referenced\n     * schema.  This MAY also be an array, in which case, the instance MUST\n     * be valid for all the schemas in the array.  A schema that extends\n     * another schema MAY define additional attributes, constrain existing\n     * attributes, or add other constraints.\n     *\n     * Conceptually, the behavior of extends can be seen as validating an\n     * instance against all constraints in the extending schema as well as\n     * the extended schema(s).\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.26\n     */\n    extends?: string | string[] | undefined;\n    id?: string | undefined;\n    /**\n     * (NOT) Must not be valid against the given schema\n     */\n    not?: JSONSchema4 | undefined;\n    /**\n     * (XOR) Must be valid against exactly one of the sub-schemas\n     */\n    oneOf?: JSONSchema4[] | undefined;\n    /**\n     * This attribute indicates if the instance must have a value, and not\n     * be undefined. This is false by default, making the instance\n     * optional.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.7\n     */\n    required?: boolean | string[] | undefined;\n    /**\n     * This attribute is a string that provides a short description of the\n     * instance property.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.21\n     */\n    title?: string | undefined;\n    /**\n     * A single type, or a union of simple types\n     */\n    type?: JSONSchema4TypeName | JSONSchema4TypeName[] | undefined;\n}\nexport interface JSONSchema4RefSchema extends JSONSchema4Base {\n    $ref: string;\n    type?: undefined;\n}\nexport interface JSONSchema4AllOfSchema extends JSONSchema4Base {\n    allOf: JSONSchema4[];\n    type?: undefined;\n}\nexport interface JSONSchema4AnyOfSchema extends JSONSchema4Base {\n    anyOf: JSONSchema4[];\n    type?: undefined;\n}\nexport interface JSONSchema4OneOfSchema extends JSONSchema4Base {\n    oneOf: JSONSchema4[];\n    type?: undefined;\n}\nexport interface JSONSchema4MultiSchema extends Omit<JSONSchema4ObjectSchema, 'enum' | 'type'>, Omit<JSONSchema4ArraySchema, 'enum' | 'type'>, Omit<JSONSchema4StringSchema, 'enum' | 'type'>, Omit<JSONSchema4NumberSchema, 'enum' | 'type'>, Omit<JSONSchema4BooleanSchema, 'enum' | 'type'>, Omit<JSONSchema4NullSchema, 'enum' | 'type'>, Omit<JSONSchema4AnySchema, 'enum' | 'type'> {\n    /**\n     * This provides an enumeration of all possible values that are valid\n     * for the instance property. This MUST be an array, and each item in\n     * the array represents a possible value for the instance value. If\n     * this attribute is defined, the instance value MUST be one of the\n     * values in the array in order for the schema to be valid.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19\n     */\n    enum?: JSONSchema4Type[];\n    type: JSONSchema4TypeName[];\n}\n/**\n * @see https://json-schema.org/understanding-json-schema/reference/object.html\n */\nexport interface JSONSchema4ObjectSchema extends JSONSchema4Base {\n    /**\n     * This attribute defines a schema for all properties that are not\n     * explicitly defined in an object type definition. If specified, the\n     * value MUST be a schema or a boolean. If false is provided, no\n     * additional properties are allowed beyond the properties defined in\n     * the schema. The default value is an empty schema which allows any\n     * value for additional properties.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.4\n     */\n    additionalProperties?: boolean | JSONSchema4 | undefined;\n    /**\n     * The `dependencies` keyword conditionally applies a sub-schema when a given\n     * property is present. This schema is applied in the same way `allOf` applies\n     * schemas. Nothing is merged or extended. Both schemas apply independently.\n     */\n    dependencies?: Record<string, JSONSchema4 | string[]> | undefined;\n    /**\n     * The maximum number of properties allowed for record-style schemas\n     */\n    maxProperties?: number | undefined;\n    /**\n     * The minimum number of properties required for record-style schemas\n     */\n    minProperties?: number | undefined;\n    /**\n     * This attribute is an object that defines the schema for a set of\n     * property names of an object instance. The name of each property of\n     * this attribute's object is a regular expression pattern in the ECMA\n     * 262/Perl 5 format, while the value is a schema. If the pattern\n     * matches the name of a property on the instance object, the value of\n     * the instance's property MUST be valid against the pattern name's\n     * schema value.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.3\n     */\n    patternProperties?: Record<string, JSONSchema4> | undefined;\n    /**\n     * This attribute is an object with property definitions that define the\n     * valid values of instance object property values. When the instance\n     * value is an object, the property values of the instance object MUST\n     * conform to the property definitions in this object. In this object,\n     * each property definition's value MUST be a schema, and the property's\n     * name MUST be the name of the instance property that it defines.  The\n     * instance property value MUST be valid according to the schema from\n     * the property definition. Properties are considered unordered, the\n     * order of the instance properties MAY be in any order.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.2\n     */\n    properties?: Record<string, JSONSchema4> | undefined;\n    type: 'object';\n}\n/**\n * @see https://json-schema.org/understanding-json-schema/reference/array.html\n */\nexport interface JSONSchema4ArraySchema extends JSONSchema4Base {\n    /**\n     * May only be defined when \"items\" is defined, and is a tuple of JSONSchemas.\n     *\n     * This provides a definition for additional items in an array instance\n     * when tuple definitions of the items is provided.  This can be false\n     * to indicate additional items in the array are not allowed, or it can\n     * be a schema that defines the schema of the additional items.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.6\n     */\n    additionalItems?: boolean | JSONSchema4 | undefined;\n    /**\n     * This attribute defines the allowed items in an instance array, and\n     * MUST be a schema or an array of schemas.  The default value is an\n     * empty schema which allows any value for items in the instance array.\n     *\n     * When this attribute value is a schema and the instance value is an\n     * array, then all the items in the array MUST be valid according to the\n     * schema.\n     *\n     * When this attribute value is an array of schemas and the instance\n     * value is an array, each position in the instance array MUST conform\n     * to the schema in the corresponding position for this array.  This\n     * called tuple typing.  When tuple typing is used, additional items are\n     * allowed, disallowed, or constrained by the \"additionalItems\"\n     * (Section 5.6) attribute using the same rules as\n     * \"additionalProperties\" (Section 5.4) for objects.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.5\n     */\n    items?: JSONSchema4 | JSONSchema4[] | undefined;\n    /**\n     * Defines the maximum length of an array\n     */\n    maxItems?: number | undefined;\n    /**\n     * Defines the minimum length of an array\n     */\n    minItems?: number | undefined;\n    type: 'array';\n    /**\n     * Enforces that all items in the array are unique\n     */\n    uniqueItems?: boolean | undefined;\n}\n/**\n * @see https://json-schema.org/understanding-json-schema/reference/string.html\n */\nexport interface JSONSchema4StringSchema extends JSONSchema4Base {\n    enum?: string[] | undefined;\n    /**\n     * The `format` keyword allows for basic semantic identification of certain\n     * kinds of string values that are commonly used.\n     *\n     * For example, because JSON doesn’t have a “DateTime” type, dates need to be\n     * encoded as strings. `format` allows the schema author to indicate that the\n     * string value should be interpreted as a date.\n     *\n     * ajv v6 provides a few built-in formats - all other strings will cause AJV\n     * to throw during schema compilation\n     */\n    format?: 'date' | 'date-time' | 'email' | 'hostname' | 'ipv4' | 'ipv6' | 'json-pointer' | 'json-pointer-uri-fragment' | 'regex' | 'relative-json-pointer' | 'time' | 'uri' | 'uri-reference' | 'uri-template' | 'url' | 'uuid' | undefined;\n    /**\n     * The maximum allowed length for the string\n     */\n    maxLength?: number | undefined;\n    /**\n     * The minimum allowed length for the string\n     */\n    minLength?: number | undefined;\n    /**\n     * The `pattern` keyword is used to restrict a string to a particular regular\n     * expression. The regular expression syntax is the one defined in JavaScript\n     * (ECMA 262 specifically) with Unicode support.\n     *\n     * When defining the regular expressions, it’s important to note that the\n     * string is considered valid if the expression matches anywhere within the\n     * string. For example, the regular expression \"p\" will match any string with\n     * a p in it, such as \"apple\" not just a string that is simply \"p\". Therefore,\n     * it is usually less confusing, as a matter of course, to surround the\n     * regular expression in ^...$, for example, \"^p$\", unless there is a good\n     * reason not to do so.\n     */\n    pattern?: string | undefined;\n    type: 'string';\n}\n/**\n * @see https://json-schema.org/understanding-json-schema/reference/numeric.html\n */\nexport interface JSONSchema4NumberSchema extends JSONSchema4Base {\n    /**\n     * This provides an enumeration of all possible values that are valid\n     * for the instance property. This MUST be an array, and each item in\n     * the array represents a possible value for the instance value. If\n     * this attribute is defined, the instance value MUST be one of the\n     * values in the array in order for the schema to be valid.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19\n     */\n    enum?: number[] | undefined;\n    /**\n     * The exclusive minimum allowed value for the number\n     * - `true` = `x < maximum`\n     * - `false` = `x <= maximum`\n     *\n     * Default is `false`\n     */\n    exclusiveMaximum?: boolean | undefined;\n    /**\n     * Indicates whether or not `minimum` is the inclusive or exclusive minimum\n     * - `true` = `x > minimum`\n     * - `false` = `x ≥ minimum`\n     *\n     * Default is `false`\n     */\n    exclusiveMinimum?: boolean | undefined;\n    /**\n     * The maximum allowed value for the number\n     */\n    maximum?: number | undefined;\n    /**\n     * The minimum allowed value for the number\n     */\n    minimum?: number | undefined;\n    /**\n     * Numbers can be restricted to a multiple of a given number, using the\n     * `multipleOf` keyword. It may be set to any positive number.\n     */\n    multipleOf?: number | undefined;\n    type: 'integer' | 'number';\n}\n/**\n * @see https://json-schema.org/understanding-json-schema/reference/boolean.html\n */\nexport interface JSONSchema4BooleanSchema extends JSONSchema4Base {\n    /**\n     * This provides an enumeration of all possible values that are valid\n     * for the instance property. This MUST be an array, and each item in\n     * the array represents a possible value for the instance value. If\n     * this attribute is defined, the instance value MUST be one of the\n     * values in the array in order for the schema to be valid.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19\n     */\n    enum?: boolean[] | undefined;\n    type: 'boolean';\n}\n/**\n * @see https://json-schema.org/understanding-json-schema/reference/null.html\n */\nexport interface JSONSchema4NullSchema extends JSONSchema4Base {\n    /**\n     * This provides an enumeration of all possible values that are valid\n     * for the instance property. This MUST be an array, and each item in\n     * the array represents a possible value for the instance value. If\n     * this attribute is defined, the instance value MUST be one of the\n     * values in the array in order for the schema to be valid.\n     *\n     * @see https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19\n     */\n    enum?: null[] | undefined;\n    type: 'null';\n}\nexport interface JSONSchema4AnySchema extends JSONSchema4Base {\n    type: 'any';\n}\nexport {};\n//# sourceMappingURL=json-schema.d.ts.map"
        }
    ]
}