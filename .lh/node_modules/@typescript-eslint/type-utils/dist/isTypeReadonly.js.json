{
    "sourceFile": "node_modules/@typescript-eslint/type-utils/dist/isTypeReadonly.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891997415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readonlynessOptionsDefaults = exports.readonlynessOptionsSchema = void 0;\nexports.isTypeReadonly = isTypeReadonly;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst propertyTypes_1 = require(\"./propertyTypes\");\nconst TypeOrValueSpecifier_1 = require(\"./TypeOrValueSpecifier\");\nvar Readonlyness;\n(function (Readonlyness) {\n    /** the type cannot be handled by the function */\n    Readonlyness[Readonlyness[\"UnknownType\"] = 1] = \"UnknownType\";\n    /** the type is mutable */\n    Readonlyness[Readonlyness[\"Mutable\"] = 2] = \"Mutable\";\n    /** the type is readonly */\n    Readonlyness[Readonlyness[\"Readonly\"] = 3] = \"Readonly\";\n})(Readonlyness || (Readonlyness = {}));\nexports.readonlynessOptionsSchema = {\n    additionalProperties: false,\n    properties: {\n        allow: TypeOrValueSpecifier_1.typeOrValueSpecifiersSchema,\n        treatMethodsAsReadonly: {\n            type: 'boolean',\n        },\n    },\n    type: 'object',\n};\nexports.readonlynessOptionsDefaults = {\n    allow: [],\n    treatMethodsAsReadonly: false,\n};\nfunction hasSymbol(node) {\n    return Object.hasOwn(node, 'symbol');\n}\nfunction isTypeReadonlyArrayOrTuple(program, type, options, seenTypes) {\n    const checker = program.getTypeChecker();\n    function checkTypeArguments(arrayType) {\n        const typeArguments = checker.getTypeArguments(arrayType);\n        // this shouldn't happen in reality as:\n        // - tuples require at least 1 type argument\n        // - ReadonlyArray requires at least 1 type argument\n        /* istanbul ignore if */ if (typeArguments.length === 0) {\n            return Readonlyness.Readonly;\n        }\n        // validate the element types are also readonly\n        if (typeArguments.some(typeArg => isTypeReadonlyRecurser(program, typeArg, options, seenTypes) ===\n            Readonlyness.Mutable)) {\n            return Readonlyness.Mutable;\n        }\n        return Readonlyness.Readonly;\n    }\n    if (checker.isArrayType(type)) {\n        const symbol = utils_1.ESLintUtils.nullThrows(type.getSymbol(), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('symbol', 'array type'));\n        const escapedName = symbol.getEscapedName();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (escapedName === 'Array') {\n            return Readonlyness.Mutable;\n        }\n        return checkTypeArguments(type);\n    }\n    if (checker.isTupleType(type)) {\n        if (!type.target.readonly) {\n            return Readonlyness.Mutable;\n        }\n        return checkTypeArguments(type);\n    }\n    return Readonlyness.UnknownType;\n}\nfunction isTypeReadonlyObject(program, type, options, seenTypes) {\n    const checker = program.getTypeChecker();\n    function checkIndexSignature(kind) {\n        const indexInfo = checker.getIndexInfoOfType(type, kind);\n        if (indexInfo) {\n            if (!indexInfo.isReadonly) {\n                return Readonlyness.Mutable;\n            }\n            if (indexInfo.type === type || seenTypes.has(indexInfo.type)) {\n                return Readonlyness.Readonly;\n            }\n            return isTypeReadonlyRecurser(program, indexInfo.type, options, seenTypes);\n        }\n        return Readonlyness.UnknownType;\n    }\n    const properties = type.getProperties();\n    if (properties.length) {\n        // ensure the properties are marked as readonly\n        for (const property of properties) {\n            if (options.treatMethodsAsReadonly) {\n                if (property.valueDeclaration != null &&\n                    hasSymbol(property.valueDeclaration) &&\n                    tsutils.isSymbolFlagSet(property.valueDeclaration.symbol, ts.SymbolFlags.Method)) {\n                    continue;\n                }\n                const declarations = property.getDeclarations();\n                const lastDeclaration = declarations != null && declarations.length > 0\n                    ? declarations[declarations.length - 1]\n                    : undefined;\n                if (lastDeclaration != null &&\n                    hasSymbol(lastDeclaration) &&\n                    tsutils.isSymbolFlagSet(lastDeclaration.symbol, ts.SymbolFlags.Method)) {\n                    continue;\n                }\n            }\n            if (tsutils.isPropertyReadonlyInType(type, property.getEscapedName(), checker)) {\n                continue;\n            }\n            const name = ts.getNameOfDeclaration(property.valueDeclaration);\n            if (name && ts.isPrivateIdentifier(name)) {\n                continue;\n            }\n            return Readonlyness.Mutable;\n        }\n        // all properties were readonly\n        // now ensure that all of the values are readonly also.\n        // do this after checking property readonly-ness as a perf optimization,\n        // as we might be able to bail out early due to a mutable property before\n        // doing this deep, potentially expensive check.\n        for (const property of properties) {\n            const propertyType = utils_1.ESLintUtils.nullThrows((0, propertyTypes_1.getTypeOfPropertyOfType)(checker, type, property), utils_1.ESLintUtils.NullThrowsReasons.MissingToken(`property \"${property.name}\"`, 'type'));\n            // handle recursive types.\n            // we only need this simple check, because a mutable recursive type will break via the above prop readonly check\n            if (seenTypes.has(propertyType)) {\n                continue;\n            }\n            if (isTypeReadonlyRecurser(program, propertyType, options, seenTypes) ===\n                Readonlyness.Mutable) {\n                return Readonlyness.Mutable;\n            }\n        }\n    }\n    const isStringIndexSigReadonly = checkIndexSignature(ts.IndexKind.String);\n    if (isStringIndexSigReadonly === Readonlyness.Mutable) {\n        return isStringIndexSigReadonly;\n    }\n    const isNumberIndexSigReadonly = checkIndexSignature(ts.IndexKind.Number);\n    if (isNumberIndexSigReadonly === Readonlyness.Mutable) {\n        return isNumberIndexSigReadonly;\n    }\n    return Readonlyness.Readonly;\n}\n// a helper function to ensure the seenTypes map is always passed down, except by the external caller\nfunction isTypeReadonlyRecurser(program, type, options, seenTypes) {\n    const checker = program.getTypeChecker();\n    seenTypes.add(type);\n    if ((0, TypeOrValueSpecifier_1.typeMatchesSomeSpecifier)(type, options.allow, program)) {\n        return Readonlyness.Readonly;\n    }\n    if (tsutils.isUnionType(type)) {\n        // all types in the union must be readonly\n        const result = tsutils\n            .unionTypeParts(type)\n            .every(t => seenTypes.has(t) ||\n            isTypeReadonlyRecurser(program, t, options, seenTypes) ===\n                Readonlyness.Readonly);\n        const readonlyness = result ? Readonlyness.Readonly : Readonlyness.Mutable;\n        return readonlyness;\n    }\n    if (tsutils.isIntersectionType(type)) {\n        // Special case for handling arrays/tuples (as readonly arrays/tuples always have mutable methods).\n        if (type.types.some(t => checker.isArrayType(t) || checker.isTupleType(t))) {\n            const allReadonlyParts = type.types.every(t => seenTypes.has(t) ||\n                isTypeReadonlyRecurser(program, t, options, seenTypes) ===\n                    Readonlyness.Readonly);\n            return allReadonlyParts ? Readonlyness.Readonly : Readonlyness.Mutable;\n        }\n        // Normal case.\n        const isReadonlyObject = isTypeReadonlyObject(program, type, options, seenTypes);\n        if (isReadonlyObject !== Readonlyness.UnknownType) {\n            return isReadonlyObject;\n        }\n    }\n    if (tsutils.isConditionalType(type)) {\n        const result = [type.root.node.trueType, type.root.node.falseType]\n            .map(checker.getTypeFromTypeNode)\n            .every(t => seenTypes.has(t) ||\n            isTypeReadonlyRecurser(program, t, options, seenTypes) ===\n                Readonlyness.Readonly);\n        const readonlyness = result ? Readonlyness.Readonly : Readonlyness.Mutable;\n        return readonlyness;\n    }\n    // all non-object, non-intersection types are readonly.\n    // this should only be primitive types\n    if (!tsutils.isObjectType(type)) {\n        return Readonlyness.Readonly;\n    }\n    // pure function types are readonly\n    if (type.getCallSignatures().length > 0 &&\n        type.getProperties().length === 0) {\n        return Readonlyness.Readonly;\n    }\n    const isReadonlyArray = isTypeReadonlyArrayOrTuple(program, type, options, seenTypes);\n    if (isReadonlyArray !== Readonlyness.UnknownType) {\n        return isReadonlyArray;\n    }\n    const isReadonlyObject = isTypeReadonlyObject(program, type, options, seenTypes);\n    /* istanbul ignore else */ if (isReadonlyObject !== Readonlyness.UnknownType) {\n        return isReadonlyObject;\n    }\n    throw new Error('Unhandled type');\n}\n/**\n * Checks if the given type is readonly\n */\nfunction isTypeReadonly(program, type, options = exports.readonlynessOptionsDefaults) {\n    return (isTypeReadonlyRecurser(program, type, options, new Set()) ===\n        Readonlyness.Readonly);\n}\n"
        }
    ]
}