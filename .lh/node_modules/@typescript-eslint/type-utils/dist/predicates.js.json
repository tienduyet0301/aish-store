{
    "sourceFile": "node_modules/@typescript-eslint/type-utils/dist/predicates.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891997583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnyType = void 0;\nexports.isNullableType = isNullableType;\nexports.isTypeArrayTypeOrUnionOfArrayTypes = isTypeArrayTypeOrUnionOfArrayTypes;\nexports.isTypeNeverType = isTypeNeverType;\nexports.isTypeUnknownType = isTypeUnknownType;\nexports.isTypeReferenceType = isTypeReferenceType;\nexports.isTypeAnyType = isTypeAnyType;\nexports.isTypeAnyArrayType = isTypeAnyArrayType;\nexports.isTypeUnknownArrayType = isTypeUnknownArrayType;\nexports.discriminateAnyType = discriminateAnyType;\nexports.typeIsOrHasBaseType = typeIsOrHasBaseType;\nexports.isTypeBigIntLiteralType = isTypeBigIntLiteralType;\nexports.isTypeTemplateLiteralType = isTypeTemplateLiteralType;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst ts = __importStar(require(\"typescript\"));\nconst typeFlagUtils_1 = require(\"./typeFlagUtils\");\nconst log = (0, debug_1.default)('typescript-eslint:type-utils:predicates');\n/**\n * Checks if the given type is (or accepts) nullable\n */\nfunction isNullableType(type) {\n    return (0, typeFlagUtils_1.isTypeFlagSet)(type, ts.TypeFlags.Any |\n        ts.TypeFlags.Unknown |\n        ts.TypeFlags.Null |\n        ts.TypeFlags.Undefined |\n        ts.TypeFlags.Void);\n}\n/**\n * Checks if the given type is either an array type,\n * or a union made up solely of array types.\n */\nfunction isTypeArrayTypeOrUnionOfArrayTypes(type, checker) {\n    for (const t of tsutils.unionTypeParts(type)) {\n        if (!checker.isArrayType(t)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @returns true if the type is `never`\n */\nfunction isTypeNeverType(type) {\n    return (0, typeFlagUtils_1.isTypeFlagSet)(type, ts.TypeFlags.Never);\n}\n/**\n * @returns true if the type is `unknown`\n */\nfunction isTypeUnknownType(type) {\n    return (0, typeFlagUtils_1.isTypeFlagSet)(type, ts.TypeFlags.Unknown);\n}\n// https://github.com/microsoft/TypeScript/blob/42aa18bf442c4df147e30deaf27261a41cbdc617/src/compiler/types.ts#L5157\nconst Nullable = ts.TypeFlags.Undefined | ts.TypeFlags.Null;\n// https://github.com/microsoft/TypeScript/blob/42aa18bf442c4df147e30deaf27261a41cbdc617/src/compiler/types.ts#L5187\nconst ObjectFlagsType = ts.TypeFlags.Any |\n    Nullable |\n    ts.TypeFlags.Never |\n    ts.TypeFlags.Object |\n    ts.TypeFlags.Union |\n    ts.TypeFlags.Intersection;\nfunction isTypeReferenceType(type) {\n    if ((type.flags & ObjectFlagsType) === 0) {\n        return false;\n    }\n    const objectTypeFlags = type.objectFlags;\n    return (objectTypeFlags & ts.ObjectFlags.Reference) !== 0;\n}\n/**\n * @returns true if the type is `any`\n */\nfunction isTypeAnyType(type) {\n    if ((0, typeFlagUtils_1.isTypeFlagSet)(type, ts.TypeFlags.Any)) {\n        if (type.intrinsicName === 'error') {\n            log('Found an \"error\" any type');\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * @returns true if the type is `any[]`\n */\nfunction isTypeAnyArrayType(type, checker) {\n    return (checker.isArrayType(type) &&\n        isTypeAnyType(checker.getTypeArguments(type)[0]));\n}\n/**\n * @returns true if the type is `unknown[]`\n */\nfunction isTypeUnknownArrayType(type, checker) {\n    return (checker.isArrayType(type) &&\n        isTypeUnknownType(checker.getTypeArguments(type)[0]));\n}\nvar AnyType;\n(function (AnyType) {\n    AnyType[AnyType[\"Any\"] = 0] = \"Any\";\n    AnyType[AnyType[\"PromiseAny\"] = 1] = \"PromiseAny\";\n    AnyType[AnyType[\"AnyArray\"] = 2] = \"AnyArray\";\n    AnyType[AnyType[\"Safe\"] = 3] = \"Safe\";\n})(AnyType || (exports.AnyType = AnyType = {}));\n/**\n * @returns `AnyType.Any` if the type is `any`, `AnyType.AnyArray` if the type is `any[]` or `readonly any[]`, `AnyType.PromiseAny` if the type is `Promise<any>`,\n *          otherwise it returns `AnyType.Safe`.\n */\nfunction discriminateAnyType(type, checker, program, tsNode) {\n    if (isTypeAnyType(type)) {\n        return AnyType.Any;\n    }\n    if (isTypeAnyArrayType(type, checker)) {\n        return AnyType.AnyArray;\n    }\n    for (const part of tsutils.typeParts(type)) {\n        if (tsutils.isThenableType(checker, tsNode, part)) {\n            const awaitedType = checker.getAwaitedType(part);\n            if (awaitedType) {\n                const awaitedAnyType = discriminateAnyType(awaitedType, checker, program, tsNode);\n                if (awaitedAnyType === AnyType.Any) {\n                    return AnyType.PromiseAny;\n                }\n            }\n        }\n    }\n    return AnyType.Safe;\n}\n/**\n * @returns Whether a type is an instance of the parent type, including for the parent's base types.\n */\nfunction typeIsOrHasBaseType(type, parentType) {\n    const parentSymbol = parentType.getSymbol();\n    if (!type.getSymbol() || !parentSymbol) {\n        return false;\n    }\n    const typeAndBaseTypes = [type];\n    const ancestorTypes = type.getBaseTypes();\n    if (ancestorTypes) {\n        typeAndBaseTypes.push(...ancestorTypes);\n    }\n    for (const baseType of typeAndBaseTypes) {\n        const baseSymbol = baseType.getSymbol();\n        if (baseSymbol && baseSymbol.name === parentSymbol.name) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isTypeBigIntLiteralType(type) {\n    return (0, typeFlagUtils_1.isTypeFlagSet)(type, ts.TypeFlags.BigIntLiteral);\n}\nfunction isTypeTemplateLiteralType(type) {\n    return (0, typeFlagUtils_1.isTypeFlagSet)(type, ts.TypeFlags.TemplateLiteral);\n}\n"
        }
    ]
}