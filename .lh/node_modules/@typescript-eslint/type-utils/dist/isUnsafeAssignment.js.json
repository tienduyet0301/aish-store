{
    "sourceFile": "node_modules/@typescript-eslint/type-utils/dist/isUnsafeAssignment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891997502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isUnsafeAssignment = isUnsafeAssignment;\nconst utils_1 = require(\"@typescript-eslint/utils\");\nconst tsutils = __importStar(require(\"ts-api-utils\"));\nconst predicates_1 = require(\"./predicates\");\n/**\n * Does a simple check to see if there is an any being assigned to a non-any type.\n *\n * This also checks generic positions to ensure there's no unsafe sub-assignments.\n * Note: in the case of generic positions, it makes the assumption that the two types are the same.\n *\n * @example See tests for examples\n *\n * @returns false if it's safe, or an object with the two types if it's unsafe\n */\nfunction isUnsafeAssignment(type, receiver, checker, senderNode) {\n    return isUnsafeAssignmentWorker(type, receiver, checker, senderNode, new Map());\n}\nfunction isUnsafeAssignmentWorker(type, receiver, checker, senderNode, visited) {\n    if ((0, predicates_1.isTypeAnyType)(type)) {\n        // Allow assignment of any ==> unknown.\n        if ((0, predicates_1.isTypeUnknownType)(receiver)) {\n            return false;\n        }\n        if (!(0, predicates_1.isTypeAnyType)(receiver)) {\n            return { receiver, sender: type };\n        }\n    }\n    const typeAlreadyVisited = visited.get(type);\n    if (typeAlreadyVisited) {\n        if (typeAlreadyVisited.has(receiver)) {\n            return false;\n        }\n        typeAlreadyVisited.add(receiver);\n    }\n    else {\n        visited.set(type, new Set([receiver]));\n    }\n    if (tsutils.isTypeReference(type) && tsutils.isTypeReference(receiver)) {\n        // TODO - figure out how to handle cases like this,\n        // where the types are assignable, but not the same type\n        /*\n        function foo(): ReadonlySet<number> { return new Set<any>(); }\n    \n        // and\n    \n        type Test<T> = { prop: T }\n        type Test2 = { prop: string }\n        declare const a: Test<any>;\n        const b: Test2 = a;\n        */\n        if (type.target !== receiver.target) {\n            // if the type references are different, assume safe, as we won't know how to compare the two types\n            // the generic positions might not be equivalent for both types\n            return false;\n        }\n        if (senderNode?.type === utils_1.AST_NODE_TYPES.NewExpression &&\n            senderNode.callee.type === utils_1.AST_NODE_TYPES.Identifier &&\n            senderNode.callee.name === 'Map' &&\n            senderNode.arguments.length === 0 &&\n            senderNode.typeArguments == null) {\n            // special case to handle `new Map()`\n            // unfortunately Map's default empty constructor is typed to return `Map<any, any>` :(\n            // https://github.com/typescript-eslint/typescript-eslint/issues/2109#issuecomment-634144396\n            return false;\n        }\n        const typeArguments = type.typeArguments ?? [];\n        const receiverTypeArguments = receiver.typeArguments ?? [];\n        for (let i = 0; i < typeArguments.length; i += 1) {\n            const arg = typeArguments[i];\n            const receiverArg = receiverTypeArguments[i];\n            const unsafe = isUnsafeAssignmentWorker(arg, receiverArg, checker, senderNode, visited);\n            if (unsafe) {\n                return { receiver, sender: type };\n            }\n        }\n        return false;\n    }\n    return false;\n}\n"
        }
    ]
}