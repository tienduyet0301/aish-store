{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/estree-to-ts-node-types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892002677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { AST_NODE_TYPES, TSESTree } from '@typescript-eslint/types';\nimport type * as ts from 'typescript';\nimport type { TSNode } from './ts-nodes';\nexport interface EstreeToTsNodeTypes {\n    [AST_NODE_TYPES.AccessorProperty]: ts.PropertyDeclaration;\n    [AST_NODE_TYPES.ArrayExpression]: ts.ArrayLiteralExpression;\n    [AST_NODE_TYPES.ArrayPattern]: ts.ArrayBindingPattern | ts.ArrayLiteralExpression;\n    [AST_NODE_TYPES.ArrowFunctionExpression]: ts.ArrowFunction;\n    [AST_NODE_TYPES.AssignmentExpression]: ts.BinaryExpression;\n    [AST_NODE_TYPES.AssignmentPattern]: ts.BinaryExpression | ts.BindingElement | ts.ParameterDeclaration | ts.ShorthandPropertyAssignment;\n    [AST_NODE_TYPES.AwaitExpression]: ts.AwaitExpression;\n    [AST_NODE_TYPES.BinaryExpression]: ts.BinaryExpression;\n    [AST_NODE_TYPES.BlockStatement]: ts.Block;\n    [AST_NODE_TYPES.BreakStatement]: ts.BreakStatement;\n    [AST_NODE_TYPES.CallExpression]: ts.CallExpression;\n    [AST_NODE_TYPES.CatchClause]: ts.CatchClause;\n    [AST_NODE_TYPES.ChainExpression]: ts.CallExpression | ts.ElementAccessExpression | ts.NonNullExpression | ts.PropertyAccessExpression;\n    [AST_NODE_TYPES.ClassBody]: ts.ClassDeclaration | ts.ClassExpression;\n    [AST_NODE_TYPES.ClassDeclaration]: ts.ClassDeclaration;\n    [AST_NODE_TYPES.ClassExpression]: ts.ClassExpression;\n    [AST_NODE_TYPES.ConditionalExpression]: ts.ConditionalExpression;\n    [AST_NODE_TYPES.ContinueStatement]: ts.ContinueStatement;\n    [AST_NODE_TYPES.DebuggerStatement]: ts.DebuggerStatement;\n    [AST_NODE_TYPES.Decorator]: ts.Decorator;\n    [AST_NODE_TYPES.DoWhileStatement]: ts.DoStatement;\n    [AST_NODE_TYPES.EmptyStatement]: ts.EmptyStatement;\n    [AST_NODE_TYPES.ExportAllDeclaration]: ts.ExportDeclaration;\n    [AST_NODE_TYPES.ExportDefaultDeclaration]: ts.ClassDeclaration | ts.ClassExpression | ts.EnumDeclaration | ts.ExportAssignment | ts.FunctionDeclaration | ts.InterfaceDeclaration | ts.ModuleDeclaration | ts.TypeAliasDeclaration | ts.VariableStatement;\n    [AST_NODE_TYPES.ExportNamedDeclaration]: ts.ClassDeclaration | ts.ClassExpression | ts.EnumDeclaration | ts.ExportDeclaration | ts.FunctionDeclaration | ts.ImportEqualsDeclaration | ts.InterfaceDeclaration | ts.ModuleDeclaration | ts.TypeAliasDeclaration | ts.VariableStatement;\n    [AST_NODE_TYPES.ExportSpecifier]: ts.ExportSpecifier;\n    [AST_NODE_TYPES.ExpressionStatement]: ts.ExpressionStatement;\n    [AST_NODE_TYPES.ForInStatement]: ts.ForInStatement;\n    [AST_NODE_TYPES.ForOfStatement]: ts.ForOfStatement;\n    [AST_NODE_TYPES.ForStatement]: ts.ForStatement;\n    [AST_NODE_TYPES.FunctionDeclaration]: ts.FunctionDeclaration;\n    [AST_NODE_TYPES.FunctionExpression]: ts.ConstructorDeclaration | ts.FunctionExpression | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;\n    [AST_NODE_TYPES.Identifier]: ts.ConstructorDeclaration | ts.Identifier | ts.Token<ts.SyntaxKind.ImportKeyword | ts.SyntaxKind.NewKeyword>;\n    [AST_NODE_TYPES.IfStatement]: ts.IfStatement;\n    [AST_NODE_TYPES.PrivateIdentifier]: ts.PrivateIdentifier;\n    [AST_NODE_TYPES.PropertyDefinition]: ts.PropertyDeclaration;\n    [AST_NODE_TYPES.ImportAttribute]: 'ImportAttribute' extends keyof typeof ts ? ts.ImportAttribute : ts.AssertEntry;\n    [AST_NODE_TYPES.ImportDeclaration]: ts.ImportDeclaration;\n    [AST_NODE_TYPES.ImportDefaultSpecifier]: ts.ImportClause;\n    [AST_NODE_TYPES.ImportExpression]: ts.CallExpression;\n    [AST_NODE_TYPES.ImportNamespaceSpecifier]: ts.NamespaceImport;\n    [AST_NODE_TYPES.ImportSpecifier]: ts.ImportSpecifier;\n    [AST_NODE_TYPES.JSXAttribute]: ts.JsxAttribute;\n    [AST_NODE_TYPES.JSXClosingElement]: ts.JsxClosingElement;\n    [AST_NODE_TYPES.JSXClosingFragment]: ts.JsxClosingFragment;\n    [AST_NODE_TYPES.JSXElement]: ts.JsxElement | ts.JsxSelfClosingElement;\n    [AST_NODE_TYPES.JSXEmptyExpression]: ts.JsxExpression;\n    [AST_NODE_TYPES.JSXExpressionContainer]: ts.JsxExpression;\n    [AST_NODE_TYPES.JSXFragment]: ts.JsxFragment;\n    [AST_NODE_TYPES.JSXIdentifier]: ts.Identifier | ts.ThisExpression;\n    [AST_NODE_TYPES.JSXMemberExpression]: ts.PropertyAccessExpression;\n    [AST_NODE_TYPES.JSXNamespacedName]: ts.JsxNamespacedName;\n    [AST_NODE_TYPES.JSXOpeningElement]: ts.JsxOpeningElement | ts.JsxSelfClosingElement;\n    [AST_NODE_TYPES.JSXOpeningFragment]: ts.JsxOpeningFragment;\n    [AST_NODE_TYPES.JSXSpreadAttribute]: ts.JsxSpreadAttribute;\n    [AST_NODE_TYPES.JSXSpreadChild]: ts.JsxExpression;\n    [AST_NODE_TYPES.JSXText]: ts.JsxText;\n    [AST_NODE_TYPES.LabeledStatement]: ts.LabeledStatement;\n    [AST_NODE_TYPES.Literal]: ts.BigIntLiteral | ts.BooleanLiteral | ts.NullLiteral | ts.NumericLiteral | ts.RegularExpressionLiteral | ts.StringLiteral;\n    [AST_NODE_TYPES.LogicalExpression]: ts.BinaryExpression;\n    [AST_NODE_TYPES.MemberExpression]: ts.ElementAccessExpression | ts.PropertyAccessExpression;\n    [AST_NODE_TYPES.MetaProperty]: ts.MetaProperty;\n    [AST_NODE_TYPES.MethodDefinition]: ts.ConstructorDeclaration | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;\n    [AST_NODE_TYPES.NewExpression]: ts.NewExpression;\n    [AST_NODE_TYPES.ObjectExpression]: ts.ObjectLiteralExpression;\n    [AST_NODE_TYPES.ObjectPattern]: ts.ObjectBindingPattern | ts.ObjectLiteralExpression;\n    [AST_NODE_TYPES.Program]: ts.SourceFile;\n    [AST_NODE_TYPES.Property]: ts.BindingElement | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.PropertyAssignment | ts.SetAccessorDeclaration | ts.ShorthandPropertyAssignment;\n    [AST_NODE_TYPES.RestElement]: ts.BindingElement | ts.ParameterDeclaration | ts.SpreadAssignment | ts.SpreadElement;\n    [AST_NODE_TYPES.ReturnStatement]: ts.ReturnStatement;\n    [AST_NODE_TYPES.SequenceExpression]: ts.BinaryExpression;\n    [AST_NODE_TYPES.SpreadElement]: ts.SpreadAssignment | ts.SpreadElement;\n    [AST_NODE_TYPES.StaticBlock]: ts.ClassStaticBlockDeclaration;\n    [AST_NODE_TYPES.Super]: ts.SuperExpression;\n    [AST_NODE_TYPES.SwitchCase]: ts.CaseClause | ts.DefaultClause;\n    [AST_NODE_TYPES.SwitchStatement]: ts.SwitchStatement;\n    [AST_NODE_TYPES.TaggedTemplateExpression]: ts.TaggedTemplateExpression;\n    [AST_NODE_TYPES.TemplateElement]: ts.NoSubstitutionTemplateLiteral | ts.TemplateHead | ts.TemplateMiddle | ts.TemplateTail;\n    [AST_NODE_TYPES.TemplateLiteral]: ts.NoSubstitutionTemplateLiteral | ts.TemplateExpression;\n    [AST_NODE_TYPES.ThisExpression]: ts.Identifier | ts.KeywordTypeNode | ts.ThisExpression;\n    [AST_NODE_TYPES.ThrowStatement]: ts.ThrowStatement;\n    [AST_NODE_TYPES.TryStatement]: ts.TryStatement;\n    [AST_NODE_TYPES.TSAbstractAccessorProperty]: ts.PropertyDeclaration;\n    [AST_NODE_TYPES.TSAbstractMethodDefinition]: ts.ConstructorDeclaration | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;\n    [AST_NODE_TYPES.TSAbstractPropertyDefinition]: ts.PropertyDeclaration;\n    [AST_NODE_TYPES.TSArrayType]: ts.ArrayTypeNode;\n    [AST_NODE_TYPES.TSAsExpression]: ts.AsExpression;\n    [AST_NODE_TYPES.TSCallSignatureDeclaration]: ts.CallSignatureDeclaration;\n    [AST_NODE_TYPES.TSClassImplements]: ts.ExpressionWithTypeArguments;\n    [AST_NODE_TYPES.TSConditionalType]: ts.ConditionalTypeNode;\n    [AST_NODE_TYPES.TSConstructorType]: ts.ConstructorTypeNode;\n    [AST_NODE_TYPES.TSConstructSignatureDeclaration]: ts.ConstructSignatureDeclaration;\n    [AST_NODE_TYPES.TSDeclareFunction]: ts.FunctionDeclaration;\n    [AST_NODE_TYPES.TSEnumBody]: ts.EnumDeclaration;\n    [AST_NODE_TYPES.TSEnumDeclaration]: ts.EnumDeclaration;\n    [AST_NODE_TYPES.TSEnumMember]: ts.EnumMember;\n    [AST_NODE_TYPES.TSExportAssignment]: ts.ExportAssignment;\n    [AST_NODE_TYPES.TSExternalModuleReference]: ts.ExternalModuleReference;\n    [AST_NODE_TYPES.TSFunctionType]: ts.FunctionTypeNode;\n    [AST_NODE_TYPES.TSImportEqualsDeclaration]: ts.ImportEqualsDeclaration;\n    [AST_NODE_TYPES.TSImportType]: ts.ImportTypeNode;\n    [AST_NODE_TYPES.TSIndexedAccessType]: ts.IndexedAccessTypeNode;\n    [AST_NODE_TYPES.TSIndexSignature]: ts.IndexSignatureDeclaration;\n    [AST_NODE_TYPES.TSInferType]: ts.InferTypeNode;\n    [AST_NODE_TYPES.TSInstantiationExpression]: ts.ExpressionWithTypeArguments;\n    [AST_NODE_TYPES.TSInterfaceBody]: ts.InterfaceDeclaration;\n    [AST_NODE_TYPES.TSInterfaceDeclaration]: ts.InterfaceDeclaration;\n    [AST_NODE_TYPES.TSInterfaceHeritage]: ts.ExpressionWithTypeArguments;\n    [AST_NODE_TYPES.TSIntersectionType]: ts.IntersectionTypeNode;\n    [AST_NODE_TYPES.TSLiteralType]: ts.LiteralTypeNode;\n    [AST_NODE_TYPES.TSMappedType]: ts.MappedTypeNode;\n    [AST_NODE_TYPES.TSMethodSignature]: ts.GetAccessorDeclaration | ts.MethodSignature | ts.SetAccessorDeclaration;\n    [AST_NODE_TYPES.TSModuleBlock]: ts.ModuleBlock;\n    [AST_NODE_TYPES.TSModuleDeclaration]: ts.ModuleDeclaration;\n    [AST_NODE_TYPES.TSNamedTupleMember]: ts.NamedTupleMember;\n    [AST_NODE_TYPES.TSNamespaceExportDeclaration]: ts.NamespaceExportDeclaration;\n    [AST_NODE_TYPES.TSNonNullExpression]: ts.NonNullExpression;\n    [AST_NODE_TYPES.TSOptionalType]: ts.OptionalTypeNode;\n    [AST_NODE_TYPES.TSParameterProperty]: ts.ParameterDeclaration;\n    [AST_NODE_TYPES.TSPropertySignature]: ts.PropertySignature;\n    [AST_NODE_TYPES.TSQualifiedName]: ts.Identifier | ts.QualifiedName;\n    [AST_NODE_TYPES.TSRestType]: ts.NamedTupleMember | ts.RestTypeNode;\n    [AST_NODE_TYPES.TSSatisfiesExpression]: ts.SatisfiesExpression;\n    [AST_NODE_TYPES.TSTemplateLiteralType]: ts.TemplateLiteralTypeNode;\n    [AST_NODE_TYPES.TSThisType]: ts.ThisTypeNode;\n    [AST_NODE_TYPES.TSTupleType]: ts.TupleTypeNode;\n    [AST_NODE_TYPES.TSTypeAliasDeclaration]: ts.TypeAliasDeclaration;\n    [AST_NODE_TYPES.TSTypeAnnotation]: undefined;\n    [AST_NODE_TYPES.TSTypeAssertion]: ts.TypeAssertion;\n    [AST_NODE_TYPES.TSTypeLiteral]: ts.TypeLiteralNode;\n    [AST_NODE_TYPES.TSTypeOperator]: ts.TypeOperatorNode;\n    [AST_NODE_TYPES.TSTypeParameter]: ts.TypeParameterDeclaration;\n    [AST_NODE_TYPES.TSTypeParameterDeclaration]: undefined;\n    [AST_NODE_TYPES.TSTypeParameterInstantiation]: ts.CallExpression | ts.ExpressionWithTypeArguments | ts.ImportTypeNode | ts.JsxOpeningElement | ts.JsxSelfClosingElement | ts.NewExpression | ts.TaggedTemplateExpression | ts.TypeQueryNode | ts.TypeReferenceNode;\n    [AST_NODE_TYPES.TSTypePredicate]: ts.TypePredicateNode;\n    [AST_NODE_TYPES.TSTypeQuery]: ts.ImportTypeNode | ts.TypeQueryNode;\n    [AST_NODE_TYPES.TSTypeReference]: ts.TypeReferenceNode;\n    [AST_NODE_TYPES.TSUnionType]: ts.UnionTypeNode;\n    [AST_NODE_TYPES.UnaryExpression]: ts.DeleteExpression | ts.PostfixUnaryExpression | ts.PrefixUnaryExpression | ts.TypeOfExpression | ts.VoidExpression;\n    [AST_NODE_TYPES.UpdateExpression]: ts.PostfixUnaryExpression | ts.PrefixUnaryExpression;\n    [AST_NODE_TYPES.VariableDeclaration]: ts.VariableDeclarationList | ts.VariableStatement;\n    [AST_NODE_TYPES.VariableDeclarator]: ts.VariableDeclaration;\n    [AST_NODE_TYPES.WhileStatement]: ts.WhileStatement;\n    [AST_NODE_TYPES.WithStatement]: ts.WithStatement;\n    [AST_NODE_TYPES.YieldExpression]: ts.YieldExpression;\n    [AST_NODE_TYPES.TSEmptyBodyFunctionExpression]: ts.ConstructorDeclaration | ts.FunctionExpression | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;\n    [AST_NODE_TYPES.TSAbstractKeyword]: ts.Token<ts.SyntaxKind.AbstractKeyword>;\n    [AST_NODE_TYPES.TSAnyKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSBigIntKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSBooleanKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSIntrinsicKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSNeverKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSNullKeyword]: ts.KeywordTypeNode | ts.NullLiteral;\n    [AST_NODE_TYPES.TSNumberKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSObjectKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSStringKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSSymbolKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSUndefinedKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSUnknownKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSVoidKeyword]: ts.KeywordTypeNode;\n    [AST_NODE_TYPES.TSAsyncKeyword]: ts.Token<ts.SyntaxKind.AsyncKeyword>;\n    [AST_NODE_TYPES.TSDeclareKeyword]: ts.Token<ts.SyntaxKind.DeclareKeyword>;\n    [AST_NODE_TYPES.TSExportKeyword]: ts.Token<ts.SyntaxKind.ExportKeyword>;\n    [AST_NODE_TYPES.TSPrivateKeyword]: ts.Token<ts.SyntaxKind.PrivateKeyword>;\n    [AST_NODE_TYPES.TSProtectedKeyword]: ts.Token<ts.SyntaxKind.ProtectedKeyword>;\n    [AST_NODE_TYPES.TSPublicKeyword]: ts.Token<ts.SyntaxKind.PublicKeyword>;\n    [AST_NODE_TYPES.TSReadonlyKeyword]: ts.Token<ts.SyntaxKind.ReadonlyKeyword>;\n    [AST_NODE_TYPES.TSStaticKeyword]: ts.Token<ts.SyntaxKind.StaticKeyword>;\n}\n/**\n * Maps TSESTree AST Node type to the expected TypeScript AST Node type(s).\n * This mapping is based on the internal logic of the parser.\n */\nexport type TSESTreeToTSNode<T extends TSESTree.Node = TSESTree.Node> = Extract<ts.Token<ts.SyntaxKind.ImportKeyword | ts.SyntaxKind.NewKeyword> | TSNode, EstreeToTsNodeTypes[T['type']]>;\n//# sourceMappingURL=estree-to-ts-node-types.d.ts.map"
        }
    ]
}