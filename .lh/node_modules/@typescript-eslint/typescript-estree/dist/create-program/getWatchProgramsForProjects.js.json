{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/create-program/getWatchProgramsForProjects.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891999632,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearWatchCaches = clearWatchCaches;\nexports.getWatchProgramsForProjects = getWatchProgramsForProjects;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst ts = __importStar(require(\"typescript\"));\nconst source_files_1 = require(\"../source-files\");\nconst shared_1 = require(\"./shared\");\nconst log = (0, debug_1.default)('typescript-eslint:typescript-estree:create-program:getWatchProgramsForProjects');\n/**\n * Maps tsconfig paths to their corresponding file contents and resulting watches\n */\nconst knownWatchProgramMap = new Map();\n/**\n * Maps file/folder paths to their set of corresponding watch callbacks\n * There may be more than one per file/folder if a file/folder is shared between projects\n */\nconst fileWatchCallbackTrackingMap = new Map();\nconst folderWatchCallbackTrackingMap = new Map();\n/**\n * Stores the list of known files for each program\n */\nconst programFileListCache = new Map();\n/**\n * Caches the last modified time of the tsconfig files\n */\nconst tsconfigLastModifiedTimestampCache = new Map();\nconst parsedFilesSeenHash = new Map();\n/**\n * Clear all of the parser caches.\n * This should only be used in testing to ensure the parser is clean between tests.\n */\nfunction clearWatchCaches() {\n    knownWatchProgramMap.clear();\n    fileWatchCallbackTrackingMap.clear();\n    folderWatchCallbackTrackingMap.clear();\n    parsedFilesSeenHash.clear();\n    programFileListCache.clear();\n    tsconfigLastModifiedTimestampCache.clear();\n}\nfunction saveWatchCallback(trackingMap) {\n    return (fileName, callback) => {\n        const normalizedFileName = (0, shared_1.getCanonicalFileName)(fileName);\n        const watchers = (() => {\n            let watchers = trackingMap.get(normalizedFileName);\n            if (!watchers) {\n                watchers = new Set();\n                trackingMap.set(normalizedFileName, watchers);\n            }\n            return watchers;\n        })();\n        watchers.add(callback);\n        return {\n            close: () => {\n                watchers.delete(callback);\n            },\n        };\n    };\n}\n/**\n * Holds information about the file currently being linted\n */\nconst currentLintOperationState = {\n    code: '',\n    filePath: '',\n};\n/**\n * Appropriately report issues found when reading a config file\n * @param diagnostic The diagnostic raised when creating a program\n */\nfunction diagnosticReporter(diagnostic) {\n    throw new Error(ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine));\n}\nfunction updateCachedFileList(tsconfigPath, program) {\n    const fileList = new Set(program.getRootFileNames().map(f => (0, shared_1.getCanonicalFileName)(f)));\n    programFileListCache.set(tsconfigPath, fileList);\n    return fileList;\n}\n/**\n * Calculate project environments using options provided by consumer and paths from config\n * @param parseSettings Internal settings for parsing the file\n * @returns The programs corresponding to the supplied tsconfig paths\n */\nfunction getWatchProgramsForProjects(parseSettings) {\n    const filePath = (0, shared_1.getCanonicalFileName)(parseSettings.filePath);\n    const results = [];\n    // preserve reference to code and file being linted\n    currentLintOperationState.code = parseSettings.code;\n    currentLintOperationState.filePath = filePath;\n    // Update file version if necessary\n    const fileWatchCallbacks = fileWatchCallbackTrackingMap.get(filePath);\n    const codeHash = (0, shared_1.createHash)((0, source_files_1.getCodeText)(parseSettings.code));\n    if (parsedFilesSeenHash.get(filePath) !== codeHash &&\n        fileWatchCallbacks &&\n        fileWatchCallbacks.size > 0) {\n        fileWatchCallbacks.forEach(cb => cb(filePath, ts.FileWatcherEventKind.Changed));\n    }\n    const currentProjectsFromSettings = new Map(parseSettings.projects);\n    /*\n     * before we go into the process of attempting to find and update every program\n     * see if we know of a program that contains this file\n     */\n    for (const [tsconfigPath, existingWatch] of knownWatchProgramMap.entries()) {\n        if (!currentProjectsFromSettings.has(tsconfigPath)) {\n            // the current parser run doesn't specify this tsconfig in parserOptions.project\n            // so we don't want to consider it for caching purposes.\n            //\n            // if we did consider it we might return a program for a project\n            // that wasn't specified in the current parser run (which is obv bad!).\n            continue;\n        }\n        let fileList = programFileListCache.get(tsconfigPath);\n        let updatedProgram = null;\n        if (!fileList) {\n            updatedProgram = existingWatch.getProgram().getProgram();\n            fileList = updateCachedFileList(tsconfigPath, updatedProgram);\n        }\n        if (fileList.has(filePath)) {\n            log('Found existing program for file. %s', filePath);\n            updatedProgram ??= existingWatch.getProgram().getProgram();\n            // sets parent pointers in source files\n            updatedProgram.getTypeChecker();\n            return [updatedProgram];\n        }\n    }\n    log('File did not belong to any existing programs, moving to create/update. %s', filePath);\n    /*\n     * We don't know of a program that contains the file, this means that either:\n     * - the required program hasn't been created yet, or\n     * - the file is new/renamed, and the program hasn't been updated.\n     */\n    for (const tsconfigPath of parseSettings.projects) {\n        const existingWatch = knownWatchProgramMap.get(tsconfigPath[0]);\n        if (existingWatch) {\n            const updatedProgram = maybeInvalidateProgram(existingWatch, filePath, tsconfigPath[0]);\n            if (!updatedProgram) {\n                continue;\n            }\n            // sets parent pointers in source files\n            updatedProgram.getTypeChecker();\n            // cache and check the file list\n            const fileList = updateCachedFileList(tsconfigPath[0], updatedProgram);\n            if (fileList.has(filePath)) {\n                log('Found updated program for file. %s', filePath);\n                // we can return early because we know this program contains the file\n                return [updatedProgram];\n            }\n            results.push(updatedProgram);\n            continue;\n        }\n        const programWatch = createWatchProgram(tsconfigPath[1], parseSettings);\n        knownWatchProgramMap.set(tsconfigPath[0], programWatch);\n        const program = programWatch.getProgram().getProgram();\n        // sets parent pointers in source files\n        program.getTypeChecker();\n        // cache and check the file list\n        const fileList = updateCachedFileList(tsconfigPath[0], program);\n        if (fileList.has(filePath)) {\n            log('Found program for file. %s', filePath);\n            // we can return early because we know this program contains the file\n            return [program];\n        }\n        results.push(program);\n    }\n    return results;\n}\nfunction createWatchProgram(tsconfigPath, parseSettings) {\n    log('Creating watch program for %s.', tsconfigPath);\n    // create compiler host\n    const watchCompilerHost = ts.createWatchCompilerHost(tsconfigPath, (0, shared_1.createDefaultCompilerOptionsFromExtra)(parseSettings), ts.sys, ts.createAbstractBuilder, diagnosticReporter, \n    // TODO: file issue on TypeScript to suggest making optional?\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    /*reportWatchStatus*/ () => { });\n    watchCompilerHost.jsDocParsingMode = parseSettings.jsDocParsingMode;\n    // ensure readFile reads the code being linted instead of the copy on disk\n    const oldReadFile = watchCompilerHost.readFile;\n    watchCompilerHost.readFile = (filePathIn, encoding) => {\n        const filePath = (0, shared_1.getCanonicalFileName)(filePathIn);\n        const fileContent = filePath === currentLintOperationState.filePath\n            ? (0, source_files_1.getCodeText)(currentLintOperationState.code)\n            : oldReadFile(filePath, encoding);\n        if (fileContent != null) {\n            parsedFilesSeenHash.set(filePath, (0, shared_1.createHash)(fileContent));\n        }\n        return fileContent;\n    };\n    // ensure process reports error on failure instead of exiting process immediately\n    watchCompilerHost.onUnRecoverableConfigFileDiagnostic = diagnosticReporter;\n    // ensure process doesn't emit programs\n    watchCompilerHost.afterProgramCreate = (program) => {\n        // report error if there are any errors in the config file\n        const configFileDiagnostics = program\n            .getConfigFileParsingDiagnostics()\n            .filter(diag => diag.category === ts.DiagnosticCategory.Error && diag.code !== 18003);\n        if (configFileDiagnostics.length > 0) {\n            diagnosticReporter(configFileDiagnostics[0]);\n        }\n    };\n    /*\n     * From the CLI, the file watchers won't matter, as the files will be parsed once and then forgotten.\n     * When running from an IDE, these watchers will let us tell typescript about changes.\n     *\n     * ESLint IDE plugins will send us unfinished file content as the user types (before it's saved to disk).\n     * We use the file watchers to tell typescript about this latest file content.\n     *\n     * When files are created (or renamed), we won't know about them because we have no filesystem watchers attached.\n     * We use the folder watchers to tell typescript it needs to go and find new files in the project folders.\n     */\n    watchCompilerHost.watchFile = saveWatchCallback(fileWatchCallbackTrackingMap);\n    watchCompilerHost.watchDirectory = saveWatchCallback(folderWatchCallbackTrackingMap);\n    // allow files with custom extensions to be included in program (uses internal ts api)\n    const oldOnDirectoryStructureHostCreate = watchCompilerHost.onCachedDirectoryStructureHostCreate;\n    watchCompilerHost.onCachedDirectoryStructureHostCreate = (host) => {\n        const oldReadDirectory = host.readDirectory;\n        host.readDirectory = (path, extensions, exclude, include, depth) => oldReadDirectory(path, !extensions\n            ? undefined\n            : [...extensions, ...parseSettings.extraFileExtensions], exclude, include, depth);\n        oldOnDirectoryStructureHostCreate(host);\n    };\n    // This works only on 3.9\n    watchCompilerHost.extraFileExtensions = parseSettings.extraFileExtensions.map(extension => ({\n        extension,\n        isMixedContent: true,\n        scriptKind: ts.ScriptKind.Deferred,\n    }));\n    watchCompilerHost.trace = log;\n    // Since we don't want to asynchronously update program we want to disable timeout methods\n    // So any changes in the program will be delayed and updated when getProgram is called on watch\n    watchCompilerHost.setTimeout = undefined;\n    watchCompilerHost.clearTimeout = undefined;\n    return ts.createWatchProgram(watchCompilerHost);\n}\nfunction hasTSConfigChanged(tsconfigPath) {\n    const stat = node_fs_1.default.statSync(tsconfigPath);\n    const lastModifiedAt = stat.mtimeMs;\n    const cachedLastModifiedAt = tsconfigLastModifiedTimestampCache.get(tsconfigPath);\n    tsconfigLastModifiedTimestampCache.set(tsconfigPath, lastModifiedAt);\n    if (cachedLastModifiedAt == null) {\n        return false;\n    }\n    return Math.abs(cachedLastModifiedAt - lastModifiedAt) > Number.EPSILON;\n}\nfunction maybeInvalidateProgram(existingWatch, filePath, tsconfigPath) {\n    /*\n     * By calling watchProgram.getProgram(), it will trigger a resync of the program based on\n     * whatever new file content we've given it from our input.\n     */\n    let updatedProgram = existingWatch.getProgram().getProgram();\n    // In case this change causes problems in larger real world codebases\n    // Provide an escape hatch so people don't _have_ to revert to an older version\n    if (process.env.TSESTREE_NO_INVALIDATION === 'true') {\n        return updatedProgram;\n    }\n    if (hasTSConfigChanged(tsconfigPath)) {\n        /*\n         * If the stat of the tsconfig has changed, that could mean the include/exclude/files lists has changed\n         * We need to make sure typescript knows this so it can update appropriately\n         */\n        log('tsconfig has changed - triggering program update. %s', tsconfigPath);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        fileWatchCallbackTrackingMap\n            .get(tsconfigPath)\n            .forEach(cb => cb(tsconfigPath, ts.FileWatcherEventKind.Changed));\n        // tsconfig change means that the file list more than likely changed, so clear the cache\n        programFileListCache.delete(tsconfigPath);\n    }\n    let sourceFile = updatedProgram.getSourceFile(filePath);\n    if (sourceFile) {\n        return updatedProgram;\n    }\n    /*\n     * Missing source file means our program's folder structure might be out of date.\n     * So we need to tell typescript it needs to update the correct folder.\n     */\n    log('File was not found in program - triggering folder update. %s', filePath);\n    // Find the correct directory callback by climbing the folder tree\n    const currentDir = (0, shared_1.canonicalDirname)(filePath);\n    let current = null;\n    let next = currentDir;\n    let hasCallback = false;\n    while (current !== next) {\n        current = next;\n        const folderWatchCallbacks = folderWatchCallbackTrackingMap.get(current);\n        if (folderWatchCallbacks) {\n            for (const cb of folderWatchCallbacks) {\n                if (currentDir !== current) {\n                    cb(currentDir, ts.FileWatcherEventKind.Changed);\n                }\n                cb(current, ts.FileWatcherEventKind.Changed);\n            }\n            hasCallback = true;\n        }\n        next = (0, shared_1.canonicalDirname)(current);\n    }\n    if (!hasCallback) {\n        /*\n         * No callback means the paths don't matchup - so no point returning any program\n         * this will signal to the caller to skip this program\n         */\n        log('No callback found for file, not part of this program. %s', filePath);\n        return null;\n    }\n    // directory update means that the file list more than likely changed, so clear the cache\n    programFileListCache.delete(tsconfigPath);\n    // force the immediate resync\n    updatedProgram = existingWatch.getProgram().getProgram();\n    sourceFile = updatedProgram.getSourceFile(filePath);\n    if (sourceFile) {\n        return updatedProgram;\n    }\n    /*\n     * At this point we're in one of two states:\n     * - The file isn't supposed to be in this program due to exclusions\n     * - The file is new, and was renamed from an old, included filename\n     *\n     * For the latter case, we need to tell typescript that the old filename is now deleted\n     */\n    log('File was still not found in program after directory update - checking file deletions. %s', filePath);\n    const rootFilenames = updatedProgram.getRootFileNames();\n    // use find because we only need to \"delete\" one file to cause typescript to do a full resync\n    const deletedFile = rootFilenames.find(file => !node_fs_1.default.existsSync(file));\n    if (!deletedFile) {\n        // There are no deleted files, so it must be the former case of the file not belonging to this program\n        return null;\n    }\n    const fileWatchCallbacks = fileWatchCallbackTrackingMap.get((0, shared_1.getCanonicalFileName)(deletedFile));\n    if (!fileWatchCallbacks) {\n        // shouldn't happen, but just in case\n        log('Could not find watch callbacks for root file. %s', deletedFile);\n        return updatedProgram;\n    }\n    log('Marking file as deleted. %s', deletedFile);\n    fileWatchCallbacks.forEach(cb => cb(deletedFile, ts.FileWatcherEventKind.Deleted));\n    // deleted files means that the file list _has_ changed, so clear the cache\n    programFileListCache.delete(tsconfigPath);\n    updatedProgram = existingWatch.getProgram().getProgram();\n    sourceFile = updatedProgram.getSourceFile(filePath);\n    if (sourceFile) {\n        return updatedProgram;\n    }\n    log('File was still not found in program after deletion check, assuming it is not part of this program. %s', filePath);\n    return null;\n}\n"
        }
    ]
}