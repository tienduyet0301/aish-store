{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/parser.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892001622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearProgramCache = clearProgramCache;\nexports.clearDefaultProjectMatchedFiles = clearDefaultProjectMatchedFiles;\nexports.parse = parse;\nexports.clearParseAndGenerateServicesCalls = clearParseAndGenerateServicesCalls;\nexports.parseAndGenerateServices = parseAndGenerateServices;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst ast_converter_1 = require(\"./ast-converter\");\nconst convert_1 = require(\"./convert\");\nconst createIsolatedProgram_1 = require(\"./create-program/createIsolatedProgram\");\nconst createProjectProgram_1 = require(\"./create-program/createProjectProgram\");\nconst createSourceFile_1 = require(\"./create-program/createSourceFile\");\nconst getWatchProgramsForProjects_1 = require(\"./create-program/getWatchProgramsForProjects\");\nconst useProvidedPrograms_1 = require(\"./create-program/useProvidedPrograms\");\nconst createParserServices_1 = require(\"./createParserServices\");\nconst createParseSettings_1 = require(\"./parseSettings/createParseSettings\");\nconst semantic_or_syntactic_errors_1 = require(\"./semantic-or-syntactic-errors\");\nconst useProgramFromProjectService_1 = require(\"./useProgramFromProjectService\");\nconst log = (0, debug_1.default)('typescript-eslint:typescript-estree:parser');\n/**\n * Cache existing programs for the single run use-case.\n *\n * clearProgramCache() is only intended to be used in testing to ensure the parser is clean between tests.\n */\nconst existingPrograms = new Map();\nfunction clearProgramCache() {\n    existingPrograms.clear();\n}\nconst defaultProjectMatchedFiles = new Set();\nfunction clearDefaultProjectMatchedFiles() {\n    defaultProjectMatchedFiles.clear();\n}\n/**\n * @param parseSettings Internal settings for parsing the file\n * @param hasFullTypeInformation True if the program should be attempted to be calculated from provided tsconfig files\n * @returns Returns a source file and program corresponding to the linted code\n */\nfunction getProgramAndAST(parseSettings, hasFullTypeInformation) {\n    if (parseSettings.projectService) {\n        const fromProjectService = (0, useProgramFromProjectService_1.useProgramFromProjectService)(parseSettings.projectService, parseSettings, hasFullTypeInformation, defaultProjectMatchedFiles);\n        if (fromProjectService) {\n            return fromProjectService;\n        }\n    }\n    if (parseSettings.programs) {\n        const fromProvidedPrograms = (0, useProvidedPrograms_1.useProvidedPrograms)(parseSettings.programs, parseSettings);\n        if (fromProvidedPrograms) {\n            return fromProvidedPrograms;\n        }\n    }\n    // no need to waste time creating a program as the caller didn't want parser services\n    // so we can save time and just create a lonesome source file\n    if (!hasFullTypeInformation) {\n        return (0, createSourceFile_1.createNoProgram)(parseSettings);\n    }\n    return (0, createProjectProgram_1.createProjectProgram)(parseSettings, (0, getWatchProgramsForProjects_1.getWatchProgramsForProjects)(parseSettings));\n}\nfunction parse(code, options) {\n    const { ast } = parseWithNodeMapsInternal(code, options, false);\n    return ast;\n}\nfunction parseWithNodeMapsInternal(code, options, shouldPreserveNodeMaps) {\n    /**\n     * Reset the parse configuration\n     */\n    const parseSettings = (0, createParseSettings_1.createParseSettings)(code, options);\n    /**\n     * Ensure users do not attempt to use parse() when they need parseAndGenerateServices()\n     */\n    if (options?.errorOnTypeScriptSyntacticAndSemanticIssues) {\n        throw new Error(`\"errorOnTypeScriptSyntacticAndSemanticIssues\" is only supported for parseAndGenerateServices()`);\n    }\n    /**\n     * Create a ts.SourceFile directly, no ts.Program is needed for a simple parse\n     */\n    const ast = (0, createSourceFile_1.createSourceFile)(parseSettings);\n    /**\n     * Convert the TypeScript AST to an ESTree-compatible one\n     */\n    const { astMaps, estree } = (0, ast_converter_1.astConverter)(ast, parseSettings, shouldPreserveNodeMaps);\n    return {\n        ast: estree,\n        esTreeNodeToTSNodeMap: astMaps.esTreeNodeToTSNodeMap,\n        tsNodeToESTreeNodeMap: astMaps.tsNodeToESTreeNodeMap,\n    };\n}\nlet parseAndGenerateServicesCalls = {};\n// Privately exported utility intended for use in typescript-eslint unit tests only\nfunction clearParseAndGenerateServicesCalls() {\n    parseAndGenerateServicesCalls = {};\n}\nfunction parseAndGenerateServices(code, tsestreeOptions) {\n    /**\n     * Reset the parse configuration\n     */\n    const parseSettings = (0, createParseSettings_1.createParseSettings)(code, tsestreeOptions);\n    /**\n     * If this is a single run in which the user has not provided any existing programs but there\n     * are programs which need to be created from the provided \"project\" option,\n     * create an Iterable which will lazily create the programs as needed by the iteration logic\n     */\n    if (parseSettings.singleRun &&\n        !parseSettings.programs &&\n        parseSettings.projects.size > 0) {\n        parseSettings.programs = {\n            *[Symbol.iterator]() {\n                for (const configFile of parseSettings.projects) {\n                    const existingProgram = existingPrograms.get(configFile[0]);\n                    if (existingProgram) {\n                        yield existingProgram;\n                    }\n                    else {\n                        log('Detected single-run/CLI usage, creating Program once ahead of time for project: %s', configFile);\n                        const newProgram = (0, useProvidedPrograms_1.createProgramFromConfigFile)(configFile[1]);\n                        existingPrograms.set(configFile[0], newProgram);\n                        yield newProgram;\n                    }\n                }\n            },\n        };\n    }\n    const hasFullTypeInformation = parseSettings.programs != null ||\n        parseSettings.projects.size > 0 ||\n        !!parseSettings.projectService;\n    if (typeof tsestreeOptions.errorOnTypeScriptSyntacticAndSemanticIssues ===\n        'boolean' &&\n        tsestreeOptions.errorOnTypeScriptSyntacticAndSemanticIssues) {\n        parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues = true;\n    }\n    if (parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues &&\n        !hasFullTypeInformation) {\n        throw new Error('Cannot calculate TypeScript semantic issues without a valid project.');\n    }\n    /**\n     * If we are in singleRun mode but the parseAndGenerateServices() function has been called more than once for the current file,\n     * it must mean that we are in the middle of an ESLint automated fix cycle (in which parsing can be performed up to an additional\n     * 10 times in order to apply all possible fixes for the file).\n     *\n     * In this scenario we cannot rely upon the singleRun AOT compiled programs because the SourceFiles will not contain the source\n     * with the latest fixes applied. Therefore we fallback to creating the quickest possible isolated program from the updated source.\n     */\n    if (parseSettings.singleRun && tsestreeOptions.filePath) {\n        parseAndGenerateServicesCalls[tsestreeOptions.filePath] =\n            (parseAndGenerateServicesCalls[tsestreeOptions.filePath] || 0) + 1;\n    }\n    const { ast, program } = parseSettings.singleRun &&\n        tsestreeOptions.filePath &&\n        parseAndGenerateServicesCalls[tsestreeOptions.filePath] > 1\n        ? (0, createIsolatedProgram_1.createIsolatedProgram)(parseSettings)\n        : getProgramAndAST(parseSettings, hasFullTypeInformation);\n    /**\n     * Convert the TypeScript AST to an ESTree-compatible one, and optionally preserve\n     * mappings between converted and original AST nodes\n     */\n    const shouldPreserveNodeMaps = typeof parseSettings.preserveNodeMaps === 'boolean'\n        ? parseSettings.preserveNodeMaps\n        : true;\n    const { astMaps, estree } = (0, ast_converter_1.astConverter)(ast, parseSettings, shouldPreserveNodeMaps);\n    /**\n     * Even if TypeScript parsed the source code ok, and we had no problems converting the AST,\n     * there may be other syntactic or semantic issues in the code that we can optionally report on.\n     */\n    if (program && parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues) {\n        const error = (0, semantic_or_syntactic_errors_1.getFirstSemanticOrSyntacticError)(program, ast);\n        if (error) {\n            throw (0, convert_1.convertError)(error);\n        }\n    }\n    /**\n     * Return the converted AST and additional parser services\n     */\n    return {\n        ast: estree,\n        services: (0, createParserServices_1.createParserServices)(astMaps, program),\n    };\n}\n"
        }
    ]
}