{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/node-utils.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892001362,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as ts from 'typescript';\nimport type { TSESTree, TSNode } from './ts-estree';\nimport { AST_NODE_TYPES, AST_TOKEN_TYPES } from './ts-estree';\ndeclare const SyntaxKind: typeof ts.SyntaxKind;\ntype LogicalOperatorKind = ts.SyntaxKind.AmpersandAmpersandToken | ts.SyntaxKind.BarBarToken | ts.SyntaxKind.QuestionQuestionToken;\ninterface TokenToText extends TSESTree.PunctuatorTokenToText, TSESTree.BinaryOperatorToText {\n    [SyntaxKind.ImportKeyword]: 'import';\n    [SyntaxKind.KeyOfKeyword]: 'keyof';\n    [SyntaxKind.NewKeyword]: 'new';\n    [SyntaxKind.ReadonlyKeyword]: 'readonly';\n    [SyntaxKind.UniqueKeyword]: 'unique';\n}\ntype AssignmentOperatorKind = keyof TSESTree.AssignmentOperatorToText;\ntype BinaryOperatorKind = keyof TSESTree.BinaryOperatorToText;\ntype DeclarationKind = TSESTree.VariableDeclaration['kind'];\n/**\n * Returns true if the given ts.Token is a logical operator\n */\nexport declare function isLogicalOperator(operator: ts.BinaryOperatorToken): operator is ts.Token<LogicalOperatorKind>;\nexport declare function isESTreeBinaryOperator(operator: ts.BinaryOperatorToken): operator is ts.Token<BinaryOperatorKind>;\ntype TokenForTokenKind<T extends ts.SyntaxKind> = T extends keyof TokenToText ? TokenToText[T] : string | undefined;\n/**\n * Returns the string form of the given TSToken SyntaxKind\n */\nexport declare function getTextForTokenKind<T extends ts.SyntaxKind>(kind: T): TokenForTokenKind<T>;\n/**\n * Returns true if the given ts.Node is a valid ESTree class member\n */\nexport declare function isESTreeClassMember(node: ts.Node): boolean;\n/**\n * Checks if a ts.Node has a modifier\n */\nexport declare function hasModifier(modifierKind: ts.KeywordSyntaxKind, node: ts.Node): boolean;\n/**\n * Get last last modifier in ast\n * @returns returns last modifier if present or null\n */\nexport declare function getLastModifier(node: ts.Node): ts.Modifier | null;\n/**\n * Returns true if the given ts.Token is a comma\n */\nexport declare function isComma(token: ts.Node): token is ts.Token<ts.SyntaxKind.CommaToken>;\n/**\n * Returns true if the given ts.Node is a comment\n */\nexport declare function isComment(node: ts.Node): boolean;\n/**\n * Returns the binary expression type of the given ts.Token\n */\nexport declare function getBinaryExpressionType(operator: ts.BinaryOperatorToken): {\n    operator: TokenForTokenKind<AssignmentOperatorKind>;\n    type: AST_NODE_TYPES.AssignmentExpression;\n} | {\n    operator: TokenForTokenKind<BinaryOperatorKind>;\n    type: AST_NODE_TYPES.BinaryExpression;\n} | {\n    operator: TokenForTokenKind<LogicalOperatorKind>;\n    type: AST_NODE_TYPES.LogicalExpression;\n};\n/**\n * Returns line and column data for the given positions\n */\nexport declare function getLineAndCharacterFor(pos: number, ast: ts.SourceFile): TSESTree.Position;\n/**\n * Returns line and column data for the given start and end positions,\n * for the given AST\n */\nexport declare function getLocFor(range: TSESTree.Range, ast: ts.SourceFile): TSESTree.SourceLocation;\n/**\n * Check whatever node can contain directive\n */\nexport declare function canContainDirective(node: ts.Block | ts.ClassStaticBlockDeclaration | ts.ModuleBlock | ts.SourceFile): boolean;\n/**\n * Returns range for the given ts.Node\n */\nexport declare function getRange(node: Pick<ts.Node, 'getEnd' | 'getStart'>, ast: ts.SourceFile): [number, number];\n/**\n * Returns true if a given ts.Node is a JSX token\n */\nexport declare function isJSXToken(node: ts.Node): boolean;\n/**\n * Returns the declaration kind of the given ts.Node\n */\nexport declare function getDeclarationKind(node: ts.VariableDeclarationList): DeclarationKind;\n/**\n * Gets a ts.Node's accessibility level\n */\nexport declare function getTSNodeAccessibility(node: ts.Node): 'private' | 'protected' | 'public' | undefined;\n/**\n * Finds the next token based on the previous one and its parent\n * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren\n */\nexport declare function findNextToken(previousToken: ts.TextRange, parent: ts.Node, ast: ts.SourceFile): ts.Node | undefined;\n/**\n * Find the first matching ancestor based on the given predicate function.\n * @param node The current ts.Node\n * @param predicate The predicate function to apply to each checked ancestor\n * @returns a matching parent ts.Node\n */\nexport declare function findFirstMatchingAncestor(node: ts.Node, predicate: (node: ts.Node) => boolean): ts.Node | undefined;\n/**\n * Returns true if a given ts.Node has a JSX token within its hierarchy\n */\nexport declare function hasJSXAncestor(node: ts.Node): boolean;\n/**\n * Unescape the text content of string literals, e.g. &amp; -> &\n * @param text The escaped string literal text.\n * @returns The unescaped string literal text.\n */\nexport declare function unescapeStringLiteralText(text: string): string;\n/**\n * Returns true if a given ts.Node is a computed property\n */\nexport declare function isComputedProperty(node: ts.Node): node is ts.ComputedPropertyName;\n/**\n * Returns true if a given ts.Node is optional (has QuestionToken)\n * @param node ts.Node to be checked\n */\nexport declare function isOptional(node: {\n    questionToken?: ts.QuestionToken;\n}): boolean;\n/**\n * Returns true if the node is an optional chain node\n */\nexport declare function isChainExpression(node: TSESTree.Node): node is TSESTree.ChainExpression;\n/**\n * Returns true of the child of property access expression is an optional chain\n */\nexport declare function isChildUnwrappableOptionalChain(node: ts.CallExpression | ts.ElementAccessExpression | ts.NonNullExpression | ts.PropertyAccessExpression, child: TSESTree.Node): boolean;\n/**\n * Returns the type of a given ts.Token\n */\nexport declare function getTokenType(token: ts.Identifier | ts.Token<ts.SyntaxKind>): Exclude<AST_TOKEN_TYPES, AST_TOKEN_TYPES.Block | AST_TOKEN_TYPES.Line>;\n/**\n * Extends and formats a given ts.Token, for a given AST\n */\nexport declare function convertToken(token: ts.Token<ts.TokenSyntaxKind>, ast: ts.SourceFile): TSESTree.Token;\n/**\n * Converts all tokens for the given AST\n * @param ast the AST object\n * @returns the converted Tokens\n */\nexport declare function convertTokens(ast: ts.SourceFile): TSESTree.Token[];\nexport declare class TSError extends Error {\n    readonly fileName: string;\n    readonly location: {\n        end: {\n            column: number;\n            line: number;\n            offset: number;\n        };\n        start: {\n            column: number;\n            line: number;\n            offset: number;\n        };\n    };\n    constructor(message: string, fileName: string, location: {\n        end: {\n            column: number;\n            line: number;\n            offset: number;\n        };\n        start: {\n            column: number;\n            line: number;\n            offset: number;\n        };\n    });\n    get index(): number;\n    get lineNumber(): number;\n    get column(): number;\n}\nexport declare function createError(message: string, ast: ts.SourceFile, startIndex: number, endIndex?: number): TSError;\nexport declare function nodeHasIllegalDecorators(node: ts.Node): node is {\n    illegalDecorators: ts.Node[];\n} & ts.Node;\nexport declare function nodeHasTokens(n: ts.Node, ast: ts.SourceFile): boolean;\n/**\n * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).\n */\nexport declare function firstDefined<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined;\nexport declare function identifierIsThisKeyword(id: ts.Identifier): boolean;\nexport declare function isThisIdentifier(node: ts.Node | undefined): node is ts.Identifier;\nexport declare function isThisInTypeQuery(node: ts.Node): boolean;\nexport declare function nodeIsPresent(node: ts.Node | undefined): node is ts.Node;\nexport declare function getContainingFunction(node: ts.Node): ts.SignatureDeclaration | undefined;\nexport declare function nodeCanBeDecorated(node: TSNode): boolean;\nexport declare function isValidAssignmentTarget(node: ts.Node): boolean;\nexport declare function getNamespaceModifiers(node: ts.ModuleDeclaration): ts.Modifier[] | undefined;\nexport {};\n//# sourceMappingURL=node-utils.d.ts.map"
        }
    ]
}