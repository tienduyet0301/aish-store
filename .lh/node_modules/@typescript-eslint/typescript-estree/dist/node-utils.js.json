{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/node-utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892001451,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TSError = void 0;\nexports.isLogicalOperator = isLogicalOperator;\nexports.isESTreeBinaryOperator = isESTreeBinaryOperator;\nexports.getTextForTokenKind = getTextForTokenKind;\nexports.isESTreeClassMember = isESTreeClassMember;\nexports.hasModifier = hasModifier;\nexports.getLastModifier = getLastModifier;\nexports.isComma = isComma;\nexports.isComment = isComment;\nexports.getBinaryExpressionType = getBinaryExpressionType;\nexports.getLineAndCharacterFor = getLineAndCharacterFor;\nexports.getLocFor = getLocFor;\nexports.canContainDirective = canContainDirective;\nexports.getRange = getRange;\nexports.isJSXToken = isJSXToken;\nexports.getDeclarationKind = getDeclarationKind;\nexports.getTSNodeAccessibility = getTSNodeAccessibility;\nexports.findNextToken = findNextToken;\nexports.findFirstMatchingAncestor = findFirstMatchingAncestor;\nexports.hasJSXAncestor = hasJSXAncestor;\nexports.unescapeStringLiteralText = unescapeStringLiteralText;\nexports.isComputedProperty = isComputedProperty;\nexports.isOptional = isOptional;\nexports.isChainExpression = isChainExpression;\nexports.isChildUnwrappableOptionalChain = isChildUnwrappableOptionalChain;\nexports.getTokenType = getTokenType;\nexports.convertToken = convertToken;\nexports.convertTokens = convertTokens;\nexports.createError = createError;\nexports.nodeHasIllegalDecorators = nodeHasIllegalDecorators;\nexports.nodeHasTokens = nodeHasTokens;\nexports.firstDefined = firstDefined;\nexports.identifierIsThisKeyword = identifierIsThisKeyword;\nexports.isThisIdentifier = isThisIdentifier;\nexports.isThisInTypeQuery = isThisInTypeQuery;\nexports.nodeIsPresent = nodeIsPresent;\nexports.getContainingFunction = getContainingFunction;\nexports.nodeCanBeDecorated = nodeCanBeDecorated;\nexports.isValidAssignmentTarget = isValidAssignmentTarget;\nexports.getNamespaceModifiers = getNamespaceModifiers;\nconst ts = __importStar(require(\"typescript\"));\nconst getModifiers_1 = require(\"./getModifiers\");\nconst xhtml_entities_1 = require(\"./jsx/xhtml-entities\");\nconst ts_estree_1 = require(\"./ts-estree\");\nconst version_check_1 = require(\"./version-check\");\nconst isAtLeast50 = version_check_1.typescriptVersionIsAtLeast['5.0'];\nconst SyntaxKind = ts.SyntaxKind;\nconst LOGICAL_OPERATORS = new Set([\n    SyntaxKind.AmpersandAmpersandToken,\n    SyntaxKind.BarBarToken,\n    SyntaxKind.QuestionQuestionToken,\n]);\nconst ASSIGNMENT_OPERATORS = new Set([\n    ts.SyntaxKind.AmpersandAmpersandEqualsToken,\n    ts.SyntaxKind.AmpersandEqualsToken,\n    ts.SyntaxKind.AsteriskAsteriskEqualsToken,\n    ts.SyntaxKind.AsteriskEqualsToken,\n    ts.SyntaxKind.BarBarEqualsToken,\n    ts.SyntaxKind.BarEqualsToken,\n    ts.SyntaxKind.CaretEqualsToken,\n    ts.SyntaxKind.EqualsToken,\n    ts.SyntaxKind.GreaterThanGreaterThanEqualsToken,\n    ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,\n    ts.SyntaxKind.LessThanLessThanEqualsToken,\n    ts.SyntaxKind.MinusEqualsToken,\n    ts.SyntaxKind.PercentEqualsToken,\n    ts.SyntaxKind.PlusEqualsToken,\n    ts.SyntaxKind.QuestionQuestionEqualsToken,\n    ts.SyntaxKind.SlashEqualsToken,\n]);\nconst BINARY_OPERATORS = new Set([\n    SyntaxKind.AmpersandAmpersandToken,\n    SyntaxKind.AmpersandToken,\n    SyntaxKind.AsteriskAsteriskToken,\n    SyntaxKind.AsteriskToken,\n    SyntaxKind.BarBarToken,\n    SyntaxKind.BarToken,\n    SyntaxKind.CaretToken,\n    SyntaxKind.EqualsEqualsEqualsToken,\n    SyntaxKind.EqualsEqualsToken,\n    SyntaxKind.ExclamationEqualsEqualsToken,\n    SyntaxKind.ExclamationEqualsToken,\n    SyntaxKind.GreaterThanEqualsToken,\n    SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\n    SyntaxKind.GreaterThanGreaterThanToken,\n    SyntaxKind.GreaterThanToken,\n    SyntaxKind.InKeyword,\n    SyntaxKind.InstanceOfKeyword,\n    SyntaxKind.LessThanEqualsToken,\n    SyntaxKind.LessThanLessThanToken,\n    SyntaxKind.LessThanToken,\n    SyntaxKind.MinusToken,\n    SyntaxKind.PercentToken,\n    SyntaxKind.PlusToken,\n    SyntaxKind.SlashToken,\n]);\n/**\n * Returns true if the given ts.Token is the assignment operator\n */\nfunction isAssignmentOperator(operator) {\n    return ASSIGNMENT_OPERATORS.has(operator.kind);\n}\n/**\n * Returns true if the given ts.Token is a logical operator\n */\nfunction isLogicalOperator(operator) {\n    return LOGICAL_OPERATORS.has(operator.kind);\n}\nfunction isESTreeBinaryOperator(operator) {\n    return BINARY_OPERATORS.has(operator.kind);\n}\n/**\n * Returns the string form of the given TSToken SyntaxKind\n */\nfunction getTextForTokenKind(kind) {\n    return ts.tokenToString(kind);\n}\n/**\n * Returns true if the given ts.Node is a valid ESTree class member\n */\nfunction isESTreeClassMember(node) {\n    return node.kind !== SyntaxKind.SemicolonClassElement;\n}\n/**\n * Checks if a ts.Node has a modifier\n */\nfunction hasModifier(modifierKind, node) {\n    const modifiers = (0, getModifiers_1.getModifiers)(node);\n    return modifiers?.some(modifier => modifier.kind === modifierKind) === true;\n}\n/**\n * Get last last modifier in ast\n * @returns returns last modifier if present or null\n */\nfunction getLastModifier(node) {\n    const modifiers = (0, getModifiers_1.getModifiers)(node);\n    if (modifiers == null) {\n        return null;\n    }\n    return modifiers[modifiers.length - 1] ?? null;\n}\n/**\n * Returns true if the given ts.Token is a comma\n */\nfunction isComma(token) {\n    return token.kind === SyntaxKind.CommaToken;\n}\n/**\n * Returns true if the given ts.Node is a comment\n */\nfunction isComment(node) {\n    return (node.kind === SyntaxKind.SingleLineCommentTrivia ||\n        node.kind === SyntaxKind.MultiLineCommentTrivia);\n}\n/**\n * Returns true if the given ts.Node is a JSDoc comment\n */\nfunction isJSDocComment(node) {\n    // eslint-disable-next-line @typescript-eslint/no-deprecated -- SyntaxKind.JSDoc was only added in TS4.7 so we can't use it yet\n    return node.kind === SyntaxKind.JSDocComment;\n}\n/**\n * Returns the binary expression type of the given ts.Token\n */\nfunction getBinaryExpressionType(operator) {\n    if (isAssignmentOperator(operator)) {\n        return {\n            type: ts_estree_1.AST_NODE_TYPES.AssignmentExpression,\n            operator: getTextForTokenKind(operator.kind),\n        };\n    }\n    if (isLogicalOperator(operator)) {\n        return {\n            type: ts_estree_1.AST_NODE_TYPES.LogicalExpression,\n            operator: getTextForTokenKind(operator.kind),\n        };\n    }\n    if (isESTreeBinaryOperator(operator)) {\n        return {\n            type: ts_estree_1.AST_NODE_TYPES.BinaryExpression,\n            operator: getTextForTokenKind(operator.kind),\n        };\n    }\n    throw new Error(`Unexpected binary operator ${ts.tokenToString(operator.kind)}`);\n}\n/**\n * Returns line and column data for the given positions\n */\nfunction getLineAndCharacterFor(pos, ast) {\n    const loc = ast.getLineAndCharacterOfPosition(pos);\n    return {\n        column: loc.character,\n        line: loc.line + 1,\n    };\n}\n/**\n * Returns line and column data for the given start and end positions,\n * for the given AST\n */\nfunction getLocFor(range, ast) {\n    const [start, end] = range.map(pos => getLineAndCharacterFor(pos, ast));\n    return { end, start };\n}\n/**\n * Check whatever node can contain directive\n */\nfunction canContainDirective(node) {\n    if (node.kind === ts.SyntaxKind.Block) {\n        switch (node.parent.kind) {\n            case ts.SyntaxKind.Constructor:\n            case ts.SyntaxKind.GetAccessor:\n            case ts.SyntaxKind.SetAccessor:\n            case ts.SyntaxKind.ArrowFunction:\n            case ts.SyntaxKind.FunctionExpression:\n            case ts.SyntaxKind.FunctionDeclaration:\n            case ts.SyntaxKind.MethodDeclaration:\n                return true;\n            default:\n                return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns range for the given ts.Node\n */\nfunction getRange(node, ast) {\n    return [node.getStart(ast), node.getEnd()];\n}\n/**\n * Returns true if a given ts.Node is a token\n */\nfunction isToken(node) {\n    return (node.kind >= SyntaxKind.FirstToken && node.kind <= SyntaxKind.LastToken);\n}\n/**\n * Returns true if a given ts.Node is a JSX token\n */\nfunction isJSXToken(node) {\n    return (node.kind >= SyntaxKind.JsxElement && node.kind <= SyntaxKind.JsxAttribute);\n}\n/**\n * Returns the declaration kind of the given ts.Node\n */\nfunction getDeclarationKind(node) {\n    if (node.flags & ts.NodeFlags.Let) {\n        return 'let';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if ((node.flags & ts.NodeFlags.AwaitUsing) === ts.NodeFlags.AwaitUsing) {\n        return 'await using';\n    }\n    if (node.flags & ts.NodeFlags.Const) {\n        return 'const';\n    }\n    if (node.flags & ts.NodeFlags.Using) {\n        return 'using';\n    }\n    return 'var';\n}\n/**\n * Gets a ts.Node's accessibility level\n */\nfunction getTSNodeAccessibility(node) {\n    const modifiers = (0, getModifiers_1.getModifiers)(node);\n    if (modifiers == null) {\n        return undefined;\n    }\n    for (const modifier of modifiers) {\n        switch (modifier.kind) {\n            case SyntaxKind.PublicKeyword:\n                return 'public';\n            case SyntaxKind.ProtectedKeyword:\n                return 'protected';\n            case SyntaxKind.PrivateKeyword:\n                return 'private';\n            default:\n                break;\n        }\n    }\n    return undefined;\n}\n/**\n * Finds the next token based on the previous one and its parent\n * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren\n */\nfunction findNextToken(previousToken, parent, ast) {\n    return find(parent);\n    function find(n) {\n        if (ts.isToken(n) && n.pos === previousToken.end) {\n            // this is token that starts at the end of previous token - return it\n            return n;\n        }\n        return firstDefined(n.getChildren(ast), (child) => {\n            const shouldDiveInChildNode = \n            // previous token is enclosed somewhere in the child\n            (child.pos <= previousToken.pos && child.end > previousToken.end) ||\n                // previous token ends exactly at the beginning of child\n                child.pos === previousToken.end;\n            return shouldDiveInChildNode && nodeHasTokens(child, ast)\n                ? find(child)\n                : undefined;\n        });\n    }\n}\n/**\n * Find the first matching ancestor based on the given predicate function.\n * @param node The current ts.Node\n * @param predicate The predicate function to apply to each checked ancestor\n * @returns a matching parent ts.Node\n */\nfunction findFirstMatchingAncestor(node, predicate) {\n    let current = node;\n    while (current) {\n        if (predicate(current)) {\n            return current;\n        }\n        current = current.parent;\n    }\n    return undefined;\n}\n/**\n * Returns true if a given ts.Node has a JSX token within its hierarchy\n */\nfunction hasJSXAncestor(node) {\n    return !!findFirstMatchingAncestor(node, isJSXToken);\n}\n/**\n * Unescape the text content of string literals, e.g. &amp; -> &\n * @param text The escaped string literal text.\n * @returns The unescaped string literal text.\n */\nfunction unescapeStringLiteralText(text) {\n    return text.replaceAll(/&(?:#\\d+|#x[\\da-fA-F]+|[0-9a-zA-Z]+);/g, entity => {\n        const item = entity.slice(1, -1);\n        if (item[0] === '#') {\n            const codePoint = item[1] === 'x'\n                ? parseInt(item.slice(2), 16)\n                : parseInt(item.slice(1), 10);\n            return codePoint > 0x10ffff // RangeError: Invalid code point\n                ? entity\n                : String.fromCodePoint(codePoint);\n        }\n        return xhtml_entities_1.xhtmlEntities[item] || entity;\n    });\n}\n/**\n * Returns true if a given ts.Node is a computed property\n */\nfunction isComputedProperty(node) {\n    return node.kind === SyntaxKind.ComputedPropertyName;\n}\n/**\n * Returns true if a given ts.Node is optional (has QuestionToken)\n * @param node ts.Node to be checked\n */\nfunction isOptional(node) {\n    return !!node.questionToken;\n}\n/**\n * Returns true if the node is an optional chain node\n */\nfunction isChainExpression(node) {\n    return node.type === ts_estree_1.AST_NODE_TYPES.ChainExpression;\n}\n/**\n * Returns true of the child of property access expression is an optional chain\n */\nfunction isChildUnwrappableOptionalChain(node, child) {\n    return (isChainExpression(child) &&\n        // (x?.y).z is semantically different, and as such .z is no longer optional\n        node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression);\n}\n/**\n * Returns the type of a given ts.Token\n */\nfunction getTokenType(token) {\n    let keywordKind;\n    if (isAtLeast50 && token.kind === SyntaxKind.Identifier) {\n        keywordKind = ts.identifierToKeywordKind(token);\n    }\n    else if ('originalKeywordKind' in token) {\n        // @ts-expect-error -- intentional fallback for older TS versions <=4.9\n        keywordKind = token.originalKeywordKind;\n    }\n    if (keywordKind) {\n        if (keywordKind === SyntaxKind.NullKeyword) {\n            return ts_estree_1.AST_TOKEN_TYPES.Null;\n        }\n        if (keywordKind >= SyntaxKind.FirstFutureReservedWord &&\n            keywordKind <= SyntaxKind.LastKeyword) {\n            return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n        }\n        return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n    }\n    if (token.kind >= SyntaxKind.FirstKeyword &&\n        token.kind <= SyntaxKind.LastFutureReservedWord) {\n        if (token.kind === SyntaxKind.FalseKeyword ||\n            token.kind === SyntaxKind.TrueKeyword) {\n            return ts_estree_1.AST_TOKEN_TYPES.Boolean;\n        }\n        return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n    }\n    if (token.kind >= SyntaxKind.FirstPunctuation &&\n        token.kind <= SyntaxKind.LastPunctuation) {\n        return ts_estree_1.AST_TOKEN_TYPES.Punctuator;\n    }\n    if (token.kind >= SyntaxKind.NoSubstitutionTemplateLiteral &&\n        token.kind <= SyntaxKind.TemplateTail) {\n        return ts_estree_1.AST_TOKEN_TYPES.Template;\n    }\n    switch (token.kind) {\n        case SyntaxKind.NumericLiteral:\n            return ts_estree_1.AST_TOKEN_TYPES.Numeric;\n        case SyntaxKind.JsxText:\n            return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n        case SyntaxKind.StringLiteral:\n            // A TypeScript-StringLiteral token with a TypeScript-JsxAttribute or TypeScript-JsxElement parent,\n            // must actually be an ESTree-JSXText token\n            if (token.parent.kind === SyntaxKind.JsxAttribute ||\n                token.parent.kind === SyntaxKind.JsxElement) {\n                return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n            }\n            return ts_estree_1.AST_TOKEN_TYPES.String;\n        case SyntaxKind.RegularExpressionLiteral:\n            return ts_estree_1.AST_TOKEN_TYPES.RegularExpression;\n        case SyntaxKind.Identifier:\n        case SyntaxKind.ConstructorKeyword:\n        case SyntaxKind.GetKeyword:\n        case SyntaxKind.SetKeyword:\n        // intentional fallthrough\n        default:\n    }\n    // Some JSX tokens have to be determined based on their parent\n    if (token.kind === SyntaxKind.Identifier) {\n        if (isJSXToken(token.parent)) {\n            return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n        }\n        if (token.parent.kind === SyntaxKind.PropertyAccessExpression &&\n            hasJSXAncestor(token)) {\n            return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n        }\n    }\n    return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n}\n/**\n * Extends and formats a given ts.Token, for a given AST\n */\nfunction convertToken(token, ast) {\n    const start = token.kind === SyntaxKind.JsxText\n        ? token.getFullStart()\n        : token.getStart(ast);\n    const end = token.getEnd();\n    const value = ast.text.slice(start, end);\n    const tokenType = getTokenType(token);\n    const range = [start, end];\n    const loc = getLocFor(range, ast);\n    if (tokenType === ts_estree_1.AST_TOKEN_TYPES.RegularExpression) {\n        return {\n            type: tokenType,\n            loc,\n            range,\n            regex: {\n                flags: value.slice(value.lastIndexOf('/') + 1),\n                pattern: value.slice(1, value.lastIndexOf('/')),\n            },\n            value,\n        };\n    }\n    // @ts-expect-error TS is complaining about `value` not being the correct\n    // type but it is\n    return {\n        type: tokenType,\n        loc,\n        range,\n        value,\n    };\n}\n/**\n * Converts all tokens for the given AST\n * @param ast the AST object\n * @returns the converted Tokens\n */\nfunction convertTokens(ast) {\n    const result = [];\n    /**\n     * @param node the ts.Node\n     */\n    function walk(node) {\n        // TypeScript generates tokens for types in JSDoc blocks. Comment tokens\n        // and their children should not be walked or added to the resulting tokens list.\n        if (isComment(node) || isJSDocComment(node)) {\n            return;\n        }\n        if (isToken(node) && node.kind !== SyntaxKind.EndOfFileToken) {\n            result.push(convertToken(node, ast));\n        }\n        else {\n            node.getChildren(ast).forEach(walk);\n        }\n    }\n    walk(ast);\n    return result;\n}\nclass TSError extends Error {\n    fileName;\n    location;\n    constructor(message, fileName, location) {\n        super(message);\n        this.fileName = fileName;\n        this.location = location;\n        Object.defineProperty(this, 'name', {\n            configurable: true,\n            enumerable: false,\n            value: new.target.name,\n        });\n    }\n    // For old version of ESLint https://github.com/typescript-eslint/typescript-eslint/pull/6556#discussion_r1123237311\n    get index() {\n        return this.location.start.offset;\n    }\n    // https://github.com/eslint/eslint/blob/b09a512107249a4eb19ef5a37b0bd672266eafdb/lib/linter/linter.js#L853\n    get lineNumber() {\n        return this.location.start.line;\n    }\n    // https://github.com/eslint/eslint/blob/b09a512107249a4eb19ef5a37b0bd672266eafdb/lib/linter/linter.js#L854\n    get column() {\n        return this.location.start.column;\n    }\n}\nexports.TSError = TSError;\nfunction createError(message, ast, startIndex, endIndex = startIndex) {\n    const [start, end] = [startIndex, endIndex].map(offset => {\n        const { character: column, line } = ast.getLineAndCharacterOfPosition(offset);\n        return { column, line: line + 1, offset };\n    });\n    return new TSError(message, ast.fileName, { end, start });\n}\nfunction nodeHasIllegalDecorators(node) {\n    return !!('illegalDecorators' in node &&\n        node.illegalDecorators?.length);\n}\nfunction nodeHasTokens(n, ast) {\n    // If we have a token or node that has a non-zero width, it must have tokens.\n    // Note: getWidth() does not take trivia into account.\n    return n.kind === SyntaxKind.EndOfFileToken\n        ? !!n.jsDoc\n        : n.getWidth(ast) !== 0;\n}\n/**\n * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).\n */\nfunction firstDefined(array, callback) {\n    // eslint-disable-next-line @typescript-eslint/internal/eqeq-nullish\n    if (array === undefined) {\n        return undefined;\n    }\n    for (let i = 0; i < array.length; i++) {\n        const result = callback(array[i], i);\n        // eslint-disable-next-line @typescript-eslint/internal/eqeq-nullish\n        if (result !== undefined) {\n            return result;\n        }\n    }\n    return undefined;\n}\nfunction identifierIsThisKeyword(id) {\n    return ((isAtLeast50\n        ? ts.identifierToKeywordKind(id)\n        : // @ts-expect-error -- intentional fallback for older TS versions <=4.9\n            id.originalKeywordKind) === SyntaxKind.ThisKeyword);\n}\nfunction isThisIdentifier(node) {\n    return (!!node &&\n        node.kind === SyntaxKind.Identifier &&\n        identifierIsThisKeyword(node));\n}\nfunction isThisInTypeQuery(node) {\n    if (!isThisIdentifier(node)) {\n        return false;\n    }\n    while (ts.isQualifiedName(node.parent) && node.parent.left === node) {\n        node = node.parent;\n    }\n    return node.parent.kind === SyntaxKind.TypeQuery;\n}\n// `ts.nodeIsMissing`\nfunction nodeIsMissing(node) {\n    if (node == null) {\n        return true;\n    }\n    return (node.pos === node.end &&\n        node.pos >= 0 &&\n        node.kind !== SyntaxKind.EndOfFileToken);\n}\n// `ts.nodeIsPresent`\nfunction nodeIsPresent(node) {\n    return !nodeIsMissing(node);\n}\n// `ts.getContainingFunction`\nfunction getContainingFunction(node) {\n    return ts.findAncestor(node.parent, ts.isFunctionLike);\n}\n// `ts.hasAbstractModifier`\nfunction hasAbstractModifier(node) {\n    return hasModifier(SyntaxKind.AbstractKeyword, node);\n}\n// `ts.getThisParameter`\nfunction getThisParameter(signature) {\n    if (signature.parameters.length && !ts.isJSDocSignature(signature)) {\n        const thisParameter = signature.parameters[0];\n        if (parameterIsThisKeyword(thisParameter)) {\n            return thisParameter;\n        }\n    }\n    return null;\n}\n// `ts.parameterIsThisKeyword`\nfunction parameterIsThisKeyword(parameter) {\n    return isThisIdentifier(parameter.name);\n}\n// Rewrite version of `ts.nodeCanBeDecorated`\n// Returns `true` for both `useLegacyDecorators: true` and `useLegacyDecorators: false`\nfunction nodeCanBeDecorated(node) {\n    switch (node.kind) {\n        case SyntaxKind.ClassDeclaration:\n            return true;\n        case SyntaxKind.ClassExpression:\n            // `ts.nodeCanBeDecorated` returns `false` if `useLegacyDecorators: true`\n            return true;\n        case SyntaxKind.PropertyDeclaration: {\n            const { parent } = node;\n            // `ts.nodeCanBeDecorated` uses this if `useLegacyDecorators: true`\n            if (ts.isClassDeclaration(parent)) {\n                return true;\n            }\n            // `ts.nodeCanBeDecorated` uses this if `useLegacyDecorators: false`\n            if (ts.isClassLike(parent) && !hasAbstractModifier(node)) {\n                return true;\n            }\n            return false;\n        }\n        case SyntaxKind.GetAccessor:\n        case SyntaxKind.SetAccessor:\n        case SyntaxKind.MethodDeclaration: {\n            const { parent } = node;\n            // In `ts.nodeCanBeDecorated`\n            // when `useLegacyDecorators: true` uses `ts.isClassDeclaration`\n            // when `useLegacyDecorators: true` uses `ts.isClassLike`\n            return (Boolean(node.body) &&\n                (ts.isClassDeclaration(parent) || ts.isClassLike(parent)));\n        }\n        case SyntaxKind.Parameter: {\n            // `ts.nodeCanBeDecorated` returns `false` if `useLegacyDecorators: false`\n            const { parent } = node;\n            const grandparent = parent.parent;\n            return (Boolean(parent) &&\n                'body' in parent &&\n                Boolean(parent.body) &&\n                (parent.kind === SyntaxKind.Constructor ||\n                    parent.kind === SyntaxKind.MethodDeclaration ||\n                    parent.kind === SyntaxKind.SetAccessor) &&\n                getThisParameter(parent) !== node &&\n                Boolean(grandparent) &&\n                grandparent.kind === SyntaxKind.ClassDeclaration);\n        }\n    }\n    return false;\n}\nfunction isValidAssignmentTarget(node) {\n    switch (node.kind) {\n        case SyntaxKind.Identifier:\n            return true;\n        case SyntaxKind.PropertyAccessExpression:\n        case SyntaxKind.ElementAccessExpression:\n            if (node.flags & ts.NodeFlags.OptionalChain) {\n                return false;\n            }\n            return true;\n        case SyntaxKind.ParenthesizedExpression:\n        case SyntaxKind.TypeAssertionExpression:\n        case SyntaxKind.AsExpression:\n        case SyntaxKind.SatisfiesExpression:\n        case SyntaxKind.ExpressionWithTypeArguments:\n        case SyntaxKind.NonNullExpression:\n            return isValidAssignmentTarget(node.expression);\n        default:\n            return false;\n    }\n}\nfunction getNamespaceModifiers(node) {\n    // For following nested namespaces, use modifiers given to the topmost namespace\n    //   export declare namespace foo.bar.baz {}\n    let modifiers = (0, getModifiers_1.getModifiers)(node);\n    let moduleDeclaration = node;\n    while ((!modifiers || modifiers.length === 0) &&\n        ts.isModuleDeclaration(moduleDeclaration.parent)) {\n        const parentModifiers = (0, getModifiers_1.getModifiers)(moduleDeclaration.parent);\n        if (parentModifiers?.length) {\n            modifiers = parentModifiers;\n        }\n        moduleDeclaration = moduleDeclaration.parent;\n    }\n    return modifiers;\n}\n"
        }
    ]
}