{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/inferSingleRun.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892002174,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.inferSingleRun = inferSingleRun;\nconst node_path_1 = __importDefault(require(\"node:path\"));\n/**\n * ESLint (and therefore typescript-eslint) is used in both \"single run\"/one-time contexts,\n * such as an ESLint CLI invocation, and long-running sessions (such as continuous feedback\n * on a file in an IDE).\n *\n * When typescript-eslint handles TypeScript Program management behind the scenes, this distinction\n * is important because there is significant overhead to managing the so called Watch Programs\n * needed for the long-running use-case. We therefore use the following logic to figure out which\n * of these contexts applies to the current execution.\n *\n * @returns Whether this is part of a single run, rather than a long-running process.\n */\nfunction inferSingleRun(options) {\n    // https://github.com/typescript-eslint/typescript-eslint/issues/9504\n    // There's no support (yet?) for extraFileExtensions in single-run hosts.\n    // Only watch program hosts and project service can support that.\n    if (options?.extraFileExtensions?.length) {\n        return false;\n    }\n    if (\n    // single-run implies type-aware linting - no projects means we can't be in single-run mode\n    options?.project == null ||\n        // programs passed via options means the user should be managing the programs, so we shouldn't\n        // be creating our own single-run programs accidentally\n        options.programs != null) {\n        return false;\n    }\n    // Allow users to explicitly inform us of their intent to perform a single run (or not) with TSESTREE_SINGLE_RUN\n    if (process.env.TSESTREE_SINGLE_RUN === 'false') {\n        return false;\n    }\n    if (process.env.TSESTREE_SINGLE_RUN === 'true') {\n        return true;\n    }\n    // Ideally, we'd like to try to auto-detect CI or CLI usage that lets us infer a single CLI run.\n    if (!options.disallowAutomaticSingleRunInference) {\n        const possibleEslintBinPaths = [\n            'node_modules/.bin/eslint', // npm or yarn repo\n            'node_modules/eslint/bin/eslint.js', // pnpm repo\n        ];\n        if (\n        // Default to single runs for CI processes. CI=true is set by most CI providers by default.\n        process.env.CI === 'true' ||\n            // This will be true for invocations such as `npx eslint ...` and `./node_modules/.bin/eslint ...`\n            possibleEslintBinPaths.some(binPath => process.argv.length > 1 &&\n                process.argv[1].endsWith(node_path_1.default.normalize(binPath)))) {\n            return !process.argv.includes('--fix');\n        }\n    }\n    /**\n     * We default to assuming that this run could be part of a long-running session (e.g. in an IDE)\n     * and watch programs will therefore be required.\n     *\n     * Unless we can reliably infer otherwise, we default to assuming that this run could be part\n     * of a long-running session (e.g. in an IDE) and watch programs will therefore be required\n     */\n    return false;\n}\n"
        }
    ]
}