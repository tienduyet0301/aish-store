{
    "sourceFile": "node_modules/@typescript-eslint/typescript-estree/dist/convert.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891998927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Converter = void 0;\nexports.convertError = convertError;\n// There's lots of funny stuff due to the typing of ts.Node\n/* eslint-disable @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access */\nconst ts = __importStar(require(\"typescript\"));\nconst getModifiers_1 = require(\"./getModifiers\");\nconst node_utils_1 = require(\"./node-utils\");\nconst ts_estree_1 = require(\"./ts-estree\");\nconst SyntaxKind = ts.SyntaxKind;\n/**\n * Extends and formats a given error object\n * @param error the error object\n * @returns converted error object\n */\nfunction convertError(error) {\n    return (0, node_utils_1.createError)(('message' in error && error.message) || error.messageText, error.file, error.start);\n}\nclass Converter {\n    allowPattern = false;\n    ast;\n    esTreeNodeToTSNodeMap = new WeakMap();\n    options;\n    tsNodeToESTreeNodeMap = new WeakMap();\n    /**\n     * Converts a TypeScript node into an ESTree node\n     * @param ast the full TypeScript AST\n     * @param options additional options for the conversion\n     * @returns the converted ESTreeNode\n     */\n    constructor(ast, options) {\n        this.ast = ast;\n        this.options = { ...options };\n    }\n    #checkForStatementDeclaration(initializer, kind) {\n        const loop = kind === ts.SyntaxKind.ForInStatement ? 'for...in' : 'for...of';\n        if (ts.isVariableDeclarationList(initializer)) {\n            if (initializer.declarations.length !== 1) {\n                this.#throwError(initializer, `Only a single variable declaration is allowed in a '${loop}' statement.`);\n            }\n            const declaration = initializer.declarations[0];\n            if (declaration.initializer) {\n                this.#throwError(declaration, `The variable declaration of a '${loop}' statement cannot have an initializer.`);\n            }\n            else if (declaration.type) {\n                this.#throwError(declaration, `The variable declaration of a '${loop}' statement cannot have a type annotation.`);\n            }\n            if (kind === ts.SyntaxKind.ForInStatement &&\n                initializer.flags & ts.NodeFlags.Using) {\n                this.#throwError(initializer, \"The left-hand side of a 'for...in' statement cannot be a 'using' declaration.\");\n            }\n        }\n        else if (!(0, node_utils_1.isValidAssignmentTarget)(initializer) &&\n            initializer.kind !== ts.SyntaxKind.ObjectLiteralExpression &&\n            initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\n            this.#throwError(initializer, `The left-hand side of a '${loop}' statement must be a variable or a property access.`);\n        }\n    }\n    #checkModifiers(node) {\n        if (this.options.allowInvalidAST) {\n            return;\n        }\n        // typescript<5.0.0\n        if ((0, node_utils_1.nodeHasIllegalDecorators)(node)) {\n            this.#throwError(node.illegalDecorators[0], 'Decorators are not valid here.');\n        }\n        for (const decorator of (0, getModifiers_1.getDecorators)(node, \n        /* includeIllegalDecorators */ true) ?? []) {\n            // `checkGrammarModifiers` function in typescript\n            if (!(0, node_utils_1.nodeCanBeDecorated)(node)) {\n                if (ts.isMethodDeclaration(node) && !(0, node_utils_1.nodeIsPresent)(node.body)) {\n                    this.#throwError(decorator, 'A decorator can only decorate a method implementation, not an overload.');\n                }\n                else {\n                    this.#throwError(decorator, 'Decorators are not valid here.');\n                }\n            }\n        }\n        for (const modifier of (0, getModifiers_1.getModifiers)(node, \n        /* includeIllegalModifiers */ true) ?? []) {\n            if (modifier.kind !== SyntaxKind.ReadonlyKeyword) {\n                if (node.kind === SyntaxKind.PropertySignature ||\n                    node.kind === SyntaxKind.MethodSignature) {\n                    this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier cannot appear on a type member`);\n                }\n                if (node.kind === SyntaxKind.IndexSignature &&\n                    (modifier.kind !== SyntaxKind.StaticKeyword ||\n                        !ts.isClassLike(node.parent))) {\n                    this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier cannot appear on an index signature`);\n                }\n            }\n            if (modifier.kind !== SyntaxKind.InKeyword &&\n                modifier.kind !== SyntaxKind.OutKeyword &&\n                modifier.kind !== SyntaxKind.ConstKeyword &&\n                node.kind === SyntaxKind.TypeParameter) {\n                this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier cannot appear on a type parameter`);\n            }\n            if ((modifier.kind === SyntaxKind.InKeyword ||\n                modifier.kind === SyntaxKind.OutKeyword) &&\n                (node.kind !== SyntaxKind.TypeParameter ||\n                    !(ts.isInterfaceDeclaration(node.parent) ||\n                        ts.isClassLike(node.parent) ||\n                        ts.isTypeAliasDeclaration(node.parent)))) {\n                this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier can only appear on a type parameter of a class, interface or type alias`);\n            }\n            if (modifier.kind === SyntaxKind.ReadonlyKeyword &&\n                node.kind !== SyntaxKind.PropertyDeclaration &&\n                node.kind !== SyntaxKind.PropertySignature &&\n                node.kind !== SyntaxKind.IndexSignature &&\n                node.kind !== SyntaxKind.Parameter) {\n                this.#throwError(modifier, \"'readonly' modifier can only appear on a property declaration or index signature.\");\n            }\n            if (modifier.kind === SyntaxKind.DeclareKeyword &&\n                ts.isClassLike(node.parent) &&\n                !ts.isPropertyDeclaration(node)) {\n                this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier cannot appear on class elements of this kind.`);\n            }\n            if (modifier.kind === SyntaxKind.DeclareKeyword &&\n                ts.isVariableStatement(node)) {\n                const declarationKind = (0, node_utils_1.getDeclarationKind)(node.declarationList);\n                if (declarationKind === 'using' || declarationKind === 'await using') {\n                    this.#throwError(modifier, `'declare' modifier cannot appear on a '${declarationKind}' declaration.`);\n                }\n            }\n            if (modifier.kind === SyntaxKind.AbstractKeyword &&\n                node.kind !== SyntaxKind.ClassDeclaration &&\n                node.kind !== SyntaxKind.ConstructorType &&\n                node.kind !== SyntaxKind.MethodDeclaration &&\n                node.kind !== SyntaxKind.PropertyDeclaration &&\n                node.kind !== SyntaxKind.GetAccessor &&\n                node.kind !== SyntaxKind.SetAccessor) {\n                this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier can only appear on a class, method, or property declaration.`);\n            }\n            if ((modifier.kind === SyntaxKind.StaticKeyword ||\n                modifier.kind === SyntaxKind.PublicKeyword ||\n                modifier.kind === SyntaxKind.ProtectedKeyword ||\n                modifier.kind === SyntaxKind.PrivateKeyword) &&\n                (node.parent.kind === SyntaxKind.ModuleBlock ||\n                    node.parent.kind === SyntaxKind.SourceFile)) {\n                this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier cannot appear on a module or namespace element.`);\n            }\n            if (modifier.kind === SyntaxKind.AccessorKeyword &&\n                node.kind !== SyntaxKind.PropertyDeclaration) {\n                this.#throwError(modifier, \"'accessor' modifier can only appear on a property declaration.\");\n            }\n            // `checkGrammarAsyncModifier` function in `typescript`\n            if (modifier.kind === SyntaxKind.AsyncKeyword &&\n                node.kind !== SyntaxKind.MethodDeclaration &&\n                node.kind !== SyntaxKind.FunctionDeclaration &&\n                node.kind !== SyntaxKind.FunctionExpression &&\n                node.kind !== SyntaxKind.ArrowFunction) {\n                this.#throwError(modifier, \"'async' modifier cannot be used here.\");\n            }\n            // `checkGrammarModifiers` function in `typescript`\n            if (node.kind === SyntaxKind.Parameter &&\n                (modifier.kind === SyntaxKind.StaticKeyword ||\n                    modifier.kind === SyntaxKind.ExportKeyword ||\n                    modifier.kind === SyntaxKind.DeclareKeyword ||\n                    modifier.kind === SyntaxKind.AsyncKeyword)) {\n                this.#throwError(modifier, `'${ts.tokenToString(modifier.kind)}' modifier cannot appear on a parameter.`);\n            }\n            // `checkGrammarModifiers` function in `typescript`\n            if (modifier.kind === SyntaxKind.PublicKeyword ||\n                modifier.kind === SyntaxKind.ProtectedKeyword ||\n                modifier.kind === SyntaxKind.PrivateKeyword) {\n                for (const anotherModifier of (0, getModifiers_1.getModifiers)(node) ?? []) {\n                    if (anotherModifier !== modifier &&\n                        (anotherModifier.kind === SyntaxKind.PublicKeyword ||\n                            anotherModifier.kind === SyntaxKind.ProtectedKeyword ||\n                            anotherModifier.kind === SyntaxKind.PrivateKeyword)) {\n                        this.#throwError(anotherModifier, `Accessibility modifier already seen.`);\n                    }\n                }\n            }\n            // `checkParameter` function in `typescript`\n            if (node.kind === SyntaxKind.Parameter &&\n                // In `typescript` package, it's `ts.hasSyntacticModifier(node, ts.ModifierFlags.ParameterPropertyModifier)`\n                // https://github.com/typescript-eslint/typescript-eslint/pull/6615#discussion_r1136489935\n                (modifier.kind === SyntaxKind.PublicKeyword ||\n                    modifier.kind === SyntaxKind.PrivateKeyword ||\n                    modifier.kind === SyntaxKind.ProtectedKeyword ||\n                    modifier.kind === SyntaxKind.ReadonlyKeyword ||\n                    modifier.kind === SyntaxKind.OverrideKeyword)) {\n                const func = (0, node_utils_1.getContainingFunction)(node);\n                if (!(func.kind === SyntaxKind.Constructor && (0, node_utils_1.nodeIsPresent)(func.body))) {\n                    this.#throwError(modifier, 'A parameter property is only allowed in a constructor implementation.');\n                }\n            }\n        }\n    }\n    #throwError(node, message) {\n        let start;\n        let end;\n        if (typeof node === 'number') {\n            start = end = node;\n        }\n        else {\n            start = node.getStart(this.ast);\n            end = node.getEnd();\n        }\n        throw (0, node_utils_1.createError)(message, this.ast, start, end);\n    }\n    #throwUnlessAllowInvalidAST(node, message) {\n        if (!this.options.allowInvalidAST) {\n            this.#throwError(node, message);\n        }\n    }\n    /**\n     * Creates a getter for a property under aliasKey that returns the value under\n     * valueKey. If suppressDeprecatedPropertyWarnings is not enabled, the\n     * getter also console warns about the deprecation.\n     *\n     * @see https://github.com/typescript-eslint/typescript-eslint/issues/6469\n     */\n    #withDeprecatedAliasGetter(node, aliasKey, valueKey, suppressWarnings = false) {\n        let warned = suppressWarnings;\n        Object.defineProperty(node, aliasKey, {\n            configurable: true,\n            get: this.options.suppressDeprecatedPropertyWarnings\n                ? () => node[valueKey]\n                : () => {\n                    if (!warned) {\n                        process.emitWarning(`The '${aliasKey}' property is deprecated on ${node.type} nodes. Use '${valueKey}' instead. See https://typescript-eslint.io/troubleshooting/faqs/general#the-key-property-is-deprecated-on-type-nodes-use-key-instead-warnings.`, 'DeprecationWarning');\n                        warned = true;\n                    }\n                    return node[valueKey];\n                },\n            set(value) {\n                Object.defineProperty(node, aliasKey, {\n                    enumerable: true,\n                    value,\n                    writable: true,\n                });\n            },\n        });\n        return node;\n    }\n    #withDeprecatedGetter(node, deprecatedKey, preferredKey, value) {\n        let warned = false;\n        Object.defineProperty(node, deprecatedKey, {\n            configurable: true,\n            get: this.options.suppressDeprecatedPropertyWarnings\n                ? () => value\n                : () => {\n                    if (!warned) {\n                        process.emitWarning(`The '${deprecatedKey}' property is deprecated on ${node.type} nodes. Use ${preferredKey} instead. See https://typescript-eslint.io/troubleshooting/faqs/general#the-key-property-is-deprecated-on-type-nodes-use-key-instead-warnings.`, 'DeprecationWarning');\n                        warned = true;\n                    }\n                    return value;\n                },\n            set(value) {\n                Object.defineProperty(node, deprecatedKey, {\n                    enumerable: true,\n                    value,\n                    writable: true,\n                });\n            },\n        });\n        return node;\n    }\n    assertModuleSpecifier(node, allowNull) {\n        if (!allowNull && node.moduleSpecifier == null) {\n            this.#throwUnlessAllowInvalidAST(node, 'Module specifier must be a string literal.');\n        }\n        if (node.moduleSpecifier &&\n            node.moduleSpecifier?.kind !== SyntaxKind.StringLiteral) {\n            this.#throwUnlessAllowInvalidAST(node.moduleSpecifier, 'Module specifier must be a string literal.');\n        }\n    }\n    convertBindingNameWithTypeAnnotation(name, tsType, parent) {\n        const id = this.convertPattern(name);\n        if (tsType) {\n            id.typeAnnotation = this.convertTypeAnnotation(tsType, parent);\n            this.fixParentLocation(id, id.typeAnnotation.range);\n        }\n        return id;\n    }\n    /**\n     * Coverts body Nodes and add a directive field to StringLiterals\n     * @param nodes of ts.Node\n     * @param parent parentNode\n     * @returns Array of body statements\n     */\n    convertBodyExpressions(nodes, parent) {\n        let allowDirectives = (0, node_utils_1.canContainDirective)(parent);\n        return (nodes\n            .map(statement => {\n            const child = this.convertChild(statement);\n            if (allowDirectives) {\n                if (child?.expression &&\n                    ts.isExpressionStatement(statement) &&\n                    ts.isStringLiteral(statement.expression)) {\n                    const raw = child.expression.raw;\n                    child.directive = raw.slice(1, -1);\n                    return child; // child can be null, but it's filtered below\n                }\n                allowDirectives = false;\n            }\n            return child; // child can be null, but it's filtered below\n        })\n            // filter out unknown nodes for now\n            .filter(statement => statement));\n    }\n    convertChainExpression(node, tsNode) {\n        const { child, isOptional } = (() => {\n            if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n                return { child: node.object, isOptional: node.optional };\n            }\n            if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n                return { child: node.callee, isOptional: node.optional };\n            }\n            return { child: node.expression, isOptional: false };\n        })();\n        const isChildUnwrappable = (0, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);\n        if (!isChildUnwrappable && !isOptional) {\n            return node;\n        }\n        if (isChildUnwrappable && (0, node_utils_1.isChainExpression)(child)) {\n            // unwrap the chain expression child\n            const newChild = child.expression;\n            if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {\n                node.object = newChild;\n            }\n            else if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {\n                node.callee = newChild;\n            }\n            else {\n                node.expression = newChild;\n            }\n        }\n        return this.createNode(tsNode, {\n            type: ts_estree_1.AST_NODE_TYPES.ChainExpression,\n            expression: node,\n        });\n    }\n    /**\n     * Converts a TypeScript node into an ESTree node.\n     * @param child the child ts.Node\n     * @param parent parentNode\n     * @returns the converted ESTree node\n     */\n    convertChild(child, parent) {\n        return this.converter(child, parent, false);\n    }\n    /**\n     * Converts a TypeScript node into an ESTree node.\n     * @param child the child ts.Node\n     * @param parent parentNode\n     * @returns the converted ESTree node\n     */\n    convertPattern(child, parent) {\n        return this.converter(child, parent, true);\n    }\n    /**\n     * Converts a child into a type annotation. This creates an intermediary\n     * TypeAnnotation node to match what Flow does.\n     * @param child The TypeScript AST node to convert.\n     * @param parent parentNode\n     * @returns The type annotation node.\n     */\n    convertTypeAnnotation(child, parent) {\n        // in FunctionType and ConstructorType typeAnnotation has 2 characters `=>` and in other places is just colon\n        const offset = parent?.kind === SyntaxKind.FunctionType ||\n            parent?.kind === SyntaxKind.ConstructorType\n            ? 2\n            : 1;\n        const annotationStartCol = child.getFullStart() - offset;\n        const range = [annotationStartCol, child.end];\n        const loc = (0, node_utils_1.getLocFor)(range, this.ast);\n        return {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,\n            loc,\n            range,\n            typeAnnotation: this.convertChild(child),\n        };\n    }\n    /**\n     * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node\n     * @param typeArguments ts.NodeArray typeArguments\n     * @param node parent used to create this node\n     * @returns TypeParameterInstantiation node\n     */\n    convertTypeArgumentsToTypeParameterInstantiation(typeArguments, node) {\n        const greaterThanToken = (0, node_utils_1.findNextToken)(typeArguments, this.ast, this.ast);\n        return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,\n            range: [typeArguments.pos - 1, greaterThanToken.end],\n            params: typeArguments.map(typeArgument => this.convertChild(typeArgument)),\n        });\n    }\n    /**\n     * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node\n     * @param typeParameters ts.Node typeParameters\n     * @returns TypeParameterDeclaration node\n     */\n    convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {\n        const greaterThanToken = (0, node_utils_1.findNextToken)(typeParameters, this.ast, this.ast);\n        const range = [\n            typeParameters.pos - 1,\n            greaterThanToken.end,\n        ];\n        return {\n            type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,\n            loc: (0, node_utils_1.getLocFor)(range, this.ast),\n            range,\n            params: typeParameters.map(typeParameter => this.convertChild(typeParameter)),\n        };\n    }\n    /**\n     * Converts an array of ts.Node parameters into an array of ESTreeNode params\n     * @param parameters An array of ts.Node params to be converted\n     * @returns an array of converted ESTreeNode params\n     */\n    convertParameters(parameters) {\n        if (!parameters?.length) {\n            return [];\n        }\n        return parameters.map(param => {\n            const convertedParam = this.convertChild(param);\n            convertedParam.decorators =\n                (0, getModifiers_1.getDecorators)(param)?.map(el => this.convertChild(el)) ?? [];\n            return convertedParam;\n        });\n    }\n    /**\n     * Converts a TypeScript node into an ESTree node.\n     * @param node the child ts.Node\n     * @param parent parentNode\n     * @param allowPattern flag to determine if patterns are allowed\n     * @returns the converted ESTree node\n     */\n    converter(node, parent, allowPattern) {\n        /**\n         * Exit early for null and undefined\n         */\n        if (!node) {\n            return null;\n        }\n        this.#checkModifiers(node);\n        const pattern = this.allowPattern;\n        if (allowPattern != null) {\n            this.allowPattern = allowPattern;\n        }\n        const result = this.convertNode(node, (parent ?? node.parent));\n        this.registerTSNodeInNodeMap(node, result);\n        this.allowPattern = pattern;\n        return result;\n    }\n    convertImportAttributes(node) {\n        return node == null\n            ? []\n            : node.elements.map(element => this.convertChild(element));\n    }\n    convertJSXIdentifier(node) {\n        const result = this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n            name: node.getText(),\n        });\n        this.registerTSNodeInNodeMap(node, result);\n        return result;\n    }\n    convertJSXNamespaceOrIdentifier(node) {\n        // TypeScript@5.1 added in ts.JsxNamespacedName directly\n        // We prefer using that if it's relevant for this node type\n        if (node.kind === ts.SyntaxKind.JsxNamespacedName) {\n            const result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n                name: this.createNode(node.name, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n                    name: node.name.text,\n                }),\n                namespace: this.createNode(node.namespace, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n                    name: node.namespace.text,\n                }),\n            });\n            this.registerTSNodeInNodeMap(node, result);\n            return result;\n        }\n        // TypeScript@<5.1 has to manually parse the JSX attributes\n        const text = node.getText();\n        const colonIndex = text.indexOf(':');\n        // this is intentional we can ignore conversion if `:` is in first character\n        if (colonIndex > 0) {\n            const range = (0, node_utils_1.getRange)(node, this.ast);\n            const result = this.createNode(node, {\n                type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,\n                range,\n                name: this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n                    range: [range[0] + colonIndex + 1, range[1]],\n                    name: text.slice(colonIndex + 1),\n                }),\n                namespace: this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,\n                    range: [range[0], range[0] + colonIndex],\n                    name: text.slice(0, colonIndex),\n                }),\n            });\n            this.registerTSNodeInNodeMap(node, result);\n            return result;\n        }\n        return this.convertJSXIdentifier(node);\n    }\n    /**\n     * Converts a TypeScript JSX node.tagName into an ESTree node.name\n     * @param node the tagName object from a JSX ts.Node\n     * @returns the converted ESTree name object\n     */\n    convertJSXTagName(node, parent) {\n        let result;\n        switch (node.kind) {\n            case SyntaxKind.PropertyAccessExpression:\n                if (node.name.kind === SyntaxKind.PrivateIdentifier) {\n                    // This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.\n                    // So we shouldn't ever get into this state to begin with.\n                    this.#throwError(node.name, 'Non-private identifier expected.');\n                }\n                result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,\n                    object: this.convertJSXTagName(node.expression, parent),\n                    property: this.convertJSXIdentifier(node.name),\n                });\n                break;\n            case SyntaxKind.ThisKeyword:\n            case SyntaxKind.Identifier:\n            default:\n                return this.convertJSXNamespaceOrIdentifier(node);\n        }\n        this.registerTSNodeInNodeMap(node, result);\n        return result;\n    }\n    convertMethodSignature(node) {\n        return this.createNode(node, {\n            type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,\n            accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n            computed: (0, node_utils_1.isComputedProperty)(node.name),\n            key: this.convertChild(node.name),\n            kind: (() => {\n                switch (node.kind) {\n                    case SyntaxKind.GetAccessor:\n                        return 'get';\n                    case SyntaxKind.SetAccessor:\n                        return 'set';\n                    case SyntaxKind.MethodSignature:\n                        return 'method';\n                }\n            })(),\n            optional: (0, node_utils_1.isOptional)(node),\n            params: this.convertParameters(node.parameters),\n            readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),\n            returnType: node.type && this.convertTypeAnnotation(node.type, node),\n            static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n            typeParameters: node.typeParameters &&\n                this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n        });\n    }\n    /**\n     * Uses the provided range location to adjust the location data of the given Node\n     * @param result The node that will have its location data mutated\n     * @param childRange The child node range used to expand location\n     */\n    fixParentLocation(result, childRange) {\n        if (childRange[0] < result.range[0]) {\n            result.range[0] = childRange[0];\n            result.loc.start = (0, node_utils_1.getLineAndCharacterFor)(result.range[0], this.ast);\n        }\n        if (childRange[1] > result.range[1]) {\n            result.range[1] = childRange[1];\n            result.loc.end = (0, node_utils_1.getLineAndCharacterFor)(result.range[1], this.ast);\n        }\n    }\n    /**\n     * Converts a TypeScript node into an ESTree node.\n     * The core of the conversion logic:\n     * Identify and convert each relevant TypeScript SyntaxKind\n     * @returns the converted ESTree node\n     */\n    convertNode(node, parent) {\n        switch (node.kind) {\n            case SyntaxKind.SourceFile: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Program,\n                    range: [node.getStart(this.ast), node.endOfFileToken.end],\n                    body: this.convertBodyExpressions(node.statements, node),\n                    comments: undefined,\n                    sourceType: node.externalModuleIndicator ? 'module' : 'script',\n                    tokens: undefined,\n                });\n            }\n            case SyntaxKind.Block: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.BlockStatement,\n                    body: this.convertBodyExpressions(node.statements, node),\n                });\n            }\n            case SyntaxKind.Identifier: {\n                if ((0, node_utils_1.isThisInTypeQuery)(node)) {\n                    // special case for `typeof this.foo` - TS emits an Identifier for `this`\n                    // but we want to treat it as a ThisExpression for consistency\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.ThisExpression,\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Identifier,\n                    decorators: [],\n                    name: node.text,\n                    optional: false,\n                    typeAnnotation: undefined,\n                });\n            }\n            case SyntaxKind.PrivateIdentifier: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,\n                    // typescript includes the `#` in the text\n                    name: node.text.slice(1),\n                });\n            }\n            case SyntaxKind.WithStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.WithStatement,\n                    body: this.convertChild(node.statement),\n                    object: this.convertChild(node.expression),\n                });\n            // Control Flow\n            case SyntaxKind.ReturnStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,\n                    argument: this.convertChild(node.expression),\n                });\n            case SyntaxKind.LabeledStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,\n                    body: this.convertChild(node.statement),\n                    label: this.convertChild(node.label),\n                });\n            case SyntaxKind.ContinueStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,\n                    label: this.convertChild(node.label),\n                });\n            case SyntaxKind.BreakStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.BreakStatement,\n                    label: this.convertChild(node.label),\n                });\n            // Choice\n            case SyntaxKind.IfStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.IfStatement,\n                    alternate: this.convertChild(node.elseStatement),\n                    consequent: this.convertChild(node.thenStatement),\n                    test: this.convertChild(node.expression),\n                });\n            case SyntaxKind.SwitchStatement:\n                if (node.caseBlock.clauses.filter(switchCase => switchCase.kind === SyntaxKind.DefaultClause).length > 1) {\n                    this.#throwError(node, \"A 'default' clause cannot appear more than once in a 'switch' statement.\");\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,\n                    cases: node.caseBlock.clauses.map(el => this.convertChild(el)),\n                    discriminant: this.convertChild(node.expression),\n                });\n            case SyntaxKind.CaseClause:\n            case SyntaxKind.DefaultClause:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.SwitchCase,\n                    // expression is present in case only\n                    consequent: node.statements.map(el => this.convertChild(el)),\n                    test: node.kind === SyntaxKind.CaseClause\n                        ? this.convertChild(node.expression)\n                        : null,\n                });\n            // Exceptions\n            case SyntaxKind.ThrowStatement:\n                if (node.expression.end === node.expression.pos) {\n                    this.#throwUnlessAllowInvalidAST(node, 'A throw statement must throw an expression.');\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,\n                    argument: this.convertChild(node.expression),\n                });\n            case SyntaxKind.TryStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TryStatement,\n                    block: this.convertChild(node.tryBlock),\n                    finalizer: this.convertChild(node.finallyBlock),\n                    handler: this.convertChild(node.catchClause),\n                });\n            case SyntaxKind.CatchClause:\n                if (node.variableDeclaration?.initializer) {\n                    this.#throwError(node.variableDeclaration.initializer, 'Catch clause variable cannot have an initializer.');\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.CatchClause,\n                    body: this.convertChild(node.block),\n                    param: node.variableDeclaration\n                        ? this.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type)\n                        : null,\n                });\n            // Loops\n            case SyntaxKind.WhileStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.WhileStatement,\n                    body: this.convertChild(node.statement),\n                    test: this.convertChild(node.expression),\n                });\n            /**\n             * Unlike other parsers, TypeScript calls a \"DoWhileStatement\"\n             * a \"DoStatement\"\n             */\n            case SyntaxKind.DoStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,\n                    body: this.convertChild(node.statement),\n                    test: this.convertChild(node.expression),\n                });\n            case SyntaxKind.ForStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ForStatement,\n                    body: this.convertChild(node.statement),\n                    init: this.convertChild(node.initializer),\n                    test: this.convertChild(node.condition),\n                    update: this.convertChild(node.incrementor),\n                });\n            case SyntaxKind.ForInStatement:\n                this.#checkForStatementDeclaration(node.initializer, node.kind);\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ForInStatement,\n                    body: this.convertChild(node.statement),\n                    left: this.convertPattern(node.initializer),\n                    right: this.convertChild(node.expression),\n                });\n            case SyntaxKind.ForOfStatement: {\n                this.#checkForStatementDeclaration(node.initializer, node.kind);\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,\n                    await: Boolean(node.awaitModifier &&\n                        node.awaitModifier.kind === SyntaxKind.AwaitKeyword),\n                    body: this.convertChild(node.statement),\n                    left: this.convertPattern(node.initializer),\n                    right: this.convertChild(node.expression),\n                });\n            }\n            // Declarations\n            case SyntaxKind.FunctionDeclaration: {\n                const isDeclare = (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);\n                const isAsync = (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node);\n                const isGenerator = !!node.asteriskToken;\n                if (isDeclare) {\n                    if (node.body) {\n                        this.#throwError(node, 'An implementation cannot be declared in ambient contexts.');\n                    }\n                    else if (isAsync) {\n                        this.#throwError(node, \"'async' modifier cannot be used in an ambient context.\");\n                    }\n                    else if (isGenerator) {\n                        this.#throwError(node, 'Generators are not allowed in an ambient context.');\n                    }\n                }\n                else if (!node.body && isGenerator) {\n                    this.#throwError(node, 'A function signature cannot be declared as a generator.');\n                }\n                const result = this.createNode(node, {\n                    // declare implies no body due to the invariant above\n                    type: !node.body\n                        ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction\n                        : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,\n                    async: isAsync,\n                    body: this.convertChild(node.body) || undefined,\n                    declare: isDeclare,\n                    expression: false,\n                    generator: isGenerator,\n                    id: this.convertChild(node.name),\n                    params: this.convertParameters(node.parameters),\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n                return this.fixExports(node, result);\n            }\n            case SyntaxKind.VariableDeclaration: {\n                const definite = !!node.exclamationToken;\n                const init = this.convertChild(node.initializer);\n                const id = this.convertBindingNameWithTypeAnnotation(node.name, node.type, node);\n                if (definite) {\n                    if (init) {\n                        this.#throwError(node, 'Declarations with initializers cannot also have definite assignment assertions.');\n                    }\n                    else if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier ||\n                        !id.typeAnnotation) {\n                        this.#throwError(node, 'Declarations with definite assignment assertions must also have type annotations.');\n                    }\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,\n                    definite,\n                    id,\n                    init,\n                });\n            }\n            case SyntaxKind.VariableStatement: {\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n                    declarations: node.declarationList.declarations.map(el => this.convertChild(el)),\n                    declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n                    kind: (0, node_utils_1.getDeclarationKind)(node.declarationList),\n                });\n                if (!result.declarations.length) {\n                    this.#throwUnlessAllowInvalidAST(node, 'A variable declaration list must have at least one variable declarator.');\n                }\n                if (result.kind === 'using' || result.kind === 'await using') {\n                    node.declarationList.declarations.forEach((declaration, i) => {\n                        if (result.declarations[i].init == null) {\n                            this.#throwError(declaration, `'${result.kind}' declarations must be initialized.`);\n                        }\n                        if (result.declarations[i].id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                            this.#throwError(declaration.name, `'${result.kind}' declarations may not have binding patterns.`);\n                        }\n                    });\n                }\n                // Definite assignment only allowed for non-declare let and var\n                if (result.declare ||\n                    ['await using', 'const', 'using'].includes(result.kind)) {\n                    node.declarationList.declarations.forEach((declaration, i) => {\n                        if (result.declarations[i].definite) {\n                            this.#throwError(declaration, `A definite assignment assertion '!' is not permitted in this context.`);\n                        }\n                    });\n                }\n                if (result.declare) {\n                    node.declarationList.declarations.forEach((declaration, i) => {\n                        if (result.declarations[i].init &&\n                            (['let', 'var'].includes(result.kind) ||\n                                result.declarations[i].id.typeAnnotation)) {\n                            this.#throwError(declaration, `Initializers are not permitted in ambient contexts.`);\n                        }\n                    });\n                    // Theoretically, only certain initializers are allowed for declare const,\n                    // (TS1254: A 'const' initializer in an ambient context must be a string\n                    // or numeric literal or literal enum reference.) but we just allow\n                    // all expressions\n                }\n                // Note! No-declare does not mean the variable is not ambient, because\n                // it can be further nested in other declare contexts. Therefore we cannot\n                // check for const initializers.\n                /**\n                 * Semantically, decorators are not allowed on variable declarations,\n                 * Pre 4.8 TS would include them in the AST, so we did as well.\n                 * However as of 4.8 TS no longer includes it (as it is, well, invalid).\n                 *\n                 * So for consistency across versions, we no longer include it either.\n                 */\n                return this.fixExports(node, result);\n            }\n            // mostly for for-of, for-in\n            case SyntaxKind.VariableDeclarationList: {\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,\n                    declarations: node.declarations.map(el => this.convertChild(el)),\n                    declare: false,\n                    kind: (0, node_utils_1.getDeclarationKind)(node),\n                });\n                if (result.kind === 'using' || result.kind === 'await using') {\n                    node.declarations.forEach((declaration, i) => {\n                        if (result.declarations[i].init != null) {\n                            this.#throwError(declaration, `'${result.kind}' declarations may not be initialized in for statement.`);\n                        }\n                        if (result.declarations[i].id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                            this.#throwError(declaration.name, `'${result.kind}' declarations may not have binding patterns.`);\n                        }\n                    });\n                }\n                return result;\n            }\n            // Expressions\n            case SyntaxKind.ExpressionStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,\n                    directive: undefined,\n                    expression: this.convertChild(node.expression),\n                });\n            case SyntaxKind.ThisKeyword:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ThisExpression,\n                });\n            case SyntaxKind.ArrayLiteralExpression: {\n                // TypeScript uses ArrayLiteralExpression in destructuring assignment, too\n                if (this.allowPattern) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n                        decorators: [],\n                        elements: node.elements.map(el => this.convertPattern(el)),\n                        optional: false,\n                        typeAnnotation: undefined,\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,\n                    elements: node.elements.map(el => this.convertChild(el)),\n                });\n            }\n            case SyntaxKind.ObjectLiteralExpression: {\n                // TypeScript uses ObjectLiteralExpression in destructuring assignment, too\n                if (this.allowPattern) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n                        decorators: [],\n                        optional: false,\n                        properties: node.properties.map(el => this.convertPattern(el)),\n                        typeAnnotation: undefined,\n                    });\n                }\n                const properties = [];\n                for (const property of node.properties) {\n                    if ((property.kind === SyntaxKind.GetAccessor ||\n                        property.kind === SyntaxKind.SetAccessor ||\n                        property.kind === SyntaxKind.MethodDeclaration) &&\n                        !property.body) {\n                        this.#throwUnlessAllowInvalidAST(property.end - 1, \"'{' expected.\");\n                    }\n                    properties.push(this.convertChild(property));\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,\n                    properties,\n                });\n            }\n            case SyntaxKind.PropertyAssignment: {\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                const { exclamationToken, questionToken } = node;\n                if (questionToken) {\n                    this.#throwError(questionToken, 'A property assignment cannot have a question token.');\n                }\n                if (exclamationToken) {\n                    this.#throwError(exclamationToken, 'A property assignment cannot have an exclamation token.');\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Property,\n                    computed: (0, node_utils_1.isComputedProperty)(node.name),\n                    key: this.convertChild(node.name),\n                    kind: 'init',\n                    method: false,\n                    optional: false,\n                    shorthand: false,\n                    value: this.converter(node.initializer, node, this.allowPattern),\n                });\n            }\n            case SyntaxKind.ShorthandPropertyAssignment: {\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                const { exclamationToken, modifiers, questionToken } = node;\n                if (modifiers) {\n                    this.#throwError(modifiers[0], 'A shorthand property assignment cannot have modifiers.');\n                }\n                if (questionToken) {\n                    this.#throwError(questionToken, 'A shorthand property assignment cannot have a question token.');\n                }\n                if (exclamationToken) {\n                    this.#throwError(exclamationToken, 'A shorthand property assignment cannot have an exclamation token.');\n                }\n                if (node.objectAssignmentInitializer) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.Property,\n                        computed: false,\n                        key: this.convertChild(node.name),\n                        kind: 'init',\n                        method: false,\n                        optional: false,\n                        shorthand: true,\n                        value: this.createNode(node, {\n                            type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                            decorators: [],\n                            left: this.convertPattern(node.name),\n                            optional: false,\n                            right: this.convertChild(node.objectAssignmentInitializer),\n                            typeAnnotation: undefined,\n                        }),\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Property,\n                    computed: false,\n                    key: this.convertChild(node.name),\n                    kind: 'init',\n                    method: false,\n                    optional: false,\n                    shorthand: true,\n                    value: this.convertChild(node.name),\n                });\n            }\n            case SyntaxKind.ComputedPropertyName:\n                return this.convertChild(node.expression);\n            case SyntaxKind.PropertyDeclaration: {\n                const isAbstract = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);\n                if (isAbstract && node.initializer) {\n                    this.#throwError(node.initializer, `Abstract property cannot have an initializer.`);\n                }\n                const isAccessor = (0, node_utils_1.hasModifier)(SyntaxKind.AccessorKeyword, node);\n                const type = (() => {\n                    if (isAccessor) {\n                        if (isAbstract) {\n                            return ts_estree_1.AST_NODE_TYPES.TSAbstractAccessorProperty;\n                        }\n                        return ts_estree_1.AST_NODE_TYPES.AccessorProperty;\n                    }\n                    if (isAbstract) {\n                        return ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition;\n                    }\n                    return ts_estree_1.AST_NODE_TYPES.PropertyDefinition;\n                })();\n                const key = this.convertChild(node.name);\n                return this.createNode(node, {\n                    type,\n                    accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n                    computed: (0, node_utils_1.isComputedProperty)(node.name),\n                    declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n                    decorators: (0, getModifiers_1.getDecorators)(node)?.map(el => this.convertChild(el)) ?? [],\n                    definite: !!node.exclamationToken,\n                    key,\n                    optional: (key.type === ts_estree_1.AST_NODE_TYPES.Literal ||\n                        node.name.kind === SyntaxKind.Identifier ||\n                        node.name.kind === SyntaxKind.ComputedPropertyName ||\n                        node.name.kind === SyntaxKind.PrivateIdentifier) &&\n                        !!node.questionToken,\n                    override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),\n                    readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),\n                    static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n                    typeAnnotation: node.type && this.convertTypeAnnotation(node.type, node),\n                    value: isAbstract ? null : this.convertChild(node.initializer),\n                });\n            }\n            case SyntaxKind.GetAccessor:\n            case SyntaxKind.SetAccessor: {\n                if (node.parent.kind === SyntaxKind.InterfaceDeclaration ||\n                    node.parent.kind === SyntaxKind.TypeLiteral) {\n                    return this.convertMethodSignature(node);\n                }\n            }\n            // otherwise, it is a non-type accessor - intentional fallthrough\n            case SyntaxKind.MethodDeclaration: {\n                const method = this.createNode(node, {\n                    type: !node.body\n                        ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression\n                        : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n                    range: [node.parameters.pos - 1, node.end],\n                    async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n                    body: this.convertChild(node.body),\n                    declare: false,\n                    expression: false, // ESTreeNode as ESTreeNode here\n                    generator: !!node.asteriskToken,\n                    id: null,\n                    params: [],\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n                if (method.typeParameters) {\n                    this.fixParentLocation(method, method.typeParameters.range);\n                }\n                let result;\n                if (parent.kind === SyntaxKind.ObjectLiteralExpression) {\n                    method.params = node.parameters.map(el => this.convertChild(el));\n                    result = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.Property,\n                        computed: (0, node_utils_1.isComputedProperty)(node.name),\n                        key: this.convertChild(node.name),\n                        kind: 'init',\n                        method: node.kind === SyntaxKind.MethodDeclaration,\n                        optional: !!node.questionToken,\n                        shorthand: false,\n                        value: method,\n                    });\n                }\n                else {\n                    // class\n                    /**\n                     * Unlike in object literal methods, class method params can have decorators\n                     */\n                    method.params = this.convertParameters(node.parameters);\n                    /**\n                     * TypeScript class methods can be defined as \"abstract\"\n                     */\n                    const methodDefinitionType = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)\n                        ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition\n                        : ts_estree_1.AST_NODE_TYPES.MethodDefinition;\n                    result = this.createNode(node, {\n                        type: methodDefinitionType,\n                        accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n                        computed: (0, node_utils_1.isComputedProperty)(node.name),\n                        decorators: (0, getModifiers_1.getDecorators)(node)?.map(el => this.convertChild(el)) ?? [],\n                        key: this.convertChild(node.name),\n                        kind: 'method',\n                        optional: !!node.questionToken,\n                        override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),\n                        static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n                        value: method,\n                    });\n                }\n                if (node.kind === SyntaxKind.GetAccessor) {\n                    result.kind = 'get';\n                }\n                else if (node.kind === SyntaxKind.SetAccessor) {\n                    result.kind = 'set';\n                }\n                else if (!result.static &&\n                    node.name.kind === SyntaxKind.StringLiteral &&\n                    node.name.text === 'constructor' &&\n                    result.type !== ts_estree_1.AST_NODE_TYPES.Property) {\n                    result.kind = 'constructor';\n                }\n                return result;\n            }\n            // TypeScript uses this even for static methods named \"constructor\"\n            case SyntaxKind.Constructor: {\n                const lastModifier = (0, node_utils_1.getLastModifier)(node);\n                const constructorToken = (lastModifier && (0, node_utils_1.findNextToken)(lastModifier, node, this.ast)) ??\n                    node.getFirstToken();\n                const constructor = this.createNode(node, {\n                    type: !node.body\n                        ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression\n                        : ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n                    range: [node.parameters.pos - 1, node.end],\n                    async: false,\n                    body: this.convertChild(node.body),\n                    declare: false,\n                    expression: false, // is not present in ESTreeNode\n                    generator: false,\n                    id: null,\n                    params: this.convertParameters(node.parameters),\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n                if (constructor.typeParameters) {\n                    this.fixParentLocation(constructor, constructor.typeParameters.range);\n                }\n                const constructorKey = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Identifier,\n                    range: [constructorToken.getStart(this.ast), constructorToken.end],\n                    decorators: [],\n                    name: 'constructor',\n                    optional: false,\n                    typeAnnotation: undefined,\n                });\n                const isStatic = (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);\n                return this.createNode(node, {\n                    type: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)\n                        ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition\n                        : ts_estree_1.AST_NODE_TYPES.MethodDefinition,\n                    accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n                    computed: false,\n                    decorators: [],\n                    key: constructorKey,\n                    kind: isStatic ? 'method' : 'constructor',\n                    optional: false,\n                    override: false,\n                    static: isStatic,\n                    value: constructor,\n                });\n            }\n            case SyntaxKind.FunctionExpression: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,\n                    async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n                    body: this.convertChild(node.body),\n                    declare: false,\n                    expression: false,\n                    generator: !!node.asteriskToken,\n                    id: this.convertChild(node.name),\n                    params: this.convertParameters(node.parameters),\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n            }\n            case SyntaxKind.SuperKeyword:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Super,\n                });\n            case SyntaxKind.ArrayBindingPattern:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,\n                    decorators: [],\n                    elements: node.elements.map(el => this.convertPattern(el)),\n                    optional: false,\n                    typeAnnotation: undefined,\n                });\n            // occurs with missing array elements like [,]\n            case SyntaxKind.OmittedExpression:\n                return null;\n            case SyntaxKind.ObjectBindingPattern:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,\n                    decorators: [],\n                    optional: false,\n                    properties: node.elements.map(el => this.convertPattern(el)),\n                    typeAnnotation: undefined,\n                });\n            case SyntaxKind.BindingElement: {\n                if (parent.kind === SyntaxKind.ArrayBindingPattern) {\n                    const arrayItem = this.convertChild(node.name, parent);\n                    if (node.initializer) {\n                        return this.createNode(node, {\n                            type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                            decorators: [],\n                            left: arrayItem,\n                            optional: false,\n                            right: this.convertChild(node.initializer),\n                            typeAnnotation: undefined,\n                        });\n                    }\n                    if (node.dotDotDotToken) {\n                        return this.createNode(node, {\n                            type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                            argument: arrayItem,\n                            decorators: [],\n                            optional: false,\n                            typeAnnotation: undefined,\n                            value: undefined,\n                        });\n                    }\n                    return arrayItem;\n                }\n                let result;\n                if (node.dotDotDotToken) {\n                    result = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                        argument: this.convertChild(node.propertyName ?? node.name),\n                        decorators: [],\n                        optional: false,\n                        typeAnnotation: undefined,\n                        value: undefined,\n                    });\n                }\n                else {\n                    result = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.Property,\n                        computed: Boolean(node.propertyName &&\n                            node.propertyName.kind === SyntaxKind.ComputedPropertyName),\n                        key: this.convertChild(node.propertyName ?? node.name),\n                        kind: 'init',\n                        method: false,\n                        optional: false,\n                        shorthand: !node.propertyName,\n                        value: this.convertChild(node.name),\n                    });\n                }\n                if (node.initializer) {\n                    result.value = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                        range: [node.name.getStart(this.ast), node.initializer.end],\n                        decorators: [],\n                        left: this.convertChild(node.name),\n                        optional: false,\n                        right: this.convertChild(node.initializer),\n                        typeAnnotation: undefined,\n                    });\n                }\n                return result;\n            }\n            case SyntaxKind.ArrowFunction: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,\n                    async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),\n                    body: this.convertChild(node.body),\n                    expression: node.body.kind !== SyntaxKind.Block,\n                    generator: false,\n                    id: null,\n                    params: this.convertParameters(node.parameters),\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n            }\n            case SyntaxKind.YieldExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.YieldExpression,\n                    argument: this.convertChild(node.expression),\n                    delegate: !!node.asteriskToken,\n                });\n            case SyntaxKind.AwaitExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,\n                    argument: this.convertChild(node.expression),\n                });\n            // Template Literals\n            case SyntaxKind.NoSubstitutionTemplateLiteral:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n                    expressions: [],\n                    quasis: [\n                        this.createNode(node, {\n                            type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n                            tail: true,\n                            value: {\n                                cooked: node.text,\n                                raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - 1),\n                            },\n                        }),\n                    ],\n                });\n            case SyntaxKind.TemplateExpression: {\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,\n                    expressions: [],\n                    quasis: [this.convertChild(node.head)],\n                });\n                node.templateSpans.forEach(templateSpan => {\n                    result.expressions.push(this.convertChild(templateSpan.expression));\n                    result.quasis.push(this.convertChild(templateSpan.literal));\n                });\n                return result;\n            }\n            case SyntaxKind.TaggedTemplateExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,\n                    quasi: this.convertChild(node.template),\n                    tag: this.convertChild(node.tag),\n                    typeArguments: node.typeArguments &&\n                        this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),\n                });\n            case SyntaxKind.TemplateHead:\n            case SyntaxKind.TemplateMiddle:\n            case SyntaxKind.TemplateTail: {\n                const tail = node.kind === SyntaxKind.TemplateTail;\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TemplateElement,\n                    tail,\n                    value: {\n                        cooked: node.text,\n                        raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - (tail ? 1 : 2)),\n                    },\n                });\n            }\n            // Patterns\n            case SyntaxKind.SpreadAssignment:\n            case SyntaxKind.SpreadElement: {\n                if (this.allowPattern) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                        argument: this.convertPattern(node.expression),\n                        decorators: [],\n                        optional: false,\n                        typeAnnotation: undefined,\n                        value: undefined,\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.SpreadElement,\n                    argument: this.convertChild(node.expression),\n                });\n            }\n            case SyntaxKind.Parameter: {\n                let parameter;\n                let result;\n                if (node.dotDotDotToken) {\n                    parameter = result = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.RestElement,\n                        argument: this.convertChild(node.name),\n                        decorators: [],\n                        optional: false,\n                        typeAnnotation: undefined,\n                        value: undefined,\n                    });\n                }\n                else if (node.initializer) {\n                    parameter = this.convertChild(node.name);\n                    result = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                        decorators: [],\n                        left: parameter,\n                        optional: false,\n                        right: this.convertChild(node.initializer),\n                        typeAnnotation: undefined,\n                    });\n                    const modifiers = (0, getModifiers_1.getModifiers)(node);\n                    if (modifiers) {\n                        // AssignmentPattern should not contain modifiers in range\n                        result.range[0] = parameter.range[0];\n                        result.loc = (0, node_utils_1.getLocFor)(result.range, this.ast);\n                    }\n                }\n                else {\n                    parameter = result = this.convertChild(node.name, parent);\n                }\n                if (node.type) {\n                    parameter.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n                    this.fixParentLocation(parameter, parameter.typeAnnotation.range);\n                }\n                if (node.questionToken) {\n                    if (node.questionToken.end > parameter.range[1]) {\n                        parameter.range[1] = node.questionToken.end;\n                        parameter.loc.end = (0, node_utils_1.getLineAndCharacterFor)(parameter.range[1], this.ast);\n                    }\n                    parameter.optional = true;\n                }\n                const modifiers = (0, getModifiers_1.getModifiers)(node);\n                if (modifiers) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,\n                        accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n                        decorators: [],\n                        override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),\n                        parameter: result,\n                        readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),\n                        static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n                    });\n                }\n                return result;\n            }\n            // Classes\n            case SyntaxKind.ClassDeclaration:\n                if (!node.name &&\n                    (!(0, node_utils_1.hasModifier)(ts.SyntaxKind.ExportKeyword, node) ||\n                        !(0, node_utils_1.hasModifier)(ts.SyntaxKind.DefaultKeyword, node))) {\n                    this.#throwUnlessAllowInvalidAST(node, \"A class declaration without the 'default' modifier must have a name.\");\n                }\n            /* intentional fallthrough */\n            case SyntaxKind.ClassExpression: {\n                const heritageClauses = node.heritageClauses ?? [];\n                const classNodeType = node.kind === SyntaxKind.ClassDeclaration\n                    ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration\n                    : ts_estree_1.AST_NODE_TYPES.ClassExpression;\n                let extendsClause;\n                let implementsClause;\n                for (const heritageClause of heritageClauses) {\n                    const { token, types } = heritageClause;\n                    if (types.length === 0) {\n                        this.#throwUnlessAllowInvalidAST(heritageClause, `'${ts.tokenToString(token)}' list cannot be empty.`);\n                    }\n                    if (token === SyntaxKind.ExtendsKeyword) {\n                        if (extendsClause) {\n                            this.#throwUnlessAllowInvalidAST(heritageClause, \"'extends' clause already seen.\");\n                        }\n                        if (implementsClause) {\n                            this.#throwUnlessAllowInvalidAST(heritageClause, \"'extends' clause must precede 'implements' clause.\");\n                        }\n                        if (types.length > 1) {\n                            this.#throwUnlessAllowInvalidAST(types[1], 'Classes can only extend a single class.');\n                        }\n                        extendsClause ??= heritageClause;\n                    }\n                    else if (token === SyntaxKind.ImplementsKeyword) {\n                        if (implementsClause) {\n                            this.#throwUnlessAllowInvalidAST(heritageClause, \"'implements' clause already seen.\");\n                        }\n                        implementsClause ??= heritageClause;\n                    }\n                }\n                const result = this.createNode(node, {\n                    type: classNodeType,\n                    abstract: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node),\n                    body: this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.ClassBody,\n                        range: [node.members.pos - 1, node.end],\n                        body: node.members\n                            .filter(node_utils_1.isESTreeClassMember)\n                            .map(el => this.convertChild(el)),\n                    }),\n                    declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n                    decorators: (0, getModifiers_1.getDecorators)(node)?.map(el => this.convertChild(el)) ?? [],\n                    id: this.convertChild(node.name),\n                    implements: implementsClause?.types.map(el => this.convertChild(el)) ?? [],\n                    superClass: extendsClause?.types[0]\n                        ? this.convertChild(extendsClause.types[0].expression)\n                        : null,\n                    superTypeArguments: undefined,\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n                if (extendsClause?.types[0]?.typeArguments) {\n                    result.superTypeArguments =\n                        this.convertTypeArgumentsToTypeParameterInstantiation(extendsClause.types[0].typeArguments, extendsClause.types[0]);\n                }\n                return this.fixExports(node, result);\n            }\n            // Modules\n            case SyntaxKind.ModuleBlock:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,\n                    body: this.convertBodyExpressions(node.statements, node),\n                });\n            case SyntaxKind.ImportDeclaration: {\n                this.assertModuleSpecifier(node, false);\n                const result = this.createNode(node, this.#withDeprecatedAliasGetter({\n                    type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,\n                    attributes: this.convertImportAttributes(\n                    // eslint-disable-next-line @typescript-eslint/no-deprecated\n                    node.attributes ?? node.assertClause),\n                    importKind: 'value',\n                    source: this.convertChild(node.moduleSpecifier),\n                    specifiers: [],\n                }, 'assertions', 'attributes', true));\n                if (node.importClause) {\n                    if (node.importClause.isTypeOnly) {\n                        result.importKind = 'type';\n                    }\n                    if (node.importClause.name) {\n                        result.specifiers.push(this.convertChild(node.importClause));\n                    }\n                    if (node.importClause.namedBindings) {\n                        switch (node.importClause.namedBindings.kind) {\n                            case SyntaxKind.NamespaceImport:\n                                result.specifiers.push(this.convertChild(node.importClause.namedBindings));\n                                break;\n                            case SyntaxKind.NamedImports:\n                                result.specifiers.push(...node.importClause.namedBindings.elements.map(el => this.convertChild(el)));\n                                break;\n                        }\n                    }\n                }\n                return result;\n            }\n            case SyntaxKind.NamespaceImport:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,\n                    local: this.convertChild(node.name),\n                });\n            case SyntaxKind.ImportSpecifier:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,\n                    imported: this.convertChild(node.propertyName ?? node.name),\n                    importKind: node.isTypeOnly ? 'type' : 'value',\n                    local: this.convertChild(node.name),\n                });\n            case SyntaxKind.ImportClause: {\n                const local = this.convertChild(node.name);\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,\n                    range: local.range,\n                    local,\n                });\n            }\n            case SyntaxKind.ExportDeclaration: {\n                if (node.exportClause?.kind === SyntaxKind.NamedExports) {\n                    this.assertModuleSpecifier(node, true);\n                    return this.createNode(node, this.#withDeprecatedAliasGetter({\n                        type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n                        attributes: this.convertImportAttributes(\n                        // eslint-disable-next-line @typescript-eslint/no-deprecated\n                        node.attributes ?? node.assertClause),\n                        declaration: null,\n                        exportKind: node.isTypeOnly ? 'type' : 'value',\n                        source: this.convertChild(node.moduleSpecifier),\n                        specifiers: node.exportClause.elements.map(el => this.convertChild(el, node)),\n                    }, 'assertions', 'attributes', true));\n                }\n                this.assertModuleSpecifier(node, false);\n                return this.createNode(node, this.#withDeprecatedAliasGetter({\n                    type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,\n                    attributes: this.convertImportAttributes(\n                    // eslint-disable-next-line @typescript-eslint/no-deprecated\n                    node.attributes ?? node.assertClause),\n                    exported: node.exportClause?.kind === SyntaxKind.NamespaceExport\n                        ? this.convertChild(node.exportClause.name)\n                        : null,\n                    exportKind: node.isTypeOnly ? 'type' : 'value',\n                    source: this.convertChild(node.moduleSpecifier),\n                }, 'assertions', 'attributes', true));\n            }\n            case SyntaxKind.ExportSpecifier: {\n                const local = node.propertyName ?? node.name;\n                if (local.kind === SyntaxKind.StringLiteral &&\n                    parent.kind === SyntaxKind.ExportDeclaration &&\n                    parent.moduleSpecifier?.kind !== SyntaxKind.StringLiteral) {\n                    this.#throwError(local, 'A string literal cannot be used as a local exported binding without `from`.');\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,\n                    exported: this.convertChild(node.name),\n                    exportKind: node.isTypeOnly ? 'type' : 'value',\n                    local: this.convertChild(local),\n                });\n            }\n            case SyntaxKind.ExportAssignment:\n                if (node.isExportEquals) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,\n                        expression: this.convertChild(node.expression),\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n                    declaration: this.convertChild(node.expression),\n                    exportKind: 'value',\n                });\n            // Unary Operations\n            case SyntaxKind.PrefixUnaryExpression:\n            case SyntaxKind.PostfixUnaryExpression: {\n                const operator = (0, node_utils_1.getTextForTokenKind)(node.operator);\n                /**\n                 * ESTree uses UpdateExpression for ++/--\n                 */\n                if (operator === '++' || operator === '--') {\n                    if (!(0, node_utils_1.isValidAssignmentTarget)(node.operand)) {\n                        this.#throwUnlessAllowInvalidAST(node.operand, 'Invalid left-hand side expression in unary operation');\n                    }\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,\n                        argument: this.convertChild(node.operand),\n                        operator,\n                        prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n                    argument: this.convertChild(node.operand),\n                    operator,\n                    prefix: node.kind === SyntaxKind.PrefixUnaryExpression,\n                });\n            }\n            case SyntaxKind.DeleteExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n                    argument: this.convertChild(node.expression),\n                    operator: 'delete',\n                    prefix: true,\n                });\n            case SyntaxKind.VoidExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n                    argument: this.convertChild(node.expression),\n                    operator: 'void',\n                    prefix: true,\n                });\n            case SyntaxKind.TypeOfExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,\n                    argument: this.convertChild(node.expression),\n                    operator: 'typeof',\n                    prefix: true,\n                });\n            case SyntaxKind.TypeOperator:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,\n                    operator: (0, node_utils_1.getTextForTokenKind)(node.operator),\n                    typeAnnotation: this.convertChild(node.type),\n                });\n            // Binary Operations\n            case SyntaxKind.BinaryExpression: {\n                // TypeScript uses BinaryExpression for sequences as well\n                if ((0, node_utils_1.isComma)(node.operatorToken)) {\n                    const result = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,\n                        expressions: [],\n                    });\n                    const left = this.convertChild(node.left);\n                    if (left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression &&\n                        node.left.kind !== SyntaxKind.ParenthesizedExpression) {\n                        result.expressions.push(...left.expressions);\n                    }\n                    else {\n                        result.expressions.push(left);\n                    }\n                    result.expressions.push(this.convertChild(node.right));\n                    return result;\n                }\n                const expressionType = (0, node_utils_1.getBinaryExpressionType)(node.operatorToken);\n                if (this.allowPattern &&\n                    expressionType.type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,\n                        decorators: [],\n                        left: this.convertPattern(node.left, node),\n                        optional: false,\n                        right: this.convertChild(node.right),\n                        typeAnnotation: undefined,\n                    });\n                }\n                return this.createNode(node, {\n                    ...expressionType,\n                    left: this.converter(node.left, node, expressionType.type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),\n                    right: this.convertChild(node.right),\n                });\n            }\n            case SyntaxKind.PropertyAccessExpression: {\n                const object = this.convertChild(node.expression);\n                const property = this.convertChild(node.name);\n                const computed = false;\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n                    computed,\n                    object,\n                    optional: node.questionDotToken != null,\n                    property,\n                });\n                return this.convertChainExpression(result, node);\n            }\n            case SyntaxKind.ElementAccessExpression: {\n                const object = this.convertChild(node.expression);\n                const property = this.convertChild(node.argumentExpression);\n                const computed = true;\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.MemberExpression,\n                    computed,\n                    object,\n                    optional: node.questionDotToken != null,\n                    property,\n                });\n                return this.convertChainExpression(result, node);\n            }\n            case SyntaxKind.CallExpression: {\n                if (node.expression.kind === SyntaxKind.ImportKeyword) {\n                    if (node.arguments.length !== 1 && node.arguments.length !== 2) {\n                        this.#throwUnlessAllowInvalidAST(node.arguments[2] ?? node, 'Dynamic import requires exactly one or two arguments.');\n                    }\n                    return this.createNode(node, this.#withDeprecatedAliasGetter({\n                        type: ts_estree_1.AST_NODE_TYPES.ImportExpression,\n                        options: node.arguments[1]\n                            ? this.convertChild(node.arguments[1])\n                            : null,\n                        source: this.convertChild(node.arguments[0]),\n                    }, 'attributes', 'options', true));\n                }\n                const callee = this.convertChild(node.expression);\n                const args = node.arguments.map(el => this.convertChild(el));\n                const typeArguments = node.typeArguments &&\n                    this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node);\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.CallExpression,\n                    arguments: args,\n                    callee,\n                    optional: node.questionDotToken != null,\n                    typeArguments,\n                });\n                return this.convertChainExpression(result, node);\n            }\n            case SyntaxKind.NewExpression: {\n                const typeArguments = node.typeArguments &&\n                    this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node);\n                // NOTE - NewExpression cannot have an optional chain in it\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.NewExpression,\n                    arguments: node.arguments\n                        ? node.arguments.map(el => this.convertChild(el))\n                        : [],\n                    callee: this.convertChild(node.expression),\n                    typeArguments,\n                });\n            }\n            case SyntaxKind.ConditionalExpression:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,\n                    alternate: this.convertChild(node.whenFalse),\n                    consequent: this.convertChild(node.whenTrue),\n                    test: this.convertChild(node.condition),\n                });\n            case SyntaxKind.MetaProperty: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.MetaProperty,\n                    meta: this.createNode(\n                    // TODO: do we really want to convert it to Token?\n                    node.getFirstToken(), {\n                        type: ts_estree_1.AST_NODE_TYPES.Identifier,\n                        decorators: [],\n                        name: (0, node_utils_1.getTextForTokenKind)(node.keywordToken),\n                        optional: false,\n                        typeAnnotation: undefined,\n                    }),\n                    property: this.convertChild(node.name),\n                });\n            }\n            case SyntaxKind.Decorator: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Decorator,\n                    expression: this.convertChild(node.expression),\n                });\n            }\n            // Literals\n            case SyntaxKind.StringLiteral: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    raw: node.getText(),\n                    value: parent.kind === SyntaxKind.JsxAttribute\n                        ? (0, node_utils_1.unescapeStringLiteralText)(node.text)\n                        : node.text,\n                });\n            }\n            case SyntaxKind.NumericLiteral: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    raw: node.getText(),\n                    value: Number(node.text),\n                });\n            }\n            case SyntaxKind.BigIntLiteral: {\n                const range = (0, node_utils_1.getRange)(node, this.ast);\n                const rawValue = this.ast.text.slice(range[0], range[1]);\n                const bigint = rawValue\n                    // remove suffix `n`\n                    .slice(0, -1)\n                    // `BigInt` doesn't accept numeric separator\n                    // and `bigint` property should not include numeric separator\n                    .replaceAll('_', '');\n                const value = typeof BigInt !== 'undefined' ? BigInt(bigint) : null;\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    range,\n                    bigint: value == null ? bigint : String(value),\n                    raw: rawValue,\n                    value,\n                });\n            }\n            case SyntaxKind.RegularExpressionLiteral: {\n                const pattern = node.text.slice(1, node.text.lastIndexOf('/'));\n                const flags = node.text.slice(node.text.lastIndexOf('/') + 1);\n                let regex = null;\n                try {\n                    regex = new RegExp(pattern, flags);\n                }\n                catch {\n                    // Intentionally blank, so regex stays null\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    raw: node.text,\n                    regex: {\n                        flags,\n                        pattern,\n                    },\n                    value: regex,\n                });\n            }\n            case SyntaxKind.TrueKeyword:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    raw: 'true',\n                    value: true,\n                });\n            case SyntaxKind.FalseKeyword:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    raw: 'false',\n                    value: false,\n                });\n            case SyntaxKind.NullKeyword: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.Literal,\n                    raw: 'null',\n                    value: null,\n                });\n            }\n            case SyntaxKind.EmptyStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.EmptyStatement,\n                });\n            case SyntaxKind.DebuggerStatement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement,\n                });\n            // JSX\n            case SyntaxKind.JsxElement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n                    children: node.children.map(el => this.convertChild(el)),\n                    closingElement: this.convertChild(node.closingElement),\n                    openingElement: this.convertChild(node.openingElement),\n                });\n            case SyntaxKind.JsxFragment:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXFragment,\n                    children: node.children.map(el => this.convertChild(el)),\n                    closingFragment: this.convertChild(node.closingFragment),\n                    openingFragment: this.convertChild(node.openingFragment),\n                });\n            case SyntaxKind.JsxSelfClosingElement: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXElement,\n                    /**\n                     * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,\n                     * TypeScript does not seem to have the idea of openingElement when tag is self-closing\n                     */\n                    children: [],\n                    closingElement: null,\n                    openingElement: this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n                        range: (0, node_utils_1.getRange)(node, this.ast),\n                        attributes: node.attributes.properties.map(el => this.convertChild(el)),\n                        name: this.convertJSXTagName(node.tagName, node),\n                        selfClosing: true,\n                        typeArguments: node.typeArguments\n                            ? this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node)\n                            : undefined,\n                    }),\n                });\n            }\n            case SyntaxKind.JsxOpeningElement: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,\n                    attributes: node.attributes.properties.map(el => this.convertChild(el)),\n                    name: this.convertJSXTagName(node.tagName, node),\n                    selfClosing: false,\n                    typeArguments: node.typeArguments &&\n                        this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),\n                });\n            }\n            case SyntaxKind.JsxClosingElement:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,\n                    name: this.convertJSXTagName(node.tagName, node),\n                });\n            case SyntaxKind.JsxOpeningFragment:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment,\n                });\n            case SyntaxKind.JsxClosingFragment:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment,\n                });\n            case SyntaxKind.JsxExpression: {\n                const expression = node.expression\n                    ? this.convertChild(node.expression)\n                    : this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,\n                        range: [node.getStart(this.ast) + 1, node.getEnd() - 1],\n                    });\n                if (node.dotDotDotToken) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,\n                        expression,\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,\n                    expression,\n                });\n            }\n            case SyntaxKind.JsxAttribute: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,\n                    name: this.convertJSXNamespaceOrIdentifier(node.name),\n                    value: this.convertChild(node.initializer),\n                });\n            }\n            case SyntaxKind.JsxText: {\n                const start = node.getFullStart();\n                const end = node.getEnd();\n                const text = this.ast.text.slice(start, end);\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXText,\n                    range: [start, end],\n                    raw: text,\n                    value: (0, node_utils_1.unescapeStringLiteralText)(text),\n                });\n            }\n            case SyntaxKind.JsxSpreadAttribute:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,\n                    argument: this.convertChild(node.expression),\n                });\n            case SyntaxKind.QualifiedName: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,\n                    left: this.convertChild(node.left),\n                    right: this.convertChild(node.right),\n                });\n            }\n            // TypeScript specific\n            case SyntaxKind.TypeReference:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,\n                    typeArguments: node.typeArguments &&\n                        this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),\n                    typeName: this.convertChild(node.typeName),\n                });\n            case SyntaxKind.TypeParameter: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,\n                    const: (0, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node),\n                    constraint: node.constraint && this.convertChild(node.constraint),\n                    default: node.default ? this.convertChild(node.default) : undefined,\n                    in: (0, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),\n                    name: this.convertChild(node.name),\n                    out: (0, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node),\n                });\n            }\n            case SyntaxKind.ThisType:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSThisType,\n                });\n            case SyntaxKind.AnyKeyword:\n            case SyntaxKind.BigIntKeyword:\n            case SyntaxKind.BooleanKeyword:\n            case SyntaxKind.NeverKeyword:\n            case SyntaxKind.NumberKeyword:\n            case SyntaxKind.ObjectKeyword:\n            case SyntaxKind.StringKeyword:\n            case SyntaxKind.SymbolKeyword:\n            case SyntaxKind.UnknownKeyword:\n            case SyntaxKind.VoidKeyword:\n            case SyntaxKind.UndefinedKeyword:\n            case SyntaxKind.IntrinsicKeyword: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES[`TS${SyntaxKind[node.kind]}`],\n                });\n            }\n            case SyntaxKind.NonNullExpression: {\n                const nnExpr = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,\n                    expression: this.convertChild(node.expression),\n                });\n                return this.convertChainExpression(nnExpr, node);\n            }\n            case SyntaxKind.TypeLiteral: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,\n                    members: node.members.map(el => this.convertChild(el)),\n                });\n            }\n            case SyntaxKind.ArrayType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSArrayType,\n                    elementType: this.convertChild(node.elementType),\n                });\n            }\n            case SyntaxKind.IndexedAccessType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,\n                    indexType: this.convertChild(node.indexType),\n                    objectType: this.convertChild(node.objectType),\n                });\n            }\n            case SyntaxKind.ConditionalType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,\n                    checkType: this.convertChild(node.checkType),\n                    extendsType: this.convertChild(node.extendsType),\n                    falseType: this.convertChild(node.falseType),\n                    trueType: this.convertChild(node.trueType),\n                });\n            }\n            case SyntaxKind.TypeQuery:\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,\n                    exprName: this.convertChild(node.exprName),\n                    typeArguments: node.typeArguments &&\n                        this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),\n                });\n            case SyntaxKind.MappedType: {\n                if (node.members && node.members.length > 0) {\n                    this.#throwUnlessAllowInvalidAST(node.members[0], 'A mapped type may not declare properties or methods.');\n                }\n                return this.createNode(node, this.#withDeprecatedGetter({\n                    type: ts_estree_1.AST_NODE_TYPES.TSMappedType,\n                    constraint: this.convertChild(node.typeParameter.constraint),\n                    key: this.convertChild(node.typeParameter.name),\n                    nameType: this.convertChild(node.nameType) ?? null,\n                    optional: node.questionToken &&\n                        (node.questionToken.kind === SyntaxKind.QuestionToken ||\n                            (0, node_utils_1.getTextForTokenKind)(node.questionToken.kind)),\n                    readonly: node.readonlyToken &&\n                        (node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword ||\n                            (0, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind)),\n                    typeAnnotation: node.type && this.convertChild(node.type),\n                }, 'typeParameter', \"'constraint' and 'key'\", this.convertChild(node.typeParameter)));\n            }\n            case SyntaxKind.ParenthesizedExpression:\n                return this.convertChild(node.expression, parent);\n            case SyntaxKind.TypeAliasDeclaration: {\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,\n                    declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n                    id: this.convertChild(node.name),\n                    typeAnnotation: this.convertChild(node.type),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n                return this.fixExports(node, result);\n            }\n            case SyntaxKind.MethodSignature: {\n                return this.convertMethodSignature(node);\n            }\n            case SyntaxKind.PropertySignature: {\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                const { initializer } = node;\n                if (initializer) {\n                    this.#throwError(initializer, 'A property signature cannot have an initializer.');\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,\n                    accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n                    computed: (0, node_utils_1.isComputedProperty)(node.name),\n                    key: this.convertChild(node.name),\n                    optional: (0, node_utils_1.isOptional)(node),\n                    readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),\n                    static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n                    typeAnnotation: node.type && this.convertTypeAnnotation(node.type, node),\n                });\n            }\n            case SyntaxKind.IndexSignature: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,\n                    accessibility: (0, node_utils_1.getTSNodeAccessibility)(node),\n                    parameters: node.parameters.map(el => this.convertChild(el)),\n                    readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),\n                    static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),\n                    typeAnnotation: node.type && this.convertTypeAnnotation(node.type, node),\n                });\n            }\n            case SyntaxKind.ConstructorType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,\n                    abstract: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node),\n                    params: this.convertParameters(node.parameters),\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n            }\n            case SyntaxKind.FunctionType: {\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                const { modifiers } = node;\n                if (modifiers) {\n                    this.#throwError(modifiers[0], 'A function type cannot have modifiers.');\n                }\n            }\n            // intentional fallthrough\n            case SyntaxKind.ConstructSignature:\n            case SyntaxKind.CallSignature: {\n                const type = node.kind === SyntaxKind.ConstructSignature\n                    ? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration\n                    : node.kind === SyntaxKind.CallSignature\n                        ? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration\n                        : ts_estree_1.AST_NODE_TYPES.TSFunctionType;\n                return this.createNode(node, {\n                    type,\n                    params: this.convertParameters(node.parameters),\n                    returnType: node.type && this.convertTypeAnnotation(node.type, node),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n            }\n            case SyntaxKind.ExpressionWithTypeArguments: {\n                const parentKind = parent.kind;\n                const type = parentKind === SyntaxKind.InterfaceDeclaration\n                    ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage\n                    : parentKind === SyntaxKind.HeritageClause\n                        ? ts_estree_1.AST_NODE_TYPES.TSClassImplements\n                        : ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;\n                return this.createNode(node, {\n                    type,\n                    expression: this.convertChild(node.expression),\n                    typeArguments: node.typeArguments &&\n                        this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),\n                });\n            }\n            case SyntaxKind.InterfaceDeclaration: {\n                const interfaceHeritageClauses = node.heritageClauses ?? [];\n                const interfaceExtends = [];\n                for (const heritageClause of interfaceHeritageClauses) {\n                    if (heritageClause.token !== SyntaxKind.ExtendsKeyword) {\n                        this.#throwError(heritageClause, heritageClause.token === SyntaxKind.ImplementsKeyword\n                            ? \"Interface declaration cannot have 'implements' clause.\"\n                            : 'Unexpected token.');\n                    }\n                    for (const heritageType of heritageClause.types) {\n                        interfaceExtends.push(this.convertChild(heritageType, node));\n                    }\n                }\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,\n                    body: this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,\n                        range: [node.members.pos - 1, node.end],\n                        body: node.members.map(member => this.convertChild(member)),\n                    }),\n                    declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n                    extends: interfaceExtends,\n                    id: this.convertChild(node.name),\n                    typeParameters: node.typeParameters &&\n                        this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),\n                });\n                return this.fixExports(node, result);\n            }\n            case SyntaxKind.TypePredicate: {\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,\n                    asserts: node.assertsModifier != null,\n                    parameterName: this.convertChild(node.parameterName),\n                    typeAnnotation: null,\n                });\n                /**\n                 * Specific fix for type-guard location data\n                 */\n                if (node.type) {\n                    result.typeAnnotation = this.convertTypeAnnotation(node.type, node);\n                    result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;\n                    result.typeAnnotation.range =\n                        result.typeAnnotation.typeAnnotation.range;\n                }\n                return result;\n            }\n            case SyntaxKind.ImportType: {\n                const range = (0, node_utils_1.getRange)(node, this.ast);\n                if (node.isTypeOf) {\n                    const token = (0, node_utils_1.findNextToken)(node.getFirstToken(), node, this.ast);\n                    range[0] = token.getStart(this.ast);\n                }\n                let options = null;\n                if (node.attributes) {\n                    const value = this.createNode(node.attributes, {\n                        type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,\n                        properties: node.attributes.elements.map(importAttribute => this.createNode(importAttribute, {\n                            type: ts_estree_1.AST_NODE_TYPES.Property,\n                            computed: false,\n                            key: this.convertChild(importAttribute.name),\n                            kind: 'init',\n                            method: false,\n                            optional: false,\n                            shorthand: false,\n                            value: this.convertChild(importAttribute.value),\n                        })),\n                    });\n                    const commaToken = (0, node_utils_1.findNextToken)(node.argument, node, this.ast);\n                    const openBraceToken = (0, node_utils_1.findNextToken)(commaToken, node, this.ast);\n                    const closeBraceToken = (0, node_utils_1.findNextToken)(node.attributes, node, this.ast);\n                    const withToken = (0, node_utils_1.findNextToken)(openBraceToken, node, this.ast);\n                    const withTokenRange = (0, node_utils_1.getRange)(withToken, this.ast);\n                    options = this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,\n                        range: [openBraceToken.getStart(this.ast), closeBraceToken.end],\n                        properties: [\n                            this.createNode(node, {\n                                type: ts_estree_1.AST_NODE_TYPES.Property,\n                                range: [withTokenRange[0], node.attributes.end],\n                                computed: false,\n                                key: this.createNode(node, {\n                                    type: ts_estree_1.AST_NODE_TYPES.Identifier,\n                                    range: withTokenRange,\n                                    decorators: [],\n                                    name: 'with',\n                                    optional: false,\n                                    typeAnnotation: undefined,\n                                }),\n                                kind: 'init',\n                                method: false,\n                                optional: false,\n                                shorthand: false,\n                                value,\n                            }),\n                        ],\n                    });\n                }\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSImportType,\n                    range,\n                    argument: this.convertChild(node.argument),\n                    options,\n                    qualifier: this.convertChild(node.qualifier),\n                    typeArguments: node.typeArguments\n                        ? this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node)\n                        : null,\n                });\n                if (node.isTypeOf) {\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,\n                        exprName: result,\n                        typeArguments: undefined,\n                    });\n                }\n                return result;\n            }\n            case SyntaxKind.EnumDeclaration: {\n                const members = node.members.map(el => this.convertChild(el));\n                const result = this.createNode(node, this.#withDeprecatedGetter({\n                    type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,\n                    body: this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSEnumBody,\n                        range: [node.members.pos - 1, node.end],\n                        members,\n                    }),\n                    const: (0, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node),\n                    declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),\n                    id: this.convertChild(node.name),\n                }, 'members', `'body.members'`, node.members.map(el => this.convertChild(el))));\n                return this.fixExports(node, result);\n            }\n            case SyntaxKind.EnumMember: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,\n                    computed: node.name.kind === ts.SyntaxKind.ComputedPropertyName,\n                    id: this.convertChild(node.name),\n                    initializer: node.initializer && this.convertChild(node.initializer),\n                });\n            }\n            case SyntaxKind.ModuleDeclaration: {\n                let isDeclare = (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration,\n                    ...(() => {\n                        // the constraints checked by this function are syntactically enforced by TS\n                        // the checks mostly exist for type's sake\n                        if (node.flags & ts.NodeFlags.GlobalAugmentation) {\n                            const id = this.convertChild(node.name);\n                            const body = this.convertChild(node.body);\n                            if (body == null ||\n                                body.type === ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration) {\n                                this.#throwUnlessAllowInvalidAST(node.body ?? node, 'Expected a valid module body');\n                            }\n                            if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {\n                                this.#throwUnlessAllowInvalidAST(node.name, 'global module augmentation must have an Identifier id');\n                            }\n                            return {\n                                body: body,\n                                declare: false,\n                                global: false,\n                                id,\n                                kind: 'global',\n                            };\n                        }\n                        if (ts.isStringLiteral(node.name)) {\n                            const body = this.convertChild(node.body);\n                            return {\n                                kind: 'module',\n                                ...(body != null ? { body } : {}),\n                                declare: false,\n                                global: false,\n                                id: this.convertChild(node.name),\n                            };\n                        }\n                        // Nested module declarations are stored in TypeScript as nested tree nodes.\n                        // We \"unravel\" them here by making our own nested TSQualifiedName,\n                        // with the innermost node's body as the actual node body.\n                        if (node.body == null) {\n                            this.#throwUnlessAllowInvalidAST(node, 'Expected a module body');\n                        }\n                        if (node.name.kind !== ts.SyntaxKind.Identifier) {\n                            this.#throwUnlessAllowInvalidAST(node.name, '`namespace`s must have an Identifier id');\n                        }\n                        let name = this.createNode(node.name, {\n                            type: ts_estree_1.AST_NODE_TYPES.Identifier,\n                            range: [node.name.getStart(this.ast), node.name.getEnd()],\n                            decorators: [],\n                            name: node.name.text,\n                            optional: false,\n                            typeAnnotation: undefined,\n                        });\n                        while (node.body &&\n                            ts.isModuleDeclaration(node.body) &&\n                            node.body.name) {\n                            node = node.body;\n                            isDeclare ||= (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);\n                            const nextName = node.name;\n                            const right = this.createNode(nextName, {\n                                type: ts_estree_1.AST_NODE_TYPES.Identifier,\n                                range: [nextName.getStart(this.ast), nextName.getEnd()],\n                                decorators: [],\n                                name: nextName.text,\n                                optional: false,\n                                typeAnnotation: undefined,\n                            });\n                            name = this.createNode(nextName, {\n                                type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,\n                                range: [name.range[0], right.range[1]],\n                                left: name,\n                                right,\n                            });\n                        }\n                        return {\n                            body: this.convertChild(node.body),\n                            declare: false,\n                            global: false,\n                            id: name,\n                            kind: node.flags & ts.NodeFlags.Namespace ? 'namespace' : 'module',\n                        };\n                    })(),\n                });\n                result.declare = isDeclare;\n                if (node.flags & ts.NodeFlags.GlobalAugmentation) {\n                    // eslint-disable-next-line @typescript-eslint/no-deprecated\n                    result.global = true;\n                }\n                return this.fixExports(node, result);\n            }\n            // TypeScript specific types\n            case SyntaxKind.ParenthesizedType: {\n                return this.convertChild(node.type);\n            }\n            case SyntaxKind.UnionType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSUnionType,\n                    types: node.types.map(el => this.convertChild(el)),\n                });\n            }\n            case SyntaxKind.IntersectionType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,\n                    types: node.types.map(el => this.convertChild(el)),\n                });\n            }\n            case SyntaxKind.AsExpression: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,\n                    expression: this.convertChild(node.expression),\n                    typeAnnotation: this.convertChild(node.type),\n                });\n            }\n            case SyntaxKind.InferType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSInferType,\n                    typeParameter: this.convertChild(node.typeParameter),\n                });\n            }\n            case SyntaxKind.LiteralType: {\n                if (node.literal.kind === SyntaxKind.NullKeyword) {\n                    // 4.0 started nesting null types inside a LiteralType node\n                    // but our AST is designed around the old way of null being a keyword\n                    return this.createNode(node.literal, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword,\n                    });\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,\n                    literal: this.convertChild(node.literal),\n                });\n            }\n            case SyntaxKind.TypeAssertionExpression: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,\n                    expression: this.convertChild(node.expression),\n                    typeAnnotation: this.convertChild(node.type),\n                });\n            }\n            case SyntaxKind.ImportEqualsDeclaration: {\n                return this.fixExports(node, this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,\n                    id: this.convertChild(node.name),\n                    importKind: node.isTypeOnly ? 'type' : 'value',\n                    moduleReference: this.convertChild(node.moduleReference),\n                }));\n            }\n            case SyntaxKind.ExternalModuleReference: {\n                if (node.expression.kind !== SyntaxKind.StringLiteral) {\n                    this.#throwError(node.expression, 'String literal expected.');\n                }\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,\n                    expression: this.convertChild(node.expression),\n                });\n            }\n            case SyntaxKind.NamespaceExportDeclaration: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,\n                    id: this.convertChild(node.name),\n                });\n            }\n            case SyntaxKind.AbstractKeyword: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword,\n                });\n            }\n            // Tuple\n            case SyntaxKind.TupleType: {\n                const elementTypes = node.elements.map(el => this.convertChild(el));\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTupleType,\n                    elementTypes,\n                });\n            }\n            case SyntaxKind.NamedTupleMember: {\n                const member = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,\n                    elementType: this.convertChild(node.type, node),\n                    label: this.convertChild(node.name, node),\n                    optional: node.questionToken != null,\n                });\n                if (node.dotDotDotToken) {\n                    // adjust the start to account for the \"...\"\n                    member.range[0] = member.label.range[0];\n                    member.loc.start = member.label.loc.start;\n                    return this.createNode(node, {\n                        type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n                        typeAnnotation: member,\n                    });\n                }\n                return member;\n            }\n            case SyntaxKind.OptionalType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,\n                    typeAnnotation: this.convertChild(node.type),\n                });\n            }\n            case SyntaxKind.RestType: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSRestType,\n                    typeAnnotation: this.convertChild(node.type),\n                });\n            }\n            // Template Literal Types\n            case SyntaxKind.TemplateLiteralType: {\n                const result = this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,\n                    quasis: [this.convertChild(node.head)],\n                    types: [],\n                });\n                node.templateSpans.forEach(templateSpan => {\n                    result.types.push(this.convertChild(templateSpan.type));\n                    result.quasis.push(this.convertChild(templateSpan.literal));\n                });\n                return result;\n            }\n            case SyntaxKind.ClassStaticBlockDeclaration: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.StaticBlock,\n                    body: this.convertBodyExpressions(node.body.statements, node),\n                });\n            }\n            // eslint-disable-next-line @typescript-eslint/no-deprecated\n            case SyntaxKind.AssertEntry:\n            case SyntaxKind.ImportAttribute: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,\n                    key: this.convertChild(node.name),\n                    value: this.convertChild(node.value),\n                });\n            }\n            case SyntaxKind.SatisfiesExpression: {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.TSSatisfiesExpression,\n                    expression: this.convertChild(node.expression),\n                    typeAnnotation: this.convertChild(node.type),\n                });\n            }\n            default:\n                return this.deeplyCopy(node);\n        }\n    }\n    createNode(node, data) {\n        const result = data;\n        result.range ??= (0, node_utils_1.getRange)(node, this.ast);\n        result.loc ??= (0, node_utils_1.getLocFor)(result.range, this.ast);\n        if (result && this.options.shouldPreserveNodeMaps) {\n            this.esTreeNodeToTSNodeMap.set(result, node);\n        }\n        return result;\n    }\n    convertProgram() {\n        return this.converter(this.ast);\n    }\n    /**\n     * For nodes that are copied directly from the TypeScript AST into\n     * ESTree mostly as-is. The only difference is the addition of a type\n     * property instead of a kind property. Recursively copies all children.\n     */\n    deeplyCopy(node) {\n        if (node.kind === ts.SyntaxKind.JSDocFunctionType) {\n            this.#throwError(node, 'JSDoc types can only be used inside documentation comments.');\n        }\n        const customType = `TS${SyntaxKind[node.kind]}`;\n        /**\n         * If the \"errorOnUnknownASTType\" option is set to true, throw an error,\n         * otherwise fallback to just including the unknown type as-is.\n         */\n        if (this.options.errorOnUnknownASTType && !ts_estree_1.AST_NODE_TYPES[customType]) {\n            throw new Error(`Unknown AST_NODE_TYPE: \"${customType}\"`);\n        }\n        const result = this.createNode(node, {\n            type: customType,\n        });\n        if ('type' in node) {\n            result.typeAnnotation =\n                node.type && 'kind' in node.type && ts.isTypeNode(node.type)\n                    ? this.convertTypeAnnotation(node.type, node)\n                    : null;\n        }\n        if ('typeArguments' in node) {\n            result.typeArguments =\n                node.typeArguments && 'pos' in node.typeArguments\n                    ? this.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node)\n                    : null;\n        }\n        if ('typeParameters' in node) {\n            result.typeParameters =\n                node.typeParameters && 'pos' in node.typeParameters\n                    ? this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters)\n                    : null;\n        }\n        const decorators = (0, getModifiers_1.getDecorators)(node);\n        if (decorators?.length) {\n            result.decorators = decorators.map(el => this.convertChild(el));\n        }\n        // keys we never want to clone from the base typescript node as they\n        // introduce garbage into our AST\n        const KEYS_TO_NOT_COPY = new Set([\n            '_children',\n            'decorators',\n            'end',\n            'flags',\n            'heritageClauses',\n            'illegalDecorators',\n            'jsDoc',\n            'kind',\n            'locals',\n            'localSymbol',\n            'modifierFlagsCache',\n            'modifiers',\n            'nextContainer',\n            'parent',\n            'pos',\n            'symbol',\n            'transformFlags',\n            'type',\n            'typeArguments',\n            'typeParameters',\n        ]);\n        Object.entries(node)\n            .filter(([key]) => !KEYS_TO_NOT_COPY.has(key))\n            .forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                result[key] = value.map(el => this.convertChild(el));\n            }\n            else if (value && typeof value === 'object' && value.kind) {\n                // need to check node[key].kind to ensure we don't try to convert a symbol\n                result[key] = this.convertChild(value);\n            }\n            else {\n                result[key] = value;\n            }\n        });\n        return result;\n    }\n    /**\n     * Fixes the exports of the given ts.Node\n     * @returns the ESTreeNode with fixed exports\n     */\n    fixExports(node, result) {\n        const isNamespaceNode = ts.isModuleDeclaration(node) && !ts.isStringLiteral(node.name);\n        const modifiers = isNamespaceNode\n            ? (0, node_utils_1.getNamespaceModifiers)(node)\n            : (0, getModifiers_1.getModifiers)(node);\n        if (modifiers?.[0].kind === SyntaxKind.ExportKeyword) {\n            /**\n             * Make sure that original node is registered instead of export\n             */\n            this.registerTSNodeInNodeMap(node, result);\n            const exportKeyword = modifiers[0];\n            const nextModifier = modifiers[1];\n            const declarationIsDefault = nextModifier?.kind === SyntaxKind.DefaultKeyword;\n            const varToken = declarationIsDefault\n                ? (0, node_utils_1.findNextToken)(nextModifier, this.ast, this.ast)\n                : (0, node_utils_1.findNextToken)(exportKeyword, this.ast, this.ast);\n            result.range[0] = varToken.getStart(this.ast);\n            result.loc = (0, node_utils_1.getLocFor)(result.range, this.ast);\n            if (declarationIsDefault) {\n                return this.createNode(node, {\n                    type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,\n                    range: [exportKeyword.getStart(this.ast), result.range[1]],\n                    declaration: result,\n                    exportKind: 'value',\n                });\n            }\n            const isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration ||\n                result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n            const isDeclare = 'declare' in result && result.declare;\n            return this.createNode(node, \n            // @ts-expect-error - TODO, narrow the types here\n            this.#withDeprecatedAliasGetter({\n                type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,\n                range: [exportKeyword.getStart(this.ast), result.range[1]],\n                attributes: [],\n                declaration: result,\n                exportKind: isType || isDeclare ? 'type' : 'value',\n                source: null,\n                specifiers: [],\n            }, 'assertions', 'attributes', true));\n        }\n        return result;\n    }\n    getASTMaps() {\n        return {\n            esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,\n            tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap,\n        };\n    }\n    /**\n     * Register specific TypeScript node into map with first ESTree node provided\n     */\n    registerTSNodeInNodeMap(node, result) {\n        if (result &&\n            this.options.shouldPreserveNodeMaps &&\n            !this.tsNodeToESTreeNodeMap.has(node)) {\n            this.tsNodeToESTreeNodeMap.set(node, result);\n        }\n    }\n}\nexports.Converter = Converter;\n"
        }
    ]
}