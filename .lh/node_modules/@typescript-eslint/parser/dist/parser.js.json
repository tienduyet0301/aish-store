{
    "sourceFile": "node_modules/@typescript-eslint/parser/dist/parser.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891983309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = parse;\nexports.parseForESLint = parseForESLint;\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\nconst typescript_estree_1 = require(\"@typescript-eslint/typescript-estree\");\nconst visitor_keys_1 = require(\"@typescript-eslint/visitor-keys\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst typescript_1 = require(\"typescript\");\nconst log = (0, debug_1.default)('typescript-eslint:parser:parser');\nfunction validateBoolean(value, fallback = false) {\n    if (typeof value !== 'boolean') {\n        return fallback;\n    }\n    return value;\n}\nconst LIB_FILENAME_REGEX = /lib\\.(.+)\\.d\\.[cm]?ts$/;\nfunction getLib(compilerOptions) {\n    if (compilerOptions.lib) {\n        return compilerOptions.lib\n            .map(lib => LIB_FILENAME_REGEX.exec(lib.toLowerCase())?.[1])\n            .filter((lib) => !!lib);\n    }\n    const target = compilerOptions.target ?? typescript_1.ScriptTarget.ES5;\n    // https://github.com/microsoft/TypeScript/blob/ae582a22ee1bb052e19b7c1bc4cac60509b574e0/src/compiler/utilitiesPublic.ts#L13-L36\n    switch (target) {\n        case typescript_1.ScriptTarget.ES2015:\n            return ['es6'];\n        case typescript_1.ScriptTarget.ES2016:\n            return ['es2016.full'];\n        case typescript_1.ScriptTarget.ES2017:\n            return ['es2017.full'];\n        case typescript_1.ScriptTarget.ES2018:\n            return ['es2018.full'];\n        case typescript_1.ScriptTarget.ES2019:\n            return ['es2019.full'];\n        case typescript_1.ScriptTarget.ES2020:\n            return ['es2020.full'];\n        case typescript_1.ScriptTarget.ES2021:\n            return ['es2021.full'];\n        case typescript_1.ScriptTarget.ES2022:\n            return ['es2022.full'];\n        case typescript_1.ScriptTarget.ES2023:\n            return ['es2023.full'];\n        case typescript_1.ScriptTarget.ES2024:\n            return ['es2024.full'];\n        case typescript_1.ScriptTarget.ESNext:\n            return ['esnext.full'];\n        default:\n            return ['lib'];\n    }\n}\nfunction parse(code, options) {\n    return parseForESLint(code, options).ast;\n}\nfunction parseForESLint(code, parserOptions) {\n    if (!parserOptions || typeof parserOptions !== 'object') {\n        parserOptions = {};\n    }\n    else {\n        parserOptions = { ...parserOptions };\n    }\n    // https://eslint.org/docs/user-guide/configuring#specifying-parser-options\n    // if sourceType is not provided by default eslint expect that it will be set to \"script\"\n    if (parserOptions.sourceType !== 'module' &&\n        parserOptions.sourceType !== 'script') {\n        parserOptions.sourceType = 'script';\n    }\n    if (typeof parserOptions.ecmaFeatures !== 'object') {\n        parserOptions.ecmaFeatures = {};\n    }\n    /**\n     * Allow the user to suppress the warning from typescript-estree if they are using an unsupported\n     * version of TypeScript\n     */\n    const warnOnUnsupportedTypeScriptVersion = validateBoolean(parserOptions.warnOnUnsupportedTypeScriptVersion, true);\n    const tsestreeOptions = {\n        jsx: validateBoolean(parserOptions.ecmaFeatures.jsx),\n        ...(!warnOnUnsupportedTypeScriptVersion && { loggerFn: false }),\n        ...parserOptions,\n        // Override errorOnTypeScriptSyntacticAndSemanticIssues and set it to false to prevent use from user config\n        // https://github.com/typescript-eslint/typescript-eslint/issues/8681#issuecomment-2000411834\n        errorOnTypeScriptSyntacticAndSemanticIssues: false,\n        // comment, loc, range, and tokens should always be set for ESLint usage\n        // https://github.com/typescript-eslint/typescript-eslint/issues/8347\n        comment: true,\n        loc: true,\n        range: true,\n        tokens: true,\n    };\n    const analyzeOptions = {\n        globalReturn: parserOptions.ecmaFeatures.globalReturn,\n        jsxFragmentName: parserOptions.jsxFragmentName,\n        jsxPragma: parserOptions.jsxPragma,\n        lib: parserOptions.lib,\n        sourceType: parserOptions.sourceType,\n    };\n    const { ast, services } = (0, typescript_estree_1.parseAndGenerateServices)(code, tsestreeOptions);\n    ast.sourceType = parserOptions.sourceType;\n    if (services.program) {\n        // automatically apply the options configured for the program\n        const compilerOptions = services.program.getCompilerOptions();\n        if (analyzeOptions.lib == null) {\n            analyzeOptions.lib = getLib(compilerOptions);\n            log('Resolved libs from program: %o', analyzeOptions.lib);\n        }\n        if (\n        // eslint-disable-next-line @typescript-eslint/internal/eqeq-nullish\n        analyzeOptions.jsxPragma === undefined &&\n            compilerOptions.jsxFactory != null) {\n            // in case the user has specified something like \"preact.h\"\n            const factory = compilerOptions.jsxFactory.split('.')[0].trim();\n            analyzeOptions.jsxPragma = factory;\n            log('Resolved jsxPragma from program: %s', analyzeOptions.jsxPragma);\n        }\n        if (\n        // eslint-disable-next-line @typescript-eslint/internal/eqeq-nullish\n        analyzeOptions.jsxFragmentName === undefined &&\n            compilerOptions.jsxFragmentFactory != null) {\n            // in case the user has specified something like \"preact.Fragment\"\n            const fragFactory = compilerOptions.jsxFragmentFactory\n                .split('.')[0]\n                .trim();\n            analyzeOptions.jsxFragmentName = fragFactory;\n            log('Resolved jsxFragmentName from program: %s', analyzeOptions.jsxFragmentName);\n        }\n    }\n    const scopeManager = (0, scope_manager_1.analyze)(ast, analyzeOptions);\n    // if not defined - override from the parserOptions\n    services.emitDecoratorMetadata ??=\n        parserOptions.emitDecoratorMetadata === true;\n    services.experimentalDecorators ??=\n        parserOptions.experimentalDecorators === true;\n    services.isolatedDeclarations ??= parserOptions.isolatedDeclarations === true;\n    return { ast, scopeManager, services, visitorKeys: visitor_keys_1.visitorKeys };\n}\n"
        }
    ]
}