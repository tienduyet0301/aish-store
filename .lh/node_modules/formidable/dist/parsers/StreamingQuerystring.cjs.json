{
    "sourceFile": "node_modules/formidable/dist/parsers/StreamingQuerystring.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892298210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar node_stream = require('node:stream');\n\nconst maxFieldsSizeExceeded = 1006;\n\nconst FormidableError = class extends Error {\n  constructor(message, internalCode, httpCode = 500) {\n    super(message);\n    this.code = internalCode;\n    this.httpCode = httpCode;\n  }\n};\n\n// not used\n/* eslint-disable no-underscore-dangle */\n\n\nconst AMPERSAND = 38;\nconst EQUALS = 61;\n\nclass QuerystringParser extends node_stream.Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n\n    const { maxFieldSize } = options;\n    this.maxFieldLength = maxFieldSize;\n    this.buffer = Buffer.from('');\n    this.fieldCount = 0;\n    this.sectionStart = 0;\n    this.key = '';\n    this.readingKey = true;\n  }\n\n  _transform(buffer, encoding, callback) {\n    let len = buffer.length;\n    if (this.buffer && this.buffer.length) {\n      // we have some data left over from the last write which we are in the middle of processing\n      len += this.buffer.length;\n      buffer = Buffer.concat([this.buffer, buffer], len);\n    }\n\n    for (let i = this.buffer.length || 0; i < len; i += 1) {\n      const c = buffer[i];\n      if (this.readingKey) {\n        // KEY, check for =\n        if (c === EQUALS) {\n          this.key = this.getSection(buffer, i);\n          this.readingKey = false;\n          this.sectionStart = i + 1;\n        } else if (c === AMPERSAND) {\n          // just key, no value. Prepare to read another key\n          this.emitField(this.getSection(buffer, i));\n          this.sectionStart = i + 1;\n        }\n        // VALUE, check for &\n      } else if (c === AMPERSAND) {\n        this.emitField(this.key, this.getSection(buffer, i));\n        this.sectionStart = i + 1;\n      }\n\n      if (\n        this.maxFieldLength &&\n        i - this.sectionStart === this.maxFieldLength\n      ) {\n        callback(\n          new FormidableError(\n            `${\n              this.readingKey ? 'Key' : `Value for ${this.key}`\n            } longer than maxFieldLength`,\n          ),\n          maxFieldsSizeExceeded,\n          413,\n        );\n      }\n    }\n\n    // Prepare the remaining key or value (from sectionStart to the end) for the next write() or for end()\n    len -= this.sectionStart;\n    if (len) {\n      // i.e. Unless the last character was a & or =\n      this.buffer = Buffer.from(this.buffer, 0, this.sectionStart);\n    } else this.buffer = null;\n\n    this.sectionStart = 0;\n    callback();\n  }\n\n  _flush(callback) {\n    // Emit the last field\n    if (this.readingKey) {\n      // we only have a key if there's something in the buffer. We definitely have no value\n      if (this.buffer && this.buffer.length) {\n        this.emitField(this.buffer.toString('ascii'));\n      }\n    } else {\n      // We have a key, we may or may not have a value\n      this.emitField(\n        this.key,\n        this.buffer && this.buffer.length && this.buffer.toString('ascii'),\n      );\n    }\n    this.buffer = '';\n    callback();\n  }\n\n  getSection(buffer, i) {\n    if (i === this.sectionStart) return '';\n\n    return buffer.toString('ascii', this.sectionStart, i);\n  }\n\n  emitField(key, val) {\n    this.key = '';\n    this.readingKey = true;\n    this.push({ key, value: val || '' });\n  }\n}\n\n// const q = new QuerystringParser({maxFieldSize: 100});\n// (async function() {\n//     for await (const chunk of q) {\n//       console.log(chunk);\n//     }\n// })();\n// q.write(\"a=b&c=d\")\n// q.end()\n\nexports.default = QuerystringParser;\n"
        }
    ]
}