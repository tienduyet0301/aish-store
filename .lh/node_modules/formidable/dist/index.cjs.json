{
    "sourceFile": "node_modules/formidable/dist/index.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892297949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar fs = require('node:fs');\nvar crypto = require('node:crypto');\nvar node_events = require('node:events');\nvar cuid2 = require('@paralleldrive/cuid2');\nvar dezalgo = require('dezalgo');\nvar fsPromises = require('node:fs/promises');\nvar os = require('node:os');\nvar path = require('node:path');\nvar node_string_decoder = require('node:string_decoder');\nvar once = require('once');\nvar node_stream = require('node:stream');\n\n/* eslint-disable no-underscore-dangle */\n\n\nclass PersistentFile extends node_events.EventEmitter {\n  constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm }) {\n    super();\n\n    this.lastModifiedDate = null;\n    Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm });\n\n    this.size = 0;\n    this._writeStream = null;\n\n    if (typeof this.hashAlgorithm === 'string') {\n      this.hash = crypto.createHash(this.hashAlgorithm);\n    } else {\n      this.hash = null;\n    }\n  }\n\n  open() {\n    this._writeStream = fs.createWriteStream(this.filepath);\n    this._writeStream.on('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  toJSON() {\n    const json = {\n      size: this.size,\n      filepath: this.filepath,\n      newFilename: this.newFilename,\n      mimetype: this.mimetype,\n      mtime: this.lastModifiedDate,\n      length: this.length,\n      originalFilename: this.originalFilename,\n    };\n    if (this.hash && this.hash !== '') {\n      json.hash = this.hash;\n    }\n    return json;\n  }\n\n  toString() {\n    return `PersistentFile: ${this.newFilename}, Original: ${this.originalFilename}, Path: ${this.filepath}`;\n  }\n\n  write(buffer, cb) {\n    if (this.hash) {\n      this.hash.update(buffer);\n    }\n\n    if (this._writeStream.closed) {\n      cb();\n      return;\n    }\n\n    this._writeStream.write(buffer, () => {\n      this.lastModifiedDate = new Date();\n      this.size += buffer.length;\n      this.emit('progress', this.size);\n      cb();\n    });\n  }\n\n  end(cb) {\n    if (this.hash) {\n      this.hash = this.hash.digest('hex');\n    }\n    this._writeStream.end(() => {\n      this.emit('end');\n      cb();\n    });\n  }\n\n  destroy() {\n    this._writeStream.destroy();\n    const filepath = this.filepath; \n    setTimeout(function () {\n        fs.unlink(filepath, () => {});\n    }, 1);\n  }\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\nclass VolatileFile extends node_events.EventEmitter {\n  constructor({ filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream }) {\n    super();\n\n    this.lastModifiedDate = null;\n    Object.assign(this, { filepath, newFilename, originalFilename, mimetype, hashAlgorithm, createFileWriteStream });\n\n    this.size = 0;\n    this._writeStream = null;\n\n    if (typeof this.hashAlgorithm === 'string') {\n      this.hash = crypto.createHash(this.hashAlgorithm);\n    } else {\n      this.hash = null;\n    }\n  }\n\n  open() {\n    this._writeStream = this.createFileWriteStream(this);\n    this._writeStream.on('error', (err) => {\n      this.emit('error', err);\n    });\n  }\n\n  destroy() {\n    this._writeStream.destroy();\n  }\n\n  toJSON() {\n    const json = {\n      size: this.size,\n      newFilename: this.newFilename,\n      length: this.length,\n      originalFilename: this.originalFilename,\n      mimetype: this.mimetype,\n    };\n    if (this.hash && this.hash !== '') {\n      json.hash = this.hash;\n    }\n    return json;\n  }\n\n  toString() {\n    return `VolatileFile: ${this.originalFilename}`;\n  }\n\n  write(buffer, cb) {\n    if (this.hash) {\n      this.hash.update(buffer);\n    }\n\n    if (this._writeStream.closed || this._writeStream.destroyed) {\n      cb();\n      return;\n    }\n\n    this._writeStream.write(buffer, () => {\n      this.size += buffer.length;\n      this.emit('progress', this.size);\n      cb();\n    });\n  }\n\n  end(cb) {\n    if (this.hash) {\n      this.hash = this.hash.digest('hex');\n    }\n    this._writeStream.end(() => {\n      this.emit('end');\n      cb();\n    });\n  }\n}\n\nconst missingPlugin = 1000;\nconst pluginFunction = 1001;\nconst aborted = 1002;\nconst noParser = 1003;\nconst uninitializedParser = 1004;\nconst filenameNotString = 1005;\nconst maxFieldsSizeExceeded = 1006;\nconst maxFieldsExceeded = 1007;\nconst smallerThanMinFileSize = 1008;\nconst biggerThanTotalMaxFileSize = 1009;\nconst noEmptyFiles = 1010;\nconst missingContentType = 1011;\nconst malformedMultipart = 1012;\nconst missingMultipartBoundary = 1013;\nconst unknownTransferEncoding = 1014;\nconst maxFilesExceeded = 1015;\nconst biggerThanMaxFileSize = 1016;\nconst pluginFailed = 1017;\nconst cannotCreateDir = 1018;\n\nconst FormidableError = class extends Error {\n  constructor(message, internalCode, httpCode = 500) {\n    super(message);\n    this.code = internalCode;\n    this.httpCode = httpCode;\n  }\n};\n\nvar FormidableError$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  aborted: aborted,\n  biggerThanMaxFileSize: biggerThanMaxFileSize,\n  biggerThanTotalMaxFileSize: biggerThanTotalMaxFileSize,\n  cannotCreateDir: cannotCreateDir,\n  default: FormidableError,\n  filenameNotString: filenameNotString,\n  malformedMultipart: malformedMultipart,\n  maxFieldsExceeded: maxFieldsExceeded,\n  maxFieldsSizeExceeded: maxFieldsSizeExceeded,\n  maxFilesExceeded: maxFilesExceeded,\n  missingContentType: missingContentType,\n  missingMultipartBoundary: missingMultipartBoundary,\n  missingPlugin: missingPlugin,\n  noEmptyFiles: noEmptyFiles,\n  noParser: noParser,\n  pluginFailed: pluginFailed,\n  pluginFunction: pluginFunction,\n  smallerThanMinFileSize: smallerThanMinFileSize,\n  uninitializedParser: uninitializedParser,\n  unknownTransferEncoding: unknownTransferEncoding\n});\n\n/* eslint-disable no-underscore-dangle */\n\n\nclass DummyParser extends node_stream.Transform {\n  constructor(incomingForm, options = {}) {\n    super();\n    this.globalOptions = { ...options };\n    this.incomingForm = incomingForm;\n  }\n\n  _flush(callback) {\n    this.incomingForm.ended = true;\n    this.incomingForm._maybeEnd();\n    callback();\n  }\n}\n\n/* eslint-disable no-fallthrough */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-underscore-dangle */\n\n\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++,\n};\n\nlet f = 1;\nconst FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: (f *= 2) };\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nfunction lower(c) {\n  return c | 0x20;\n}\n\nconst STATES = {};\n\nObject.keys(STATE).forEach((stateName) => {\n  STATES[stateName] = STATE[stateName];\n});\n\nclass MultipartParser extends node_stream.Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n\n    this.globalOptions = { ...options };\n    this.index = null;\n    this.flags = 0;\n  }\n\n  _endUnexpected() {\n    return new FormidableError(\n      `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,\n      malformedMultipart,\n      400,\n    );\n  }\n\n  _flush(done) {\n    if (\n      (this.state === STATE.HEADER_FIELD_START && this.index === 0) ||\n      (this.state === STATE.PART_DATA && this.index === this.boundary.length)\n    ) {\n      this._handleCallback('partEnd');\n      this._handleCallback('end');\n      done();\n    } else if (this.state !== STATE.END) {\n      done(this._endUnexpected());\n    } else {\n      done();\n    }\n  }\n\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  }\n\n  // eslint-disable-next-line max-params\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n    this.push({ name, buffer: buf, start, end });\n  }\n\n  // eslint-disable-next-line max-statements\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let { index, state, flags } = this;\n    const { lookbehind, boundary, boundaryChars } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n\n    const clearMarkSymbol = (name) => {\n      delete this[`${name}Mark`];\n    };\n\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n        clearMarkSymbol(name);\n      }\n    };\n\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          done(this._endUnexpected());\n          return;\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              done(this._endUnexpected());\n              return;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              this._handleCallback('partBegin');\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              done(this._endUnexpected());\n              return;\n            }\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              done(this._endUnexpected());\n              return;\n            }\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            done(this._endUnexpected());\n            return;\n          }\n          break;\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n            this._handleCallback('headerEnd');\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            done(this._endUnexpected());\nreturn;\n          }\n          state = STATE.HEADER_FIELD_START;\n          break;\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            done(this._endUnexpected());\n            return;\n          }\n\n          this._handleCallback('headersEnd');\n          state = STATE.PART_DATA_START;\n          break;\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n        case STATE.PART_DATA:\n          prevIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n                this._handleCallback('partEnd');\n                this._handleCallback('partBegin');\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n                this._handleCallback('end');\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n            prevIndex = 0;\n            setMark('partData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n\n          break;\n        case STATE.END:\n          break;\n        default:\n          done(this._endUnexpected());\n          return;\n      }\n    }\n\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n\n    done();\n    return this.bufferLength;\n  }\n\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n}\n\n// eslint-disable-next-line consistent-return\nMultipartParser.stateToString = (stateNumber) => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\n\nvar MultipartParser$1 = Object.assign(MultipartParser, { STATES });\n\nclass OctetStreamParser extends node_stream.PassThrough {\n  constructor(options = {}) {\n    super();\n    this.globalOptions = { ...options };\n  }\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\nconst octetStreamType = 'octet-stream';\n// the `options` is also available through the `options` / `formidable.options`\nasync function plugin$3(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/octet-stream/i.test(self.headers['content-type'])) {\n    await init$2.call(self, self, options);\n  }\n  return self;\n}\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nasync function init$2(_self, _opts) {\n  this.type = octetStreamType;\n  const originalFilename = this.headers['x-file-name'];\n  const mimetype = this.headers['content-type'];\n\n  const thisPart = {\n    originalFilename,\n    mimetype,\n  };\n  const newFilename = this._getNewName(thisPart);\n  const filepath = this._joinDirectoryName(newFilename);\n  const file = await this._newFile({\n    newFilename,\n    filepath,\n    originalFilename,\n    mimetype,\n  });\n\n  this.emit('fileBegin', originalFilename, file);\n  file.open();\n  this.openedFiles.push(file);\n  this._flushing += 1;\n\n  this._parser = new OctetStreamParser(this.options);\n\n  // Keep track of writes that haven't finished so we don't emit the file before it's done being written\n  let outstandingWrites = 0;\n\n  this._parser.on('data', (buffer) => {\n    this.pause();\n    outstandingWrites += 1;\n\n    file.write(buffer, () => {\n      outstandingWrites -= 1;\n      this.resume();\n\n      if (this.ended) {\n        this._parser.emit('doneWritingFile');\n      }\n    });\n  });\n\n  this._parser.on('end', () => {\n    this._flushing -= 1;\n    this.ended = true;\n\n    const done = () => {\n      file.end(() => {\n        this.emit('file', 'file', file);\n        this._maybeEnd();\n      });\n    };\n\n    if (outstandingWrites === 0) {\n      done();\n    } else {\n      this._parser.once('doneWritingFile', done);\n    }\n  });\n\n  return this;\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\n// This is a buffering parser, have a look at StreamingQuerystring.js for a streaming parser\nclass QuerystringParser extends node_stream.Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.globalOptions = { ...options };\n    this.buffer = '';\n    this.bufferLength = 0;\n  }\n\n  _transform(buffer, encoding, callback) {\n    this.buffer += buffer.toString('ascii');\n    this.bufferLength = this.buffer.length;\n    callback();\n  }\n\n  _flush(callback) {\n    const fields = new URLSearchParams(this.buffer);\n    for (const [key, value] of fields) {\n      this.push({\n        key,\n        value,\n      });\n    }\n    this.buffer = '';\n    callback();\n  }\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\nconst querystringType = 'urlencoded';\n// the `options` is also available through the `this.options` / `formidable.options`\nfunction plugin$2(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/urlencoded/i.test(self.headers['content-type'])) {\n    init$1.call(self, self, options);\n  }\n  return self;\n}\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction init$1(_self, _opts) {\n  this.type = querystringType;\n\n  const parser = new QuerystringParser(this.options);\n\n  parser.on('data', ({ key, value }) => {\n    this.emit('field', key, value);\n  });\n\n  parser.once('end', () => {\n    this.ended = true;\n    this._maybeEnd();\n  });\n\n  this._parser = parser;\n\n  return this;\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\nconst multipartType = 'multipart';\n// the `options` is also available through the `options` / `formidable.options`\nfunction plugin$1(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  // NOTE: we (currently) support both multipart/form-data and multipart/related\n  const multipart = /multipart/i.test(self.headers['content-type']);\n\n  if (multipart) {\n    const m = self.headers['content-type'].match(\n      /boundary=(?:\"([^\"]+)\"|([^;]+))/i,\n    );\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError(\n        'bad content-type header, no multipart boundary',\n        missingMultipartBoundary,\n        400,\n      );\n      self._error(err);\n    }\n  }\n  return self;\n}\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = multipartType;\n\n    const parser = new MultipartParser$1(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n\n    parser.initWithBoundary(boundary);\n\n    // eslint-disable-next-line max-statements, consistent-return\n    parser.on('data', async ({ name, buffer, start, end }) => {\n      if (name === 'partBegin') {\n        part = new node_stream.Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue;\n\n        // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n        const m = headerValue.match(\n          // eslint-disable-next-line no-useless-escape\n          /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i,\n        );\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          case 'base64': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.transferBuffer += ctx.buffer\n                  .slice(ctx.start, ctx.end)\n                  .toString('ascii');\n\n                /*\n                  four bytes (chars) in base64 converts to three bytes in binary\n                  encoding. So we should always work with a number of bytes that\n                  can be divided by 4, it will result in a number of bytes that\n                  can be divided vy 3.\n                  */\n                const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                part.emit(\n                  'data',\n                  Buffer.from(\n                    part.transferBuffer.substring(0, offset),\n                    'base64',\n                  ),\n                );\n                part.transferBuffer = part.transferBuffer.substring(offset);\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          default:\n            return this._error(\n              new FormidableError(\n                'unknown transfer-encoding',\n                unknownTransferEncoding,\n                501,\n              ),\n            );\n        }\n        this._parser.pause();\n        await this.onPart(part);\n        this._parser.resume();\n      } else if (name === 'end') {\n        this.ended = true;\n        this._maybeEnd();\n      }\n    });\n\n    this._parser = parser;\n  };\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\nclass JSONParser extends node_stream.Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.chunks = [];\n    this.globalOptions = { ...options };\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.chunks.push(String(chunk)); // todo consider using a string decoder\n    callback();\n  }\n\n  _flush(callback) {\n    try {\n      const fields = JSON.parse(this.chunks.join(''));\n      this.push(fields);\n    } catch (e) {\n      callback(e);\n      return;\n    }\n    this.chunks = null;\n    callback();\n  }\n}\n\n/* eslint-disable no-underscore-dangle */\n\n\nconst jsonType = 'json';\n// the `options` is also available through the `this.options` / `formidable.options`\nfunction plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  if (/json/i.test(self.headers['content-type'])) {\n    init.call(self, self, options);\n  }\n\n  return self;\n}\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction init(_self, _opts) {\n  this.type = jsonType;\n\n  const parser = new JSONParser(this.options);\n\n  parser.on('data', (fields) => {\n    this.fields = fields;\n  });\n\n  parser.once('end', () => {\n    this.ended = true;\n    this._maybeEnd();\n  });\n\n  this._parser = parser;\n}\n\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\n\n\nconst CUID2_FINGERPRINT = `${process.env.NODE_ENV}-${os.platform()}-${os.hostname()}`;\nconst createId = cuid2.init({ length: 25, fingerprint: CUID2_FINGERPRINT.toLowerCase() });\n\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFiles: Infinity,\n  maxFileSize: 200 * 1024 * 1024,\n  maxTotalFileSize: undefined,\n  minFileSize: 1,\n  allowEmptyFiles: false,\n  createDirsFromUploads: false,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  enabledPlugins: [plugin$3, plugin$2, plugin$1, plugin],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter(_part) {\n    return true;\n  },\n  filename: undefined,\n};\n\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n\nconst decorateForceSequential = function (promiseCreator) {\n  /* forces a function that returns a promise to be sequential\n  useful for fs  for example */\n  let lastPromise = Promise.resolve();\n  return async function (...x) {\n      const promiseWeAreWaitingFor = lastPromise;\n      let currentPromise;\n      let callback;\n      // we need to change lastPromise before await anything,\n      // otherwise 2 calls might wait the same thing\n      lastPromise = new Promise(function (resolve) {\n          callback = resolve;\n      });\n      await promiseWeAreWaitingFor;\n      currentPromise = promiseCreator(...x);\n      currentPromise.then(callback).catch(callback);\n      return currentPromise;\n  };\n};\n\nconst createNecessaryDirectoriesAsync = decorateForceSequential(function (filePath) {\n  const directoryname = path.dirname(filePath);\n  return fsPromises.mkdir(directoryname, { recursive: true });\n});\n\nconst invalidExtensionChar = (c) => {\n  const code = c.charCodeAt(0);\n  return !(\n    code === 46 || // .\n    (code >= 48 && code <= 57) ||\n    (code >= 65 && code <= 90) ||\n    (code >= 97 && code <= 122)\n  );\n};\n\nclass IncomingForm extends node_events.EventEmitter {\n  constructor(options = {}) {\n    super();\n\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    if (!this.options.maxTotalFileSize) {\n      this.options.maxTotalFileSize = this.options.maxFileSize;\n    }\n\n    const dir = path.resolve(\n      this.options.uploadDir || this.options.uploaddir || os.tmpdir(),\n    );\n\n    this.uploaddir = dir;\n    this.uploadDir = dir;\n\n    // initialize with null\n    [\n      'error',\n      'headers',\n      'type',\n      'bytesExpected',\n      'bytesReceived',\n      '_parser',\n      'req',\n    ].forEach((key) => {\n      this[key] = null;\n    });\n\n    this._setUpRename();\n\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._totalFileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n\n    this.options.enabledPlugins = []\n      .concat(this.options.enabledPlugins)\n      .filter(Boolean);\n\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError(\n        'expect at least 1 enabled builtin plugin, see options.enabledPlugins',\n        missingPlugin,\n      );\n    }\n\n    this.options.enabledPlugins.forEach((plugin) => {\n      this.use(plugin);\n    });\n\n    this._setUpMaxFields();\n    this._setUpMaxFiles();\n    this.ended = undefined;\n    this.type = undefined;\n  }\n\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError(\n        '.use: expect `plugin` to be a function',\n        pluginFunction,\n      );\n    }\n    this._plugins.push(plugin.bind(this));\n    return this;\n  }\n\n  pause () {\n    try {\n      this.req.pause();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  resume () {\n    try {\n      this.req.resume();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n      return false;\n    }\n\n    return true;\n  }\n\n  // returns a promise if no callback is provided\n  async parse(req, cb) {\n    this.req = req;\n    let promise;\n\n    // Setup callback first, so we don't miss anything from data events emitted immediately.\n    if (!cb) {\n      let resolveRef;\n      let rejectRef;\n      promise = new Promise((resolve, reject) => {\n        resolveRef = resolve;\n        rejectRef = reject;\n      });\n      cb = (err, fields, files) => {\n        if (err) {\n          rejectRef(err);\n        } else {\n          resolveRef([fields, files]);\n        }\n      };\n    }\n    const callback = once(dezalgo(cb));\n    this.fields = {};\n    const files = {};\n\n    this.on('field', (name, value) => {\n      if (this.type === 'multipart' || this.type === 'urlencoded') {\n        if (!hasOwnProp(this.fields, name)) {\n          this.fields[name] = [value];\n        } else {\n          this.fields[name].push(value);\n        }\n      } else {\n        this.fields[name] = value;\n      }\n    });\n    this.on('file', (name, file) => {\n      if (!hasOwnProp(files, name)) {\n        files[name] = [file];\n      } else {\n        files[name].push(file);\n      }\n    });\n    this.on('error', (err) => {\n      callback(err, this.fields, files);\n    });\n    this.on('end', () => {\n      callback(null, this.fields, files);\n    });\n\n    // Parse headers and setup the parser, ready to start listening for data.\n    await this.writeHeaders(req.headers);\n\n    // Start listening for data.\n    req\n      .on('error', (err) => {\n        this._error(err);\n      })\n      .on('aborted', () => {\n        this.emit('aborted');\n        this._error(new FormidableError('Request aborted', aborted));\n      })\n      .on('data', (buffer) => {\n        try {\n          this.write(buffer);\n        } catch (err) {\n          this._error(err);\n        }\n      })\n      .on('end', () => {\n        if (this.error) {\n          return;\n        }\n        if (this._parser) {\n          this._parser.end();\n        }\n      });\n    if (promise) {\n      return promise;\n    }\n    return this;\n  }\n\n  async writeHeaders(headers) {\n    this.headers = headers;\n    this._parseContentLength();\n    await this._parseContentType();\n\n    if (!this._parser) {\n      this._error(\n        new FormidableError(\n          'no parser found',\n          noParser,\n          415, // Unsupported Media Type\n        ),\n      );\n      return;\n    }\n\n    this._parser.once('error', (error) => {\n      this._error(error);\n    });\n  }\n\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n    if (!this._parser) {\n      this._error(\n        new FormidableError('uninitialized parser', uninitializedParser),\n      );\n      return null;\n    }\n\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n    this._parser.write(buffer);\n\n    return this.bytesReceived;\n  }\n\n  onPart(part) {\n    // this method can be overwritten by the user\n    return this._handlePart(part);\n  }\n\n  async _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(\n        new FormidableError(\n          `the part.originalFilename should be string when it exists`,\n          filenameNotString,\n        ),\n      );\n      return;\n    }\n\n    // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new node_string_decoder.StringDecoder(\n        part.transferEncoding || this.options.encoding,\n      );\n\n      part.on('data', (buffer) => {\n        this._fieldsSize += buffer.length;\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(\n            new FormidableError(\n              `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,\n              maxFieldsSizeExceeded,\n              413, // Payload Too Large\n            ),\n          );\n          return;\n        }\n        value += decoder.write(buffer);\n      });\n\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n\n    if (!this.options.filter(part)) {\n      return;\n    }\n\n    this._flushing += 1;\n\n    let fileSize = 0;\n    const newFilename = this._getNewName(part);\n    const filepath = this._joinDirectoryName(newFilename);\n    const file = await this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype,\n    });\n    file.on('error', (err) => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n\n    file.open();\n    this.openedFiles.push(file);\n\n    part.on('data', (buffer) => {\n      this._totalFileSize += buffer.length;\n      fileSize += buffer.length;\n\n      if (this._totalFileSize > this.options.maxTotalFileSize) {\n        this._error(\n          new FormidableError(\n            `options.maxTotalFileSize (${this.options.maxTotalFileSize} bytes) exceeded, received ${this._totalFileSize} bytes of file data`,\n            biggerThanTotalMaxFileSize,\n            413,\n          ),\n        );\n        return;\n      }\n      if (buffer.length === 0) {\n        return;\n      }\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && fileSize === 0) {\n        this._error(\n          new FormidableError(\n            `options.allowEmptyFiles is false, file size should be greater than 0`,\n            noEmptyFiles,\n            400,\n          ),\n        );\n        return;\n      }\n      if (fileSize < this.options.minFileSize) {\n        this._error(\n          new FormidableError(\n            `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${fileSize} bytes of file data`,\n            smallerThanMinFileSize,\n            400,\n          ),\n        );\n        return;\n      }\n      if (fileSize > this.options.maxFileSize) {\n        this._error(\n          new FormidableError(\n            `options.maxFileSize (${this.options.maxFileSize} bytes), received ${fileSize} bytes of file data`,\n            biggerThanMaxFileSize,\n            413,\n          ),\n        );\n        return;\n      }\n\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n        this._maybeEnd();\n      });\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  async _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n\n    if (!this.headers['content-type']) {\n      this._error(\n        new FormidableError(\n          'bad content-type header, no content-type',\n          missingContentType,\n          400,\n        ),\n      );\n      return;\n    }\n\n\n    new DummyParser(this, this.options);\n\n    const results = [];\n    await Promise.all(this._plugins.map(async (plugin, idx) => {\n      let pluginReturn = null;\n      try {\n        pluginReturn = await plugin(this, this.options) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(\n          `plugin on index ${idx} failed with: ${err.message}`,\n          pluginFailed,\n          500,\n        );\n        error.idx = idx;\n        throw error;\n      }\n      Object.assign(this, pluginReturn);\n\n      // todo: use Set/Map and pass plugin name instead of the `idx` index\n      this.emit('plugin', idx, pluginReturn);\n    }));\n    this.emit('pluginsResults', results);\n  }\n\n  _error(err, eventName = 'error') {\n    if (this.error || this.ended) {\n      return;\n    }\n\n    this.req = null;\n    this.error = err;\n    this.emit(eventName, err);\n\n    this.openedFiles.forEach((file) => {\n      file.destroy();\n    });\n  }\n\n  _parseContentLength() {\n    this.bytesReceived = 0;\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n\n  _newParser() {\n    return new MultipartParser$1(this.options);\n  }\n\n  async _newFile({ filepath, originalFilename, mimetype, newFilename }) {\n    if (this.options.fileWriteStreamHandler) {\n      return new VolatileFile({\n        newFilename,\n        filepath,\n        originalFilename,\n        mimetype,\n        createFileWriteStream: this.options.fileWriteStreamHandler,\n        hashAlgorithm: this.options.hashAlgorithm,\n      });\n    }\n    if (this.options.createDirsFromUploads) {\n      try {\n        await createNecessaryDirectoriesAsync(filepath);\n      } catch (errorCreatingDir) {\n        this._error(new FormidableError(\n          `cannot create directory`,\n          cannotCreateDir,\n          409,\n        ));\n      }\n    }\n    return new PersistentFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      hashAlgorithm: this.options.hashAlgorithm,\n    });\n  }\n\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(\n      /\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i,\n    );\n    if (!m) return null;\n\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) =>\n      String.fromCharCode(code),\n    );\n\n    return originalFilename;\n  }\n\n  // able to get composed extension with multiple dots\n  // \"a.b.c\" -> \".b.c\"\n  // as opposed to path.extname -> \".c\"\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    let rawExtname = path.extname(basename);\n\n    if (firstDot !== lastDot) {\n      rawExtname =  basename.slice(firstDot);\n    }\n\n    let filtered;\n    const firstInvalidIndex = Array.from(rawExtname).findIndex(invalidExtensionChar);\n    if (firstInvalidIndex === -1) {\n      filtered = rawExtname;\n    } else {\n      filtered = rawExtname.substring(0, firstInvalidIndex);\n    }\n    if (filtered === '.') {\n      return '';\n    }\n    return filtered;\n  }\n\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name);\n\n    // prevent directory traversal attacks\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n\n    return newPath;\n  }\n\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n    if (hasRename) {\n      this._getNewName = (part) => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n        if (part.originalFilename) {\n          // can be null\n          ({ ext, name } = path.parse(part.originalFilename));\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = (part) => {\n        const name = createId();\n\n        if (part && this.options.keepExtensions) {\n          const originalFilename =\n            typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n\n        return name;\n      };\n    }\n  }\n\n  _setUpMaxFields() {\n    if (this.options.maxFields !== Infinity) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n        if (fieldsCount > this.options.maxFields) {\n          this._error(\n            new FormidableError(\n              `options.maxFields (${this.options.maxFields}) exceeded`,\n              maxFieldsExceeded,\n              413,\n            ),\n          );\n        }\n      });\n    }\n  }\n\n  _setUpMaxFiles() {\n    if (this.options.maxFiles !== Infinity) {\n      let fileCount = 0;\n      this.on('fileBegin', () => {\n        fileCount += 1;\n        if (fileCount > this.options.maxFiles) {\n          this._error(\n            new FormidableError(\n              `options.maxFiles (${this.options.maxFiles}) exceeded`,\n              maxFilesExceeded,\n              413,\n            ),\n          );\n        }\n      });\n    }\n  }\n\n  _maybeEnd() {\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n    this.req = null;\n    this.emit('end');\n  }\n}\n\n// make it available without requiring the `new` keyword\n// if you want it access `const formidable.IncomingForm` as v1\nconst formidable = (...args) => new IncomingForm(...args);\nconst {enabledPlugins} = DEFAULT_OPTIONS;\n\nexports.DummyParser = DummyParser;\nexports.File = PersistentFile;\nexports.Formidable = IncomingForm;\nexports.IncomingForm = IncomingForm;\nexports.JSONParser = JSONParser;\nexports.MultipartParser = MultipartParser$1;\nexports.OctetStreamParser = OctetStreamParser;\nexports.OctetstreamParser = OctetStreamParser;\nexports.PersistentFile = PersistentFile;\nexports.QueryStringParser = QuerystringParser;\nexports.QuerystringParser = QuerystringParser;\nexports.VolatileFile = VolatileFile;\nexports.default = formidable;\nexports.defaultOptions = DEFAULT_OPTIONS;\nexports.enabledPlugins = enabledPlugins;\nexports.errors = FormidableError$1;\nexports.formidable = formidable;\nexports.json = plugin;\nexports.multipart = plugin$1;\nexports.octetstream = plugin$3;\nexports.querystring = plugin$2;\n"
        }
    ]
}