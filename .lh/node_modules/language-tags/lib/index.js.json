{
    "sourceFile": "node_modules/language-tags/lib/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892383447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @author Matthew Caruana Galizia <mattcg@gmail.com>\n * @license MIT: http://mattcg.mit-license.org/\n * @copyright Copyright (c) 2013, Matthew Caruana Galizia\n */\n\n'use strict';\n\nvar Tag = require('./Tag.js');\nvar Subtag = require('./Subtag.js');\nvar index = require('language-subtag-registry/data/json/index.json');\nvar registry = require('language-subtag-registry/data/json/registry.json');\nvar tags = function tags(tag) {\n  return new Tag(tag);\n};\nmodule.exports = tags;\ntags.check = function (tag) {\n  return new Tag(tag).valid();\n};\ntags.types = function (subtag) {\n  var types = index[subtag.toLowerCase()];\n  if (!types) {\n    return [];\n  }\n  return Object.keys(types).filter(function (type) {\n    return type !== 'grandfathered' && type !== 'redundant';\n  });\n};\ntags.subtags = function (subtags) {\n  var result = [];\n  if (!Array.isArray(subtags)) {\n    subtags = [subtags];\n  }\n  subtags.forEach(function (subtag) {\n    tags.types(subtag).forEach(function (type) {\n      result.push(new Subtag(subtag, type));\n    });\n  });\n  return result;\n};\ntags.filter = function (subtags) {\n  return subtags.filter(function (subtag) {\n    return !tags.types(subtag).length;\n  });\n};\ntags.search = function (query, all) {\n  var test;\n  if ('function' === typeof query.test) {\n    test = function test(description) {\n      return query.test(description);\n    };\n\n    // If the query is all lowercase, make a case-insensitive match.\n  } else if (query.toLowerCase() === query) {\n    test = function test(description) {\n      return -1 !== description.toLowerCase().indexOf(query);\n    };\n  } else {\n    test = function test(description) {\n      return -1 !== description.indexOf(query);\n    };\n  }\n  return registry.filter(function (record) {\n    if (!record.Subtag && !all) {\n      return false;\n    }\n    return record.Description.some(test);\n\n    // Sort by matched description string length.\n    // This is a quick way to push precise matches towards the top.\n  }).sort(function (a, b) {\n    return Math.min.apply(Math, a.Description.filter(test).map(function (description) {\n      return description.length;\n    })) - Math.min.apply(Math, b.Description.filter(test).map(function (description) {\n      return description.length;\n    }));\n  }).map(function (record) {\n    if (record.Subtag) {\n      return new Subtag(record.Subtag, record.Type);\n    }\n    return new Tag(record.Tag);\n  });\n};\ntags.languages = function (macrolanguage) {\n  var i,\n    l,\n    record,\n    results = [];\n  macrolanguage = macrolanguage.toLowerCase();\n  if (!require('language-subtag-registry/data/json/macrolanguage.json')[macrolanguage]) {\n    throw new Error('\\'' + macrolanguage + '\\' is not a macrolanguage.');\n  }\n  for (i = 0, l = registry.length; i < l; i++) {\n    record = registry[i];\n    if (record.Macrolanguage === macrolanguage) {\n      results.push(new Subtag(record.Subtag, record.Type));\n    }\n  }\n  return results;\n};\ntags.language = function (subtag) {\n  return tags.type(subtag, 'language');\n};\ntags.region = function (subtag) {\n  return tags.type(subtag, 'region');\n};\ntags.type = function (subtag, type) {\n  var types = index[subtag.toLowerCase()];\n  if (types && types[type]) {\n    return new Subtag(subtag, type);\n  }\n  return null;\n};\ntags.date = function () {\n  return require('language-subtag-registry/data/json/meta.json')['File-Date'];\n};"
        }
    ]
}