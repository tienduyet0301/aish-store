{
    "sourceFile": "node_modules/language-tags/lib/Tag.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892383583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @author Matthew Caruana Galizia <mattcg@gmail.com>\n * @license MIT: http://mattcg.mit-license.org/\n * @copyright Copyright (c) 2013, Matthew Caruana Galizia\n */\n\n'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar index = require('language-subtag-registry/data/json/index.json');\nvar registry = require('language-subtag-registry/data/json/registry.json');\nvar Subtag = require('./Subtag.js');\nvar Tag = /*#__PURE__*/function () {\n  /** @param {string} tag */\n  function Tag(tag) {\n    _classCallCheck(this, Tag);\n    var types;\n\n    // Lowercase for consistency (case is only a formatting convention, not a standard requirement).\n    tag = tag.trim().toLowerCase();\n    this.data = {\n      tag: tag\n    };\n\n    // Check if the input tag is grandfathered or redundant.\n    types = index[tag];\n    if (types && (types.grandfathered || types.redundant)) {\n      this.data.record = registry[types.grandfathered || types.redundant];\n    }\n  }\n  _createClass(Tag, [{\n    key: \"preferred\",\n    value: function preferred() {\n      var preferred = this.data.record['Preferred-Value'];\n      if (preferred) {\n        return new Tag(preferred);\n      }\n      return null;\n    }\n\n    /** @return {Subtag[]} */\n  }, {\n    key: \"subtags\",\n    value: function subtags() {\n      var codes,\n        data = this.data,\n        subtags = [];\n\n      // No subtags if the tag is grandfathered.\n      if (data.record && this.type() === 'grandfathered') {\n        return subtags;\n      }\n      codes = data.tag.split('-');\n      if (!codes.length) {\n        return subtags;\n      }\n\n      // Try and find the language tag.\n      codes.some(function (code, i) {\n        var types;\n\n        // Singletons and anything after are unhandled.\n        if (code.length < 2) {\n          return true; // Stop the loop (stop processing after a singleton).\n        }\n\n        types = index[code];\n\n        // Check for non-existent tag.\n        if (!types) {\n          return; // Skip to the next item.\n        }\n\n        // Check against undefined because value could be 0.\n        // Language subtags may only appear at the beginning of the tag, otherwise the subtag type is indeterminate.\n        if (0 === i && undefined !== types.language) {\n          subtags.push(new Subtag(code, 'language'));\n          return;\n        }\n        switch (code.length) {\n          case 2:\n            // Should be a region.\n            if (types.region) {\n              subtags.push(new Subtag(code, 'region'));\n\n              // Error case: language subtag in the wrong place.\n            } else if (types.language) {\n              subtags.push(new Subtag(code, 'language'));\n            }\n            break;\n          case 3:\n            // Could be a numeric region code e.g. '001' for 'World'.\n            if (types.region) {\n              subtags.push(new Subtag(code, 'region'));\n            } else if (types.extlang) {\n              subtags.push(new Subtag(code, 'extlang'));\n\n              // Error case: language subtag in the wrong place.\n            } else if (types.language) {\n              subtags.push(new Subtag(code, 'language'));\n            }\n            break;\n          case 4:\n            // Could be a numeric variant.\n            if (types.variant) {\n              subtags.push(new Subtag(code, 'variant'));\n            } else if (types.script) {\n              subtags.push(new Subtag(code, 'script'));\n            }\n            break;\n          default:\n            // Should be a variant.\n            if (types.variant) {\n              subtags.push(new Subtag(code, 'variant'));\n            }\n            break;\n        }\n      });\n      return subtags;\n    }\n  }, {\n    key: \"language\",\n    value: function language() {\n      return this.find('language');\n    }\n  }, {\n    key: \"region\",\n    value: function region() {\n      return this.find('region');\n    }\n  }, {\n    key: \"script\",\n    value: function script() {\n      return this.find('script');\n    }\n\n    /** @param {string} type */\n  }, {\n    key: \"find\",\n    value: function find(type) {\n      var i,\n        l,\n        subtag,\n        subtags = this.subtags();\n      for (i = 0, l = subtags.length; i < l; i++) {\n        subtag = subtags[i];\n        if (subtag.type() === type) {\n          return subtag;\n        }\n      }\n    }\n  }, {\n    key: \"valid\",\n    value: function valid() {\n      return this.errors().length < 1;\n    }\n  }, {\n    key: \"errors\",\n    value: function errors() {\n      var error,\n        subtags,\n        data = this.data,\n        errors = [];\n      error = function error(code, subtag) {\n        var err, message;\n        switch (code) {\n          case Tag.ERR_DEPRECATED:\n            message = 'The tag \\'' + data.tag + '\\' is deprecated.';\n\n            // Note that a record that contains a 'Deprecated' field and no corresponding 'Preferred-Value' field has no replacement mapping (RFC 5646 section 3.1.6).\n            if (data.record['Preferred-Value']) {\n              message += ' Use \\'' + data.record['Preferred-Value'] + '\\' instead.';\n            }\n            break;\n          case Tag.ERR_SUBTAG_DEPRECATED:\n            message = 'The subtag \\'' + subtag + '\\' is deprecated.';\n            break;\n          case Tag.ERR_NO_LANGUAGE:\n            if (!data.tag) {\n              message = 'Empty tag.';\n            } else {\n              message = 'Missing language tag in \\'' + data.tag + '\\'.';\n            }\n            break;\n          case Tag.ERR_UNKNOWN:\n            message = 'Unknown code \\'' + subtag + '\\'';\n            break;\n          case Tag.ERR_TOO_LONG:\n            message = 'The private-use subtag \\'' + subtag + '\\' is too long.';\n            break;\n          case Tag.ERR_EXTRA_LANGUAGE:\n          case Tag.ERR_EXTRA_EXTLANG:\n          case Tag.ERR_EXTRA_REGION:\n          case Tag.ERR_EXTRA_SCRIPT:\n            message = 'Extra ' + subtag.type() + ' subtag \\'' + subtag + '\\' found.';\n            break;\n          case Tag.ERR_DUPLICATE_VARIANT:\n            message = 'Duplicate variant subtag \\'' + subtag + '\\' found.';\n            break;\n          case Tag.ERR_WRONG_ORDER:\n            message = 'The subtag \\'' + subtag[0] + '\\' should not appear before \\'' + subtag[1] + '\\'.';\n            break;\n          case Tag.ERR_SUPPRESS_SCRIPT:\n            message = 'The script subtag \\'' + subtag + '\\' is the same as the language suppress-script.';\n            break;\n        }\n        err = new Error(message);\n        err.code = code;\n        err.tag = data.tag;\n        err.subtag = subtag;\n        errors.push(err);\n      };\n\n      // Check if the tag is grandfathered and if the grandfathered tag is deprecated (e.g. no-nyn).\n      if (data.record) {\n        if (data.record.Deprecated) {\n          error(Tag.ERR_DEPRECATED);\n        }\n\n        // Only check every subtag if the tag is not explicitly listed as grandfathered or redundant.\n        return errors;\n      }\n\n      // Check that all subtag codes are meaningful.\n      data.tag.split('-').some(function (code, i, codes) {\n        var types;\n\n        // Ignore anything after a singleton.\n        if (code.length < 2) {\n          // Check that each private-use subtag is within the maximum allowed length.\n          codes.slice(i).forEach(function (code) {\n            if (code.length > 8) {\n              error(Tag.ERR_TOO_LONG, code);\n            }\n          });\n          return true;\n        }\n        types = index[code];\n        if (!types) {\n          error(Tag.ERR_UNKNOWN, code);\n        }\n        return false; // Continue to the next item.\n      });\n\n      // Check that first tag is a language tag.\n      subtags = this.subtags();\n      if (!subtags.length || 'language' !== subtags[0].type()) {\n        error(Tag.ERR_NO_LANGUAGE);\n        return errors;\n      }\n\n      // Check for more than one of some types and for deprecation.\n      subtags.forEach(function (subtag, i) {\n        var type = subtag.type(),\n          language,\n          script,\n          found = this;\n        if (subtag.deprecated()) {\n          error(Tag.ERR_SUBTAG_DEPRECATED, subtag);\n        }\n        if (found[type]) {\n          found[type].push(subtag);\n        }\n        switch (type) {\n          case 'language':\n            if (found.language.length > 1) {\n              error(Tag.ERR_EXTRA_LANGUAGE, subtag);\n            }\n            break;\n          case 'region':\n            if (found.region.length > 1) {\n              error(Tag.ERR_EXTRA_REGION, subtag);\n            }\n            break;\n          case 'extlang':\n            if (found.extlang.length > 1) {\n              error(Tag.ERR_EXTRA_EXTLANG, subtag);\n            }\n            break;\n          case 'script':\n            if (found.script.length > 1) {\n              error(Tag.ERR_EXTRA_SCRIPT, subtag);\n\n              // Check if script is same as language suppress-script.\n            } else {\n              language = subtags[0];\n              if ('language' === language.type()) {\n                script = language.script();\n                if (script && script.format() === subtag.format()) {\n                  error(Tag.ERR_SUPPRESS_SCRIPT, subtag);\n                }\n              }\n            }\n            break;\n          case 'variant':\n            if (found.variant.length > 1 && found.variant.some(function (variant) {\n              return variant.format() === subtag.format();\n            })) {\n              error(Tag.ERR_DUPLICATE_VARIANT, subtag);\n            }\n        }\n      }, {\n        language: [],\n        extlang: [],\n        variant: [],\n        script: [],\n        region: []\n      });\n\n      // Check for correct order.\n      subtags.forEach(function (subtag, i, subtags) {\n        var priority = this,\n          next = subtags[i + 1];\n        if (next && priority[subtag.type()] > priority[next.type()]) {\n          error(Tag.ERR_WRONG_ORDER, [subtag, next]);\n        }\n      }, {\n        language: 4,\n        extlang: 5,\n        script: 6,\n        region: 7,\n        variant: 8\n      });\n      return errors;\n    }\n  }, {\n    key: \"type\",\n    value: function type() {\n      var record = this.data.record;\n      if (record) {\n        return record.Type;\n      }\n      return 'tag';\n    }\n  }, {\n    key: \"added\",\n    value: function added() {\n      var record = this.data.record;\n      return record && record.Added;\n    }\n  }, {\n    key: \"deprecated\",\n    value: function deprecated() {\n      var record = this.data.record;\n      return record && record.Deprecated;\n    }\n  }, {\n    key: \"descriptions\",\n    value: function descriptions() {\n      var record = this.data.record;\n      if (record && record.Description) {\n        return record.Description;\n      }\n      return [];\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      var tag = this.data.tag;\n\n      // Format according to algorithm defined in RFC 5646 section 2.1.1.\n      return tag.split('-').reduce(function (p, c, i, a) {\n        if (i === 0) {\n          return c;\n        }\n        if (a[i - 1].length === 1) {\n          return p + '-' + c;\n        }\n        switch (c.length) {\n          case 2:\n            return p + '-' + c.toUpperCase();\n          case 4:\n            return p + '-' + c[0].toUpperCase() + c.substr(1);\n        }\n        return p + '-' + c;\n      });\n    }\n  }]);\n  return Tag;\n}();\n_defineProperty(Tag, \"ERR_DEPRECATED\", 1);\n_defineProperty(Tag, \"ERR_NO_LANGUAGE\", 2);\n_defineProperty(Tag, \"ERR_UNKNOWN\", 3);\n_defineProperty(Tag, \"ERR_TOO_LONG\", 4);\n_defineProperty(Tag, \"ERR_EXTRA_REGION\", 5);\n_defineProperty(Tag, \"ERR_EXTRA_EXTLANG\", 6);\n_defineProperty(Tag, \"ERR_EXTRA_SCRIPT\", 7);\n_defineProperty(Tag, \"ERR_DUPLICATE_VARIANT\", 8);\n_defineProperty(Tag, \"ERR_WRONG_ORDER\", 9);\n_defineProperty(Tag, \"ERR_SUPPRESS_SCRIPT\", 10);\n_defineProperty(Tag, \"ERR_SUBTAG_DEPRECATED\", 11);\n_defineProperty(Tag, \"ERR_EXTRA_LANGUAGE\", 12);\nmodule.exports = Tag;"
        }
    ]
}