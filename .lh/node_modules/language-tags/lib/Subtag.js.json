{
    "sourceFile": "node_modules/language-tags/lib/Subtag.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892383523,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @author Matthew Caruana Galizia <mattcg@gmail.com>\n * @license MIT: http://mattcg.mit-license.org/\n * @copyright Copyright (c) 2013, Matthew Caruana Galizia\n */\n\n'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar index = require('language-subtag-registry/data/json/index.json');\nvar registry = require('language-subtag-registry/data/json/registry.json');\nvar Subtag = /*#__PURE__*/function () {\n  /**\n   * @param {string} subtag\n   * @param {string} type\n   */\n  function Subtag(subtag, type) {\n    _classCallCheck(this, Subtag);\n    var types, i, record;\n\n    // Lowercase for consistency (case is only a formatting convention, not a standard requirement).\n    subtag = subtag.toLowerCase();\n    type = type.toLowerCase();\n    function error(code, message) {\n      var err;\n      err = new Error(message);\n      err.code = code;\n      err.subtag = subtag;\n      throw err;\n    }\n    types = index[subtag];\n    if (!types) {\n      error(Subtag.ERR_NONEXISTENT, 'Non-existent subtag \\'' + subtag + '\\'.');\n    }\n    i = types[type];\n    if (!i && 0 !== i) {\n      error(Subtag.ERR_NONEXISTENT, 'Non-existent subtag \\'' + subtag + '\\' of type \\'' + type + '\\'.');\n    }\n    record = registry[i];\n    if (!record.Subtag) {\n      error(Subtag.ERR_TAG, '\\'' + subtag + '\\' is a \\'' + type + '\\' tag.');\n    }\n    this.data = {\n      subtag: subtag,\n      record: record,\n      type: type\n    };\n  }\n  _createClass(Subtag, [{\n    key: \"type\",\n    value: function type() {\n      return this.data.type;\n    }\n  }, {\n    key: \"descriptions\",\n    value: function descriptions() {\n      // Every record has one or more descriptions (stored as an array).\n      return this.data.record.Description;\n    }\n  }, {\n    key: \"preferred\",\n    value: function preferred() {\n      var type,\n        preferred = this.data.record['Preferred-Value'];\n      if (preferred) {\n        type = this.data.type;\n        if (type === 'extlang') {\n          type = 'language';\n        }\n        return new Subtag(preferred, type);\n      }\n      return null;\n    }\n  }, {\n    key: \"script\",\n    value: function script() {\n      var script = this.data.record['Suppress-Script'];\n      if (script) {\n        return new Subtag(script, 'script');\n      }\n      return null;\n    }\n  }, {\n    key: \"scope\",\n    value: function scope() {\n      return this.data.record.Scope || null;\n    }\n  }, {\n    key: \"deprecated\",\n    value: function deprecated() {\n      return this.data.record.Deprecated || null;\n    }\n  }, {\n    key: \"added\",\n    value: function added() {\n      return this.data.record.Added;\n    }\n  }, {\n    key: \"comments\",\n    value: function comments() {\n      // Comments don't always occur for records, so switch to an empty array if missing.\n      return this.data.record.Comments || [];\n    }\n  }, {\n    key: \"format\",\n    value: function format() {\n      var subtag = this.data.subtag;\n      switch (this.data.type) {\n        case 'region':\n          return subtag.toUpperCase();\n        case 'script':\n          return subtag[0].toUpperCase() + subtag.slice(1);\n      }\n      return subtag;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.format();\n    }\n  }]);\n  return Subtag;\n}();\n_defineProperty(Subtag, \"ERR_NONEXISTENT\", 1);\n_defineProperty(Subtag, \"ERR_TAG\", 2);\nmodule.exports = Subtag;"
        }
    ]
}