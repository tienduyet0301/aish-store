{
    "sourceFile": "node_modules/next-auth/src/react/index.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892936172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Note about signIn() and signOut() methods:\n//\n// On signIn() and signOut() we pass 'json: true' to request a response in JSON\n// instead of HTTP as redirect URLs on other domains are not returned to\n// requests made using the fetch API in the browser, and we need to ask the API\n// to return the response as a JSON object (the end point still defaults to\n// returning an HTTP response with a redirect for non-JavaScript clients).\n//\n// We use HTTP POST requests with CSRF Tokens to protect against CSRF attacks.\n\nimport * as React from \"react\"\nimport _logger, { proxyLogger } from \"../utils/logger\"\nimport parseUrl from \"../utils/parse-url\"\nimport { Session } from \"..\"\nimport {\n  BroadcastChannel,\n  CtxOrReq,\n  apiBaseUrl,\n  fetchData,\n  now,\n  AuthClientConfig,\n} from \"../client/_utils\"\n\nimport type {\n  ClientSafeProvider,\n  LiteralUnion,\n  SessionProviderProps,\n  SignInAuthorizationParams,\n  SignInOptions,\n  SignInResponse,\n  SignOutParams,\n  SignOutResponse,\n  UseSessionOptions,\n} from \"./types\"\n\nimport type {\n  BuiltInProviderType,\n  RedirectableProviderType,\n} from \"../providers\"\n\nexport * from \"./types\"\n\n// This behaviour mirrors the default behaviour for getting the site name that\n// happens server side in server/index.js\n// 1. An empty value is legitimate when the code is being invoked client side as\n//    relative URLs are valid in that context and so defaults to empty.\n// 2. When invoked server side the value is picked up from an environment\n//    variable and defaults to 'http://localhost:3000'.\nconst __NEXTAUTH: AuthClientConfig = {\n  baseUrl: parseUrl(process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n  basePath: parseUrl(process.env.NEXTAUTH_URL).path,\n  baseUrlServer: parseUrl(\n    process.env.NEXTAUTH_URL_INTERNAL ??\n      process.env.NEXTAUTH_URL ??\n      process.env.VERCEL_URL\n  ).origin,\n  basePathServer: parseUrl(\n    process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL\n  ).path,\n  _lastSync: 0,\n  _session: undefined,\n  _getSession: () => {},\n}\n\nconst broadcast = BroadcastChannel()\n\nconst logger = proxyLogger(_logger, __NEXTAUTH.basePath)\n\nfunction useOnline() {\n  const [isOnline, setIsOnline] = React.useState(\n    typeof navigator !== \"undefined\" ? navigator.onLine : false\n  )\n\n  const setOnline = () => setIsOnline(true)\n  const setOffline = () => setIsOnline(false)\n\n  React.useEffect(() => {\n    window.addEventListener(\"online\", setOnline)\n    window.addEventListener(\"offline\", setOffline)\n\n    return () => {\n      window.removeEventListener(\"online\", setOnline)\n      window.removeEventListener(\"offline\", setOffline)\n    }\n  }, [])\n\n  return isOnline\n}\n\ntype UpdateSession = (data?: any) => Promise<Session | null>\n\nexport type SessionContextValue<R extends boolean = false> = R extends true\n  ?\n      | { update: UpdateSession; data: Session; status: \"authenticated\" }\n      | { update: UpdateSession; data: null; status: \"loading\" }\n  :\n      | { update: UpdateSession; data: Session; status: \"authenticated\" }\n      | {\n          update: UpdateSession\n          data: null\n          status: \"unauthenticated\" | \"loading\"\n        }\n\nexport const SessionContext = React.createContext?.<\n  SessionContextValue | undefined\n>(undefined)\n\n/**\n * React Hook that gives you access\n * to the logged in user's session data.\n *\n * [Documentation](https://next-auth.js.org/getting-started/client#usesession)\n */\nexport function useSession<R extends boolean>(\n  options?: UseSessionOptions<R>\n): SessionContextValue<R> {\n  if (!SessionContext) {\n    throw new Error(\"React Context is unavailable in Server Components\")\n  }\n\n  // @ts-expect-error Satisfy TS if branch on line below\n  const value: SessionContextValue<R> = React.useContext(SessionContext)\n  if (!value && process.env.NODE_ENV !== \"production\") {\n    throw new Error(\n      \"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\"\n    )\n  }\n\n  const { required, onUnauthenticated } = options ?? {}\n\n  const requiredAndNotLoading = required && value.status === \"unauthenticated\"\n\n  React.useEffect(() => {\n    if (requiredAndNotLoading) {\n      const url = `/api/auth/signin?${new URLSearchParams({\n        error: \"SessionRequired\",\n        callbackUrl: window.location.href,\n      })}`\n      if (onUnauthenticated) onUnauthenticated()\n      else window.location.href = url\n    }\n  }, [requiredAndNotLoading, onUnauthenticated])\n\n  if (requiredAndNotLoading) {\n    return {\n      data: value.data,\n      update: value.update,\n      status: \"loading\",\n    }\n  }\n\n  return value\n}\n\nexport type GetSessionParams = CtxOrReq & {\n  event?: \"storage\" | \"timer\" | \"hidden\" | string\n  triggerEvent?: boolean\n  broadcast?: boolean\n}\n\nexport async function getSession(params?: GetSessionParams) {\n  const session = await fetchData<Session>(\n    \"session\",\n    __NEXTAUTH,\n    logger,\n    params\n  )\n  if (params?.broadcast ?? true) {\n    broadcast.post({ event: \"session\", data: { trigger: \"getSession\" } })\n  }\n  return session\n}\n\n/**\n * Returns the current Cross Site Request Forgery Token (CSRF Token)\n * required to make POST requests (e.g. for signing in and signing out).\n * You likely only need to use this if you are not using the built-in\n * `signIn()` and `signOut()` methods.\n *\n * [Documentation](https://next-auth.js.org/getting-started/client#getcsrftoken)\n */\nexport async function getCsrfToken(params?: CtxOrReq) {\n  const response = await fetchData<{ csrfToken: string }>(\n    \"csrf\",\n    __NEXTAUTH,\n    logger,\n    params\n  )\n  return response?.csrfToken\n}\n\n/**\n * It calls `/api/auth/providers` and returns\n * a list of the currently configured authentication providers.\n * It can be useful if you are creating a dynamic custom sign in page.\n *\n * [Documentation](https://next-auth.js.org/getting-started/client#getproviders)\n */\nexport async function getProviders() {\n  return await fetchData<\n    Record<LiteralUnion<BuiltInProviderType>, ClientSafeProvider>\n  >(\"providers\", __NEXTAUTH, logger)\n}\n\n/**\n * Client-side method to initiate a signin flow\n * or send the user to the signin page listing all possible providers.\n * Automatically adds the CSRF token to the request.\n *\n * [Documentation](https://next-auth.js.org/getting-started/client#signin)\n */\nexport async function signIn<\n  P extends RedirectableProviderType | undefined = undefined\n>(\n  provider?: LiteralUnion<\n    P extends RedirectableProviderType\n      ? P | BuiltInProviderType\n      : BuiltInProviderType\n  >,\n  options?: SignInOptions,\n  authorizationParams?: SignInAuthorizationParams\n): Promise<\n  P extends RedirectableProviderType ? SignInResponse | undefined : undefined\n> {\n  const { callbackUrl = window.location.href, redirect = true } = options ?? {}\n\n  const baseUrl = apiBaseUrl(__NEXTAUTH)\n  const providers = await getProviders()\n\n  if (!providers) {\n    window.location.href = `${baseUrl}/error`\n    return\n  }\n\n  if (!provider || !(provider in providers)) {\n    window.location.href = `${baseUrl}/signin?${new URLSearchParams({\n      callbackUrl,\n    })}`\n    return\n  }\n\n  const isCredentials = providers[provider].type === \"credentials\"\n  const isEmail = providers[provider].type === \"email\"\n  const isSupportingReturn = isCredentials || isEmail\n\n  const signInUrl = `${baseUrl}/${\n    isCredentials ? \"callback\" : \"signin\"\n  }/${provider}`\n\n  const _signInUrl = `${signInUrl}${authorizationParams ? `?${new URLSearchParams(authorizationParams)}` : \"\"}`\n\n  const res = await fetch(_signInUrl, {\n    method: \"post\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    // @ts-expect-error\n    body: new URLSearchParams({\n      ...options,\n      csrfToken: await getCsrfToken(),\n      callbackUrl,\n      json: true,\n    }),\n  })\n\n  const data = await res.json()\n\n  // TODO: Do not redirect for Credentials and Email providers by default in next major\n  if (redirect || !isSupportingReturn) {\n    const url = data.url ?? callbackUrl\n    window.location.href = url\n    // If url contains a hash, the browser does not reload the page. We reload manually\n    if (url.includes(\"#\")) window.location.reload()\n    return\n  }\n\n  const error = new URL(data.url).searchParams.get(\"error\")\n\n  if (res.ok) {\n    await __NEXTAUTH._getSession({ event: \"storage\" })\n  }\n\n  return {\n    error,\n    status: res.status,\n    ok: res.ok,\n    url: error ? null : data.url,\n  } as any\n}\n\n/**\n * Signs the user out, by removing the session cookie.\n * Automatically adds the CSRF token to the request.\n *\n * [Documentation](https://next-auth.js.org/getting-started/client#signout)\n */\nexport async function signOut<R extends boolean = true>(\n  options?: SignOutParams<R>\n): Promise<R extends true ? undefined : SignOutResponse> {\n  const { callbackUrl = window.location.href } = options ?? {}\n  const baseUrl = apiBaseUrl(__NEXTAUTH)\n  const fetchOptions = {\n    method: \"post\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    // @ts-expect-error\n    body: new URLSearchParams({\n      csrfToken: await getCsrfToken(),\n      callbackUrl,\n      json: true,\n    }),\n  }\n  const res = await fetch(`${baseUrl}/signout`, fetchOptions)\n  const data = await res.json()\n\n  broadcast.post({ event: \"session\", data: { trigger: \"signout\" } })\n\n  if (options?.redirect ?? true) {\n    const url = data.url ?? callbackUrl\n    window.location.href = url\n    // If url contains a hash, the browser does not reload the page. We reload manually\n    if (url.includes(\"#\")) window.location.reload()\n    // @ts-expect-error\n    return\n  }\n\n  await __NEXTAUTH._getSession({ event: \"storage\" })\n\n  return data\n}\n\n/**\n * Provider to wrap the app in to make session data available globally.\n * Can also be used to throttle the number of requests to the endpoint\n * `/api/auth/session`.\n *\n * [Documentation](https://next-auth.js.org/getting-started/client#sessionprovider)\n */\nexport function SessionProvider(props: SessionProviderProps) {\n  if (!SessionContext) {\n    throw new Error(\"React Context is unavailable in Server Components\")\n  }\n\n  const { children, basePath, refetchInterval, refetchWhenOffline } = props\n\n  if (basePath) __NEXTAUTH.basePath = basePath\n\n  /**\n   * If session was `null`, there was an attempt to fetch it,\n   * but it failed, but we still treat it as a valid initial value.\n   */\n  const hasInitialSession = props.session !== undefined\n\n  /** If session was passed, initialize as already synced */\n  __NEXTAUTH._lastSync = hasInitialSession ? now() : 0\n\n  const [session, setSession] = React.useState(() => {\n    if (hasInitialSession) __NEXTAUTH._session = props.session\n    return props.session\n  })\n\n  /** If session was passed, initialize as not loading */\n  const [loading, setLoading] = React.useState(!hasInitialSession)\n\n  React.useEffect(() => {\n    __NEXTAUTH._getSession = async ({ event } = {}) => {\n      try {\n        const storageEvent = event === \"storage\"\n        // We should always update if we don't have a client session yet\n        // or if there are events from other tabs/windows\n        if (storageEvent || __NEXTAUTH._session === undefined) {\n          __NEXTAUTH._lastSync = now()\n          __NEXTAUTH._session = await getSession({\n            broadcast: !storageEvent,\n          })\n          setSession(__NEXTAUTH._session)\n          return\n        }\n\n        if (\n          // If there is no time defined for when a session should be considered\n          // stale, then it's okay to use the value we have until an event is\n          // triggered which updates it\n          !event ||\n          // If the client doesn't have a session then we don't need to call\n          // the server to check if it does (if they have signed in via another\n          // tab or window that will come through as a \"stroage\" event\n          // event anyway)\n          __NEXTAUTH._session === null ||\n          // Bail out early if the client session is not stale yet\n          now() < __NEXTAUTH._lastSync\n        ) {\n          return\n        }\n\n        // An event or session staleness occurred, update the client session.\n        __NEXTAUTH._lastSync = now()\n        __NEXTAUTH._session = await getSession()\n        setSession(__NEXTAUTH._session)\n      } catch (error) {\n        logger.error(\"CLIENT_SESSION_ERROR\", error as Error)\n      } finally {\n        setLoading(false)\n      }\n    }\n\n    __NEXTAUTH._getSession()\n\n    return () => {\n      __NEXTAUTH._lastSync = 0\n      __NEXTAUTH._session = undefined\n      __NEXTAUTH._getSession = () => {}\n    }\n  }, [])\n\n  React.useEffect(() => {\n    // Listen for storage events and update session if event fired from\n    // another window (but suppress firing another event to avoid a loop)\n    // Fetch new session data but tell it to not to fire another event to\n    // avoid an infinite loop.\n    // Note: We could pass session data through and do something like\n    // `setData(message.data)` but that can cause problems depending\n    // on how the session object is being used in the client; it is\n    // more robust to have each window/tab fetch it's own copy of the\n    // session object rather than share it across instances.\n    const unsubscribe = broadcast.receive(() =>\n      __NEXTAUTH._getSession({ event: \"storage\" })\n    )\n\n    return () => unsubscribe()\n  }, [])\n\n  React.useEffect(() => {\n    const { refetchOnWindowFocus = true } = props\n    // Listen for when the page is visible, if the user switches tabs\n    // and makes our tab visible again, re-fetch the session, but only if\n    // this feature is not disabled.\n    const visibilityHandler = () => {\n      if (refetchOnWindowFocus && document.visibilityState === \"visible\")\n        __NEXTAUTH._getSession({ event: \"visibilitychange\" })\n    }\n    document.addEventListener(\"visibilitychange\", visibilityHandler, false)\n    return () =>\n      document.removeEventListener(\"visibilitychange\", visibilityHandler, false)\n  }, [props.refetchOnWindowFocus])\n\n  const isOnline = useOnline()\n  // TODO: Flip this behavior in next major version\n  const shouldRefetch = refetchWhenOffline !== false || isOnline\n\n  React.useEffect(() => {\n    if (refetchInterval && shouldRefetch) {\n      const refetchIntervalTimer = setInterval(() => {\n        if (__NEXTAUTH._session) {\n          __NEXTAUTH._getSession({ event: \"poll\" })\n        }\n      }, refetchInterval * 1000)\n      return () => clearInterval(refetchIntervalTimer)\n    }\n  }, [refetchInterval, shouldRefetch])\n\n  const value: any = React.useMemo(\n    () => ({\n      data: session,\n      status: loading\n        ? \"loading\"\n        : session\n        ? \"authenticated\"\n        : \"unauthenticated\",\n      async update(data) {\n        if (loading || !session) return\n        setLoading(true)\n        const newSession = await fetchData<Session>(\n          \"session\",\n          __NEXTAUTH,\n          logger,\n          { req: { body: { csrfToken: await getCsrfToken(), data } } }\n        )\n        setLoading(false)\n        if (newSession) {\n          setSession(newSession)\n          broadcast.post({ event: \"session\", data: { trigger: \"getSession\" } })\n        }\n        return newSession\n      },\n    }),\n    [session, loading]\n  )\n\n  return (\n    <SessionContext.Provider value={value}>{children}</SessionContext.Provider>\n  )\n}\n"
        }
    ]
}