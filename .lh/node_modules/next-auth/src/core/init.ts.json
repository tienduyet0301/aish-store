{
    "sourceFile": "node_modules/next-auth/src/core/init.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { randomBytes, randomUUID } from \"crypto\"\nimport { AuthOptions } from \"..\"\nimport logger from \"../utils/logger\"\nimport { adapterErrorHandler, eventsErrorHandler } from \"./errors\"\nimport parseProviders from \"./lib/providers\"\nimport { createSecret } from \"./lib/utils\"\nimport * as cookie from \"./lib/cookie\"\nimport * as jwt from \"../jwt\"\nimport { defaultCallbacks } from \"./lib/default-callbacks\"\nimport { createCSRFToken } from \"./lib/csrf-token\"\nimport { createCallbackUrl } from \"./lib/callback-url\"\nimport { RequestInternal } from \".\"\n\nimport type { InternalOptions } from \"./types\"\nimport parseUrl from \"../utils/parse-url\"\n\ninterface InitParams {\n  origin?: string\n  authOptions: AuthOptions\n  providerId?: string\n  action: InternalOptions[\"action\"]\n  /** Callback URL value extracted from the incoming request. */\n  callbackUrl?: string\n  /** CSRF token value extracted from the incoming request. From body if POST, from query if GET */\n  csrfToken?: string\n  /** Is the incoming request a POST request? */\n  isPost: boolean\n  cookies: RequestInternal[\"cookies\"]\n}\n\n/** Initialize all internal options and cookies. */\nexport async function init({\n  authOptions,\n  providerId,\n  action,\n  origin,\n  cookies: reqCookies,\n  callbackUrl: reqCallbackUrl,\n  csrfToken: reqCsrfToken,\n  isPost,\n}: InitParams): Promise<{\n  options: InternalOptions\n  cookies: cookie.Cookie[]\n}> {\n  const url = parseUrl(origin)\n\n  const secret = createSecret({ authOptions, url })\n\n  const { providers, provider } = parseProviders({\n    providers: authOptions.providers,\n    url,\n    providerId,\n  })\n\n  const maxAge = 30 * 24 * 60 * 60 // Sessions expire after 30 days of being idle by default\n\n  // User provided options are overriden by other options,\n  // except for the options with special handling above\n  const options: InternalOptions = {\n    debug: false,\n    pages: {},\n    theme: {\n      colorScheme: \"auto\",\n      logo: \"\",\n      brandColor: \"\",\n      buttonText: \"\",\n    },\n    // Custom options override defaults\n    ...authOptions,\n    // These computed settings can have values in authOptions but we override them\n    // and are request-specific.\n    url,\n    action,\n    // @ts-expect-errors\n    provider,\n    cookies: {\n      ...cookie.defaultCookies(\n        authOptions.useSecureCookies ?? url.base.startsWith(\"https://\")\n      ),\n      // Allow user cookie options to override any cookie settings above\n      ...authOptions.cookies,\n    },\n    secret,\n    providers,\n    // Session options\n    session: {\n      // If no adapter specified, force use of JSON Web Tokens (stateless)\n      strategy: authOptions.adapter ? \"database\" : \"jwt\",\n      maxAge,\n      updateAge: 24 * 60 * 60,\n      generateSessionToken: () => {\n        // Use `randomUUID` if available. (Node 15.6+)\n        return randomUUID?.() ?? randomBytes(32).toString(\"hex\")\n      },\n      ...authOptions.session,\n    },\n    // JWT options\n    jwt: {\n      secret, // Use application secret if no keys specified\n      maxAge, // same as session maxAge,\n      encode: jwt.encode,\n      decode: jwt.decode,\n      ...authOptions.jwt,\n    },\n    // Event messages\n    events: eventsErrorHandler(authOptions.events ?? {}, logger),\n    adapter: adapterErrorHandler(authOptions.adapter, logger),\n    // Callback functions\n    callbacks: { ...defaultCallbacks, ...authOptions.callbacks },\n    logger,\n    callbackUrl: url.origin,\n  }\n\n  // Init cookies\n\n  const cookies: cookie.Cookie[] = []\n\n  const {\n    csrfToken,\n    cookie: csrfCookie,\n    csrfTokenVerified,\n  } = createCSRFToken({\n    options,\n    cookieValue: reqCookies?.[options.cookies.csrfToken.name],\n    isPost,\n    bodyValue: reqCsrfToken,\n  })\n\n  options.csrfToken = csrfToken\n  options.csrfTokenVerified = csrfTokenVerified\n\n  if (csrfCookie) {\n    cookies.push({\n      name: options.cookies.csrfToken.name,\n      value: csrfCookie,\n      options: options.cookies.csrfToken.options,\n    })\n  }\n\n  const { callbackUrl, callbackUrlCookie } = await createCallbackUrl({\n    options,\n    cookieValue: reqCookies?.[options.cookies.callbackUrl.name],\n    paramValue: reqCallbackUrl,\n  })\n  options.callbackUrl = callbackUrl\n  if (callbackUrlCookie) {\n    cookies.push({\n      name: options.cookies.callbackUrl.name,\n      value: callbackUrlCookie,\n      options: options.cookies.callbackUrl.options,\n    })\n  }\n\n  return { options, cookies }\n}\n"
        }
    ]
}