{
    "sourceFile": "node_modules/next-auth/src/core/lib/providers.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892933268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { merge } from \"../../utils/merge\"\n\nimport type { InternalProvider, OAuthConfigInternal } from \"../types\"\nimport type { OAuthConfig, Provider } from \"../../providers\"\nimport type { InternalUrl } from \"../../utils/parse-url\"\n\n/**\n * Adds `signinUrl` and `callbackUrl` to each provider\n * and deep merge user-defined options.\n */\nexport default function parseProviders(params: {\n  providers: Provider[]\n  url: InternalUrl\n  providerId?: string\n}): {\n  providers: InternalProvider[]\n  provider?: InternalProvider\n} {\n  const { url, providerId } = params\n\n  const providers = params.providers.map<InternalProvider>(\n    ({ options: userOptions, ...rest }) => {\n      if (rest.type === \"oauth\") {\n        const normalizedOptions = normalizeOAuthOptions(rest)\n        const normalizedUserOptions = normalizeOAuthOptions(userOptions, true)\n        const id = normalizedUserOptions?.id ?? rest.id\n        return merge(normalizedOptions, {\n          ...normalizedUserOptions,\n          signinUrl: `${url}/signin/${id}`,\n          callbackUrl: `${url}/callback/${id}`,\n        })\n      }\n      const id = (userOptions?.id as string) ?? rest.id\n      return merge(rest, {\n        ...userOptions,\n        signinUrl: `${url}/signin/${id}`,\n        callbackUrl: `${url}/callback/${id}`,\n      })\n    }\n  )\n\n  return {\n    providers,\n    provider: providers.find(({ id }) => id === providerId),\n  }\n}\n\n/**\n * Transform OAuth options `authorization`, `token` and `profile` strings to `{ url: string; params: Record<string, string> }`\n */\nfunction normalizeOAuthOptions(\n  oauthOptions?: Partial<OAuthConfig<any>> | Record<string, unknown>,\n  isUserOptions = false\n) {\n  if (!oauthOptions) return\n\n  const normalized = Object.entries(oauthOptions).reduce<\n    OAuthConfigInternal<Record<string, unknown>>\n  >(\n    (acc, [key, value]) => {\n      if (\n        [\"authorization\", \"token\", \"userinfo\"].includes(key) &&\n        typeof value === \"string\"\n      ) {\n        const url = new URL(value)\n        acc[key] = {\n          url: `${url.origin}${url.pathname}`,\n          params: Object.fromEntries(url.searchParams ?? []),\n        }\n      } else {\n        acc[key] = value\n      }\n\n      return acc\n    },\n    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n    {} as any\n  )\n\n  if (!isUserOptions && !normalized.version?.startsWith(\"1.\")) {\n    // If provider has as an \"openid-configuration\" well-known endpoint\n    // or an \"openid\" scope request, it will also likely be able to receive an `id_token`\n    // Only do this if this function is not called with user options to avoid overriding in later stage.\n    normalized.idToken = Boolean(\n      normalized.idToken ??\n        normalized.wellKnown?.includes(\"openid-configuration\") ??\n        normalized.authorization?.params?.scope?.includes(\"openid\")\n    )\n\n    if (!normalized.checks) normalized.checks = [\"state\"]\n  }\n  return normalized\n}\n"
        }
    ]
}