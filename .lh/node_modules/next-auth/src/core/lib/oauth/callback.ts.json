{
    "sourceFile": "node_modules/next-auth/src/core/lib/oauth/callback.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892933129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { TokenSet } from \"openid-client\"\nimport { openidClient } from \"./client\"\nimport { oAuth1Client, oAuth1TokenStore } from \"./client-legacy\"\nimport * as _checks from \"./checks\"\nimport { OAuthCallbackError } from \"../../errors\"\n\nimport type { CallbackParamsType } from \"openid-client\"\nimport type { LoggerInstance, Profile } from \"../../..\"\nimport type { OAuthChecks, OAuthConfig } from \"../../../providers\"\nimport type { InternalOptions } from \"../../types\"\nimport type { RequestInternal } from \"../..\"\nimport type { Cookie } from \"../cookie\"\n\nexport default async function oAuthCallback(params: {\n  options: InternalOptions<\"oauth\">\n  query: RequestInternal[\"query\"]\n  body: RequestInternal[\"body\"]\n  method: Required<RequestInternal>[\"method\"]\n  cookies: RequestInternal[\"cookies\"]\n}) {\n  const { options, query, body, method, cookies } = params\n  const { logger, provider } = options\n\n  const errorMessage = body?.error ?? query?.error\n  if (errorMessage) {\n    const error = new Error(errorMessage)\n    logger.error(\"OAUTH_CALLBACK_HANDLER_ERROR\", {\n      error,\n      error_description: query?.error_description,\n      providerId: provider.id,\n    })\n    logger.debug(\"OAUTH_CALLBACK_HANDLER_ERROR\", { body })\n    throw error\n  }\n\n  if (provider.version?.startsWith(\"1.\")) {\n    try {\n      const client = await oAuth1Client(options)\n      // Handle OAuth v1.x\n      const { oauth_token, oauth_verifier } = query ?? {}\n      const tokens = (await (client as any).getOAuthAccessToken(\n        oauth_token,\n        oAuth1TokenStore.get(oauth_token),\n        oauth_verifier\n      )) as TokenSet\n      let profile: Profile = await (client as any).get(\n        provider.profileUrl,\n        tokens.oauth_token,\n        tokens.oauth_token_secret\n      )\n\n      if (typeof profile === \"string\") {\n        profile = JSON.parse(profile)\n      }\n\n      const newProfile = await getProfile({ profile, tokens, provider, logger })\n      return { ...newProfile, cookies: [] }\n    } catch (error) {\n      logger.error(\"OAUTH_V1_GET_ACCESS_TOKEN_ERROR\", error as Error)\n      throw error\n    }\n  }\n\n  if (query?.oauth_token) oAuth1TokenStore.delete(query.oauth_token)\n\n  try {\n    const client = await openidClient(options)\n\n    let tokens: TokenSet\n\n    const checks: OAuthChecks = {}\n    const resCookies: Cookie[] = []\n\n    await _checks.state.use(cookies, resCookies, options, checks)\n    await _checks.pkce.use(cookies, resCookies, options, checks)\n    await _checks.nonce.use(cookies, resCookies, options, checks)\n\n    const params: CallbackParamsType = {\n      ...client.callbackParams({\n        url: `http://n?${new URLSearchParams(query)}`,\n        // TODO: Ask to allow object to be passed upstream:\n        // https://github.com/panva/node-openid-client/blob/3ae206dfc78c02134aa87a07f693052c637cab84/types/index.d.ts#L439\n        // @ts-expect-error\n        body,\n        method,\n      }),\n      ...provider.token?.params,\n    }\n\n    if (provider.token?.request) {\n      const response = await provider.token.request({\n        provider,\n        params,\n        checks,\n        client,\n      })\n      tokens = new TokenSet(response.tokens)\n    } else if (provider.idToken) {\n      tokens = await client.callback(provider.callbackUrl, params, checks)\n    } else {\n      tokens = await client.oauthCallback(provider.callbackUrl, params, checks)\n    }\n\n    // REVIEW: How can scope be returned as an array?\n    if (Array.isArray(tokens.scope)) {\n      tokens.scope = tokens.scope.join(\" \")\n    }\n\n    let profile: Profile\n    if (provider.userinfo?.request) {\n      profile = await provider.userinfo.request({\n        provider,\n        tokens,\n        client,\n      })\n    } else if (provider.idToken) {\n      profile = tokens.claims()\n    } else {\n      profile = await client.userinfo(tokens, {\n        params: provider.userinfo?.params,\n      })\n    }\n\n    const profileResult = await getProfile({\n      profile,\n      provider,\n      tokens,\n      logger,\n    })\n    return { ...profileResult, cookies: resCookies }\n  } catch (error) {\n    throw new OAuthCallbackError(error as Error)\n  }\n}\n\nexport interface GetProfileParams {\n  profile: Profile\n  tokens: TokenSet\n  provider: OAuthConfig<any>\n  logger: LoggerInstance\n}\n\n/** Returns profile, raw profile and auth provider details */\nasync function getProfile({\n  profile: OAuthProfile,\n  tokens,\n  provider,\n  logger,\n}: GetProfileParams) {\n  try {\n    logger.debug(\"PROFILE_DATA\", { OAuthProfile })\n    const profile = await provider.profile(OAuthProfile, tokens)\n    profile.email = profile.email?.toLowerCase()\n    if (!profile.id)\n      throw new TypeError(\n        `Profile id is missing in ${provider.name} OAuth profile response`\n      )\n\n    // Return profile, raw profile and auth provider details\n    return {\n      profile,\n      account: {\n        provider: provider.id,\n        type: provider.type,\n        providerAccountId: profile.id.toString(),\n        ...tokens,\n      },\n      OAuthProfile,\n    }\n  } catch (error) {\n    // If we didn't get a response either there was a problem with the provider\n    // response *or* the user cancelled the action with the provider.\n    //\n    // Unfortuately, we can't tell which - at least not in a way that works for\n    // all providers, so we return an empty object; the user should then be\n    // redirected back to the sign up page. We log the error to help developers\n    // who might be trying to debug this when configuring a new provider.\n    logger.error(\"OAUTH_PARSE_PROFILE_ERROR\", {\n      error: error as Error,\n      OAuthProfile,\n    })\n  }\n}\n"
        }
    ]
}