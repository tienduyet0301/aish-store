{
    "sourceFile": "node_modules/next-auth/src/core/lib/oauth/checks.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892933166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import {\n  AuthorizationParameters,\n  generators,\n  OpenIDCallbackChecks,\n} from \"openid-client\"\nimport * as jwt from \"../../../jwt\"\n\nimport type { RequestInternal } from \"../..\"\nimport type { OAuthChecks } from \"../../../providers\"\nimport type { CookiesOptions, InternalOptions } from \"../../types\"\nimport type { Cookie } from \"../cookie\"\n\n/** Returns a signed cookie. */\nexport async function signCookie(\n  type: keyof CookiesOptions,\n  value: string,\n  maxAge: number,\n  options: InternalOptions<\"oauth\">\n): Promise<Cookie> {\n  const { cookies, logger } = options\n\n  logger.debug(`CREATE_${type.toUpperCase()}`, { value, maxAge })\n\n  const { name } = cookies[type]\n  const expires = new Date()\n  expires.setTime(expires.getTime() + maxAge * 1000)\n  return {\n    name,\n    value: await jwt.encode({\n      ...options.jwt,\n      maxAge,\n      token: { value },\n      salt: name,\n    }),\n    options: { ...cookies[type].options, expires },\n  }\n}\n\nconst PKCE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const PKCE_CODE_CHALLENGE_METHOD = \"S256\"\nexport const pkce = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider?.checks?.includes(\"pkce\")) return\n    const code_verifier = generators.codeVerifier()\n    const value = generators.codeChallenge(code_verifier)\n    resParams.code_challenge = value\n    resParams.code_challenge_method = PKCE_CODE_CHALLENGE_METHOD\n\n    const maxAge =\n      options.cookies.pkceCodeVerifier.options.maxAge ?? PKCE_MAX_AGE\n\n    cookies.push(\n      await signCookie(\"pkceCodeVerifier\", code_verifier, maxAge, options)\n    )\n  },\n  /**\n   * Returns code_verifier if the provider is configured to use PKCE,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the code_verifier is missing or invalid.\n   * @see https://www.rfc-editor.org/rfc/rfc7636\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#pkce\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OAuthChecks\n  ): Promise<string | undefined> {\n    if (!options.provider?.checks?.includes(\"pkce\")) return\n\n    const codeVerifier = cookies?.[options.cookies.pkceCodeVerifier.name]\n\n    if (!codeVerifier)\n      throw new TypeError(\"PKCE code_verifier cookie was missing.\")\n\n    const { name } = options.cookies.pkceCodeVerifier\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: codeVerifier,\n      salt: name,\n    })) as any\n\n    if (!value?.value)\n      throw new TypeError(\"PKCE code_verifier value could not be parsed.\")\n\n    resCookies.push({\n      name,\n      value: \"\",\n      options: { ...options.cookies.pkceCodeVerifier.options, maxAge: 0 },\n    })\n\n    checks.code_verifier = value.value\n  },\n}\n\nconst STATE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const state = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider.checks?.includes(\"state\")) return\n    const value = generators.state()\n    resParams.state = value\n    const maxAge = options.cookies.state.options.maxAge ?? STATE_MAX_AGE\n    cookies.push(await signCookie(\"state\", value, maxAge, options))\n  },\n  /**\n   * Returns state if the provider is configured to use state,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the state is missing or invalid.\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-10.12\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.1\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OAuthChecks\n  ) {\n    if (!options.provider.checks?.includes(\"state\")) return\n\n    const state = cookies?.[options.cookies.state.name]\n\n    if (!state) throw new TypeError(\"State cookie was missing.\")\n\n    const { name } = options.cookies.state\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: state,\n      salt: name,\n    })) as any\n\n    if (!value?.value) throw new TypeError(\"State value could not be parsed.\")\n\n    resCookies.push({\n      name,\n      value: \"\",\n      options: { ...options.cookies.state.options, maxAge: 0 },\n    })\n\n    checks.state = value.value\n  },\n}\n\nconst NONCE_MAX_AGE = 60 * 15 // 15 minutes in seconds\nexport const nonce = {\n  async create(\n    options: InternalOptions<\"oauth\">,\n    cookies: Cookie[],\n    resParams: AuthorizationParameters\n  ) {\n    if (!options.provider.checks?.includes(\"nonce\")) return\n    const value = generators.nonce()\n    resParams.nonce = value\n    const maxAge = options.cookies.nonce.options.maxAge ?? NONCE_MAX_AGE\n    cookies.push(await signCookie(\"nonce\", value, maxAge, options))\n  },\n  /**\n   * Returns nonce if the provider is configured to use nonce,\n   * and clears the container cookie afterwards.\n   * An error is thrown if the nonce is missing or invalid.\n   * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n   * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce\n   */\n  async use(\n    cookies: RequestInternal[\"cookies\"],\n    resCookies: Cookie[],\n    options: InternalOptions<\"oauth\">,\n    checks: OpenIDCallbackChecks\n  ): Promise<string | undefined> {\n    if (!options.provider?.checks?.includes(\"nonce\")) return\n\n    const nonce = cookies?.[options.cookies.nonce.name]\n    if (!nonce) throw new TypeError(\"Nonce cookie was missing.\")\n\n    const { name } = options.cookies.nonce\n    const value = (await jwt.decode({\n      ...options.jwt,\n      token: nonce,\n      salt: name,\n    })) as any\n\n    if (!value?.value) throw new TypeError(\"Nonce value could not be parsed.\")\n\n    resCookies.push({\n      name,\n      value: \"\",\n      options: { ...options.cookies.nonce.options, maxAge: 0 },\n    })\n\n    checks.nonce = value.value\n  },\n}\n"
        }
    ]
}