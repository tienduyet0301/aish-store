{
    "sourceFile": "node_modules/next-auth/src/core/lib/cookie.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { CookiesOptions } from \"../..\"\nimport type { CookieOption, LoggerInstance, SessionStrategy } from \"../types\"\nimport type { NextRequest } from \"next/server\"\nimport type { NextApiRequest } from \"next\"\n\n// Uncomment to recalculate the estimated size\n// of an empty session cookie\n// import { serialize } from \"cookie\"\n// console.log(\n//   \"Cookie estimated to be \",\n//   serialize(`__Secure.next-auth.session-token.0`, \"\", {\n//     expires: new Date(),\n//     httpOnly: true,\n//     maxAge: Number.MAX_SAFE_INTEGER,\n//     path: \"/\",\n//     sameSite: \"strict\",\n//     secure: true,\n//     domain: \"example.com\",\n//   }).length,\n//   \" bytes\"\n// )\n\nconst ALLOWED_COOKIE_SIZE = 4096\n// Based on commented out section above\nconst ESTIMATED_EMPTY_COOKIE_SIZE = 163\nconst CHUNK_SIZE = ALLOWED_COOKIE_SIZE - ESTIMATED_EMPTY_COOKIE_SIZE\n\n// REVIEW: Is there any way to defer two types of strings?\n\n/** Stringified form of `JWT`. Extract the content with `jwt.decode` */\nexport type JWTString = string\n\nexport type SetCookieOptions = Partial<CookieOption[\"options\"]> & {\n  expires?: Date | string\n  encode?: (val: unknown) => string\n}\n\n/**\n * If `options.session.strategy` is set to `jwt`, this is a stringified `JWT`.\n * In case of `strategy: \"database\"`, this is the `sessionToken` of the session in the database.\n */\nexport type SessionToken<T extends SessionStrategy = \"jwt\"> = T extends \"jwt\"\n  ? JWTString\n  : string\n\n/**\n * Use secure cookies if the site uses HTTPS\n * This being conditional allows cookies to work non-HTTPS development URLs\n * Honour secure cookie option, which sets 'secure' and also adds '__Secure-'\n * prefix, but enable them by default if the site URL is HTTPS; but not for\n * non-HTTPS URLs like http://localhost which are used in development).\n * For more on prefixes see https://googlechrome.github.io/samples/cookie-prefixes/\n *\n * @TODO Review cookie settings (names, options)\n */\nexport function defaultCookies(useSecureCookies: boolean): CookiesOptions {\n  const cookiePrefix = useSecureCookies ? \"__Secure-\" : \"\"\n  return {\n    // default cookie options\n    sessionToken: {\n      name: `${cookiePrefix}next-auth.session-token`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    callbackUrl: {\n      name: `${cookiePrefix}next-auth.callback-url`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    csrfToken: {\n      // Default to __Host- for CSRF token for additional protection if using useSecureCookies\n      // NB: The `__Host-` prefix is stricter than the `__Secure-` prefix.\n      name: `${useSecureCookies ? \"__Host-\" : \"\"}next-auth.csrf-token`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n    pkceCodeVerifier: {\n      name: `${cookiePrefix}next-auth.pkce.code_verifier`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n        maxAge: 60 * 15, // 15 minutes in seconds\n      },\n    },\n    state: {\n      name: `${cookiePrefix}next-auth.state`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n        maxAge: 60 * 15, // 15 minutes in seconds\n      },\n    },\n    nonce: {\n      name: `${cookiePrefix}next-auth.nonce`,\n      options: {\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n        secure: useSecureCookies,\n      },\n    },\n  }\n}\n\nexport interface Cookie extends CookieOption {\n  value: string\n}\n\ntype Chunks = Record<string, string>\n\nexport class SessionStore {\n  #chunks: Chunks = {}\n  #option: CookieOption\n  #logger: LoggerInstance | Console\n\n  constructor(\n    option: CookieOption,\n    req: Partial<{\n      cookies: NextRequest[\"cookies\"] | NextApiRequest[\"cookies\"]\n      headers: NextRequest[\"headers\"] | NextApiRequest[\"headers\"]\n    }>,\n    logger: LoggerInstance | Console\n  ) {\n    this.#logger = logger\n    this.#option = option\n\n    const { cookies } = req\n    const { name: cookieName } = option\n\n    if (typeof cookies?.getAll === \"function\") {\n      // Next.js ^v13.0.1 (Edge Env)\n      for (const { name, value } of cookies.getAll()) {\n        if (name.startsWith(cookieName)) {\n          this.#chunks[name] = value\n        }\n      }\n    } else if (cookies instanceof Map) {\n      for (const name of cookies.keys()) {\n        if (name.startsWith(cookieName)) this.#chunks[name] = cookies.get(name)\n      }\n    } else {\n      for (const name in cookies) {\n        if (name.startsWith(cookieName)) this.#chunks[name] = cookies[name]\n      }\n    }\n  }\n\n  /**\n   * The JWT Session or database Session ID\n   * constructed from the cookie chunks.\n   */\n  get value() {\n    // Sort the chunks by their keys before joining\n    const sortedKeys = Object.keys(this.#chunks).sort((a, b) => {\n      const aSuffix = parseInt(a.split(\".\").pop() ?? \"0\")\n      const bSuffix = parseInt(b.split(\".\").pop() ?? \"0\")\n\n      return aSuffix - bSuffix\n    })\n\n    // Use the sorted keys to join the chunks in the correct order\n    return sortedKeys.map((key) => this.#chunks[key]).join(\"\")\n  }\n\n  /** Given a cookie, return a list of cookies, chunked to fit the allowed cookie size. */\n  #chunk(cookie: Cookie): Cookie[] {\n    const chunkCount = Math.ceil(cookie.value.length / CHUNK_SIZE)\n\n    if (chunkCount === 1) {\n      this.#chunks[cookie.name] = cookie.value\n      return [cookie]\n    }\n\n    const cookies: Cookie[] = []\n    for (let i = 0; i < chunkCount; i++) {\n      const name = `${cookie.name}.${i}`\n      const value = cookie.value.substr(i * CHUNK_SIZE, CHUNK_SIZE)\n      cookies.push({ ...cookie, name, value })\n      this.#chunks[name] = value\n    }\n\n    this.#logger.debug(\"CHUNKING_SESSION_COOKIE\", {\n      message: `Session cookie exceeds allowed ${ALLOWED_COOKIE_SIZE} bytes.`,\n      emptyCookieSize: ESTIMATED_EMPTY_COOKIE_SIZE,\n      valueSize: cookie.value.length,\n      chunks: cookies.map((c) => c.value.length + ESTIMATED_EMPTY_COOKIE_SIZE),\n    })\n\n    return cookies\n  }\n\n  /** Returns cleaned cookie chunks. */\n  #clean(): Record<string, Cookie> {\n    const cleanedChunks: Record<string, Cookie> = {}\n    for (const name in this.#chunks) {\n      delete this.#chunks?.[name]\n      cleanedChunks[name] = {\n        name,\n        value: \"\",\n        options: { ...this.#option.options, maxAge: 0 },\n      }\n    }\n    return cleanedChunks\n  }\n\n  /**\n   * Given a cookie value, return new cookies, chunked, to fit the allowed cookie size.\n   * If the cookie has changed from chunked to unchunked or vice versa,\n   * it deletes the old cookies as well.\n   */\n  chunk(value: string, options: Partial<Cookie[\"options\"]>): Cookie[] {\n    // Assume all cookies should be cleaned by default\n    const cookies: Record<string, Cookie> = this.#clean()\n\n    // Calculate new chunks\n    const chunked = this.#chunk({\n      name: this.#option.name,\n      value,\n      options: { ...this.#option.options, ...options },\n    })\n\n    // Update stored chunks / cookies\n    for (const chunk of chunked) {\n      cookies[chunk.name] = chunk\n    }\n\n    return Object.values(cookies)\n  }\n\n  /** Returns a list of cookies that should be cleaned. */\n  clean(): Cookie[] {\n    return Object.values(this.#clean())\n  }\n}\n"
        }
    ]
}