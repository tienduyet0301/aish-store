{
    "sourceFile": "node_modules/next-auth/src/core/lib/callback-handler.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { AccountNotLinkedError } from \"../errors\"\nimport { fromDate } from \"./utils\"\n\nimport type { InternalOptions } from \"../types\"\nimport type { AdapterSession, AdapterUser } from \"../../adapters\"\nimport type { JWT } from \"../../jwt\"\nimport type { Account, User } from \"../..\"\nimport type { SessionToken } from \"./cookie\"\nimport { OAuthConfig } from \"src/providers\"\n\n/**\n * This function handles the complex flow of signing users in, and either creating,\n * linking (or not linking) accounts depending on if the user is currently logged\n * in, if they have account already and the authentication mechanism they are using.\n *\n * It prevents insecure behaviour, such as linking OAuth accounts unless a user is\n * signed in and authenticated with an existing valid account.\n *\n * All verification (e.g. OAuth flows or email address verificaiton flows) are\n * done prior to this handler being called to avoid additonal complexity in this\n * handler.\n */\nexport default async function callbackHandler(params: {\n  sessionToken?: SessionToken\n  profile: User | AdapterUser | { email: string }\n  account: Account | null\n  options: InternalOptions\n}) {\n  const { sessionToken, profile: _profile, account, options } = params\n  // Input validation\n  if (!account?.providerAccountId || !account.type)\n    throw new Error(\"Missing or invalid provider account\")\n  if (![\"email\", \"oauth\"].includes(account.type))\n    throw new Error(\"Provider not supported\")\n\n  const {\n    adapter,\n    jwt,\n    events,\n    session: { strategy: sessionStrategy, generateSessionToken },\n  } = options\n\n  // If no adapter is configured then we don't have a database and cannot\n  // persist data; in this mode we just return a dummy session object.\n  if (!adapter) {\n    return { user: _profile as User, account }\n  }\n\n  const profile = _profile as AdapterUser\n\n  const {\n    createUser,\n    updateUser,\n    getUser,\n    getUserByAccount,\n    getUserByEmail,\n    linkAccount,\n    createSession,\n    getSessionAndUser,\n    deleteSession,\n  } = adapter\n\n  let session: AdapterSession | JWT | null = null\n  let user: AdapterUser | null = null\n  let isNewUser = false\n\n  const useJwtSession = sessionStrategy === \"jwt\"\n\n  if (sessionToken) {\n    if (useJwtSession) {\n      try {\n        session = await jwt.decode({ ...jwt, token: sessionToken })\n        if (session && \"sub\" in session && session.sub) {\n          user = await getUser(session.sub)\n        }\n      } catch {\n        // If session can't be verified, treat as no session\n      }\n    } else {\n      const userAndSession = await getSessionAndUser(sessionToken)\n      if (userAndSession) {\n        session = userAndSession.session\n        user = userAndSession.user\n      }\n    }\n  }\n\n  if (account.type === \"email\") {\n    // If signing in with an email, check if an account with the same email address exists already\n    const userByEmail = await getUserByEmail(profile.email)\n    if (userByEmail) {\n      // If they are not already signed in as the same user, this flow will\n      // sign them out of the current session and sign them in as the new user\n      if (user?.id !== userByEmail.id && !useJwtSession && sessionToken) {\n        // Delete existing session if they are currently signed in as another user.\n        // This will switch user accounts for the session in cases where the user was\n        // already logged in with a different account.\n        await deleteSession(sessionToken)\n      }\n\n      // Update emailVerified property on the user object\n      user = await updateUser({ id: userByEmail.id, emailVerified: new Date() })\n      await events.updateUser?.({ user })\n    } else {\n      const { id: _, ...newUser } = { ...profile, emailVerified: new Date() }\n      // Create user account if there isn't one for the email address already\n      // @ts-expect-error see adapters.ts' FutureAdapter[\"createUser\"]\n      user = await createUser(newUser)\n      await events.createUser?.({ user })\n      isNewUser = true\n    }\n\n    // Create new session\n    session = useJwtSession\n      ? {}\n      : await createSession({\n          sessionToken: await generateSessionToken(),\n          userId: user.id,\n          expires: fromDate(options.session.maxAge),\n        })\n\n    return { session, user, isNewUser }\n  } else if (account.type === \"oauth\") {\n    // If signing in with OAuth account, check to see if the account exists already\n    const userByAccount = await getUserByAccount({\n      providerAccountId: account.providerAccountId,\n      provider: account.provider,\n    })\n    if (userByAccount) {\n      if (user) {\n        // If the user is already signed in with this account, we don't need to do anything\n        if (userByAccount.id === user.id) {\n          return { session, user, isNewUser }\n        }\n        // If the user is currently signed in, but the new account they are signing in\n        // with is already associated with another user, then we cannot link them\n        // and need to return an error.\n        throw new AccountNotLinkedError(\n          \"The account is already associated with another user\"\n        )\n      }\n      // If there is no active session, but the account being signed in with is already\n      // associated with a valid user then create session to sign the user in.\n      session = useJwtSession\n        ? {}\n        : await createSession({\n            sessionToken: await generateSessionToken(),\n            userId: userByAccount.id,\n            expires: fromDate(options.session.maxAge),\n          })\n\n      return { session, user: userByAccount, isNewUser }\n    } else {\n      if (user) {\n        // If the user is already signed in and the OAuth account isn't already associated\n        // with another user account then we can go ahead and link the accounts safely.\n        // @ts-expect-error see adapters.ts' FutureAdapter[\"linkAccount\"]\n        await linkAccount({ ...account, userId: user.id })\n        await events.linkAccount?.({ user, account, profile })\n\n        // As they are already signed in, we don't need to do anything after linking them\n        return { session, user, isNewUser }\n      }\n\n      // If the user is not signed in and it looks like a new OAuth account then we\n      // check there also isn't an user account already associated with the same\n      // email address as the one in the OAuth profile.\n      //\n      // This step is often overlooked in OAuth implementations, but covers the following cases:\n      //\n      // 1. It makes it harder for someone to accidentally create two accounts.\n      //    e.g. by signin in with email, then again with an oauth account connected to the same email.\n      // 2. It makes it harder to hijack a user account using a 3rd party OAuth account.\n      //    e.g. by creating an oauth account then changing the email address associated with it.\n      //\n      // It's quite common for services to automatically link accounts in this case, but it's\n      // better practice to require the user to sign in *then* link accounts to be sure\n      // someone is not exploiting a problem with a third party OAuth service.\n      //\n      // OAuth providers should require email address verification to prevent this, but in\n      // practice that is not always the case; this helps protect against that.\n      const userByEmail = profile.email\n        ? await getUserByEmail(profile.email)\n        : null\n      if (userByEmail) {\n        const provider = options.provider as OAuthConfig<any>\n        if (provider?.allowDangerousEmailAccountLinking) {\n          // If you trust the oauth provider to correctly verify email addresses, you can opt-in to\n          // account linking even when the user is not signed-in.\n          user = userByEmail\n        } else {\n          // We end up here when we don't have an account with the same [provider].id *BUT*\n          // we do already have an account with the same email address as the one in the\n          // OAuth profile the user has just tried to sign in with.\n          //\n          // We don't want to have two accounts with the same email address, and we don't\n          // want to link them in case it's not safe to do so, so instead we prompt the user\n          // to sign in via email to verify their identity and then link the accounts.\n          throw new AccountNotLinkedError(\n            \"Another account already exists with the same e-mail address\"\n          )\n        }\n      } else {\n        // If the current user is not logged in and the profile isn't linked to any user\n        // accounts (by email or provider account id)...\n        //\n        // If no account matching the same [provider].id or .email exists, we can\n        // create a new account for the user, link it to the OAuth acccount and\n        // create a new session for them so they are signed in with it.\n        const { id: _, ...newUser } = { ...profile, emailVerified: null }\n        // @ts-expect-error see adapters.ts' FutureAdapter[\"createUser\"]\n        user = await createUser(newUser)\n      }\n      await events.createUser?.({ user })\n\n      // @ts-expect-error see adapters.ts' FutureAdapter[\"linkAccount\"]\n      await linkAccount({ ...account, userId: user.id })\n      await events.linkAccount?.({ user, account, profile })\n\n      session = useJwtSession\n        ? {}\n        : await createSession({\n            sessionToken: await generateSessionToken(),\n            userId: user.id,\n            expires: fromDate(options.session.maxAge),\n          })\n\n      return { session, user, isNewUser: true }\n    }\n  }\n\n  throw new Error(\"Unsupported account type\")\n}\n"
        }
    ]
}