{
    "sourceFile": "node_modules/next-auth/src/core/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import logger, { setLogger } from \"../utils/logger\"\nimport { detectOrigin } from \"../utils/detect-origin\"\nimport * as routes from \"./routes\"\nimport renderPage from \"./pages\"\nimport { init } from \"./init\"\nimport { assertConfig } from \"./lib/assert\"\nimport { SessionStore } from \"./lib/cookie\"\n\nimport type { AuthAction, AuthOptions } from \"./types\"\nimport type { Cookie } from \"./lib/cookie\"\nimport type { ErrorType } from \"./pages/error\"\nimport { parse as parseCookie } from \"cookie\"\n\nexport interface RequestInternal {\n  /** @default \"http://localhost:3000\" */\n  origin?: string\n  method?: string\n  cookies?: Partial<Record<string, string>>\n  headers?: Record<string, any>\n  query?: Record<string, any>\n  body?: Record<string, any>\n  action: AuthAction\n  providerId?: string\n  error?: string\n}\n\nexport interface NextAuthHeader {\n  key: string\n  value: string\n}\n\nexport interface ResponseInternal<\n  Body extends string | Record<string, any> | any[] = any\n> {\n  status?: number\n  headers?: NextAuthHeader[]\n  body?: Body\n  redirect?: string\n  cookies?: Cookie[]\n}\n\nexport interface NextAuthHandlerParams {\n  req: Request | RequestInternal\n  options: AuthOptions\n}\n\nasync function getBody(req: Request): Promise<Record<string, any> | undefined> {\n  try {\n    return await req.json()\n  } catch {}\n}\n\n// TODO:\nasync function toInternalRequest(\n  req: RequestInternal | Request\n): Promise<RequestInternal> {\n  if (req instanceof Request) {\n    const url = new URL(req.url)\n    // TODO: handle custom paths?\n    const nextauth = url.pathname.split(\"/\").slice(3)\n    const headers = Object.fromEntries(req.headers)\n    const query: Record<string, any> = Object.fromEntries(url.searchParams)\n    query.nextauth = nextauth\n\n    return {\n      action: nextauth[0] as AuthAction,\n      method: req.method,\n      headers,\n      body: await getBody(req),\n      cookies: parseCookie(req.headers.get(\"cookie\") ?? \"\"),\n      providerId: nextauth[1],\n      error: url.searchParams.get(\"error\") ?? nextauth[1],\n      origin: detectOrigin(\n        headers[\"x-forwarded-host\"] ?? headers.host,\n        headers[\"x-forwarded-proto\"]\n      ),\n      query,\n    }\n  }\n\n  const { headers } = req\n  const host = headers?.[\"x-forwarded-host\"] ?? headers?.host\n  req.origin = detectOrigin(host, headers?.[\"x-forwarded-proto\"])\n\n  return req\n}\n\nexport async function AuthHandler<\n  Body extends string | Record<string, any> | any[]\n>(params: NextAuthHandlerParams): Promise<ResponseInternal<Body>> {\n  const { options: authOptions, req: incomingRequest } = params\n\n  const req = await toInternalRequest(incomingRequest)\n\n  setLogger(authOptions.logger, authOptions.debug)\n\n  const assertionResult = assertConfig({ options: authOptions, req })\n\n  if (Array.isArray(assertionResult)) {\n    assertionResult.forEach(logger.warn)\n  } else if (assertionResult instanceof Error) {\n    // Bail out early if there's an error in the user config\n    logger.error(assertionResult.code, assertionResult)\n\n    const htmlPages = [\"signin\", \"signout\", \"error\", \"verify-request\"]\n    if (!htmlPages.includes(req.action) || req.method !== \"GET\") {\n      const message = `There is a problem with the server configuration. Check the server logs for more information.`\n      return {\n        status: 500,\n        headers: [{ key: \"Content-Type\", value: \"application/json\" }],\n        body: { message } as any,\n      }\n    }\n    const { pages, theme } = authOptions\n\n    const authOnErrorPage =\n      pages?.error && req.query?.callbackUrl?.startsWith(pages.error)\n\n    if (!pages?.error || authOnErrorPage) {\n      if (authOnErrorPage) {\n        logger.error(\n          \"AUTH_ON_ERROR_PAGE_ERROR\",\n          new Error(\n            `The error page ${pages?.error} should not require authentication`\n          )\n        )\n      }\n      const render = renderPage({ theme })\n      return render.error({ error: \"configuration\" })\n    }\n\n    return {\n      redirect: `${pages.error}?error=Configuration`,\n    }\n  }\n\n  const { action, providerId, error, method = \"GET\" } = req\n\n  const { options, cookies } = await init({\n    authOptions,\n    action,\n    providerId,\n    origin: req.origin,\n    callbackUrl: req.body?.callbackUrl ?? req.query?.callbackUrl,\n    csrfToken: req.body?.csrfToken,\n    cookies: req.cookies,\n    isPost: method === \"POST\",\n  })\n\n  const sessionStore = new SessionStore(\n    options.cookies.sessionToken,\n    req,\n    options.logger\n  )\n\n  if (method === \"GET\") {\n    const render = renderPage({ ...options, query: req.query, cookies })\n    const { pages } = options\n    switch (action) {\n      case \"providers\":\n        return (await routes.providers(options.providers)) as any\n      case \"session\": {\n        const session = await routes.session({ options, sessionStore })\n        if (session.cookies) cookies.push(...session.cookies)\n        return { ...session, cookies } as any\n      }\n      case \"csrf\":\n        return {\n          headers: [{ key: \"Content-Type\", value: \"application/json\" }],\n          body: { csrfToken: options.csrfToken } as any,\n          cookies,\n        }\n      case \"signin\":\n        if (pages.signIn) {\n          let signinUrl = `${pages.signIn}${\n            pages.signIn.includes(\"?\") ? \"&\" : \"?\"\n          }callbackUrl=${encodeURIComponent(options.callbackUrl)}`\n          if (error)\n            signinUrl = `${signinUrl}&error=${encodeURIComponent(error)}`\n          return { redirect: signinUrl, cookies }\n        }\n\n        return render.signin()\n      case \"signout\":\n        if (pages.signOut) return { redirect: pages.signOut, cookies }\n\n        return render.signout()\n      case \"callback\":\n        if (options.provider) {\n          const callback = await routes.callback({\n            body: req.body,\n            query: req.query,\n            headers: req.headers,\n            cookies: req.cookies,\n            method,\n            options,\n            sessionStore,\n          })\n          if (callback.cookies) cookies.push(...callback.cookies)\n          return { ...callback, cookies }\n        }\n        break\n      case \"verify-request\":\n        if (pages.verifyRequest) {\n          return { redirect: pages.verifyRequest, cookies }\n        }\n        return render.verifyRequest()\n      case \"error\":\n        // These error messages are displayed in line on the sign in page\n        if (\n          [\n            \"Signin\",\n            \"OAuthSignin\",\n            \"OAuthCallback\",\n            \"OAuthCreateAccount\",\n            \"EmailCreateAccount\",\n            \"Callback\",\n            \"OAuthAccountNotLinked\",\n            \"EmailSignin\",\n            \"CredentialsSignin\",\n            \"SessionRequired\",\n          ].includes(error as string)\n        ) {\n          return { redirect: `${options.url}/signin?error=${error}`, cookies }\n        }\n\n        if (pages.error) {\n          return {\n            redirect: `${pages.error}${\n              pages.error.includes(\"?\") ? \"&\" : \"?\"\n            }error=${error}`,\n            cookies,\n          }\n        }\n\n        return render.error({ error: error as ErrorType })\n      default:\n    }\n  } else if (method === \"POST\") {\n    switch (action) {\n      case \"signin\":\n        // Verified CSRF Token required for all sign-in routes\n        if (options.csrfTokenVerified && options.provider) {\n          const signin = await routes.signin({\n            query: req.query,\n            body: req.body,\n            options,\n          })\n          if (signin.cookies) cookies.push(...signin.cookies)\n          return { ...signin, cookies }\n        }\n\n        return { redirect: `${options.url}/signin?csrf=true`, cookies }\n      case \"signout\":\n        // Verified CSRF Token required for signout\n        if (options.csrfTokenVerified) {\n          const signout = await routes.signout({ options, sessionStore })\n          if (signout.cookies) cookies.push(...signout.cookies)\n          return { ...signout, cookies }\n        }\n        return { redirect: `${options.url}/signout?csrf=true`, cookies }\n      case \"callback\":\n        if (options.provider) {\n          // Verified CSRF Token required for credentials providers only\n          if (\n            options.provider.type === \"credentials\" &&\n            !options.csrfTokenVerified\n          ) {\n            return { redirect: `${options.url}/signin?csrf=true`, cookies }\n          }\n\n          const callback = await routes.callback({\n            body: req.body,\n            query: req.query,\n            headers: req.headers,\n            cookies: req.cookies,\n            method,\n            options,\n            sessionStore,\n          })\n          if (callback.cookies) cookies.push(...callback.cookies)\n          return { ...callback, cookies }\n        }\n        break\n      case \"_log\": {\n        if (authOptions.logger) {\n          try {\n            const { code, level, ...metadata } = req.body ?? {}\n            logger[level](code, metadata)\n          } catch (error) {\n            // If logging itself failed...\n            logger.error(\"LOGGER_ERROR\", error as Error)\n          }\n        }\n        return {}\n      }\n      case \"session\": {\n        // Verified CSRF Token required for session updates\n        if (options.csrfTokenVerified) {\n          const session = await routes.session({\n            options,\n            sessionStore,\n            newSession: req.body?.data,\n            isUpdate: true,\n          })\n          if (session.cookies) cookies.push(...session.cookies)\n          return { ...session, cookies } as any\n        }\n\n        // If CSRF token is invalid, return a 400 status code\n        // we should not redirect to a page as this is an API route\n        return { status: 400, body: {} as any, cookies }\n      }\n      default:\n    }\n  }\n\n  return {\n    status: 400,\n    body: `Error: This action with HTTP ${method} is not supported by NextAuth.js` as any,\n  }\n}\n"
        }
    ]
}