{
    "sourceFile": "node_modules/next-auth/src/core/routes/callback.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892933601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import oAuthCallback from \"../lib/oauth/callback\"\nimport callbackHandler from \"../lib/callback-handler\"\nimport { hashToken } from \"../lib/utils\"\nimport getAdapterUserFromEmail from \"../lib/email/getUserFromEmail\"\n\nimport type { InternalOptions } from \"../types\"\nimport type { RequestInternal, ResponseInternal } from \"..\"\nimport type { Cookie, SessionStore } from \"../lib/cookie\"\nimport type { User } from \"../..\"\nimport type { AdapterSession } from \"../../adapters\"\n\n/** Handle callbacks from login services */\nexport default async function callback(params: {\n  options: InternalOptions\n  query: RequestInternal[\"query\"]\n  method: Required<RequestInternal>[\"method\"]\n  body: RequestInternal[\"body\"]\n  headers: RequestInternal[\"headers\"]\n  cookies: RequestInternal[\"cookies\"]\n  sessionStore: SessionStore\n}): Promise<ResponseInternal> {\n  const { options, query, body, method, headers, sessionStore } = params\n  const {\n    provider,\n    adapter,\n    url,\n    callbackUrl,\n    pages,\n    jwt,\n    events,\n    callbacks,\n    session: { strategy: sessionStrategy, maxAge: sessionMaxAge },\n    logger,\n  } = options\n\n  const cookies: Cookie[] = []\n\n  const useJwtSession = sessionStrategy === \"jwt\"\n\n  if (provider.type === \"oauth\") {\n    try {\n      const {\n        profile,\n        account,\n        OAuthProfile,\n        cookies: oauthCookies,\n      } = await oAuthCallback({\n        query,\n        body,\n        method,\n        options,\n        cookies: params.cookies,\n      })\n\n      if (oauthCookies.length) cookies.push(...oauthCookies)\n\n      try {\n        // Make it easier to debug when adding a new provider\n        logger.debug(\"OAUTH_CALLBACK_RESPONSE\", {\n          profile,\n          account,\n          OAuthProfile,\n        })\n\n        // If we don't have a profile object then either something went wrong\n        // or the user cancelled signing in. We don't know which, so we just\n        // direct the user to the signin page for now. We could do something\n        // else in future.\n        //\n        // Note: In oAuthCallback an error is logged with debug info, so it\n        // should at least be visible to developers what happened if it is an\n        // error with the provider.\n        if (!profile || !account || !OAuthProfile) {\n          return { redirect: `${url}/signin`, cookies }\n        }\n\n        // Check if user is allowed to sign in\n        // Attempt to get Profile from OAuth provider details before invoking\n        // signIn callback - but if no user object is returned, that is fine\n        // (that just means it's a new user signing in for the first time).\n        let userOrProfile = profile\n        if (adapter) {\n          const { getUserByAccount } = adapter\n          const userByAccount = await getUserByAccount({\n            providerAccountId: account.providerAccountId,\n            provider: provider.id,\n          })\n\n          if (userByAccount) userOrProfile = userByAccount\n        }\n\n        try {\n          const isAllowed = await callbacks.signIn({\n            user: userOrProfile,\n            account,\n            profile: OAuthProfile,\n          })\n          if (!isAllowed) {\n            return { redirect: `${url}/error?error=AccessDenied`, cookies }\n          } else if (typeof isAllowed === \"string\") {\n            return { redirect: isAllowed, cookies }\n          }\n        } catch (error) {\n          return {\n            redirect: `${url}/error?error=${encodeURIComponent(\n              (error as Error).message,\n            )}`,\n            cookies,\n          }\n        }\n\n        // Sign user in\n        const { user, session, isNewUser } = await callbackHandler({\n          sessionToken: sessionStore.value,\n          profile,\n          account,\n          options,\n        })\n\n        if (useJwtSession) {\n          const defaultToken = {\n            name: user.name,\n            email: user.email,\n            picture: user.image,\n            sub: user.id?.toString(),\n          }\n          const token = await callbacks.jwt({\n            token: defaultToken,\n            user,\n            account,\n            profile: OAuthProfile,\n            isNewUser,\n            trigger: isNewUser ? \"signUp\" : \"signIn\",\n          })\n\n          // Encode token\n          const newToken = await jwt.encode({ ...jwt, token })\n\n          // Set cookie expiry date\n          const cookieExpires = new Date()\n          cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000)\n\n          const sessionCookies = sessionStore.chunk(newToken, {\n            expires: cookieExpires,\n          })\n          cookies.push(...sessionCookies)\n        } else {\n          // Save Session Token in cookie\n          cookies.push({\n            name: options.cookies.sessionToken.name,\n            value: (session as AdapterSession).sessionToken,\n            options: {\n              ...options.cookies.sessionToken.options,\n              expires: (session as AdapterSession).expires,\n            },\n          })\n        }\n\n        // @ts-expect-error\n        await events.signIn?.({ user, account, profile, isNewUser })\n\n        // Handle first logins on new accounts\n        // e.g. option to send users to a new account landing page on initial login\n        // Note that the callback URL is preserved, so the journey can still be resumed\n        if (isNewUser && pages.newUser) {\n          return {\n            redirect: `${pages.newUser}${\n              pages.newUser.includes(\"?\") ? \"&\" : \"?\"\n            }callbackUrl=${encodeURIComponent(callbackUrl)}`,\n            cookies,\n          }\n        }\n\n        // Callback URL is already verified at this point, so safe to use if specified\n        return { redirect: callbackUrl, cookies }\n      } catch (error) {\n        if ((error as Error).name === \"AccountNotLinkedError\") {\n          // If the email on the account is already linked, but not with this OAuth account\n          return {\n            redirect: `${url}/error?error=OAuthAccountNotLinked`,\n            cookies,\n          }\n        } else if ((error as Error).name === \"CreateUserError\") {\n          return { redirect: `${url}/error?error=OAuthCreateAccount`, cookies }\n        }\n        logger.error(\"OAUTH_CALLBACK_HANDLER_ERROR\", error as Error)\n        return { redirect: `${url}/error?error=Callback`, cookies }\n      }\n    } catch (error) {\n      if ((error as Error).name === \"OAuthCallbackError\") {\n        logger.error(\"OAUTH_CALLBACK_ERROR\", {\n          error: error as Error,\n          providerId: provider.id,\n        })\n        return { redirect: `${url}/error?error=OAuthCallback`, cookies }\n      }\n      logger.error(\"OAUTH_CALLBACK_ERROR\", error as Error)\n      return { redirect: `${url}/error?error=Callback`, cookies }\n    }\n  } else if (provider.type === \"email\") {\n    try {\n      const paramToken = query?.token as string | undefined\n      const paramIdentifier = query?.email as string | undefined\n\n      // If token is missing, the sign-in URL was manually opened without this param or the `sendVerificationRequest` method did not send the link correctly in the email.\n      if (!paramToken) {\n        return { redirect: `${url}/error?error=configuration`, cookies }\n      }\n\n      // @ts-expect-error -- Verified in `assertConfig`. adapter: Adapter<true>\n      const invite = await adapter.useVerificationToken({\n        // @ts-expect-error User-land adapters might decide to omit the identifier during lookup\n        identifier: paramIdentifier,\n        token: hashToken(paramToken, options),\n      })\n\n      const invalidInvite =\n        !invite ||\n        invite.expires.valueOf() < Date.now() ||\n        // The user might have configured the link to not contain the identifier\n        // so we only compare if it exists\n        (paramIdentifier && invite.identifier !== paramIdentifier)\n      if (invalidInvite) {\n        return { redirect: `${url}/error?error=Verification`, cookies }\n      }\n\n      const profile = await getAdapterUserFromEmail({\n        email: invite.identifier,\n        adapter,\n      })\n\n      const account = {\n        providerAccountId: profile.email,\n        type: \"email\" as const,\n        provider: provider.id,\n      }\n\n      // Check if user is allowed to sign in\n      try {\n        const signInCallbackResponse = await callbacks.signIn({\n          user: profile,\n          account,\n        })\n        if (!signInCallbackResponse) {\n          return { redirect: `${url}/error?error=AccessDenied`, cookies }\n        } else if (typeof signInCallbackResponse === \"string\") {\n          return { redirect: signInCallbackResponse, cookies }\n        }\n      } catch (error) {\n        return {\n          redirect: `${url}/error?error=${encodeURIComponent(\n            (error as Error).message,\n          )}`,\n          cookies,\n        }\n      }\n\n      // Sign user in\n      const { user, session, isNewUser } = await callbackHandler({\n        sessionToken: sessionStore.value,\n        profile,\n        account,\n        options,\n      })\n\n      if (useJwtSession) {\n        const defaultToken = {\n          name: user.name,\n          email: user.email,\n          picture: user.image,\n          sub: user.id?.toString(),\n        }\n        const token = await callbacks.jwt({\n          token: defaultToken,\n          user,\n          account,\n          isNewUser,\n          trigger: isNewUser ? \"signUp\" : \"signIn\",\n        })\n\n        // Encode token\n        const newToken = await jwt.encode({ ...jwt, token })\n\n        // Set cookie expiry date\n        const cookieExpires = new Date()\n        cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000)\n\n        const sessionCookies = sessionStore.chunk(newToken, {\n          expires: cookieExpires,\n        })\n        cookies.push(...sessionCookies)\n      } else {\n        // Save Session Token in cookie\n        cookies.push({\n          name: options.cookies.sessionToken.name,\n          value: (session as AdapterSession).sessionToken,\n          options: {\n            ...options.cookies.sessionToken.options,\n            expires: (session as AdapterSession).expires,\n          },\n        })\n      }\n\n      await events.signIn?.({ user, account, isNewUser })\n\n      // Handle first logins on new accounts\n      // e.g. option to send users to a new account landing page on initial login\n      // Note that the callback URL is preserved, so the journey can still be resumed\n      if (isNewUser && pages.newUser) {\n        return {\n          redirect: `${pages.newUser}${\n            pages.newUser.includes(\"?\") ? \"&\" : \"?\"\n          }callbackUrl=${encodeURIComponent(callbackUrl)}`,\n          cookies,\n        }\n      }\n\n      // Callback URL is already verified at this point, so safe to use if specified\n      return { redirect: callbackUrl, cookies }\n    } catch (error) {\n      if ((error as Error).name === \"CreateUserError\") {\n        return { redirect: `${url}/error?error=EmailCreateAccount`, cookies }\n      }\n      logger.error(\"CALLBACK_EMAIL_ERROR\", error as Error)\n      return { redirect: `${url}/error?error=Callback`, cookies }\n    }\n  } else if (provider.type === \"credentials\" && method === \"POST\") {\n    const credentials = body\n\n    let user: User | null\n    try {\n      user = await provider.authorize(credentials, {\n        query,\n        body,\n        headers,\n        method,\n      })\n      if (!user) {\n        return {\n          status: 401,\n          redirect: `${url}/error?${new URLSearchParams({\n            error: \"CredentialsSignin\",\n            provider: provider.id,\n          })}`,\n          cookies,\n        }\n      }\n    } catch (error) {\n      return {\n        status: 401,\n        redirect: `${url}/error?error=${encodeURIComponent(\n          (error as Error).message,\n        )}`,\n        cookies,\n      }\n    }\n\n    /** @type {import(\"src\").Account} */\n    const account = {\n      providerAccountId: user.id,\n      type: \"credentials\",\n      provider: provider.id,\n    }\n\n    try {\n      const isAllowed = await callbacks.signIn({\n        user,\n        // @ts-expect-error\n        account,\n        credentials,\n      })\n      if (!isAllowed) {\n        return {\n          status: 403,\n          redirect: `${url}/error?error=AccessDenied`,\n          cookies,\n        }\n      } else if (typeof isAllowed === \"string\") {\n        return { redirect: isAllowed, cookies }\n      }\n    } catch (error) {\n      return {\n        redirect: `${url}/error?error=${encodeURIComponent(\n          (error as Error).message,\n        )}`,\n        cookies,\n      }\n    }\n\n    const defaultToken = {\n      name: user.name,\n      email: user.email,\n      picture: user.image,\n      sub: user.id?.toString(),\n    }\n\n    const token = await callbacks.jwt({\n      token: defaultToken,\n      user,\n      // @ts-expect-error\n      account,\n      isNewUser: false,\n      trigger: \"signIn\",\n    })\n\n    // Encode token\n    const newToken = await jwt.encode({ ...jwt, token })\n\n    // Set cookie expiry date\n    const cookieExpires = new Date()\n    cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000)\n\n    const sessionCookies = sessionStore.chunk(newToken, {\n      expires: cookieExpires,\n    })\n\n    cookies.push(...sessionCookies)\n\n    // @ts-expect-error\n    await events.signIn?.({ user, account })\n\n    return { redirect: callbackUrl, cookies }\n  }\n  return {\n    status: 500,\n    body: `Error: Callback for provider type ${provider.type} not supported`,\n    cookies,\n  }\n}\n"
        }
    ]
}