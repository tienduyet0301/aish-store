{
    "sourceFile": "node_modules/next-auth/src/core/routes/signin.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892933744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import getAuthorizationUrl from \"../lib/oauth/authorization-url\"\nimport emailSignin from \"../lib/email/signin\"\nimport getAdapterUserFromEmail from \"../lib/email/getUserFromEmail\"\nimport type { RequestInternal, ResponseInternal } from \"..\"\nimport type { InternalOptions } from \"../types\"\nimport type { Account } from \"../..\"\n\n/** Handle requests to /api/auth/signin */\nexport default async function signin(params: {\n  options: InternalOptions<\"oauth\" | \"email\">\n  query: RequestInternal[\"query\"]\n  body: RequestInternal[\"body\"]\n}): Promise<ResponseInternal> {\n  const { options, query, body } = params\n  const { url, callbacks, logger, provider } = options\n\n  if (!provider.type) {\n    return {\n      status: 500,\n      // @ts-expect-error\n      text: `Error: Type not specified for ${provider.name}`,\n    }\n  }\n\n  if (provider.type === \"oauth\") {\n    try {\n      const response = await getAuthorizationUrl({ options, query })\n      return response\n    } catch (error) {\n      logger.error(\"SIGNIN_OAUTH_ERROR\", {\n        error: error as Error,\n        providerId: provider.id,\n      })\n      return { redirect: `${url}/error?error=OAuthSignin` }\n    }\n  } else if (provider.type === \"email\") {\n    let email: string = body?.email\n    if (!email) return { redirect: `${url}/error?error=EmailSignin` }\n    const normalizer: (identifier: string) => string =\n      provider.normalizeIdentifier ??\n      ((identifier) => {\n        // Get the first two elements only,\n        // separated by `@` from user input.\n        let [local, domain] = identifier.toLowerCase().trim().split(\"@\")\n        // The part before \"@\" can contain a \",\"\n        // but we remove it on the domain part\n        domain = domain.split(\",\")[0]\n        return `${local}@${domain}`\n      })\n\n    try {\n      email = normalizer(body?.email)\n    } catch (error) {\n      logger.error(\"SIGNIN_EMAIL_ERROR\", { error, providerId: provider.id })\n      return { redirect: `${url}/error?error=EmailSignin` }\n    }\n\n    const user = await getAdapterUserFromEmail({\n      email,\n      adapter: options.adapter,\n    })\n\n    const account: Account = {\n      providerAccountId: email,\n      userId: email,\n      type: \"email\",\n      provider: provider.id,\n    }\n\n    // Check if user is allowed to sign in\n    try {\n      const signInCallbackResponse = await callbacks.signIn({\n        user,\n        account,\n        email: { verificationRequest: true },\n      })\n      if (!signInCallbackResponse) {\n        return { redirect: `${url}/error?error=AccessDenied` }\n      } else if (typeof signInCallbackResponse === \"string\") {\n        return { redirect: signInCallbackResponse }\n      }\n    } catch (error) {\n      return {\n        redirect: `${url}/error?${new URLSearchParams({\n          error: error as string,\n        })}`,\n      }\n    }\n\n    try {\n      const redirect = await emailSignin(email, options)\n      return { redirect }\n    } catch (error) {\n      logger.error(\"SIGNIN_EMAIL_ERROR\", { error, providerId: provider.id })\n      return { redirect: `${url}/error?error=EmailSignin` }\n    }\n  }\n  return { redirect: `${url}/signin` }\n}\n"
        }
    ]
}