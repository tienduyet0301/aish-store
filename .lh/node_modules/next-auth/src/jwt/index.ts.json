{
    "sourceFile": "node_modules/next-auth/src/jwt/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892933971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { EncryptJWT, jwtDecrypt } from \"jose\"\nimport hkdf from \"@panva/hkdf\"\nimport { v4 as uuid } from \"uuid\"\nimport { SessionStore } from \"../core/lib/cookie\"\nimport type { GetServerSidePropsContext, NextApiRequest } from \"next\"\nimport type { NextRequest } from \"next/server\"\nimport type { JWT, JWTDecodeParams, JWTEncodeParams, JWTOptions } from \"./types\"\nimport type { LoggerInstance } from \"..\"\n\nexport * from \"./types\"\n\nconst DEFAULT_MAX_AGE = 30 * 24 * 60 * 60 // 30 days\n\nconst now = () => (Date.now() / 1000) | 0\n\n/** Issues a JWT. By default, the JWT is encrypted using \"A256GCM\". */\nexport async function encode(params: JWTEncodeParams) {\n  /** @note empty `salt` means a session token. See {@link JWTEncodeParams.salt}. */\n  const { token = {}, secret, maxAge = DEFAULT_MAX_AGE, salt = \"\" } = params\n  const encryptionSecret = await getDerivedEncryptionKey(secret, salt)\n  return await new EncryptJWT(token)\n    .setProtectedHeader({ alg: \"dir\", enc: \"A256GCM\" })\n    .setIssuedAt()\n    .setExpirationTime(now() + maxAge)\n    .setJti(uuid())\n    .encrypt(encryptionSecret)\n}\n\n/** Decodes a NextAuth.js issued JWT. */\nexport async function decode(params: JWTDecodeParams): Promise<JWT | null> {\n  /** @note empty `salt` means a session token. See {@link JWTDecodeParams.salt}. */\n  const { token, secret, salt = \"\" } = params\n  if (!token) return null\n  const encryptionSecret = await getDerivedEncryptionKey(secret, salt)\n  const { payload } = await jwtDecrypt(token, encryptionSecret, {\n    clockTolerance: 15,\n  })\n  return payload\n}\n\nexport interface GetTokenParams<R extends boolean = false> {\n  /** The request containing the JWT either in the cookies or in the `Authorization` header. */\n  req: GetServerSidePropsContext[\"req\"] | NextRequest | NextApiRequest\n  /**\n   * Use secure prefix for cookie name, unless URL in `NEXTAUTH_URL` is http://\n   * or not set (e.g. development or test instance) case use unprefixed name\n   */\n  secureCookie?: boolean\n  /** If the JWT is in the cookie, what name `getToken()` should look for. */\n  cookieName?: string\n  /**\n   * `getToken()` will return the raw JWT if this is set to `true`\n   * @default false\n   */\n  raw?: R\n  /**\n   * The same `secret` used in the `NextAuth` configuration.\n   * Defaults to the `NEXTAUTH_SECRET` environment variable.\n   */\n  secret?: string\n  decode?: JWTOptions[\"decode\"]\n  logger?: LoggerInstance | Console\n}\n\n/**\n * Takes a NextAuth.js request (`req`) and returns either the NextAuth.js issued JWT's payload,\n * or the raw JWT string. We look for the JWT in the either the cookies, or the `Authorization` header.\n * [Documentation](https://next-auth.js.org/tutorials/securing-pages-and-api-routes#using-gettoken)\n */\nexport async function getToken<R extends boolean = false>(\n  params: GetTokenParams<R>\n): Promise<R extends true ? string : JWT | null> {\n  const {\n    req,\n    secureCookie = process.env.NEXTAUTH_URL?.startsWith(\"https://\") ??\n      !!process.env.VERCEL,\n    cookieName = secureCookie\n      ? \"__Secure-next-auth.session-token\"\n      : \"next-auth.session-token\",\n    raw,\n    decode: _decode = decode,\n    logger = console,\n    secret = process.env.NEXTAUTH_SECRET ?? process.env.AUTH_SECRET,\n  } = params\n\n  if (!req) throw new Error(\"Must pass `req` to JWT getToken()\")\n\n  const sessionStore = new SessionStore(\n    { name: cookieName, options: { secure: secureCookie } },\n    { cookies: req.cookies, headers: req.headers },\n    logger\n  )\n\n  let token = sessionStore.value\n\n  const authorizationHeader =\n    req.headers instanceof Headers\n      ? req.headers.get(\"authorization\")\n      : req.headers?.authorization\n\n  if (!token && authorizationHeader?.split(\" \")[0] === \"Bearer\") {\n    const urlEncodedToken = authorizationHeader.split(\" \")[1]\n    token = decodeURIComponent(urlEncodedToken)\n  }\n\n  // @ts-expect-error\n  if (!token) return null\n\n  // @ts-expect-error\n  if (raw) return token\n\n  try {\n    // @ts-expect-error\n    return await _decode({ token, secret })\n  } catch {\n    // @ts-expect-error\n    return null\n  }\n}\n\nasync function getDerivedEncryptionKey(\n  keyMaterial: string | Buffer,\n  salt: string\n) {\n  return await hkdf(\n    \"sha256\",\n    keyMaterial,\n    salt,\n    `NextAuth.js Generated Encryption Key${salt ? ` (${salt})` : \"\"}`,\n    32\n  )\n}\n"
        }
    ]
}