{
    "sourceFile": "node_modules/next-auth/src/next/middleware.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892934118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import type { NextMiddleware, NextFetchEvent } from \"next/server\"\nimport type { Awaitable, CookieOption, AuthOptions } from \"..\"\nimport type { JWT, JWTOptions } from \"../jwt\"\n\nimport { NextResponse, NextRequest } from \"next/server\"\n\nimport { getToken } from \"../jwt\"\nimport parseUrl from \"../utils/parse-url\"\n\ntype AuthorizedCallback = (params: {\n  token: JWT | null\n  req: NextRequest\n}) => Awaitable<boolean>\n\nexport interface NextAuthMiddlewareOptions {\n  /**\n   * Where to redirect the user in case of an error if they weren't logged in.\n   * Similar to `pages` in `NextAuth`.\n   *\n   * ---\n   * [Documentation](https://next-auth.js.org/configuration/pages)\n   */\n  pages?: AuthOptions[\"pages\"]\n\n  /**\n   * You can override the default cookie names and options for any of the cookies\n   * by this middleware. Similar to `cookies` in `NextAuth`.\n   *\n   * Useful if the token is stored in not a default cookie.\n   *\n   * ---\n   * [Documentation](https://next-auth.js.org/configuration/options#cookies)\n   *\n   * - âš  **This is an advanced option.** Advanced options are passed the same way as basic options,\n   * but **may have complex implications** or side effects.\n   * You should **try to avoid using advanced options** unless you are very comfortable using them.\n   *\n   */\n  cookies?: Partial<\n    Record<\n      keyof Pick<keyof AuthOptions[\"cookies\"], \"sessionToken\">,\n      Omit<CookieOption, \"options\">\n    >\n  >\n\n  /**\n   * If a custom jwt `decode` method is set in `[...nextauth].ts`, the same method should be set here also.\n   *\n   * ---\n   * [Documentation](https://next-auth.js.org/configuration/nextjs#custom-jwt-decode-method)\n   */\n  jwt?: Partial<Pick<JWTOptions, \"decode\">>\n\n  callbacks?: {\n    /**\n     * Callback that receives the user's JWT payload\n     * and returns `true` to allow the user to continue.\n     *\n     * This is similar to the `signIn` callback in `NextAuthOptions`.\n     *\n     * If it returns `false`, the user is redirected to the sign-in page instead\n     *\n     * The default is to let the user continue if they have a valid JWT (basic authentication).\n     *\n     * How to restrict a page and all of it's subpages for admins-only:\n     * @example\n     *\n     * ```js\n     * // `middleware.js`\n     * import { withAuth } from \"next-auth/middleware\"\n     *\n     * export default withAuth({\n     *   callbacks: {\n     *     authorized: ({ token }) => token?.user.isAdmin\n     *   }\n     * })\n     *\n     * export const config = { matcher: [\"/admin\"] }\n     *\n     * ```\n     *\n     * ---\n     * [Documentation](https://next-auth.js.org/configuration/nextjs#middleware) | [`signIn` callback](configuration/callbacks#sign-in-callback)\n     */\n    authorized?: AuthorizedCallback\n  }\n\n  /**\n   * The same `secret` used in the `NextAuth` configuration.\n   * Defaults to the `NEXTAUTH_SECRET` environment variable.\n   */\n  secret?: string\n}\n\n// TODO: `NextMiddleware` should allow returning `void`\n// Simplify when https://github.com/vercel/next.js/pull/38625 is merged.\ntype NextMiddlewareResult = ReturnType<NextMiddleware> | void // eslint-disable-line @typescript-eslint/no-invalid-void-type\n\nasync function handleMiddleware(\n  req: NextRequest,\n  options: NextAuthMiddlewareOptions | undefined,\n  onSuccess?: (token: JWT | null) => Promise<NextMiddlewareResult>\n) {\n  const { pathname, search, origin, basePath } = req.nextUrl\n\n  const signInPage = options?.pages?.signIn ?? \"/api/auth/signin\"\n  const errorPage = options?.pages?.error ?? \"/api/auth/error\"\n  const authPath = parseUrl(process.env.NEXTAUTH_URL).path\n  const publicPaths = [\"/_next\", \"/favicon.ico\"]\n\n  // Avoid infinite redirects/invalid response\n  // on paths that never require authentication\n  if (\n    `${basePath}${pathname}`.startsWith(authPath) ||\n    [signInPage, errorPage].includes(pathname) ||\n    publicPaths.some((p) => pathname.startsWith(p))\n  ) {\n    return\n  }\n\n  const secret =\n    options?.secret ?? process.env.NEXTAUTH_SECRET ?? process.env.AUTH_SECRET\n  if (!secret) {\n    console.error(\n      `[next-auth][error][NO_SECRET]`,\n      `\\nhttps://next-auth.js.org/errors#no_secret`\n    )\n\n    const errorUrl = new URL(`${basePath}${errorPage}`, origin)\n    errorUrl.searchParams.append(\"error\", \"Configuration\")\n\n    return NextResponse.redirect(errorUrl)\n  }\n\n  const token = await getToken({\n    req,\n    decode: options?.jwt?.decode,\n    cookieName: options?.cookies?.sessionToken?.name,\n    secret,\n  })\n\n  const isAuthorized =\n    (await options?.callbacks?.authorized?.({ req, token })) ?? !!token\n\n  // the user is authorized, let the middleware handle the rest\n  if (isAuthorized) return await onSuccess?.(token)\n\n  // the user is not logged in, redirect to the sign-in page\n  const signInUrl = new URL(`${basePath}${signInPage}`, origin)\n  signInUrl.searchParams.append(\n    \"callbackUrl\",\n    `${basePath}${pathname}${search}`\n  )\n  return NextResponse.redirect(signInUrl)\n}\n\nexport interface NextRequestWithAuth extends NextRequest {\n  nextauth: { token: JWT | null }\n}\n\nexport type NextMiddlewareWithAuth = (\n  request: NextRequestWithAuth,\n  event: NextFetchEvent\n) => NextMiddlewareResult | Promise<NextMiddlewareResult>\n\nexport type WithAuthArgs =\n  | [NextRequestWithAuth]\n  | [NextRequestWithAuth, NextFetchEvent]\n  | [NextRequestWithAuth, NextAuthMiddlewareOptions]\n  | [NextMiddlewareWithAuth]\n  | [NextMiddlewareWithAuth, NextAuthMiddlewareOptions]\n  | [NextAuthMiddlewareOptions]\n  | []\n\n/**\n * Middleware that checks if the user is authenticated/authorized.\n * If if they aren't, they will be redirected to the login page.\n * Otherwise, continue.\n *\n * @example\n *\n * ```js\n * // `middleware.js`\n * export { default } from \"next-auth/middleware\"\n * ```\n *\n * ---\n * [Documentation](https://next-auth.js.org/configuration/nextjs#middleware)\n */\n\nexport function withAuth(): ReturnType<NextMiddlewareWithAuth>\n\nexport function withAuth(\n  req: NextRequestWithAuth\n): ReturnType<NextMiddlewareWithAuth>\n\nexport function withAuth(\n  req: NextRequestWithAuth,\n  event: NextFetchEvent\n): ReturnType<NextMiddlewareWithAuth>\n\nexport function withAuth(\n  req: NextRequestWithAuth,\n  options: NextAuthMiddlewareOptions\n): ReturnType<NextMiddlewareWithAuth>\n\nexport function withAuth(\n  middleware: NextMiddlewareWithAuth,\n  options: NextAuthMiddlewareOptions\n): NextMiddlewareWithAuth\n\nexport function withAuth(\n  middleware: NextMiddlewareWithAuth\n): NextMiddlewareWithAuth\n\nexport function withAuth(\n  options: NextAuthMiddlewareOptions\n): NextMiddlewareWithAuth\n\nexport function withAuth(\n  ...args: WithAuthArgs\n): ReturnType<NextMiddlewareWithAuth> | NextMiddlewareWithAuth {\n  if (!args.length || args[0] instanceof Request) {\n    // @ts-expect-error\n    return handleMiddleware(...args)\n  }\n\n  if (typeof args[0] === \"function\") {\n    const middleware = args[0]\n    const options = args[1] as NextAuthMiddlewareOptions | undefined\n    return async (...args: Parameters<NextMiddlewareWithAuth>) =>\n      await handleMiddleware(args[0], options, async (token) => {\n        args[0].nextauth = { token }\n        return await middleware(...args)\n      })\n  }\n\n  const options = args[0]\n  return async (...args: Parameters<NextMiddleware>) =>\n    await handleMiddleware(args[0], options)\n}\n\nexport default withAuth\n"
        }
    ]
}