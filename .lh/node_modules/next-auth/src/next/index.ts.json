{
    "sourceFile": "node_modules/next-auth/src/next/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892934077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { AuthHandler } from \"../core\"\nimport { setCookie, getBody, toResponse } from \"./utils\"\n\nimport type {\n  GetServerSidePropsContext,\n  NextApiRequest,\n  NextApiResponse,\n} from \"next\"\nimport { type NextRequest } from \"next/server\"\nimport type { AuthOptions, Session } from \"..\"\nimport type {\n  CallbacksOptions,\n  AuthAction,\n  NextAuthRequest,\n  NextAuthResponse,\n  Awaitable,\n} from \"../core/types\"\n\ninterface RouteHandlerContext {\n  params: Awaitable<{ nextauth: string[] }>\n}\n\nasync function NextAuthApiHandler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  options: AuthOptions\n) {\n  const { nextauth, ...query } = req.query\n\n  options.secret ??=\n    options.jwt?.secret ??\n    process.env.NEXTAUTH_SECRET ??\n    process.env.AUTH_SECRET\n\n  const handler = await AuthHandler({\n    req: {\n      body: req.body,\n      query,\n      cookies: req.cookies,\n      headers: req.headers,\n      method: req.method,\n      action: nextauth?.[0] as AuthAction,\n      providerId: nextauth?.[1],\n      error: (req.query.error as string | undefined) ?? nextauth?.[1],\n    },\n    options,\n  })\n\n  res.status(handler.status ?? 200)\n\n  handler.cookies?.forEach((cookie) => setCookie(res, cookie))\n\n  handler.headers?.forEach((h) => res.setHeader(h.key, h.value))\n\n  if (handler.redirect) {\n    // If the request expects a return URL, send it as JSON\n    // instead of doing an actual redirect.\n    if (req.body?.json !== \"true\") {\n      // Could chain. .end() when lowest target is Node 14\n      // https://github.com/nodejs/node/issues/33148\n      res.status(302).setHeader(\"Location\", handler.redirect)\n      res.end()\n      return\n    }\n    return res.json({ url: handler.redirect })\n  }\n\n  return res.send(handler.body)\n}\n\n// @see https://beta.nextjs.org/docs/routing/route-handlers\nasync function NextAuthRouteHandler(\n  req: NextRequest,\n  context: RouteHandlerContext,\n  options: AuthOptions\n) {\n  options.secret ??= process.env.NEXTAUTH_SECRET ?? process.env.AUTH_SECRET\n\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const { headers, cookies } = require(\"next/headers\")\n  const nextauth = (await context.params)?.nextauth\n  const query = Object.fromEntries(req.nextUrl.searchParams)\n  const body = await getBody(req)\n  const internalResponse = await AuthHandler({\n    req: {\n      body,\n      query,\n      cookies: Object.fromEntries(\n        (await cookies()).getAll().map((c) => [c.name, c.value])\n      ),\n      headers: Object.fromEntries((await headers()) as Headers),\n      method: req.method,\n      action: nextauth?.[0] as AuthAction,\n      providerId: nextauth?.[1],\n      error: query.error ?? nextauth?.[1],\n    },\n    options,\n  })\n\n  const response = toResponse(internalResponse)\n  const redirect = response.headers.get(\"Location\")\n  if (body?.json === \"true\" && redirect) {\n    response.headers.delete(\"Location\")\n    response.headers.set(\"Content-Type\", \"application/json\")\n    return new Response(JSON.stringify({ url: redirect }), {\n      status: internalResponse.status,\n      headers: response.headers,\n    })\n  }\n\n  return response\n}\n\nfunction NextAuth(options: AuthOptions): any\nfunction NextAuth(\n  req: NextApiRequest,\n  res: NextApiResponse,\n  options: AuthOptions\n): any\n\nfunction NextAuth(\n  req: NextRequest,\n  res: RouteHandlerContext,\n  options: AuthOptions\n): any\n\n/** The main entry point to next-auth */\nfunction NextAuth(\n  ...args:\n    | [AuthOptions]\n    | Parameters<typeof NextAuthRouteHandler>\n    | Parameters<typeof NextAuthApiHandler>\n) {\n  if (args.length === 1) {\n    return async (\n      req: NextAuthRequest | NextRequest,\n      res: NextAuthResponse | RouteHandlerContext\n    ) => {\n      if ((res as any)?.params) {\n        return await NextAuthRouteHandler(\n          req as NextRequest,\n          res as RouteHandlerContext,\n          args[0]\n        )\n      }\n      return await NextAuthApiHandler(\n        req as NextApiRequest,\n        res as NextApiResponse,\n        args[0]\n      )\n    }\n  }\n\n  if ((args[1] as any)?.params) {\n    return NextAuthRouteHandler(\n      ...(args as Parameters<typeof NextAuthRouteHandler>)\n    )\n  }\n\n  return NextAuthApiHandler(...(args as Parameters<typeof NextAuthApiHandler>))\n}\n\nexport default NextAuth\n\ntype GetServerSessionOptions = Partial<Omit<AuthOptions, \"callbacks\">> & {\n  callbacks?: Omit<AuthOptions[\"callbacks\"], \"session\"> & {\n    session?: (...args: Parameters<CallbacksOptions[\"session\"]>) => any\n  }\n}\n\ntype GetServerSessionParams<O extends GetServerSessionOptions> =\n  | [GetServerSidePropsContext[\"req\"], GetServerSidePropsContext[\"res\"], O]\n  | [NextApiRequest, NextApiResponse, O]\n  | [O]\n  | []\n\nexport async function getServerSession<\n  O extends GetServerSessionOptions,\n  R = O[\"callbacks\"] extends { session: (...args: any[]) => infer U }\n    ? U\n    : Session\n>(...args: GetServerSessionParams<O>): Promise<R | null> {\n  const isRSC = args.length === 0 || args.length === 1\n\n  let req, res, options: AuthOptions\n  if (isRSC) {\n    options = Object.assign({}, args[0], { providers: [] })\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { headers, cookies } = require(\"next/headers\")\n    req = {\n      headers: Object.fromEntries((await headers()) as Headers),\n      cookies: Object.fromEntries(\n        (await cookies()).getAll().map((c) => [c.name, c.value])\n      ),\n    }\n    res = { getHeader() {}, setCookie() {}, setHeader() {} }\n  } else {\n    req = args[0]\n    res = args[1]\n    options = Object.assign({}, args[2], { providers: [] })\n  }\n\n  options.secret ??= process.env.NEXTAUTH_SECRET ?? process.env.AUTH_SECRET\n\n  const session = await AuthHandler<Session | {} | string>({\n    options,\n    req: {\n      action: \"session\",\n      method: \"GET\",\n      cookies: req.cookies,\n      headers: req.headers,\n    },\n  })\n\n  const { body, cookies, status = 200 } = session\n\n  cookies?.forEach((cookie) => setCookie(res, cookie))\n\n  if (body && typeof body !== \"string\" && Object.keys(body).length) {\n    if (status === 200) {\n      // @ts-expect-error\n      if (isRSC) delete body.expires\n      return body as R\n    }\n    throw new Error((body as any).message)\n  }\n\n  return null\n}\n\nlet deprecatedWarningShown = false\n\n/** @deprecated renamed to `getServerSession` */\nexport async function unstable_getServerSession<\n  O extends GetServerSessionOptions,\n  R = O[\"callbacks\"] extends { session: (...args: any[]) => infer U }\n    ? U\n    : Session\n>(...args: GetServerSessionParams<O>): Promise<R | null> {\n  if (!deprecatedWarningShown && process.env.NODE_ENV !== \"production\") {\n    console.warn(\n      \"`unstable_getServerSession` has been renamed to `getServerSession`.\"\n    )\n    deprecatedWarningShown = true\n  }\n\n  return await getServerSession(...args)\n}\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace NodeJS {\n    interface ProcessEnv {\n      NEXTAUTH_URL?: string\n      NEXTAUTH_SECRET?: string\n      AUTH_SECRET?: string\n      VERCEL?: \"1\"\n    }\n  }\n}\n"
        }
    ]
}