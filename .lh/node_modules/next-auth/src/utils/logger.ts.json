{
    "sourceFile": "node_modules/next-auth/src/utils/logger.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892936266,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { UnknownError } from \"../core/errors\"\n\n// TODO: better typing\n/** Makes sure that error is always serializable */\nfunction formatError(o: unknown): unknown {\n  if (o instanceof Error && !(o instanceof UnknownError)) {\n    return { message: o.message, stack: o.stack, name: o.name }\n  }\n  if (hasErrorProperty(o)) {\n    o.error = formatError(o.error) as Error\n    o.message = o.message ?? o.error.message\n  }\n  return o\n}\n\nfunction hasErrorProperty(\n  x: unknown\n): x is { error: Error; [key: string]: unknown } {\n  return !!(x as any)?.error\n}\n\nexport type WarningCode =\n  | \"NEXTAUTH_URL\"\n  | \"NO_SECRET\"\n  | \"TWITTER_OAUTH_2_BETA\"\n  | \"DEBUG_ENABLED\"\n\n/**\n * Override any of the methods, and the rest will use the default logger.\n *\n * [Documentation](https://next-auth.js.org/configuration/options#logger)\n */\nexport interface LoggerInstance extends Record<string, Function> {\n  warn: (code: WarningCode) => void\n  error: (\n    code: string,\n    /**\n     * Either an instance of (JSON serializable) Error\n     * or an object that contains some debug information.\n     * (Error is still available through `metadata.error`)\n     */\n    metadata: Error | { error: Error; [key: string]: unknown }\n  ) => void\n  debug: (code: string, metadata: unknown) => void\n}\n\nconst _logger: LoggerInstance = {\n  error(code, metadata) {\n    metadata = formatError(metadata) as Error\n    console.error(\n      `[next-auth][error][${code}]`,\n      `\\nhttps://next-auth.js.org/errors#${code.toLowerCase()}`,\n      metadata.message,\n      metadata\n    )\n  },\n  warn(code) {\n    console.warn(\n      `[next-auth][warn][${code}]`,\n      `\\nhttps://next-auth.js.org/warnings#${code.toLowerCase()}`\n    )\n  },\n  debug(code, metadata) {\n    console.log(`[next-auth][debug][${code}]`, metadata)\n  },\n}\n\n/**\n * Override the built-in logger with user's implementation.\n * Any `undefined` level will use the default logger.\n */\nexport function setLogger(\n  newLogger: Partial<LoggerInstance> = {},\n  debug?: boolean\n) {\n  // Turn off debug logging if `debug` isn't set to `true`\n  if (!debug) _logger.debug = () => {}\n\n  if (newLogger.error) _logger.error = newLogger.error\n  if (newLogger.warn) _logger.warn = newLogger.warn\n  if (newLogger.debug) _logger.debug = newLogger.debug\n}\n\nexport default _logger\n\n/** Serializes client-side log messages and sends them to the server */\nexport function proxyLogger(\n  logger: LoggerInstance = _logger,\n  basePath?: string\n): LoggerInstance {\n  try {\n    if (typeof window === \"undefined\") {\n      return logger\n    }\n\n    const clientLogger: Record<string, unknown> = {}\n    for (const level in logger) {\n      clientLogger[level] = async (code: string, metadata: Error) => {\n        _logger[level](code, metadata) // Logs to console\n\n        if (level === \"error\") {\n          metadata = formatError(metadata) as Error\n        }\n        ;(metadata as any).client = true\n        const url = `${basePath}/_log`\n        const body = new URLSearchParams({ level, code, ...(metadata as any) })\n        if (navigator.sendBeacon) {\n          return navigator.sendBeacon(url, body)\n        }\n        return await fetch(url, { method: \"POST\", body, keepalive: true })\n      }\n    }\n    return clientLogger as unknown as LoggerInstance\n  } catch {\n    return _logger\n  }\n}\n"
        }
    ]
}