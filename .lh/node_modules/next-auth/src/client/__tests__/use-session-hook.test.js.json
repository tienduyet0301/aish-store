{
    "sourceFile": "node_modules/next-auth/src/client/__tests__/use-session-hook.test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932458,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { rest } from \"msw\"\nimport { renderHook } from \"@testing-library/react-hooks\"\nimport { render, waitFor } from \"@testing-library/react\"\nimport { SessionProvider, useSession, signOut } from \"../../react\"\nimport { server, mockSession } from \"./helpers/mocks\"\n\nconst origConsoleError = console.error\nconst { location } = window\n\nlet _href = window.location.href\nbeforeAll(() => {\n  // Prevent noise on the terminal... `next-auth` will log to `console.error`\n  // every time a request fails, which makes the tests output very noisy...\n  console.error = jest.fn()\n\n  // Allows to mutate `window.location`...\n  delete window.location\n  window.location = {}\n  Object.defineProperty(window.location, \"href\", {\n    get: () => _href,\n    // whatwg-fetch or whatwg-url does not seem to work with relative URLs\n    set: (href) => {\n      _href = href.startsWith(\"/\") ? `http://localhost${href}` : href\n      return _href\n    },\n  })\n\n  server.listen()\n})\n\nafterEach(() => {\n  server.resetHandlers()\n  _href = \"http://localhost/\"\n\n  // clear the internal session cache...\n  signOut({ redirect: false })\n})\n\nafterAll(() => {\n  console.error = origConsoleError\n  window.location = location\n  server.close()\n})\n\ntest(\"it won't allow to fetch the session in isolation without a session context\", () => {\n  function App() {\n    useSession()\n    return null\n  }\n\n  expect(() => render(<App />)).toThrow(\n    \"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\"\n  )\n})\n\ntest(\"when fetching the session, there won't be `data` and `status` will be 'loading'\", () => {\n  const { result } = renderHook(() => useSession(), {\n    wrapper: SessionProvider,\n  })\n\n  expect(result.current.data).toBe(undefined)\n  expect(result.current.status).toBe(\"loading\")\n})\n\ntest(\"when session is fetched, `data` will contain the session data and `status` will be 'authenticated'\", async () => {\n  const { result } = renderHook(() => useSession(), {\n    wrapper: SessionProvider,\n  })\n\n  await waitFor(() => {\n    expect(result.current.data).toEqual(mockSession)\n    expect(result.current.status).toBe(\"authenticated\")\n  })\n})\n\ntest(\"when it fails to fetch the session, `data` will be null and `status` will be 'unauthenticated'\", async () => {\n  server.use(\n    rest.get(`http://localhost/api/auth/session`, (_, res, ctx) =>\n      res(ctx.status(401), ctx.json({}))\n    )\n  )\n\n  const { result } = renderHook(() => useSession(), {\n    wrapper: SessionProvider,\n  })\n\n  return waitFor(() => {\n    expect(result.current.data).toEqual(null)\n    expect(result.current.status).toBe(\"unauthenticated\")\n  })\n})\n\ntest(\"it'll redirect to sign-in page if the session is required and the user is not authenticated\", async () => {\n  server.use(\n    rest.get(`http://localhost/api/auth/session`, (req, res, ctx) =>\n      res(ctx.status(401), ctx.json({}))\n    )\n  )\n\n  const callbackUrl = window.location.href\n  const { result } = renderHook(() => useSession({ required: true }), {\n    wrapper: SessionProvider,\n  })\n\n  await waitFor(() => {\n    expect(result.current.data).toEqual(null)\n    expect(result.current.status).toBe(\"loading\")\n  })\n\n  expect(window.location.href).toBe(\n    `http://localhost/api/auth/signin?${new URLSearchParams({\n      error: \"SessionRequired\",\n      callbackUrl,\n    })}`\n  )\n})\n\ntest(\"will call custom redirect logic if supplied when the user could not authenticate\", async () => {\n  server.use(\n    rest.get(`http://localhost/api/auth/session`, (_, res, ctx) =>\n      res(ctx.status(401), ctx.json({}))\n    )\n  )\n\n  const customRedirect = jest.fn()\n\n  const { result } = renderHook(\n    () => useSession({ required: true, onUnauthenticated: customRedirect }),\n    {\n      wrapper: SessionProvider,\n    }\n  )\n\n  await waitFor(() => {\n    expect(result.current.data).toEqual(null)\n    expect(result.current.status).toBe(\"loading\")\n  })\n\n  expect(customRedirect).toHaveBeenCalledTimes(1)\n})\n"
        }
    ]
}