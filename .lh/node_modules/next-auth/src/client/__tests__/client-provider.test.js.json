{
    "sourceFile": "node_modules/next-auth/src/client/__tests__/client-provider.test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892931959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { rest } from \"msw\"\nimport { render, screen, waitFor } from \"@testing-library/react\"\nimport { server, mockSession } from \"./helpers/mocks\"\nimport { printFetchCalls } from \"./helpers/utils\"\nimport { SessionProvider, useSession, signOut, getSession } from \"../../react\"\n\nconst origDocumentVisibility = document.visibilityState\nconst fetchSpy = jest.spyOn(global, \"fetch\")\n\nbeforeAll(() => {\n  server.listen()\n})\n\nafterEach(() => {\n  server.resetHandlers()\n  changeTabVisibility(origDocumentVisibility)\n  fetchSpy.mockClear()\n})\n\nafterAll(() => {\n  server.close()\n})\n\ntest(\"fetches the session once and re-uses it for different consumers\", async () => {\n  render(<ProviderFlow />)\n\n  expect(screen.getByTestId(\"session-1\")).toHaveTextContent(\"loading\")\n  expect(screen.getByTestId(\"session-2\")).toHaveTextContent(\"loading\")\n\n  return waitFor(() => {\n    expect(fetchSpy).toHaveBeenCalledTimes(1)\n\n    expect(fetchSpy).toHaveBeenCalledWith(\n      \"/api/auth/session\",\n      expect.anything()\n    )\n\n    const session1 = screen.getByTestId(\"session-1\").textContent\n    const session2 = screen.getByTestId(\"session-2\").textContent\n\n    expect(session1).toEqual(session2)\n  })\n})\n\ntest(\"when there's an existing session, it won't try to fetch a new one straightaway\", async () => {\n  render(<ProviderFlow session={mockSession} />)\n\n  expect(fetchSpy).not.toHaveBeenCalled()\n})\n\ntest(\"will refetch the session when the browser tab becomes active again\", async () => {\n  render(<ProviderFlow session={mockSession} />)\n\n  expect(fetchSpy).not.toHaveBeenCalled()\n\n  // Hide the current tab\n  changeTabVisibility(\"hidden\")\n\n  // Given the current tab got hidden, it should not attempt to re-fetch the session\n  expect(fetchSpy).not.toHaveBeenCalled()\n\n  // Make the tab again visible\n  changeTabVisibility(\"visible\")\n\n  // Given the user made the tab visible again, now attempts to sync and re-fetch the session\n  return waitFor(() => {\n    expect(fetchSpy).toHaveBeenCalledTimes(1)\n    expect(fetchSpy).toHaveBeenCalledWith(\n      \"/api/auth/session\",\n      expect.anything()\n    )\n  })\n})\n\ntest(\"will refetch the session if told to do so programmatically from another window\", async () => {\n  render(<ProviderFlow session={mockSession} />)\n\n  expect(fetchSpy).not.toHaveBeenCalled()\n\n  // Hide the current tab\n  changeTabVisibility(\"hidden\")\n\n  // Given the current tab got hidden, it should not attempt to re-fetch the session\n  expect(fetchSpy).not.toHaveBeenCalled()\n\n  // simulate sign-out triggered by another tab\n  signOut({ redirect: false })\n\n  // Given signed out in another tab, it attempts to sync and re-fetch the session\n  return waitFor(() => {\n    expect(fetchSpy).toHaveBeenCalledWith(\n      \"/api/auth/session\",\n      expect.anything()\n    )\n\n    // We should have a call to sign-out and a call to refetch the session accordingly\n    expect(printFetchCalls(fetchSpy.mock.calls)).toMatchInlineSnapshot(`\n      Array [\n        \"GET /api/auth/csrf\",\n        \"POST /api/auth/signout\",\n        \"GET /api/auth/session\",\n      ]\n    `)\n  })\n})\n\ntest(\"allows to customize how often the session will be re-fetched through polling\", () => {\n  jest.useFakeTimers()\n\n  render(<ProviderFlow session={mockSession} refetchInterval={1} />)\n\n  // we provided a mock session so it shouldn't try to fetch a new one\n  expect(fetchSpy).not.toHaveBeenCalled()\n\n  jest.advanceTimersByTime(1000)\n\n  expect(fetchSpy).toHaveBeenCalledTimes(1)\n  expect(fetchSpy).toHaveBeenCalledWith(\"/api/auth/session\", expect.anything())\n\n  jest.advanceTimersByTime(1000)\n\n  // it should have tried to refetch the session, hence counting 2 calls to the session endpoint\n  expect(fetchSpy).toHaveBeenCalledTimes(2)\n  expect(printFetchCalls(fetchSpy.mock.calls)).toMatchInlineSnapshot(`\n      Array [\n        \"GET /api/auth/session\",\n        \"GET /api/auth/session\",\n      ]\n    `)\n})\n\ntest(\"allows to customize the URL for session fetching\", async () => {\n  const myPath = \"/api/v1/auth\"\n\n  server.use(\n    rest.get(`${myPath}/session`, (req, res, ctx) =>\n      res(ctx.status(200), ctx.json(mockSession))\n    )\n  )\n\n  render(<ProviderFlow session={mockSession} basePath={myPath} />)\n\n  // there's an existing session so it should not try to fetch a new one\n  expect(fetchSpy).not.toHaveBeenCalled()\n\n  // force a session refetch across all clients...\n  getSession()\n\n  return waitFor(() => {\n    expect(fetchSpy).toHaveBeenCalledTimes(1)\n    expect(fetchSpy).toHaveBeenCalledWith(\n      `${myPath}/session`,\n      expect.anything()\n    )\n  })\n})\n\nfunction ProviderFlow(props) {\n  return (\n    <SessionProvider {...props}>\n      <SessionConsumer />\n      <SessionConsumer testId=\"2\" />\n    </SessionProvider>\n  )\n}\n\nfunction SessionConsumer({ testId = 1, ...rest }) {\n  const { data: session, status } = useSession(rest)\n\n  return (\n    <div data-testid={`session-${testId}`}>\n      {status === \"loading\" ? \"loading\" : JSON.stringify(session)}\n    </div>\n  )\n}\n\nfunction changeTabVisibility(status) {\n  const visibleStates = [\"visible\", \"hidden\"]\n\n  if (!visibleStates.includes(status)) return\n\n  Object.defineProperty(document, \"visibilityState\", {\n    configurable: true,\n    value: status,\n  })\n\n  document.dispatchEvent(new Event(\"visibilitychange\"))\n}\n"
        }
    ]
}