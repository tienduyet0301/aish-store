{
    "sourceFile": "node_modules/next-auth/src/client/__tests__/session.test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { render, screen, waitFor } from \"@testing-library/react\"\nimport { rest } from \"msw\"\nimport { server, mockSession } from \"./helpers/mocks\"\nimport logger from \"../../utils/logger\"\nimport { useState, useEffect } from \"react\"\nimport { getSession } from \"../../react\"\nimport { getBroadcastEvents } from \"./helpers/utils\"\n\njest.mock(\"../../utils/logger\", () => ({\n  __esModule: true,\n  default: {\n    warn: jest.fn(),\n    debug: jest.fn(),\n    error: jest.fn(),\n  },\n  proxyLogger(logger) {\n    return logger\n  },\n}))\n\nbeforeAll(() => server.listen())\n\nbeforeEach(() => {\n  // eslint-disable-next-line no-proto\n  jest.spyOn(window.localStorage.__proto__, \"setItem\")\n})\n\nafterEach(() => {\n  server.resetHandlers()\n  jest.clearAllMocks()\n})\n\nafterAll(() => {\n  server.close()\n})\n\ntest(\"if it can fetch the session, it should store it in `localStorage`\", async () => {\n  render(<SessionFlow />)\n\n  // In the start, there is no session\n  const noSession = await screen.findByText(\"No session\")\n  expect(noSession).toBeInTheDocument()\n\n  // After we fetched the session, it should have been rendered by `<SessionFlow />`\n  const session = await screen.findByText(new RegExp(mockSession.user.name))\n  expect(session).toBeInTheDocument()\n\n  const broadcastCalls = getBroadcastEvents()\n  const [broadcastedEvent] = broadcastCalls\n\n  expect(broadcastCalls).toHaveLength(1)\n  expect(broadcastCalls).toHaveLength(1)\n  expect(broadcastedEvent.eventName).toBe(\"nextauth.message\")\n  expect(broadcastedEvent.value).toStrictEqual({\n    data: {\n      trigger: \"getSession\",\n    },\n    event: \"session\",\n  })\n})\n\ntest(\"if there's an error fetching the session, it should log it\", async () => {\n  server.use(\n    rest.get(\"*/api/auth/session\", (req, res, ctx) => {\n      return res(ctx.status(500), ctx.body(\"Server error\"))\n    })\n  )\n\n  render(<SessionFlow />)\n\n  await waitFor(() => {\n    expect(logger.error).toHaveBeenCalledTimes(1)\n    expect(logger.error).toBeCalledWith(\"CLIENT_FETCH_ERROR\", {\n      url: \"/api/auth/session\",\n      error: new SyntaxError(\"Unexpected token S in JSON at position 0\"),\n    })\n  })\n})\n\nfunction SessionFlow() {\n  const [session, setSession] = useState(null)\n  useEffect(() => {\n    async function fetchUserSession() {\n      try {\n        const result = await getSession()\n        setSession(result)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n    fetchUserSession()\n  }, [])\n\n  if (session) return <pre>{JSON.stringify(session, null, 2)}</pre>\n\n  return <p>No session</p>\n}\n"
        }
    ]
}