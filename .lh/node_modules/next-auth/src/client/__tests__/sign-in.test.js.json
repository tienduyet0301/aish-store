{
    "sourceFile": "node_modules/next-auth/src/client/__tests__/sign-in.test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892932320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { useState } from \"react\"\nimport userEvent from \"@testing-library/user-event\"\nimport { render, screen, waitFor } from \"@testing-library/react\"\nimport logger from \"../../utils/logger\"\nimport {\n  server,\n  mockCredentialsResponse,\n  mockEmailResponse,\n  mockGithubResponse,\n} from \"./helpers/mocks\"\nimport { signIn } from \"../../react\"\nimport { rest } from \"msw\"\n\nconst { location } = window\n\njest.mock(\"../../utils/logger\", () => ({\n  __esModule: true,\n  default: {\n    warn: jest.fn(),\n    debug: jest.fn(),\n    error: jest.fn(),\n  },\n  proxyLogger(logger) {\n    return logger\n  },\n}))\n\nbeforeAll(() => {\n  server.listen()\n\n  let _href = window.location.href\n  // Allows to mutate `window.location`...\n  delete window.location\n\n  window.location = {\n    reload: jest.fn(),\n  }\n  Object.defineProperty(window.location, \"href\", {\n    get: () => _href,\n    // whatwg-fetch or whatwg-url does not seem to work with relative URLs\n    set: (href) => {\n      _href = href.startsWith(\"/\") ? `http://localhost${href}` : href\n      return _href\n    },\n  })\n})\n\nbeforeEach(() => {\n  jest.clearAllMocks()\n  server.resetHandlers()\n})\n\nafterAll(() => {\n  window.location = location\n  server.close()\n})\n\nconst callbackUrl = \"https://redirects/to\"\n\ntest.each`\n  provider | type\n  ${\"\"}    | ${\"no\"}\n  ${\"foo\"} | ${\"unknown\"}\n`(\n  \"if $type provider, it redirects to the default sign-in page\",\n  async ({ provider }) => {\n    render(<SignInFlow providerId={provider} callbackUrl={callbackUrl} />)\n\n    userEvent.click(screen.getByRole(\"button\"))\n\n    await waitFor(() => {\n      expect(window.location.href).toBe(\n        `http://localhost/api/auth/signin?${new URLSearchParams({\n          callbackUrl,\n        })}`\n      )\n    })\n  }\n)\n\ntest.each`\n  provider | type\n  ${\"\"}    | ${\"no\"}\n  ${\"foo\"} | ${\"unknown\"}\n`(\n  \"if $type provider supplied and no callback URL, redirects using the current location\",\n  async ({ provider }) => {\n    render(<SignInFlow providerId={provider} />)\n\n    const callbackUrl = window.location.href\n    userEvent.click(screen.getByRole(\"button\"))\n\n    await waitFor(() => {\n      expect(window.location.href).toBe(\n        `http://localhost/api/auth/signin?${new URLSearchParams({\n          callbackUrl,\n        })}`\n      )\n    })\n  }\n)\n\ntest.each`\n  provider         | mockUrl\n  ${`email`}       | ${mockEmailResponse.url}\n  ${`credentials`} | ${mockCredentialsResponse.url}\n`(\n  \"$provider provider redirects if `redirect` is `true`\",\n  async ({ provider, mockUrl }) => {\n    render(<SignInFlow providerId={provider} redirect={true} />)\n\n    userEvent.click(screen.getByRole(\"button\"))\n\n    await waitFor(() => {\n      expect(window.location.href).toBe(mockUrl)\n    })\n  }\n)\n\ntest(\"redirection can't be stopped using an oauth provider\", async () => {\n  render(\n    <SignInFlow\n      providerId=\"github\"\n      callbackUrl={callbackUrl}\n      redirect={false}\n    />\n  )\n\n  userEvent.click(screen.getByRole(\"button\"))\n\n  await waitFor(() => {\n    expect(window.location.href).toBe(mockGithubResponse.url)\n  })\n})\n\ntest(\"redirection can be stopped using the 'credentials' provider\", async () => {\n  render(\n    <SignInFlow\n      providerId=\"credentials\"\n      callbackUrl={callbackUrl}\n      redirect={false}\n    />\n  )\n\n  userEvent.click(screen.getByRole(\"button\"))\n\n  await waitFor(() => {\n    expect(window.location.href).not.toBe(mockCredentialsResponse.url)\n\n    expect(screen.getByTestId(\"signin-result\").textContent).not.toBe(\n      \"no response\"\n    )\n  })\n\n  // snapshot the expected return shape from `signIn`\n  expect(JSON.parse(screen.getByTestId(\"signin-result\").textContent))\n    .toMatchInlineSnapshot(`\n    Object {\n      \"error\": null,\n      \"ok\": true,\n      \"status\": 200,\n      \"url\": \"https://path/to/credentials/url\",\n    }\n  `)\n})\n\ntest(\"redirection can be stopped using the 'email' provider\", async () => {\n  render(\n    <SignInFlow providerId=\"email\" callbackUrl={callbackUrl} redirect={false} />\n  )\n\n  userEvent.click(screen.getByRole(\"button\"))\n\n  await waitFor(() => {\n    expect(window.location.href).not.toBe(mockEmailResponse.url)\n\n    expect(screen.getByTestId(\"signin-result\").textContent).not.toBe(\n      \"no response\"\n    )\n  })\n\n  // snapshot the expected return shape from `signIn` oauth\n  expect(JSON.parse(screen.getByTestId(\"signin-result\").textContent))\n    .toMatchInlineSnapshot(`\n    Object {\n      \"error\": null,\n      \"ok\": true,\n      \"status\": 200,\n      \"url\": \"https://path/to/email/url\",\n    }\n  `)\n})\n\ntest(\"if callback URL contains a hash we force a window reload when re-directing\", async () => {\n  const mockUrlWithHash = \"https://path/to/email/url#foo-bar-baz\"\n\n  server.use(\n    rest.post(\"*/api/auth/signin/email\", (req, res, ctx) => {\n      return res(\n        ctx.status(200),\n        ctx.json({\n          ...mockEmailResponse,\n          url: mockUrlWithHash,\n        })\n      )\n    })\n  )\n\n  render(<SignInFlow providerId=\"email\" callbackUrl={mockUrlWithHash} />)\n\n  userEvent.click(screen.getByRole(\"button\"))\n\n  await waitFor(() => {\n    expect(window.location.href).toBe(mockUrlWithHash)\n    // the browser will not refresh the page if the redirect URL contains a hash, hence we force it on the client, see #1289\n    expect(window.location.reload).toHaveBeenCalledTimes(1)\n  })\n})\n\ntest(\"params are propagated to the signin URL when supplied\", async () => {\n  let matchedParams = \"\"\n  const authParams = \"foo=bar&bar=foo\"\n\n  server.use(\n    rest.post(\"*/auth/signin/github\", (req, res, ctx) => {\n      matchedParams = req.url.search\n      return res(ctx.status(200), ctx.json(mockGithubResponse))\n    })\n  )\n\n  render(<SignInFlow providerId=\"github\" authorizationParams={authParams} />)\n\n  userEvent.click(screen.getByRole(\"button\"))\n\n  await waitFor(() => {\n    expect(matchedParams).toEqual(`?${authParams}`)\n  })\n})\n\ntest(\"when it fails to fetch the providers, it redirected back to signin page\", async () => {\n  const errorMsg = \"Error when retrieving providers\"\n\n  server.use(\n    rest.get(\"*/api/auth/providers\", (req, res, ctx) =>\n      res(ctx.status(500), ctx.json(errorMsg))\n    )\n  )\n\n  render(<SignInFlow providerId=\"github\" />)\n\n  userEvent.click(screen.getByRole(\"button\"))\n\n  await waitFor(() => {\n    expect(window.location.href).toBe(`http://localhost/api/auth/error`)\n\n    expect(logger.error).toHaveBeenCalledTimes(1)\n    expect(logger.error).toBeCalledWith(\"CLIENT_FETCH_ERROR\", {\n      error: \"Error when retrieving providers\",\n      url: \"/api/auth/providers\",\n    })\n  })\n})\n\nfunction SignInFlow({\n  providerId,\n  callbackUrl,\n  redirect = true,\n  authorizationParams = {},\n}) {\n  const [response, setResponse] = useState(null)\n\n  async function handleSignIn() {\n    const result = await signIn(\n      providerId,\n      { callbackUrl, redirect },\n      authorizationParams\n    )\n\n    setResponse(result)\n  }\n\n  return (\n    <>\n      <p data-testid=\"signin-result\">\n        {response ? JSON.stringify(response) : \"no response\"}\n      </p>\n      <button onClick={handleSignIn}>Sign in</button>\n    </>\n  )\n}\n"
        }
    ]
}