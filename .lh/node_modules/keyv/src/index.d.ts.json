{
    "sourceFile": "node_modules/keyv/src/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892382539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import {EventEmitter} from 'events';\n\ntype WithRequiredProperties<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\ndeclare class Keyv<Value = any, Options extends Record<string, any> = Record<string, unknown>> extends EventEmitter {\n\t/**\n     * `this.opts` is an object containing at least the properties listed\n     * below. However, `Keyv.Options` allows arbitrary properties as well.\n     * These properties can be specified as the second type parameter to `Keyv`.\n     */\n\topts: WithRequiredProperties<\n\tKeyv.Options<Value>,\n\t'deserialize' | 'namespace' | 'serialize' | 'store' | 'uri'\n\t> &\n\tOptions;\n\n\t/**\n     * @param opts The options object is also passed through to the storage adapter. Check your storage adapter docs for any extra options.\n     */\n\tconstructor(options?: Keyv.Options<Value> & Options);\n\t/**\n     * @param uri The connection string URI.\n     *\n     * Merged into the options object as options.uri.\n     * @param opts The options object is also passed through to the storage adapter. Check your storage adapter docs for any extra options.\n     */\n\tconstructor(uri?: string, options?: Keyv.Options<Value> & Options);\n\n\t/** Returns the value. */\n\tget(key: string, options?: {raw?: false}): Promise<Value | undefined>;\n\t/** Returns the raw value. */\n\tget(key: string, options: {raw: true}): Promise<Keyv.DeserializedData<Value> | undefined>;\n\n\t/** Returns an array of values. Uses `store.getMany` if it exists, otherwise uses parallel calls to `store.get`. */\n\tget(key: string[], options?: {raw?: false}): Promise<Array<Value | undefined>>;\n\t/** Returns an array of raw values. Uses `store.getMany` if it exists, otherwise uses parallel calls to `store.get`. */\n\tget(key: string[], options: {raw: true}): Promise<Array<Keyv.DeserializedData<Value> | undefined>>;\n\n\t/**\n     * Set a value.\n     *\n     * By default keys are persistent. You can set an expiry TTL in milliseconds.\n     */\n\tset(key: string, value: Value, ttl?: number): Promise<true>;\n\t/**\n     * Deletes an entry.\n     *\n     * Returns `true` if the key existed, `false` if not.\n     */\n\tdelete(key: string | string[]): Promise<boolean>;\n\t/** Delete all entries in the current namespace. */\n\tclear(): Promise<void>;\n\t/** Check if key exists in current namespace. */\n\thas(key: string): Promise<boolean>;\n\t/** Iterator */\n\titerator(namespace?: string): AsyncGenerator<any, void, any>;\n\t/**\n\t * Closes the connection.\n\t *\n\t * Returns `undefined` when the connection closes.\n\t */\n\tdisconnect(): Promise<void>;\n}\n\ndeclare namespace Keyv {\n\tinterface Options<Value> {\n\t\t[key: string]: any;\n\n\t\t/** Namespace for the current instance. */\n\t\tnamespace?: string | undefined;\n\t\t/** A custom serialization function. */\n\t\tserialize?: ((data: DeserializedData<Value>) => string) | undefined;\n\t\t/** A custom deserialization function. */\n\t\tdeserialize?: ((data: string) => DeserializedData<Value> | undefined) | undefined;\n\t\t/** The connection string URI. */\n\t\turi?: string | undefined;\n\t\t/** The storage adapter instance to be used by Keyv. */\n\t\tstore?: Store<string | undefined> | undefined;\n\t\t/** Default TTL. Can be overridden by specififying a TTL on `.set()`. */\n\t\tttl?: number | undefined;\n\t\t/** Specify an adapter to use. e.g `'redis'` or `'mongodb'`. */\n\t\tadapter?: 'redis' | 'mongodb' | 'mongo' | 'sqlite' | 'postgresql' | 'postgres' | 'mysql' | undefined;\n\t\t/** Enable compression option **/\n\t\tcompression?: CompressionAdapter | undefined;\n\t}\n\n\tinterface CompressionAdapter {\n\t\tcompress(value: any, options?: any): Promise<any>;\n\t\tdecompress(value: any, options?: any): Promise<any>;\n\t\tserialize(value: any): Promise<any>;\n\t\tdeserialize(value: any): Promise<any>;\n\t}\n\n\tinterface DeserializedData<Value> {\n\t\tvalue: Value; expires: number | undefined;\n\t}\n\n\ttype StoredData<Value> = DeserializedData<Value> | string | undefined;\n\n\tinterface Store<Value> {\n\t\tget(key: string): Value | Promise<Value | undefined> | undefined;\n\t\tset(key: string, value: Value, ttl?: number): any;\n\t\tdelete(key: string): boolean | Promise<boolean>;\n\t\tclear(): void | Promise<void>;\n\t\thas?(key: string): boolean | Promise<boolean>;\n\t\tgetMany?(\n\t\t\tkeys: string[]\n\t\t): Array<StoredData<Value>> | Promise<Array<StoredData<Value>>> | undefined;\n\t}\n}\n\nexport = Keyv;\n"
        }
    ]
}