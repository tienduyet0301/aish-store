{
    "sourceFile": "node_modules/@react-types/shared/src/events.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891922438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from './dom';\nimport {\n  FocusEvent,\n  MouseEvent,\n  KeyboardEvent as ReactKeyboardEvent,\n  SyntheticEvent\n} from 'react';\n\n// Event bubbling can be problematic in real-world applications, so the default for React Spectrum components\n// is not to propagate. This can be overridden by calling continuePropagation() on the event.\nexport type BaseEvent<T extends SyntheticEvent> = T & {\n  /**\n   * Use continuePropagation.\n   * @deprecated */\n  stopPropagation(): void,\n  continuePropagation(): void\n}\n\nexport type KeyboardEvent = BaseEvent<ReactKeyboardEvent<any>>;\n\nexport type PointerType = 'mouse' | 'pen' | 'touch' | 'keyboard' | 'virtual';\n\nexport interface PressEvent {\n  /** The type of press event being fired. */\n  type: 'pressstart' | 'pressend' | 'pressup' | 'press',\n  /** The pointer type that triggered the press event. */\n  pointerType: PointerType,\n  /** The target element of the press event. */\n  target: Element,\n  /** Whether the shift keyboard modifier was held during the press event. */\n  shiftKey: boolean,\n  /** Whether the ctrl keyboard modifier was held during the press event. */\n  ctrlKey: boolean,\n  /** Whether the meta keyboard modifier was held during the press event. */\n  metaKey: boolean,\n  /** Whether the alt keyboard modifier was held during the press event. */\n  altKey: boolean,\n  /** X position relative to the target. */\n  x: number,\n  /** Y position relative to the target. */\n  y: number,\n  /**\n   * By default, press events stop propagation to parent elements.\n   * In cases where a handler decides not to handle a specific event,\n   * it can call `continuePropagation()` to allow a parent to handle it.\n   */\n  continuePropagation(): void\n}\n\nexport interface LongPressEvent extends Omit<PressEvent, 'type' | 'continuePropagation'> {\n  /** The type of long press event being fired. */\n  type: 'longpressstart' | 'longpressend' | 'longpress'\n}\n\nexport interface HoverEvent {\n  /** The type of hover event being fired. */\n  type: 'hoverstart' | 'hoverend',\n  /** The pointer type that triggered the hover event. */\n  pointerType: 'mouse' | 'pen',\n  /** The target element of the hover event. */\n  target: HTMLElement\n}\n\nexport interface KeyboardEvents {\n  /** Handler that is called when a key is pressed. */\n  onKeyDown?: (e: KeyboardEvent) => void,\n  /** Handler that is called when a key is released. */\n  onKeyUp?: (e: KeyboardEvent) => void\n}\n\nexport interface FocusEvents<Target = Element> {\n  /** Handler that is called when the element receives focus. */\n  onFocus?: (e: FocusEvent<Target>) => void,\n  /** Handler that is called when the element loses focus. */\n  onBlur?: (e: FocusEvent<Target>) => void,\n  /** Handler that is called when the element's focus status changes. */\n  onFocusChange?: (isFocused: boolean) => void\n}\n\nexport interface HoverEvents {\n  /** Handler that is called when a hover interaction starts. */\n  onHoverStart?: (e: HoverEvent) => void,\n  /** Handler that is called when a hover interaction ends. */\n  onHoverEnd?: (e: HoverEvent) => void,\n  /** Handler that is called when the hover state changes. */\n  onHoverChange?: (isHovering: boolean) => void\n}\n\nexport interface PressEvents {\n  /** Handler that is called when the press is released over the target. */\n  onPress?: (e: PressEvent) => void,\n  /** Handler that is called when a press interaction starts. */\n  onPressStart?: (e: PressEvent) => void,\n  /**\n   * Handler that is called when a press interaction ends, either\n   * over the target or when the pointer leaves the target.\n   */\n  onPressEnd?: (e: PressEvent) => void,\n  /** Handler that is called when the press state changes. */\n  onPressChange?: (isPressed: boolean) => void,\n  /**\n   * Handler that is called when a press is released over the target, regardless of\n   * whether it started on the target or not.\n   */\n  onPressUp?: (e: PressEvent) => void,\n  /**\n   * **Not recommended â€“ use `onPress` instead.** `onClick` is an alias for `onPress`\n   * provided for compatibility with other libraries. `onPress` provides \n   * additional event details for non-mouse interactions.\n   */\n  onClick?: (e: MouseEvent<FocusableElement>) => void\n}\n\nexport interface FocusableProps<Target = Element> extends FocusEvents<Target>, KeyboardEvents {\n  /** Whether the element should receive focus on render. */\n  autoFocus?: boolean\n}\n\ninterface BaseMoveEvent {\n  /** The pointer type that triggered the move event. */\n  pointerType: PointerType,\n  /** Whether the shift keyboard modifier was held during the move event. */\n  shiftKey: boolean,\n  /** Whether the ctrl keyboard modifier was held during the move event. */\n  ctrlKey: boolean,\n  /** Whether the meta keyboard modifier was held during the move event. */\n  metaKey: boolean,\n  /** Whether the alt keyboard modifier was held during the move event. */\n  altKey: boolean\n}\n\nexport interface MoveStartEvent extends BaseMoveEvent {\n  /** The type of move event being fired. */\n  type: 'movestart'\n}\n\nexport interface MoveMoveEvent extends BaseMoveEvent {\n  /** The type of move event being fired. */\n  type: 'move',\n  /** The amount moved in the X direction since the last event. */\n  deltaX: number,\n  /** The amount moved in the Y direction since the last event. */\n  deltaY: number\n\n}\n\nexport interface MoveEndEvent extends BaseMoveEvent {\n  /** The type of move event being fired. */\n  type: 'moveend'\n}\n\nexport type MoveEvent = MoveStartEvent | MoveMoveEvent | MoveEndEvent;\n\nexport interface MoveEvents {\n  /** Handler that is called when a move interaction starts. */\n  onMoveStart?: (e: MoveStartEvent) => void,\n  /** Handler that is called when the element is moved. */\n  onMove?: (e: MoveMoveEvent) => void,\n  /** Handler that is called when a move interaction ends. */\n  onMoveEnd?: (e: MoveEndEvent) => void\n}\n\nexport interface ScrollEvent {\n  /** The amount moved in the X direction since the last event. */\n  deltaX: number,\n  /** The amount moved in the Y direction since the last event. */\n  deltaY: number\n}\n\nexport interface ScrollEvents {\n  /** Handler that is called when the scroll wheel moves. */\n  onScroll?: (e: ScrollEvent) => void\n}\n"
        }
    ]
}