{
    "sourceFile": "node_modules/has-symbols/test/tests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892324106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\n/** @type {(t: import('tape').Test) => false | void} */\n// eslint-disable-next-line consistent-return\nmodule.exports = function runSymbolTests(t) {\n\tt.equal(typeof Symbol, 'function', 'global Symbol is a function');\n\n\tif (typeof Symbol !== 'function') { return false; }\n\n\tt.notEqual(Symbol(), Symbol(), 'two symbols are not equal');\n\n\t/*\n\tt.equal(\n\t\tSymbol.prototype.toString.call(Symbol('foo')),\n\t\tSymbol.prototype.toString.call(Symbol('foo')),\n\t\t'two symbols with the same description stringify the same'\n\t);\n\t*/\n\n\t/*\n\tvar foo = Symbol('foo');\n\n\tt.notEqual(\n\t\tString(foo),\n\t\tString(Symbol('bar')),\n\t\t'two symbols with different descriptions do not stringify the same'\n\t);\n\t*/\n\n\tt.equal(typeof Symbol.prototype.toString, 'function', 'Symbol#toString is a function');\n\t// t.equal(String(foo), Symbol.prototype.toString.call(foo), 'Symbol#toString equals String of the same symbol');\n\n\tt.equal(typeof Object.getOwnPropertySymbols, 'function', 'Object.getOwnPropertySymbols is a function');\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tt.notEqual(typeof sym, 'string', 'Symbol is not a string');\n\tt.equal(Object.prototype.toString.call(sym), '[object Symbol]', 'symbol primitive Object#toStrings properly');\n\tt.equal(Object.prototype.toString.call(symObj), '[object Symbol]', 'symbol primitive Object#toStrings properly');\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\t// eslint-disable-next-line no-restricted-syntax, no-unused-vars\n\tfor (var _ in obj) { t.fail('symbol property key was found in for..in of object'); }\n\n\tt.deepEqual(Object.keys(obj), [], 'no enumerable own keys on symbol-valued object');\n\tt.deepEqual(Object.getOwnPropertyNames(obj), [], 'no own names on symbol-valued object');\n\tt.deepEqual(Object.getOwnPropertySymbols(obj), [sym], 'one own symbol on symbol-valued object');\n\tt.equal(Object.prototype.propertyIsEnumerable.call(obj, sym), true, 'symbol is enumerable');\n\tt.deepEqual(Object.getOwnPropertyDescriptor(obj, sym), {\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t\tvalue: 42,\n\t\twritable: true\n\t}, 'property descriptor is correct');\n};\n"
        }
    ]
}