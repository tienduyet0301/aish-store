{
    "sourceFile": "node_modules/eslint-import-resolver-typescript/lib/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892246350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import fs from 'node:fs';\nimport path from 'node:path';\nimport isNodeCoreModule from '@nolyfill/is-core-module';\nimport debug from 'debug';\nimport enhancedResolve from 'enhanced-resolve';\nimport { createPathsMatcher, getTsconfig } from 'get-tsconfig';\nimport { isBunModule } from 'is-bun-module';\nimport stableHashExports from 'stable-hash';\nimport { globSync, isDynamicPattern } from 'tinyglobby';\nconst stableHash = stableHashExports.default || stableHashExports;\nconst IMPORTER_NAME = 'eslint-import-resolver-typescript';\nconst log = debug(IMPORTER_NAME);\nexport const defaultConditionNames = [\n    'types',\n    'import',\n    'esm2020',\n    'es2020',\n    'es2015',\n    'require',\n    'node',\n    'node-addons',\n    'browser',\n    'default',\n];\nexport const defaultExtensions = [\n    '.ts',\n    '.tsx',\n    '.d.ts',\n    '.js',\n    '.jsx',\n    '.json',\n    '.node',\n];\nexport const defaultExtensionAlias = {\n    '.js': [\n        '.ts',\n        '.tsx',\n        '.d.ts',\n        '.js',\n    ],\n    '.jsx': ['.tsx', '.d.ts', '.jsx'],\n    '.cjs': ['.cts', '.d.cts', '.cjs'],\n    '.mjs': ['.mts', '.d.mts', '.mjs'],\n};\nexport const defaultMainFields = [\n    'types',\n    'typings',\n    'fesm2020',\n    'fesm2015',\n    'esm2020',\n    'es2020',\n    'module',\n    'jsnext:main',\n    'main',\n];\nexport const interfaceVersion = 2;\nconst fileSystem = fs;\nconst JS_EXT_PATTERN = /\\.(?:[cm]js|jsx?)$/;\nconst RELATIVE_PATH_PATTERN = /^\\.{1,2}(?:\\/.*)?$/;\nlet previousOptionsHash;\nlet optionsHash;\nlet cachedOptions;\nlet prevCwd;\nlet mappersCachedOptions;\nlet mappers = [];\nlet resolverCachedOptions;\nlet cachedResolver;\nexport function resolve(source, file, options, resolver = null) {\n    if (!cachedOptions ||\n        previousOptionsHash !== (optionsHash = stableHash(options))) {\n        previousOptionsHash = optionsHash;\n        cachedOptions = {\n            ...options,\n            conditionNames: options?.conditionNames ?? defaultConditionNames,\n            extensions: options?.extensions ?? defaultExtensions,\n            extensionAlias: options?.extensionAlias ?? defaultExtensionAlias,\n            mainFields: options?.mainFields ?? defaultMainFields,\n            fileSystem: new enhancedResolve.CachedInputFileSystem(fileSystem, 5 * 1000),\n            useSyncFileSystemCalls: true,\n        };\n    }\n    if (!resolver) {\n        if (!cachedResolver || resolverCachedOptions !== cachedOptions) {\n            cachedResolver =\n                enhancedResolve.ResolverFactory.createResolver(cachedOptions);\n            resolverCachedOptions = cachedOptions;\n        }\n        resolver = cachedResolver;\n    }\n    log('looking for', source, 'in', file);\n    source = removeQuerystring(source);\n    if (isNodeCoreModule(source) ||\n        isBunModule(source, (process.versions.bun ?? 'latest'))) {\n        log('matched core:', source);\n        return {\n            found: true,\n            path: null,\n        };\n    }\n    initMappers(cachedOptions);\n    const mappedPath = getMappedPath(source, file, cachedOptions.extensions, true);\n    if (mappedPath) {\n        log('matched ts path:', mappedPath);\n    }\n    let foundNodePath;\n    try {\n        foundNodePath =\n            resolver.resolveSync({}, path.dirname(path.resolve(file)), mappedPath ?? source) || null;\n    }\n    catch {\n        foundNodePath = null;\n    }\n    if ((JS_EXT_PATTERN.test(foundNodePath) ||\n        (cachedOptions.alwaysTryTypes && !foundNodePath)) &&\n        !/^@types[/\\\\]/.test(source) &&\n        !path.isAbsolute(source) &&\n        !source.startsWith('.')) {\n        const definitelyTyped = resolve('@types' + path.sep + mangleScopedPackage(source), file, options);\n        if (definitelyTyped.found) {\n            return definitelyTyped;\n        }\n    }\n    if (foundNodePath) {\n        log('matched node path:', foundNodePath);\n        return {\n            found: true,\n            path: foundNodePath,\n        };\n    }\n    log(\"didn't find \", source);\n    return {\n        found: false,\n    };\n}\nexport function createTypeScriptImportResolver(options) {\n    const resolver = enhancedResolve.ResolverFactory.createResolver({\n        ...options,\n        conditionNames: options?.conditionNames ?? defaultConditionNames,\n        extensions: options?.extensions ?? defaultExtensions,\n        extensionAlias: options?.extensionAlias ?? defaultExtensionAlias,\n        mainFields: options?.mainFields ?? defaultMainFields,\n        fileSystem: new enhancedResolve.CachedInputFileSystem(fileSystem, 5 * 1000),\n        useSyncFileSystemCalls: true,\n    });\n    return {\n        interfaceVersion: 3,\n        name: IMPORTER_NAME,\n        resolve(source, file) {\n            return resolve(source, file, options, resolver);\n        },\n    };\n}\nfunction removeQuerystring(id) {\n    const querystringIndex = id.lastIndexOf('?');\n    if (querystringIndex >= 0) {\n        return id.slice(0, querystringIndex);\n    }\n    return id;\n}\nconst isFile = (path) => {\n    try {\n        return !!(path && fs.statSync(path, { throwIfNoEntry: false })?.isFile());\n    }\n    catch {\n        return false;\n    }\n};\nconst isModule = (modulePath) => {\n    return !!modulePath && isFile(path.resolve(modulePath, 'package.json'));\n};\nfunction getMappedPath(source, file, extensions = defaultExtensions, retry) {\n    const originalExtensions = extensions;\n    extensions = ['', ...extensions];\n    let paths = [];\n    if (RELATIVE_PATH_PATTERN.test(source)) {\n        const resolved = path.resolve(path.dirname(file), source);\n        if (isFile(resolved)) {\n            paths = [resolved];\n        }\n    }\n    else {\n        paths = [\n            ...new Set(mappers\n                .filter(({ files }) => files.has(file))\n                .map(({ mapperFn }) => mapperFn(source).map(item => [\n                ...extensions.map(ext => `${item}${ext}`),\n                ...originalExtensions.map(ext => `${item}/index${ext}`),\n            ]))\n                .flat(2)\n                .map(toNativePathSeparator)),\n        ].filter(mappedPath => {\n            try {\n                const stat = fs.statSync(mappedPath, { throwIfNoEntry: false });\n                if (stat === undefined)\n                    return false;\n                if (stat.isFile())\n                    return true;\n                if (stat.isDirectory()) {\n                    return isModule(mappedPath);\n                }\n            }\n            catch {\n                return false;\n            }\n            return false;\n        });\n    }\n    if (retry && paths.length === 0) {\n        const isJs = JS_EXT_PATTERN.test(source);\n        if (isJs) {\n            const jsExt = path.extname(source);\n            const tsExt = jsExt.replace('js', 'ts');\n            const basename = source.replace(JS_EXT_PATTERN, '');\n            const resolved = getMappedPath(basename + tsExt, file) ||\n                getMappedPath(basename + '.d' + (tsExt === '.tsx' ? '.ts' : tsExt), file);\n            if (resolved) {\n                return resolved;\n            }\n        }\n        for (const ext of extensions) {\n            const resolved = (isJs ? null : getMappedPath(source + ext, file)) ||\n                getMappedPath(source + `/index${ext}`, file);\n            if (resolved) {\n                return resolved;\n            }\n        }\n    }\n    if (paths.length > 1) {\n        log('found multiple matching ts paths:', paths);\n    }\n    return paths[0];\n}\nfunction initMappers(options) {\n    if (mappers.length > 0 &&\n        mappersCachedOptions === options &&\n        prevCwd === process.cwd()) {\n        return;\n    }\n    prevCwd = process.cwd();\n    const configPaths = (typeof options.project === 'string'\n        ? [options.project]\n        : Array.isArray(options.project)\n            ? options.project\n            : [process.cwd()])\n        .map(config => replacePathSeparator(config, path.sep, path.posix.sep));\n    const defaultInclude = ['**/*'];\n    const defaultIgnore = ['**/node_modules/**'];\n    const projectPaths = [\n        ...new Set([\n            ...configPaths.filter(path => !isDynamicPattern(path)),\n            ...globSync(configPaths.filter(path => isDynamicPattern(path)), {\n                absolute: true,\n                dot: true,\n                expandDirectories: false,\n                ignore: defaultIgnore,\n            }),\n        ]),\n    ];\n    mappers = projectPaths\n        .map(projectPath => {\n        let tsconfigResult;\n        if (isFile(projectPath)) {\n            const { dir, base } = path.parse(projectPath);\n            tsconfigResult = getTsconfig(dir, base);\n        }\n        else {\n            tsconfigResult = getTsconfig(projectPath);\n        }\n        if (!tsconfigResult) {\n            return undefined;\n        }\n        const mapperFn = createPathsMatcher(tsconfigResult);\n        if (!mapperFn) {\n            return undefined;\n        }\n        const files = tsconfigResult.config.files === undefined &&\n            tsconfigResult.config.include === undefined\n            ?\n                globSync(defaultInclude, {\n                    absolute: true,\n                    cwd: path.dirname(tsconfigResult.path),\n                    dot: true,\n                    ignore: [\n                        ...(tsconfigResult.config.exclude ?? []),\n                        ...defaultIgnore,\n                    ],\n                })\n            : [\n                ...(tsconfigResult.config.files !== undefined &&\n                    tsconfigResult.config.files.length > 0\n                    ? tsconfigResult.config.files.map(file => path.normalize(path.resolve(path.dirname(tsconfigResult.path), file)))\n                    : []),\n                ...(tsconfigResult.config.include !== undefined &&\n                    tsconfigResult.config.include.length > 0\n                    ? globSync(tsconfigResult.config.include, {\n                        absolute: true,\n                        cwd: path.dirname(tsconfigResult.path),\n                        dot: true,\n                        ignore: [\n                            ...(tsconfigResult.config.exclude ?? []),\n                            ...defaultIgnore,\n                        ],\n                    })\n                    : []),\n            ];\n        if (files.length === 0) {\n            return undefined;\n        }\n        return {\n            files: new Set(files.map(toNativePathSeparator)),\n            mapperFn,\n        };\n    })\n        .filter(isDefined);\n    mappersCachedOptions = options;\n}\nfunction mangleScopedPackage(moduleName) {\n    if (moduleName.startsWith('@')) {\n        const replaceSlash = moduleName.replace(path.sep, '__');\n        if (replaceSlash !== moduleName) {\n            return replaceSlash.slice(1);\n        }\n    }\n    return moduleName;\n}\nfunction replacePathSeparator(p, from, to) {\n    return from === to ? p : p.replaceAll(from, to);\n}\nfunction toNativePathSeparator(p) {\n    return replacePathSeparator(p, path[process.platform === 'win32' ? 'posix' : 'win32'].sep, path[process.platform === 'win32' ? 'win32' : 'posix'].sep);\n}\nfunction isDefined(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=index.js.map"
        }
    ]
}