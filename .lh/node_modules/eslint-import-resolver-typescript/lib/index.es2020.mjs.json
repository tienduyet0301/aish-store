{
    "sourceFile": "node_modules/eslint-import-resolver-typescript/lib/index.es2020.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892246115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import fs from 'node:fs';\nimport path from 'node:path';\nimport isNodeCoreModule from '@nolyfill/is-core-module';\nimport debug from 'debug';\nimport enhancedResolve from 'enhanced-resolve';\nimport { getTsconfig, createPathsMatcher } from 'get-tsconfig';\nimport { isBunModule } from 'is-bun-module';\nimport stableHashExports from 'stable-hash';\nimport { isDynamicPattern, globSync } from 'tinyglobby';\n\nconst stableHash = stableHashExports.default || stableHashExports;\nconst IMPORTER_NAME = \"eslint-import-resolver-typescript\";\nconst log = debug(IMPORTER_NAME);\nconst defaultConditionNames = [\n  \"types\",\n  \"import\",\n  // APF: https://angular.io/guide/angular-package-format\n  \"esm2020\",\n  \"es2020\",\n  \"es2015\",\n  \"require\",\n  \"node\",\n  \"node-addons\",\n  \"browser\",\n  \"default\"\n];\nconst defaultExtensions = [\n  \".ts\",\n  \".tsx\",\n  \".d.ts\",\n  \".js\",\n  \".jsx\",\n  \".json\",\n  \".node\"\n];\nconst defaultExtensionAlias = {\n  \".js\": [\n    \".ts\",\n    // `.tsx` can also be compiled as `.js`\n    \".tsx\",\n    \".d.ts\",\n    \".js\"\n  ],\n  \".jsx\": [\".tsx\", \".d.ts\", \".jsx\"],\n  \".cjs\": [\".cts\", \".d.cts\", \".cjs\"],\n  \".mjs\": [\".mts\", \".d.mts\", \".mjs\"]\n};\nconst defaultMainFields = [\n  \"types\",\n  \"typings\",\n  // APF: https://angular.io/guide/angular-package-format\n  \"fesm2020\",\n  \"fesm2015\",\n  \"esm2020\",\n  \"es2020\",\n  \"module\",\n  \"jsnext:main\",\n  \"main\"\n];\nconst interfaceVersion = 2;\nconst fileSystem = fs;\nconst JS_EXT_PATTERN = /\\.(?:[cm]js|jsx?)$/;\nconst RELATIVE_PATH_PATTERN = /^\\.{1,2}(?:\\/.*)?$/;\nlet previousOptionsHash;\nlet optionsHash;\nlet cachedOptions;\nlet prevCwd;\nlet mappersCachedOptions;\nlet mappers = [];\nlet resolverCachedOptions;\nlet cachedResolver;\nfunction resolve(source, file, options, resolver = null) {\n  if (!cachedOptions || previousOptionsHash !== (optionsHash = stableHash(options))) {\n    previousOptionsHash = optionsHash;\n    cachedOptions = {\n      ...options,\n      conditionNames: options?.conditionNames ?? defaultConditionNames,\n      extensions: options?.extensions ?? defaultExtensions,\n      extensionAlias: options?.extensionAlias ?? defaultExtensionAlias,\n      mainFields: options?.mainFields ?? defaultMainFields,\n      fileSystem: new enhancedResolve.CachedInputFileSystem(\n        fileSystem,\n        5 * 1e3\n      ),\n      useSyncFileSystemCalls: true\n    };\n  }\n  if (!resolver) {\n    if (!cachedResolver || resolverCachedOptions !== cachedOptions) {\n      cachedResolver = enhancedResolve.ResolverFactory.createResolver(cachedOptions);\n      resolverCachedOptions = cachedOptions;\n    }\n    resolver = cachedResolver;\n  }\n  log(\"looking for\", source, \"in\", file);\n  source = removeQuerystring(source);\n  if (isNodeCoreModule(source) || isBunModule(source, process.versions.bun ?? \"latest\")) {\n    log(\"matched core:\", source);\n    return {\n      found: true,\n      path: null\n    };\n  }\n  initMappers(cachedOptions);\n  const mappedPath = getMappedPath(source, file, cachedOptions.extensions, true);\n  if (mappedPath) {\n    log(\"matched ts path:\", mappedPath);\n  }\n  let foundNodePath;\n  try {\n    foundNodePath = resolver.resolveSync(\n      {},\n      path.dirname(path.resolve(file)),\n      mappedPath ?? source\n    ) || null;\n  } catch {\n    foundNodePath = null;\n  }\n  if ((JS_EXT_PATTERN.test(foundNodePath) || cachedOptions.alwaysTryTypes && !foundNodePath) && !/^@types[/\\\\]/.test(source) && !path.isAbsolute(source) && !source.startsWith(\".\")) {\n    const definitelyTyped = resolve(\n      \"@types\" + path.sep + mangleScopedPackage(source),\n      file,\n      options\n    );\n    if (definitelyTyped.found) {\n      return definitelyTyped;\n    }\n  }\n  if (foundNodePath) {\n    log(\"matched node path:\", foundNodePath);\n    return {\n      found: true,\n      path: foundNodePath\n    };\n  }\n  log(\"didn't find \", source);\n  return {\n    found: false\n  };\n}\nfunction createTypeScriptImportResolver(options) {\n  const resolver = enhancedResolve.ResolverFactory.createResolver({\n    ...options,\n    conditionNames: options?.conditionNames ?? defaultConditionNames,\n    extensions: options?.extensions ?? defaultExtensions,\n    extensionAlias: options?.extensionAlias ?? defaultExtensionAlias,\n    mainFields: options?.mainFields ?? defaultMainFields,\n    fileSystem: new enhancedResolve.CachedInputFileSystem(fileSystem, 5 * 1e3),\n    useSyncFileSystemCalls: true\n  });\n  return {\n    interfaceVersion: 3,\n    name: IMPORTER_NAME,\n    resolve(source, file) {\n      return resolve(source, file, options, resolver);\n    }\n  };\n}\nfunction removeQuerystring(id) {\n  const querystringIndex = id.lastIndexOf(\"?\");\n  if (querystringIndex >= 0) {\n    return id.slice(0, querystringIndex);\n  }\n  return id;\n}\nconst isFile = (path2) => {\n  try {\n    return !!(path2 && fs.statSync(path2, { throwIfNoEntry: false })?.isFile());\n  } catch {\n    return false;\n  }\n};\nconst isModule = (modulePath) => {\n  return !!modulePath && isFile(path.resolve(modulePath, \"package.json\"));\n};\nfunction getMappedPath(source, file, extensions = defaultExtensions, retry) {\n  const originalExtensions = extensions;\n  extensions = [\"\", ...extensions];\n  let paths = [];\n  if (RELATIVE_PATH_PATTERN.test(source)) {\n    const resolved = path.resolve(path.dirname(file), source);\n    if (isFile(resolved)) {\n      paths = [resolved];\n    }\n  } else {\n    paths = [\n      ...new Set(\n        mappers.filter(({ files }) => files.has(file)).map(\n          ({ mapperFn }) => mapperFn(source).map((item) => [\n            ...extensions.map((ext) => `${item}${ext}`),\n            ...originalExtensions.map((ext) => `${item}/index${ext}`)\n          ])\n        ).flat(2).map(toNativePathSeparator)\n      )\n    ].filter((mappedPath) => {\n      try {\n        const stat = fs.statSync(mappedPath, { throwIfNoEntry: false });\n        if (stat === void 0)\n          return false;\n        if (stat.isFile())\n          return true;\n        if (stat.isDirectory()) {\n          return isModule(mappedPath);\n        }\n      } catch {\n        return false;\n      }\n      return false;\n    });\n  }\n  if (retry && paths.length === 0) {\n    const isJs = JS_EXT_PATTERN.test(source);\n    if (isJs) {\n      const jsExt = path.extname(source);\n      const tsExt = jsExt.replace(\"js\", \"ts\");\n      const basename = source.replace(JS_EXT_PATTERN, \"\");\n      const resolved = getMappedPath(basename + tsExt, file) || getMappedPath(\n        basename + \".d\" + (tsExt === \".tsx\" ? \".ts\" : tsExt),\n        file\n      );\n      if (resolved) {\n        return resolved;\n      }\n    }\n    for (const ext of extensions) {\n      const resolved = (isJs ? null : getMappedPath(source + ext, file)) || getMappedPath(source + `/index${ext}`, file);\n      if (resolved) {\n        return resolved;\n      }\n    }\n  }\n  if (paths.length > 1) {\n    log(\"found multiple matching ts paths:\", paths);\n  }\n  return paths[0];\n}\nfunction initMappers(options) {\n  if (mappers.length > 0 && mappersCachedOptions === options && prevCwd === process.cwd()) {\n    return;\n  }\n  prevCwd = process.cwd();\n  const configPaths = (typeof options.project === \"string\" ? [options.project] : Array.isArray(options.project) ? options.project : [process.cwd()]).map((config) => replacePathSeparator(config, path.sep, path.posix.sep));\n  const defaultInclude = [\"**/*\"];\n  const defaultIgnore = [\"**/node_modules/**\"];\n  const projectPaths = [\n    .../* @__PURE__ */ new Set([\n      ...configPaths.filter((path2) => !isDynamicPattern(path2)),\n      ...globSync(\n        configPaths.filter((path2) => isDynamicPattern(path2)),\n        {\n          absolute: true,\n          dot: true,\n          expandDirectories: false,\n          ignore: defaultIgnore\n        }\n      )\n    ])\n  ];\n  mappers = projectPaths.map((projectPath) => {\n    let tsconfigResult;\n    if (isFile(projectPath)) {\n      const { dir, base } = path.parse(projectPath);\n      tsconfigResult = getTsconfig(dir, base);\n    } else {\n      tsconfigResult = getTsconfig(projectPath);\n    }\n    if (!tsconfigResult) {\n      return void 0;\n    }\n    const mapperFn = createPathsMatcher(tsconfigResult);\n    if (!mapperFn) {\n      return void 0;\n    }\n    const files = tsconfigResult.config.files === void 0 && tsconfigResult.config.include === void 0 ? (\n      // Include everything if no files or include options\n      globSync(defaultInclude, {\n        absolute: true,\n        cwd: path.dirname(tsconfigResult.path),\n        dot: true,\n        ignore: [\n          ...tsconfigResult.config.exclude ?? [],\n          ...defaultIgnore\n        ]\n      })\n    ) : [\n      // https://www.typescriptlang.org/tsconfig/#files\n      ...tsconfigResult.config.files !== void 0 && tsconfigResult.config.files.length > 0 ? tsconfigResult.config.files.map(\n        (file) => path.normalize(\n          path.resolve(path.dirname(tsconfigResult.path), file)\n        )\n      ) : [],\n      // https://www.typescriptlang.org/tsconfig/#include\n      ...tsconfigResult.config.include !== void 0 && tsconfigResult.config.include.length > 0 ? globSync(tsconfigResult.config.include, {\n        absolute: true,\n        cwd: path.dirname(tsconfigResult.path),\n        dot: true,\n        ignore: [\n          ...tsconfigResult.config.exclude ?? [],\n          ...defaultIgnore\n        ]\n      }) : []\n    ];\n    if (files.length === 0) {\n      return void 0;\n    }\n    return {\n      files: new Set(files.map(toNativePathSeparator)),\n      mapperFn\n    };\n  }).filter(isDefined);\n  mappersCachedOptions = options;\n}\nfunction mangleScopedPackage(moduleName) {\n  if (moduleName.startsWith(\"@\")) {\n    const replaceSlash = moduleName.replace(path.sep, \"__\");\n    if (replaceSlash !== moduleName) {\n      return replaceSlash.slice(1);\n    }\n  }\n  return moduleName;\n}\nfunction replacePathSeparator(p, from, to) {\n  return from === to ? p : p.replaceAll(from, to);\n}\nfunction toNativePathSeparator(p) {\n  return replacePathSeparator(\n    p,\n    path[process.platform === \"win32\" ? \"posix\" : \"win32\"].sep,\n    path[process.platform === \"win32\" ? \"win32\" : \"posix\"].sep\n  );\n}\nfunction isDefined(value) {\n  return value !== null && value !== void 0;\n}\n\nexport { createTypeScriptImportResolver, defaultConditionNames, defaultExtensionAlias, defaultExtensions, defaultMainFields, interfaceVersion, resolve };\n"
        }
    ]
}