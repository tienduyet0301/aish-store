{
    "sourceFile": "node_modules/axe-core/axe.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892043690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Type definitions for axe-core\n// Project: https://github.com/dequelabs/axe-core\n\ndeclare namespace axe {\n  type ImpactValue = 'minor' | 'moderate' | 'serious' | 'critical' | null;\n\n  type TagValue = string;\n\n  type ReporterVersion = 'v1' | 'v2' | 'raw' | 'rawEnv' | 'no-passes';\n\n  type RunOnlyType = 'rule' | 'rules' | 'tag' | 'tags';\n\n  type resultGroups = 'inapplicable' | 'passes' | 'incomplete' | 'violations';\n\n  type AriaAttrsType =\n    | 'boolean'\n    | 'nmtoken'\n    | 'mntokens'\n    | 'idref'\n    | 'idrefs'\n    | 'string'\n    | 'decimal'\n    | 'int';\n\n  type AriaRolesType = 'abstract' | 'widget' | 'structure' | 'landmark';\n\n  type DpubRolesType =\n    | 'section'\n    | 'landmark'\n    | 'link'\n    | 'listitem'\n    | 'img'\n    | 'navigation'\n    | 'note'\n    | 'separator'\n    | 'none'\n    | 'sectionhead';\n\n  type HtmlContentTypes =\n    | 'flow'\n    | 'sectioning'\n    | 'heading'\n    | 'phrasing'\n    | 'embedded'\n    | 'interactive';\n\n  // Array of length 2 or greater\n  type MultiArray<T> = [T, T, ...T[]];\n\n  // Selectors within a frame\n  type BaseSelector = string;\n\n  type ShadowDomSelector = MultiArray<BaseSelector>;\n  type CrossTreeSelector = BaseSelector | ShadowDomSelector;\n  type LabelledShadowDomSelector = { fromShadowDom: ShadowDomSelector };\n\n  // Cross-frame selectors\n  type FramesSelector = Array<CrossTreeSelector | LabelledShadowDomSelector>;\n  type UnlabelledFrameSelector = CrossTreeSelector[];\n  type LabelledFramesSelector = { fromFrames: MultiArray<FramesSelector[0]> };\n  /**\n   * @deprecated Use UnlabelledFrameSelector instead\n   */\n  type CrossFrameSelector = UnlabelledFrameSelector;\n\n  // Context options\n  type Selector =\n    | Node\n    | BaseSelector\n    | LabelledShadowDomSelector\n    | LabelledFramesSelector;\n  type SelectorList = Array<Selector | FramesSelector> | NodeList;\n  type ContextProp = Selector | SelectorList;\n  type ContextObject =\n    | {\n        include: ContextProp;\n        exclude?: ContextProp;\n      }\n    | {\n        exclude: ContextProp;\n        include?: ContextProp;\n      };\n  type ContextSpec = ContextProp | ContextObject;\n  /** Synonym to ContextSpec */\n  type ElementContext = ContextSpec;\n\n  type SerialSelector =\n    | BaseSelector\n    | LabelledShadowDomSelector\n    | LabelledFramesSelector;\n  type SerialFrameSelector = SerialSelector | FramesSelector;\n  type SerialSelectorList = Array<SerialFrameSelector>;\n\n  type SerialContextObject =\n    | {\n        include: SerialSelector | SerialSelectorList;\n        exclude?: SerialSelector | SerialSelectorList;\n      }\n    | {\n        exclude: SerialSelector | SerialSelectorList;\n        include?: SerialSelector | SerialSelectorList;\n      };\n\n  interface FrameContextObject {\n    include: UnlabelledFrameSelector[];\n    exclude: UnlabelledFrameSelector[];\n  }\n\n  type RunCallback<T = AxeResults> = (error: Error, results: T) => void;\n\n  interface TestEngine {\n    name: string;\n    version: string;\n  }\n  interface TestRunner {\n    name: string;\n  }\n  interface TestEnvironment {\n    userAgent: string;\n    windowWidth: number;\n    windowHeight: number;\n    orientationAngle?: number;\n    orientationType?: string;\n  }\n  interface RunOnly {\n    type: RunOnlyType;\n    values: TagValue[] | string[];\n  }\n  interface RuleObject {\n    [key: string]: {\n      enabled: boolean;\n    };\n  }\n  interface RunOptions {\n    runOnly?: RunOnly | TagValue[] | string[] | string;\n    rules?: RuleObject;\n    reporter?: ReporterVersion | string;\n    resultTypes?: resultGroups[];\n    selectors?: boolean;\n    ancestry?: boolean;\n    xpath?: boolean;\n    absolutePaths?: boolean;\n    iframes?: boolean;\n    elementRef?: boolean;\n    frameWaitTime?: number;\n    preload?: boolean | PreloadOptions;\n    performanceTimer?: boolean;\n    pingWaitTime?: number;\n  }\n  interface PreloadOptions {\n    assets: string[];\n    timeout?: number;\n  }\n  interface AxeResults extends EnvironmentData {\n    toolOptions: RunOptions;\n    passes: Result[];\n    violations: Result[];\n    incomplete: Result[];\n    inapplicable: Result[];\n  }\n  interface Result {\n    description: string;\n    help: string;\n    helpUrl: string;\n    id: string;\n    impact?: ImpactValue;\n    tags: TagValue[];\n    nodes: NodeResult[];\n  }\n  interface NodeResult {\n    html: string;\n    impact?: ImpactValue;\n    target: UnlabelledFrameSelector;\n    xpath?: string[];\n    ancestry?: UnlabelledFrameSelector;\n    any: CheckResult[];\n    all: CheckResult[];\n    none: CheckResult[];\n    failureSummary?: string;\n    element?: HTMLElement;\n  }\n  interface CheckResult {\n    id: string;\n    impact: string;\n    message: string;\n    data: any;\n    relatedNodes?: RelatedNode[];\n  }\n  interface RelatedNode {\n    html: string;\n    target: UnlabelledFrameSelector;\n    xpath?: string[];\n    ancestry?: UnlabelledFrameSelector;\n    element?: HTMLElement;\n  }\n  interface RuleLocale {\n    [key: string]: {\n      description: string;\n      help: string;\n    };\n  }\n  interface CheckMessages {\n    pass: string | { [key: string]: string };\n    fail: string | { [key: string]: string };\n    incomplete?: string | { [key: string]: string };\n  }\n  interface CheckLocale {\n    [key: string]: CheckMessages;\n  }\n  interface Locale {\n    lang?: string;\n    rules?: RuleLocale;\n    checks?: CheckLocale;\n  }\n  interface AriaAttrs {\n    type: AriaAttrsType;\n    values?: string[];\n    allowEmpty?: boolean;\n    global?: boolean;\n    unsupported?: boolean;\n  }\n  interface AriaRoles {\n    type: AriaRolesType | DpubRolesType;\n    requiredContext?: string[];\n    requiredOwned?: string[];\n    requiredAttrs?: string[];\n    allowedAttrs?: string[];\n    nameFromContent?: boolean;\n    unsupported?: boolean;\n  }\n  interface HtmlElmsVariant {\n    contentTypes?: HtmlContentTypes[];\n    allowedRoles: boolean | string[];\n    noAriaAttrs?: boolean;\n    shadowRoot?: boolean;\n    implicitAttrs?: { [key: string]: string };\n    namingMethods?: string[];\n  }\n  interface HtmlElms extends HtmlElmsVariant {\n    variant?: { [key: string]: HtmlElmsVariant };\n  }\n  interface Standards {\n    ariaAttrs?: { [key: string]: AriaAttrs };\n    ariaRoles?: { [key: string]: AriaRoles };\n    htmlElms?: { [key: string]: HtmlElms };\n    cssColors?: { [key: string]: number[] };\n  }\n  interface Spec {\n    branding?: string | Branding;\n    reporter?: ReporterVersion | string | AxeReporter;\n    checks?: Check[];\n    rules?: Rule[];\n    standards?: Standards;\n    locale?: Locale;\n    disableOtherRules?: boolean;\n    axeVersion?: string;\n    noHtml?: boolean;\n    allowedOrigins?: string[];\n    // Deprecated - do not use.\n    ver?: string;\n  }\n  /**\n   * @deprecated Use branding: string instead to set the application key in help URLs\n   */\n  interface Branding {\n    brand?: string;\n    application?: string;\n  }\n  interface CheckHelper {\n    async: () => (result: boolean | undefined | Error) => void;\n    data: (data: unknown) => void;\n    relatedNodes: (nodes: Element[]) => void;\n  }\n  interface AfterResult {\n    id: string;\n    data?: unknown;\n    relatedNodes: SerialDqElement[];\n    result: boolean | undefined;\n    node: SerialDqElement;\n  }\n  interface Check {\n    id: string;\n    evaluate?:\n      | string\n      | ((\n          this: CheckHelper,\n          node: Element,\n          options: unknown,\n          virtualNode: VirtualNode\n        ) => boolean | undefined | void);\n    after?:\n      | string\n      | ((results: AfterResult[], options: unknown) => AfterResult[]);\n    options?: any;\n    matches?: string;\n    enabled?: boolean;\n    metadata?: {\n      impact?: ImpactValue;\n      messages?: CheckMessages;\n    };\n  }\n  interface Rule {\n    id: string;\n    selector?: string;\n    impact?: ImpactValue;\n    excludeHidden?: boolean;\n    enabled?: boolean;\n    pageLevel?: boolean;\n    any?: string[];\n    all?: string[];\n    none?: string[];\n    tags?: string[];\n    matches?: string | ((node: Element, virtualNode: VirtualNode) => boolean);\n    reviewOnFail?: boolean;\n    actIds?: string[];\n    metadata?: Omit<RuleMetadata, 'ruleId' | 'tags' | 'actIds'>;\n  }\n  interface AxePlugin {\n    id: string;\n    run(...args: any[]): any;\n    commands: {\n      id: string;\n      callback(...args: any[]): void;\n    }[];\n    cleanup?(callback: Function): void;\n  }\n  interface RuleMetadata {\n    ruleId: string;\n    description: string;\n    help: string;\n    helpUrl: string;\n    tags: string[];\n    actIds?: string[];\n  }\n  interface SerialDqElement {\n    source: string;\n    nodeIndexes: number[];\n    selector: UnlabelledFrameSelector;\n    xpath: string[];\n    ancestry: UnlabelledFrameSelector;\n  }\n  interface DqElement extends SerialDqElement {\n    element: Element;\n    toJSON(): SerialDqElement;\n    mergeSpecs(\n      childSpec: SerialDqElement,\n      parentSpec: SerialDqElement\n    ): SerialDqElement;\n  }\n  interface PartialRuleResult {\n    id: string;\n    result: 'inapplicable';\n    pageLevel: boolean;\n    impact: null;\n    nodes: Array<Record<string, unknown>>;\n  }\n  interface PartialResult {\n    frames: SerialDqElement[];\n    results: PartialRuleResult[];\n    environmentData?: EnvironmentData;\n  }\n  type PartialResults = Array<PartialResult | null>;\n  interface FrameContext {\n    frameSelector: CrossTreeSelector;\n    frameContext: FrameContextObject;\n  }\n\n  interface RawCheckResult extends Omit<CheckResult, 'relatedNodes'> {\n    relatedNodes?: Array<SerialDqElement | DqElement>;\n  }\n\n  interface RawNodeResult<T extends 'passed' | 'failed' | 'incomplete'> {\n    node: SerialDqElement | DqElement;\n    any: RawCheckResult[];\n    all: RawCheckResult[];\n    none: RawCheckResult[];\n    impact: ImpactValue | null;\n    result: T;\n  }\n\n  interface RawResult extends Omit<Result, 'nodes'> {\n    inapplicable: Array<never>;\n    passes: RawNodeResult<'passed'>[];\n    incomplete: RawNodeResult<'incomplete'>[];\n    violations: RawNodeResult<'failed'>[];\n    pageLevel: boolean;\n    result: 'failed' | 'passed' | 'incomplete' | 'inapplicable';\n  }\n\n  type AxeReporter<T = unknown> = (\n    rawResults: RawResult[],\n    option: RunOptions,\n    resolve: (report: T) => void,\n    reject: (error: Error) => void\n  ) => void;\n\n  interface VirtualNode {\n    actualNode?: Node;\n    shadowId?: string;\n    children?: VirtualNode[];\n    parent?: VirtualNode;\n    attr(attr: string): string | null;\n    hasAttr(attr: string): boolean;\n    props: { [key: string]: unknown };\n    boundingClientRect: DOMRect;\n  }\n\n  interface Utils {\n    getFrameContexts: (\n      context?: ElementContext,\n      options?: RunOptions\n    ) => FrameContext[];\n    shadowSelect: (selector: CrossTreeSelector) => Element | null;\n    shadowSelectAll: (selector: CrossTreeSelector) => Element[];\n    getStandards(): Required<Standards>;\n    isContextSpec: (context: unknown) => context is ContextSpec;\n    isContextObject: (context: unknown) => context is ContextObject;\n    isContextProp: (context: unknown) => context is ContextProp;\n    isLabelledFramesSelector: (\n      selector: unknown\n    ) => selector is LabelledFramesSelector;\n    isLabelledShadowDomSelector: (\n      selector: unknown\n    ) => selector is LabelledShadowDomSelector;\n\n    DqElement: new (\n      elm: Element,\n      options?: { absolutePaths?: boolean }\n    ) => DqElement;\n    uuid: (\n      options?: { random?: Uint8Array | Array<number> },\n      buf?: Uint8Array | Array<number>,\n      offset?: number\n    ) => string | Uint8Array | Array<number>;\n  }\n\n  interface Aria {\n    getRoleType: (role: string | Element | VirtualNode | null) => string | null;\n  }\n\n  interface Dom {\n    isFocusable: (node: Element | VirtualNode) => boolean;\n    isNativelyFocusable: (node: Element | VirtualNode) => boolean;\n  }\n\n  type AccessibleTextOptions = {\n    inControlContext?: boolean;\n    inLabelledByContext?: boolean;\n  };\n\n  interface Text {\n    accessibleText: (\n      element: Element,\n      options?: AccessibleTextOptions\n    ) => string;\n  }\n\n  interface Commons {\n    aria: Aria;\n    dom: Dom;\n    text: Text;\n  }\n\n  interface EnvironmentData {\n    testEngine: TestEngine;\n    testRunner: TestRunner;\n    testEnvironment: TestEnvironment;\n    url: string;\n    timestamp: string;\n  }\n\n  let version: string;\n  let plugins: any;\n  let utils: Utils;\n  let commons: Commons;\n\n  /**\n   * Source string to use as an injected script in Selenium\n   */\n  let source: string;\n\n  /**\n   * Object for axe Results\n   */\n  var AxeResults: AxeResults;\n\n  /**\n   * Runs a number of rules against the provided HTML page and returns the resulting issue list\n   *\n   * @param   {ElementContext} context  Optional The `Context` specification object @see Context\n   * @param   {RunOptions}     options  Optional Options passed into rules or checks, temporarily modifying them.\n   * @param   {RunCallback}    callback Optional The function to invoke when analysis is complete.\n   * @returns {Promise<AxeResults>|void} If the callback was not defined, axe will return a Promise.\n   */\n  function run<T = AxeResults>(context?: ElementContext): Promise<T>;\n  function run<T = AxeResults>(options: RunOptions): Promise<T>;\n  function run<T = AxeResults>(\n    callback: (error: Error, results: T) => void\n  ): void;\n  function run<T = AxeResults>(\n    context: ElementContext,\n    callback: RunCallback<T>\n  ): void;\n  function run<T = AxeResults>(\n    options: RunOptions,\n    callback: RunCallback<T>\n  ): void;\n  function run<T = AxeResults>(\n    context: ElementContext,\n    options: RunOptions\n  ): Promise<T>;\n  function run<T = AxeResults>(\n    context: ElementContext,\n    options: RunOptions,\n    callback: RunCallback<T>\n  ): void;\n\n  /**\n   * Method for configuring the data format used by axe. Helpful for adding new\n   * rules, which must be registered with the library to execute.\n   * @param  {Spec}       Spec Object with valid `branding`, `reporter`, `checks` and `rules` data\n   */\n  function configure(spec: Spec): void;\n\n  /**\n   * Run axe in the current window only\n   * @param   {ElementContext} context  Optional The `Context` specification object @see Context\n   * @param   {RunOptions}     options  Optional Options passed into rules or checks, temporarily modifying them.\n   * @returns {Promise<PartialResult>}  Partial result, for use in axe.finishRun.\n   */\n  function runPartial(\n    context: ElementContext,\n    options: RunOptions\n  ): Promise<PartialResult>;\n\n  /**\n   * Create a report from axe.runPartial results\n   * @param   {PartialResult[]}     partialResults  Results from axe.runPartial, calls in different frames on the page.\n   * @param   {RunOptions}     options  Optional Options passed into rules or checks, temporarily modifying them.\n   */\n  function finishRun(\n    partialResults: PartialResults,\n    options: RunOptions\n  ): Promise<AxeResults>;\n\n  /**\n   * Searches and returns rules that contain a tag in the list of tags.\n   * @param  {Array}  tags  Optional array of tags\n   * @return {Array}  Array of rules\n   */\n  function getRules(tags?: string[]): RuleMetadata[];\n\n  /**\n   * Restores the default axe configuration\n   */\n  function reset(): void;\n\n  /**\n   * Function to register a plugin configuration in document and its subframes\n   * @param  {Object}    plugin    A plugin configuration object\n   */\n  function registerPlugin(plugin: AxePlugin): void;\n\n  /**\n   * Function to clean up plugin configuration in document and its subframes\n   */\n  function cleanup(): void;\n\n  /**\n   * Set up alternative frame communication\n   */\n  function frameMessenger(frameMessenger: FrameMessenger): void;\n\n  /**\n   * Setup axe-core so axe.common functions can work properly.\n   */\n  function setup(node?: Element | Document): VirtualNode;\n\n  /**\n   * Clean up axe-core tree and caches. `axe.run` will call this function at the end of the run so there's no need to call it yourself afterwards.\n   */\n  function teardown(): void;\n\n  /**\n   * Check if a reporter is registered\n   */\n  function hasReporter(reporterName: string): boolean;\n\n  /**\n   * Get a reporter based the name it is registered with\n   */\n  function getReporter<T>(reporterName: string): AxeReporter<T>;\n\n  /**\n   * Register a new reporter, optionally setting it as the default\n   */\n  function addReporter<T>(\n    reporterName: string,\n    reporter: AxeReporter<T>,\n    isDefault?: boolean\n  ): void;\n\n  // axe.frameMessenger\n  type FrameMessenger = {\n    open: (topicHandler: TopicHandler) => Close | void;\n    post: (\n      frameWindow: Window,\n      data: TopicData,\n      replyHandler: ReplyHandler\n    ) => boolean | void;\n  };\n  type Close = Function;\n  type TopicHandler = (data: TopicData, responder: Responder) => void;\n  type ReplyHandler = (\n    message: any | Error,\n    keepalive: boolean,\n    responder: Responder\n  ) => void;\n  type Responder = (\n    message: any | Error,\n    keepalive?: boolean,\n    replyHandler?: ReplyHandler\n  ) => void;\n  type TopicData = { topic: string } & ReplyData;\n  type ReplyData = { channelId: string; message: any; keepalive: boolean };\n}\n\nexport = axe;\n"
        }
    ]
}