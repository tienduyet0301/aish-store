{
    "sourceFile": "node_modules/@rushstack/eslint-patch/lib/eslint-bulk-suppressions/bulk-suppressions-patch.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891924297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendVerifyFunction = exports.patchClass = exports.requireFromPathToLinterJS = exports.write = exports.prune = exports.shouldBulkSuppress = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst Guards = __importStar(require(\"./ast-guards\"));\nconst _patch_base_1 = require(\"../_patch-base\");\nconst constants_1 = require(\"./constants\");\nconst bulk_suppressions_file_1 = require(\"./bulk-suppressions-file\");\nconst ESLINTRC_FILENAMES = [\n    '.eslintrc.js',\n    '.eslintrc.cjs'\n    // Several other filenames are allowed, but this patch requires that it be loaded via a JS config file,\n    // so we only need to check for the JS-based filenames\n];\nconst SUPPRESSION_SYMBOL = Symbol('suppression');\nconst ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE = process.env[constants_1.ESLINT_BULK_SUPPRESS_ENV_VAR_NAME];\nconst SUPPRESS_ALL_RULES = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE === '*';\nconst RULES_TO_SUPPRESS = ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE\n    ? new Set(ESLINT_BULK_SUPPRESS_ENV_VAR_VALUE.split(','))\n    : undefined;\nfunction getNodeName(node) {\n    if (Guards.isClassDeclarationWithName(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isFunctionDeclarationWithName(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isClassExpressionWithName(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isFunctionExpressionWithName(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isNormalVariableDeclaratorWithAnonymousExpressionAssigned(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isNormalObjectPropertyWithAnonymousExpressionAssigned(node)) {\n        return node.key.name;\n    }\n    else if (Guards.isNormalClassPropertyDefinitionWithAnonymousExpressionAssigned(node)) {\n        return node.key.name;\n    }\n    else if (Guards.isNormalAssignmentPatternWithAnonymousExpressionAssigned(node)) {\n        return node.left.name;\n    }\n    else if (Guards.isNormalMethodDefinition(node)) {\n        return node.key.name;\n    }\n    else if (Guards.isTSEnumDeclaration(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isTSInterfaceDeclaration(node)) {\n        return node.id.name;\n    }\n    else if (Guards.isTSTypeAliasDeclaration(node)) {\n        return node.id.name;\n    }\n}\nfunction calculateScopeId(node) {\n    const scopeIds = [];\n    for (let current = node; current; current = current.parent) {\n        const scopeIdForASTNode = getNodeName(current);\n        if (scopeIdForASTNode !== undefined) {\n            scopeIds.unshift(scopeIdForASTNode);\n        }\n    }\n    if (scopeIds.length === 0) {\n        return '.';\n    }\n    else {\n        return '.' + scopeIds.join('.');\n    }\n}\nconst eslintrcPathByFileOrFolderPath = new Map();\nfunction findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFilePath) {\n    const cachedFolderPathForFilePath = eslintrcPathByFileOrFolderPath.get(normalizedFilePath);\n    if (cachedFolderPathForFilePath) {\n        return cachedFolderPathForFilePath;\n    }\n    const normalizedFileFolderPath = normalizedFilePath.substring(0, normalizedFilePath.lastIndexOf('/'));\n    const pathsToCache = [normalizedFilePath];\n    let eslintrcFolderPath;\n    findEslintrcFileLoop: for (let currentFolder = normalizedFileFolderPath; currentFolder; // 'something'.substring(0, -1) is ''\n     currentFolder = currentFolder.substring(0, currentFolder.lastIndexOf('/'))) {\n        const cachedEslintrcFolderPath = eslintrcPathByFileOrFolderPath.get(currentFolder);\n        if (cachedEslintrcFolderPath) {\n            // Need to cache this result into the intermediate paths\n            eslintrcFolderPath = cachedEslintrcFolderPath;\n            break;\n        }\n        pathsToCache.push(currentFolder);\n        for (const eslintrcFilename of ESLINTRC_FILENAMES) {\n            if (fs_1.default.existsSync(`${currentFolder}/${eslintrcFilename}`)) {\n                eslintrcFolderPath = currentFolder;\n                break findEslintrcFileLoop;\n            }\n        }\n    }\n    if (eslintrcFolderPath) {\n        for (const checkedFolder of pathsToCache) {\n            eslintrcPathByFileOrFolderPath.set(checkedFolder, eslintrcFolderPath);\n        }\n        return eslintrcFolderPath;\n    }\n    else {\n        throw new Error(`Cannot locate an ESLint configuration file for ${normalizedFilePath}`);\n    }\n}\n// One-line insert into the ruleContext report method to prematurely exit if the ESLint problem has been suppressed\nfunction shouldBulkSuppress(params) {\n    // Use this ENV variable to turn off eslint-bulk-suppressions functionality, default behavior is on\n    if (process.env[constants_1.ESLINT_BULK_ENABLE_ENV_VAR_NAME] === 'false') {\n        return false;\n    }\n    const { filename: fileAbsolutePath, currentNode, ruleId: rule, problem } = params;\n    const normalizedFileAbsolutePath = fileAbsolutePath.replace(/\\\\/g, '/');\n    const eslintrcDirectory = findEslintrcFolderPathForNormalizedFileAbsolutePath(normalizedFileAbsolutePath);\n    const fileRelativePath = normalizedFileAbsolutePath.substring(eslintrcDirectory.length + 1);\n    const scopeId = calculateScopeId(currentNode);\n    const suppression = { file: fileRelativePath, scopeId, rule };\n    const config = (0, bulk_suppressions_file_1.getSuppressionsConfigForEslintrcFolderPath)(eslintrcDirectory);\n    const serializedSuppression = (0, bulk_suppressions_file_1.serializeSuppression)(suppression);\n    const currentNodeIsSuppressed = config.serializedSuppressions.has(serializedSuppression);\n    if (currentNodeIsSuppressed || SUPPRESS_ALL_RULES || (RULES_TO_SUPPRESS === null || RULES_TO_SUPPRESS === void 0 ? void 0 : RULES_TO_SUPPRESS.has(suppression.rule))) {\n        problem[SUPPRESSION_SYMBOL] = {\n            suppression,\n            serializedSuppression,\n            config\n        };\n    }\n    return process.env[constants_1.ESLINT_BULK_PRUNE_ENV_VAR_NAME] !== '1' && currentNodeIsSuppressed;\n}\nexports.shouldBulkSuppress = shouldBulkSuppress;\nfunction prune() {\n    for (const [eslintrcFolderPath, suppressionsConfig] of (0, bulk_suppressions_file_1.getAllBulkSuppressionsConfigsByEslintrcFolderPath)()) {\n        if (suppressionsConfig) {\n            const { newSerializedSuppressions, newJsonObject } = suppressionsConfig;\n            const newSuppressionsConfig = {\n                serializedSuppressions: newSerializedSuppressions,\n                jsonObject: newJsonObject,\n                newSerializedSuppressions: new Set(),\n                newJsonObject: { suppressions: [] }\n            };\n            (0, bulk_suppressions_file_1.writeSuppressionsJsonToFile)(eslintrcFolderPath, newSuppressionsConfig);\n        }\n    }\n}\nexports.prune = prune;\nfunction write() {\n    for (const [eslintrcFolderPath, suppressionsConfig] of (0, bulk_suppressions_file_1.getAllBulkSuppressionsConfigsByEslintrcFolderPath)()) {\n        if (suppressionsConfig) {\n            (0, bulk_suppressions_file_1.writeSuppressionsJsonToFile)(eslintrcFolderPath, suppressionsConfig);\n        }\n    }\n}\nexports.write = write;\n// utility function for linter-patch.js to make require statements that use relative paths in linter.js work in linter-patch.js\nfunction requireFromPathToLinterJS(importPath) {\n    if (!_patch_base_1.eslintFolder) {\n        return require(importPath);\n    }\n    const pathToLinterFolder = `${_patch_base_1.eslintFolder}/lib/linter`;\n    const moduleAbsolutePath = require.resolve(importPath, { paths: [pathToLinterFolder] });\n    return require(moduleAbsolutePath);\n}\nexports.requireFromPathToLinterJS = requireFromPathToLinterJS;\nfunction patchClass(originalClass, patchedClass) {\n    // Get all the property names of the patched class prototype\n    const patchedProperties = Object.getOwnPropertyNames(patchedClass.prototype);\n    // Loop through all the properties\n    for (const prop of patchedProperties) {\n        // Override the property in the original class\n        originalClass.prototype[prop] = patchedClass.prototype[prop];\n    }\n    // Handle getters and setters\n    for (const [prop, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(patchedClass.prototype))) {\n        if (descriptor.get || descriptor.set) {\n            Object.defineProperty(originalClass.prototype, prop, descriptor);\n        }\n    }\n}\nexports.patchClass = patchClass;\n/**\n * This returns a wrapped version of the \"verify\" function from ESLint's Linter class\n * that postprocesses rule violations that weren't suppressed by comments. This postprocessing\n * records suppressions that weren't otherwise suppressed by comments to be used\n * by the \"suppress\" and \"prune\" commands.\n */\nfunction extendVerifyFunction(originalFn) {\n    return function (...args) {\n        const problems = originalFn.apply(this, args);\n        if (problems) {\n            for (const problem of problems) {\n                if (problem[SUPPRESSION_SYMBOL]) {\n                    const { serializedSuppression, suppression, config: { newSerializedSuppressions, jsonObject: { suppressions }, newJsonObject: { suppressions: newSuppressions } } } = problem[SUPPRESSION_SYMBOL];\n                    if (!newSerializedSuppressions.has(serializedSuppression)) {\n                        newSerializedSuppressions.add(serializedSuppression);\n                        newSuppressions.push(suppression);\n                        suppressions.push(suppression);\n                    }\n                }\n            }\n        }\n        return problems;\n    };\n}\nexports.extendVerifyFunction = extendVerifyFunction;\n//# sourceMappingURL=bulk-suppressions-patch.js.map"
        }
    ]
}