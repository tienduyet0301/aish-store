{
    "sourceFile": "node_modules/@rushstack/eslint-patch/lib/eslint-bulk-suppressions/generate-patched-file.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891932723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generatePatchedLinterJsFileIfDoesNotExist = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst constants_1 = require(\"./constants\");\n/**\n * Dynamically generate file to properly patch many versions of ESLint\n * @param inputFilePath - Must be an iteration of https://github.com/eslint/eslint/blob/main/lib/linter/linter.js\n * @param outputFilePath - Some small changes to linter.js\n */\nfunction generatePatchedLinterJsFileIfDoesNotExist(inputFilePath, outputFilePath) {\n    const generateEnvVarValue = process.env[constants_1.ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME];\n    if (generateEnvVarValue !== 'true' && generateEnvVarValue !== '1' && fs_1.default.existsSync(outputFilePath)) {\n        return;\n    }\n    const inputFile = fs_1.default.readFileSync(inputFilePath).toString();\n    let inputIndex = 0;\n    /**\n     * Extract from the stream until marker is reached.  When matching marker,\n     * ignore whitespace in the stream and in the marker.  Return the extracted text.\n     */\n    function scanUntilMarker(marker) {\n        const trimmedMarker = marker.replace(/\\s/g, '');\n        let output = '';\n        let trimmed = '';\n        while (inputIndex < inputFile.length) {\n            const char = inputFile[inputIndex++];\n            output += char;\n            if (!/^\\s$/.test(char)) {\n                trimmed += char;\n            }\n            if (trimmed.endsWith(trimmedMarker)) {\n                return output;\n            }\n        }\n        throw new Error('Unexpected end of input while looking for ' + JSON.stringify(marker));\n    }\n    function scanUntilNewline() {\n        let output = '';\n        while (inputIndex < inputFile.length) {\n            const char = inputFile[inputIndex++];\n            output += char;\n            if (char === '\\n') {\n                return output;\n            }\n        }\n        throw new Error('Unexpected end of input while looking for new line');\n    }\n    function scanUntilEnd() {\n        const output = inputFile.substring(inputIndex);\n        inputIndex = inputFile.length;\n        return output;\n    }\n    /**\n     * Returns index of next public method\n     * @param fromIndex - index of inputFile to search if public method still exists\n     * @returns -1 if public method does not exist or index of next public method\n     */\n    function getIndexOfNextPublicMethod(fromIndex) {\n        const rest = inputFile.substring(fromIndex);\n        const endOfClassIndex = rest.indexOf('\\n}');\n        const markerForStartOfClassMethod = '\\n     */\\n    ';\n        const startOfClassMethodIndex = rest.indexOf(markerForStartOfClassMethod);\n        if (startOfClassMethodIndex === -1 || startOfClassMethodIndex > endOfClassIndex) {\n            return -1;\n        }\n        const afterMarkerIndex = rest.indexOf(markerForStartOfClassMethod) + markerForStartOfClassMethod.length;\n        const isPublicMethod = rest[afterMarkerIndex] !== '_' &&\n            rest[afterMarkerIndex] !== '#' &&\n            !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('static') &&\n            !rest.substring(afterMarkerIndex, rest.indexOf('\\n', afterMarkerIndex)).includes('constructor');\n        if (isPublicMethod) {\n            return fromIndex + afterMarkerIndex;\n        }\n        return getIndexOfNextPublicMethod(fromIndex + afterMarkerIndex);\n    }\n    function scanUntilIndex(indexToScanTo) {\n        const output = inputFile.substring(inputIndex, indexToScanTo);\n        inputIndex = indexToScanTo;\n        return output;\n    }\n    let outputFile = '';\n    // Match this:\n    //    //------------------------------------------------------------------------------\n    //    // Requirements\n    //    //------------------------------------------------------------------------------\n    outputFile += scanUntilMarker('// Requirements');\n    outputFile += scanUntilMarker('//--');\n    outputFile += scanUntilNewline();\n    outputFile += `\n// --- BEGIN MONKEY PATCH ---\nconst bulkSuppressionsPatch = require(process.env.${constants_1.ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME});\nconst requireFromPathToLinterJS = bulkSuppressionsPatch.requireFromPathToLinterJS;\n`;\n    // Match this:\n    //    //------------------------------------------------------------------------------\n    //    // Typedefs\n    //    //------------------------------------------------------------------------------\n    const requireSection = scanUntilMarker('// Typedefs');\n    // Match something like this:\n    //\n    //    const path = require('path'),\n    //    eslintScope = require('eslint-scope'),\n    //    evk = require('eslint-visitor-keys'),\n    //\n    // Convert to something like this:\n    //\n    //    const path = require('path'),\n    //    eslintScope = requireFromPathToLinterJS('eslint-scope'),\n    //    evk = requireFromPathToLinterJS('eslint-visitor-keys'),\n    //\n    outputFile += requireSection.replace(/require\\s*\\((?:'([^']+)'|\"([^\"]+)\")\\)/g, (match, p1, p2) => {\n        var _a;\n        const importPath = (_a = p1 !== null && p1 !== void 0 ? p1 : p2) !== null && _a !== void 0 ? _a : '';\n        if (importPath !== 'path') {\n            if (p1) {\n                return `requireFromPathToLinterJS('${p1}')`;\n            }\n            if (p2) {\n                return `requireFromPathToLinterJS(\"${p2}\")`;\n            }\n        }\n        // Keep as-is\n        return match;\n    });\n    outputFile += `--- END MONKEY PATCH ---\n`;\n    // Match this:\n    // ```\n    //      if (reportTranslator === null) {\n    //        reportTranslator = createReportTranslator({\n    //            ruleId,\n    //            severity,\n    //            sourceCode,\n    //            messageIds,\n    //            disableFixes\n    //        });\n    //    }\n    //    const problem = reportTranslator(...args);\n    //\n    //    if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n    //        throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n    //    }\n    // ```\n    //\n    // Convert to something like this:\n    // ```\n    //      if (reportTranslator === null) {\n    //        reportTranslator = createReportTranslator({\n    //            ruleId,\n    //            severity,\n    //            sourceCode,\n    //            messageIds,\n    //            disableFixes\n    //        });\n    //    }\n    //    const problem = reportTranslator(...args);\n    //    // --- BEGIN MONKEY PATCH ---\n    //    if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId })) return;\n    //    // --- END MONKEY PATCH ---\n    //\n    //    if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n    //        throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n    //    }\n    // ```\n    outputFile += scanUntilMarker('const problem = reportTranslator(...args);');\n    outputFile += `\n                        // --- BEGIN MONKEY PATCH ---\n                        if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode, ruleId, problem })) return;\n                        // --- END MONKEY PATCH ---\n`;\n    outputFile += scanUntilMarker('nodeQueue.forEach(traversalInfo => {');\n    outputFile += scanUntilMarker('});');\n    outputFile += scanUntilNewline();\n    outputFile += scanUntilMarker('class Linter {');\n    outputFile += scanUntilNewline();\n    outputFile += `\n    // --- BEGIN MONKEY PATCH ---\n    /**\n     * We intercept ESLint execution at the .eslintrc.js file, but unfortunately the Linter class is\n     * initialized before the .eslintrc.js file is executed. This means the internalSlotsMap that all\n     * the patched methods refer to is not initialized. This method checks if the internalSlotsMap is\n     * initialized, and if not, initializes it.\n     */\n    _conditionallyReinitialize({ cwd, configType } = {}) {\n        if (internalSlotsMap.get(this) === undefined) {\n            internalSlotsMap.set(this, {\n              cwd: normalizeCwd(cwd),\n              lastConfigArray: null,\n              lastSourceCode: null,\n              lastSuppressedMessages: [],\n              configType, // TODO: Remove after flat config conversion\n              parserMap: new Map([['espree', espree]]),\n              ruleMap: new Rules()\n            });\n\n            this.version = pkg.version;\n        }\n    }\n    // --- END MONKEY PATCH ---\n`;\n    let indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n    while (indexOfNextPublicMethod !== -1) {\n        outputFile += scanUntilIndex(indexOfNextPublicMethod);\n        outputFile += scanUntilNewline();\n        outputFile += `        // --- BEGIN MONKEY PATCH ---\n        this._conditionallyReinitialize();\n        // --- END MONKEY PATCH ---\n`;\n        indexOfNextPublicMethod = getIndexOfNextPublicMethod(inputIndex);\n    }\n    outputFile += scanUntilEnd();\n    fs_1.default.writeFileSync(outputFilePath, outputFile);\n}\nexports.generatePatchedLinterJsFileIfDoesNotExist = generatePatchedLinterJsFileIfDoesNotExist;\n//# sourceMappingURL=generate-patched-file.js.map"
        }
    ]
}