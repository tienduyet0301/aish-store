{
    "sourceFile": "node_modules/@rushstack/eslint-patch/lib/eslint-bulk-suppressions/cli/utils/wrap-words-to-lines.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891932399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapWordsToLines = void 0;\nfunction wrapWordsToLines(text, maxLineLength, indentOrLinePrefix) {\n    var _a;\n    let linePrefix;\n    switch (typeof indentOrLinePrefix) {\n        case 'number':\n            linePrefix = ' '.repeat(indentOrLinePrefix);\n            break;\n        case 'string':\n            linePrefix = indentOrLinePrefix;\n            break;\n        default:\n            linePrefix = '';\n            break;\n    }\n    const linePrefixLength = linePrefix.length;\n    if (!maxLineLength) {\n        maxLineLength = process.stdout.getWindowSize()[0];\n    }\n    // Apply word wrapping and the provided line prefix, while also respecting existing newlines\n    // and prefix spaces that may exist in the text string already.\n    const lines = text.split(/\\r?\\n/);\n    const wrappedLines = [];\n    for (const line of lines) {\n        if (line.length + linePrefixLength <= maxLineLength) {\n            wrappedLines.push(linePrefix + line);\n        }\n        else {\n            const lineAdditionalPrefix = ((_a = line.match(/^\\s*/)) === null || _a === void 0 ? void 0 : _a[0]) || '';\n            const whitespaceRegexp = /\\s+/g;\n            let currentWhitespaceMatch = null;\n            let previousWhitespaceMatch;\n            let currentLineStartIndex = lineAdditionalPrefix.length;\n            let previousBreakRanOver = false;\n            while ((currentWhitespaceMatch = whitespaceRegexp.exec(line)) !== null) {\n                if (currentWhitespaceMatch.index + linePrefixLength - currentLineStartIndex > maxLineLength) {\n                    let whitespaceToSplitAt;\n                    if (!previousWhitespaceMatch ||\n                        // Handle the case where there are two words longer than the maxLineLength in a row\n                        previousBreakRanOver) {\n                        whitespaceToSplitAt = currentWhitespaceMatch;\n                    }\n                    else {\n                        whitespaceToSplitAt = previousWhitespaceMatch;\n                    }\n                    wrappedLines.push(linePrefix +\n                        lineAdditionalPrefix +\n                        line.substring(currentLineStartIndex, whitespaceToSplitAt.index));\n                    previousBreakRanOver = whitespaceToSplitAt.index - currentLineStartIndex > maxLineLength;\n                    currentLineStartIndex = whitespaceToSplitAt.index + whitespaceToSplitAt[0].length;\n                }\n                else {\n                    previousBreakRanOver = false;\n                }\n                previousWhitespaceMatch = currentWhitespaceMatch;\n            }\n            if (currentLineStartIndex < line.length) {\n                wrappedLines.push(linePrefix + lineAdditionalPrefix + line.substring(currentLineStartIndex));\n            }\n        }\n    }\n    return wrappedLines;\n}\nexports.wrapWordsToLines = wrapWordsToLines;\n//# sourceMappingURL=wrap-words-to-lines.js.map"
        }
    ]
}