{
    "sourceFile": "node_modules/stable-hash/README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893035801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "# stable-hash\n\nA tiny and fast (481b <sup>[unpkg](https://unpkg.com/stable-hash@0.0.3/dist/index.mjs)</sup>) lib for \"stably hashing\" a JavaScript value. Originally created for [SWR](https://github.com/vercel/swr).\n\nIt's similar to `JSON.stringify(value)`, but:\n1. Supports any JavaScript value (BigInt, NaN, Symbol, function, class, ...)\n2. Sorts object keys (stable)\n3. Supports circular objects\n\n## Use\n\n```bash\nyarn add stable-hash\n```\n\n```js\nimport hash from 'stable-hash'\n\nhash(anyJavaScriptValueHere) // returns a string\n```\n\n## Examples\n\n### Primitive Value\n\n```js\nhash(1)\nhash('foo')\nhash(true)\nhash(undefined)\nhash(null)\nhash(NaN)\n```\n\nBigInt:\n\n```js\nhash(1) === hash(1n)\nhash(1) !== hash(2n)\n```\n\nSymbol:\n\n```js\nhash(Symbol.for('foo')) === hash(Symbol.for('foo'))\nhash(Symbol.for('foo')) === hash(Symbol('foo'))\nhash(Symbol('foo')) === hash(Symbol('foo'))\nhash(Symbol('foo')) !== hash(Symbol('bar'))\n```\n\n_Since Symbols cannot be serialized, stable-hash simply uses its description as the hash._\n\n### Regex\n\n```js\nhash(/foo/) === hash(/foo/)\nhash(/foo/) !== hash(/bar/)\n```\n\n### Date\n\n```js\nhash(new Date(1)) === hash(new Date(1))\n```\n\n### Array\n\n```js\nhash([1, '2', [new Date(3)]]) === hash([1, '2', [new Date(3)]])\nhash([1, 2]) !== hash([2, 1])\n```\n\nCircular:\n\n```js\nconst foo = []\nfoo.push(foo)\nhash(foo) === hash(foo)\n```\n\n### Object\n\n```js\nhash({ foo: 'bar' }) === hash({ foo: 'bar' })\nhash({ foo: { bar: 1 } }) === hash({ foo: { bar: 1 } })\n```\n\nStable:\n\n```js\nhash({ a: 1, b: 2, c: 3 }) === hash({ c: 3, b: 2, a: 1 })\n```\n\nCircular:\n\n```js\nconst foo = {}\nfoo.foo = foo\nhash(foo) === hash(foo)\n```\n\n### Function, Class, Set, Map, Buffer...\n\n`stable-hash` guarantees reference consistency (`===`) for objects that the constructor isn't `Object`.\n\n```js\nconst foo = () => {}\nhash(foo) === hash(foo)\nhash(foo) !== hash(() => {})\n```\n\n```js\nclass Foo {}\nhash(Foo) === hash(Foo)\nhash(Foo) !== hash(class {})\n```\n\n```js\nconst foo = new Set([1])\nhash(foo) === hash(foo)\nhash(foo) !== hash(new Set([1]))\n```\n\n## Notes\n\nThis function does something similar to `JSON.stringify`, but more than it. It doesn't generate a secure checksum, which usually has a fixed length and is hard to be reversed. With `stable-hash` it's still possible to get the original data. Also, the output might include any charaters, not just alphabets and numbers like other hash algorithms. So:\n\n- Use another encoding layer on top of it if you want to display the output. \n- Use another crypto layer on top of it if you want to have a secure and fixed length hash.\n\n```js\nimport crypto from 'crypto'\nimport hash from 'stable-hash'\n\nconst weakHash = hash(anyJavaScriptValueHere)\nconst encodedHash = Buffer.from(weakHash).toString('base64')\nconst safeHash = crypto.createHash('MD5').update(weakHash).digest('hex')\n```\n\nAlso, the consistency of this lib is sometimes guaranteed by the singularity of the WeakMap instance. So it might not generate the consistent results when running in different runtimes, e.g. server/client or parent/worker scenarios.\n\n## License\n\nCreated by Shu Ding. Released under the MIT License.\n"
        }
    ]
}