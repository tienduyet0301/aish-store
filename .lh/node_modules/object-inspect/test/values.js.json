{
    "sourceFile": "node_modules/object-inspect/test/values.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892942734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar inspect = require('../');\nvar test = require('tape');\nvar mockProperty = require('mock-property');\nvar hasSymbols = require('has-symbols/shams')();\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar forEach = require('for-each');\nvar semver = require('semver');\n\ntest('values', function (t) {\n    t.plan(1);\n    var obj = [{}, [], { 'a-b': 5 }];\n    t.equal(inspect(obj), '[ {}, [], { \\'a-b\\': 5 } ]');\n});\n\ntest('arrays with properties', function (t) {\n    t.plan(1);\n    var arr = [3];\n    arr.foo = 'bar';\n    var obj = [1, 2, arr];\n    obj.baz = 'quux';\n    obj.index = -1;\n    t.equal(inspect(obj), '[ 1, 2, [ 3, foo: \\'bar\\' ], baz: \\'quux\\', index: -1 ]');\n});\n\ntest('has', function (t) {\n    t.plan(1);\n    t.teardown(mockProperty(Object.prototype, 'hasOwnProperty', { 'delete': true }));\n\n    t.equal(inspect({ a: 1, b: 2 }), '{ a: 1, b: 2 }');\n});\n\ntest('indexOf seen', function (t) {\n    t.plan(1);\n    var xs = [1, 2, 3, {}];\n    xs.push(xs);\n\n    var seen = [];\n    seen.indexOf = undefined;\n\n    t.equal(\n        inspect(xs, {}, 0, seen),\n        '[ 1, 2, 3, {}, [Circular] ]'\n    );\n});\n\ntest('seen seen', function (t) {\n    t.plan(1);\n    var xs = [1, 2, 3];\n\n    var seen = [xs];\n    seen.indexOf = undefined;\n\n    t.equal(\n        inspect(xs, {}, 0, seen),\n        '[Circular]'\n    );\n});\n\ntest('seen seen seen', function (t) {\n    t.plan(1);\n    var xs = [1, 2, 3];\n\n    var seen = [5, xs];\n    seen.indexOf = undefined;\n\n    t.equal(\n        inspect(xs, {}, 0, seen),\n        '[Circular]'\n    );\n});\n\ntest('symbols', { skip: !hasSymbols }, function (t) {\n    var sym = Symbol('foo');\n    t.equal(inspect(sym), 'Symbol(foo)', 'Symbol(\"foo\") should be \"Symbol(foo)\"');\n    if (typeof sym === 'symbol') {\n        // Symbol shams are incapable of differentiating boxed from unboxed symbols\n        t.equal(inspect(Object(sym)), 'Object(Symbol(foo))', 'Object(Symbol(\"foo\")) should be \"Object(Symbol(foo))\"');\n    }\n\n    t.test('toStringTag', { skip: !hasToStringTag }, function (st) {\n        st.plan(1);\n\n        var faker = {};\n        faker[Symbol.toStringTag] = 'Symbol';\n        st.equal(\n            inspect(faker),\n            '{ [Symbol(Symbol.toStringTag)]: \\'Symbol\\' }',\n            'object lying about being a Symbol inspects as an object'\n        );\n    });\n\n    t.end();\n});\n\ntest('Map', { skip: typeof Map !== 'function' }, function (t) {\n    var map = new Map();\n    map.set({ a: 1 }, ['b']);\n    map.set(3, NaN);\n    var expectedString = 'Map (2) {' + inspect({ a: 1 }) + ' => ' + inspect(['b']) + ', 3 => NaN}';\n    t.equal(inspect(map), expectedString, 'new Map([[{ a: 1 }, [\"b\"]], [3, NaN]]) should show size and contents');\n    t.equal(inspect(new Map()), 'Map (0) {}', 'empty Map should show as empty');\n\n    var nestedMap = new Map();\n    nestedMap.set(nestedMap, map);\n    t.equal(inspect(nestedMap), 'Map (1) {[Circular] => ' + expectedString + '}', 'Map containing a Map should work');\n\n    t.end();\n});\n\ntest('WeakMap', { skip: typeof WeakMap !== 'function' }, function (t) {\n    var map = new WeakMap();\n    map.set({ a: 1 }, ['b']);\n    var expectedString = 'WeakMap { ? }';\n    t.equal(inspect(map), expectedString, 'new WeakMap([[{ a: 1 }, [\"b\"]]]) should not show size or contents');\n    t.equal(inspect(new WeakMap()), 'WeakMap { ? }', 'empty WeakMap should not show as empty');\n\n    t.end();\n});\n\ntest('Set', { skip: typeof Set !== 'function' }, function (t) {\n    var set = new Set();\n    set.add({ a: 1 });\n    set.add(['b']);\n    var expectedString = 'Set (2) {' + inspect({ a: 1 }) + ', ' + inspect(['b']) + '}';\n    t.equal(inspect(set), expectedString, 'new Set([{ a: 1 }, [\"b\"]]) should show size and contents');\n    t.equal(inspect(new Set()), 'Set (0) {}', 'empty Set should show as empty');\n\n    var nestedSet = new Set();\n    nestedSet.add(set);\n    nestedSet.add(nestedSet);\n    t.equal(inspect(nestedSet), 'Set (2) {' + expectedString + ', [Circular]}', 'Set containing a Set should work');\n\n    t.end();\n});\n\ntest('WeakSet', { skip: typeof WeakSet !== 'function' }, function (t) {\n    var map = new WeakSet();\n    map.add({ a: 1 });\n    var expectedString = 'WeakSet { ? }';\n    t.equal(inspect(map), expectedString, 'new WeakSet([{ a: 1 }]) should not show size or contents');\n    t.equal(inspect(new WeakSet()), 'WeakSet { ? }', 'empty WeakSet should not show as empty');\n\n    t.end();\n});\n\ntest('WeakRef', { skip: typeof WeakRef !== 'function' }, function (t) {\n    var ref = new WeakRef({ a: 1 });\n    var expectedString = 'WeakRef { ? }';\n    t.equal(inspect(ref), expectedString, 'new WeakRef({ a: 1 }) should not show contents');\n\n    t.end();\n});\n\ntest('FinalizationRegistry', { skip: typeof FinalizationRegistry !== 'function' }, function (t) {\n    var registry = new FinalizationRegistry(function () {});\n    var expectedString = 'FinalizationRegistry [FinalizationRegistry] {}';\n    t.equal(inspect(registry), expectedString, 'new FinalizationRegistry(function () {}) should work normallys');\n\n    t.end();\n});\n\ntest('Strings', function (t) {\n    var str = 'abc';\n\n    t.equal(inspect(str), \"'\" + str + \"'\", 'primitive string shows as such');\n    t.equal(inspect(str, { quoteStyle: 'single' }), \"'\" + str + \"'\", 'primitive string shows as such, single quoted');\n    t.equal(inspect(str, { quoteStyle: 'double' }), '\"' + str + '\"', 'primitive string shows as such, double quoted');\n    t.equal(inspect(Object(str)), 'Object(' + inspect(str) + ')', 'String object shows as such');\n    t.equal(inspect(Object(str), { quoteStyle: 'single' }), 'Object(' + inspect(str, { quoteStyle: 'single' }) + ')', 'String object shows as such, single quoted');\n    t.equal(inspect(Object(str), { quoteStyle: 'double' }), 'Object(' + inspect(str, { quoteStyle: 'double' }) + ')', 'String object shows as such, double quoted');\n\n    t.end();\n});\n\ntest('Numbers', function (t) {\n    var num = 42;\n\n    t.equal(inspect(num), String(num), 'primitive number shows as such');\n    t.equal(inspect(Object(num)), 'Object(' + inspect(num) + ')', 'Number object shows as such');\n\n    t.end();\n});\n\ntest('Booleans', function (t) {\n    t.equal(inspect(true), String(true), 'primitive true shows as such');\n    t.equal(inspect(Object(true)), 'Object(' + inspect(true) + ')', 'Boolean object true shows as such');\n\n    t.equal(inspect(false), String(false), 'primitive false shows as such');\n    t.equal(inspect(Object(false)), 'Object(' + inspect(false) + ')', 'Boolean false object shows as such');\n\n    t.end();\n});\n\ntest('Date', function (t) {\n    var now = new Date();\n    t.equal(inspect(now), String(now), 'Date shows properly');\n    t.equal(inspect(new Date(NaN)), 'Invalid Date', 'Invalid Date shows properly');\n\n    t.end();\n});\n\ntest('RegExps', function (t) {\n    t.equal(inspect(/a/g), '/a/g', 'regex shows properly');\n    t.equal(inspect(new RegExp('abc', 'i')), '/abc/i', 'new RegExp shows properly');\n\n    var match = 'abc abc'.match(/[ab]+/);\n    delete match.groups; // for node < 10\n    t.equal(inspect(match), '[ \\'ab\\', index: 0, input: \\'abc abc\\' ]', 'RegExp match object shows properly');\n\n    t.end();\n});\n\ntest('Proxies', { skip: typeof Proxy !== 'function' || !hasToStringTag }, function (t) {\n    var target = { proxy: true };\n    var fake = new Proxy(target, { has: function () { return false; } });\n\n    // needed to work around a weird difference in node v6.0 - v6.4 where non-present properties are not logged\n    var isNode60 = semver.satisfies(process.version, '6.0 - 6.4');\n\n    forEach([\n        'Boolean',\n        'Number',\n        'String',\n        'Symbol',\n        'Date'\n    ], function (tag) {\n        target[Symbol.toStringTag] = tag;\n\n        t.equal(\n            inspect(fake),\n            '{ ' + (isNode60 ? '' : 'proxy: true, ') + '[Symbol(Symbol.toStringTag)]: \\'' + tag + '\\' }',\n            'Proxy for + ' + tag + ' shows as the target, which has no slots'\n        );\n    });\n\n    t.end();\n});\n\ntest('fakers', { skip: !hasToStringTag }, function (t) {\n    var target = { proxy: false };\n\n    forEach([\n        'Boolean',\n        'Number',\n        'String',\n        'Symbol',\n        'Date'\n    ], function (tag) {\n        target[Symbol.toStringTag] = tag;\n\n        t.equal(\n            inspect(target),\n            '{ proxy: false, [Symbol(Symbol.toStringTag)]: \\'' + tag + '\\' }',\n            'Object pretending to be ' + tag + ' does not trick us'\n        );\n    });\n\n    t.end();\n});\n"
        }
    ]
}