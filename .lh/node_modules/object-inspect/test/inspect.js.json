{
    "sourceFile": "node_modules/object-inspect/test/inspect.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892942256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var test = require('tape');\nvar hasSymbols = require('has-symbols/shams')();\nvar utilInspect = require('../util.inspect');\nvar repeat = require('string.prototype.repeat');\n\nvar inspect = require('..');\n\ntest('inspect', function (t) {\n    t.plan(5);\n\n    var obj = [{ inspect: function xyzInspect() { return '!XYZ¡'; } }, []];\n    var stringResult = '[ !XYZ¡, [] ]';\n    var falseResult = '[ { inspect: [Function: xyzInspect] }, [] ]';\n\n    t.equal(inspect(obj), stringResult);\n    t.equal(inspect(obj, { customInspect: true }), stringResult);\n    t.equal(inspect(obj, { customInspect: 'symbol' }), falseResult);\n    t.equal(inspect(obj, { customInspect: false }), falseResult);\n    t['throws'](\n        function () { inspect(obj, { customInspect: 'not a boolean or \"symbol\"' }); },\n        TypeError,\n        '`customInspect` must be a boolean or the string \"symbol\"'\n    );\n});\n\ntest('inspect custom symbol', { skip: !hasSymbols || !utilInspect || !utilInspect.custom }, function (t) {\n    t.plan(4);\n\n    var obj = { inspect: function stringInspect() { return 'string'; } };\n    obj[utilInspect.custom] = function custom() { return 'symbol'; };\n\n    var symbolResult = '[ symbol, [] ]';\n    var stringResult = '[ string, [] ]';\n    var falseResult = '[ { inspect: [Function: stringInspect]' + (utilInspect.custom ? ', [' + inspect(utilInspect.custom) + ']: [Function: custom]' : '') + ' }, [] ]';\n\n    var symbolStringFallback = utilInspect.custom ? symbolResult : stringResult;\n    var symbolFalseFallback = utilInspect.custom ? symbolResult : falseResult;\n\n    t.equal(inspect([obj, []]), symbolStringFallback);\n    t.equal(inspect([obj, []], { customInspect: true }), symbolStringFallback);\n    t.equal(inspect([obj, []], { customInspect: 'symbol' }), symbolFalseFallback);\n    t.equal(inspect([obj, []], { customInspect: false }), falseResult);\n});\n\ntest('symbols', { skip: !hasSymbols }, function (t) {\n    t.plan(2);\n\n    var obj = { a: 1 };\n    obj[Symbol('test')] = 2;\n    obj[Symbol.iterator] = 3;\n    Object.defineProperty(obj, Symbol('non-enum'), {\n        enumerable: false,\n        value: 4\n    });\n\n    if (typeof Symbol.iterator === 'symbol') {\n        t.equal(inspect(obj), '{ a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }', 'object with symbols');\n        t.equal(inspect([obj, []]), '[ { a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }, [] ]', 'object with symbols in array');\n    } else {\n        // symbol sham key ordering is unreliable\n        t.match(\n            inspect(obj),\n            /^(?:{ a: 1, \\[Symbol\\(test\\)\\]: 2, \\[Symbol\\(Symbol.iterator\\)\\]: 3 }|{ a: 1, \\[Symbol\\(Symbol.iterator\\)\\]: 3, \\[Symbol\\(test\\)\\]: 2 })$/,\n            'object with symbols (nondeterministic symbol sham key ordering)'\n        );\n        t.match(\n            inspect([obj, []]),\n            /^\\[ (?:{ a: 1, \\[Symbol\\(test\\)\\]: 2, \\[Symbol\\(Symbol.iterator\\)\\]: 3 }|{ a: 1, \\[Symbol\\(Symbol.iterator\\)\\]: 3, \\[Symbol\\(test\\)\\]: 2 }), \\[\\] \\]$/,\n            'object with symbols in array (nondeterministic symbol sham key ordering)'\n        );\n    }\n});\n\ntest('maxStringLength', function (t) {\n    t['throws'](\n        function () { inspect('', { maxStringLength: -1 }); },\n        TypeError,\n        'maxStringLength must be >= 0, or Infinity, not negative'\n    );\n\n    var str = repeat('a', 1e8);\n\n    t.equal(\n        inspect([str], { maxStringLength: 10 }),\n        '[ \\'aaaaaaaaaa\\'... 99999990 more characters ]',\n        'maxStringLength option limits output'\n    );\n\n    t.equal(\n        inspect(['f'], { maxStringLength: null }),\n        '[ \\'\\'... 1 more character ]',\n        'maxStringLength option accepts `null`'\n    );\n\n    t.equal(\n        inspect([str], { maxStringLength: Infinity }),\n        '[ \\'' + str + '\\' ]',\n        'maxStringLength option accepts ∞'\n    );\n\n    t.end();\n});\n\ntest('inspect options', { skip: !utilInspect.custom }, function (t) {\n    var obj = {};\n    obj[utilInspect.custom] = function () {\n        return JSON.stringify(arguments);\n    };\n    t.equal(\n        inspect(obj),\n        utilInspect(obj, { depth: 5 }),\n        'custom symbols will use node\\'s inspect'\n    );\n    t.equal(\n        inspect(obj, { depth: 2 }),\n        utilInspect(obj, { depth: 2 }),\n        'a reduced depth will be passed to node\\'s inspect'\n    );\n    t.equal(\n        inspect({ d1: obj }, { depth: 3 }),\n        '{ d1: ' + utilInspect(obj, { depth: 2 }) + ' }',\n        'deep objects will receive a reduced depth'\n    );\n    t.equal(\n        inspect({ d1: obj }, { depth: 1 }),\n        '{ d1: [Object] }',\n        'unlike nodejs inspect, customInspect will not be used once the depth is exceeded.'\n    );\n    t.end();\n});\n\ntest('inspect URL', { skip: typeof URL === 'undefined' }, function (t) {\n    t.match(\n        inspect(new URL('https://nodejs.org')),\n        /nodejs\\.org/, // Different environments stringify it differently\n        'url can be inspected'\n    );\n    t.end();\n});\n"
        }
    ]
}