{
    "sourceFile": "node_modules/object-inspect/test/indent-option.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892942190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var test = require('tape');\nvar forEach = require('for-each');\n\nvar inspect = require('../');\n\ntest('bad indent options', function (t) {\n    forEach([\n        undefined,\n        true,\n        false,\n        -1,\n        1.2,\n        Infinity,\n        -Infinity,\n        NaN\n    ], function (indent) {\n        t['throws'](\n            function () { inspect('', { indent: indent }); },\n            TypeError,\n            inspect(indent) + ' is invalid'\n        );\n    });\n\n    t.end();\n});\n\ntest('simple object with indent', function (t) {\n    t.plan(2);\n\n    var obj = { a: 1, b: 2 };\n\n    var expectedSpaces = [\n        '{',\n        '  a: 1,',\n        '  b: 2',\n        '}'\n    ].join('\\n');\n    var expectedTabs = [\n        '{',\n        '\ta: 1,',\n        '\tb: 2',\n        '}'\n    ].join('\\n');\n\n    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');\n    t.equal(inspect(obj, { indent: '\\t' }), expectedTabs, 'tabs');\n});\n\ntest('two deep object with indent', function (t) {\n    t.plan(2);\n\n    var obj = { a: 1, b: { c: 3, d: 4 } };\n\n    var expectedSpaces = [\n        '{',\n        '  a: 1,',\n        '  b: {',\n        '    c: 3,',\n        '    d: 4',\n        '  }',\n        '}'\n    ].join('\\n');\n    var expectedTabs = [\n        '{',\n        '\ta: 1,',\n        '\tb: {',\n        '\t\tc: 3,',\n        '\t\td: 4',\n        '\t}',\n        '}'\n    ].join('\\n');\n\n    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');\n    t.equal(inspect(obj, { indent: '\\t' }), expectedTabs, 'tabs');\n});\n\ntest('simple array with all single line elements', function (t) {\n    t.plan(2);\n\n    var obj = [1, 2, 3, 'asdf\\nsdf'];\n\n    var expected = '[ 1, 2, 3, \\'asdf\\\\nsdf\\' ]';\n\n    t.equal(inspect(obj, { indent: 2 }), expected, 'two');\n    t.equal(inspect(obj, { indent: '\\t' }), expected, 'tabs');\n});\n\ntest('array with complex elements', function (t) {\n    t.plan(2);\n\n    var obj = [1, { a: 1, b: { c: 1 } }, 'asdf\\nsdf'];\n\n    var expectedSpaces = [\n        '[',\n        '  1,',\n        '  {',\n        '    a: 1,',\n        '    b: {',\n        '      c: 1',\n        '    }',\n        '  },',\n        '  \\'asdf\\\\nsdf\\'',\n        ']'\n    ].join('\\n');\n    var expectedTabs = [\n        '[',\n        '\t1,',\n        '\t{',\n        '\t\ta: 1,',\n        '\t\tb: {',\n        '\t\t\tc: 1',\n        '\t\t}',\n        '\t},',\n        '\t\\'asdf\\\\nsdf\\'',\n        ']'\n    ].join('\\n');\n\n    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');\n    t.equal(inspect(obj, { indent: '\\t' }), expectedTabs, 'tabs');\n});\n\ntest('values', function (t) {\n    t.plan(2);\n    var obj = [{}, [], { 'a-b': 5 }];\n\n    var expectedSpaces = [\n        '[',\n        '  {},',\n        '  [],',\n        '  {',\n        '    \\'a-b\\': 5',\n        '  }',\n        ']'\n    ].join('\\n');\n    var expectedTabs = [\n        '[',\n        '\t{},',\n        '\t[],',\n        '\t{',\n        '\t\t\\'a-b\\': 5',\n        '\t}',\n        ']'\n    ].join('\\n');\n\n    t.equal(inspect(obj, { indent: 2 }), expectedSpaces, 'two');\n    t.equal(inspect(obj, { indent: '\\t' }), expectedTabs, 'tabs');\n});\n\ntest('Map', { skip: typeof Map !== 'function' }, function (t) {\n    var map = new Map();\n    map.set({ a: 1 }, ['b']);\n    map.set(3, NaN);\n\n    var expectedStringSpaces = [\n        'Map (2) {',\n        '  { a: 1 } => [ \\'b\\' ],',\n        '  3 => NaN',\n        '}'\n    ].join('\\n');\n    var expectedStringTabs = [\n        'Map (2) {',\n        '\t{ a: 1 } => [ \\'b\\' ],',\n        '\t3 => NaN',\n        '}'\n    ].join('\\n');\n    var expectedStringTabsDoubleQuotes = [\n        'Map (2) {',\n        '\t{ a: 1 } => [ \"b\" ],',\n        '\t3 => NaN',\n        '}'\n    ].join('\\n');\n\n    t.equal(\n        inspect(map, { indent: 2 }),\n        expectedStringSpaces,\n        'Map keys are not indented (two)'\n    );\n    t.equal(\n        inspect(map, { indent: '\\t' }),\n        expectedStringTabs,\n        'Map keys are not indented (tabs)'\n    );\n    t.equal(\n        inspect(map, { indent: '\\t', quoteStyle: 'double' }),\n        expectedStringTabsDoubleQuotes,\n        'Map keys are not indented (tabs + double quotes)'\n    );\n\n    t.equal(inspect(new Map(), { indent: 2 }), 'Map (0) {}', 'empty Map should show as empty (two)');\n    t.equal(inspect(new Map(), { indent: '\\t' }), 'Map (0) {}', 'empty Map should show as empty (tabs)');\n\n    var nestedMap = new Map();\n    nestedMap.set(nestedMap, map);\n    var expectedNestedSpaces = [\n        'Map (1) {',\n        '  [Circular] => Map (2) {',\n        '    { a: 1 } => [ \\'b\\' ],',\n        '    3 => NaN',\n        '  }',\n        '}'\n    ].join('\\n');\n    var expectedNestedTabs = [\n        'Map (1) {',\n        '\t[Circular] => Map (2) {',\n        '\t\t{ a: 1 } => [ \\'b\\' ],',\n        '\t\t3 => NaN',\n        '\t}',\n        '}'\n    ].join('\\n');\n    t.equal(inspect(nestedMap, { indent: 2 }), expectedNestedSpaces, 'Map containing a Map should work (two)');\n    t.equal(inspect(nestedMap, { indent: '\\t' }), expectedNestedTabs, 'Map containing a Map should work (tabs)');\n\n    t.end();\n});\n\ntest('Set', { skip: typeof Set !== 'function' }, function (t) {\n    var set = new Set();\n    set.add({ a: 1 });\n    set.add(['b']);\n    var expectedStringSpaces = [\n        'Set (2) {',\n        '  {',\n        '    a: 1',\n        '  },',\n        '  [ \\'b\\' ]',\n        '}'\n    ].join('\\n');\n    var expectedStringTabs = [\n        'Set (2) {',\n        '\t{',\n        '\t\ta: 1',\n        '\t},',\n        '\t[ \\'b\\' ]',\n        '}'\n    ].join('\\n');\n    t.equal(inspect(set, { indent: 2 }), expectedStringSpaces, 'new Set([{ a: 1 }, [\"b\"]]) should show size and contents (two)');\n    t.equal(inspect(set, { indent: '\\t' }), expectedStringTabs, 'new Set([{ a: 1 }, [\"b\"]]) should show size and contents (tabs)');\n\n    t.equal(inspect(new Set(), { indent: 2 }), 'Set (0) {}', 'empty Set should show as empty (two)');\n    t.equal(inspect(new Set(), { indent: '\\t' }), 'Set (0) {}', 'empty Set should show as empty (tabs)');\n\n    var nestedSet = new Set();\n    nestedSet.add(set);\n    nestedSet.add(nestedSet);\n    var expectedNestedSpaces = [\n        'Set (2) {',\n        '  Set (2) {',\n        '    {',\n        '      a: 1',\n        '    },',\n        '    [ \\'b\\' ]',\n        '  },',\n        '  [Circular]',\n        '}'\n    ].join('\\n');\n    var expectedNestedTabs = [\n        'Set (2) {',\n        '\tSet (2) {',\n        '\t\t{',\n        '\t\t\ta: 1',\n        '\t\t},',\n        '\t\t[ \\'b\\' ]',\n        '\t},',\n        '\t[Circular]',\n        '}'\n    ].join('\\n');\n    t.equal(inspect(nestedSet, { indent: 2 }), expectedNestedSpaces, 'Set containing a Set should work (two)');\n    t.equal(inspect(nestedSet, { indent: '\\t' }), expectedNestedTabs, 'Set containing a Set should work (tabs)');\n\n    t.end();\n});\n"
        }
    ]
}