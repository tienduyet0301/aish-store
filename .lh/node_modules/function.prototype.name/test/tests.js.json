{
    "sourceFile": "node_modules/function.prototype.name/test/tests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892312402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar functionsHaveNames = require('functions-have-names')();\nvar arrows = require('make-arrow-function').list();\nvar generators = require('make-generator-function')();\nvar asyncs = require('make-async-function').list();\nvar IsCallable = require('is-callable');\nvar forEach = require('for-each');\n\nvar foo = Object(function foo() {});\nvar anon = Object(function () {});\nvar evalled = Object(Function()); // eslint-disable-line no-new-func\n\nmodule.exports = function (getName, t) {\n\tt.test('functions', function (st) {\n\t\tif (functionsHaveNames) {\n\t\t\tst.equal(getName(foo), foo.name, 'foo has name \"foo\"');\n\t\t\tst.equal(getName(anon), anon.name, 'anonymous function has name of empty string');\n\t\t\tst.equal(getName(evalled), evalled.name, 'eval-d function has name \"anonymous\" (or empty string)');\n\t\t}\n\t\tst.equal(getName(foo), 'foo', 'foo has name \"foo\"');\n\t\tst.equal(getName(anon), '', 'anonymous function has name of empty string');\n\t\tvar evalledName = getName(evalled);\n\t\tst.equal(evalledName === 'anonymous' || evalledName === '', true, 'eval-d function has name \"anonymous\" (or empty string');\n\t\tst.end();\n\t});\n\n\tt.test('arrow functions', { skip: arrows.length === 0 }, function (st) {\n\t\tst.equal(true, functionsHaveNames, 'functions have names in any env with arrow functions');\n\t\tforEach(arrows, function (arrowFn) {\n\t\t\tst.equal(getName(arrowFn), arrowFn.name, 'arrow function name matches for ' + arrowFn);\n\t\t});\n\t\tst.end();\n\t});\n\n\tt.test('generators', { skip: generators.length === 0 }, function (st) {\n\t\tst.equal(true, functionsHaveNames, 'functions have names in any env with generator functions');\n\t\tforEach(generators, function (genFn) {\n\t\t\tst.equal(getName(genFn), genFn.name, 'generator function name matches for ' + genFn);\n\t\t});\n\t\tst.end();\n\t});\n\n\tt.test('asyncs', { skip: asyncs.length === 0 }, function (st) {\n\t\tst.equal(true, functionsHaveNames, 'functions have names in any env with async functions');\n\t\tforEach(asyncs, function (asyncFn) {\n\t\t\tst.equal(getName(asyncFn), asyncFn.name, 'async function name matches for ' + asyncFn);\n\t\t});\n\t\tst.end();\n\t});\n\n\tt.test('Function.prototype.name', function (st) {\n\t\tst.equal(getName(function before() {}), 'before', 'function prior to accessing Function.prototype has the right name');\n\t\tvar protoName = getName(Function.prototype);\n\t\t// on <= node v2.5, this is \"Empty\"; on Opera 12.1, \"Function.prototype\" - otherwise, the empty string\n\t\tst.equal(protoName === '' || protoName === 'Empty' || protoName === 'Function.prototype', true, 'Function.prototype has the right name');\n\t\tst.equal(getName(function after() {}), 'after', 'function after accessing Function.prototype has the right name');\n\n\t\tst.end();\n\t});\n\n\tt.test('DOM', function (st) {\n\t\t/* eslint-env browser */\n\n\t\tst.test('document.all', { skip: typeof document !== 'object' }, function (s2t) {\n\t\t\ts2t['throws'](\n\t\t\t\tfunction () { getName(document.all); },\n\t\t\t\tTypeError,\n\t\t\t\t'a document.all has no name'\n\t\t\t);\n\n\t\t\ts2t.end();\n\t\t});\n\n\t\tforEach([\n\t\t\t'HTMLElement',\n\t\t\t'HTMLAnchorElement'\n\t\t], function (name) {\n\t\t\tvar constructor = global[name];\n\n\t\t\tst.test(name, { skip: !constructor }, function (s2t) {\n\t\t\t\ts2t.match(typeof constructor, /^(?:function|object)$/, name + ' is a function or an object');\n\n\t\t\t\tif (IsCallable(constructor)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ts2t.equal(getName(constructor), name, name + ' has the right name');\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\ts2t.fail(e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ts2t['throws'](\n\t\t\t\t\t\tfunction () { getName(constructor); },\n\t\t\t\t\t\tTypeError,\n\t\t\t\t\t\tname + ' is not callable'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\ts2t.end();\n\t\t\t});\n\t\t});\n\n\t\tst.end();\n\t});\n};\n"
        }
    ]
}