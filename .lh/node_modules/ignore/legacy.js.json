{
    "sourceFile": "node_modules/ignore/legacy.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892325291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n// A simple implementation of make-array\nfunction makeArray(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\nvar EMPTY = '';\nvar SPACE = ' ';\nvar ESCAPE = '\\\\';\nvar REGEX_TEST_BLANK_LINE = /^\\s+$/;\nvar REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/;\nvar REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nvar REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nvar REGEX_SPLITALL_CRLF = /\\r?\\n/g;\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nvar REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nvar SLASH = '/';\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nvar TMP_KEY_IGNORE = 'node-ignore';\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol[\"for\"]('node-ignore');\n}\nvar KEY_IGNORE = TMP_KEY_IGNORE;\nvar define = function define(object, key, value) {\n  return Object.defineProperty(object, key, {\n    value: value\n  });\n};\nvar REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\nvar RETURN_FALSE = function RETURN_FALSE() {\n  return false;\n};\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nvar sanitizeRange = function sanitizeRange(range) {\n  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {\n    return from.charCodeAt(0) <= to.charCodeAt(0) ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY;\n  });\n};\n\n// See fixtures #59\nvar cleanRangeBackSlash = function cleanRangeBackSlash(slashes) {\n  var length = slashes.length;\n  return slashes.slice(0, length - length % 2);\n};\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nvar REPLACERS = [[\n// remove BOM\n// TODO:\n// Other similar zero-width characters?\n/^\\uFEFF/, function () {\n  return EMPTY;\n}],\n// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[\n// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a ) -> (a)\n// (a \\ ) -> (a  )\n/((?:\\\\\\\\)*?)(\\\\?\\s+)$/, function (_, m1, m2) {\n  return m1 + (m2.indexOf('\\\\') === 0 ? SPACE : EMPTY);\n}],\n// replace (\\ ) with ' '\n// (\\ ) -> ' '\n// (\\\\ ) -> '\\\\ '\n// (\\\\\\ ) -> '\\\\ '\n[/(\\\\+?)\\s/g, function (_, m1) {\n  var length = m1.length;\n  return m1.slice(0, length - length % 2) + SPACE;\n}],\n// Escape metacharacters\n// which is written down by users but means special for regular expressions.\n\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\$.|*+(){^]/g, function (match) {\n  return \"\\\\\".concat(match);\n}], [\n// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, function () {\n  return '[^/]';\n}],\n// leading slash\n[\n// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, function () {\n  return '^';\n}],\n// replace special metacharacter slash after the leading slash\n[/\\//g, function () {\n  return '\\\\/';\n}], [\n// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//,\n// '**/foo' <-> 'foo'\nfunction () {\n  return '^(?:.*\\\\/)?';\n}],\n// starting\n[\n// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  // If has a slash `/` at the beginning or middle\n  return !/\\/(?!$)/.test(this)\n  // > Prior to 2.22.1\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n\n  // After 2.22.1 (compatible but clearer)\n  // > If there is a separator at the beginning or middle (or both)\n  // > of the pattern, then the pattern is relative to the directory\n  // > level of the particular .gitignore file itself.\n  // > Otherwise the pattern may also match at any level below\n  // > the .gitignore level.\n  ? '(?:^|\\\\/)'\n\n  // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}],\n// two globstars\n[\n// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n// Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n\n// Check if it is not the last `'/**'`\nfunction (_, index, str) {\n  return index + 6 < str.length\n\n  // case: /**/\n  // > A slash followed by two consecutive asterisks then a slash matches\n  // >   zero or more directories.\n  // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n  // '/**/'\n  ? '(?:\\\\/[^\\\\/]+)*'\n\n  // case: /**\n  // > A trailing `\"/**\"` matches everything inside.\n\n  // #21: everything inside but it should not include the current folder\n  : '\\\\/.+';\n}],\n// normal intermediate wildcards\n[\n// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule,\n//    coz trailing single wildcard will be handed by [trailing wildcard]\n/(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n// '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\nfunction (_, p1, p2) {\n  // 1.\n  // > An asterisk \"*\" matches anything except a slash.\n  // 2.\n  // > Other consecutive asterisks are considered regular asterisks\n  // > and will match according to the previous rules.\n  var unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*');\n  return p1 + unescaped;\n}], [\n// unescape, revert step 3 except for back slash\n// For example, if a user escape a '\\\\*',\n// after step 3, the result will be '\\\\\\\\\\\\*'\n/\\\\\\\\\\\\(?=[$.|*+(){^])/g, function () {\n  return ESCAPE;\n}], [\n// '\\\\\\\\' -> '\\\\'\n/\\\\\\\\/g, function () {\n  return ESCAPE;\n}], [\n// > The range notation, e.g. [a-zA-Z],\n// > can be used to match one of the characters in a range.\n\n// `\\` is escaped by step 3\n/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, function (match, leadEscape, range, endEscape, close) {\n  return leadEscape === ESCAPE\n  // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n  ? \"\\\\[\".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === ']' ? endEscape.length % 2 === 0\n  // A normal case, and it is a range notation\n  // '[bar]'\n  // '[bar\\\\\\\\]'\n  ? \"[\".concat(sanitizeRange(range)).concat(endEscape, \"]\") // Invalid range notaton\n  // '[bar\\\\]' -> '[bar\\\\\\\\]'\n  : '[]' : '[]';\n}],\n// ending\n[\n// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*])$/,\n// WTF!\n// https://git-scm.com/docs/gitignore\n// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n// which re-fixes #24, #38\n\n// > If there is a separator at the end of the pattern then the pattern\n// > will only match directories, otherwise the pattern can match both\n// > files and directories.\n\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nfunction (match) {\n  return /\\/$/.test(match)\n  // foo/ will not match 'foo'\n  ? \"\".concat(match, \"$\") // foo matches 'foo' and 'foo/'\n  : \"\".concat(match, \"(?=$|\\\\/$)\");\n}],\n// trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, function (_, p1) {\n  var prefix = p1\n  // '\\^':\n  // '/*' does not match EMPTY\n  // '/*' does not match everything\n\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? \"\".concat(p1, \"[^/]+\") // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return \"\".concat(prefix, \"(?=$|\\\\/$)\");\n}]];\n\n// A simple cache, because an ignore rule only has only one certain meaning\nvar regexCache = Object.create(null);\n\n// @param {pattern}\nvar makeRegex = function makeRegex(pattern, ignoreCase) {\n  var source = regexCache[pattern];\n  if (!source) {\n    source = REPLACERS.reduce(function (prev, _ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        matcher = _ref2[0],\n        replacer = _ref2[1];\n      return prev.replace(matcher, replacer.bind(pattern));\n    }, pattern);\n    regexCache[pattern] = source;\n  }\n  return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);\n};\nvar isString = function isString(subject) {\n  return typeof subject === 'string';\n};\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nvar checkPattern = function checkPattern(pattern) {\n  return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0;\n};\nvar splitPattern = function splitPattern(pattern) {\n  return pattern.split(REGEX_SPLITALL_CRLF);\n};\nvar IgnoreRule = /*#__PURE__*/_createClass(function IgnoreRule(origin, pattern, negative, regex) {\n  _classCallCheck(this, IgnoreRule);\n  this.origin = origin;\n  this.pattern = pattern;\n  this.negative = negative;\n  this.regex = regex;\n});\nvar createRule = function createRule(pattern, ignoreCase) {\n  var origin = pattern;\n  var negative = false;\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');\n  var regex = makeRegex(pattern, ignoreCase);\n  return new IgnoreRule(origin, pattern, negative, regex);\n};\nvar throwError = function throwError(message, Ctor) {\n  throw new Ctor(message);\n};\nvar checkPath = function checkPath(path, originalPath, doThrow) {\n  if (!isString(path)) {\n    return doThrow(\"path must be a string, but got `\".concat(originalPath, \"`\"), TypeError);\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(\"path must not be empty\", TypeError);\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    var r = '`path.relative()`d';\n    return doThrow(\"path should be a \".concat(r, \" string, but got \\\"\").concat(originalPath, \"\\\"\"), RangeError);\n  }\n  return true;\n};\nvar isNotRelative = function isNotRelative(path) {\n  return REGEX_TEST_INVALID_PATH.test(path);\n};\ncheckPath.isNotRelative = isNotRelative;\ncheckPath.convert = function (p) {\n  return p;\n};\nvar Ignore = /*#__PURE__*/function () {\n  function Ignore() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref3$ignorecase = _ref3.ignorecase,\n      ignorecase = _ref3$ignorecase === void 0 ? true : _ref3$ignorecase,\n      _ref3$ignoreCase = _ref3.ignoreCase,\n      ignoreCase = _ref3$ignoreCase === void 0 ? ignorecase : _ref3$ignoreCase,\n      _ref3$allowRelativePa = _ref3.allowRelativePaths,\n      allowRelativePaths = _ref3$allowRelativePa === void 0 ? false : _ref3$allowRelativePa;\n    _classCallCheck(this, Ignore);\n    define(this, KEY_IGNORE, true);\n    this._rules = [];\n    this._ignoreCase = ignoreCase;\n    this._allowRelativePaths = allowRelativePaths;\n    this._initCache();\n  }\n  _createClass(Ignore, [{\n    key: \"_initCache\",\n    value: function _initCache() {\n      this._ignoreCache = Object.create(null);\n      this._testCache = Object.create(null);\n    }\n  }, {\n    key: \"_addPattern\",\n    value: function _addPattern(pattern) {\n      // #32\n      if (pattern && pattern[KEY_IGNORE]) {\n        this._rules = this._rules.concat(pattern._rules);\n        this._added = true;\n        return;\n      }\n      if (checkPattern(pattern)) {\n        var rule = createRule(pattern, this._ignoreCase);\n        this._added = true;\n        this._rules.push(rule);\n      }\n    }\n\n    // @param {Array<string> | string | Ignore} pattern\n  }, {\n    key: \"add\",\n    value: function add(pattern) {\n      this._added = false;\n      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);\n\n      // Some rules have just added to the ignore,\n      // making the behavior changed.\n      if (this._added) {\n        this._initCache();\n      }\n      return this;\n    }\n\n    // legacy\n  }, {\n    key: \"addPattern\",\n    value: function addPattern(pattern) {\n      return this.add(pattern);\n    }\n\n    //          |           ignored : unignored\n    // negative |   0:0   |   0:1   |   1:0   |   1:1\n    // -------- | ------- | ------- | ------- | --------\n    //     0    |  TEST   |  TEST   |  SKIP   |    X\n    //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n    // - SKIP: always skip\n    // - TEST: always test\n    // - TESTIF: only test if checkUnignored\n    // - X: that never happen\n\n    // @param {boolean} whether should check if the path is unignored,\n    //   setting `checkUnignored` to `false` could reduce additional\n    //   path matching.\n\n    // @returns {TestResult} true if a file is ignored\n  }, {\n    key: \"_testOne\",\n    value: function _testOne(path, checkUnignored) {\n      var ignored = false;\n      var unignored = false;\n      this._rules.forEach(function (rule) {\n        var negative = rule.negative;\n        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n          return;\n        }\n        var matched = rule.regex.test(path);\n        if (matched) {\n          ignored = !negative;\n          unignored = negative;\n        }\n      });\n      return {\n        ignored: ignored,\n        unignored: unignored\n      };\n    }\n\n    // @returns {TestResult}\n  }, {\n    key: \"_test\",\n    value: function _test(originalPath, cache, checkUnignored, slices) {\n      var path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath);\n      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n      return this._t(path, cache, checkUnignored, slices);\n    }\n  }, {\n    key: \"_t\",\n    value: function _t(path, cache, checkUnignored, slices) {\n      if (path in cache) {\n        return cache[path];\n      }\n      if (!slices) {\n        // path/to/a.js\n        // ['path', 'to', 'a.js']\n        slices = path.split(SLASH);\n      }\n      slices.pop();\n\n      // If the path has no parent directory, just test it\n      if (!slices.length) {\n        return cache[path] = this._testOne(path, checkUnignored);\n      }\n      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);\n\n      // If the path contains a parent directory, check the parent first\n      return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent : this._testOne(path, checkUnignored);\n    }\n  }, {\n    key: \"ignores\",\n    value: function ignores(path) {\n      return this._test(path, this._ignoreCache, false).ignored;\n    }\n  }, {\n    key: \"createFilter\",\n    value: function createFilter() {\n      var _this = this;\n      return function (path) {\n        return !_this.ignores(path);\n      };\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(paths) {\n      return makeArray(paths).filter(this.createFilter());\n    }\n\n    // @returns {TestResult}\n  }, {\n    key: \"test\",\n    value: function test(path) {\n      return this._test(path, this._testCache, true);\n    }\n  }]);\n  return Ignore;\n}();\nvar factory = function factory(options) {\n  return new Ignore(options);\n};\nvar isPathValid = function isPathValid(path) {\n  return checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\n};\nfactory.isPathValid = isPathValid;\n\n// Fixes typescript\nfactory[\"default\"] = factory;\nmodule.exports = factory;\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if */\nif (\n// Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  /* eslint no-control-regex: \"off\" */\n  var makePosix = function makePosix(str) {\n    return /^\\\\\\\\\\?\\\\/.test(str) || /[\\0-\\x1F\"<>\\|]+/.test(str) ? str : str.replace(/\\\\/g, '/');\n  };\n  checkPath.convert = makePosix;\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n  checkPath.isNotRelative = function (path) {\n    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n  };\n}\n"
        }
    ]
}