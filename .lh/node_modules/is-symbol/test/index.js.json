{
    "sourceFile": "node_modules/is-symbol/test/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892342837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar test = require('tape');\nvar forEach = require('for-each');\nvar v = require('es-value-fixtures');\n\nvar isSymbol = require('../index');\n\nvar hasSymbols = require('has-symbols')();\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar inspect = require('object-inspect');\n\ntest('non-symbol values', function (t) {\n\tvar nonSymbols = v.nonSymbolPrimitives.concat(\n\t\tObject(true),\n\t\tObject(false),\n\t\t// @ts-expect-error TS sucks with concat\n\t\t{},\n\t\t[],\n\t\t/a/g,\n\t\tnew Date(),\n\t\tfunction () {},\n\t\tNaN\n\t);\n\tt.plan(nonSymbols.length);\n\tforEach(nonSymbols, function (nonSymbol) {\n\t\tt.equal(isSymbol(nonSymbol), false, inspect(nonSymbol) + ' is not a symbol');\n\t});\n\tt.end();\n});\n\ntest('faked symbol values', function (t) {\n\tt.test('real symbol valueOf', { skip: !hasSymbols }, function (st) {\n\t\tvar fakeSymbol = { valueOf: function () { return Symbol('foo'); } };\n\t\tst.equal(isSymbol(fakeSymbol), false, 'object with valueOf returning a symbol is not a symbol');\n\t\tst.end();\n\t});\n\n\tt.test('faked @@toStringTag', { skip: !hasToStringTag }, function (st) {\n\t\t/** @type {{ valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */\n\t\tvar fakeSymbol = { valueOf: function () { return Symbol('foo'); } };\n\t\tfakeSymbol[Symbol.toStringTag] = 'Symbol';\n\t\tst.equal(isSymbol(fakeSymbol), false, 'object with fake Symbol @@toStringTag and valueOf returning a symbol is not a symbol');\n\n\t\t/** @type {{ valueOf(): unknown; [Symbol.toStringTag]?: unknown }} */\n\t\tvar notSoFakeSymbol = { valueOf: function () { return 42; } };\n\t\tnotSoFakeSymbol[Symbol.toStringTag] = 'Symbol';\n\t\tst.equal(isSymbol(notSoFakeSymbol), false, 'object with fake Symbol @@toStringTag and valueOf not returning a symbol is not a symbol');\n\t\tst.end();\n\t});\n\n\tvar fakeSymbolString = { toString: function () { return 'Symbol(foo)'; } };\n\tt.equal(isSymbol(fakeSymbolString), false, 'object with toString returning Symbol(foo) is not a symbol');\n\n\tt.end();\n});\n\ntest('Symbol support', { skip: !hasSymbols }, function (t) {\n\tt.test('well-known Symbols', function (st) {\n\t\t/** @type {(name: string) => name is Exclude<keyof SymbolConstructor, 'for' | 'keyFor'>} */\n\t\tvar isWellKnown = function filterer(name) {\n\t\t\treturn name !== 'for' && name !== 'keyFor' && !(name in filterer);\n\t\t};\n\t\tvar wellKnownSymbols = Object.getOwnPropertyNames(Symbol).filter(isWellKnown);\n\t\twellKnownSymbols.forEach(function (name) {\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tvar sym = Symbol[/** @type {keyof SymbolConstructor} */ (name)];\n\t\t\tst.equal(isSymbol(sym), true, inspect(sym) + ' is a symbol');\n\t\t});\n\t\tst.end();\n\t});\n\n\tt.test('user-created symbols', function (st) {\n\t\tvar symbols = v.symbols.concat(\n\t\t\tSymbol(),\n\t\t\tSymbol('foo'),\n\t\t\tSymbol['for']('foo'),\n\t\t\tObject(Symbol('object'))\n\t\t);\n\t\tsymbols.forEach(function (sym) {\n\t\t\tst.equal(isSymbol(sym), true, inspect(sym) + ' is a symbol');\n\t\t});\n\t\tst.end();\n\t});\n\n\tt.end();\n});\n\n"
        }
    ]
}