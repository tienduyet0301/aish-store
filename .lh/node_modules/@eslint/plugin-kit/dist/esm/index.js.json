{
    "sourceFile": "node_modules/@eslint/plugin-kit/dist/esm/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891759690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// @ts-self-types=\"./index.d.ts\"\nimport levn from 'levn';\n\n/**\n * @fileoverview Config Comment Parser\n * @author Nicholas C. Zakas\n */\n\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@eslint/core\").RuleConfig} RuleConfig */\n/** @typedef {import(\"@eslint/core\").RulesConfig} RulesConfig */\n/** @typedef {import(\"./types.ts\").StringConfig} StringConfig */\n/** @typedef {import(\"./types.ts\").BooleanConfig} BooleanConfig */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst directivesPattern = /^([a-z]+(?:-[a-z]+)*)(?:\\s|$)/u;\nconst validSeverities = new Set([0, 1, 2, \"off\", \"warn\", \"error\"]);\n\n/**\n * Determines if the severity in the rule configuration is valid.\n * @param {RuleConfig} ruleConfig A rule's configuration.\n */\nfunction isSeverityValid(ruleConfig) {\n\tconst severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\treturn validSeverities.has(severity);\n}\n\n/**\n * Determines if all severities in the rules configuration are valid.\n * @param {RulesConfig} rulesConfig The rules configuration to check.\n * @returns {boolean} `true` if all severities are valid, otherwise `false`.\n */\nfunction isEverySeverityValid(rulesConfig) {\n\treturn Object.values(rulesConfig).every(isSeverityValid);\n}\n\n/**\n * Represents a directive comment.\n */\nclass DirectiveComment {\n\t/**\n\t * The label of the directive, such as \"eslint\", \"eslint-disable\", etc.\n\t * @type {string}\n\t */\n\tlabel = \"\";\n\n\t/**\n\t * The value of the directive (the string after the label).\n\t * @type {string}\n\t */\n\tvalue = \"\";\n\n\t/**\n\t * The justification of the directive (the string after the --).\n\t * @type {string}\n\t */\n\tjustification = \"\";\n\n\t/**\n\t * Creates a new directive comment.\n\t * @param {string} label The label of the directive.\n\t * @param {string} value The value of the directive.\n\t * @param {string} justification The justification of the directive.\n\t */\n\tconstructor(label, value, justification) {\n\t\tthis.label = label;\n\t\tthis.value = value;\n\t\tthis.justification = justification;\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object to parse ESLint configuration comments.\n */\nclass ConfigCommentParser {\n\t/**\n\t * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n\t * whitespace. Used for \"global\" comments.\n\t * @param {string} string The string to parse.\n\t * @returns {StringConfig} Result map object of names and string values, or null values if no value was provided.\n\t */\n\tparseStringConfig(string) {\n\t\tconst items = /** @type {StringConfig} */ ({});\n\n\t\t// Collapse whitespace around `:` and `,` to make parsing easier\n\t\tconst trimmedString = string\n\t\t\t.trim()\n\t\t\t.replace(/(?<!\\s)\\s*([:,])\\s*/gu, \"$1\");\n\n\t\ttrimmedString.split(/\\s|,+/u).forEach(name => {\n\t\t\tif (!name) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n\t\t\tconst [key, value = null] = name.split(\":\");\n\n\t\t\titems[key] = value;\n\t\t});\n\n\t\treturn items;\n\t}\n\n\t/**\n\t * Parses a JSON-like config.\n\t * @param {string} string The string to parse.\n\t * @returns {({ok: true, config: RulesConfig}|{ok: false, error: {message: string}})} Result map object\n\t */\n\tparseJSONLikeConfig(string) {\n\t\t// Parses a JSON-like comment by the same way as parsing CLI option.\n\t\ttry {\n\t\t\tconst items =\n\t\t\t\t/** @type {RulesConfig} */ (levn.parse(\"Object\", string)) || {};\n\n\t\t\t/*\n\t\t\t * When the configuration has any invalid severities, it should be completely\n\t\t\t * ignored. This is because the configuration is not valid and should not be\n\t\t\t * applied.\n\t\t\t *\n\t\t\t * For example, the following configuration is invalid:\n\t\t\t *\n\t\t\t *    \"no-alert: 2 no-console: 2\"\n\t\t\t *\n\t\t\t * This results in a configuration of { \"no-alert\": \"2 no-console: 2\" }, which is\n\t\t\t * not valid. In this case, the configuration should be ignored.\n\t\t\t */\n\t\t\tif (isEverySeverityValid(items)) {\n\t\t\t\treturn {\n\t\t\t\t\tok: true,\n\t\t\t\t\tconfig: items,\n\t\t\t\t};\n\t\t\t}\n\t\t} catch {\n\t\t\t// levn parsing error: ignore to parse the string by a fallback.\n\t\t}\n\n\t\t/*\n\t\t * Optionator cannot parse commaless notations.\n\t\t * But we are supporting that. So this is a fallback for that.\n\t\t */\n\t\tconst normalizedString = string\n\t\t\t.replace(/([-a-zA-Z0-9/]+):/gu, '\"$1\":')\n\t\t\t.replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n\t\ttry {\n\t\t\tconst items = JSON.parse(`{${normalizedString}}`);\n\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tconfig: items,\n\t\t\t};\n\t\t} catch (ex) {\n\t\t\tconst errorMessage = ex instanceof Error ? ex.message : String(ex);\n\n\t\t\treturn {\n\t\t\t\tok: false,\n\t\t\t\terror: {\n\t\t\t\t\tmessage: `Failed to parse JSON from '${normalizedString}': ${errorMessage}`,\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Parses a config of values separated by comma.\n\t * @param {string} string The string to parse.\n\t * @returns {BooleanConfig} Result map of values and true values\n\t */\n\tparseListConfig(string) {\n\t\tconst items = /** @type {BooleanConfig} */ ({});\n\n\t\tstring.split(\",\").forEach(name => {\n\t\t\tconst trimmedName = name\n\t\t\t\t.trim()\n\t\t\t\t.replace(\n\t\t\t\t\t/^(?<quote>['\"]?)(?<ruleId>.*)\\k<quote>$/su,\n\t\t\t\t\t\"$<ruleId>\",\n\t\t\t\t);\n\n\t\t\tif (trimmedName) {\n\t\t\t\titems[trimmedName] = true;\n\t\t\t}\n\t\t});\n\n\t\treturn items;\n\t}\n\n\t/**\n\t * Extract the directive and the justification from a given directive comment and trim them.\n\t * @param {string} value The comment text to extract.\n\t * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.\n\t */\n\t#extractDirectiveComment(value) {\n\t\tconst match = /\\s-{2,}\\s/u.exec(value);\n\n\t\tif (!match) {\n\t\t\treturn { directivePart: value.trim(), justificationPart: \"\" };\n\t\t}\n\n\t\tconst directive = value.slice(0, match.index).trim();\n\t\tconst justification = value.slice(match.index + match[0].length).trim();\n\n\t\treturn { directivePart: directive, justificationPart: justification };\n\t}\n\n\t/**\n\t * Parses a directive comment into directive text and value.\n\t * @param {string} string The string with the directive to be parsed.\n\t * @returns {DirectiveComment|undefined} The parsed directive or `undefined` if the directive is invalid.\n\t */\n\tparseDirective(string) {\n\t\tconst { directivePart, justificationPart } =\n\t\t\tthis.#extractDirectiveComment(string);\n\t\tconst match = directivesPattern.exec(directivePart);\n\n\t\tif (!match) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst directiveText = match[1];\n\t\tconst directiveValue = directivePart.slice(\n\t\t\tmatch.index + directiveText.length,\n\t\t);\n\n\t\treturn new DirectiveComment(\n\t\t\tdirectiveText,\n\t\t\tdirectiveValue.trim(),\n\t\t\tjustificationPart,\n\t\t);\n\t}\n}\n\n/**\n * @fileoverview A collection of helper classes for implementing `SourceCode`.\n * @author Nicholas C. Zakas\n */\n\n/* eslint class-methods-use-this: off -- Required to complete interface. */\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@eslint/core\").VisitTraversalStep} VisitTraversalStep */\n/** @typedef {import(\"@eslint/core\").CallTraversalStep} CallTraversalStep */\n/** @typedef {import(\"@eslint/core\").TextSourceCode} TextSourceCode */\n/** @typedef {import(\"@eslint/core\").TraversalStep} TraversalStep */\n/** @typedef {import(\"@eslint/core\").SourceLocation} SourceLocation */\n/** @typedef {import(\"@eslint/core\").SourceLocationWithOffset} SourceLocationWithOffset */\n/** @typedef {import(\"@eslint/core\").SourceRange} SourceRange */\n/** @typedef {import(\"@eslint/core\").Directive} IDirective */\n/** @typedef {import(\"@eslint/core\").DirectiveType} DirectiveType */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a node has ESTree-style loc information.\n * @param {object} node The node to check.\n * @returns {node is {loc:SourceLocation}} `true` if the node has ESTree-style loc information, `false` if not.\n */\nfunction hasESTreeStyleLoc(node) {\n\treturn \"loc\" in node;\n}\n\n/**\n * Determines if a node has position-style loc information.\n * @param {object} node The node to check.\n * @returns {node is {position:SourceLocation}} `true` if the node has position-style range information, `false` if not.\n */\nfunction hasPosStyleLoc(node) {\n\treturn \"position\" in node;\n}\n\n/**\n * Determines if a node has ESTree-style range information.\n * @param {object} node The node to check.\n * @returns {node is {range:SourceRange}} `true` if the node has ESTree-style range information, `false` if not.\n */\nfunction hasESTreeStyleRange(node) {\n\treturn \"range\" in node;\n}\n\n/**\n * Determines if a node has position-style range information.\n * @param {object} node The node to check.\n * @returns {node is {position:SourceLocationWithOffset}} `true` if the node has position-style range information, `false` if not.\n */\nfunction hasPosStyleRange(node) {\n\treturn \"position\" in node;\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A class to represent a step in the traversal process where a node is visited.\n * @implements {VisitTraversalStep}\n */\nclass VisitNodeStep {\n\t/**\n\t * The type of the step.\n\t * @type {\"visit\"}\n\t * @readonly\n\t */\n\ttype = \"visit\";\n\n\t/**\n\t * The kind of the step. Represents the same data as the `type` property\n\t * but it's a number for performance.\n\t * @type {1}\n\t * @readonly\n\t */\n\tkind = 1;\n\n\t/**\n\t * The target of the step.\n\t * @type {object}\n\t */\n\ttarget;\n\n\t/**\n\t * The phase of the step.\n\t * @type {1|2}\n\t */\n\tphase;\n\n\t/**\n\t * The arguments of the step.\n\t * @type {Array<any>}\n\t */\n\targs;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Object} options The options for the step.\n\t * @param {object} options.target The target of the step.\n\t * @param {1|2} options.phase The phase of the step.\n\t * @param {Array<any>} options.args The arguments of the step.\n\t */\n\tconstructor({ target, phase, args }) {\n\t\tthis.target = target;\n\t\tthis.phase = phase;\n\t\tthis.args = args;\n\t}\n}\n\n/**\n * A class to represent a step in the traversal process where a\n * method is called.\n * @implements {CallTraversalStep}\n */\nclass CallMethodStep {\n\t/**\n\t * The type of the step.\n\t * @type {\"call\"}\n\t * @readonly\n\t */\n\ttype = \"call\";\n\n\t/**\n\t * The kind of the step. Represents the same data as the `type` property\n\t * but it's a number for performance.\n\t * @type {2}\n\t * @readonly\n\t */\n\tkind = 2;\n\n\t/**\n\t * The name of the method to call.\n\t * @type {string}\n\t */\n\ttarget;\n\n\t/**\n\t * The arguments to pass to the method.\n\t * @type {Array<any>}\n\t */\n\targs;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Object} options The options for the step.\n\t * @param {string} options.target The target of the step.\n\t * @param {Array<any>} options.args The arguments of the step.\n\t */\n\tconstructor({ target, args }) {\n\t\tthis.target = target;\n\t\tthis.args = args;\n\t}\n}\n\n/**\n * A class to represent a directive comment.\n * @implements {IDirective}\n */\nclass Directive {\n\t/**\n\t * The type of directive.\n\t * @type {DirectiveType}\n\t * @readonly\n\t */\n\ttype;\n\n\t/**\n\t * The node representing the directive.\n\t * @type {unknown}\n\t * @readonly\n\t */\n\tnode;\n\n\t/**\n\t * Everything after the \"eslint-disable\" portion of the directive,\n\t * but before the \"--\" that indicates the justification.\n\t * @type {string}\n\t * @readonly\n\t */\n\tvalue;\n\n\t/**\n\t * The justification for the directive.\n\t * @type {string}\n\t * @readonly\n\t */\n\tjustification;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Object} options The options for the directive.\n\t * @param {\"disable\"|\"enable\"|\"disable-next-line\"|\"disable-line\"} options.type The type of directive.\n\t * @param {unknown} options.node The node representing the directive.\n\t * @param {string} options.value The value of the directive.\n\t * @param {string} options.justification The justification for the directive.\n\t */\n\tconstructor({ type, node, value, justification }) {\n\t\tthis.type = type;\n\t\tthis.node = node;\n\t\tthis.value = value;\n\t\tthis.justification = justification;\n\t}\n}\n\n/**\n * Source Code Base Object\n * @implements {TextSourceCode}\n */\nclass TextSourceCodeBase {\n\t/**\n\t * The lines of text in the source code.\n\t * @type {Array<string>}\n\t */\n\t#lines;\n\n\t/**\n\t * The AST of the source code.\n\t * @type {object}\n\t */\n\tast;\n\n\t/**\n\t * The text of the source code.\n\t * @type {string}\n\t */\n\ttext;\n\n\t/**\n\t * Creates a new instance.\n\t * @param {Object} options The options for the instance.\n\t * @param {string} options.text The source code text.\n\t * @param {object} options.ast The root AST node.\n\t * @param {RegExp} [options.lineEndingPattern] The pattern to match lineEndings in the source code.\n\t */\n\tconstructor({ text, ast, lineEndingPattern = /\\r?\\n/u }) {\n\t\tthis.ast = ast;\n\t\tthis.text = text;\n\t\tthis.#lines = text.split(lineEndingPattern);\n\t}\n\n\t/**\n\t * Returns the loc information for the given node or token.\n\t * @param {object} nodeOrToken The node or token to get the loc information for.\n\t * @returns {SourceLocation} The loc information for the node or token.\n\t */\n\tgetLoc(nodeOrToken) {\n\t\tif (hasESTreeStyleLoc(nodeOrToken)) {\n\t\t\treturn nodeOrToken.loc;\n\t\t}\n\n\t\tif (hasPosStyleLoc(nodeOrToken)) {\n\t\t\treturn nodeOrToken.position;\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t\"Custom getLoc() method must be implemented in the subclass.\",\n\t\t);\n\t}\n\n\t/**\n\t * Returns the range information for the given node or token.\n\t * @param {object} nodeOrToken The node or token to get the range information for.\n\t * @returns {SourceRange} The range information for the node or token.\n\t */\n\tgetRange(nodeOrToken) {\n\t\tif (hasESTreeStyleRange(nodeOrToken)) {\n\t\t\treturn nodeOrToken.range;\n\t\t}\n\n\t\tif (hasPosStyleRange(nodeOrToken)) {\n\t\t\treturn [\n\t\t\t\tnodeOrToken.position.start.offset,\n\t\t\t\tnodeOrToken.position.end.offset,\n\t\t\t];\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t\"Custom getRange() method must be implemented in the subclass.\",\n\t\t);\n\t}\n\n\t/* eslint-disable no-unused-vars -- Required to complete interface. */\n\t/**\n\t * Returns the parent of the given node.\n\t * @param {object} node The node to get the parent of.\n\t * @returns {object|undefined} The parent of the node.\n\t */\n\tgetParent(node) {\n\t\tthrow new Error(\"Not implemented.\");\n\t}\n\t/* eslint-enable no-unused-vars -- Required to complete interface. */\n\n\t/**\n\t * Gets all the ancestors of a given node\n\t * @param {object} node The node\n\t * @returns {Array<object>} All the ancestor nodes in the AST, not including the provided node, starting\n\t * from the root node at index 0 and going inwards to the parent node.\n\t * @throws {TypeError} When `node` is missing.\n\t */\n\tgetAncestors(node) {\n\t\tif (!node) {\n\t\t\tthrow new TypeError(\"Missing required argument: node.\");\n\t\t}\n\n\t\tconst ancestorsStartingAtParent = [];\n\n\t\tfor (\n\t\t\tlet ancestor = this.getParent(node);\n\t\t\tancestor;\n\t\t\tancestor = this.getParent(ancestor)\n\t\t) {\n\t\t\tancestorsStartingAtParent.push(ancestor);\n\t\t}\n\n\t\treturn ancestorsStartingAtParent.reverse();\n\t}\n\n\t/**\n\t * Gets the source code for the given node.\n\t * @param {object} [node] The AST node to get the text for.\n\t * @param {number} [beforeCount] The number of characters before the node to retrieve.\n\t * @param {number} [afterCount] The number of characters after the node to retrieve.\n\t * @returns {string} The text representing the AST node.\n\t * @public\n\t */\n\tgetText(node, beforeCount, afterCount) {\n\t\tif (node) {\n\t\t\tconst range = this.getRange(node);\n\t\t\treturn this.text.slice(\n\t\t\t\tMath.max(range[0] - (beforeCount || 0), 0),\n\t\t\t\trange[1] + (afterCount || 0),\n\t\t\t);\n\t\t}\n\t\treturn this.text;\n\t}\n\n\t/**\n\t * Gets the entire source text split into an array of lines.\n\t * @returns {Array<string>} The source text as an array of lines.\n\t * @public\n\t */\n\tget lines() {\n\t\treturn this.#lines;\n\t}\n\n\t/**\n\t * Traverse the source code and return the steps that were taken.\n\t * @returns {Iterable<TraversalStep>} The steps that were taken while traversing the source code.\n\t */\n\ttraverse() {\n\t\tthrow new Error(\"Not implemented.\");\n\t}\n}\n\nexport { CallMethodStep, ConfigCommentParser, Directive, TextSourceCodeBase, VisitNodeStep };\n"
        }
    ]
}