{
    "sourceFile": "node_modules/@eslint/plugin-kit/dist/cjs/index.d.cts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891759618,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "export type VisitTraversalStep = import(\"@eslint/core\").VisitTraversalStep;\nexport type CallTraversalStep = import(\"@eslint/core\").CallTraversalStep;\nexport type TextSourceCode = import(\"@eslint/core\").TextSourceCode;\nexport type TraversalStep = import(\"@eslint/core\").TraversalStep;\nexport type SourceLocation = import(\"@eslint/core\").SourceLocation;\nexport type SourceLocationWithOffset = import(\"@eslint/core\").SourceLocationWithOffset;\nexport type SourceRange = import(\"@eslint/core\").SourceRange;\nexport type IDirective = import(\"@eslint/core\").Directive;\nexport type DirectiveType = import(\"@eslint/core\").DirectiveType;\nexport type RuleConfig = import(\"@eslint/core\").RuleConfig;\nexport type RulesConfig = import(\"@eslint/core\").RulesConfig;\nexport type StringConfig = import(\"./types.cts\").StringConfig;\nexport type BooleanConfig = import(\"./types.cts\").BooleanConfig;\n/**\n * A class to represent a step in the traversal process where a\n * method is called.\n * @implements {CallTraversalStep}\n */\nexport class CallMethodStep implements CallTraversalStep {\n    /**\n     * Creates a new instance.\n     * @param {Object} options The options for the step.\n     * @param {string} options.target The target of the step.\n     * @param {Array<any>} options.args The arguments of the step.\n     */\n    constructor({ target, args }: {\n        target: string;\n        args: Array<any>;\n    });\n    /**\n     * The type of the step.\n     * @type {\"call\"}\n     * @readonly\n     */\n    readonly type: \"call\";\n    /**\n     * The kind of the step. Represents the same data as the `type` property\n     * but it's a number for performance.\n     * @type {2}\n     * @readonly\n     */\n    readonly kind: 2;\n    /**\n     * The name of the method to call.\n     * @type {string}\n     */\n    target: string;\n    /**\n     * The arguments to pass to the method.\n     * @type {Array<any>}\n     */\n    args: Array<any>;\n}\n/**\n * Object to parse ESLint configuration comments.\n */\nexport class ConfigCommentParser {\n    /**\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\n     * whitespace. Used for \"global\" comments.\n     * @param {string} string The string to parse.\n     * @returns {StringConfig} Result map object of names and string values, or null values if no value was provided.\n     */\n    parseStringConfig(string: string): StringConfig;\n    /**\n     * Parses a JSON-like config.\n     * @param {string} string The string to parse.\n     * @returns {({ok: true, config: RulesConfig}|{ok: false, error: {message: string}})} Result map object\n     */\n    parseJSONLikeConfig(string: string): ({\n        ok: true;\n        config: RulesConfig;\n    } | {\n        ok: false;\n        error: {\n            message: string;\n        };\n    });\n    /**\n     * Parses a config of values separated by comma.\n     * @param {string} string The string to parse.\n     * @returns {BooleanConfig} Result map of values and true values\n     */\n    parseListConfig(string: string): BooleanConfig;\n    /**\n     * Parses a directive comment into directive text and value.\n     * @param {string} string The string with the directive to be parsed.\n     * @returns {DirectiveComment|undefined} The parsed directive or `undefined` if the directive is invalid.\n     */\n    parseDirective(string: string): DirectiveComment | undefined;\n    #private;\n}\n/**\n * A class to represent a directive comment.\n * @implements {IDirective}\n */\nexport class Directive implements IDirective {\n    /**\n     * Creates a new instance.\n     * @param {Object} options The options for the directive.\n     * @param {\"disable\"|\"enable\"|\"disable-next-line\"|\"disable-line\"} options.type The type of directive.\n     * @param {unknown} options.node The node representing the directive.\n     * @param {string} options.value The value of the directive.\n     * @param {string} options.justification The justification for the directive.\n     */\n    constructor({ type, node, value, justification }: {\n        type: \"disable\" | \"enable\" | \"disable-next-line\" | \"disable-line\";\n        node: unknown;\n        value: string;\n        justification: string;\n    });\n    /**\n     * The type of directive.\n     * @type {DirectiveType}\n     * @readonly\n     */\n    readonly type: DirectiveType;\n    /**\n     * The node representing the directive.\n     * @type {unknown}\n     * @readonly\n     */\n    readonly node: unknown;\n    /**\n     * Everything after the \"eslint-disable\" portion of the directive,\n     * but before the \"--\" that indicates the justification.\n     * @type {string}\n     * @readonly\n     */\n    readonly value: string;\n    /**\n     * The justification for the directive.\n     * @type {string}\n     * @readonly\n     */\n    readonly justification: string;\n}\n/**\n * Source Code Base Object\n * @implements {TextSourceCode}\n */\nexport class TextSourceCodeBase implements TextSourceCode {\n    /**\n     * Creates a new instance.\n     * @param {Object} options The options for the instance.\n     * @param {string} options.text The source code text.\n     * @param {object} options.ast The root AST node.\n     * @param {RegExp} [options.lineEndingPattern] The pattern to match lineEndings in the source code.\n     */\n    constructor({ text, ast, lineEndingPattern }: {\n        text: string;\n        ast: object;\n        lineEndingPattern?: RegExp;\n    });\n    /**\n     * The AST of the source code.\n     * @type {object}\n     */\n    ast: object;\n    /**\n     * The text of the source code.\n     * @type {string}\n     */\n    text: string;\n    /**\n     * Returns the loc information for the given node or token.\n     * @param {object} nodeOrToken The node or token to get the loc information for.\n     * @returns {SourceLocation} The loc information for the node or token.\n     */\n    getLoc(nodeOrToken: object): SourceLocation;\n    /**\n     * Returns the range information for the given node or token.\n     * @param {object} nodeOrToken The node or token to get the range information for.\n     * @returns {SourceRange} The range information for the node or token.\n     */\n    getRange(nodeOrToken: object): SourceRange;\n    /**\n     * Returns the parent of the given node.\n     * @param {object} node The node to get the parent of.\n     * @returns {object|undefined} The parent of the node.\n     */\n    getParent(node: object): object | undefined;\n    /**\n     * Gets all the ancestors of a given node\n     * @param {object} node The node\n     * @returns {Array<object>} All the ancestor nodes in the AST, not including the provided node, starting\n     * from the root node at index 0 and going inwards to the parent node.\n     * @throws {TypeError} When `node` is missing.\n     */\n    getAncestors(node: object): Array<object>;\n    /**\n     * Gets the source code for the given node.\n     * @param {object} [node] The AST node to get the text for.\n     * @param {number} [beforeCount] The number of characters before the node to retrieve.\n     * @param {number} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    public getText(node?: object, beforeCount?: number, afterCount?: number): string;\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array<string>} The source text as an array of lines.\n     * @public\n     */\n    public get lines(): Array<string>;\n    /**\n     * Traverse the source code and return the steps that were taken.\n     * @returns {Iterable<TraversalStep>} The steps that were taken while traversing the source code.\n     */\n    traverse(): Iterable<TraversalStep>;\n    #private;\n}\n/**\n * A class to represent a step in the traversal process where a node is visited.\n * @implements {VisitTraversalStep}\n */\nexport class VisitNodeStep implements VisitTraversalStep {\n    /**\n     * Creates a new instance.\n     * @param {Object} options The options for the step.\n     * @param {object} options.target The target of the step.\n     * @param {1|2} options.phase The phase of the step.\n     * @param {Array<any>} options.args The arguments of the step.\n     */\n    constructor({ target, phase, args }: {\n        target: object;\n        phase: 1 | 2;\n        args: Array<any>;\n    });\n    /**\n     * The type of the step.\n     * @type {\"visit\"}\n     * @readonly\n     */\n    readonly type: \"visit\";\n    /**\n     * The kind of the step. Represents the same data as the `type` property\n     * but it's a number for performance.\n     * @type {1}\n     * @readonly\n     */\n    readonly kind: 1;\n    /**\n     * The target of the step.\n     * @type {object}\n     */\n    target: object;\n    /**\n     * The phase of the step.\n     * @type {1|2}\n     */\n    phase: 1 | 2;\n    /**\n     * The arguments of the step.\n     * @type {Array<any>}\n     */\n    args: Array<any>;\n}\n/**\n * Represents a directive comment.\n */\ndeclare class DirectiveComment {\n    /**\n     * Creates a new directive comment.\n     * @param {string} label The label of the directive.\n     * @param {string} value The value of the directive.\n     * @param {string} justification The justification of the directive.\n     */\n    constructor(label: string, value: string, justification: string);\n    /**\n     * The label of the directive, such as \"eslint\", \"eslint-disable\", etc.\n     * @type {string}\n     */\n    label: string;\n    /**\n     * The value of the directive (the string after the label).\n     * @type {string}\n     */\n    value: string;\n    /**\n     * The justification of the directive (the string after the --).\n     * @type {string}\n     */\n    justification: string;\n}\nexport {};\n"
        }
    ]
}