{
    "sourceFile": "node_modules/@eslint/config-array/dist/cjs/index.d.cts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891757629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "export { ObjectSchema } from \"@eslint/object-schema\";\nexport type PropertyDefinition = import(\"@eslint/object-schema\").PropertyDefinition;\nexport type ObjectDefinition = import(\"@eslint/object-schema\").ObjectDefinition;\nexport type ConfigObject = import(\"./types.cts\").ConfigObject;\nexport type IMinimatchStatic = import(\"minimatch\").IMinimatchStatic;\nexport type IMinimatch = import(\"minimatch\").IMinimatch;\nexport type PathImpl = typeof import(\"@jsr/std__path\");\nexport type ObjectSchemaInstance = import(\"@eslint/object-schema\").ObjectSchema;\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nexport class ConfigArray extends Array<any> {\n    [x: symbol]: (config: any) => any;\n    /**\n     * Creates a new instance of ConfigArray.\n     * @param {Iterable|Function|Object} configs An iterable yielding config\n     *      objects, or a config function, or a config object.\n     * @param {Object} options The options for the ConfigArray.\n     * @param {string} [options.basePath=\"/\"] The absolute path of the config file directory.\n     * \t\tDefaults to `\"/\"`.\n     * @param {boolean} [options.normalized=false] Flag indicating if the\n     *      configs have already been normalized.\n     * @param {Object} [options.schema] The additional schema\n     *      definitions to use for the ConfigArray schema.\n     * @param {Array<string>} [options.extraConfigTypes] List of config types supported.\n     */\n    constructor(configs: Iterable<any> | Function | any, { basePath, normalized, schema: customSchema, extraConfigTypes, }?: {\n        basePath?: string;\n        normalized?: boolean;\n        schema?: any;\n        extraConfigTypes?: Array<string>;\n    });\n    /**\n     * The path of the config file that this array was loaded from.\n     * This is used to calculate filename matches.\n     * @property basePath\n     * @type {string}\n     */\n    basePath: string;\n    /**\n     * The supported config types.\n     * @type {Array<string>}\n     */\n    extraConfigTypes: Array<string>;\n    /**\n     * Returns the `files` globs from every config object in the array.\n     * This can be used to determine which files will be matched by a\n     * config array or to use as a glob pattern when no patterns are provided\n     * for a command line interface.\n     * @returns {Array<string|Function>} An array of matchers.\n     */\n    get files(): Array<string | Function>;\n    /**\n     * Returns ignore matchers that should always be ignored regardless of\n     * the matching `files` fields in any configs. This is necessary to mimic\n     * the behavior of things like .gitignore and .eslintignore, allowing a\n     * globbing operation to be faster.\n     * @returns {string[]} An array of string patterns and functions to be ignored.\n     */\n    get ignores(): string[];\n    /**\n     * Indicates if the config array has been normalized.\n     * @returns {boolean} True if the config array is normalized, false if not.\n     */\n    isNormalized(): boolean;\n    /**\n     * Normalizes a config array by flattening embedded arrays and executing\n     * config functions.\n     * @param {Object} [context] The context object for config functions.\n     * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n     */\n    normalize(context?: any): Promise<ConfigArray>;\n    /**\n     * Normalizes a config array by flattening embedded arrays and executing\n     * config functions.\n     * @param {Object} [context] The context object for config functions.\n     * @returns {ConfigArray} The current ConfigArray instance.\n     */\n    normalizeSync(context?: any): ConfigArray;\n    /**\n     * Returns the config object for a given file path and a status that can be used to determine why a file has no config.\n     * @param {string} filePath The path of a file to get a config for.\n     * @returns {{ config?: Object, status: \"ignored\"|\"external\"|\"unconfigured\"|\"matched\" }}\n     * An object with an optional property `config` and property `status`.\n     * `config` is the config object for the specified file as returned by {@linkcode ConfigArray.getConfig},\n     * `status` a is one of the constants returned by {@linkcode ConfigArray.getConfigStatus}.\n     */\n    getConfigWithStatus(filePath: string): {\n        config?: any;\n        status: \"ignored\" | \"external\" | \"unconfigured\" | \"matched\";\n    };\n    /**\n     * Returns the config object for a given file path.\n     * @param {string} filePath The path of a file to get a config for.\n     * @returns {Object|undefined} The config object for this file or `undefined`.\n     */\n    getConfig(filePath: string): any | undefined;\n    /**\n     * Determines whether a file has a config or why it doesn't.\n     * @param {string} filePath The path of the file to check.\n     * @returns {\"ignored\"|\"external\"|\"unconfigured\"|\"matched\"} One of the following values:\n     * * `\"ignored\"`: the file is ignored\n     * * `\"external\"`: the file is outside the base path\n     * * `\"unconfigured\"`: the file is not matched by any config\n     * * `\"matched\"`: the file has a matching config\n     */\n    getConfigStatus(filePath: string): \"ignored\" | \"external\" | \"unconfigured\" | \"matched\";\n    /**\n     * Determines if the given filepath is ignored based on the configs.\n     * @param {string} filePath The path of a file to check.\n     * @returns {boolean} True if the path is ignored, false if not.\n     * @deprecated Use `isFileIgnored` instead.\n     */\n    isIgnored(filePath: string): boolean;\n    /**\n     * Determines if the given filepath is ignored based on the configs.\n     * @param {string} filePath The path of a file to check.\n     * @returns {boolean} True if the path is ignored, false if not.\n     */\n    isFileIgnored(filePath: string): boolean;\n    /**\n     * Determines if the given directory is ignored based on the configs.\n     * This checks only default `ignores` that don't have `files` in the\n     * same config. A pattern such as `/foo` be considered to ignore the directory\n     * while a pattern such as `/foo/**` is not considered to ignore the\n     * directory because it is matching files.\n     * @param {string} directoryPath The path of a directory to check.\n     * @returns {boolean} True if the directory is ignored, false if not. Will\n     * \t\treturn true for any directory that is not inside of `basePath`.\n     * @throws {Error} When the `ConfigArray` is not normalized.\n     */\n    isDirectoryIgnored(directoryPath: string): boolean;\n    #private;\n}\nexport namespace ConfigArraySymbol {\n    let isNormalized: symbol;\n    let configCache: symbol;\n    let schema: symbol;\n    let finalizeConfig: symbol;\n    let preprocessConfig: symbol;\n}\n"
        }
    ]
}