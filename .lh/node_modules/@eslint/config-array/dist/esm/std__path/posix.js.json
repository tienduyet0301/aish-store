{
    "sourceFile": "node_modules/@eslint/config-array/dist/esm/std__path/posix.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891757842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\nfunction assertPath(path) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(`Path must be a string, received \"${JSON.stringify(path)}\"`);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction stripSuffix(name, suffix) {\n  if (suffix.length >= name.length) {\n    return name;\n  }\n  const lenDiff = name.length - suffix.length;\n  for(let i = suffix.length - 1; i >= 0; --i){\n    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\n      return name;\n    }\n  }\n  return name.slice(0, -suffix.length);\n}\nfunction lastPathSegment(path, isSep, start = 0) {\n  let matchedNonSeparator = false;\n  let end = path.length;\n  for(let i = path.length - 1; i >= start; --i){\n    if (isSep(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        start = i + 1;\n        break;\n      }\n    } else if (!matchedNonSeparator) {\n      matchedNonSeparator = true;\n      end = i + 1;\n    }\n  }\n  return path.slice(start, end);\n}\nfunction assertArgs$1(path, suffix) {\n  assertPath(path);\n  if (path.length === 0) return path;\n  if (typeof suffix !== \"string\") {\n    throw new TypeError(`Suffix must be a string, received \"${JSON.stringify(suffix)}\"`);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\nfunction stripTrailingSeparators(segment, isSep) {\n  if (segment.length <= 1) {\n    return segment;\n  }\n  let end = segment.length;\n  for(let i = segment.length - 1; i > 0; i--){\n    if (isSep(segment.charCodeAt(i))) {\n      end = i;\n    } else {\n      break;\n    }\n  }\n  return segment.slice(0, end);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n// Alphabet chars.\n// Non-alphabetic chars.\nconst CHAR_DOT = 46; /* . */ \nconst CHAR_FORWARD_SLASH = 47; /* / */\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/posix/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"/home/user/Documents/\"), \"Documents\");\n * assertEquals(basename(\"/home/user/Documents/image.png\"), \"image.png\");\n * assertEquals(basename(\"/home/user/Documents/image.png\", \".png\"), \"image\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function doesn't automatically strip hash and query parts from\n * URLs. If your URL contains a hash or query, remove them before passing the\n * URL to the function. This can be done by passing the URL to `new URL(url)`,\n * and setting the `hash` and `search` properties to empty strings.\n *\n * ```ts\n * import { basename } from \"@std/path/posix/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts\"), \"mod.ts\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts\", \".ts\"), \"mod\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts?a=b\"), \"mod.ts?a=b\");\n * assertEquals(basename(\"https://deno.land/std/path/mod.ts#header\"), \"mod.ts#header\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/posix/unstable-basename`.\n *\n * @param path The path to extract the name from.\n * @param suffix The suffix to remove from extracted name.\n * @returns The extracted name.\n */ function basename(path, suffix = \"\") {\n  assertArgs$1(path, suffix);\n  const lastSegment = lastPathSegment(path, isPosixPathSeparator);\n  const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * The character used to separate entries in the PATH environment variable.\n */ const DELIMITER = \":\";\n/**\n * The character used to separate components of a file path.\n */ const SEPARATOR = \"/\";\n/**\n * A regular expression that matches one or more path separators.\n */ const SEPARATOR_PATTERN = /\\/+/;\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArg$3(path) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the directory path of a `path`.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/posix/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(dirname(\"/home/user/Documents/\"), \"/home/user\");\n * assertEquals(dirname(\"/home/user/Documents/image.png\"), \"/home/user/Documents\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts\"), \"https://deno.land/std/path\");\n * ```\n *\n * @example Working with URLs\n *\n * ```ts\n * import { dirname } from \"@std/path/posix/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts\"), \"https://deno.land/std/path\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts?a=b\"), \"https://deno.land/std/path\");\n * assertEquals(dirname(\"https://deno.land/std/path/mod.ts#header\"), \"https://deno.land/std/path\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/posix/unstable-dirname`.\n *\n * @param path The path to get the directory from.\n * @returns The directory path.\n */ function dirname(path) {\n  assertArg$3(path);\n  let end = -1;\n  let matchedNonSeparator = false;\n  for(let i = path.length - 1; i >= 1; --i){\n    if (isPosixPathSeparator(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        end = i;\n        break;\n      }\n    } else {\n      matchedNonSeparator = true;\n    }\n  }\n  // No matches. Fallback based on provided path:\n  //\n  // - leading slashes paths\n  //     \"/foo\" => \"/\"\n  //     \"///foo\" => \"/\"\n  // - no slash path\n  //     \"foo\" => \".\"\n  if (end === -1) {\n    return isPosixPathSeparator(path.charCodeAt(0)) ? \"/\" : \".\";\n  }\n  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the extension of the `path` with leading period.\n *\n * @example Usage\n * ```ts\n * import { extname } from \"@std/path/posix/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(extname(\"/home/user/Documents/file.ts\"), \".ts\");\n * assertEquals(extname(\"/home/user/Documents/\"), \"\");\n * assertEquals(extname(\"/home/user/Documents/image.png\"), \".png\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function doesn't automatically strip hash and query parts from\n * URLs. If your URL contains a hash or query, remove them before passing the\n * URL to the function. This can be done by passing the URL to `new URL(url)`,\n * and setting the `hash` and `search` properties to empty strings.\n *\n * ```ts\n * import { extname } from \"@std/path/posix/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(extname(\"https://deno.land/std/path/mod.ts\"), \".ts\");\n * assertEquals(extname(\"https://deno.land/std/path/mod.ts?a=b\"), \".ts?a=b\");\n * assertEquals(extname(\"https://deno.land/std/path/mod.ts#header\"), \".ts#header\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `extname` from `@std/path/posix/unstable-extname`.\n *\n * @param path The path to get the extension from.\n * @returns The extension (ex. for `file.ts` returns `.ts`).\n */ function extname(path) {\n  assertPath(path);\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  for(let i = path.length - 1; i >= 0; --i){\n    const code = path.charCodeAt(i);\n    if (isPosixPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction _format(sep, pathObject) {\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || (pathObject.name ?? \"\") + (pathObject.ext ?? \"\");\n  if (!dir) return base;\n  if (base === sep) return dir;\n  if (dir === pathObject.root) return dir + base;\n  return dir + sep + base;\n}\nfunction assertArg$2(pathObject) {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(`The \"pathObject\" argument must be of type Object, received type \"${typeof pathObject}\"`);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Generate a path from `ParsedPath` object.\n *\n * @example Usage\n * ```ts\n * import { format } from \"@std/path/posix/format\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = format({\n *   root: \"/\",\n *   dir: \"/path/dir\",\n *   base: \"file.txt\",\n *   ext: \".txt\",\n *   name: \"file\"\n * });\n * assertEquals(path, \"/path/dir/file.txt\");\n * ```\n *\n * @param pathObject The path object to format.\n * @returns The formatted path.\n */ function format(pathObject) {\n  assertArg$2(pathObject);\n  return _format(\"/\", pathObject);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArg$1(url) {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol !== \"file:\") {\n    throw new TypeError(`URL must be a file URL: received \"${url.protocol}\"`);\n  }\n  return url;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Converts a file URL to a path string.\n *\n * @example Usage\n * ```ts\n * import { fromFileUrl } from \"@std/path/posix/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(fromFileUrl(new URL(\"file:///home/foo\")), \"/home/foo\");\n * ```\n *\n * @param url The file URL to convert.\n * @returns The path string.\n */ function fromFileUrl(url) {\n  url = assertArg$1(url);\n  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\"));\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Verifies whether provided path is absolute.\n *\n * @example Usage\n * ```ts\n * import { isAbsolute } from \"@std/path/posix/is-absolute\";\n * import { assert, assertFalse } from \"@std/assert\";\n *\n * assert(isAbsolute(\"/home/user/Documents/\"));\n * assertFalse(isAbsolute(\"home/user/Documents/\"));\n * ```\n *\n * @param path The path to verify.\n * @returns Whether the path is absolute.\n */ function isAbsolute(path) {\n  assertPath(path);\n  return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArg(path) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code;\n  for(let i = 0; i <= path.length; ++i){\n    if (i < path.length) code = path.charCodeAt(i);\n    else if (isPathSeparator(code)) break;\n    else code = CHAR_FORWARD_SLASH;\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/posix/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = normalize(\"/foo/bar//baz/asdf/quux/..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @example Working with URLs\n *\n * Note: This function will remove the double slashes from a URL's scheme.\n * Hence, do not pass a full URL to this function. Instead, pass the pathname of\n * the URL.\n *\n * ```ts\n * import { normalize } from \"@std/path/posix/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const url = new URL(\"https://deno.land\");\n * url.pathname = normalize(\"//std//assert//.//mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/assert/mod.ts\");\n *\n * url.pathname = normalize(\"std/assert/../async/retry.ts\");\n * assertEquals(url.href, \"https://deno.land/std/async/retry.ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/posix/unstable-normalize`.\n *\n * @param path The path to normalize.\n * @returns The normalized path.\n */ function normalize(path) {\n  assertArg(path);\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));\n  // Normalize the path\n  path = normalizeString(path, !isAbsolute, \"/\", isPosixPathSeparator);\n  if (path.length === 0 && !isAbsolute) path = \".\";\n  if (path.length > 0 && trailingSeparator) path += \"/\";\n  if (isAbsolute) return `/${path}`;\n  return path;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n *\n * @example Usage\n * ```ts\n * import { join } from \"@std/path/posix/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = join(\"/foo\", \"bar\", \"baz/asdf\", \"quux\", \"..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @example Working with URLs\n * ```ts\n * import { join } from \"@std/path/posix/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const url = new URL(\"https://deno.land\");\n * url.pathname = join(\"std\", \"path\", \"mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/path/mod.ts\");\n *\n * url.pathname = join(\"//std\", \"path/\", \"/mod.ts\");\n * assertEquals(url.href, \"https://deno.land/std/path/mod.ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `join` from `@std/path/posix/unstable-join`.\n *\n * @param paths The paths to join.\n * @returns The joined path.\n */ function join(...paths) {\n  if (paths.length === 0) return \".\";\n  paths.forEach((path)=>assertPath(path));\n  const joined = paths.filter((path)=>path.length > 0).join(\"/\");\n  return joined === \"\" ? \".\" : normalize(joined);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return a `ParsedPath` object of the `path`.\n *\n * @example Usage\n * ```ts\n * import { parse } from \"@std/path/posix/parse\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = parse(\"/home/user/file.txt\");\n * assertEquals(path, {\n *   root: \"/\",\n *   dir: \"/home/user\",\n *   base: \"file.txt\",\n *   ext: \".txt\",\n *   name: \"file\"\n * });\n * ```\n *\n * @param path The path to parse.\n * @returns The parsed path object.\n */ function parse(path) {\n  assertPath(path);\n  const ret = {\n    root: \"\",\n    dir: \"\",\n    base: \"\",\n    ext: \"\",\n    name: \"\"\n  };\n  if (path.length === 0) return ret;\n  const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  let start;\n  if (isAbsolute) {\n    ret.root = \"/\";\n    start = 1;\n  } else {\n    start = 0;\n  }\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  // Get non-dir info\n  for(; i >= start; --i){\n    const code = path.charCodeAt(i);\n    if (isPosixPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    if (end !== -1) {\n      if (startPart === 0 && isAbsolute) {\n        ret.base = ret.name = path.slice(1, end);\n      } else {\n        ret.base = ret.name = path.slice(startPart, end);\n      }\n    }\n    // Fallback to '/' in case there is no basename\n    ret.base = ret.base || \"/\";\n  } else {\n    if (startPart === 0 && isAbsolute) {\n      ret.name = path.slice(1, startDot);\n      ret.base = path.slice(1, end);\n    } else {\n      ret.name = path.slice(startPart, startDot);\n      ret.base = path.slice(startPart, end);\n    }\n    ret.ext = path.slice(startDot, end);\n  }\n  if (startPart > 0) {\n    ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);\n  } else if (isAbsolute) ret.dir = \"/\";\n  return ret;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Resolves path segments into a `path`.\n *\n * @example Usage\n * ```ts\n * import { resolve } from \"@std/path/posix/resolve\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = resolve(\"/foo\", \"bar\", \"baz/asdf\", \"quux\", \"..\");\n * assertEquals(path, \"/foo/bar/baz/asdf\");\n * ```\n *\n * @param pathSegments The path segments to resolve.\n * @returns The resolved path.\n */ function resolve(...pathSegments) {\n  let resolvedPath = \"\";\n  let resolvedAbsolute = false;\n  for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n    let path;\n    if (i >= 0) path = pathSegments[i];\n    else {\n      // deno-lint-ignore no-explicit-any\n      const { Deno } = globalThis;\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a relative path without a current working directory (CWD)\");\n      }\n      path = Deno.cwd();\n    }\n    assertPath(path);\n    // Skip empty entries\n    if (path.length === 0) {\n      continue;\n    }\n    resolvedPath = `${path}/${resolvedPath}`;\n    resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));\n  }\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when Deno.cwd() fails)\n  // Normalize the path\n  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, \"/\", isPosixPathSeparator);\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0) return `/${resolvedPath}`;\n    else return \"/\";\n  } else if (resolvedPath.length > 0) return resolvedPath;\n  else return \".\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArgs(from, to) {\n  assertPath(from);\n  assertPath(to);\n  if (from === to) return \"\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n *\n * If `from` and `to` are the same, return an empty string.\n *\n * @example Usage\n * ```ts\n * import { relative } from \"@std/path/posix/relative\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = relative(\"/data/orandea/test/aaa\", \"/data/orandea/impl/bbb\");\n * assertEquals(path, \"../../impl/bbb\");\n * ```\n *\n * @param from The path to start from.\n * @param to The path to reach.\n * @returns The relative path.\n */ function relative(from, to) {\n  assertArgs(from, to);\n  from = resolve(from);\n  to = resolve(to);\n  if (from === to) return \"\";\n  // Trim any leading backslashes\n  let fromStart = 1;\n  const fromEnd = from.length;\n  for(; fromStart < fromEnd; ++fromStart){\n    if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;\n  }\n  const fromLen = fromEnd - fromStart;\n  // Trim any leading backslashes\n  let toStart = 1;\n  const toEnd = to.length;\n  for(; toStart < toEnd; ++toStart){\n    if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;\n  }\n  const toLen = toEnd - toStart;\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for(; i <= length; ++i){\n    if (i === length) {\n      if (toLen > length) {\n        if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        } else if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;\n  }\n  let out = \"\";\n  // Generate the relative path based on the path difference between `to`\n  // and `from`\n  for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\n    if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {\n      if (out.length === 0) out += \"..\";\n      else out += \"/..\";\n    }\n  }\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) return out + to.slice(toStart + lastCommonSep);\n  else {\n    toStart += lastCommonSep;\n    if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;\n    return to.slice(toStart);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nconst WHITESPACE_ENCODINGS = {\n  \"\\u0009\": \"%09\",\n  \"\\u000A\": \"%0A\",\n  \"\\u000B\": \"%0B\",\n  \"\\u000C\": \"%0C\",\n  \"\\u000D\": \"%0D\",\n  \"\\u0020\": \"%20\"\n};\nfunction encodeWhitespace(string) {\n  return string.replaceAll(/[\\s]/g, (c)=>{\n    return WHITESPACE_ENCODINGS[c] ?? c;\n  });\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Converts a path string to a file URL.\n *\n * @example Usage\n * ```ts\n * import { toFileUrl } from \"@std/path/posix/to-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(toFileUrl(\"/home/foo\"), new URL(\"file:///home/foo\"));\n * assertEquals(toFileUrl(\"/home/foo bar\"), new URL(\"file:///home/foo%20bar\"));\n * ```\n *\n * @param path The path to convert.\n * @returns The file URL.\n */ function toFileUrl(path) {\n  if (!isAbsolute(path)) {\n    throw new TypeError(`Path must be absolute: received \"${path}\"`);\n  }\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(path.replace(/%/g, \"%25\").replace(/\\\\/g, \"%5C\"));\n  return url;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Converts a path to a namespaced path. This function returns the path as is on posix.\n *\n * @example Usage\n * ```ts\n * import { toNamespacedPath } from \"@std/path/posix/to-namespaced-path\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(toNamespacedPath(\"/home/foo\"), \"/home/foo\");\n * ```\n *\n * @param path The path.\n * @returns The namespaced path.\n */ function toNamespacedPath(path) {\n  // Non-op on posix systems\n  return path;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction common$1(paths, sep) {\n  const [first = \"\", ...remaining] = paths;\n  const parts = first.split(sep);\n  let endOfPrefix = parts.length;\n  let append = \"\";\n  for (const path of remaining){\n    const compare = path.split(sep);\n    if (compare.length <= endOfPrefix) {\n      endOfPrefix = compare.length;\n      append = \"\";\n    }\n    for(let i = 0; i < endOfPrefix; i++){\n      if (compare[i] !== parts[i]) {\n        endOfPrefix = i;\n        append = i === 0 ? \"\" : sep;\n        break;\n      }\n    }\n  }\n  return parts.slice(0, endOfPrefix).join(sep) + append;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/** Determines the common path from a set of paths for POSIX systems.\n *\n * @example Usage\n * ```ts\n * import { common } from \"@std/path/posix/common\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = common([\n *   \"./deno/std/path/mod.ts\",\n *   \"./deno/std/fs/mod.ts\",\n * ]);\n * assertEquals(path, \"./deno/std/\");\n * ```\n *\n * @param paths The paths to compare.\n * @returns The common path.\n */ function common(paths) {\n  return common$1(paths, SEPARATOR);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Options for {@linkcode globToRegExp}, {@linkcode joinGlobs},\n * {@linkcode normalizeGlob} and {@linkcode expandGlob}.\n */ const REG_EXP_ESCAPE_CHARS = [\n  \"!\",\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"=\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"^\",\n  \"{\",\n  \"|\"\n];\nconst RANGE_ESCAPE_CHARS = [\n  \"-\",\n  \"\\\\\",\n  \"]\"\n];\nfunction _globToRegExp(c, glob, { extended = true, globstar: globstarOption = true, // os = osType,\ncaseInsensitive = false } = {}) {\n  if (glob === \"\") {\n    return /(?!)/;\n  }\n  // Remove trailing separators.\n  let newLength = glob.length;\n  for(; newLength > 1 && c.seps.includes(glob[newLength - 1]); newLength--);\n  glob = glob.slice(0, newLength);\n  let regExpString = \"\";\n  // Terminates correctly. Trust that `j` is incremented every iteration.\n  for(let j = 0; j < glob.length;){\n    let segment = \"\";\n    const groupStack = [];\n    let inRange = false;\n    let inEscape = false;\n    let endsWithSep = false;\n    let i = j;\n    // Terminates with `i` at the non-inclusive end of the current segment.\n    for(; i < glob.length && !c.seps.includes(glob[i]); i++){\n      if (inEscape) {\n        inEscape = false;\n        const escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;\n        segment += escapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n        continue;\n      }\n      if (glob[i] === c.escapePrefix) {\n        inEscape = true;\n        continue;\n      }\n      if (glob[i] === \"[\") {\n        if (!inRange) {\n          inRange = true;\n          segment += \"[\";\n          if (glob[i + 1] === \"!\") {\n            i++;\n            segment += \"^\";\n          } else if (glob[i + 1] === \"^\") {\n            i++;\n            segment += \"\\\\^\";\n          }\n          continue;\n        } else if (glob[i + 1] === \":\") {\n          let k = i + 1;\n          let value = \"\";\n          while(glob[k + 1] !== undefined && glob[k + 1] !== \":\"){\n            value += glob[k + 1];\n            k++;\n          }\n          if (glob[k + 1] === \":\" && glob[k + 2] === \"]\") {\n            i = k + 2;\n            if (value === \"alnum\") segment += \"\\\\dA-Za-z\";\n            else if (value === \"alpha\") segment += \"A-Za-z\";\n            else if (value === \"ascii\") segment += \"\\x00-\\x7F\";\n            else if (value === \"blank\") segment += \"\\t \";\n            else if (value === \"cntrl\") segment += \"\\x00-\\x1F\\x7F\";\n            else if (value === \"digit\") segment += \"\\\\d\";\n            else if (value === \"graph\") segment += \"\\x21-\\x7E\";\n            else if (value === \"lower\") segment += \"a-z\";\n            else if (value === \"print\") segment += \"\\x20-\\x7E\";\n            else if (value === \"punct\") {\n              segment += \"!\\\"#$%&'()*+,\\\\-./:;<=>?@[\\\\\\\\\\\\]^_‘{|}~\";\n            } else if (value === \"space\") segment += \"\\\\s\\v\";\n            else if (value === \"upper\") segment += \"A-Z\";\n            else if (value === \"word\") segment += \"\\\\w\";\n            else if (value === \"xdigit\") segment += \"\\\\dA-Fa-f\";\n            continue;\n          }\n        }\n      }\n      if (glob[i] === \"]\" && inRange) {\n        inRange = false;\n        segment += \"]\";\n        continue;\n      }\n      if (inRange) {\n        segment += glob[i];\n        continue;\n      }\n      if (glob[i] === \")\" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== \"BRACE\") {\n        segment += \")\";\n        const type = groupStack.pop();\n        if (type === \"!\") {\n          segment += c.wildcard;\n        } else if (type !== \"@\") {\n          segment += type;\n        }\n        continue;\n      }\n      if (glob[i] === \"|\" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n      if (glob[i] === \"+\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"+\");\n        segment += \"(?:\";\n        continue;\n      }\n      if (glob[i] === \"@\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"@\");\n        segment += \"(?:\";\n        continue;\n      }\n      if (glob[i] === \"?\") {\n        if (extended && glob[i + 1] === \"(\") {\n          i++;\n          groupStack.push(\"?\");\n          segment += \"(?:\";\n        } else {\n          segment += \".\";\n        }\n        continue;\n      }\n      if (glob[i] === \"!\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"!\");\n        segment += \"(?!\";\n        continue;\n      }\n      if (glob[i] === \"{\") {\n        groupStack.push(\"BRACE\");\n        segment += \"(?:\";\n        continue;\n      }\n      if (glob[i] === \"}\" && groupStack[groupStack.length - 1] === \"BRACE\") {\n        groupStack.pop();\n        segment += \")\";\n        continue;\n      }\n      if (glob[i] === \",\" && groupStack[groupStack.length - 1] === \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n      if (glob[i] === \"*\") {\n        if (extended && glob[i + 1] === \"(\") {\n          i++;\n          groupStack.push(\"*\");\n          segment += \"(?:\";\n        } else {\n          const prevChar = glob[i - 1];\n          let numStars = 1;\n          while(glob[i + 1] === \"*\"){\n            i++;\n            numStars++;\n          }\n          const nextChar = glob[i + 1];\n          if (globstarOption && numStars === 2 && [\n            ...c.seps,\n            undefined\n          ].includes(prevChar) && [\n            ...c.seps,\n            undefined\n          ].includes(nextChar)) {\n            segment += c.globstar;\n            endsWithSep = true;\n          } else {\n            segment += c.wildcard;\n          }\n        }\n        continue;\n      }\n      segment += REG_EXP_ESCAPE_CHARS.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n    }\n    // Check for unclosed groups or a dangling backslash.\n    if (groupStack.length > 0 || inRange || inEscape) {\n      // Parse failure. Take all characters from this segment literally.\n      segment = \"\";\n      for (const c of glob.slice(j, i)){\n        segment += REG_EXP_ESCAPE_CHARS.includes(c) ? `\\\\${c}` : c;\n        endsWithSep = false;\n      }\n    }\n    regExpString += segment;\n    if (!endsWithSep) {\n      regExpString += i < glob.length ? c.sep : c.sepMaybe;\n      endsWithSep = true;\n    }\n    // Terminates with `i` at the start of the next segment.\n    while(c.seps.includes(glob[i]))i++;\n    j = i;\n  }\n  regExpString = `^${regExpString}$`;\n  return new RegExp(regExpString, caseInsensitive ? \"i\" : \"\");\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nconst constants = {\n  sep: \"/+\",\n  sepMaybe: \"/*\",\n  seps: [\n    \"/\"\n  ],\n  globstar: \"(?:[^/]*(?:/|$)+)*\",\n  wildcard: \"[^/]*\",\n  escapePrefix: \"\\\\\"\n};\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment.\n *\n * @example Usage\n * ```ts\n * import { globToRegExp } from \"@std/path/posix/glob-to-regexp\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(globToRegExp(\"*.js\"), /^[^/]*\\.js\\/*$/);\n * ```\n *\n * @param glob Glob string to convert.\n * @param options Conversion options.\n * @returns The regular expression equivalent to the glob.\n */ function globToRegExp(glob, options = {}) {\n  return _globToRegExp(constants, glob, options);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Test whether the given string is a glob.\n *\n * @example Usage\n * ```ts\n * import { isGlob } from \"@std/path/is-glob\";\n * import { assert } from \"@std/assert\";\n *\n * assert(!isGlob(\"foo/bar/../baz\"));\n * assert(isGlob(\"foo/*ar/../baz\"));\n * ```\n *\n * @param str String to test.\n * @returns `true` if the given string is a glob, otherwise `false`\n */ function isGlob(str) {\n  const chars = {\n    \"{\": \"}\",\n    \"(\": \")\",\n    \"[\": \"]\"\n  };\n  const regex = /\\\\(.)|(^!|\\*|\\?|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n  if (str === \"\") {\n    return false;\n  }\n  let match;\n  while(match = regex.exec(str)){\n    if (match[2]) return true;\n    let idx = match.index + match[0].length;\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    const open = match[1];\n    const close = open ? chars[open] : null;\n    if (open && close) {\n      const n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n    str = str.slice(idx);\n  }\n  return false;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { normalizeGlob } from \"@std/path/posix/normalize-glob\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = normalizeGlob(\"foo/bar/../*\", { globstar: true });\n * assertEquals(path, \"foo/*\");\n * ```\n *\n * @param glob The glob to normalize.\n * @param options The options to use.\n * @returns The normalized path.\n */ function normalizeGlob(glob, options = {}) {\n  const { globstar = false } = options;\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEPARATOR_PATTERN.source;\n  const badParentPattern = new RegExp(`(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`, \"g\");\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { joinGlobs } from \"@std/path/posix/join-globs\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = joinGlobs([\"foo\", \"bar\", \"**\"], { globstar: true });\n * assertEquals(path, \"foo/bar/**\");\n * ```\n *\n * @param globs The globs to join.\n * @param options The options to use.\n * @returns The joined path.\n */ function joinGlobs(globs, options = {}) {\n  const { globstar = false } = options;\n  if (!globstar || globs.length === 0) {\n    return join(...globs);\n  }\n  let joined;\n  for (const glob of globs){\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEPARATOR}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, {\n    globstar\n  });\n}\n\nexport { DELIMITER, SEPARATOR, SEPARATOR_PATTERN, basename, common, dirname, extname, format, fromFileUrl, globToRegExp, isAbsolute, isGlob, join, joinGlobs, normalize, normalizeGlob, parse, relative, resolve, toFileUrl, toNamespacedPath };\n"
        }
    ]
}