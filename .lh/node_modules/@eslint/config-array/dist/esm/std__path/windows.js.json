{
    "sourceFile": "node_modules/@eslint/config-array/dist/esm/std__path/windows.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891757885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\nfunction assertPath(path) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(`Path must be a string, received \"${JSON.stringify(path)}\"`);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction stripSuffix(name, suffix) {\n  if (suffix.length >= name.length) {\n    return name;\n  }\n  const lenDiff = name.length - suffix.length;\n  for(let i = suffix.length - 1; i >= 0; --i){\n    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {\n      return name;\n    }\n  }\n  return name.slice(0, -suffix.length);\n}\nfunction lastPathSegment(path, isSep, start = 0) {\n  let matchedNonSeparator = false;\n  let end = path.length;\n  for(let i = path.length - 1; i >= start; --i){\n    if (isSep(path.charCodeAt(i))) {\n      if (matchedNonSeparator) {\n        start = i + 1;\n        break;\n      }\n    } else if (!matchedNonSeparator) {\n      matchedNonSeparator = true;\n      end = i + 1;\n    }\n  }\n  return path.slice(start, end);\n}\nfunction assertArgs$1(path, suffix) {\n  assertPath(path);\n  if (path.length === 0) return path;\n  if (typeof suffix !== \"string\") {\n    throw new TypeError(`Suffix must be a string, received \"${JSON.stringify(suffix)}\"`);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n// Alphabet chars.\nconst CHAR_UPPERCASE_A = 65; /* A */ \nconst CHAR_LOWERCASE_A = 97; /* a */ \nconst CHAR_UPPERCASE_Z = 90; /* Z */ \nconst CHAR_LOWERCASE_Z = 122; /* z */ \n// Non-alphabetic chars.\nconst CHAR_DOT = 46; /* . */ \nconst CHAR_FORWARD_SLASH = 47; /* / */ \nconst CHAR_BACKWARD_SLASH = 92; /* \\ */ \nconst CHAR_COLON = 58; /* : */ \nconst CHAR_QUESTION_MARK = 63; /* ? */\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\nfunction stripTrailingSeparators(segment, isSep) {\n  if (segment.length <= 1) {\n    return segment;\n  }\n  let end = segment.length;\n  for(let i = segment.length - 1; i > 0; i--){\n    if (isSep(segment.charCodeAt(i))) {\n      end = i;\n    } else {\n      break;\n    }\n  }\n  return segment.slice(0, end);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z || code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the last portion of a `path`.\n * Trailing directory separators are ignored, and optional suffix is removed.\n *\n * @example Usage\n * ```ts\n * import { basename } from \"@std/path/windows/basename\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\\"), \"Documents\");\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\"), \"image.png\");\n * assertEquals(basename(\"C:\\\\user\\\\Documents\\\\image.png\", \".png\"), \"image\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `basename` from `@std/path/windows/unstable-basename`.\n *\n * @param path The path to extract the name from.\n * @param suffix The suffix to remove from extracted name.\n * @returns The extracted name.\n */ function basename(path, suffix = \"\") {\n  assertArgs$1(path, suffix);\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n  let start = 0;\n  if (path.length >= 2) {\n    const drive = path.charCodeAt(0);\n    if (isWindowsDeviceRoot(drive)) {\n      if (path.charCodeAt(1) === CHAR_COLON) start = 2;\n    }\n  }\n  const lastSegment = lastPathSegment(path, isPathSeparator, start);\n  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);\n  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * The character used to separate entries in the PATH environment variable.\n */ const DELIMITER = \";\";\n/**\n * The character used to separate components of a file path.\n */ const SEPARATOR = \"\\\\\";\n/**\n * A regular expression that matches one or more path separators.\n */ const SEPARATOR_PATTERN = /[\\\\/]+/;\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArg$3(path) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the directory path of a `path`.\n *\n * @example Usage\n * ```ts\n * import { dirname } from \"@std/path/windows/dirname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const dir = dirname(\"C:\\\\foo\\\\bar\\\\baz.ext\");\n * assertEquals(dir, \"C:\\\\foo\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `dirname` from `@std/path/windows/unstable-dirname`.\n *\n * @param path The path to get the directory from.\n * @returns The directory path.\n */ function dirname(path) {\n  assertArg$3(path);\n  const len = path.length;\n  let rootEnd = -1;\n  let end = -1;\n  let matchedSlash = true;\n  let offset = 0;\n  const code = path.charCodeAt(0);\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      rootEnd = offset = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for(; j < len; ++j){\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for(; j < len; ++j){\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for(; j < len; ++j){\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    return path;\n  }\n  for(let i = len - 1; i >= offset; --i){\n    if (isPathSeparator(path.charCodeAt(i))) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n  if (end === -1) {\n    if (rootEnd === -1) return \".\";\n    else end = rootEnd;\n  }\n  return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the extension of the `path` with leading period.\n *\n * @example Usage\n * ```ts\n * import { extname } from \"@std/path/windows/extname\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const ext = extname(\"file.ts\");\n * assertEquals(ext, \".ts\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `extname` from `@std/path/windows/unstable-extname`.\n *\n * @param path The path to get the extension from.\n * @returns The extension of the `path`.\n */ function extname(path) {\n  assertPath(path);\n  let start = 0;\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  // Check for a drive letter prefix so as not to mistake the following\n  // path separator as an extra separator at the end of the path that can be\n  // disregarded\n  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n    start = startPart = 2;\n  }\n  for(let i = path.length - 1; i >= start; --i){\n    const code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return \"\";\n  }\n  return path.slice(startDot, end);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction _format(sep, pathObject) {\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || (pathObject.name ?? \"\") + (pathObject.ext ?? \"\");\n  if (!dir) return base;\n  if (base === sep) return dir;\n  if (dir === pathObject.root) return dir + base;\n  return dir + sep + base;\n}\nfunction assertArg$2(pathObject) {\n  if (pathObject === null || typeof pathObject !== \"object\") {\n    throw new TypeError(`The \"pathObject\" argument must be of type Object, received type \"${typeof pathObject}\"`);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Generate a path from `ParsedPath` object.\n *\n * @example Usage\n * ```ts\n * import { format } from \"@std/path/windows/format\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = format({\n *   root: \"C:\\\\\",\n *   dir: \"C:\\\\path\\\\dir\",\n *   base: \"file.txt\",\n *   ext: \".txt\",\n *   name: \"file\"\n * });\n * assertEquals(path, \"C:\\\\path\\\\dir\\\\file.txt\");\n * ```\n *\n * @param pathObject The path object to format.\n * @returns The formatted path.\n */ function format(pathObject) {\n  assertArg$2(pathObject);\n  return _format(\"\\\\\", pathObject);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArg$1(url) {\n  url = url instanceof URL ? url : new URL(url);\n  if (url.protocol !== \"file:\") {\n    throw new TypeError(`URL must be a file URL: received \"${url.protocol}\"`);\n  }\n  return url;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Converts a file URL to a path string.\n *\n * @example Usage\n * ```ts\n * import { fromFileUrl } from \"@std/path/windows/from-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(fromFileUrl(\"file:///home/foo\"), \"\\\\home\\\\foo\");\n * assertEquals(fromFileUrl(\"file:///C:/Users/foo\"), \"C:\\\\Users\\\\foo\");\n * assertEquals(fromFileUrl(\"file://localhost/home/foo\"), \"\\\\home\\\\foo\");\n * ```\n *\n * @param url The file URL to convert.\n * @returns The path string.\n */ function fromFileUrl(url) {\n  url = assertArg$1(url);\n  let path = decodeURIComponent(url.pathname.replace(/\\//g, \"\\\\\").replace(/%(?![0-9A-Fa-f]{2})/g, \"%25\")).replace(/^\\\\*([A-Za-z]:)(\\\\|$)/, \"$1\\\\\");\n  if (url.hostname !== \"\") {\n    // Note: The `URL` implementation guarantees that the drive letter and\n    // hostname are mutually exclusive. Otherwise it would not have been valid\n    // to append the hostname and path like this.\n    path = `\\\\\\\\${url.hostname}${path}`;\n  }\n  return path;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Verifies whether provided path is absolute.\n *\n * @example Usage\n * ```ts\n * import { isAbsolute } from \"@std/path/windows/is-absolute\";\n * import { assert, assertFalse } from \"@std/assert\";\n *\n * assert(isAbsolute(\"C:\\\\foo\\\\bar\"));\n * assertFalse(isAbsolute(\"..\\\\baz\"));\n * ```\n *\n * @param path The path to verify.\n * @returns `true` if the path is absolute, `false` otherwise.\n */ function isAbsolute(path) {\n  assertPath(path);\n  const len = path.length;\n  if (len === 0) return false;\n  const code = path.charCodeAt(0);\n  if (isPathSeparator(code)) {\n    return true;\n  } else if (isWindowsDeviceRoot(code)) {\n    // Possible device root\n    if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {\n      if (isPathSeparator(path.charCodeAt(2))) return true;\n    }\n  }\n  return false;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArg(path) {\n  assertPath(path);\n  if (path.length === 0) return \".\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// Copyright the Browserify authors. MIT License.\n// Ported from https://github.com/browserify/path-browserify/\n// This module is browser compatible.\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code;\n  for(let i = 0; i <= path.length; ++i){\n    if (i < path.length) code = path.charCodeAt(i);\n    else if (isPathSeparator(code)) break;\n    else code = CHAR_FORWARD_SLASH;\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = \"\";\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) res += `${separator}..`;\n          else res = \"..\";\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);\n        else res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Normalize the `path`, resolving `'..'` and `'.'` segments.\n * Note that resolving these segments does not necessarily mean that all will be eliminated.\n * A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.\n *\n * @example Usage\n * ```ts\n * import { normalize } from \"@std/path/windows/normalize\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const normalized = normalize(\"C:\\\\foo\\\\..\\\\bar\");\n * assertEquals(normalized, \"C:\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `normalize` from `@std/path/windows/unstable-normalize`.\n *\n * @param path The path to normalize\n * @returns The normalized path\n */ function normalize(path) {\n  assertArg(path);\n  const len = path.length;\n  let rootEnd = 0;\n  let device;\n  let isAbsolute = false;\n  const code = path.charCodeAt(0);\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for(; j < len; ++j){\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for(; j < len; ++j){\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for(; j < len; ++j){\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            // Treat separator following drive name as an absolute path\n            // indicator\n            isAbsolute = true;\n            rootEnd = 3;\n          }\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid unnecessary\n    // work\n    return \"\\\\\";\n  }\n  let tail;\n  if (rootEnd < len) {\n    tail = normalizeString(path.slice(rootEnd), !isAbsolute, \"\\\\\", isPathSeparator);\n  } else {\n    tail = \"\";\n  }\n  if (tail.length === 0 && !isAbsolute) tail = \".\";\n  if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n    tail += \"\\\\\";\n  }\n  if (device === undefined) {\n    if (isAbsolute) {\n      if (tail.length > 0) return `\\\\${tail}`;\n      else return \"\\\\\";\n    }\n    return tail;\n  } else if (isAbsolute) {\n    if (tail.length > 0) return `${device}\\\\${tail}`;\n    else return `${device}\\\\`;\n  }\n  return device + tail;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Join all given a sequence of `paths`,then normalizes the resulting path.\n *\n * @example Usage\n * ```ts\n * import { join } from \"@std/path/windows/join\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const joined = join(\"C:\\\\foo\", \"bar\", \"baz\\\\..\");\n * assertEquals(joined, \"C:\\\\foo\\\\bar\");\n * ```\n *\n * Note: If you are working with file URLs,\n * use the new version of `join` from `@std/path/windows/unstable-join`.\n *\n * @param paths The paths to join.\n * @returns The joined path.\n */ function join(...paths) {\n  paths.forEach((path)=>assertPath(path));\n  paths = paths.filter((path)=>path.length > 0);\n  if (paths.length === 0) return \".\";\n  // Make sure that the joined path doesn't start with two slashes, because\n  // normalize() will mistake it for an UNC path then.\n  //\n  // This step is skipped when it is very clear that the user actually\n  // intended to point at an UNC path. This is assumed when the first\n  // non-empty string arguments starts with exactly two slashes followed by\n  // at least one more non-slash character.\n  //\n  // Note that for normalize() to treat a path as an UNC path it needs to\n  // have at least 2 components, so we don't filter for that here.\n  // This means that the user can use join to construct UNC paths from\n  // a server name and a share name; for example:\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\'\n  let needsReplace = true;\n  let slashCount = 0;\n  const firstPart = paths[0];\n  if (isPathSeparator(firstPart.charCodeAt(0))) {\n    ++slashCount;\n    const firstLen = firstPart.length;\n    if (firstLen > 1) {\n      if (isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n  }\n  let joined = paths.join(\"\\\\\");\n  if (needsReplace) {\n    // Find any more consecutive slashes we need to replace\n    for(; slashCount < joined.length; ++slashCount){\n      if (!isPathSeparator(joined.charCodeAt(slashCount))) break;\n    }\n    // Replace the slashes if needed\n    if (slashCount >= 2) joined = `\\\\${joined.slice(slashCount)}`;\n  }\n  return normalize(joined);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return a `ParsedPath` object of the `path`.\n *\n * @example Usage\n * ```ts\n * import { parse } from \"@std/path/windows/parse\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const parsed = parse(\"C:\\\\foo\\\\bar\\\\baz.ext\");\n * assertEquals(parsed, {\n *   root: \"C:\\\\\",\n *   dir: \"C:\\\\foo\\\\bar\",\n *   base: \"baz.ext\",\n *   ext: \".ext\",\n *   name: \"baz\",\n * });\n * ```\n *\n * @param path The path to parse.\n * @returns The `ParsedPath` object.\n */ function parse(path) {\n  assertPath(path);\n  const ret = {\n    root: \"\",\n    dir: \"\",\n    base: \"\",\n    ext: \"\",\n    name: \"\"\n  };\n  const len = path.length;\n  if (len === 0) return ret;\n  let rootEnd = 0;\n  let code = path.charCodeAt(0);\n  // Try to match a root\n  if (len > 1) {\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        for(; j < len; ++j){\n          if (isPathSeparator(path.charCodeAt(j))) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for(; j < len; ++j){\n            if (!isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for(; j < len; ++j){\n              if (isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code)) {\n      // Possible device root\n      if (path.charCodeAt(1) === CHAR_COLON) {\n        rootEnd = 2;\n        if (len > 2) {\n          if (isPathSeparator(path.charCodeAt(2))) {\n            if (len === 3) {\n              // `path` contains just a drive root, exit early to avoid\n              // unnecessary work\n              ret.root = ret.dir = path;\n              ret.base = \"\\\\\";\n              return ret;\n            }\n            rootEnd = 3;\n          }\n        } else {\n          // `path` contains just a relative drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n      }\n    }\n  } else if (isPathSeparator(code)) {\n    // `path` contains just a path separator, exit early to avoid\n    // unnecessary work\n    ret.root = ret.dir = path;\n    ret.base = \"\\\\\";\n    return ret;\n  }\n  if (rootEnd > 0) ret.root = path.slice(0, rootEnd);\n  let startDot = -1;\n  let startPart = rootEnd;\n  let end = -1;\n  let matchedSlash = true;\n  let i = path.length - 1;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  let preDotState = 0;\n  // Get non-dir info\n  for(; i >= rootEnd; --i){\n    code = path.charCodeAt(i);\n    if (isPathSeparator(code)) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === CHAR_DOT) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;\n      else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    if (end !== -1) {\n      ret.base = ret.name = path.slice(startPart, end);\n    }\n  } else {\n    ret.name = path.slice(startPart, startDot);\n    ret.base = path.slice(startPart, end);\n    ret.ext = path.slice(startDot, end);\n  }\n  // Fallback to '\\' in case there is no basename\n  ret.base = ret.base || \"\\\\\";\n  // If the directory is the root, use the entire root as the `dir` including\n  // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n  // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n  if (startPart > 0 && startPart !== rootEnd) {\n    ret.dir = path.slice(0, startPart - 1);\n  } else ret.dir = ret.root;\n  return ret;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Resolves path segments into a `path`.\n *\n * @example Usage\n * ```ts\n * import { resolve } from \"@std/path/windows/resolve\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const resolved = resolve(\"C:\\\\foo\\\\bar\", \"..\\\\baz\");\n * assertEquals(resolved, \"C:\\\\foo\\\\baz\");\n * ```\n *\n * @param pathSegments The path segments to process to path\n * @returns The resolved path\n */ function resolve(...pathSegments) {\n  let resolvedDevice = \"\";\n  let resolvedTail = \"\";\n  let resolvedAbsolute = false;\n  for(let i = pathSegments.length - 1; i >= -1; i--){\n    let path;\n    // deno-lint-ignore no-explicit-any\n    const { Deno } = globalThis;\n    if (i >= 0) {\n      path = pathSegments[i];\n    } else if (!resolvedDevice) {\n      if (typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a drive-letter-less path without a current working directory (CWD)\");\n      }\n      path = Deno.cwd();\n    } else {\n      if (typeof Deno?.env?.get !== \"function\" || typeof Deno?.cwd !== \"function\") {\n        throw new TypeError(\"Resolved a relative path without a current working directory (CWD)\");\n      }\n      path = Deno.cwd();\n      // Verify that a cwd was found and that it actually points\n      // to our drive. If not, default to the drive's root.\n      if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\\\`) {\n        path = `${resolvedDevice}\\\\`;\n      }\n    }\n    assertPath(path);\n    const len = path.length;\n    // Skip empty entries\n    if (len === 0) continue;\n    let rootEnd = 0;\n    let device = \"\";\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n    // Try to match a root\n    if (len > 1) {\n      if (isPathSeparator(code)) {\n        // Possible UNC root\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          for(; j < len; ++j){\n            if (isPathSeparator(path.charCodeAt(j))) break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for(; j < len; ++j){\n              if (!isPathSeparator(path.charCodeAt(j))) break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for(; j < len; ++j){\n                if (isPathSeparator(path.charCodeAt(j))) break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last)}`;\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code)) {\n        // Possible device root\n        if (path.charCodeAt(1) === CHAR_COLON) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (isPathSeparator(code)) {\n      // `path` contains just a path separator\n      rootEnd = 1;\n      isAbsolute = true;\n    }\n    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n      continue;\n    }\n    if (resolvedDevice.length === 0 && device.length > 0) {\n      resolvedDevice = device;\n    }\n    if (!resolvedAbsolute) {\n      resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n      resolvedAbsolute = isAbsolute;\n    }\n    if (resolvedAbsolute && resolvedDevice.length > 0) break;\n  }\n  // At this point the path should be resolved to a full absolute path,\n  // but handle relative paths to be safe (might happen when Deno.cwd()\n  // fails)\n  // Normalize the tail path\n  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, \"\\\\\", isPathSeparator);\n  return resolvedDevice + (resolvedAbsolute ? \"\\\\\" : \"\") + resolvedTail || \".\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction assertArgs(from, to) {\n  assertPath(from);\n  assertPath(to);\n  if (from === to) return \"\";\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Return the relative path from `from` to `to` based on current working directory.\n *\n * An example in windws, for instance:\n *  from = 'C:\\\\orandea\\\\test\\\\aaa'\n *  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n *\n * @example Usage\n * ```ts\n * import { relative } from \"@std/path/windows/relative\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const relativePath = relative(\"C:\\\\foobar\\\\test\\\\aaa\", \"C:\\\\foobar\\\\impl\\\\bbb\");\n * assertEquals(relativePath, \"..\\\\..\\\\impl\\\\bbb\");\n * ```\n *\n * @param from The path from which to calculate the relative path\n * @param to The path to which to calculate the relative path\n * @returns The relative path from `from` to `to`\n */ function relative(from, to) {\n  assertArgs(from, to);\n  const fromOrig = resolve(from);\n  const toOrig = resolve(to);\n  if (fromOrig === toOrig) return \"\";\n  from = fromOrig.toLowerCase();\n  to = toOrig.toLowerCase();\n  if (from === to) return \"\";\n  // Trim any leading backslashes\n  let fromStart = 0;\n  let fromEnd = from.length;\n  for(; fromStart < fromEnd; ++fromStart){\n    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for(; fromEnd - 1 > fromStart; --fromEnd){\n    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const fromLen = fromEnd - fromStart;\n  // Trim any leading backslashes\n  let toStart = 0;\n  let toEnd = to.length;\n  for(; toStart < toEnd; ++toStart){\n    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;\n  }\n  // Trim trailing backslashes (applicable to UNC paths only)\n  for(; toEnd - 1 > toStart; --toEnd){\n    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;\n  }\n  const toLen = toEnd - toStart;\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for(; i <= length; ++i){\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        } else if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      break;\n    }\n    const fromCode = from.charCodeAt(fromStart + i);\n    const toCode = to.charCodeAt(toStart + i);\n    if (fromCode !== toCode) break;\n    else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i;\n  }\n  // We found a mismatch before the first common path separator was seen, so\n  // return the original `to`.\n  if (i !== length && lastCommonSep === -1) {\n    return toOrig;\n  }\n  let out = \"\";\n  if (lastCommonSep === -1) lastCommonSep = 0;\n  // Generate the relative path based on the path difference between `to` and\n  // `from`\n  for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){\n    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      if (out.length === 0) out += \"..\";\n      else out += \"\\\\..\";\n    }\n  }\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) {\n    return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n  } else {\n    toStart += lastCommonSep;\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;\n    return toOrig.slice(toStart, toEnd);\n  }\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nconst WHITESPACE_ENCODINGS = {\n  \"\\u0009\": \"%09\",\n  \"\\u000A\": \"%0A\",\n  \"\\u000B\": \"%0B\",\n  \"\\u000C\": \"%0C\",\n  \"\\u000D\": \"%0D\",\n  \"\\u0020\": \"%20\"\n};\nfunction encodeWhitespace(string) {\n  return string.replaceAll(/[\\s]/g, (c)=>{\n    return WHITESPACE_ENCODINGS[c] ?? c;\n  });\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Converts a path string to a file URL.\n *\n * @example Usage\n * ```ts\n * import { toFileUrl } from \"@std/path/windows/to-file-url\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(toFileUrl(\"\\\\home\\\\foo\"), new URL(\"file:///home/foo\"));\n * assertEquals(toFileUrl(\"C:\\\\Users\\\\foo\"), new URL(\"file:///C:/Users/foo\"));\n * assertEquals(toFileUrl(\"\\\\\\\\127.0.0.1\\\\home\\\\foo\"), new URL(\"file://127.0.0.1/home/foo\"));\n * ```\n * @param path The path to convert.\n * @returns The file URL.\n */ function toFileUrl(path) {\n  if (!isAbsolute(path)) {\n    throw new TypeError(`Path must be absolute: received \"${path}\"`);\n  }\n  const [, hostname, pathname] = path.match(/^(?:[/\\\\]{2}([^/\\\\]+)(?=[/\\\\](?:[^/\\\\]|$)))?(.*)/);\n  const url = new URL(\"file:///\");\n  url.pathname = encodeWhitespace(pathname.replace(/%/g, \"%25\"));\n  if (hostname !== undefined && hostname !== \"localhost\") {\n    url.hostname = hostname;\n    if (!url.hostname) {\n      throw new TypeError(`Invalid hostname: \"${url.hostname}\"`);\n    }\n  }\n  return url;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Resolves path to a namespace path\n *\n * @example Usage\n * ```ts\n * import { toNamespacedPath } from \"@std/path/windows/to-namespaced-path\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const namespaced = toNamespacedPath(\"C:\\\\foo\\\\bar\");\n * assertEquals(namespaced, \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\");\n * ```\n *\n * @param path The path to resolve to namespaced path\n * @returns The resolved namespaced path\n */ function toNamespacedPath(path) {\n  // Note: this will *probably* throw somewhere.\n  if (typeof path !== \"string\") return path;\n  if (path.length === 0) return \"\";\n  const resolvedPath = resolve(path);\n  if (resolvedPath.length >= 3) {\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {\n      // Possible device root\n      if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n        // Matched device root, convert the path to a long UNC path\n        return `\\\\\\\\?\\\\${resolvedPath}`;\n      }\n    }\n  }\n  return path;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nfunction common$1(paths, sep) {\n  const [first = \"\", ...remaining] = paths;\n  const parts = first.split(sep);\n  let endOfPrefix = parts.length;\n  let append = \"\";\n  for (const path of remaining){\n    const compare = path.split(sep);\n    if (compare.length <= endOfPrefix) {\n      endOfPrefix = compare.length;\n      append = \"\";\n    }\n    for(let i = 0; i < endOfPrefix; i++){\n      if (compare[i] !== parts[i]) {\n        endOfPrefix = i;\n        append = i === 0 ? \"\" : sep;\n        break;\n      }\n    }\n  }\n  return parts.slice(0, endOfPrefix).join(sep) + append;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Determines the common path from a set of paths for Windows systems.\n *\n * @example Usage\n * ```ts\n * import { common } from \"@std/path/windows/common\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const path = common([\n *   \"C:\\\\foo\\\\bar\",\n *   \"C:\\\\foo\\\\baz\",\n * ]);\n * assertEquals(path, \"C:\\\\foo\\\\\");\n * ```\n *\n * @param paths The paths to compare.\n * @returns The common path.\n */ function common(paths) {\n  return common$1(paths, SEPARATOR);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Options for {@linkcode globToRegExp}, {@linkcode joinGlobs},\n * {@linkcode normalizeGlob} and {@linkcode expandGlob}.\n */ const REG_EXP_ESCAPE_CHARS = [\n  \"!\",\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"=\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"^\",\n  \"{\",\n  \"|\"\n];\nconst RANGE_ESCAPE_CHARS = [\n  \"-\",\n  \"\\\\\",\n  \"]\"\n];\nfunction _globToRegExp(c, glob, { extended = true, globstar: globstarOption = true, // os = osType,\ncaseInsensitive = false } = {}) {\n  if (glob === \"\") {\n    return /(?!)/;\n  }\n  // Remove trailing separators.\n  let newLength = glob.length;\n  for(; newLength > 1 && c.seps.includes(glob[newLength - 1]); newLength--);\n  glob = glob.slice(0, newLength);\n  let regExpString = \"\";\n  // Terminates correctly. Trust that `j` is incremented every iteration.\n  for(let j = 0; j < glob.length;){\n    let segment = \"\";\n    const groupStack = [];\n    let inRange = false;\n    let inEscape = false;\n    let endsWithSep = false;\n    let i = j;\n    // Terminates with `i` at the non-inclusive end of the current segment.\n    for(; i < glob.length && !c.seps.includes(glob[i]); i++){\n      if (inEscape) {\n        inEscape = false;\n        const escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;\n        segment += escapeChars.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n        continue;\n      }\n      if (glob[i] === c.escapePrefix) {\n        inEscape = true;\n        continue;\n      }\n      if (glob[i] === \"[\") {\n        if (!inRange) {\n          inRange = true;\n          segment += \"[\";\n          if (glob[i + 1] === \"!\") {\n            i++;\n            segment += \"^\";\n          } else if (glob[i + 1] === \"^\") {\n            i++;\n            segment += \"\\\\^\";\n          }\n          continue;\n        } else if (glob[i + 1] === \":\") {\n          let k = i + 1;\n          let value = \"\";\n          while(glob[k + 1] !== undefined && glob[k + 1] !== \":\"){\n            value += glob[k + 1];\n            k++;\n          }\n          if (glob[k + 1] === \":\" && glob[k + 2] === \"]\") {\n            i = k + 2;\n            if (value === \"alnum\") segment += \"\\\\dA-Za-z\";\n            else if (value === \"alpha\") segment += \"A-Za-z\";\n            else if (value === \"ascii\") segment += \"\\x00-\\x7F\";\n            else if (value === \"blank\") segment += \"\\t \";\n            else if (value === \"cntrl\") segment += \"\\x00-\\x1F\\x7F\";\n            else if (value === \"digit\") segment += \"\\\\d\";\n            else if (value === \"graph\") segment += \"\\x21-\\x7E\";\n            else if (value === \"lower\") segment += \"a-z\";\n            else if (value === \"print\") segment += \"\\x20-\\x7E\";\n            else if (value === \"punct\") {\n              segment += \"!\\\"#$%&'()*+,\\\\-./:;<=>?@[\\\\\\\\\\\\]^_â€˜{|}~\";\n            } else if (value === \"space\") segment += \"\\\\s\\v\";\n            else if (value === \"upper\") segment += \"A-Z\";\n            else if (value === \"word\") segment += \"\\\\w\";\n            else if (value === \"xdigit\") segment += \"\\\\dA-Fa-f\";\n            continue;\n          }\n        }\n      }\n      if (glob[i] === \"]\" && inRange) {\n        inRange = false;\n        segment += \"]\";\n        continue;\n      }\n      if (inRange) {\n        segment += glob[i];\n        continue;\n      }\n      if (glob[i] === \")\" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== \"BRACE\") {\n        segment += \")\";\n        const type = groupStack.pop();\n        if (type === \"!\") {\n          segment += c.wildcard;\n        } else if (type !== \"@\") {\n          segment += type;\n        }\n        continue;\n      }\n      if (glob[i] === \"|\" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n      if (glob[i] === \"+\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"+\");\n        segment += \"(?:\";\n        continue;\n      }\n      if (glob[i] === \"@\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"@\");\n        segment += \"(?:\";\n        continue;\n      }\n      if (glob[i] === \"?\") {\n        if (extended && glob[i + 1] === \"(\") {\n          i++;\n          groupStack.push(\"?\");\n          segment += \"(?:\";\n        } else {\n          segment += \".\";\n        }\n        continue;\n      }\n      if (glob[i] === \"!\" && extended && glob[i + 1] === \"(\") {\n        i++;\n        groupStack.push(\"!\");\n        segment += \"(?!\";\n        continue;\n      }\n      if (glob[i] === \"{\") {\n        groupStack.push(\"BRACE\");\n        segment += \"(?:\";\n        continue;\n      }\n      if (glob[i] === \"}\" && groupStack[groupStack.length - 1] === \"BRACE\") {\n        groupStack.pop();\n        segment += \")\";\n        continue;\n      }\n      if (glob[i] === \",\" && groupStack[groupStack.length - 1] === \"BRACE\") {\n        segment += \"|\";\n        continue;\n      }\n      if (glob[i] === \"*\") {\n        if (extended && glob[i + 1] === \"(\") {\n          i++;\n          groupStack.push(\"*\");\n          segment += \"(?:\";\n        } else {\n          const prevChar = glob[i - 1];\n          let numStars = 1;\n          while(glob[i + 1] === \"*\"){\n            i++;\n            numStars++;\n          }\n          const nextChar = glob[i + 1];\n          if (globstarOption && numStars === 2 && [\n            ...c.seps,\n            undefined\n          ].includes(prevChar) && [\n            ...c.seps,\n            undefined\n          ].includes(nextChar)) {\n            segment += c.globstar;\n            endsWithSep = true;\n          } else {\n            segment += c.wildcard;\n          }\n        }\n        continue;\n      }\n      segment += REG_EXP_ESCAPE_CHARS.includes(glob[i]) ? `\\\\${glob[i]}` : glob[i];\n    }\n    // Check for unclosed groups or a dangling backslash.\n    if (groupStack.length > 0 || inRange || inEscape) {\n      // Parse failure. Take all characters from this segment literally.\n      segment = \"\";\n      for (const c of glob.slice(j, i)){\n        segment += REG_EXP_ESCAPE_CHARS.includes(c) ? `\\\\${c}` : c;\n        endsWithSep = false;\n      }\n    }\n    regExpString += segment;\n    if (!endsWithSep) {\n      regExpString += i < glob.length ? c.sep : c.sepMaybe;\n      endsWithSep = true;\n    }\n    // Terminates with `i` at the start of the next segment.\n    while(c.seps.includes(glob[i]))i++;\n    j = i;\n  }\n  regExpString = `^${regExpString}$`;\n  return new RegExp(regExpString, caseInsensitive ? \"i\" : \"\");\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\nconst constants = {\n  sep: \"(?:\\\\\\\\|/)+\",\n  sepMaybe: \"(?:\\\\\\\\|/)*\",\n  seps: [\n    \"\\\\\",\n    \"/\"\n  ],\n  globstar: \"(?:[^\\\\\\\\/]*(?:\\\\\\\\|/|$)+)*\",\n  wildcard: \"[^\\\\\\\\/]*\",\n  escapePrefix: \"`\"\n};\n/** Convert a glob string to a regular expression.\n *\n * Tries to match bash glob expansion as closely as possible.\n *\n * Basic glob syntax:\n * - `*` - Matches everything without leaving the path segment.\n * - `?` - Matches any single character.\n * - `{foo,bar}` - Matches `foo` or `bar`.\n * - `[abcd]` - Matches `a`, `b`, `c` or `d`.\n * - `[a-d]` - Matches `a`, `b`, `c` or `d`.\n * - `[!abcd]` - Matches any single character besides `a`, `b`, `c` or `d`.\n * - `[[:<class>:]]` - Matches any character belonging to `<class>`.\n *     - `[[:alnum:]]` - Matches any digit or letter.\n *     - `[[:digit:]abc]` - Matches any digit, `a`, `b` or `c`.\n *     - See https://facelessuser.github.io/wcmatch/glob/#posix-character-classes\n *       for a complete list of supported character classes.\n * - `\\` - Escapes the next character for an `os` other than `\"windows\"`.\n * - \\` - Escapes the next character for `os` set to `\"windows\"`.\n * - `/` - Path separator.\n * - `\\` - Additional path separator only for `os` set to `\"windows\"`.\n *\n * Extended syntax:\n * - Requires `{ extended: true }`.\n * - `?(foo|bar)` - Matches 0 or 1 instance of `{foo,bar}`.\n * - `@(foo|bar)` - Matches 1 instance of `{foo,bar}`. They behave the same.\n * - `*(foo|bar)` - Matches _n_ instances of `{foo,bar}`.\n * - `+(foo|bar)` - Matches _n > 0_ instances of `{foo,bar}`.\n * - `!(foo|bar)` - Matches anything other than `{foo,bar}`.\n * - See https://www.linuxjournal.com/content/bash-extended-globbing.\n *\n * Globstar syntax:\n * - Requires `{ globstar: true }`.\n * - `**` - Matches any number of any path segments.\n *     - Must comprise its entire path segment in the provided glob.\n * - See https://www.linuxjournal.com/content/globstar-new-bash-globbing-option.\n *\n * Note the following properties:\n * - The generated `RegExp` is anchored at both start and end.\n * - Repeating and trailing separators are tolerated. Trailing separators in the\n *   provided glob have no meaning and are discarded.\n * - Absolute globs will only match absolute paths, etc.\n * - Empty globs will match nothing.\n * - Any special glob syntax must be contained to one path segment. For example,\n *   `?(foo|bar/baz)` is invalid. The separator will take precedence and the\n *   first segment ends with an unclosed group.\n * - If a path segment ends with unclosed groups or a dangling escape prefix, a\n *   parse error has occurred. Every character for that segment is taken\n *   literally in this event.\n *\n * Limitations:\n * - A negative group like `!(foo|bar)` will wrongly be converted to a negative\n *   look-ahead followed by a wildcard. This means that `!(foo).js` will wrongly\n *   fail to match `foobar.js`, even though `foobar` is not `foo`. Effectively,\n *   `!(foo|bar)` is treated like `!(@(foo|bar)*)`. This will work correctly if\n *   the group occurs not nested at the end of the segment.\n *\n * @example Usage\n * ```ts\n * import { globToRegExp } from \"@std/path/windows/glob-to-regexp\";\n * import { assertEquals } from \"@std/assert\";\n *\n * assertEquals(globToRegExp(\"*.js\"), /^[^\\\\/]*\\.js(?:\\\\|\\/)*$/);\n * ```\n *\n * @param glob Glob string to convert.\n * @param options Conversion options.\n * @returns The regular expression equivalent to the glob.\n */ function globToRegExp(glob, options = {}) {\n  return _globToRegExp(constants, glob, options);\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Test whether the given string is a glob.\n *\n * @example Usage\n * ```ts\n * import { isGlob } from \"@std/path/is-glob\";\n * import { assert } from \"@std/assert\";\n *\n * assert(!isGlob(\"foo/bar/../baz\"));\n * assert(isGlob(\"foo/*ar/../baz\"));\n * ```\n *\n * @param str String to test.\n * @returns `true` if the given string is a glob, otherwise `false`\n */ function isGlob(str) {\n  const chars = {\n    \"{\": \"}\",\n    \"(\": \")\",\n    \"[\": \"]\"\n  };\n  const regex = /\\\\(.)|(^!|\\*|\\?|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n  if (str === \"\") {\n    return false;\n  }\n  let match;\n  while(match = regex.exec(str)){\n    if (match[2]) return true;\n    let idx = match.index + match[0].length;\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    const open = match[1];\n    const close = open ? chars[open] : null;\n    if (open && close) {\n      const n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n    str = str.slice(idx);\n  }\n  return false;\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Like normalize(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n * ```ts\n * import { normalizeGlob } from \"@std/path/windows/normalize-glob\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const normalized = normalizeGlob(\"**\\\\foo\\\\..\\\\bar\", { globstar: true });\n * assertEquals(normalized, \"**\\\\bar\");\n * ```\n *\n * @param glob The glob pattern to normalize.\n * @param options The options for glob pattern.\n * @returns The normalized glob pattern.\n */ function normalizeGlob(glob, options = {}) {\n  const { globstar = false } = options;\n  if (glob.match(/\\0/g)) {\n    throw new Error(`Glob contains invalid characters: \"${glob}\"`);\n  }\n  if (!globstar) {\n    return normalize(glob);\n  }\n  const s = SEPARATOR_PATTERN.source;\n  const badParentPattern = new RegExp(`(?<=(${s}|^)\\\\*\\\\*${s})\\\\.\\\\.(?=${s}|$)`, \"g\");\n  return normalize(glob.replace(badParentPattern, \"\\0\")).replace(/\\0/g, \"..\");\n}\n\n// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n// This module is browser compatible.\n/**\n * Like join(), but doesn't collapse \"**\\/..\" when `globstar` is true.\n *\n * @example Usage\n *\n * ```ts\n * import { joinGlobs } from \"@std/path/windows/join-globs\";\n * import { assertEquals } from \"@std/assert\";\n *\n * const joined = joinGlobs([\"foo\", \"**\", \"bar\"], { globstar: true });\n * assertEquals(joined, \"foo\\\\**\\\\bar\");\n * ```\n *\n * @param globs The globs to join.\n * @param options The options for glob pattern.\n * @returns The joined glob pattern.\n */ function joinGlobs(globs, options = {}) {\n  const { globstar = false } = options;\n  if (!globstar || globs.length === 0) {\n    return join(...globs);\n  }\n  let joined;\n  for (const glob of globs){\n    const path = glob;\n    if (path.length > 0) {\n      if (!joined) joined = path;\n      else joined += `${SEPARATOR}${path}`;\n    }\n  }\n  if (!joined) return \".\";\n  return normalizeGlob(joined, {\n    globstar\n  });\n}\n\nexport { DELIMITER, SEPARATOR, SEPARATOR_PATTERN, basename, common, dirname, extname, format, fromFileUrl, globToRegExp, isAbsolute, isGlob, join, joinGlobs, normalize, normalizeGlob, parse, relative, resolve, toFileUrl, toNamespacedPath };\n"
        }
    ]
}