{
    "sourceFile": "node_modules/@eslint/config-array/dist/esm/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891757803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// @ts-self-types=\"./index.d.ts\"\nimport * as posixPath from './std__path/posix.js';\nimport * as windowsPath from './std__path/windows.js';\nimport minimatch from 'minimatch';\nimport createDebug from 'debug';\nimport { ObjectSchema } from '@eslint/object-schema';\nexport { ObjectSchema } from '@eslint/object-schema';\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"@eslint/object-schema\").PropertyDefinition} PropertyDefinition */\n/** @typedef {import(\"@eslint/object-schema\").ObjectDefinition} ObjectDefinition */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * A strategy that does nothing.\n * @type {PropertyDefinition}\n */\nconst NOOP_STRATEGY = {\n\trequired: false,\n\tmerge() {\n\t\treturn undefined;\n\t},\n\tvalidate() {},\n};\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type {ObjectDefinition}\n */\nconst baseSchema = Object.freeze({\n\tname: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\tthrow new TypeError(\"Property must be a string.\");\n\t\t\t}\n\t\t},\n\t},\n\tfiles: NOOP_STRATEGY,\n\tignores: NOOP_STRATEGY,\n});\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Asserts that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array.\n */\nfunction assertIsArray(value) {\n\tif (!Array.isArray(value)) {\n\t\tthrow new TypeError(\"Expected value to be an array.\");\n\t}\n}\n\n/**\n * Asserts that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value) {\n\tassertIsArray(value);\n\n\tif (\n\t\tvalue.some(\n\t\t\titem => typeof item !== \"string\" && typeof item !== \"function\",\n\t\t)\n\t) {\n\t\tthrow new TypeError(\n\t\t\t\"Expected array to only contain strings and functions.\",\n\t\t);\n\t}\n}\n\n/**\n * Asserts that a given value is a non-empty array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array or an empty array.\n */\nfunction assertIsNonEmptyArray(value) {\n\tif (!Array.isArray(value) || value.length === 0) {\n\t\tthrow new TypeError(\"Expected value to be a non-empty array.\");\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The schema for `files` and `ignores` that every ConfigArray uses.\n * @type {ObjectDefinition}\n */\nconst filesAndIgnoresSchema = Object.freeze({\n\tfiles: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\t\t\t// first check if it's an array\n\t\t\tassertIsNonEmptyArray(value);\n\n\t\t\t// then check each member\n\t\t\tvalue.forEach(item => {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\tassertIsArrayOfStringsAndFunctions(item);\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof item !== \"string\" &&\n\t\t\t\t\ttypeof item !== \"function\"\n\t\t\t\t) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\"Items must be a string, a function, or an array of strings and functions.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t},\n\tignores: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate: assertIsArrayOfStringsAndFunctions,\n\t},\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n\n//------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"./types.ts\").ConfigObject} ConfigObject */\n/** @typedef {import(\"minimatch\").IMinimatchStatic} IMinimatchStatic */\n/** @typedef {import(\"minimatch\").IMinimatch} IMinimatch */\n/** @typedef {import(\"@jsr/std__path\")} PathImpl */\n\n/*\n * This is a bit of a hack to make TypeScript happy with the Rollup-created\n * CommonJS file. Rollup doesn't do object destructuring for imported files\n * and instead imports the default via `require()`. This messes up type checking\n * for `ObjectSchema`. To work around that, we just import the type manually\n * and give it a different name to use in the JSDoc comments.\n */\n/** @typedef {import(\"@eslint/object-schema\").ObjectSchema} ObjectSchemaInstance */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst debug = createDebug(\"@eslint/config-array\");\n\n/**\n * A cache for minimatch instances.\n * @type {Map<string, IMinimatch>}\n */\nconst minimatchCache = new Map();\n\n/**\n * A cache for negated minimatch instances.\n * @type {Map<string, IMinimatch>}\n */\nconst negatedMinimatchCache = new Map();\n\n/**\n * Options to use with minimatch.\n * @type {Object}\n */\nconst MINIMATCH_OPTIONS = {\n\t// matchBase: true,\n\tdot: true,\n\tallowWindowsEscape: true,\n};\n\n/**\n * The types of config objects that are supported.\n * @type {Set<string>}\n */\nconst CONFIG_TYPES = new Set([\"array\", \"function\"]);\n\n/**\n * Fields that are considered metadata and not part of the config object.\n * @type {Set<string>}\n */\nconst META_FIELDS = new Set([\"name\"]);\n\n/**\n * A schema containing just files and ignores for early validation.\n * @type {ObjectSchemaInstance}\n */\nconst FILES_AND_IGNORES_SCHEMA = new ObjectSchema(filesAndIgnoresSchema);\n\n// Precomputed constant objects returned by `ConfigArray.getConfigWithStatus`.\n\nconst CONFIG_WITH_STATUS_EXTERNAL = Object.freeze({ status: \"external\" });\nconst CONFIG_WITH_STATUS_IGNORED = Object.freeze({ status: \"ignored\" });\nconst CONFIG_WITH_STATUS_UNCONFIGURED = Object.freeze({\n\tstatus: \"unconfigured\",\n});\n\n// Match two leading dots followed by a slash or the end of input.\nconst EXTERNAL_PATH_REGEX = /^\\.\\.(?:\\/|$)/u;\n\n/**\n * Wrapper error for config validation errors that adds a name to the front of the\n * error message.\n */\nclass ConfigError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} name The config object name causing the error.\n\t * @param {number} index The index of the config object in the array.\n\t * @param {Object} options The options for the error.\n\t * @param {Error} [options.cause] The error that caused this error.\n\t * @param {string} [options.message] The message to use for the error.\n\t */\n\tconstructor(name, index, { cause, message }) {\n\t\tconst finalMessage = message || cause.message;\n\n\t\tsuper(`Config ${name}: ${finalMessage}`, { cause });\n\n\t\t// copy over custom properties that aren't represented\n\t\tif (cause) {\n\t\t\tfor (const key of Object.keys(cause)) {\n\t\t\t\tif (!(key in this)) {\n\t\t\t\t\tthis[key] = cause[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * The name of the error.\n\t\t * @type {string}\n\t\t * @readonly\n\t\t */\n\t\tthis.name = \"ConfigError\";\n\n\t\t/**\n\t\t * The index of the config object in the array.\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tthis.index = index;\n\t}\n}\n\n/**\n * Gets the name of a config object.\n * @param {ConfigObject} config The config object to get the name of.\n * @returns {string} The name of the config object.\n */\nfunction getConfigName(config) {\n\tif (config && typeof config.name === \"string\" && config.name) {\n\t\treturn `\"${config.name}\"`;\n\t}\n\n\treturn \"(unnamed)\";\n}\n\n/**\n * Rethrows a config error with additional information about the config object.\n * @param {object} config The config object to get the name of.\n * @param {number} index The index of the config object in the array.\n * @param {Error} error The error to rethrow.\n * @throws {ConfigError} When the error is rethrown for a config.\n */\nfunction rethrowConfigError(config, index, error) {\n\tconst configName = getConfigName(config);\n\tthrow new ConfigError(configName, index, { cause: error });\n}\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not.\n */\nfunction isString(value) {\n\treturn typeof value === \"string\";\n}\n\n/**\n * Creates a function that asserts that the config is valid\n * during normalization. This checks that the config is not nullish\n * and that files and ignores keys  of a config object are valid as per base schema.\n * @param {Object} config The config object to check.\n * @param {number} index The index of the config object in the array.\n * @returns {void}\n * @throws {ConfigError} If the files and ignores keys of a config object are not valid.\n */\nfunction assertValidBaseConfig(config, index) {\n\tif (config === null) {\n\t\tthrow new ConfigError(getConfigName(config), index, {\n\t\t\tmessage: \"Unexpected null config.\",\n\t\t});\n\t}\n\n\tif (config === undefined) {\n\t\tthrow new ConfigError(getConfigName(config), index, {\n\t\t\tmessage: \"Unexpected undefined config.\",\n\t\t});\n\t}\n\n\tif (typeof config !== \"object\") {\n\t\tthrow new ConfigError(getConfigName(config), index, {\n\t\t\tmessage: \"Unexpected non-object config.\",\n\t\t});\n\t}\n\n\tconst validateConfig = {};\n\n\tif (\"files\" in config) {\n\t\tvalidateConfig.files = config.files;\n\t}\n\n\tif (\"ignores\" in config) {\n\t\tvalidateConfig.ignores = config.ignores;\n\t}\n\n\ttry {\n\t\tFILES_AND_IGNORES_SCHEMA.validate(validateConfig);\n\t} catch (validationError) {\n\t\trethrowConfigError(config, index, validationError);\n\t}\n}\n\n/**\n * Wrapper around minimatch that caches minimatch patterns for\n * faster matching speed over multiple file path evaluations.\n * @param {string} filepath The file path to match.\n * @param {string} pattern The glob pattern to match against.\n * @param {object} options The minimatch options to use.\n * @returns\n */\nfunction doMatch(filepath, pattern, options = {}) {\n\tlet cache = minimatchCache;\n\n\tif (options.flipNegate) {\n\t\tcache = negatedMinimatchCache;\n\t}\n\n\tlet matcher = cache.get(pattern);\n\n\tif (!matcher) {\n\t\tmatcher = new Minimatch(\n\t\t\tpattern,\n\t\t\tObject.assign({}, MINIMATCH_OPTIONS, options),\n\t\t);\n\t\tcache.set(pattern, matcher);\n\t}\n\n\treturn matcher.match(filepath);\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n\tconst allowFunctions = extraConfigTypes.includes(\"function\");\n\tconst allowArrays = extraConfigTypes.includes(\"array\");\n\n\tasync function* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === \"function\") {\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError(\"Unexpected function.\");\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\titem = await item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError(\"Unexpected array.\");\n\t\t\t\t}\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\"A config function can only return an object or array.\",\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Async iterables cannot be used with the spread operator, so we need to manually\n\t * create the array to return.\n\t */\n\tconst asyncIterable = await flatTraverse(items);\n\tconst configs = [];\n\n\tfor await (const config of asyncIterable) {\n\t\tconfigs.push(config);\n\t}\n\n\treturn configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n\tconst allowFunctions = extraConfigTypes.includes(\"function\");\n\tconst allowArrays = extraConfigTypes.includes(\"array\");\n\n\tfunction* flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === \"function\") {\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError(\"Unexpected function.\");\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\"Async config functions are not supported.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError(\"Unexpected array.\");\n\t\t\t\t}\n\n\t\t\t\tyield* flatTraverse(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\"A config function can only return an object or array.\",\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|((string) => boolean)>} ignores The ignore patterns to check.\n * @param {string} filePath The unprocessed file path to check.\n * @param {string} relativeFilePath The path of the file to check relative to the base path,\n * \t\tusing forward slash (`\"/\"`) as a separator.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnorePath(ignores, filePath, relativeFilePath) {\n\treturn ignores.reduce((ignored, matcher) => {\n\t\tif (!ignored) {\n\t\t\tif (typeof matcher === \"function\") {\n\t\t\t\treturn matcher(filePath);\n\t\t\t}\n\n\t\t\t// don't check negated patterns because we're not ignored yet\n\t\t\tif (!matcher.startsWith(\"!\")) {\n\t\t\t\treturn doMatch(relativeFilePath, matcher);\n\t\t\t}\n\n\t\t\t// otherwise we're still not ignored\n\t\t\treturn false;\n\t\t}\n\n\t\t// only need to check negated patterns because we're ignored\n\t\tif (typeof matcher === \"string\" && matcher.startsWith(\"!\")) {\n\t\t\treturn !doMatch(relativeFilePath, matcher, {\n\t\t\t\tflipNegate: true,\n\t\t\t});\n\t\t}\n\n\t\treturn ignored;\n\t}, false);\n}\n\n/**\n * Determines if a given file path is matched by a config based on\n * `ignores` only.\n * @param {string} filePath The unprocessed file path to check.\n * @param {string} relativeFilePath The path of the file to check relative to the base path,\n * \t\tusing forward slash (`\"/\"`) as a separator.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatchesIgnores(filePath, relativeFilePath, config) {\n\treturn (\n\t\tObject.keys(config).filter(key => !META_FIELDS.has(key)).length > 1 &&\n\t\t!shouldIgnorePath(config.ignores, filePath, relativeFilePath)\n\t);\n}\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The unprocessed file path to check.\n * @param {string} relativeFilePath The path of the file to check relative to the base path,\n * \t\tusing forward slash (`\"/\"`) as a separator.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, relativeFilePath, config) {\n\t// match both strings and functions\n\tfunction match(pattern) {\n\t\tif (isString(pattern)) {\n\t\t\treturn doMatch(relativeFilePath, pattern);\n\t\t}\n\n\t\tif (typeof pattern === \"function\") {\n\t\t\treturn pattern(filePath);\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected matcher type ${pattern}.`);\n\t}\n\n\t// check for all matches to config.files\n\tlet filePathMatchesPattern = config.files.some(pattern => {\n\t\tif (Array.isArray(pattern)) {\n\t\t\treturn pattern.every(match);\n\t\t}\n\n\t\treturn match(pattern);\n\t});\n\n\t/*\n\t * If the file path matches the config.files patterns, then check to see\n\t * if there are any files to ignore.\n\t */\n\tif (filePathMatchesPattern && config.ignores) {\n\t\tfilePathMatchesPattern = !shouldIgnorePath(\n\t\t\tconfig.ignores,\n\t\t\tfilePath,\n\t\t\trelativeFilePath,\n\t\t);\n\t}\n\n\treturn filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check.\n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n\t// TODO: Throw more verbose error\n\tif (!configArray.isNormalized()) {\n\t\tthrow new Error(\n\t\t\t\"ConfigArray must be normalized to perform this operation.\",\n\t\t);\n\t}\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n\tif (extraConfigTypes.length > 2) {\n\t\tthrow new TypeError(\n\t\t\t\"configTypes must be an array with at most two items.\",\n\t\t);\n\t}\n\n\tfor (const configType of extraConfigTypes) {\n\t\tif (!CONFIG_TYPES.has(configType)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`,\n\t\t\t);\n\t\t}\n\t}\n}\n\n/**\n * Returns path-handling implementations for Unix or Windows, depending on a given absolute path.\n * @param {string} fileOrDirPath The absolute path to check.\n * @returns {PathImpl} Path-handling implementations for the specified path.\n * @throws An error is thrown if the specified argument is not an absolute path.\n */\nfunction getPathImpl(fileOrDirPath) {\n\t// Posix absolute paths always start with a slash.\n\tif (fileOrDirPath.startsWith(\"/\")) {\n\t\treturn posixPath;\n\t}\n\n\t// Windows absolute paths start with a letter followed by a colon and at least one backslash,\n\t// or with two backslashes in the case of UNC paths.\n\t// Forward slashed are automatically normalized to backslashes.\n\tif (/^(?:[A-Za-z]:[/\\\\]|[/\\\\]{2})/u.test(fileOrDirPath)) {\n\t\treturn windowsPath;\n\t}\n\n\tthrow new Error(\n\t\t`Expected an absolute path but received \"${fileOrDirPath}\"`,\n\t);\n}\n\n/**\n * Converts a given path to a relative path with all separator characters replaced by forward slashes (`\"/\"`).\n * @param {string} fileOrDirPath The unprocessed path to convert.\n * @param {string} namespacedBasePath The namespaced base path of the directory to which the calculated path shall be relative.\n * @param {PathImpl} path Path-handling implementations.\n * @returns {string} A relative path with all separator characters replaced by forward slashes.\n */\nfunction toRelativePath(fileOrDirPath, namespacedBasePath, path) {\n\tconst fullPath = path.resolve(namespacedBasePath, fileOrDirPath);\n\tconst namespacedFullPath = path.toNamespacedPath(fullPath);\n\tconst relativePath = path.relative(namespacedBasePath, namespacedFullPath);\n\treturn relativePath.replaceAll(path.SEPARATOR, \"/\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n\tisNormalized: Symbol(\"isNormalized\"),\n\tconfigCache: Symbol(\"configCache\"),\n\tschema: Symbol(\"schema\"),\n\tfinalizeConfig: Symbol(\"finalizeConfig\"),\n\tpreprocessConfig: Symbol(\"preprocessConfig\"),\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n\t/**\n\t * The namespaced path of the config file directory.\n\t * @type {string}\n\t */\n\t#namespacedBasePath;\n\n\t/**\n\t * Path-handling implementations.\n\t * @type {PathImpl}\n\t */\n\t#path;\n\n\t/**\n\t * Creates a new instance of ConfigArray.\n\t * @param {Iterable|Function|Object} configs An iterable yielding config\n\t *      objects, or a config function, or a config object.\n\t * @param {Object} options The options for the ConfigArray.\n\t * @param {string} [options.basePath=\"/\"] The absolute path of the config file directory.\n\t * \t\tDefaults to `\"/\"`.\n\t * @param {boolean} [options.normalized=false] Flag indicating if the\n\t *      configs have already been normalized.\n\t * @param {Object} [options.schema] The additional schema\n\t *      definitions to use for the ConfigArray schema.\n\t * @param {Array<string>} [options.extraConfigTypes] List of config types supported.\n\t */\n\tconstructor(\n\t\tconfigs,\n\t\t{\n\t\t\tbasePath = \"/\",\n\t\t\tnormalized = false,\n\t\t\tschema: customSchema,\n\t\t\textraConfigTypes = [],\n\t\t} = {},\n\t) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Tracks if the array has been normalized.\n\t\t * @property isNormalized\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.isNormalized] = normalized;\n\n\t\t/**\n\t\t * The schema used for validating and merging configs.\n\t\t * @property schema\n\t\t * @type {ObjectSchemaInstance}\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.schema] = new ObjectSchema(\n\t\t\tObject.assign({}, customSchema, baseSchema),\n\t\t);\n\n\t\tif (!isString(basePath) || !basePath) {\n\t\t\tthrow new TypeError(\"basePath must be a non-empty string\");\n\t\t}\n\n\t\t/**\n\t\t * The path of the config file that this array was loaded from.\n\t\t * This is used to calculate filename matches.\n\t\t * @property basePath\n\t\t * @type {string}\n\t\t */\n\t\tthis.basePath = basePath;\n\n\t\tassertExtraConfigTypes(extraConfigTypes);\n\n\t\t/**\n\t\t * The supported config types.\n\t\t * @type {Array<string>}\n\t\t */\n\t\tthis.extraConfigTypes = [...extraConfigTypes];\n\t\tObject.freeze(this.extraConfigTypes);\n\n\t\t/**\n\t\t * A cache to store calculated configs for faster repeat lookup.\n\t\t * @property configCache\n\t\t * @type {Map<string, Object>}\n\t\t * @private\n\t\t */\n\t\tthis[ConfigArraySymbol.configCache] = new Map();\n\n\t\t// init cache\n\t\tdataCache.set(this, {\n\t\t\texplicitMatches: new Map(),\n\t\t\tdirectoryMatches: new Map(),\n\t\t\tfiles: undefined,\n\t\t\tignores: undefined,\n\t\t});\n\n\t\t// load the configs into this array\n\t\tif (Array.isArray(configs)) {\n\t\t\tthis.push(...configs);\n\t\t} else {\n\t\t\tthis.push(configs);\n\t\t}\n\n\t\t// select path-handling implementations depending on the base path\n\t\tthis.#path = getPathImpl(basePath);\n\n\t\t// On Windows, `path.relative()` returns an absolute path when given two paths on different drives.\n\t\t// The namespaced base path is useful to make sure that calculated relative paths are always relative.\n\t\t// On Unix, it is identical to the base path.\n\t\tthis.#namespacedBasePath = this.#path.toNamespacedPath(basePath);\n\t}\n\n\t/**\n\t * Prevent normal array methods from creating a new `ConfigArray` instance.\n\t * This is to ensure that methods such as `slice()` won't try to create a\n\t * new instance of `ConfigArray` behind the scenes as doing so may throw\n\t * an error due to the different constructor signature.\n\t * @type {ArrayConstructor} The `Array` constructor.\n\t */\n\tstatic get [Symbol.species]() {\n\t\treturn Array;\n\t}\n\n\t/**\n\t * Returns the `files` globs from every config object in the array.\n\t * This can be used to determine which files will be matched by a\n\t * config array or to use as a glob pattern when no patterns are provided\n\t * for a command line interface.\n\t * @returns {Array<string|Function>} An array of matchers.\n\t */\n\tget files() {\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.files) {\n\t\t\treturn cache.files;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\t\t\tif (config.files) {\n\t\t\t\tconfig.files.forEach(filePattern => {\n\t\t\t\t\tresult.push(filePattern);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.files = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns ignore matchers that should always be ignored regardless of\n\t * the matching `files` fields in any configs. This is necessary to mimic\n\t * the behavior of things like .gitignore and .eslintignore, allowing a\n\t * globbing operation to be faster.\n\t * @returns {string[]} An array of string patterns and functions to be ignored.\n\t */\n\tget ignores() {\n\t\tassertNormalized(this);\n\n\t\t// if this data has been cached, retrieve it\n\t\tconst cache = dataCache.get(this);\n\n\t\tif (cache.ignores) {\n\t\t\treturn cache.ignores;\n\t\t}\n\n\t\t// otherwise calculate it\n\n\t\tconst result = [];\n\n\t\tfor (const config of this) {\n\t\t\t/*\n\t\t\t * We only count ignores if there are no other keys in the object.\n\t\t\t * In this case, it acts list a globally ignored pattern. If there\n\t\t\t * are additional keys, then ignores act like exclusions.\n\t\t\t */\n\t\t\tif (\n\t\t\t\tconfig.ignores &&\n\t\t\t\tObject.keys(config).filter(key => !META_FIELDS.has(key))\n\t\t\t\t\t.length === 1\n\t\t\t) {\n\t\t\t\tresult.push(...config.ignores);\n\t\t\t}\n\t\t}\n\n\t\t// store result\n\t\tcache.ignores = result;\n\t\tdataCache.set(this, cache);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Indicates if the config array has been normalized.\n\t * @returns {boolean} True if the config array is normalized, false if not.\n\t */\n\tisNormalized() {\n\t\treturn this[ConfigArraySymbol.isNormalized];\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {Object} [context] The context object for config functions.\n\t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n\t */\n\tasync normalize(context = {}) {\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = await normalize(\n\t\t\t\tthis,\n\t\t\t\tcontext,\n\t\t\t\tthis.extraConfigTypes,\n\t\t\t);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(\n\t\t\t\t...normalizedConfigs.map(\n\t\t\t\t\tthis[ConfigArraySymbol.preprocessConfig].bind(this),\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis.forEach(assertValidBaseConfig);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {Object} [context] The context object for config functions.\n\t * @returns {ConfigArray} The current ConfigArray instance.\n\t */\n\tnormalizeSync(context = {}) {\n\t\tif (!this.isNormalized()) {\n\t\t\tconst normalizedConfigs = normalizeSync(\n\t\t\t\tthis,\n\t\t\t\tcontext,\n\t\t\t\tthis.extraConfigTypes,\n\t\t\t);\n\t\t\tthis.length = 0;\n\t\t\tthis.push(\n\t\t\t\t...normalizedConfigs.map(\n\t\t\t\t\tthis[ConfigArraySymbol.preprocessConfig].bind(this),\n\t\t\t\t),\n\t\t\t);\n\t\t\tthis.forEach(assertValidBaseConfig);\n\t\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t\t// prevent further changes\n\t\t\tObject.freeze(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/* eslint-disable class-methods-use-this -- Desired as instance methods */\n\n\t/**\n\t * Finalizes the state of a config before being cached and returned by\n\t * `getConfig()`. Does nothing by default but is provided to be\n\t * overridden by subclasses as necessary.\n\t * @param {Object} config The config to finalize.\n\t * @returns {Object} The finalized config.\n\t */\n\t[ConfigArraySymbol.finalizeConfig](config) {\n\t\treturn config;\n\t}\n\n\t/**\n\t * Preprocesses a config during the normalization process. This is the\n\t * method to override if you want to convert an array item before it is\n\t * validated for the first time. For example, if you want to replace a\n\t * string with an object, this is the method to override.\n\t * @param {Object} config The config to preprocess.\n\t * @returns {Object} The config to use in place of the argument.\n\t */\n\t[ConfigArraySymbol.preprocessConfig](config) {\n\t\treturn config;\n\t}\n\n\t/* eslint-enable class-methods-use-this -- Desired as instance methods */\n\n\t/**\n\t * Returns the config object for a given file path and a status that can be used to determine why a file has no config.\n\t * @param {string} filePath The path of a file to get a config for.\n\t * @returns {{ config?: Object, status: \"ignored\"|\"external\"|\"unconfigured\"|\"matched\" }}\n\t * An object with an optional property `config` and property `status`.\n\t * `config` is the config object for the specified file as returned by {@linkcode ConfigArray.getConfig},\n\t * `status` a is one of the constants returned by {@linkcode ConfigArray.getConfigStatus}.\n\t */\n\tgetConfigWithStatus(filePath) {\n\t\tassertNormalized(this);\n\n\t\tconst cache = this[ConfigArraySymbol.configCache];\n\n\t\t// first check the cache for a filename match to avoid duplicate work\n\t\tif (cache.has(filePath)) {\n\t\t\treturn cache.get(filePath);\n\t\t}\n\n\t\t// check to see if the file is outside the base path\n\n\t\tconst relativeFilePath = toRelativePath(\n\t\t\tfilePath,\n\t\t\tthis.#namespacedBasePath,\n\t\t\tthis.#path,\n\t\t);\n\n\t\tif (EXTERNAL_PATH_REGEX.test(relativeFilePath)) {\n\t\t\tdebug(`No config for file ${filePath} outside of base path`);\n\n\t\t\t// cache and return result\n\t\t\tcache.set(filePath, CONFIG_WITH_STATUS_EXTERNAL);\n\t\t\treturn CONFIG_WITH_STATUS_EXTERNAL;\n\t\t}\n\n\t\t// next check to see if the file should be ignored\n\n\t\t// check if this should be ignored due to its directory\n\t\tif (this.isDirectoryIgnored(this.#path.dirname(filePath))) {\n\t\t\tdebug(`Ignoring ${filePath} based on directory pattern`);\n\n\t\t\t// cache and return result\n\t\t\tcache.set(filePath, CONFIG_WITH_STATUS_IGNORED);\n\t\t\treturn CONFIG_WITH_STATUS_IGNORED;\n\t\t}\n\n\t\tif (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {\n\t\t\tdebug(`Ignoring ${filePath} based on file pattern`);\n\n\t\t\t// cache and return result\n\t\t\tcache.set(filePath, CONFIG_WITH_STATUS_IGNORED);\n\t\t\treturn CONFIG_WITH_STATUS_IGNORED;\n\t\t}\n\n\t\t// filePath isn't automatically ignored, so try to construct config\n\n\t\tconst matchingConfigIndices = [];\n\t\tlet matchFound = false;\n\t\tconst universalPattern = /^\\*$|\\/\\*{1,2}$/u;\n\n\t\tthis.forEach((config, index) => {\n\t\t\tif (!config.files) {\n\t\t\t\tif (!config.ignores) {\n\t\t\t\t\tdebug(`Universal config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (pathMatchesIgnores(filePath, relativeFilePath, config)) {\n\t\t\t\t\tdebug(\n\t\t\t\t\t\t`Matching config found for ${filePath} (based on ignores: ${config.ignores})`,\n\t\t\t\t\t);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdebug(\n\t\t\t\t\t`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`,\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a config has a files pattern * or patterns ending in /** or /*,\n\t\t\t * and the filePath only matches those patterns, then the config is only\n\t\t\t * applied if there is another config where the filePath matches\n\t\t\t * a file with a specific extensions such as *.js.\n\t\t\t */\n\n\t\t\tconst universalFiles = config.files.filter(pattern =>\n\t\t\t\tuniversalPattern.test(pattern),\n\t\t\t);\n\n\t\t\t// universal patterns were found so we need to check the config twice\n\t\t\tif (universalFiles.length) {\n\t\t\t\tdebug(\"Universal files patterns found. Checking carefully.\");\n\n\t\t\t\tconst nonUniversalFiles = config.files.filter(\n\t\t\t\t\tpattern => !universalPattern.test(pattern),\n\t\t\t\t);\n\n\t\t\t\t// check that the config matches without the non-universal files first\n\t\t\t\tif (\n\t\t\t\t\tnonUniversalFiles.length &&\n\t\t\t\t\tpathMatches(filePath, relativeFilePath, {\n\t\t\t\t\t\tfiles: nonUniversalFiles,\n\t\t\t\t\t\tignores: config.ignores,\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\tmatchFound = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if there wasn't a match then check if it matches with universal files\n\t\t\t\tif (\n\t\t\t\t\tuniversalFiles.length &&\n\t\t\t\t\tpathMatches(filePath, relativeFilePath, {\n\t\t\t\t\t\tfiles: universalFiles,\n\t\t\t\t\t\tignores: config.ignores,\n\t\t\t\t\t})\n\t\t\t\t) {\n\t\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// if we make here, then there was no match\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// the normal case\n\t\t\tif (pathMatches(filePath, relativeFilePath, config)) {\n\t\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\t\tmatchingConfigIndices.push(index);\n\t\t\t\tmatchFound = true;\n\t\t\t}\n\t\t});\n\n\t\t// if matching both files and ignores, there will be no config to create\n\t\tif (!matchFound) {\n\t\t\tdebug(`No matching configs found for ${filePath}`);\n\n\t\t\t// cache and return result\n\t\t\tcache.set(filePath, CONFIG_WITH_STATUS_UNCONFIGURED);\n\t\t\treturn CONFIG_WITH_STATUS_UNCONFIGURED;\n\t\t}\n\n\t\t// check to see if there is a config cached by indices\n\t\tconst indicesKey = matchingConfigIndices.toString();\n\t\tlet configWithStatus = cache.get(indicesKey);\n\n\t\tif (configWithStatus) {\n\t\t\t// also store for filename for faster lookup next time\n\t\t\tcache.set(filePath, configWithStatus);\n\n\t\t\treturn configWithStatus;\n\t\t}\n\n\t\t// otherwise construct the config\n\n\t\t// eslint-disable-next-line array-callback-return, consistent-return -- rethrowConfigError always throws an error\n\t\tlet finalConfig = matchingConfigIndices.reduce((result, index) => {\n\t\t\ttry {\n\t\t\t\treturn this[ConfigArraySymbol.schema].merge(\n\t\t\t\t\tresult,\n\t\t\t\t\tthis[index],\n\t\t\t\t);\n\t\t\t} catch (validationError) {\n\t\t\t\trethrowConfigError(this[index], index, validationError);\n\t\t\t}\n\t\t}, {});\n\n\t\tfinalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n\n\t\tconfigWithStatus = Object.freeze({\n\t\t\tconfig: finalConfig,\n\t\t\tstatus: \"matched\",\n\t\t});\n\t\tcache.set(filePath, configWithStatus);\n\t\tcache.set(indicesKey, configWithStatus);\n\n\t\treturn configWithStatus;\n\t}\n\n\t/**\n\t * Returns the config object for a given file path.\n\t * @param {string} filePath The path of a file to get a config for.\n\t * @returns {Object|undefined} The config object for this file or `undefined`.\n\t */\n\tgetConfig(filePath) {\n\t\treturn this.getConfigWithStatus(filePath).config;\n\t}\n\n\t/**\n\t * Determines whether a file has a config or why it doesn't.\n\t * @param {string} filePath The path of the file to check.\n\t * @returns {\"ignored\"|\"external\"|\"unconfigured\"|\"matched\"} One of the following values:\n\t * * `\"ignored\"`: the file is ignored\n\t * * `\"external\"`: the file is outside the base path\n\t * * `\"unconfigured\"`: the file is not matched by any config\n\t * * `\"matched\"`: the file has a matching config\n\t */\n\tgetConfigStatus(filePath) {\n\t\treturn this.getConfigWithStatus(filePath).status;\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t * @deprecated Use `isFileIgnored` instead.\n\t */\n\tisIgnored(filePath) {\n\t\treturn this.isFileIgnored(filePath);\n\t}\n\n\t/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t */\n\tisFileIgnored(filePath) {\n\t\treturn this.getConfigStatus(filePath) === \"ignored\";\n\t}\n\n\t/**\n\t * Determines if the given directory is ignored based on the configs.\n\t * This checks only default `ignores` that don't have `files` in the\n\t * same config. A pattern such as `/foo` be considered to ignore the directory\n\t * while a pattern such as `/foo/**` is not considered to ignore the\n\t * directory because it is matching files.\n\t * @param {string} directoryPath The path of a directory to check.\n\t * @returns {boolean} True if the directory is ignored, false if not. Will\n\t * \t\treturn true for any directory that is not inside of `basePath`.\n\t * @throws {Error} When the `ConfigArray` is not normalized.\n\t */\n\tisDirectoryIgnored(directoryPath) {\n\t\tassertNormalized(this);\n\n\t\tconst relativeDirectoryPath = toRelativePath(\n\t\t\tdirectoryPath,\n\t\t\tthis.#namespacedBasePath,\n\t\t\tthis.#path,\n\t\t);\n\n\t\t// basePath directory can never be ignored\n\t\tif (relativeDirectoryPath === \"\") {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (EXTERNAL_PATH_REGEX.test(relativeDirectoryPath)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// first check the cache\n\t\tconst cache = dataCache.get(this).directoryMatches;\n\n\t\tif (cache.has(relativeDirectoryPath)) {\n\t\t\treturn cache.get(relativeDirectoryPath);\n\t\t}\n\n\t\tconst directoryParts = relativeDirectoryPath.split(\"/\");\n\t\tlet relativeDirectoryToCheck = \"\";\n\t\tlet result;\n\n\t\t/*\n\t\t * In order to get the correct gitignore-style ignores, where an\n\t\t * ignored parent directory cannot have any descendants unignored,\n\t\t * we need to check every directory starting at the parent all\n\t\t * the way down to the actual requested directory.\n\t\t *\n\t\t * We aggressively cache all of this info to make sure we don't\n\t\t * have to recalculate everything for every call.\n\t\t */\n\t\tdo {\n\t\t\trelativeDirectoryToCheck += `${directoryParts.shift()}/`;\n\n\t\t\tresult = shouldIgnorePath(\n\t\t\t\tthis.ignores,\n\t\t\t\tthis.#path.join(this.basePath, relativeDirectoryToCheck),\n\t\t\t\trelativeDirectoryToCheck,\n\t\t\t);\n\n\t\t\tcache.set(relativeDirectoryToCheck, result);\n\t\t} while (!result && directoryParts.length);\n\n\t\t// also cache the result for the requested path\n\t\tcache.set(relativeDirectoryPath, result);\n\n\t\treturn result;\n\t}\n}\n\nexport { ConfigArray, ConfigArraySymbol };\n"
        }
    ]
}