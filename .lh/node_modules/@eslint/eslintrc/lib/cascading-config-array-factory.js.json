{
    "sourceFile": "node_modules/@eslint/eslintrc/lib/cascading-config-array-factory.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891758504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview `CascadingConfigArrayFactory` class.\n *\n * `CascadingConfigArrayFactory` class has a responsibility:\n *\n * 1. Handles cascading of config files.\n *\n * It provides two methods:\n *\n * - `getConfigArrayForFile(filePath)`\n *     Get the corresponded configuration of a given file. This method doesn't\n *     throw even if the given file didn't exist.\n * - `clearCache()`\n *     Clear the internal cache. You have to call this method when\n *     `additionalPluginPool` was updated if `baseConfig` or `cliConfig` depends\n *     on the additional plugins. (`CLIEngine#addPlugin()` method calls this.)\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport debugOrig from \"debug\";\nimport os from \"node:os\";\nimport path from \"node:path\";\n\nimport { ConfigArrayFactory } from \"./config-array-factory.js\";\nimport {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern\n} from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport { emitDeprecationWarning } from \"./shared/deprecation-warnings.js\";\n\nconst debug = debugOrig(\"eslintrc:cascading-config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArrayFactory[\"create\"]>} ConfigArray */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {ConfigData} [baseConfig] The config by `baseConfig` option.\n * @property {ConfigData} [cliConfig] The config by CLI options (`--env`, `--global`, `--ignore-pattern`, `--parser`, `--parser-options`, `--plugin`, and `--rule`). CLI options overwrite the setting in config files.\n * @property {string} [cwd] The base directory to start lookup.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\n * @property {string} [specificConfigPath] The value of `--config` option.\n * @property {boolean} [useEslintrc] if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} CascadingConfigArrayFactoryInternalSlots\n * @property {ConfigArray} baseConfigArray The config array of `baseConfig` option.\n * @property {ConfigData} baseConfigData The config data of `baseConfig` option. This is used to reset `baseConfigArray`.\n * @property {ConfigArray} cliConfigArray The config array of CLI options.\n * @property {ConfigData} cliConfigData The config data of CLI options. This is used to reset `cliConfigArray`.\n * @property {ConfigArrayFactory} configArrayFactory The factory for config arrays.\n * @property {Map<string, ConfigArray>} configCache The cache from directory paths to config arrays.\n * @property {string} cwd The base directory to start lookup.\n * @property {WeakMap<ConfigArray, ConfigArray>} finalizeCache The cache from config arrays to finalized config arrays.\n * @property {string} [ignorePath] The path to the alternative file of `.eslintignore`.\n * @property {string[]|null} rulePaths The value of `--rulesdir` option. This is used to reset `baseConfigArray`.\n * @property {string|null} specificConfigPath The value of `--config` option. This is used to reset `cliConfigArray`.\n * @property {boolean} useEslintrc if `false` then it doesn't load config files.\n * @property {Function} loadRules The function to use to load rules.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/** @type {WeakMap<CascadingConfigArrayFactory, CascadingConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Create the config array from `baseConfig` and `rulePaths`.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\nfunction createBaseConfigArray({\n    configArrayFactory,\n    baseConfigData,\n    rulePaths,\n    cwd,\n    loadRules\n}) {\n    const baseConfigArray = configArrayFactory.create(\n        baseConfigData,\n        { name: \"BaseConfig\" }\n    );\n\n    /*\n     * Create the config array element for the default ignore patterns.\n     * This element has `ignorePattern` property that ignores the default\n     * patterns in the current working directory.\n     */\n    baseConfigArray.unshift(configArrayFactory.create(\n        { ignorePatterns: IgnorePattern.DefaultPatterns },\n        { name: \"DefaultIgnorePattern\" }\n    )[0]);\n\n    /*\n     * Load rules `--rulesdir` option as a pseudo plugin.\n     * Use a pseudo plugin to define rules of `--rulesdir`, so we can validate\n     * the rule's options with only information in the config array.\n     */\n    if (rulePaths && rulePaths.length > 0) {\n        baseConfigArray.push({\n            type: \"config\",\n            name: \"--rulesdir\",\n            filePath: \"\",\n            plugins: {\n                \"\": new ConfigDependency({\n                    definition: {\n                        rules: rulePaths.reduce(\n                            (map, rulesPath) => Object.assign(\n                                map,\n                                loadRules(rulesPath, cwd)\n                            ),\n                            {}\n                        )\n                    },\n                    filePath: \"\",\n                    id: \"\",\n                    importerName: \"--rulesdir\",\n                    importerPath: \"\"\n                })\n            }\n        });\n    }\n\n    return baseConfigArray;\n}\n\n/**\n * Create the config array from CLI options.\n * @param {CascadingConfigArrayFactoryInternalSlots} slots The slots.\n * @returns {ConfigArray} The config array of the base configs.\n */\nfunction createCLIConfigArray({\n    cliConfigData,\n    configArrayFactory,\n    cwd,\n    ignorePath,\n    specificConfigPath\n}) {\n    const cliConfigArray = configArrayFactory.create(\n        cliConfigData,\n        { name: \"CLIOptions\" }\n    );\n\n    cliConfigArray.unshift(\n        ...(ignorePath\n            ? configArrayFactory.loadESLintIgnore(ignorePath)\n            : configArrayFactory.loadDefaultESLintIgnore())\n    );\n\n    if (specificConfigPath) {\n        cliConfigArray.unshift(\n            ...configArrayFactory.loadFile(\n                specificConfigPath,\n                { name: \"--config\", basePath: cwd }\n            )\n        );\n    }\n\n    return cliConfigArray;\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass ConfigurationNotFoundError extends Error {\n\n\n    /**\n     * @param {string} directoryPath The directory path.\n     */\n    constructor(directoryPath) {\n        super(`No ESLint configuration found in ${directoryPath}.`);\n        this.messageTemplate = \"no-config-found\";\n        this.messageData = { directoryPath };\n    }\n}\n\n/**\n * This class provides the functionality that enumerates every file which is\n * matched by given glob patterns and that configuration.\n */\nclass CascadingConfigArrayFactory {\n\n    /**\n     * Initialize this enumerator.\n     * @param {CascadingConfigArrayFactoryOptions} options The options.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        baseConfig: baseConfigData = null,\n        cliConfig: cliConfigData = null,\n        cwd = process.cwd(),\n        ignorePath,\n        resolvePluginsRelativeTo,\n        rulePaths = [],\n        specificConfigPath = null,\n        useEslintrc = true,\n        builtInRules = new Map(),\n        loadRules,\n        resolver,\n        eslintRecommendedPath,\n        getEslintRecommendedConfig,\n        eslintAllPath,\n        getEslintAllConfig\n    } = {}) {\n        const configArrayFactory = new ConfigArrayFactory({\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo,\n            builtInRules,\n            resolver,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig,\n            eslintAllPath,\n            getEslintAllConfig\n        });\n\n        internalSlotsMap.set(this, {\n            baseConfigArray: createBaseConfigArray({\n                baseConfigData,\n                configArrayFactory,\n                cwd,\n                rulePaths,\n                loadRules\n            }),\n            baseConfigData,\n            cliConfigArray: createCLIConfigArray({\n                cliConfigData,\n                configArrayFactory,\n                cwd,\n                ignorePath,\n                specificConfigPath\n            }),\n            cliConfigData,\n            configArrayFactory,\n            configCache: new Map(),\n            cwd,\n            finalizeCache: new WeakMap(),\n            ignorePath,\n            rulePaths,\n            specificConfigPath,\n            useEslintrc,\n            builtInRules,\n            loadRules\n        });\n    }\n\n    /**\n     * The path to the current working directory.\n     * This is used by tests.\n     * @type {string}\n     */\n    get cwd() {\n        const { cwd } = internalSlotsMap.get(this);\n\n        return cwd;\n    }\n\n    /**\n     * Get the config array of a given file.\n     * If `filePath` was not given, it returns the config which contains only\n     * `baseConfigData` and `cliConfigData`.\n     * @param {string} [filePath] The file path to a file.\n     * @param {Object} [options] The options.\n     * @param {boolean} [options.ignoreNotFoundError] If `true` then it doesn't throw `ConfigurationNotFoundError`.\n     * @returns {ConfigArray} The config array of the file.\n     */\n    getConfigArrayForFile(filePath, { ignoreNotFoundError = false } = {}) {\n        const {\n            baseConfigArray,\n            cliConfigArray,\n            cwd\n        } = internalSlotsMap.get(this);\n\n        if (!filePath) {\n            return new ConfigArray(...baseConfigArray, ...cliConfigArray);\n        }\n\n        const directoryPath = path.dirname(path.resolve(cwd, filePath));\n\n        debug(`Load config files for ${directoryPath}.`);\n\n        return this._finalizeConfigArray(\n            this._loadConfigInAncestors(directoryPath),\n            directoryPath,\n            ignoreNotFoundError\n        );\n    }\n\n    /**\n     * Set the config data to override all configs.\n     * Require to call `clearCache()` method after this method is called.\n     * @param {ConfigData} configData The config data to override all configs.\n     * @returns {void}\n     */\n    setOverrideConfig(configData) {\n        const slots = internalSlotsMap.get(this);\n\n        slots.cliConfigData = configData;\n    }\n\n    /**\n     * Clear config cache.\n     * @returns {void}\n     */\n    clearCache() {\n        const slots = internalSlotsMap.get(this);\n\n        slots.baseConfigArray = createBaseConfigArray(slots);\n        slots.cliConfigArray = createCLIConfigArray(slots);\n        slots.configCache.clear();\n    }\n\n    /**\n     * Load and normalize config files from the ancestor directories.\n     * @param {string} directoryPath The path to a leaf directory.\n     * @param {boolean} configsExistInSubdirs `true` if configurations exist in subdirectories.\n     * @returns {ConfigArray} The loaded config.\n     * @throws {Error} If a config file is invalid.\n     * @private\n     */\n    _loadConfigInAncestors(directoryPath, configsExistInSubdirs = false) {\n        const {\n            baseConfigArray,\n            configArrayFactory,\n            configCache,\n            cwd,\n            useEslintrc\n        } = internalSlotsMap.get(this);\n\n        if (!useEslintrc) {\n            return baseConfigArray;\n        }\n\n        let configArray = configCache.get(directoryPath);\n\n        // Hit cache.\n        if (configArray) {\n            debug(`Cache hit: ${directoryPath}.`);\n            return configArray;\n        }\n        debug(`No cache found: ${directoryPath}.`);\n\n        const homePath = os.homedir();\n\n        // Consider this is root.\n        if (directoryPath === homePath && cwd !== homePath) {\n            debug(\"Stop traversing because of considered root.\");\n            if (configsExistInSubdirs) {\n                const filePath = ConfigArrayFactory.getPathToConfigFileInDirectory(directoryPath);\n\n                if (filePath) {\n                    emitDeprecationWarning(\n                        filePath,\n                        \"ESLINT_PERSONAL_CONFIG_SUPPRESS\"\n                    );\n                }\n            }\n            return this._cacheConfig(directoryPath, baseConfigArray);\n        }\n\n        // Load the config on this directory.\n        try {\n            configArray = configArrayFactory.loadInDirectory(directoryPath);\n        } catch (error) {\n            /* istanbul ignore next */\n            if (error.code === \"EACCES\") {\n                debug(\"Stop traversing because of 'EACCES' error.\");\n                return this._cacheConfig(directoryPath, baseConfigArray);\n            }\n            throw error;\n        }\n\n        if (configArray.length > 0 && configArray.isRoot()) {\n            debug(\"Stop traversing because of 'root:true'.\");\n            configArray.unshift(...baseConfigArray);\n            return this._cacheConfig(directoryPath, configArray);\n        }\n\n        // Load from the ancestors and merge it.\n        const parentPath = path.dirname(directoryPath);\n        const parentConfigArray = parentPath && parentPath !== directoryPath\n            ? this._loadConfigInAncestors(\n                parentPath,\n                configsExistInSubdirs || configArray.length > 0\n            )\n            : baseConfigArray;\n\n        if (configArray.length > 0) {\n            configArray.unshift(...parentConfigArray);\n        } else {\n            configArray = parentConfigArray;\n        }\n\n        // Cache and return.\n        return this._cacheConfig(directoryPath, configArray);\n    }\n\n    /**\n     * Freeze and cache a given config.\n     * @param {string} directoryPath The path to a directory as a cache key.\n     * @param {ConfigArray} configArray The config array as a cache value.\n     * @returns {ConfigArray} The `configArray` (frozen).\n     */\n    _cacheConfig(directoryPath, configArray) {\n        const { configCache } = internalSlotsMap.get(this);\n\n        Object.freeze(configArray);\n        configCache.set(directoryPath, configArray);\n\n        return configArray;\n    }\n\n    /**\n     * Finalize a given config array.\n     * Concatenate `--config` and other CLI options.\n     * @param {ConfigArray} configArray The parent config array.\n     * @param {string} directoryPath The path to the leaf directory to find config files.\n     * @param {boolean} ignoreNotFoundError If `true` then it doesn't throw `ConfigurationNotFoundError`.\n     * @returns {ConfigArray} The loaded config.\n     * @throws {Error} If a config file is invalid.\n     * @private\n     */\n    _finalizeConfigArray(configArray, directoryPath, ignoreNotFoundError) {\n        const {\n            cliConfigArray,\n            configArrayFactory,\n            finalizeCache,\n            useEslintrc,\n            builtInRules\n        } = internalSlotsMap.get(this);\n\n        let finalConfigArray = finalizeCache.get(configArray);\n\n        if (!finalConfigArray) {\n            finalConfigArray = configArray;\n\n            // Load the personal config if there are no regular config files.\n            if (\n                useEslintrc &&\n                configArray.every(c => !c.filePath) &&\n                cliConfigArray.every(c => !c.filePath) // `--config` option can be a file.\n            ) {\n                const homePath = os.homedir();\n\n                debug(\"Loading the config file of the home directory:\", homePath);\n\n                const personalConfigArray = configArrayFactory.loadInDirectory(\n                    homePath,\n                    { name: \"PersonalConfig\" }\n                );\n\n                if (\n                    personalConfigArray.length > 0 &&\n                    !directoryPath.startsWith(homePath)\n                ) {\n                    const lastElement =\n                        personalConfigArray.at(-1);\n\n                    emitDeprecationWarning(\n                        lastElement.filePath,\n                        \"ESLINT_PERSONAL_CONFIG_LOAD\"\n                    );\n                }\n\n                finalConfigArray = finalConfigArray.concat(personalConfigArray);\n            }\n\n            // Apply CLI options.\n            if (cliConfigArray.length > 0) {\n                finalConfigArray = finalConfigArray.concat(cliConfigArray);\n            }\n\n            // Validate rule settings and environments.\n            const validator = new ConfigValidator({\n                builtInRules\n            });\n\n            validator.validateConfigArray(finalConfigArray);\n\n            // Cache it.\n            Object.freeze(finalConfigArray);\n            finalizeCache.set(configArray, finalConfigArray);\n\n            debug(\n                \"Configuration was determined: %o on %s\",\n                finalConfigArray,\n                directoryPath\n            );\n        }\n\n        // At least one element (the default ignore patterns) exists.\n        if (!ignoreNotFoundError && useEslintrc && finalConfigArray.length <= 1) {\n            throw new ConfigurationNotFoundError(directoryPath);\n        }\n\n        return finalConfigArray;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nexport { CascadingConfigArrayFactory };\n"
        }
    ]
}