{
    "sourceFile": "node_modules/@eslint/eslintrc/lib/flat-compat.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891758766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Compatibility class for flat config.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nimport createDebug from \"debug\";\nimport path from \"node:path\";\n\nimport environments from \"../conf/environments.js\";\nimport { ConfigArrayFactory } from \"./config-array-factory.js\";\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"../../shared/types\").Environment} Environment */\n/** @typedef {import(\"../../shared/types\").Processor} Processor */\n\nconst debug = createDebug(\"eslintrc:flat-compat\");\nconst cafactory = Symbol(\"cafactory\");\n\n/**\n * Translates an ESLintRC-style config object into a flag-config-style config\n * object.\n * @param {Object} eslintrcConfig An ESLintRC-style config object.\n * @param {Object} options Options to help translate the config.\n * @param {string} options.resolveConfigRelativeTo To the directory to resolve\n *      configs from.\n * @param {string} options.resolvePluginsRelativeTo The directory to resolve\n *      plugins from.\n * @param {ReadOnlyMap<string,Environment>} options.pluginEnvironments A map of plugin environment\n *      names to objects.\n * @param {ReadOnlyMap<string,Processor>} options.pluginProcessors A map of plugin processor\n *      names to objects.\n * @returns {Object} A flag-config-style config object.\n * @throws {Error} If a plugin or environment cannot be resolved.\n */\nfunction translateESLintRC(eslintrcConfig, {\n    resolveConfigRelativeTo,\n    resolvePluginsRelativeTo,\n    pluginEnvironments,\n    pluginProcessors\n}) {\n\n    const flatConfig = {};\n    const configs = [];\n    const languageOptions = {};\n    const linterOptions = {};\n    const keysToCopy = [\"settings\", \"rules\", \"processor\"];\n    const languageOptionsKeysToCopy = [\"globals\", \"parser\", \"parserOptions\"];\n    const linterOptionsKeysToCopy = [\"noInlineConfig\", \"reportUnusedDisableDirectives\"];\n\n    // copy over simple translations\n    for (const key of keysToCopy) {\n        if (key in eslintrcConfig && typeof eslintrcConfig[key] !== \"undefined\") {\n            flatConfig[key] = eslintrcConfig[key];\n        }\n    }\n\n    // copy over languageOptions\n    for (const key of languageOptionsKeysToCopy) {\n        if (key in eslintrcConfig && typeof eslintrcConfig[key] !== \"undefined\") {\n\n            // create the languageOptions key in the flat config\n            flatConfig.languageOptions = languageOptions;\n\n            if (key === \"parser\") {\n                debug(`Resolving parser '${languageOptions[key]}' relative to ${resolveConfigRelativeTo}`);\n\n                if (eslintrcConfig[key].error) {\n                    throw eslintrcConfig[key].error;\n                }\n\n                languageOptions[key] = eslintrcConfig[key].definition;\n                continue;\n            }\n\n            // clone any object values that are in the eslintrc config\n            if (eslintrcConfig[key] && typeof eslintrcConfig[key] === \"object\") {\n                languageOptions[key] = {\n                    ...eslintrcConfig[key]\n                };\n            } else {\n                languageOptions[key] = eslintrcConfig[key];\n            }\n        }\n    }\n\n    // copy over linterOptions\n    for (const key of linterOptionsKeysToCopy) {\n        if (key in eslintrcConfig && typeof eslintrcConfig[key] !== \"undefined\") {\n            flatConfig.linterOptions = linterOptions;\n            linterOptions[key] = eslintrcConfig[key];\n        }\n    }\n\n    // move ecmaVersion a level up\n    if (languageOptions.parserOptions) {\n\n        if (\"ecmaVersion\" in languageOptions.parserOptions) {\n            languageOptions.ecmaVersion = languageOptions.parserOptions.ecmaVersion;\n            delete languageOptions.parserOptions.ecmaVersion;\n        }\n\n        if (\"sourceType\" in languageOptions.parserOptions) {\n            languageOptions.sourceType = languageOptions.parserOptions.sourceType;\n            delete languageOptions.parserOptions.sourceType;\n        }\n\n        // check to see if we even need parserOptions anymore and remove it if not\n        if (Object.keys(languageOptions.parserOptions).length === 0) {\n            delete languageOptions.parserOptions;\n        }\n    }\n\n    // overrides\n    if (eslintrcConfig.criteria) {\n        flatConfig.files = [absoluteFilePath => eslintrcConfig.criteria.test(absoluteFilePath)];\n    }\n\n    // translate plugins\n    if (eslintrcConfig.plugins && typeof eslintrcConfig.plugins === \"object\") {\n        debug(`Translating plugins: ${eslintrcConfig.plugins}`);\n\n        flatConfig.plugins = {};\n\n        for (const pluginName of Object.keys(eslintrcConfig.plugins)) {\n\n            debug(`Translating plugin: ${pluginName}`);\n            debug(`Resolving plugin '${pluginName} relative to ${resolvePluginsRelativeTo}`);\n\n            const { original: plugin, error } = eslintrcConfig.plugins[pluginName];\n\n            if (error) {\n                throw error;\n            }\n\n            flatConfig.plugins[pluginName] = plugin;\n\n            // create a config for any processors\n            if (plugin.processors) {\n                for (const processorName of Object.keys(plugin.processors)) {\n                    if (processorName.startsWith(\".\")) {\n                        debug(`Assigning processor: ${pluginName}/${processorName}`);\n\n                        configs.unshift({\n                            files: [`**/*${processorName}`],\n                            processor: pluginProcessors.get(`${pluginName}/${processorName}`)\n                        });\n                    }\n\n                }\n            }\n        }\n    }\n\n    // translate env - must come after plugins\n    if (eslintrcConfig.env && typeof eslintrcConfig.env === \"object\") {\n        for (const envName of Object.keys(eslintrcConfig.env)) {\n\n            // only add environments that are true\n            if (eslintrcConfig.env[envName]) {\n                debug(`Translating environment: ${envName}`);\n\n                if (environments.has(envName)) {\n\n                    // built-in environments should be defined first\n                    configs.unshift(...translateESLintRC({\n                        criteria: eslintrcConfig.criteria,\n                        ...environments.get(envName)\n                    }, {\n                        resolveConfigRelativeTo,\n                        resolvePluginsRelativeTo\n                    }));\n                } else if (pluginEnvironments.has(envName)) {\n\n                    // if the environment comes from a plugin, it should come after the plugin config\n                    configs.push(...translateESLintRC({\n                        criteria: eslintrcConfig.criteria,\n                        ...pluginEnvironments.get(envName)\n                    }, {\n                        resolveConfigRelativeTo,\n                        resolvePluginsRelativeTo\n                    }));\n                }\n            }\n        }\n    }\n\n    // only add if there are actually keys in the config\n    if (Object.keys(flatConfig).length > 0) {\n        configs.push(flatConfig);\n    }\n\n    return configs;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * A compatibility class for working with configs.\n */\nclass FlatCompat {\n\n    constructor({\n        baseDirectory = process.cwd(),\n        resolvePluginsRelativeTo = baseDirectory,\n        recommendedConfig,\n        allConfig\n    } = {}) {\n        this.baseDirectory = baseDirectory;\n        this.resolvePluginsRelativeTo = resolvePluginsRelativeTo;\n        this[cafactory] = new ConfigArrayFactory({\n            cwd: baseDirectory,\n            resolvePluginsRelativeTo,\n            getEslintAllConfig() {\n\n                if (!allConfig) {\n                    throw new TypeError(\"Missing parameter 'allConfig' in FlatCompat constructor.\");\n                }\n\n                return allConfig;\n            },\n            getEslintRecommendedConfig() {\n\n                if (!recommendedConfig) {\n                    throw new TypeError(\"Missing parameter 'recommendedConfig' in FlatCompat constructor.\");\n                }\n\n                return recommendedConfig;\n            }\n        });\n    }\n\n    /**\n     * Translates an ESLintRC-style config into a flag-config-style config.\n     * @param {Object} eslintrcConfig The ESLintRC-style config object.\n     * @returns {Object} A flag-config-style config object.\n     */\n    config(eslintrcConfig) {\n        const eslintrcArray = this[cafactory].create(eslintrcConfig, {\n            basePath: this.baseDirectory\n        });\n\n        const flatArray = [];\n        let hasIgnorePatterns = false;\n\n        eslintrcArray.forEach(configData => {\n            if (configData.type === \"config\") {\n                hasIgnorePatterns = hasIgnorePatterns || configData.ignorePattern;\n                flatArray.push(...translateESLintRC(configData, {\n                    resolveConfigRelativeTo: path.join(this.baseDirectory, \"__placeholder.js\"),\n                    resolvePluginsRelativeTo: path.join(this.resolvePluginsRelativeTo, \"__placeholder.js\"),\n                    pluginEnvironments: eslintrcArray.pluginEnvironments,\n                    pluginProcessors: eslintrcArray.pluginProcessors\n                }));\n            }\n        });\n\n        // combine ignorePatterns to emulate ESLintRC behavior better\n        if (hasIgnorePatterns) {\n            flatArray.unshift({\n                ignores: [filePath => {\n\n                    // Compute the final config for this file.\n                    // This filters config array elements by `files`/`excludedFiles` then merges the elements.\n                    const finalConfig = eslintrcArray.extractConfig(filePath);\n\n                    // Test the `ignorePattern` properties of the final config.\n                    return Boolean(finalConfig.ignores) && finalConfig.ignores(filePath);\n                }]\n            });\n        }\n\n        return flatArray;\n    }\n\n    /**\n     * Translates the `env` section of an ESLintRC-style config.\n     * @param {Object} envConfig The `env` section of an ESLintRC config.\n     * @returns {Object[]} An array of flag-config objects representing the environments.\n     */\n    env(envConfig) {\n        return this.config({\n            env: envConfig\n        });\n    }\n\n    /**\n     * Translates the `extends` section of an ESLintRC-style config.\n     * @param {...string} configsToExtend The names of the configs to load.\n     * @returns {Object[]} An array of flag-config objects representing the config.\n     */\n    extends(...configsToExtend) {\n        return this.config({\n            extends: configsToExtend\n        });\n    }\n\n    /**\n     * Translates the `plugins` section of an ESLintRC-style config.\n     * @param {...string} plugins The names of the plugins to load.\n     * @returns {Object[]} An array of flag-config objects representing the plugins.\n     */\n    plugins(...plugins) {\n        return this.config({\n            plugins\n        });\n    }\n}\n\nexport { FlatCompat };\n"
        }
    ]
}