{
    "sourceFile": "node_modules/@eslint/object-schema/dist/cjs/index.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891759360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\n/**\n * @fileoverview Merge Strategy\n */\n\n//-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\n * Container class for several different merge strategies.\n */\nclass MergeStrategy {\n\t/**\n\t * Merges two keys by overwriting the first with the second.\n\t * @param {*} value1 The value from the first object key.\n\t * @param {*} value2 The value from the second object key.\n\t * @returns {*} The second value.\n\t */\n\tstatic overwrite(value1, value2) {\n\t\treturn value2;\n\t}\n\n\t/**\n\t * Merges two keys by replacing the first with the second only if the\n\t * second is defined.\n\t * @param {*} value1 The value from the first object key.\n\t * @param {*} value2 The value from the second object key.\n\t * @returns {*} The second value if it is defined.\n\t */\n\tstatic replace(value1, value2) {\n\t\tif (typeof value2 !== \"undefined\") {\n\t\t\treturn value2;\n\t\t}\n\n\t\treturn value1;\n\t}\n\n\t/**\n\t * Merges two properties by assigning properties from the second to the first.\n\t * @param {*} value1 The value from the first object key.\n\t * @param {*} value2 The value from the second object key.\n\t * @returns {*} A new object containing properties from both value1 and\n\t *      value2.\n\t */\n\tstatic assign(value1, value2) {\n\t\treturn Object.assign({}, value1, value2);\n\t}\n}\n\n/**\n * @fileoverview Validation Strategy\n */\n\n//-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\n * Container class for several different validation strategies.\n */\nclass ValidationStrategy {\n\t/**\n\t * Validates that a value is an array.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic array(value) {\n\t\tif (!Array.isArray(value)) {\n\t\t\tthrow new TypeError(\"Expected an array.\");\n\t\t}\n\t}\n\n\t/**\n\t * Validates that a value is a boolean.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic boolean(value) {\n\t\tif (typeof value !== \"boolean\") {\n\t\t\tthrow new TypeError(\"Expected a Boolean.\");\n\t\t}\n\t}\n\n\t/**\n\t * Validates that a value is a number.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic number(value) {\n\t\tif (typeof value !== \"number\") {\n\t\t\tthrow new TypeError(\"Expected a number.\");\n\t\t}\n\t}\n\n\t/**\n\t * Validates that a value is a object.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic object(value) {\n\t\tif (!value || typeof value !== \"object\") {\n\t\t\tthrow new TypeError(\"Expected an object.\");\n\t\t}\n\t}\n\n\t/**\n\t * Validates that a value is a object or null.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic \"object?\"(value) {\n\t\tif (typeof value !== \"object\") {\n\t\t\tthrow new TypeError(\"Expected an object or null.\");\n\t\t}\n\t}\n\n\t/**\n\t * Validates that a value is a string.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic string(value) {\n\t\tif (typeof value !== \"string\") {\n\t\t\tthrow new TypeError(\"Expected a string.\");\n\t\t}\n\t}\n\n\t/**\n\t * Validates that a value is a non-empty string.\n\t * @param {*} value The value to validate.\n\t * @returns {void}\n\t * @throws {TypeError} If the value is invalid.\n\t */\n\tstatic \"string!\"(value) {\n\t\tif (typeof value !== \"string\" || value.length === 0) {\n\t\t\tthrow new TypeError(\"Expected a non-empty string.\");\n\t\t}\n\t}\n}\n\n/**\n * @fileoverview Object Schema\n */\n\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"./types.ts\").ObjectDefinition} ObjectDefinition */\n/** @typedef {import(\"./types.ts\").PropertyDefinition} PropertyDefinition */\n\n//-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\n/**\n * Validates a schema strategy.\n * @param {string} name The name of the key this strategy is for.\n * @param {PropertyDefinition} definition The strategy for the object key.\n * @returns {void}\n * @throws {Error} When the strategy is missing a name.\n * @throws {Error} When the strategy is missing a merge() method.\n * @throws {Error} When the strategy is missing a validate() method.\n */\nfunction validateDefinition(name, definition) {\n\tlet hasSchema = false;\n\tif (definition.schema) {\n\t\tif (typeof definition.schema === \"object\") {\n\t\t\thasSchema = true;\n\t\t} else {\n\t\t\tthrow new TypeError(\"Schema must be an object.\");\n\t\t}\n\t}\n\n\tif (typeof definition.merge === \"string\") {\n\t\tif (!(definition.merge in MergeStrategy)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Definition for key \"${name}\" missing valid merge strategy.`,\n\t\t\t);\n\t\t}\n\t} else if (!hasSchema && typeof definition.merge !== \"function\") {\n\t\tthrow new TypeError(\n\t\t\t`Definition for key \"${name}\" must have a merge property.`,\n\t\t);\n\t}\n\n\tif (typeof definition.validate === \"string\") {\n\t\tif (!(definition.validate in ValidationStrategy)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Definition for key \"${name}\" missing valid validation strategy.`,\n\t\t\t);\n\t\t}\n\t} else if (!hasSchema && typeof definition.validate !== \"function\") {\n\t\tthrow new TypeError(\n\t\t\t`Definition for key \"${name}\" must have a validate() method.`,\n\t\t);\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * Error when an unexpected key is found.\n */\nclass UnexpectedKeyError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} key The key that was unexpected.\n\t */\n\tconstructor(key) {\n\t\tsuper(`Unexpected key \"${key}\" found.`);\n\t}\n}\n\n/**\n * Error when a required key is missing.\n */\nclass MissingKeyError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} key The key that was missing.\n\t */\n\tconstructor(key) {\n\t\tsuper(`Missing required key \"${key}\".`);\n\t}\n}\n\n/**\n * Error when a key requires other keys that are missing.\n */\nclass MissingDependentKeysError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} key The key that was unexpected.\n\t * @param {Array<string>} requiredKeys The keys that are required.\n\t */\n\tconstructor(key, requiredKeys) {\n\t\tsuper(`Key \"${key}\" requires keys \"${requiredKeys.join('\", \"')}\".`);\n\t}\n}\n\n/**\n * Wrapper error for errors occuring during a merge or validate operation.\n */\nclass WrapperError extends Error {\n\t/**\n\t * Creates a new instance.\n\t * @param {string} key The object key causing the error.\n\t * @param {Error} source The source error.\n\t */\n\tconstructor(key, source) {\n\t\tsuper(`Key \"${key}\": ${source.message}`, { cause: source });\n\n\t\t// copy over custom properties that aren't represented\n\t\tfor (const sourceKey of Object.keys(source)) {\n\t\t\tif (!(sourceKey in this)) {\n\t\t\t\tthis[sourceKey] = source[sourceKey];\n\t\t\t}\n\t\t}\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Represents an object validation/merging schema.\n */\nclass ObjectSchema {\n\t/**\n\t * Track all definitions in the schema by key.\n\t * @type {Map<string, PropertyDefinition>}\n\t */\n\t#definitions = new Map();\n\n\t/**\n\t * Separately track any keys that are required for faster validtion.\n\t * @type {Map<string, PropertyDefinition>}\n\t */\n\t#requiredKeys = new Map();\n\n\t/**\n\t * Creates a new instance.\n\t * @param {ObjectDefinition} definitions The schema definitions.\n\t */\n\tconstructor(definitions) {\n\t\tif (!definitions) {\n\t\t\tthrow new Error(\"Schema definitions missing.\");\n\t\t}\n\n\t\t// add in all strategies\n\t\tfor (const key of Object.keys(definitions)) {\n\t\t\tvalidateDefinition(key, definitions[key]);\n\n\t\t\t// normalize merge and validate methods if subschema is present\n\t\t\tif (typeof definitions[key].schema === \"object\") {\n\t\t\t\tconst schema = new ObjectSchema(definitions[key].schema);\n\t\t\t\tdefinitions[key] = {\n\t\t\t\t\t...definitions[key],\n\t\t\t\t\tmerge(first = {}, second = {}) {\n\t\t\t\t\t\treturn schema.merge(first, second);\n\t\t\t\t\t},\n\t\t\t\t\tvalidate(value) {\n\t\t\t\t\t\tValidationStrategy.object(value);\n\t\t\t\t\t\tschema.validate(value);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// normalize the merge method in case there's a string\n\t\t\tif (typeof definitions[key].merge === \"string\") {\n\t\t\t\tdefinitions[key] = {\n\t\t\t\t\t...definitions[key],\n\t\t\t\t\tmerge: MergeStrategy[\n\t\t\t\t\t\t/** @type {string} */ (definitions[key].merge)\n\t\t\t\t\t],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// normalize the validate method in case there's a string\n\t\t\tif (typeof definitions[key].validate === \"string\") {\n\t\t\t\tdefinitions[key] = {\n\t\t\t\t\t...definitions[key],\n\t\t\t\t\tvalidate:\n\t\t\t\t\t\tValidationStrategy[\n\t\t\t\t\t\t\t/** @type {string} */ (definitions[key].validate)\n\t\t\t\t\t\t],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.#definitions.set(key, definitions[key]);\n\n\t\t\tif (definitions[key].required) {\n\t\t\t\tthis.#requiredKeys.set(key, definitions[key]);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Determines if a strategy has been registered for the given object key.\n\t * @param {string} key The object key to find a strategy for.\n\t * @returns {boolean} True if the key has a strategy registered, false if not.\n\t */\n\thasKey(key) {\n\t\treturn this.#definitions.has(key);\n\t}\n\n\t/**\n\t * Merges objects together to create a new object comprised of the keys\n\t * of the all objects. Keys are merged based on the each key's merge\n\t * strategy.\n\t * @param {...Object} objects The objects to merge.\n\t * @returns {Object} A new object with a mix of all objects' keys.\n\t * @throws {Error} If any object is invalid.\n\t */\n\tmerge(...objects) {\n\t\t// double check arguments\n\t\tif (objects.length < 2) {\n\t\t\tthrow new TypeError(\"merge() requires at least two arguments.\");\n\t\t}\n\n\t\tif (\n\t\t\tobjects.some(\n\t\t\t\tobject => object === null || typeof object !== \"object\",\n\t\t\t)\n\t\t) {\n\t\t\tthrow new TypeError(\"All arguments must be objects.\");\n\t\t}\n\n\t\treturn objects.reduce((result, object) => {\n\t\t\tthis.validate(object);\n\n\t\t\tfor (const [key, strategy] of this.#definitions) {\n\t\t\t\ttry {\n\t\t\t\t\tif (key in result || key in object) {\n\t\t\t\t\t\tconst merge = /** @type {Function} */ (strategy.merge);\n\t\t\t\t\t\tconst value = merge.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tresult[key],\n\t\t\t\t\t\t\tobject[key],\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\t\tresult[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthrow new WrapperError(key, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * Validates an object's keys based on the validate strategy for each key.\n\t * @param {Object} object The object to validate.\n\t * @returns {void}\n\t * @throws {Error} When the object is invalid.\n\t */\n\tvalidate(object) {\n\t\t// check existing keys first\n\t\tfor (const key of Object.keys(object)) {\n\t\t\t// check to see if the key is defined\n\t\t\tif (!this.hasKey(key)) {\n\t\t\t\tthrow new UnexpectedKeyError(key);\n\t\t\t}\n\n\t\t\t// validate existing keys\n\t\t\tconst definition = this.#definitions.get(key);\n\n\t\t\t// first check to see if any other keys are required\n\t\t\tif (Array.isArray(definition.requires)) {\n\t\t\t\tif (\n\t\t\t\t\t!definition.requires.every(otherKey => otherKey in object)\n\t\t\t\t) {\n\t\t\t\t\tthrow new MissingDependentKeysError(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tdefinition.requires,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now apply remaining validation strategy\n\t\t\ttry {\n\t\t\t\tconst validate = /** @type {Function} */ (definition.validate);\n\t\t\t\tvalidate.call(definition, object[key]);\n\t\t\t} catch (ex) {\n\t\t\t\tthrow new WrapperError(key, ex);\n\t\t\t}\n\t\t}\n\n\t\t// ensure required keys aren't missing\n\t\tfor (const [key] of this.#requiredKeys) {\n\t\t\tif (!(key in object)) {\n\t\t\t\tthrow new MissingKeyError(key);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexports.MergeStrategy = MergeStrategy;\nexports.ObjectSchema = ObjectSchema;\nexports.ValidationStrategy = ValidationStrategy;\n"
        }
    ]
}