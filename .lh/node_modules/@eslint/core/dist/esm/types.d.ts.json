{
    "sourceFile": "node_modules/@eslint/core/dist/esm/types.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891758106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Shared types for ESLint Core.\n */\nimport { JSONSchema4 } from \"json-schema\";\n/**\n * Represents an error inside of a file.\n */\nexport interface FileError {\n    message: string;\n    line: number;\n    column: number;\n    endLine?: number;\n    endColumn?: number;\n}\n/**\n * Represents a problem found in a file.\n */\nexport interface FileProblem {\n    ruleId: string | null;\n    message: string;\n    loc: SourceLocation;\n}\n/**\n * Represents the start and end coordinates of a node inside the source.\n */\nexport interface SourceLocation {\n    start: Position;\n    end: Position;\n}\n/**\n * Represents the start and end coordinates of a node inside the source with an offset.\n */\nexport interface SourceLocationWithOffset {\n    start: PositionWithOffset;\n    end: PositionWithOffset;\n}\n/**\n * Represents a location coordinate inside the source. ESLint-style formats\n * have just `line` and `column` while others may have `offset` as well.\n */\nexport interface Position {\n    line: number;\n    column: number;\n}\n/**\n * Represents a location coordinate inside the source with an offset.\n */\nexport interface PositionWithOffset extends Position {\n    offset: number;\n}\n/**\n * Represents a range of characters in the source.\n */\nexport type SourceRange = [number, number];\n/**\n * What the rule is responsible for finding:\n * - `problem` means the rule has noticed a potential error.\n * - `suggestion` means the rule suggests an alternate or better approach.\n * - `layout` means the rule is looking at spacing, indentation, etc.\n */\nexport type RuleType = \"problem\" | \"suggestion\" | \"layout\";\n/**\n * The type of fix the rule can provide:\n * - `code` means the rule can fix syntax.\n * - `whitespace` means the rule can fix spacing and indentation.\n */\nexport type RuleFixType = \"code\" | \"whitespace\";\n/**\n * An object containing visitor information for a rule. Each method is either the\n * name of a node type or a selector, or is a method that will be called at specific\n * times during the traversal.\n */\nexport type RuleVisitor = Record<string, ((...args: any[]) => void) | undefined>;\n/**\n * Rule meta information used for documentation.\n */\nexport interface RulesMetaDocs {\n    /**\n     * A short description of the rule.\n     */\n    description?: string | undefined;\n    /**\n     * The URL to the documentation for the rule.\n     */\n    url?: string | undefined;\n    /**\n     * The category the rule falls under.\n     * @deprecated No longer used.\n     */\n    category?: string | undefined;\n    /**\n     * Indicates if the rule is generally recommended for all users.\n     */\n    recommended?: boolean | undefined;\n    /**\n     * Indicates if the rule is frozen (no longer accepting feature requests).\n     */\n    frozen?: boolean | undefined;\n}\n/**\n * Meta information about a rule.\n */\nexport interface RulesMeta<MessageIds extends string = string, ExtRuleDocs = unknown> {\n    /**\n     * Properties that are used when documenting the rule.\n     */\n    docs?: (RulesMetaDocs & ExtRuleDocs) | undefined;\n    /**\n     * The type of rule.\n     */\n    type?: RuleType | undefined;\n    /**\n     * The schema for the rule options. Required if the rule has options.\n     */\n    schema?: JSONSchema4 | JSONSchema4[] | false | undefined;\n    /** Any default options to be recursively merged on top of any user-provided options. */\n    defaultOptions?: unknown[];\n    /**\n     * The messages that the rule can report.\n     */\n    messages?: Record<MessageIds, string>;\n    /**\n     * Indicates whether the rule has been deprecated or provides additional metadata about the deprecation. Omit if not deprecated.\n     */\n    deprecated?: boolean | DeprecatedInfo | undefined;\n    /**\n     * @deprecated Use deprecated.replacedBy instead.\n     * The name of the rule(s) this rule was replaced by, if it was deprecated.\n     */\n    replacedBy?: readonly string[] | undefined;\n    /**\n     * Indicates if the rule is fixable, and if so, what type of fix it provides.\n     */\n    fixable?: RuleFixType | undefined;\n    /**\n     * Indicates if the rule may provide suggestions.\n     */\n    hasSuggestions?: boolean | undefined;\n    /**\n     * The language the rule is intended to lint.\n     */\n    language?: string;\n    /**\n     * The dialects of `language` that the rule is intended to lint.\n     */\n    dialects?: string[];\n}\n/**\n * Provides additional metadata about a deprecation.\n */\nexport interface DeprecatedInfo {\n    /**\n     * General message presented to the user, e.g. for the key rule why the rule\n     * is deprecated or for info how to replace the rule.\n     */\n    message?: string;\n    /**\n     * URL to more information about this deprecation in general.\n     */\n    url?: string;\n    /**\n     * An empty array explicitly states that there is no replacement.\n     */\n    replacedBy?: ReplacedByInfo[];\n    /**\n     * The package version since when the rule is deprecated (should use full\n     * semver without a leading \"v\").\n     */\n    deprecatedSince?: string;\n    /**\n     * The estimated version when the rule is removed (probably the next major\n     * version). null means the rule is \"frozen\" (will be available but will not\n     * be changed).\n     */\n    availableUntil?: string | null;\n}\n/**\n * Provides metadata about a replacement\n */\nexport interface ReplacedByInfo {\n    /**\n     * General message presented to the user, e.g. how to replace the rule\n     */\n    message?: string;\n    /**\n     * URL to more information about this replacement in general\n     */\n    url?: string;\n    /**\n     * Name should be \"eslint\" if the replacement is an ESLint core rule. Omit\n     * the property if the replacement is in the same plugin.\n     */\n    plugin?: ExternalSpecifier;\n    /**\n     * Name and documentation of the replacement rule\n     */\n    rule?: ExternalSpecifier;\n}\n/**\n * Specifies the name and url of an external resource. At least one property\n * should be set.\n */\nexport interface ExternalSpecifier {\n    /**\n     * Name of the referenced plugin / rule.\n     */\n    name?: string;\n    /**\n     * URL pointing to documentation for the plugin / rule.\n     */\n    url?: string;\n}\n/**\n * Generic type for `RuleContext`.\n */\nexport interface RuleContextTypeOptions {\n    LangOptions: LanguageOptions;\n    Code: SourceCode;\n    RuleOptions: unknown[];\n    Node: unknown;\n    MessageIds: string;\n}\n/**\n * Represents the context object that is passed to a rule. This object contains\n * information about the current state of the linting process and is the rule's\n * view into the outside world.\n */\nexport interface RuleContext<Options extends RuleContextTypeOptions = RuleContextTypeOptions> {\n    /**\n     * The current working directory for the session.\n     */\n    cwd: string;\n    /**\n     * Returns the current working directory for the session.\n     * @deprecated Use `cwd` instead.\n     */\n    getCwd(): string;\n    /**\n     * The filename of the file being linted.\n     */\n    filename: string;\n    /**\n     * Returns the filename of the file being linted.\n     * @deprecated Use `filename` instead.\n     */\n    getFilename(): string;\n    /**\n     * The physical filename of the file being linted.\n     */\n    physicalFilename: string;\n    /**\n     * Returns the physical filename of the file being linted.\n     * @deprecated Use `physicalFilename` instead.\n     */\n    getPhysicalFilename(): string;\n    /**\n     * The source code object that the rule is running on.\n     */\n    sourceCode: Options[\"Code\"];\n    /**\n     * Returns the source code object that the rule is running on.\n     * @deprecated Use `sourceCode` instead.\n     */\n    getSourceCode(): Options[\"Code\"];\n    /**\n     * Shared settings for the configuration.\n     */\n    settings: SettingsConfig;\n    /**\n     * Parser-specific options for the configuration.\n     * @deprecated Use `languageOptions.parserOptions` instead.\n     */\n    parserOptions: Record<string, unknown>;\n    /**\n     * The language options for the configuration.\n     */\n    languageOptions: Options[\"LangOptions\"];\n    /**\n     * The CommonJS path to the parser used while parsing this file.\n     * @deprecated No longer used.\n     */\n    parserPath: string | undefined;\n    /**\n     * The rule ID.\n     */\n    id: string;\n    /**\n     * The rule's configured options.\n     */\n    options: Options[\"RuleOptions\"];\n    /**\n     * The report function that the rule should use to report problems.\n     * @param violation The violation to report.\n     */\n    report(violation: ViolationReport<Options[\"Node\"], Options[\"MessageIds\"]>): void;\n}\n/**\n * Manager of text edits for a rule fix.\n */\nexport interface RuleTextEditor<EditableSyntaxElement = unknown> {\n    /**\n     * Inserts text after the specified node or token.\n     * @param syntaxElement The node or token to insert after.\n     * @param text The edit to insert after the node or token.\n     */\n    insertTextAfter(syntaxElement: EditableSyntaxElement, text: string): RuleTextEdit;\n    /**\n     * Inserts text after the specified range.\n     * @param range The range to insert after.\n     * @param text The edit to insert after the range.\n     */\n    insertTextAfterRange(range: SourceRange, text: string): RuleTextEdit;\n    /**\n     * Inserts text before the specified node or token.\n     * @param syntaxElement A syntax element with location information to insert before.\n     * @param text The edit to insert before the node or token.\n     */\n    insertTextBefore(syntaxElement: EditableSyntaxElement, text: string): RuleTextEdit;\n    /**\n     * Inserts text before the specified range.\n     * @param range The range to insert before.\n     * @param text The edit to insert before the range.\n     */\n    insertTextBeforeRange(range: SourceRange, text: string): RuleTextEdit;\n    /**\n     * Removes the specified node or token.\n     * @param syntaxElement A syntax element with location information to remove.\n     * @returns The edit to remove the node or token.\n     */\n    remove(syntaxElement: EditableSyntaxElement): RuleTextEdit;\n    /**\n     * Removes the specified range.\n     * @param range The range to remove.\n     * @returns The edit to remove the range.\n     */\n    removeRange(range: SourceRange): RuleTextEdit;\n    /**\n     * Replaces the specified node or token with the given text.\n     * @param syntaxElement A syntax element with location information to replace.\n     * @param text The text to replace the node or token with.\n     * @returns The edit to replace the node or token.\n     */\n    replaceText(syntaxElement: EditableSyntaxElement, text: string): RuleTextEdit;\n    /**\n     * Replaces the specified range with the given text.\n     * @param range The range to replace.\n     * @param text The text to replace the range with.\n     * @returns The edit to replace the range.\n     */\n    replaceTextRange(range: SourceRange, text: string): RuleTextEdit;\n}\n/**\n * Represents a fix for a rule violation implemented as a text edit.\n */\nexport interface RuleTextEdit {\n    /**\n     * The range to replace.\n     */\n    range: SourceRange;\n    /**\n     * The text to insert.\n     */\n    text: string;\n}\n/**\n * Fixes a violation.\n * @param fixer The text editor to apply the fix.\n * @returns The fix(es) for the violation.\n */\ntype RuleFixer = (fixer: RuleTextEditor) => RuleTextEdit | Iterable<RuleTextEdit> | null;\ninterface ViolationReportBase {\n    /**\n     * The type of node that the violation is for.\n     * @deprecated May be removed in the future.\n     */\n    nodeType?: string | undefined;\n    /**\n     * The data to insert into the message.\n     */\n    data?: Record<string, string> | undefined;\n    /**\n     * The fix to be applied for the violation.\n     */\n    fix?: RuleFixer | null | undefined;\n    /**\n     * An array of suggested fixes for the problem. These fixes may change the\n     * behavior of the code, so they are not applied automatically.\n     */\n    suggest?: SuggestedEdit[] | null | undefined;\n}\ntype ViolationMessage<MessageIds = string> = {\n    message: string;\n} | {\n    messageId: MessageIds;\n};\ntype ViolationLocation<Node> = {\n    loc: SourceLocation | Position;\n} | {\n    node: Node;\n};\nexport type ViolationReport<Node = unknown, MessageIds = string> = ViolationReportBase & ViolationMessage<MessageIds> & ViolationLocation<Node>;\ninterface SuggestedEditBase {\n    /**\n     * The data to insert into the message.\n     */\n    data?: Record<string, string> | undefined;\n    /**\n     * The fix to be applied for the suggestion.\n     */\n    fix?: RuleFixer | null | undefined;\n}\ntype SuggestionMessage = {\n    desc: string;\n} | {\n    messageId: string;\n};\n/**\n * A suggested edit for a rule violation.\n */\nexport type SuggestedEdit = SuggestedEditBase & SuggestionMessage;\n/**\n * Generic options for the `RuleDefinition` type.\n */\nexport interface RuleDefinitionTypeOptions {\n    LangOptions: LanguageOptions;\n    Code: SourceCode;\n    RuleOptions: unknown[];\n    Visitor: RuleVisitor;\n    Node: unknown;\n    MessageIds: string;\n    ExtRuleDocs: unknown;\n}\n/**\n * The definition of an ESLint rule.\n */\nexport interface RuleDefinition<Options extends RuleDefinitionTypeOptions = RuleDefinitionTypeOptions> {\n    /**\n     * The meta information for the rule.\n     */\n    meta?: RulesMeta<Options[\"MessageIds\"], Options[\"ExtRuleDocs\"]>;\n    /**\n     * Creates the visitor that ESLint uses to apply the rule during traversal.\n     * @param context The rule context.\n     * @returns The rule visitor.\n     */\n    create(context: RuleContext<{\n        LangOptions: Options[\"LangOptions\"];\n        Code: Options[\"Code\"];\n        RuleOptions: Options[\"RuleOptions\"];\n        Node: Options[\"Node\"];\n        MessageIds: Options[\"MessageIds\"];\n    }>): Options[\"Visitor\"];\n}\n/**\n * The human readable severity level used in a configuration.\n */\nexport type SeverityName = \"off\" | \"warn\" | \"error\";\n/**\n * The numeric severity level for a rule.\n *\n * - `0` means off.\n * - `1` means warn.\n * - `2` means error.\n */\nexport type SeverityLevel = 0 | 1 | 2;\n/**\n * The severity of a rule in a configuration.\n */\nexport type Severity = SeverityName | SeverityLevel;\n/**\n * Represents the configuration options for the core linter.\n */\nexport interface LinterOptionsConfig {\n    /**\n     * Indicates whether or not inline configuration is evaluated.\n     */\n    noInlineConfig?: boolean;\n    /**\n     * Indicates what to do when an unused disable directive is found.\n     */\n    reportUnusedDisableDirectives?: boolean | Severity;\n}\n/**\n * Shared settings that are accessible from within plugins.\n */\nexport type SettingsConfig = Record<string, unknown>;\n/**\n * The configuration for a rule.\n */\nexport type RuleConfig = Severity | [Severity, ...unknown[]];\n/**\n * A collection of rules and their configurations.\n */\nexport type RulesConfig = Record<string, RuleConfig>;\n/**\n * Generic options for the `Language` type.\n */\nexport interface LanguageTypeOptions {\n    LangOptions: LanguageOptions;\n    Code: SourceCode;\n    RootNode: unknown;\n    Node: unknown;\n}\n/**\n * Represents a plugin language.\n */\nexport interface Language<Options extends LanguageTypeOptions = {\n    LangOptions: LanguageOptions;\n    Code: SourceCode;\n    RootNode: unknown;\n    Node: unknown;\n}> {\n    /**\n     * Indicates how ESLint should read the file.\n     */\n    fileType: \"text\";\n    /**\n     * First line number returned from the parser (text mode only).\n     */\n    lineStart: 0 | 1;\n    /**\n     * First column number returned from the parser (text mode only).\n     */\n    columnStart: 0 | 1;\n    /**\n     * The property to read the node type from. Used in selector querying.\n     */\n    nodeTypeKey: string;\n    /**\n     * The traversal path that tools should take when evaluating the AST\n     */\n    visitorKeys?: Record<string, string[]>;\n    /**\n     * Default language options. User-defined options are merged with this object.\n     */\n    defaultLanguageOptions?: LanguageOptions;\n    /**\n     * Validates languageOptions for this language.\n     */\n    validateLanguageOptions(languageOptions: Options[\"LangOptions\"]): void;\n    /**\n     * Normalizes languageOptions for this language.\n     */\n    normalizeLanguageOptions?(languageOptions: Options[\"LangOptions\"]): Options[\"LangOptions\"];\n    /**\n     * Helper for esquery that allows languages to match nodes against\n     * class. esquery currently has classes like `function` that will\n     * match all the various function nodes. This method allows languages\n     * to implement similar shorthands.\n     */\n    matchesSelectorClass?(className: string, node: Options[\"Node\"], ancestry: Options[\"Node\"][]): boolean;\n    /**\n     * Parses the given file input into its component parts. This file should not\n     * throws errors for parsing errors but rather should return any parsing\n     * errors as parse of the ParseResult object.\n     */\n    parse(file: File, context: LanguageContext<Options[\"LangOptions\"]>): ParseResult<Options[\"RootNode\"]>;\n    /**\n     * Creates SourceCode object that ESLint uses to work with a file.\n     */\n    createSourceCode(file: File, input: OkParseResult<Options[\"RootNode\"]>, context: LanguageContext<Options[\"LangOptions\"]>): Options[\"Code\"];\n}\n/**\n * Plugin-defined options for the language.\n */\nexport type LanguageOptions = Record<string, unknown>;\n/**\n * The context object that is passed to the language plugin methods.\n */\nexport interface LanguageContext<LangOptions = LanguageOptions> {\n    languageOptions: LangOptions;\n}\n/**\n * Represents a file read by ESLint.\n */\nexport interface File {\n    /**\n     * The path that ESLint uses for this file. May be a virtual path\n     * if it was returned by a processor.\n     */\n    path: string;\n    /**\n     * The path to the file on disk. This always maps directly to a file\n     * regardless of whether it was returned from a processor.\n     */\n    physicalPath: string;\n    /**\n     * Indicates if the original source contained a byte-order marker.\n     * ESLint strips the BOM from the `body`, but this info is needed\n     * to correctly apply autofixing.\n     */\n    bom: boolean;\n    /**\n     * The body of the file to parse.\n     */\n    body: string | Uint8Array;\n}\n/**\n * Represents the successful result of parsing a file.\n */\nexport interface OkParseResult<RootNode = unknown> {\n    /**\n     * Indicates if the parse was successful. If true, the parse was successful\n     * and ESLint should continue on to create a SourceCode object and run rules;\n     * if false, ESLint should just report the error(s) without doing anything\n     * else.\n     */\n    ok: true;\n    /**\n     * The abstract syntax tree created by the parser. (only when ok: true)\n     */\n    ast: RootNode;\n    /**\n     * Any additional data that the parser wants to provide.\n     */\n    [key: string]: any;\n}\n/**\n * Represents the unsuccessful result of parsing a file.\n */\nexport interface NotOkParseResult {\n    /**\n     * Indicates if the parse was successful. If true, the parse was successful\n     * and ESLint should continue on to create a SourceCode object and run rules;\n     * if false, ESLint should just report the error(s) without doing anything\n     * else.\n     */\n    ok: false;\n    /**\n     * Any parsing errors, whether fatal or not. (only when ok: false)\n     */\n    errors: FileError[];\n    /**\n     * Any additional data that the parser wants to provide.\n     */\n    [key: string]: any;\n}\nexport type ParseResult<RootNode = unknown> = OkParseResult<RootNode> | NotOkParseResult;\n/**\n * Represents inline configuration found in the source code.\n */\ninterface InlineConfigElement {\n    /**\n     * The location of the inline config element.\n     */\n    loc: SourceLocation;\n    /**\n     * The interpreted configuration from the inline config element.\n     */\n    config: {\n        rules: RulesConfig;\n    };\n}\n/**\n * Generic options for the `SourceCodeBase` type.\n */\ninterface SourceCodeBaseTypeOptions {\n    LangOptions: LanguageOptions;\n    RootNode: unknown;\n    SyntaxElementWithLoc: unknown;\n    ConfigNode: unknown;\n}\n/**\n * Represents the basic interface for a source code object.\n */\ninterface SourceCodeBase<Options extends SourceCodeBaseTypeOptions = {\n    LangOptions: LanguageOptions;\n    RootNode: unknown;\n    SyntaxElementWithLoc: unknown;\n    ConfigNode: unknown;\n}> {\n    /**\n     * Root of the AST.\n     */\n    ast: Options[\"RootNode\"];\n    /**\n     * The traversal path that tools should take when evaluating the AST.\n     * When present, this overrides the `visitorKeys` on the language for\n     * just this source code object.\n     */\n    visitorKeys?: Record<string, string[]>;\n    /**\n     * Retrieves the equivalent of `loc` for a given node or token.\n     * @param syntaxElement The node or token to get the location for.\n     * @returns The location of the node or token.\n     */\n    getLoc(syntaxElement: Options[\"SyntaxElementWithLoc\"]): SourceLocation;\n    /**\n     * Retrieves the equivalent of `range` for a given node or token.\n     * @param syntaxElement The node or token to get the range for.\n     * @returns The range of the node or token.\n     */\n    getRange(syntaxElement: Options[\"SyntaxElementWithLoc\"]): SourceRange;\n    /**\n     * Traversal of AST.\n     */\n    traverse(): Iterable<TraversalStep>;\n    /**\n     * Applies language options passed in from the ESLint core.\n     */\n    applyLanguageOptions?(languageOptions: Options[\"LangOptions\"]): void;\n    /**\n     * Return all of the inline areas where ESLint should be disabled/enabled\n     * along with any problems found in evaluating the directives.\n     */\n    getDisableDirectives?(): {\n        directives: Directive[];\n        problems: FileProblem[];\n    };\n    /**\n     * Returns an array of all inline configuration nodes found in the\n     * source code.\n     */\n    getInlineConfigNodes?(): Options[\"ConfigNode\"][];\n    /**\n     * Applies configuration found inside of the source code. This method is only\n     * called when ESLint is running with inline configuration allowed.\n     */\n    applyInlineConfig?(): {\n        configs: InlineConfigElement[];\n        problems: FileProblem[];\n    };\n    /**\n     * Called by ESLint core to indicate that it has finished providing\n     * information. We now add in all the missing variables and ensure that\n     * state-changing methods cannot be called by rules.\n     * @returns {void}\n     */\n    finalize?(): void;\n}\n/**\n * Represents the source of a text file being linted.\n */\nexport interface TextSourceCode<Options extends SourceCodeBaseTypeOptions = {\n    LangOptions: LanguageOptions;\n    RootNode: unknown;\n    SyntaxElementWithLoc: unknown;\n    ConfigNode: unknown;\n}> extends SourceCodeBase<Options> {\n    /**\n     * The body of the file that you'd like rule developers to access.\n     */\n    text: string;\n}\n/**\n * Represents the source of a binary file being linted.\n */\nexport interface BinarySourceCode<Options extends SourceCodeBaseTypeOptions = {\n    LangOptions: LanguageOptions;\n    RootNode: unknown;\n    SyntaxElementWithLoc: unknown;\n    ConfigNode: unknown;\n}> extends SourceCodeBase<Options> {\n    /**\n     * The body of the file that you'd like rule developers to access.\n     */\n    body: Uint8Array;\n}\nexport type SourceCode<Options extends SourceCodeBaseTypeOptions = {\n    LangOptions: LanguageOptions;\n    RootNode: unknown;\n    SyntaxElementWithLoc: unknown;\n    ConfigNode: unknown;\n}> = TextSourceCode<Options> | BinarySourceCode<Options>;\n/**\n * Represents a traversal step visiting the AST.\n */\nexport interface VisitTraversalStep {\n    kind: 1;\n    target: unknown;\n    phase: 1 | 2;\n    args: unknown[];\n}\n/**\n * Represents a traversal step calling a function.\n */\nexport interface CallTraversalStep {\n    kind: 2;\n    target: string;\n    phase?: string;\n    args: unknown[];\n}\nexport type TraversalStep = VisitTraversalStep | CallTraversalStep;\n/**\n * The type of disable directive. This determines how ESLint will disable rules.\n */\nexport type DirectiveType = \"disable\" | \"enable\" | \"disable-line\" | \"disable-next-line\";\n/**\n * Represents a disable directive.\n */\nexport interface Directive {\n    /**\n     * The type of directive.\n     */\n    type: DirectiveType;\n    /**\n     * The node of the directive. May be in the AST or a comment/token.\n     */\n    node: unknown;\n    /**\n     * The value of the directive.\n     */\n    value: string;\n    /**\n     * The justification for the directive.\n     */\n    justification?: string;\n}\nexport {};\n"
        }
    ]
}