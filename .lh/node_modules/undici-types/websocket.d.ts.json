{
    "sourceFile": "node_modules/undici-types/websocket.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893087745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/// <reference types=\"node\" />\n\nimport type { Blob } from 'buffer'\nimport type { MessagePort } from 'worker_threads'\nimport {\n  EventInit,\n  EventListenerOptions,\n  AddEventListenerOptions,\n  EventListenerOrEventListenerObject\n} from './patch'\nimport Dispatcher from './dispatcher'\nimport { HeadersInit } from './fetch'\n\nexport type BinaryType = 'blob' | 'arraybuffer'\n\ninterface WebSocketEventMap {\n  close: CloseEvent\n  error: ErrorEvent\n  message: MessageEvent\n  open: Event\n}\n\ninterface WebSocket extends EventTarget {\n  binaryType: BinaryType\n  \n  readonly bufferedAmount: number\n  readonly extensions: string\n\n  onclose: ((this: WebSocket, ev: WebSocketEventMap['close']) => any) | null\n  onerror: ((this: WebSocket, ev: WebSocketEventMap['error']) => any) | null\n  onmessage: ((this: WebSocket, ev: WebSocketEventMap['message']) => any) | null\n  onopen: ((this: WebSocket, ev: WebSocketEventMap['open']) => any) | null\n\n  readonly protocol: string\n  readonly readyState: number\n  readonly url: string\n\n  close(code?: number, reason?: string): void\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void\n\n  readonly CLOSED: number\n  readonly CLOSING: number\n  readonly CONNECTING: number\n  readonly OPEN: number\n\n  addEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  removeEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,\n    options?: boolean | EventListenerOptions\n  ): void\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions\n  ): void\n}\n\nexport declare const WebSocket: {\n  prototype: WebSocket\n  new (url: string | URL, protocols?: string | string[] | WebSocketInit): WebSocket\n  readonly CLOSED: number\n  readonly CLOSING: number\n  readonly CONNECTING: number\n  readonly OPEN: number\n}\n\ninterface CloseEventInit extends EventInit {\n  code?: number\n  reason?: string\n  wasClean?: boolean\n}\n\ninterface CloseEvent extends Event {\n  readonly code: number\n  readonly reason: string\n  readonly wasClean: boolean\n}\n\nexport declare const CloseEvent: {\n  prototype: CloseEvent\n  new (type: string, eventInitDict?: CloseEventInit): CloseEvent\n}\n\ninterface MessageEventInit<T = any> extends EventInit {\n  data?: T\n  lastEventId?: string\n  origin?: string\n  ports?: (typeof MessagePort)[]\n  source?: typeof MessagePort | null\n}\n\ninterface MessageEvent<T = any> extends Event {\n  readonly data: T\n  readonly lastEventId: string\n  readonly origin: string\n  readonly ports: ReadonlyArray<typeof MessagePort>\n  readonly source: typeof MessagePort | null\n  initMessageEvent(\n    type: string,\n    bubbles?: boolean,\n    cancelable?: boolean,\n    data?: any,\n    origin?: string,\n    lastEventId?: string,\n    source?: typeof MessagePort | null,\n    ports?: (typeof MessagePort)[]\n  ): void;\n}\n\nexport declare const MessageEvent: {\n  prototype: MessageEvent\n  new<T>(type: string, eventInitDict?: MessageEventInit<T>): MessageEvent<T>\n}\n\ninterface ErrorEventInit extends EventInit {\n  message?: string\n  filename?: string\n  lineno?: number\n  colno?: number\n  error?: any\n}\n\ninterface ErrorEvent extends Event {\n  readonly message: string\n  readonly filename: string\n  readonly lineno: number\n  readonly colno: number\n  readonly error: any\n}\n\nexport declare const ErrorEvent: {\n  prototype: ErrorEvent\n  new (type: string, eventInitDict?: ErrorEventInit): ErrorEvent\n}\n\ninterface WebSocketInit {\n  protocols?: string | string[],\n  dispatcher?: Dispatcher,\n  headers?: HeadersInit\n}\n"
        }
    ]
}