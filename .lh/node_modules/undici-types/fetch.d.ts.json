{
    "sourceFile": "node_modules/undici-types/fetch.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893082840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// based on https://github.com/Ethan-Arrowood/undici-fetch/blob/249269714db874351589d2d364a0645d5160ae71/index.d.ts (MIT license)\n// and https://github.com/node-fetch/node-fetch/blob/914ce6be5ec67a8bab63d68510aabf07cb818b6d/index.d.ts (MIT license)\n/// <reference types=\"node\" />\n\nimport { Blob } from 'buffer'\nimport { URL, URLSearchParams } from 'url'\nimport { ReadableStream } from 'stream/web'\nimport { FormData } from './formdata'\n\nimport Dispatcher from './dispatcher'\n\nexport type RequestInfo = string | URL | Request\n\nexport declare function fetch (\n  input: RequestInfo,\n  init?: RequestInit\n): Promise<Response>\n\nexport type BodyInit =\n  | ArrayBuffer\n  | AsyncIterable<Uint8Array>\n  | Blob\n  | FormData\n  | Iterable<Uint8Array>\n  | NodeJS.ArrayBufferView\n  | URLSearchParams\n  | null\n  | string\n\nexport class BodyMixin {\n  readonly body: ReadableStream | null\n  readonly bodyUsed: boolean\n\n  readonly arrayBuffer: () => Promise<ArrayBuffer>\n  readonly blob: () => Promise<Blob>\n  /**\n   * @deprecated This method is not recommended for parsing multipart/form-data bodies in server environments.\n   * It is recommended to use a library such as [@fastify/busboy](https://www.npmjs.com/package/@fastify/busboy) as follows:\n   * \n   * @example\n   * ```js\n   * import { Busboy } from '@fastify/busboy'\n   * import { Readable } from 'node:stream'\n   * \n   * const response = await fetch('...')\n   * const busboy = new Busboy({ headers: { 'content-type': response.headers.get('content-type') } })\n   * \n   * // handle events emitted from `busboy`\n   * \n   * Readable.fromWeb(response.body).pipe(busboy)\n   * ```\n   */\n  readonly formData: () => Promise<FormData>\n  readonly json: () => Promise<unknown>\n  readonly text: () => Promise<string>\n}\n\nexport interface SpecIterator<T, TReturn = any, TNext = undefined> {\n  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;\n}\n\nexport interface SpecIterableIterator<T> extends SpecIterator<T> {\n  [Symbol.iterator](): SpecIterableIterator<T>;\n}\n\nexport interface SpecIterable<T> {\n  [Symbol.iterator](): SpecIterator<T>;\n}\n\nexport type HeadersInit = string[][] | Record<string, string | ReadonlyArray<string>> | Headers\n\nexport declare class Headers implements SpecIterable<[string, string]> {\n  constructor (init?: HeadersInit)\n  readonly append: (name: string, value: string) => void\n  readonly delete: (name: string) => void\n  readonly get: (name: string) => string | null\n  readonly has: (name: string) => boolean\n  readonly set: (name: string, value: string) => void\n  readonly getSetCookie: () => string[]\n  readonly forEach: (\n    callbackfn: (value: string, key: string, iterable: Headers) => void,\n    thisArg?: unknown\n  ) => void\n\n  readonly keys: () => SpecIterableIterator<string>\n  readonly values: () => SpecIterableIterator<string>\n  readonly entries: () => SpecIterableIterator<[string, string]>\n  readonly [Symbol.iterator]: () => SpecIterableIterator<[string, string]>\n}\n\nexport type RequestCache =\n  | 'default'\n  | 'force-cache'\n  | 'no-cache'\n  | 'no-store'\n  | 'only-if-cached'\n  | 'reload'\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\ntype RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'worker'\n  | 'xslt'\n\nexport interface RequestInit {\n  method?: string\n  keepalive?: boolean\n  headers?: HeadersInit\n  body?: BodyInit | null\n  redirect?: RequestRedirect\n  integrity?: string\n  signal?: AbortSignal | null\n  credentials?: RequestCredentials\n  mode?: RequestMode\n  referrer?: string\n  referrerPolicy?: ReferrerPolicy\n  window?: null\n  dispatcher?: Dispatcher\n  duplex?: RequestDuplex\n}\n\nexport type ReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url';\n\nexport type RequestMode = 'cors' | 'navigate' | 'no-cors' | 'same-origin'\n\nexport type RequestRedirect = 'error' | 'follow' | 'manual'\n\nexport type RequestDuplex = 'half'\n\nexport declare class Request extends BodyMixin {\n  constructor (input: RequestInfo, init?: RequestInit)\n\n  readonly cache: RequestCache\n  readonly credentials: RequestCredentials\n  readonly destination: RequestDestination\n  readonly headers: Headers\n  readonly integrity: string\n  readonly method: string\n  readonly mode: RequestMode\n  readonly redirect: RequestRedirect\n  readonly referrer: string\n  readonly referrerPolicy: ReferrerPolicy\n  readonly url: string\n\n  readonly keepalive: boolean\n  readonly signal: AbortSignal\n  readonly duplex: RequestDuplex\n\n  readonly clone: () => Request\n}\n\nexport interface ResponseInit {\n  readonly status?: number\n  readonly statusText?: string\n  readonly headers?: HeadersInit\n}\n\nexport type ResponseType =\n  | 'basic'\n  | 'cors'\n  | 'default'\n  | 'error'\n  | 'opaque'\n  | 'opaqueredirect'\n\nexport type ResponseRedirectStatus = 301 | 302 | 303 | 307 | 308\n\nexport declare class Response extends BodyMixin {\n  constructor (body?: BodyInit, init?: ResponseInit)\n\n  readonly headers: Headers\n  readonly ok: boolean\n  readonly status: number\n  readonly statusText: string\n  readonly type: ResponseType\n  readonly url: string\n  readonly redirected: boolean\n\n  readonly clone: () => Response\n\n  static error (): Response\n  static json(data: any, init?: ResponseInit): Response\n  static redirect (url: string | URL, status: ResponseRedirectStatus): Response\n}\n"
        }
    ]
}