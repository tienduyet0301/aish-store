{
    "sourceFile": "node_modules/undici-types/mock-interceptor.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893086480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { IncomingHttpHeaders } from './header'\nimport Dispatcher from './dispatcher';\nimport { BodyInit, Headers } from './fetch'\n\nexport {\n  Interceptable,\n  MockInterceptor,\n  MockScope\n}\n\n/** The scope associated with a mock dispatch. */\ndeclare class MockScope<TData extends object = object> {\n  constructor(mockDispatch: MockInterceptor.MockDispatch<TData>);\n  /** Delay a reply by a set amount of time in ms. */\n  delay(waitInMs: number): MockScope<TData>;\n  /** Persist the defined mock data for the associated reply. It will return the defined mock data indefinitely. */\n  persist(): MockScope<TData>;\n  /** Define a reply for a set amount of matching requests. */\n  times(repeatTimes: number): MockScope<TData>;\n}\n\n/** The interceptor for a Mock. */\ndeclare class MockInterceptor {\n  constructor(options: MockInterceptor.Options, mockDispatches: MockInterceptor.MockDispatch[]);\n  /** Mock an undici request with the defined reply. */\n  reply<TData extends object = object>(replyOptionsCallback: MockInterceptor.MockReplyOptionsCallback<TData>): MockScope<TData>;\n  reply<TData extends object = object>(\n    statusCode: number,\n    data?: TData | Buffer | string | MockInterceptor.MockResponseDataHandler<TData>,\n    responseOptions?: MockInterceptor.MockResponseOptions\n  ): MockScope<TData>;\n  /** Mock an undici request by throwing the defined reply error. */\n  replyWithError<TError extends Error = Error>(error: TError): MockScope;\n  /** Set default reply headers on the interceptor for subsequent mocked replies. */\n  defaultReplyHeaders(headers: IncomingHttpHeaders): MockInterceptor;\n  /** Set default reply trailers on the interceptor for subsequent mocked replies. */\n  defaultReplyTrailers(trailers: Record<string, string>): MockInterceptor;\n  /** Set automatically calculated content-length header on subsequent mocked replies. */\n  replyContentLength(): MockInterceptor;\n}\n\ndeclare namespace MockInterceptor {\n  /** MockInterceptor options. */\n  export interface Options {\n    /** Path to intercept on. */\n    path: string | RegExp | ((path: string) => boolean);\n    /** Method to intercept on. Defaults to GET. */\n    method?: string | RegExp | ((method: string) => boolean);\n    /** Body to intercept on. */\n    body?: string | RegExp | ((body: string) => boolean);\n    /** Headers to intercept on. */\n    headers?: Record<string, string | RegExp | ((body: string) => boolean)> | ((headers: Record<string, string>) => boolean);\n    /** Query params to intercept on */\n    query?: Record<string, any>;\n  }\n  export interface MockDispatch<TData extends object = object, TError extends Error = Error> extends Options {\n    times: number | null;\n    persist: boolean;\n    consumed: boolean;\n    data: MockDispatchData<TData, TError>;\n  }\n  export interface MockDispatchData<TData extends object = object, TError extends Error = Error> extends MockResponseOptions {\n    error: TError | null;\n    statusCode?: number;\n    data?: TData | string;\n  }\n  export interface MockResponseOptions {\n    headers?: IncomingHttpHeaders;\n    trailers?: Record<string, string>;\n  }\n\n  export interface MockResponseCallbackOptions {\n    path: string;\n    method: string;\n    headers?: Headers | Record<string, string>;\n    origin?: string;\n    body?: BodyInit | Dispatcher.DispatchOptions['body'] | null;\n    maxRedirections?: number;\n  }\n\n  export type MockResponseDataHandler<TData extends object = object> = (\n    opts: MockResponseCallbackOptions\n  ) => TData | Buffer | string;\n\n  export type MockReplyOptionsCallback<TData extends object = object> = (\n    opts: MockResponseCallbackOptions\n  ) => { statusCode: number, data?: TData | Buffer | string, responseOptions?: MockResponseOptions }\n}\n\ninterface Interceptable extends Dispatcher {\n  /** Intercepts any matching requests that use the same origin as this mock client. */\n  intercept(options: MockInterceptor.Options): MockInterceptor;\n}\n"
        }
    ]
}