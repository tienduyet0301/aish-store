{
    "sourceFile": "node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892284446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\n/* eslint-disable jsdoc/valid-types -- doesn't allow `readonly`.\n   TODO: remove eslint-disable when https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/164 is fixed\n*/\n/**\n * @typedef {{ readonly [type: string]: ReadonlyArray<string> }} VisitorKeys\n */\n/* eslint-enable jsdoc/valid-types -- doesn't allow `readonly string[]`. TODO: check why */\n\n/**\n * @type {VisitorKeys}\n */\nconst KEYS = {\n    ArrayExpression: [\n        \"elements\"\n    ],\n    ArrayPattern: [\n        \"elements\"\n    ],\n    ArrowFunctionExpression: [\n        \"params\",\n        \"body\"\n    ],\n    AssignmentExpression: [\n        \"left\",\n        \"right\"\n    ],\n    AssignmentPattern: [\n        \"left\",\n        \"right\"\n    ],\n    AwaitExpression: [\n        \"argument\"\n    ],\n    BinaryExpression: [\n        \"left\",\n        \"right\"\n    ],\n    BlockStatement: [\n        \"body\"\n    ],\n    BreakStatement: [\n        \"label\"\n    ],\n    CallExpression: [\n        \"callee\",\n        \"arguments\"\n    ],\n    CatchClause: [\n        \"param\",\n        \"body\"\n    ],\n    ChainExpression: [\n        \"expression\"\n    ],\n    ClassBody: [\n        \"body\"\n    ],\n    ClassDeclaration: [\n        \"id\",\n        \"superClass\",\n        \"body\"\n    ],\n    ClassExpression: [\n        \"id\",\n        \"superClass\",\n        \"body\"\n    ],\n    ConditionalExpression: [\n        \"test\",\n        \"consequent\",\n        \"alternate\"\n    ],\n    ContinueStatement: [\n        \"label\"\n    ],\n    DebuggerStatement: [],\n    DoWhileStatement: [\n        \"body\",\n        \"test\"\n    ],\n    EmptyStatement: [],\n    ExperimentalRestProperty: [\n        \"argument\"\n    ],\n    ExperimentalSpreadProperty: [\n        \"argument\"\n    ],\n    ExportAllDeclaration: [\n        \"exported\",\n        \"source\",\n        \"attributes\"\n    ],\n    ExportDefaultDeclaration: [\n        \"declaration\"\n    ],\n    ExportNamedDeclaration: [\n        \"declaration\",\n        \"specifiers\",\n        \"source\",\n        \"attributes\"\n    ],\n    ExportSpecifier: [\n        \"exported\",\n        \"local\"\n    ],\n    ExpressionStatement: [\n        \"expression\"\n    ],\n    ForInStatement: [\n        \"left\",\n        \"right\",\n        \"body\"\n    ],\n    ForOfStatement: [\n        \"left\",\n        \"right\",\n        \"body\"\n    ],\n    ForStatement: [\n        \"init\",\n        \"test\",\n        \"update\",\n        \"body\"\n    ],\n    FunctionDeclaration: [\n        \"id\",\n        \"params\",\n        \"body\"\n    ],\n    FunctionExpression: [\n        \"id\",\n        \"params\",\n        \"body\"\n    ],\n    Identifier: [],\n    IfStatement: [\n        \"test\",\n        \"consequent\",\n        \"alternate\"\n    ],\n    ImportAttribute: [\n        \"key\",\n        \"value\"\n    ],\n    ImportDeclaration: [\n        \"specifiers\",\n        \"source\",\n        \"attributes\"\n    ],\n    ImportDefaultSpecifier: [\n        \"local\"\n    ],\n    ImportExpression: [\n        \"source\",\n        \"options\"\n    ],\n    ImportNamespaceSpecifier: [\n        \"local\"\n    ],\n    ImportSpecifier: [\n        \"imported\",\n        \"local\"\n    ],\n    JSXAttribute: [\n        \"name\",\n        \"value\"\n    ],\n    JSXClosingElement: [\n        \"name\"\n    ],\n    JSXClosingFragment: [],\n    JSXElement: [\n        \"openingElement\",\n        \"children\",\n        \"closingElement\"\n    ],\n    JSXEmptyExpression: [],\n    JSXExpressionContainer: [\n        \"expression\"\n    ],\n    JSXFragment: [\n        \"openingFragment\",\n        \"children\",\n        \"closingFragment\"\n    ],\n    JSXIdentifier: [],\n    JSXMemberExpression: [\n        \"object\",\n        \"property\"\n    ],\n    JSXNamespacedName: [\n        \"namespace\",\n        \"name\"\n    ],\n    JSXOpeningElement: [\n        \"name\",\n        \"attributes\"\n    ],\n    JSXOpeningFragment: [],\n    JSXSpreadAttribute: [\n        \"argument\"\n    ],\n    JSXSpreadChild: [\n        \"expression\"\n    ],\n    JSXText: [],\n    LabeledStatement: [\n        \"label\",\n        \"body\"\n    ],\n    Literal: [],\n    LogicalExpression: [\n        \"left\",\n        \"right\"\n    ],\n    MemberExpression: [\n        \"object\",\n        \"property\"\n    ],\n    MetaProperty: [\n        \"meta\",\n        \"property\"\n    ],\n    MethodDefinition: [\n        \"key\",\n        \"value\"\n    ],\n    NewExpression: [\n        \"callee\",\n        \"arguments\"\n    ],\n    ObjectExpression: [\n        \"properties\"\n    ],\n    ObjectPattern: [\n        \"properties\"\n    ],\n    PrivateIdentifier: [],\n    Program: [\n        \"body\"\n    ],\n    Property: [\n        \"key\",\n        \"value\"\n    ],\n    PropertyDefinition: [\n        \"key\",\n        \"value\"\n    ],\n    RestElement: [\n        \"argument\"\n    ],\n    ReturnStatement: [\n        \"argument\"\n    ],\n    SequenceExpression: [\n        \"expressions\"\n    ],\n    SpreadElement: [\n        \"argument\"\n    ],\n    StaticBlock: [\n        \"body\"\n    ],\n    Super: [],\n    SwitchCase: [\n        \"test\",\n        \"consequent\"\n    ],\n    SwitchStatement: [\n        \"discriminant\",\n        \"cases\"\n    ],\n    TaggedTemplateExpression: [\n        \"tag\",\n        \"quasi\"\n    ],\n    TemplateElement: [],\n    TemplateLiteral: [\n        \"quasis\",\n        \"expressions\"\n    ],\n    ThisExpression: [],\n    ThrowStatement: [\n        \"argument\"\n    ],\n    TryStatement: [\n        \"block\",\n        \"handler\",\n        \"finalizer\"\n    ],\n    UnaryExpression: [\n        \"argument\"\n    ],\n    UpdateExpression: [\n        \"argument\"\n    ],\n    VariableDeclaration: [\n        \"declarations\"\n    ],\n    VariableDeclarator: [\n        \"id\",\n        \"init\"\n    ],\n    WhileStatement: [\n        \"test\",\n        \"body\"\n    ],\n    WithStatement: [\n        \"object\",\n        \"body\"\n    ],\n    YieldExpression: [\n        \"argument\"\n    ]\n};\n\n// Types.\nconst NODE_TYPES = Object.keys(KEYS);\n\n// Freeze the keys.\nfor (const type of NODE_TYPES) {\n    Object.freeze(KEYS[type]);\n}\nObject.freeze(KEYS);\n\n/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n\n/**\n * @typedef {import('./visitor-keys.js').VisitorKeys} VisitorKeys\n */\n\n// List to ignore keys.\nconst KEY_BLACKLIST = new Set([\n    \"parent\",\n    \"leadingComments\",\n    \"trailingComments\"\n]);\n\n/**\n * Check whether a given key should be used or not.\n * @param {string} key The key to check.\n * @returns {boolean} `true` if the key should be used.\n */\nfunction filterKey(key) {\n    return !KEY_BLACKLIST.has(key) && key[0] !== \"_\";\n}\n\n\n/* eslint-disable jsdoc/valid-types -- doesn't allow `readonly`.\n   TODO: remove eslint-disable when https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/164 is fixed\n*/\n/**\n * Get visitor keys of a given node.\n * @param {Object} node The AST node to get keys.\n * @returns {readonly string[]} Visitor keys of the node.\n */\nfunction getKeys(node) {\n    return Object.keys(node).filter(filterKey);\n}\n/* eslint-enable jsdoc/valid-types -- doesn't allow `readonly` */\n\n/**\n * Make the union set with `KEYS` and given keys.\n * @param {VisitorKeys} additionalKeys The additional keys.\n * @returns {VisitorKeys} The union set.\n */\nfunction unionWith(additionalKeys) {\n    const retv = /** @type {{ [type: string]: ReadonlyArray<string> }} */\n        (Object.assign({}, KEYS));\n\n    for (const type of Object.keys(additionalKeys)) {\n        if (Object.hasOwn(retv, type)) {\n            const keys = new Set(additionalKeys[type]);\n\n            for (const key of retv[type]) {\n                keys.add(key);\n            }\n\n            retv[type] = Object.freeze(Array.from(keys));\n        } else {\n            retv[type] = Object.freeze(Array.from(additionalKeys[type]));\n        }\n    }\n\n    return Object.freeze(retv);\n}\n\nexports.KEYS = KEYS;\nexports.getKeys = getKeys;\nexports.unionWith = unionWith;\n"
        }
    ]
}