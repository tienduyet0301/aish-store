{
    "sourceFile": "node_modules/@noble/hashes/src/eskdf.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891898615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Experimental KDF for AES.\n */\nimport { hkdf } from './hkdf.ts';\nimport { pbkdf2 as _pbkdf2 } from './pbkdf2.ts';\nimport { scrypt as _scrypt } from './scrypt.ts';\nimport { sha256 } from './sha256.ts';\nimport { abytes, bytesToHex, clean, createView, hexToBytes, kdfInputToBytes } from './utils.ts';\n\n// A tiny KDF for various applications like AES key-gen.\n// Uses HKDF in a non-standard way, so it's not \"KDF-secure\", only \"PRF-secure\".\n// Which is good enough: assume sha2-256 retained preimage resistance.\n\nconst SCRYPT_FACTOR = 2 ** 19;\nconst PBKDF2_FACTOR = 2 ** 17;\n\n// Scrypt KDF\nexport function scrypt(password: string, salt: string): Uint8Array {\n  return _scrypt(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 });\n}\n\n// PBKDF2-HMAC-SHA256\nexport function pbkdf2(password: string, salt: string): Uint8Array {\n  return _pbkdf2(sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 });\n}\n\n// Combines two 32-byte byte arrays\nfunction xor32(a: Uint8Array, b: Uint8Array): Uint8Array {\n  abytes(a, 32);\n  abytes(b, 32);\n  const arr = new Uint8Array(32);\n  for (let i = 0; i < 32; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction strHasLength(str: string, min: number, max: number): boolean {\n  return typeof str === 'string' && str.length >= min && str.length <= max;\n}\n\n/**\n * Derives main seed. Takes a lot of time. Prefer `eskdf` method instead.\n */\nexport function deriveMainSeed(username: string, password: string): Uint8Array {\n  if (!strHasLength(username, 8, 255)) throw new Error('invalid username');\n  if (!strHasLength(password, 8, 255)) throw new Error('invalid password');\n  // Declared like this to throw off minifiers which auto-convert .fromCharCode(1) to actual string.\n  // String with non-ascii may be problematic in some envs\n  const codes = { _1: 1, _2: 2 };\n  const sep = { s: String.fromCharCode(codes._1), p: String.fromCharCode(codes._2) };\n  const scr = scrypt(password + sep.s, username + sep.s);\n  const pbk = pbkdf2(password + sep.p, username + sep.p);\n  const res = xor32(scr, pbk);\n  clean(scr, pbk);\n  return res;\n}\n\ntype AccountID = number | string;\n\n/**\n * Converts protocol & accountId pair to HKDF salt & info params.\n */\nfunction getSaltInfo(protocol: string, accountId: AccountID = 0) {\n  // Note that length here also repeats two lines below\n  // We do an additional length check here to reduce the scope of DoS attacks\n  if (!(strHasLength(protocol, 3, 15) && /^[a-z0-9]{3,15}$/.test(protocol))) {\n    throw new Error('invalid protocol');\n  }\n\n  // Allow string account ids for some protocols\n  const allowsStr = /^password\\d{0,3}|ssh|tor|file$/.test(protocol);\n  let salt: Uint8Array; // Extract salt. Default is undefined.\n  if (typeof accountId === 'string') {\n    if (!allowsStr) throw new Error('accountId must be a number');\n    if (!strHasLength(accountId, 1, 255))\n      throw new Error('accountId must be string of length 1..255');\n    salt = kdfInputToBytes(accountId);\n  } else if (Number.isSafeInteger(accountId)) {\n    if (accountId < 0 || accountId > Math.pow(2, 32) - 1) throw new Error('invalid accountId');\n    // Convert to Big Endian Uint32\n    salt = new Uint8Array(4);\n    createView(salt).setUint32(0, accountId, false);\n  } else {\n    throw new Error('accountId must be a number' + (allowsStr ? ' or string' : ''));\n  }\n  const info = kdfInputToBytes(protocol);\n  return { salt, info };\n}\n\ntype OptsLength = { keyLength: number };\ntype OptsMod = { modulus: bigint };\ntype KeyOpts = undefined | OptsLength | OptsMod;\n\nfunction countBytes(num: bigint): number {\n  if (typeof num !== 'bigint' || num <= BigInt(128)) throw new Error('invalid number');\n  return Math.ceil(num.toString(2).length / 8);\n}\n\n/**\n * Parses keyLength and modulus options to extract length of result key.\n * If modulus is used, adds 64 bits to it as per FIPS 186 B.4.1 to combat modulo bias.\n */\nfunction getKeyLength(options: KeyOpts): number {\n  if (!options || typeof options !== 'object') return 32;\n  const hasLen = 'keyLength' in options;\n  const hasMod = 'modulus' in options;\n  if (hasLen && hasMod) throw new Error('cannot combine keyLength and modulus options');\n  if (!hasLen && !hasMod) throw new Error('must have either keyLength or modulus option');\n  // FIPS 186 B.4.1 requires at least 64 more bits\n  const l = hasMod ? countBytes(options.modulus) + 8 : options.keyLength;\n  if (!(typeof l === 'number' && l >= 16 && l <= 8192)) throw new Error('invalid keyLength');\n  return l;\n}\n\n/**\n * Converts key to bigint and divides it by modulus. Big Endian.\n * Implements FIPS 186 B.4.1, which removes 0 and modulo bias from output.\n */\nfunction modReduceKey(key: Uint8Array, modulus: bigint): Uint8Array {\n  const _1 = BigInt(1);\n  const num = BigInt('0x' + bytesToHex(key)); // check for ui8a, then bytesToNumber()\n  const res = (num % (modulus - _1)) + _1; // Remove 0 from output\n  if (res < _1) throw new Error('expected positive number'); // Guard against bad values\n  const len = key.length - 8; // FIPS requires 64 more bits = 8 bytes\n  const hex = res.toString(16).padStart(len * 2, '0'); // numberToHex()\n  const bytes = hexToBytes(hex);\n  if (bytes.length !== len) throw new Error('invalid length of result key');\n  return bytes;\n}\n\n// We are not using classes because constructor cannot be async\nexport interface ESKDF {\n  /**\n   * Derives a child key. Child key will not be associated with any\n   * other child key because of properties of underlying KDF.\n   *\n   * @param protocol - 3-15 character protocol name\n   * @param accountId - numeric identifier of account\n   * @param options - `keyLength: 64` or `modulus: 41920438n`\n   * @example deriveChildKey('aes', 0)\n   */\n  deriveChildKey: (protocol: string, accountId: AccountID, options?: KeyOpts) => Uint8Array;\n  /**\n   * Deletes the main seed from eskdf instance\n   */\n  expire: () => void;\n  /**\n   * Account fingerprint\n   */\n  fingerprint: string;\n}\n\n/**\n * ESKDF\n * @param username - username, email, or identifier, min: 8 characters, should have enough entropy\n * @param password - password, min: 8 characters, should have enough entropy\n * @example\n * const kdf = await eskdf('example-university', 'beginning-new-example');\n * const key = kdf.deriveChildKey('aes', 0);\n * console.log(kdf.fingerprint);\n * kdf.expire();\n */\nexport async function eskdf(username: string, password: string): Promise<ESKDF> {\n  // We are using closure + object instead of class because\n  // we want to make `seed` non-accessible for any external function.\n  let seed: Uint8Array | undefined = deriveMainSeed(username, password);\n\n  function deriveCK(protocol: string, accountId: AccountID = 0, options?: KeyOpts): Uint8Array {\n    abytes(seed, 32);\n    const { salt, info } = getSaltInfo(protocol, accountId); // validate protocol & accountId\n    const keyLength = getKeyLength(options); // validate options\n    const key = hkdf(sha256, seed!, salt, info, keyLength);\n    // Modulus has already been validated\n    return options && 'modulus' in options ? modReduceKey(key, options.modulus) : key;\n  }\n  function expire() {\n    if (seed) seed.fill(1);\n    seed = undefined;\n  }\n  // prettier-ignore\n  const fingerprint = Array.from(deriveCK('fingerprint', 0))\n    .slice(0, 6)\n    .map((char) => char.toString(16).padStart(2, '0').toUpperCase())\n    .join(':');\n  return Object.freeze({ deriveChildKey: deriveCK, expire, fingerprint });\n}\n"
        }
    ]
}