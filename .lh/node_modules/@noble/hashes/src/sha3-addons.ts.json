{
    "sourceFile": "node_modules/@noble/hashes/src/sha3-addons.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891898917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * SHA3 (keccak) addons.\n *\n * * Full [NIST SP 800-185](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf):\n *   cSHAKE, KMAC, TupleHash, ParallelHash + XOF variants\n * * Reduced-round Keccak [(draft)](https://datatracker.ietf.org/doc/draft-irtf-cfrg-kangarootwelve/):\n *     * ðŸ¦˜ K12 aka KangarooTwelve\n *     * M14 aka MarsupilamiFourteen\n *     * TurboSHAKE\n * * KeccakPRG: Pseudo-random generator based on Keccak [(pdf)](https://keccak.team/files/CSF-0.1.pdf)\n * @module\n */\nimport { Keccak, type ShakeOpts } from './sha3.ts';\nimport {\n  abytes,\n  anumber,\n  type CHashO,\n  type CHashXO,\n  createOptHasher,\n  createXOFer,\n  Hash,\n  type HashXOF,\n  type Input,\n  toBytes,\n  u32,\n} from './utils.ts';\n\n// cSHAKE && KMAC (NIST SP800-185)\nconst _8n = BigInt(8);\nconst _ffn = BigInt(0xff);\n\n// NOTE: it is safe to use bigints here, since they used only for length encoding (not actual data).\n// We use bigints in sha256 for lengths too.\nfunction leftEncode(n: number | bigint): Uint8Array {\n  n = BigInt(n);\n  const res = [Number(n & _ffn)];\n  n >>= _8n;\n  for (; n > 0; n >>= _8n) res.unshift(Number(n & _ffn));\n  res.unshift(res.length);\n  return new Uint8Array(res);\n}\n\nfunction rightEncode(n: number | bigint): Uint8Array {\n  n = BigInt(n);\n  const res = [Number(n & _ffn)];\n  n >>= _8n;\n  for (; n > 0; n >>= _8n) res.unshift(Number(n & _ffn));\n  res.push(res.length);\n  return new Uint8Array(res);\n}\n\nfunction chooseLen(opts: ShakeOpts, outputLen: number): number {\n  return opts.dkLen === undefined ? outputLen : opts.dkLen;\n}\n\nconst abytesOrZero = (buf?: Input) => {\n  if (buf === undefined) return Uint8Array.of();\n  return toBytes(buf);\n};\n// NOTE: second modulo is necessary since we don't need to add padding if current element takes whole block\nconst getPadding = (len: number, block: number) => new Uint8Array((block - (len % block)) % block);\nexport type cShakeOpts = ShakeOpts & { personalization?: Input; NISTfn?: Input };\n\n// Personalization\nfunction cshakePers(hash: Keccak, opts: cShakeOpts = {}): Keccak {\n  if (!opts || (!opts.personalization && !opts.NISTfn)) return hash;\n  // Encode and pad inplace to avoid unneccesary memory copies/slices (so we don't need to zero them later)\n  // bytepad(encode_string(N) || encode_string(S), 168)\n  const blockLenBytes = leftEncode(hash.blockLen);\n  const fn = abytesOrZero(opts.NISTfn);\n  const fnLen = leftEncode(_8n * BigInt(fn.length)); // length in bits\n  const pers = abytesOrZero(opts.personalization);\n  const persLen = leftEncode(_8n * BigInt(pers.length)); // length in bits\n  if (!fn.length && !pers.length) return hash;\n  hash.suffix = 0x04;\n  hash.update(blockLenBytes).update(fnLen).update(fn).update(persLen).update(pers);\n  let totalLen = blockLenBytes.length + fnLen.length + fn.length + persLen.length + pers.length;\n  hash.update(getPadding(totalLen, hash.blockLen));\n  return hash;\n}\n\nconst gencShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<Keccak, cShakeOpts>((opts: cShakeOpts = {}) =>\n    cshakePers(new Keccak(blockLen, suffix, chooseLen(opts, outputLen), true), opts)\n  );\n\n// TODO: refactor\nexport type ICShake = {\n  (msg: Input, opts?: cShakeOpts): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: cShakeOpts): HashXOF<Keccak>;\n};\nexport type ITupleHash = {\n  (messages: Input[], opts?: cShakeOpts): Uint8Array;\n  create(opts?: cShakeOpts): TupleHash;\n};\nexport type IParHash = {\n  (message: Input, opts?: ParallelOpts): Uint8Array;\n  create(opts?: ParallelOpts): ParallelHash;\n};\nexport const cshake128: ICShake = /* @__PURE__ */ (() => gencShake(0x1f, 168, 128 / 8))();\nexport const cshake256: ICShake = /* @__PURE__ */ (() => gencShake(0x1f, 136, 256 / 8))();\n\nexport class KMAC extends Keccak implements HashXOF<KMAC> {\n  constructor(\n    blockLen: number,\n    outputLen: number,\n    enableXOF: boolean,\n    key: Input,\n    opts: cShakeOpts = {}\n  ) {\n    super(blockLen, 0x1f, outputLen, enableXOF);\n    cshakePers(this, { NISTfn: 'KMAC', personalization: opts.personalization });\n    key = toBytes(key);\n    abytes(key);\n    // 1. newX = bytepad(encode_string(K), 168) || X || right_encode(L).\n    const blockLenBytes = leftEncode(this.blockLen);\n    const keyLen = leftEncode(_8n * BigInt(key.length));\n    this.update(blockLenBytes).update(keyLen).update(key);\n    const totalLen = blockLenBytes.length + keyLen.length + key.length;\n    this.update(getPadding(totalLen, this.blockLen));\n  }\n  protected finish(): void {\n    if (!this.finished) this.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits\n    super.finish();\n  }\n  _cloneInto(to?: KMAC): KMAC {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    // Force \"to\" to be instance of KMAC instead of Sha3.\n    if (!to) {\n      to = Object.create(Object.getPrototypeOf(this), {}) as KMAC;\n      to.state = this.state.slice();\n      to.blockLen = this.blockLen;\n      to.state32 = u32(to.state);\n    }\n    return super._cloneInto(to) as KMAC;\n  }\n  clone(): KMAC {\n    return this._cloneInto();\n  }\n}\n\nfunction genKmac(blockLen: number, outputLen: number, xof = false) {\n  const kmac = (key: Input, message: Input, opts?: cShakeOpts): Uint8Array =>\n    kmac.create(key, opts).update(message).digest();\n  kmac.create = (key: Input, opts: cShakeOpts = {}) =>\n    new KMAC(blockLen, chooseLen(opts, outputLen), xof, key, opts);\n  return kmac;\n}\n\nexport const kmac128: {\n  (key: Input, message: Input, opts?: cShakeOpts): Uint8Array;\n  create(key: Input, opts?: cShakeOpts): KMAC;\n} = /* @__PURE__ */ (() => genKmac(168, 128 / 8))();\nexport const kmac256: {\n  (key: Input, message: Input, opts?: cShakeOpts): Uint8Array;\n  create(key: Input, opts?: cShakeOpts): KMAC;\n} = /* @__PURE__ */ (() => genKmac(136, 256 / 8))();\nexport const kmac128xof: {\n  (key: Input, message: Input, opts?: cShakeOpts): Uint8Array;\n  create(key: Input, opts?: cShakeOpts): KMAC;\n} = /* @__PURE__ */ (() => genKmac(168, 128 / 8, true))();\nexport const kmac256xof: {\n  (key: Input, message: Input, opts?: cShakeOpts): Uint8Array;\n  create(key: Input, opts?: cShakeOpts): KMAC;\n} = /* @__PURE__ */ (() => genKmac(136, 256 / 8, true))();\n\n// TupleHash\n// Usage: tuple(['ab', 'cd']) != tuple(['a', 'bcd'])\nexport class TupleHash extends Keccak implements HashXOF<TupleHash> {\n  constructor(blockLen: number, outputLen: number, enableXOF: boolean, opts: cShakeOpts = {}) {\n    super(blockLen, 0x1f, outputLen, enableXOF);\n    cshakePers(this, { NISTfn: 'TupleHash', personalization: opts.personalization });\n    // Change update after cshake processed\n    this.update = (data: Input) => {\n      data = toBytes(data);\n      abytes(data);\n      super.update(leftEncode(_8n * BigInt(data.length)));\n      super.update(data);\n      return this;\n    };\n  }\n  protected finish(): void {\n    if (!this.finished)\n      super.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits\n    super.finish();\n  }\n  _cloneInto(to?: TupleHash): TupleHash {\n    to ||= new TupleHash(this.blockLen, this.outputLen, this.enableXOF);\n    return super._cloneInto(to) as TupleHash;\n  }\n  clone(): TupleHash {\n    return this._cloneInto();\n  }\n}\n\nfunction genTuple(blockLen: number, outputLen: number, xof = false) {\n  const tuple = (messages: Input[], opts?: cShakeOpts): Uint8Array => {\n    const h = tuple.create(opts);\n    for (const msg of messages) h.update(msg);\n    return h.digest();\n  };\n  tuple.create = (opts: cShakeOpts = {}) =>\n    new TupleHash(blockLen, chooseLen(opts, outputLen), xof, opts);\n  return tuple;\n}\n\n/** 128-bit TupleHASH. */\nexport const tuplehash128: ITupleHash = /* @__PURE__ */ (() => genTuple(168, 128 / 8))();\n/** 256-bit TupleHASH. */\nexport const tuplehash256: ITupleHash = /* @__PURE__ */ (() => genTuple(136, 256 / 8))();\n/** 128-bit TupleHASH XOF. */\nexport const tuplehash128xof: ITupleHash = /* @__PURE__ */ (() => genTuple(168, 128 / 8, true))();\n/** 256-bit TupleHASH XOF. */\nexport const tuplehash256xof: ITupleHash = /* @__PURE__ */ (() => genTuple(136, 256 / 8, true))();\n\n// ParallelHash (same as K12/M14, but without speedup for inputs less 8kb, reduced number of rounds and more simple)\ntype ParallelOpts = cShakeOpts & { blockLen?: number };\n\nexport class ParallelHash extends Keccak implements HashXOF<ParallelHash> {\n  private leafHash?: Hash<Keccak>;\n  protected leafCons: () => Hash<Keccak>;\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private chunkLen: number;\n  constructor(\n    blockLen: number,\n    outputLen: number,\n    leafCons: () => Hash<Keccak>,\n    enableXOF: boolean,\n    opts: ParallelOpts = {}\n  ) {\n    super(blockLen, 0x1f, outputLen, enableXOF);\n    cshakePers(this, { NISTfn: 'ParallelHash', personalization: opts.personalization });\n    this.leafCons = leafCons;\n    let { blockLen: B } = opts;\n    B ||= 8;\n    anumber(B);\n    this.chunkLen = B;\n    super.update(leftEncode(B));\n    // Change update after cshake processed\n    this.update = (data: Input) => {\n      data = toBytes(data);\n      abytes(data);\n      const { chunkLen, leafCons } = this;\n      for (let pos = 0, len = data.length; pos < len; ) {\n        if (this.chunkPos == chunkLen || !this.leafHash) {\n          if (this.leafHash) {\n            super.update(this.leafHash.digest());\n            this.chunksDone++;\n          }\n          this.leafHash = leafCons();\n          this.chunkPos = 0;\n        }\n        const take = Math.min(chunkLen - this.chunkPos, len - pos);\n        this.leafHash.update(data.subarray(pos, pos + take));\n        this.chunkPos += take;\n        pos += take;\n      }\n      return this;\n    };\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    if (this.leafHash) {\n      super.update(this.leafHash.digest());\n      this.chunksDone++;\n    }\n    super.update(rightEncode(this.chunksDone));\n    super.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits\n    super.finish();\n  }\n  _cloneInto(to?: ParallelHash): ParallelHash {\n    to ||= new ParallelHash(this.blockLen, this.outputLen, this.leafCons, this.enableXOF);\n    if (this.leafHash) to.leafHash = this.leafHash._cloneInto(to.leafHash as Keccak);\n    to.chunkPos = this.chunkPos;\n    to.chunkLen = this.chunkLen;\n    to.chunksDone = this.chunksDone;\n    return super._cloneInto(to) as ParallelHash;\n  }\n  destroy(): void {\n    super.destroy.call(this);\n    if (this.leafHash) this.leafHash.destroy();\n  }\n  clone(): ParallelHash {\n    return this._cloneInto();\n  }\n}\n\nfunction genPrl(\n  blockLen: number,\n  outputLen: number,\n  leaf: ReturnType<typeof gencShake>,\n  xof = false\n) {\n  const parallel = (message: Input, opts?: ParallelOpts): Uint8Array =>\n    parallel.create(opts).update(message).digest();\n  parallel.create = (opts: ParallelOpts = {}) =>\n    new ParallelHash(\n      blockLen,\n      chooseLen(opts, outputLen),\n      () => leaf.create({ dkLen: 2 * outputLen }),\n      xof,\n      opts\n    );\n  return parallel;\n}\n\n/** 128-bit ParallelHash. In JS, it is not parallel. */\nexport const parallelhash128: IParHash = /* @__PURE__ */ (() => genPrl(168, 128 / 8, cshake128))();\n/** 256-bit ParallelHash. In JS, it is not parallel. */\nexport const parallelhash256: IParHash = /* @__PURE__ */ (() => genPrl(136, 256 / 8, cshake256))();\n/** 128-bit ParallelHash XOF. In JS, it is not parallel. */\nexport const parallelhash128xof: IParHash = /* @__PURE__ */ (() =>\n  genPrl(168, 128 / 8, cshake128, true))();\n/** 256-bit ParallelHash. In JS, it is not parallel. */\nexport const parallelhash256xof: IParHash = /* @__PURE__ */ (() =>\n  genPrl(136, 256 / 8, cshake256, true))();\n\n// Should be simple 'shake with 12 rounds', but no, we got whole new spec about Turbo SHAKE Pro MAX.\nexport type TurboshakeOpts = ShakeOpts & {\n  D?: number; // Domain separation byte\n};\n\nconst genTurboshake = (blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, TurboshakeOpts>((opts: TurboshakeOpts = {}) => {\n    const D = opts.D === undefined ? 0x1f : opts.D;\n    // Section 2.1 of https://datatracker.ietf.org/doc/draft-irtf-cfrg-kangarootwelve/\n    if (!Number.isSafeInteger(D) || D < 0x01 || D > 0x7f)\n      throw new Error('invalid domain separation byte must be 0x01..0x7f, got: ' + D);\n    return new Keccak(blockLen, D, opts.dkLen === undefined ? outputLen : opts.dkLen, true, 12);\n  });\n\n/** TurboSHAKE 128-bit: reduced 12-round keccak. */\nexport const turboshake128: CHashXO = /* @__PURE__ */ genTurboshake(168, 256 / 8);\n/** TurboSHAKE 256-bit: reduced 12-round keccak. */\nexport const turboshake256: CHashXO = /* @__PURE__ */ genTurboshake(136, 512 / 8);\n\n// Kangaroo\n// Same as NIST rightEncode, but returns [0] for zero string\nfunction rightEncodeK12(n: number | bigint): Uint8Array {\n  n = BigInt(n);\n  const res: number[] = [];\n  for (; n > 0; n >>= _8n) res.unshift(Number(n & _ffn));\n  res.push(res.length);\n  return Uint8Array.from(res);\n}\n\nexport type KangarooOpts = { dkLen?: number; personalization?: Input };\nconst EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();\n\nexport class KangarooTwelve extends Keccak implements HashXOF<KangarooTwelve> {\n  readonly chunkLen = 8192;\n  private leafHash?: Keccak;\n  protected leafLen: number;\n  private personalization: Uint8Array;\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  constructor(\n    blockLen: number,\n    leafLen: number,\n    outputLen: number,\n    rounds: number,\n    opts: KangarooOpts\n  ) {\n    super(blockLen, 0x07, outputLen, true, rounds);\n    this.leafLen = leafLen;\n    this.personalization = abytesOrZero(opts.personalization);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    abytes(data);\n    const { chunkLen, blockLen, leafLen, rounds } = this;\n    for (let pos = 0, len = data.length; pos < len; ) {\n      if (this.chunkPos == chunkLen) {\n        if (this.leafHash) super.update(this.leafHash.digest());\n        else {\n          this.suffix = 0x06; // Its safe to change suffix here since its used only in digest()\n          super.update(Uint8Array.from([3, 0, 0, 0, 0, 0, 0, 0]));\n        }\n        this.leafHash = new Keccak(blockLen, 0x0b, leafLen, false, rounds);\n        this.chunksDone++;\n        this.chunkPos = 0;\n      }\n      const take = Math.min(chunkLen - this.chunkPos, len - pos);\n      const chunk = data.subarray(pos, pos + take);\n      if (this.leafHash) this.leafHash.update(chunk);\n      else super.update(chunk);\n      this.chunkPos += take;\n      pos += take;\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    const { personalization } = this;\n    this.update(personalization).update(rightEncodeK12(personalization.length));\n    // Leaf hash\n    if (this.leafHash) {\n      super.update(this.leafHash.digest());\n      super.update(rightEncodeK12(this.chunksDone));\n      super.update(Uint8Array.from([0xff, 0xff]));\n    }\n    super.finish.call(this);\n  }\n  destroy(): void {\n    super.destroy.call(this);\n    if (this.leafHash) this.leafHash.destroy();\n    // We cannot zero personalization buffer since it is user provided and we don't want to mutate user input\n    this.personalization = EMPTY_BUFFER;\n  }\n  _cloneInto(to?: KangarooTwelve): KangarooTwelve {\n    const { blockLen, leafLen, leafHash, outputLen, rounds } = this;\n    to ||= new KangarooTwelve(blockLen, leafLen, outputLen, rounds, {});\n    super._cloneInto(to);\n    if (leafHash) to.leafHash = leafHash._cloneInto(to.leafHash);\n    to.personalization.set(this.personalization);\n    to.leafLen = this.leafLen;\n    to.chunkPos = this.chunkPos;\n    to.chunksDone = this.chunksDone;\n    return to;\n  }\n  clone(): KangarooTwelve {\n    return this._cloneInto();\n  }\n}\n/** KangarooTwelve: reduced 12-round keccak. */\nexport const k12: CHashO = /* @__PURE__ */ (() =>\n  createOptHasher<KangarooTwelve, KangarooOpts>(\n    (opts: KangarooOpts = {}) => new KangarooTwelve(168, 32, chooseLen(opts, 32), 12, opts)\n  ))();\n/** MarsupilamiFourteen: reduced 14-round keccak. */\nexport const m14: CHashO = /* @__PURE__ */ (() =>\n  createOptHasher<KangarooTwelve, KangarooOpts>(\n    (opts: KangarooOpts = {}) => new KangarooTwelve(136, 64, chooseLen(opts, 64), 14, opts)\n  ))();\n\n/**\n * More at https://github.com/XKCP/XKCP/tree/master/lib/high/Keccak/PRG.\n */\nexport class KeccakPRG extends Keccak {\n  protected rate: number;\n  constructor(capacity: number) {\n    anumber(capacity);\n    // Rho should be full bytes\n    if (capacity < 0 || capacity > 1600 - 10 || (1600 - capacity - 2) % 8)\n      throw new Error('invalid capacity');\n    // blockLen = rho in bytes\n    super((1600 - capacity - 2) / 8, 0, 0, true);\n    this.rate = 1600 - capacity;\n    this.posOut = Math.floor((this.rate + 7) / 8);\n  }\n  keccak(): void {\n    // Duplex padding\n    this.state[this.pos] ^= 0x01;\n    this.state[this.blockLen] ^= 0x02; // Rho is full bytes\n    super.keccak();\n    this.pos = 0;\n    this.posOut = 0;\n  }\n  update(data: Input): this {\n    super.update(data);\n    this.posOut = this.blockLen;\n    return this;\n  }\n  feed(data: Input): this {\n    return this.update(data);\n  }\n  protected finish(): void {}\n  digestInto(_out: Uint8Array): Uint8Array {\n    throw new Error('digest is not allowed, use .fetch instead');\n  }\n  fetch(bytes: number): Uint8Array {\n    return this.xof(bytes);\n  }\n  // Ensure irreversibility (even if state leaked previous outputs cannot be computed)\n  forget(): void {\n    if (this.rate < 1600 / 2 + 1) throw new Error('rate is too low to use .forget()');\n    this.keccak();\n    for (let i = 0; i < this.blockLen; i++) this.state[i] = 0;\n    this.pos = this.blockLen;\n    this.keccak();\n    this.posOut = this.blockLen;\n  }\n  _cloneInto(to?: KeccakPRG): KeccakPRG {\n    const { rate } = this;\n    to ||= new KeccakPRG(1600 - rate);\n    super._cloneInto(to);\n    to.rate = rate;\n    return to;\n  }\n  clone(): KeccakPRG {\n    return this._cloneInto();\n  }\n}\n\n/** KeccakPRG: Pseudo-random generator based on Keccak. https://keccak.team/files/CSF-0.1.pdf */\nexport const keccakprg = (capacity = 254): KeccakPRG => new KeccakPRG(capacity);\n"
        }
    ]
}