{
    "sourceFile": "node_modules/@noble/hashes/src/argon2.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891898401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Argon2 KDF from RFC 9106. Can be used to create a key from password and salt.\n * We suggest to use Scrypt. JS Argon is 2-10x slower than native code because of 64-bitness:\n * * argon uses uint64, but JS doesn't have fast uint64array\n * * uint64 multiplication is 1/3 of time\n * * `P` function would be very nice with u64, because most of value will be in registers,\n *   hovewer with u32 it will require 32 registers, which is too much.\n * * JS arrays do slow bound checks, so reading from `A2_BUF` slows it down\n * @module\n */\nimport { add3H, add3L, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL } from './_u64.ts';\nimport { blake2b } from './blake2.ts';\nimport { abytes, clean, kdfInputToBytes, nextTick, u32, u8, type KDFInput } from './utils.ts';\n\nconst AT = { Argond2d: 0, Argon2i: 1, Argon2id: 2 } as const;\ntype Types = (typeof AT)[keyof typeof AT];\n\nconst ARGON2_SYNC_POINTS = 4;\nconst abytesOrZero = (buf?: KDFInput) => {\n  if (buf === undefined) return Uint8Array.of();\n  return kdfInputToBytes(buf);\n};\n\n// u32 * u32 = u64\nfunction mul(a: number, b: number) {\n  const aL = a & 0xffff;\n  const aH = a >>> 16;\n  const bL = b & 0xffff;\n  const bH = b >>> 16;\n  const ll = Math.imul(aL, bL);\n  const hl = Math.imul(aH, bL);\n  const lh = Math.imul(aL, bH);\n  const hh = Math.imul(aH, bH);\n  const carry = (ll >>> 16) + (hl & 0xffff) + lh;\n  const high = (hh + (hl >>> 16) + (carry >>> 16)) | 0;\n  const low = (carry << 16) | (ll & 0xffff);\n  return { h: high, l: low };\n}\n\nfunction mul2(a: number, b: number) {\n  // 2 * a * b (via shifts)\n  const { h, l } = mul(a, b);\n  return { h: ((h << 1) | (l >>> 31)) & 0xffff_ffff, l: (l << 1) & 0xffff_ffff };\n}\n\n// BlaMka permutation for Argon2\n// A + B + (2 * u32(A) * u32(B))\nfunction blamka(Ah: number, Al: number, Bh: number, Bl: number) {\n  const { h: Ch, l: Cl } = mul2(Al, Bl);\n  // A + B + (2 * A * B)\n  const Rll = add3L(Al, Bl, Cl);\n  return { h: add3H(Rll, Ah, Bh, Ch), l: Rll | 0 };\n}\n\n// Temporary block buffer\nconst A2_BUF = new Uint32Array(256); // 1024 bytes (matrix 16x16)\n\nfunction G(a: number, b: number, c: number, d: number) {\n  let Al = A2_BUF[2*a], Ah = A2_BUF[2*a + 1]; // prettier-ignore\n  let Bl = A2_BUF[2*b], Bh = A2_BUF[2*b + 1]; // prettier-ignore\n  let Cl = A2_BUF[2*c], Ch = A2_BUF[2*c + 1]; // prettier-ignore\n  let Dl = A2_BUF[2*d], Dh = A2_BUF[2*d + 1]; // prettier-ignore\n\n  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });\n\n  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });\n\n  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });\n\n  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });\n\n  (A2_BUF[2 * a] = Al), (A2_BUF[2 * a + 1] = Ah);\n  (A2_BUF[2 * b] = Bl), (A2_BUF[2 * b + 1] = Bh);\n  (A2_BUF[2 * c] = Cl), (A2_BUF[2 * c + 1] = Ch);\n  (A2_BUF[2 * d] = Dl), (A2_BUF[2 * d + 1] = Dh);\n}\n\n// prettier-ignore\nfunction P(\n  v00: number, v01: number, v02: number, v03: number, v04: number, v05: number, v06: number, v07: number,\n  v08: number, v09: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n) {\n  G(v00, v04, v08, v12);\n  G(v01, v05, v09, v13);\n  G(v02, v06, v10, v14);\n  G(v03, v07, v11, v15);\n  G(v00, v05, v10, v15);\n  G(v01, v06, v11, v12);\n  G(v02, v07, v08, v13);\n  G(v03, v04, v09, v14);\n}\n\nfunction block(x: Uint32Array, xPos: number, yPos: number, outPos: number, needXor: boolean) {\n  for (let i = 0; i < 256; i++) A2_BUF[i] = x[xPos + i] ^ x[yPos + i];\n  // columns (8)\n  for (let i = 0; i < 128; i += 16) {\n    // prettier-ignore\n    P(\n      i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7,\n      i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15\n    );\n  }\n  // rows (8)\n  for (let i = 0; i < 16; i += 2) {\n    // prettier-ignore\n    P(\n      i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49,\n      i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113\n    );\n  }\n\n  if (needXor) for (let i = 0; i < 256; i++) x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  else for (let i = 0; i < 256; i++) x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  clean(A2_BUF);\n}\n\n// Variable-Length Hash Function H'\nfunction Hp(A: Uint32Array, dkLen: number) {\n  const A8 = u8(A);\n  const T = new Uint32Array(1);\n  const T8 = u8(T);\n  T[0] = dkLen;\n  // Fast path\n  if (dkLen <= 64) return blake2b.create({ dkLen }).update(T8).update(A8).digest();\n  const out = new Uint8Array(dkLen);\n  let V = blake2b.create({}).update(T8).update(A8).digest();\n  let pos = 0;\n  // First block\n  out.set(V.subarray(0, 32));\n  pos += 32;\n  // Rest blocks\n  for (; dkLen - pos > 64; pos += 32) {\n    const Vh = blake2b.create({}).update(V);\n    Vh.digestInto(V);\n    Vh.destroy();\n    out.set(V.subarray(0, 32), pos);\n  }\n  // Last block\n  out.set(blake2b(V, { dkLen: dkLen - pos }), pos);\n  clean(V, T);\n  return u32(out);\n}\n\n// Used only inside process block!\nfunction indexAlpha(\n  r: number,\n  s: number,\n  laneLen: number,\n  segmentLen: number,\n  index: number,\n  randL: number,\n  sameLane: boolean = false\n) {\n  // This is ugly, but close enough to reference implementation.\n  let area: number;\n  if (r === 0) {\n    if (s === 0) area = index - 1;\n    else if (sameLane) area = s * segmentLen + index - 1;\n    else area = s * segmentLen + (index == 0 ? -1 : 0);\n  } else if (sameLane) area = laneLen - segmentLen + index - 1;\n  else area = laneLen - segmentLen + (index == 0 ? -1 : 0);\n  const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;\n  const rel = area - 1 - mul(area, mul(randL, randL).h).h;\n  return (startPos + rel) % laneLen;\n}\n\n/**\n * Argon2 options.\n * * t: time cost, m: mem cost in kb, p: parallelization.\n * * key: optional key. personalization: arbitrary extra data.\n * * dkLen: desired number of output bytes.\n */\nexport type ArgonOpts = {\n  t: number; // Time cost, iterations count\n  m: number; // Memory cost (in KB)\n  p: number; // Parallelization parameter\n  version?: number; // Default: 0x13 (19)\n  key?: KDFInput; // Optional key\n  personalization?: KDFInput; // Optional arbitrary extra data\n  dkLen?: number; // Desired number of returned bytes\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n  maxmem?: number;\n  onProgress?: (progress: number) => void;\n};\n\nconst maxUint32 = Math.pow(2, 32);\nfunction isU32(num: number) {\n  return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;\n}\n\nfunction argon2Opts(opts: ArgonOpts) {\n  const merged: any = {\n    version: 0x13,\n    dkLen: 32,\n    maxmem: maxUint32 - 1,\n    asyncTick: 10,\n  };\n  for (let [k, v] of Object.entries(opts)) if (v != null) merged[k] = v;\n\n  const { dkLen, p, m, t, version, onProgress } = merged;\n  if (!isU32(dkLen) || dkLen < 4) throw new Error('dkLen should be at least 4 bytes');\n  if (!isU32(p) || p < 1 || p >= Math.pow(2, 24)) throw new Error('p should be 1 <= p < 2^24');\n  if (!isU32(m)) throw new Error('m should be 0 <= m < 2^32');\n  if (!isU32(t) || t < 1) throw new Error('t (iterations) should be 1 <= t < 2^32');\n  if (onProgress !== undefined && typeof onProgress !== 'function')\n    throw new Error('progressCb should be function');\n  /*\n  Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.\n  */\n  if (!isU32(m) || m < 8 * p) throw new Error('memory should be at least 8*p bytes');\n  if (version !== 0x10 && version !== 0x13) throw new Error('unknown version=' + version);\n  return merged;\n}\n\nfunction argon2Init(password: KDFInput, salt: KDFInput, type: Types, opts: ArgonOpts) {\n  password = kdfInputToBytes(password);\n  salt = kdfInputToBytes(salt);\n  abytes(password);\n  abytes(salt);\n  if (!isU32(password.length)) throw new Error('password should be less than 4 GB');\n  if (!isU32(salt.length) || salt.length < 8)\n    throw new Error('salt should be at least 8 bytes and less than 4 GB');\n  if (!Object.values(AT).includes(type)) throw new Error('invalid type');\n  let { p, dkLen, m, t, version, key, personalization, maxmem, onProgress, asyncTick } =\n    argon2Opts(opts);\n\n  // Validation\n  key = abytesOrZero(key);\n  personalization = abytesOrZero(personalization);\n  // H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n  //       LE32(v) || LE32(y) || LE32(length(P)) || P ||\n  //       LE32(length(S)) || S ||  LE32(length(K)) || K ||\n  //       LE32(length(X)) || X)\n  const h = blake2b.create({});\n  const BUF = new Uint32Array(1);\n  const BUF8 = u8(BUF);\n  for (let item of [p, dkLen, m, t, version, type]) {\n    BUF[0] = item;\n    h.update(BUF8);\n  }\n  for (let i of [password, salt, key, personalization]) {\n    BUF[0] = i.length; // BUF is u32 array, this is valid\n    h.update(BUF8).update(i);\n  }\n  const H0 = new Uint32Array(18);\n  const H0_8 = u8(H0);\n  h.digestInto(H0_8);\n  // 256 u32 = 1024 (BLOCK_SIZE), fills A2_BUF on processing\n\n  // Params\n  const lanes = p;\n  // m' = 4 * p * floor (m / 4p)\n  const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));\n  //q = m' / p columns\n  const laneLen = Math.floor(mP / p);\n  const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);\n  const memUsed = mP * 256;\n  if (!isU32(maxmem) || memUsed > maxmem)\n    throw new Error(\n      'mem should be less than 2**32, got: maxmem=' + maxmem + ', memused=' + memUsed\n    );\n  const B = new Uint32Array(memUsed);\n  // Fill first blocks\n  for (let l = 0; l < p; l++) {\n    const i = 256 * laneLen * l;\n    // B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))\n    H0[17] = l;\n    H0[16] = 0;\n    B.set(Hp(H0, 1024), i);\n    // B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))\n    H0[16] = 1;\n    B.set(Hp(H0, 1024), i + 256);\n  }\n  let perBlock = () => {};\n  if (onProgress) {\n    const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlock / 10000), 1);\n    let blockCnt = 0;\n    perBlock = () => {\n      blockCnt++;\n      if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock))\n        onProgress(blockCnt / totalBlock);\n    };\n  }\n  clean(BUF, H0);\n  return { type, mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick };\n}\n\nfunction argon2Output(B: Uint32Array, p: number, laneLen: number, dkLen: number) {\n  const B_final = new Uint32Array(256);\n  for (let l = 0; l < p; l++)\n    for (let j = 0; j < 256; j++) B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];\n  const res = u8(Hp(B_final, dkLen));\n  clean(B_final);\n  return res;\n}\n\nfunction processBlock(\n  B: Uint32Array,\n  address: Uint32Array,\n  l: number,\n  r: number,\n  s: number,\n  index: number,\n  laneLen: number,\n  segmentLen: number,\n  lanes: number,\n  offset: number,\n  prev: number,\n  dataIndependent: boolean,\n  needXor: boolean\n) {\n  if (offset % laneLen) prev = offset - 1;\n  let randL, randH;\n  if (dataIndependent) {\n    let i128 = index % 128;\n    if (i128 === 0) {\n      address[256 + 12]++;\n      block(address, 256, 2 * 256, 0, false);\n      block(address, 0, 2 * 256, 0, false);\n    }\n    randL = address[2 * i128];\n    randH = address[2 * i128 + 1];\n  } else {\n    const T = 256 * prev;\n    randL = B[T];\n    randH = B[T + 1];\n  }\n  // address block\n  const refLane = r === 0 && s === 0 ? l : randH % lanes;\n  const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);\n  const refBlock = laneLen * refLane + refPos;\n  // B[i][j] = G(B[i][j-1], B[l][z])\n  block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);\n}\n\nfunction argon2(type: Types, password: KDFInput, salt: KDFInput, opts: ArgonOpts) {\n  const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock } = argon2Init(\n    password,\n    salt,\n    type,\n    opts\n  );\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(\n            B,\n            address,\n            l,\n            r,\n            s,\n            index,\n            laneLen,\n            segmentLen,\n            lanes,\n            offset,\n            prev,\n            dataIndependent,\n            needXor\n          );\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n\n/** argon2d GPU-resistant version. */\nexport const argon2d = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argond2d, password, salt, opts);\n/** argon2i side-channel-resistant version. */\nexport const argon2i = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argon2i, password, salt, opts);\n/** argon2id, combining i+d, the most popular version from RFC 9106 */\nexport const argon2id = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argon2id, password, salt, opts);\n\nasync function argon2Async(type: Types, password: KDFInput, salt: KDFInput, opts: ArgonOpts) {\n  const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick } =\n    argon2Init(password, salt, type, opts);\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  let ts = Date.now();\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(\n            B,\n            address,\n            l,\n            r,\n            s,\n            index,\n            laneLen,\n            segmentLen,\n            lanes,\n            offset,\n            prev,\n            dataIndependent,\n            needXor\n          );\n          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n          const diff = Date.now() - ts;\n          if (!(diff >= 0 && diff < asyncTick)) {\n            await nextTick();\n            ts += diff;\n          }\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n\n/** argon2d async GPU-resistant version. */\nexport const argon2dAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argond2d, password, salt, opts);\n/** argon2i async side-channel-resistant version. */\nexport const argon2iAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argon2i, password, salt, opts);\n/** argon2id async, combining i+d, the most popular version from RFC 9106 */\nexport const argon2idAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argon2id, password, salt, opts);\n"
        }
    ]
}