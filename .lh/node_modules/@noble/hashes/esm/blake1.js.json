{
    "sourceFile": "node_modules/@noble/hashes/esm/blake1.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891893931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Blake1 legacy hash function, one of SHA3 proposals.\n * Rarely used. Check out blake2 or blake3 instead.\n * https://www.aumasson.jp/blake/blake.pdf\n *\n * In the best case, there are 0 allocations.\n *\n * Differences from blake2:\n *\n * - BE instead of LE\n * - Paddings, similar to MD5, RIPEMD, SHA1, SHA2, but:\n *     - length flag is located before actual length\n *     - padding block is compressed differently (no lengths)\n * Instead of msg[sigma[k]], we have `msg[sigma[k]] ^ constants[sigma[k-1]]`\n * (-1 for g1, g2 without -1)\n * - Salt is XOR-ed into constants instead of state\n * - Salt is XOR-ed with output in `compress`\n * - Additional rows (+64 bytes) in SIGMA for new rounds\n * - Different round count:\n *     - 14 / 10 rounds in blake256 / blake2s\n *     - 16 / 12 rounds in blake512 / blake2b\n * - blake512: G1b: rotr 24 -> 25, G2b: rotr 63 -> 11\n * @module\n */\nimport { BSIGMA, G1s, G2s } from \"./_blake.js\";\nimport { setBigUint64, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, aoutput, clean, createOptHasher, createView, Hash, toBytes, } from \"./utils.js\";\n// Empty zero-filled salt\nconst EMPTY_SALT = /* @__PURE__ */ new Uint32Array(8);\nclass BLAKE1 extends Hash {\n    constructor(blockLen, outputLen, lengthFlag, counterLen, saltLen, constants, opts = {}) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        const { salt } = opts;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.lengthFlag = lengthFlag;\n        this.counterLen = counterLen;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n        if (salt) {\n            let slt = salt;\n            slt = toBytes(slt);\n            abytes(slt);\n            if (slt.length !== 4 * saltLen)\n                throw new Error('wrong salt length');\n            const salt32 = (this.salt = new Uint32Array(saltLen));\n            const sv = createView(slt);\n            this.constants = constants.slice();\n            for (let i = 0, offset = 0; i < salt32.length; i++, offset += 4) {\n                salt32[i] = sv.getUint32(offset, false);\n                this.constants[i] ^= salt32[i];\n            }\n        }\n        else {\n            this.salt = EMPTY_SALT;\n            this.constants = constants;\n        }\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        // From _md, but update length before each compress\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        let dataView;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                if (!dataView)\n                    dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(dataView, pos);\n                }\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.length += blockLen;\n                this.compress(view, 0, true);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.destroyed = true;\n        if (this.salt !== EMPTY_SALT) {\n            clean(this.salt, this.constants);\n        }\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { buffer, length, finished, destroyed, constants, salt, pos } = this;\n        to.buffer.set(buffer);\n        to.constants = constants.slice();\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        to.salt = salt.slice();\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        const { buffer, blockLen, counterLen, lengthFlag, view } = this;\n        clean(buffer.subarray(this.pos)); // clean buf\n        const counter = BigInt((this.length + this.pos) * 8);\n        const counterPos = blockLen - counterLen - 1;\n        buffer[this.pos] |= 128; // End block flag\n        this.length += this.pos; // add unwritten length\n        // Not enough in buffer for length: write what we have.\n        if (this.pos > counterPos) {\n            this.compress(view, 0);\n            clean(buffer);\n            this.pos = 0;\n        }\n        // Difference with md: here we have lengthFlag!\n        buffer[counterPos] |= lengthFlag; // Length flag\n        // We always set 8 byte length flag. Because length will overflow significantly sooner.\n        setBigUint64(view, blockLen - 8, counter, false);\n        this.compress(view, 0, this.pos !== 0); // don't add length if length is not empty block?\n        // Write output\n        clean(buffer);\n        const v = createView(out);\n        const state = this.get();\n        for (let i = 0; i < this.outputLen / 4; ++i)\n            v.setUint32(i * 4, state[i]);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\n// Constants\nconst B64C = /* @__PURE__ */ Uint32Array.from([\n    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,\n    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,\n    0x9216d5d9, 0x8979fb1b, 0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,\n    0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69,\n]);\n// first half of C512\nconst B32C = B64C.slice(0, 16);\nconst B256_IV = SHA256_IV.slice();\nconst B224_IV = SHA224_IV.slice();\nconst B384_IV = SHA384_IV.slice();\nconst B512_IV = SHA512_IV.slice();\nfunction generateTBL256() {\n    const TBL = [];\n    for (let i = 0, j = 0; i < 14; i++, j += 16) {\n        for (let offset = 1; offset < 16; offset += 2) {\n            TBL.push(B32C[BSIGMA[j + offset]]);\n            TBL.push(B32C[BSIGMA[j + offset - 1]]);\n        }\n    }\n    return new Uint32Array(TBL);\n}\nconst TBL256 = /* @__PURE__ */ generateTBL256(); // C256[SIGMA[X]] precompute\n// Reusable temporary buffer\nconst BLAKE256_W = /* @__PURE__ */ new Uint32Array(16);\nclass Blake1_32 extends BLAKE1 {\n    constructor(outputLen, IV, lengthFlag, opts = {}) {\n        super(64, outputLen, lengthFlag, 8, 4, B32C, opts);\n        this.v0 = IV[0] | 0;\n        this.v1 = IV[1] | 0;\n        this.v2 = IV[2] | 0;\n        this.v3 = IV[3] | 0;\n        this.v4 = IV[4] | 0;\n        this.v5 = IV[5] | 0;\n        this.v6 = IV[6] | 0;\n        this.v7 = IV[7] | 0;\n    }\n    get() {\n        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n        return [v0, v1, v2, v3, v4, v5, v6, v7];\n    }\n    // prettier-ignore\n    set(v0, v1, v2, v3, v4, v5, v6, v7) {\n        this.v0 = v0 | 0;\n        this.v1 = v1 | 0;\n        this.v2 = v2 | 0;\n        this.v3 = v3 | 0;\n        this.v4 = v4 | 0;\n        this.v5 = v5 | 0;\n        this.v6 = v6 | 0;\n        this.v7 = v7 | 0;\n    }\n    destroy() {\n        super.destroy();\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    compress(view, offset, withLength = true) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BLAKE256_W[i] = view.getUint32(offset, false);\n        // NOTE: we cannot re-use compress from blake2s, since there is additional xor over u256[SIGMA[e]]\n        let v00 = this.v0 | 0;\n        let v01 = this.v1 | 0;\n        let v02 = this.v2 | 0;\n        let v03 = this.v3 | 0;\n        let v04 = this.v4 | 0;\n        let v05 = this.v5 | 0;\n        let v06 = this.v6 | 0;\n        let v07 = this.v7 | 0;\n        let v08 = this.constants[0] | 0;\n        let v09 = this.constants[1] | 0;\n        let v10 = this.constants[2] | 0;\n        let v11 = this.constants[3] | 0;\n        const { h, l } = u64.fromBig(BigInt(withLength ? this.length * 8 : 0));\n        let v12 = (this.constants[4] ^ l) >>> 0;\n        let v13 = (this.constants[5] ^ l) >>> 0;\n        let v14 = (this.constants[6] ^ h) >>> 0;\n        let v15 = (this.constants[7] ^ h) >>> 0;\n        // prettier-ignore\n        for (let i = 0, k = 0, j = 0; i < 14; i++) {\n            ({ a: v00, b: v04, c: v08, d: v12 } = G1s(v00, v04, v08, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v00, b: v04, c: v08, d: v12 } = G2s(v00, v04, v08, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v01, b: v05, c: v09, d: v13 } = G1s(v01, v05, v09, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v01, b: v05, c: v09, d: v13 } = G2s(v01, v05, v09, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v02, b: v06, c: v10, d: v14 } = G1s(v02, v06, v10, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v02, b: v06, c: v10, d: v14 } = G2s(v02, v06, v10, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v03, b: v07, c: v11, d: v15 } = G1s(v03, v07, v11, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v03, b: v07, c: v11, d: v15 } = G2s(v03, v07, v11, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v00, b: v05, c: v10, d: v15 } = G1s(v00, v05, v10, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v00, b: v05, c: v10, d: v15 } = G2s(v00, v05, v10, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v01, b: v06, c: v11, d: v12 } = G1s(v01, v06, v11, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v01, b: v06, c: v11, d: v12 } = G2s(v01, v06, v11, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v02, b: v07, c: v08, d: v13 } = G1s(v02, v07, v08, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v02, b: v07, c: v08, d: v13 } = G2s(v02, v07, v08, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v03, b: v04, c: v09, d: v14 } = G1s(v03, v04, v09, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n            ({ a: v03, b: v04, c: v09, d: v14 } = G2s(v03, v04, v09, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));\n        }\n        this.v0 = (this.v0 ^ v00 ^ v08 ^ this.salt[0]) >>> 0;\n        this.v1 = (this.v1 ^ v01 ^ v09 ^ this.salt[1]) >>> 0;\n        this.v2 = (this.v2 ^ v02 ^ v10 ^ this.salt[2]) >>> 0;\n        this.v3 = (this.v3 ^ v03 ^ v11 ^ this.salt[3]) >>> 0;\n        this.v4 = (this.v4 ^ v04 ^ v12 ^ this.salt[0]) >>> 0;\n        this.v5 = (this.v5 ^ v05 ^ v13 ^ this.salt[1]) >>> 0;\n        this.v6 = (this.v6 ^ v06 ^ v14 ^ this.salt[2]) >>> 0;\n        this.v7 = (this.v7 ^ v07 ^ v15 ^ this.salt[3]) >>> 0;\n        clean(BLAKE256_W);\n    }\n}\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\nconst BLAKE512_W = /* @__PURE__ */ new Uint32Array(32);\nfunction generateTBL512() {\n    const TBL = [];\n    for (let r = 0, k = 0; r < 16; r++, k += 16) {\n        for (let offset = 1; offset < 16; offset += 2) {\n            TBL.push(B64C[BSIGMA[k + offset] * 2 + 0]);\n            TBL.push(B64C[BSIGMA[k + offset] * 2 + 1]);\n            TBL.push(B64C[BSIGMA[k + offset - 1] * 2 + 0]);\n            TBL.push(B64C[BSIGMA[k + offset - 1] * 2 + 1]);\n        }\n    }\n    return new Uint32Array(TBL);\n}\nconst TBL512 = /* @__PURE__ */ generateTBL512(); // C512[SIGMA[X]] precompute\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, k) {\n    const Xpos = 2 * BSIGMA[k];\n    const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2]; // prettier-ignore\n    let Al = BBUF[2 * a + 1], Ah = BBUF[2 * a]; // prettier-ignore\n    let Bl = BBUF[2 * b + 1], Bh = BBUF[2 * b]; // prettier-ignore\n    let Cl = BBUF[2 * c + 1], Ch = BBUF[2 * c]; // prettier-ignore\n    let Dl = BBUF[2 * d + 1], Dh = BBUF[2 * d]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh) >>> 0;\n    Al = (ll | 0) >>> 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 25)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 25), Bl: u64.rotrSL(Bh, Bl, 25) });\n    (BBUF[2 * a + 1] = Al), (BBUF[2 * a] = Ah);\n    (BBUF[2 * b + 1] = Bl), (BBUF[2 * b] = Bh);\n    (BBUF[2 * c + 1] = Cl), (BBUF[2 * c] = Ch);\n    (BBUF[2 * d + 1] = Dl), (BBUF[2 * d] = Dh);\n}\nfunction G2b(a, b, c, d, msg, k) {\n    const Xpos = 2 * BSIGMA[k];\n    const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2]; // prettier-ignore\n    let Al = BBUF[2 * a + 1], Ah = BBUF[2 * a]; // prettier-ignore\n    let Bl = BBUF[2 * b + 1], Bh = BBUF[2 * b]; // prettier-ignore\n    let Cl = BBUF[2 * c + 1], Ch = BBUF[2 * c]; // prettier-ignore\n    let Dl = BBUF[2 * d + 1], Dh = BBUF[2 * d]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 11)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 11), Bl: u64.rotrSL(Bh, Bl, 11) });\n    (BBUF[2 * a + 1] = Al), (BBUF[2 * a] = Ah);\n    (BBUF[2 * b + 1] = Bl), (BBUF[2 * b] = Bh);\n    (BBUF[2 * c + 1] = Cl), (BBUF[2 * c] = Ch);\n    (BBUF[2 * d + 1] = Dl), (BBUF[2 * d] = Dh);\n}\nclass Blake1_64 extends BLAKE1 {\n    constructor(outputLen, IV, lengthFlag, opts = {}) {\n        super(128, outputLen, lengthFlag, 16, 8, B64C, opts);\n        this.v0l = IV[0] | 0;\n        this.v0h = IV[1] | 0;\n        this.v1l = IV[2] | 0;\n        this.v1h = IV[3] | 0;\n        this.v2l = IV[4] | 0;\n        this.v2h = IV[5] | 0;\n        this.v3l = IV[6] | 0;\n        this.v3h = IV[7] | 0;\n        this.v4l = IV[8] | 0;\n        this.v4h = IV[9] | 0;\n        this.v5l = IV[10] | 0;\n        this.v5h = IV[11] | 0;\n        this.v6l = IV[12] | 0;\n        this.v6h = IV[13] | 0;\n        this.v7l = IV[14] | 0;\n        this.v7h = IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    destroy() {\n        super.destroy();\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    compress(view, offset, withLength = true) {\n        for (let i = 0; i < 32; i++, offset += 4)\n            BLAKE512_W[i] = view.getUint32(offset, false);\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(this.constants.subarray(0, 16), 16);\n        if (withLength) {\n            const { h, l } = u64.fromBig(BigInt(this.length * 8));\n            BBUF[24] = (BBUF[24] ^ h) >>> 0;\n            BBUF[25] = (BBUF[25] ^ l) >>> 0;\n            BBUF[26] = (BBUF[26] ^ h) >>> 0;\n            BBUF[27] = (BBUF[27] ^ l) >>> 0;\n        }\n        for (let i = 0, k = 0; i < 16; i++) {\n            G1b(0, 4, 8, 12, BLAKE512_W, k++);\n            G2b(0, 4, 8, 12, BLAKE512_W, k++);\n            G1b(1, 5, 9, 13, BLAKE512_W, k++);\n            G2b(1, 5, 9, 13, BLAKE512_W, k++);\n            G1b(2, 6, 10, 14, BLAKE512_W, k++);\n            G2b(2, 6, 10, 14, BLAKE512_W, k++);\n            G1b(3, 7, 11, 15, BLAKE512_W, k++);\n            G2b(3, 7, 11, 15, BLAKE512_W, k++);\n            G1b(0, 5, 10, 15, BLAKE512_W, k++);\n            G2b(0, 5, 10, 15, BLAKE512_W, k++);\n            G1b(1, 6, 11, 12, BLAKE512_W, k++);\n            G2b(1, 6, 11, 12, BLAKE512_W, k++);\n            G1b(2, 7, 8, 13, BLAKE512_W, k++);\n            G2b(2, 7, 8, 13, BLAKE512_W, k++);\n            G1b(3, 4, 9, 14, BLAKE512_W, k++);\n            G2b(3, 4, 9, 14, BLAKE512_W, k++);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16] ^ this.salt[0];\n        this.v0h ^= BBUF[1] ^ BBUF[17] ^ this.salt[1];\n        this.v1l ^= BBUF[2] ^ BBUF[18] ^ this.salt[2];\n        this.v1h ^= BBUF[3] ^ BBUF[19] ^ this.salt[3];\n        this.v2l ^= BBUF[4] ^ BBUF[20] ^ this.salt[4];\n        this.v2h ^= BBUF[5] ^ BBUF[21] ^ this.salt[5];\n        this.v3l ^= BBUF[6] ^ BBUF[22] ^ this.salt[6];\n        this.v3h ^= BBUF[7] ^ BBUF[23] ^ this.salt[7];\n        this.v4l ^= BBUF[8] ^ BBUF[24] ^ this.salt[0];\n        this.v4h ^= BBUF[9] ^ BBUF[25] ^ this.salt[1];\n        this.v5l ^= BBUF[10] ^ BBUF[26] ^ this.salt[2];\n        this.v5h ^= BBUF[11] ^ BBUF[27] ^ this.salt[3];\n        this.v6l ^= BBUF[12] ^ BBUF[28] ^ this.salt[4];\n        this.v6h ^= BBUF[13] ^ BBUF[29] ^ this.salt[5];\n        this.v7l ^= BBUF[14] ^ BBUF[30] ^ this.salt[6];\n        this.v7h ^= BBUF[15] ^ BBUF[31] ^ this.salt[7];\n        clean(BBUF, BLAKE512_W);\n    }\n}\nexport class BLAKE224 extends Blake1_32 {\n    constructor(opts = {}) {\n        super(28, B224_IV, 0, opts);\n    }\n}\nexport class BLAKE256 extends Blake1_32 {\n    constructor(opts = {}) {\n        super(32, B256_IV, 1, opts);\n    }\n}\nexport class BLAKE384 extends Blake1_64 {\n    constructor(opts = {}) {\n        super(48, B384_IV, 0, opts);\n    }\n}\nexport class BLAKE512 extends Blake1_64 {\n    constructor(opts = {}) {\n        super(64, B512_IV, 1, opts);\n    }\n}\n/** blake1-224 hash function */\nexport const blake224 = /* @__PURE__ */ createOptHasher((opts) => new BLAKE224(opts));\n/** blake1-256 hash function */\nexport const blake256 = /* @__PURE__ */ createOptHasher((opts) => new BLAKE256(opts));\n/** blake1-384 hash function */\nexport const blake384 = /* @__PURE__ */ createOptHasher((opts) => new BLAKE384(opts));\n/** blake1-512 hash function */\nexport const blake512 = /* @__PURE__ */ createOptHasher((opts) => new BLAKE512(opts));\n//# sourceMappingURL=blake1.js.map"
        }
    ]
}