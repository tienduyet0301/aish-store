{
    "sourceFile": "node_modules/@noble/hashes/esm/utils.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891896370,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport declare function isBytes(a: unknown): a is Uint8Array;\n/** Asserts something is positive integer. */\nexport declare function anumber(n: number): void;\n/** Asserts something is Uint8Array. */\nexport declare function abytes(b: Uint8Array | undefined, ...lengths: number[]): void;\n/** Asserts something is hash */\nexport declare function ahash(h: IHash): void;\n/** Asserts a hash instance has not been destroyed / finished */\nexport declare function aexists(instance: any, checkFinished?: boolean): void;\n/** Asserts output is properly-sized byte array */\nexport declare function aoutput(out: any, instance: any): void;\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array | Uint16Array | Int16Array | Uint32Array | Int32Array;\n/** Cast u8 / u16 / u32 to u8. */\nexport declare function u8(arr: TypedArray): Uint8Array;\n/** Cast u8 / u16 / u32 to u32. */\nexport declare function u32(arr: TypedArray): Uint32Array;\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport declare function clean(...arrays: TypedArray[]): void;\n/** Create DataView of an array for easy byte-level manipulation. */\nexport declare function createView(arr: TypedArray): DataView;\n/** The rotate right (circular right shift) operation for uint32 */\nexport declare function rotr(word: number, shift: number): number;\n/** The rotate left (circular left shift) operation for uint32 */\nexport declare function rotl(word: number, shift: number): number;\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport declare const isLE: boolean;\n/** The byte swap operation for uint32 */\nexport declare function byteSwap(word: number): number;\n/** Conditionally byte swap if on a big-endian platform */\nexport declare const swap8IfBE: (n: number) => number;\n/** @deprecated */\nexport declare const byteSwapIfBE: typeof swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport declare function byteSwap32(arr: Uint32Array): Uint32Array;\nexport declare const swap32IfBE: (u: Uint32Array) => Uint32Array;\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport declare function bytesToHex(bytes: Uint8Array): string;\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport declare function hexToBytes(hex: string): Uint8Array;\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport declare const nextTick: () => Promise<void>;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport declare function asyncLoop(iters: number, tick: number, cb: (i: number) => void): Promise<void>;\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport declare function utf8ToBytes(str: string): Uint8Array;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport declare function bytesToUtf8(bytes: Uint8Array): string;\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport declare function toBytes(data: Input): Uint8Array;\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport declare function kdfInputToBytes(data: KDFInput): Uint8Array;\n/** Copies several Uint8Arrays into one. */\nexport declare function concatBytes(...arrays: Uint8Array[]): Uint8Array;\ntype EmptyObj = {};\nexport declare function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(defaults: T1, opts?: T2): T1 & T2;\n/** Hash interface. */\nexport type IHash = {\n    (data: Uint8Array): Uint8Array;\n    blockLen: number;\n    outputLen: number;\n    create: any;\n};\n/** For runtime check if class implements interface */\nexport declare abstract class Hash<T extends Hash<T>> {\n    abstract blockLen: number;\n    abstract outputLen: number;\n    abstract update(buf: Input): this;\n    abstract digestInto(buf: Uint8Array): void;\n    abstract digest(): Uint8Array;\n    /**\n     * Resets internal state. Makes Hash instance unusable.\n     * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n     * by user, they will need to manually call `destroy()` when zeroing is necessary.\n     */\n    abstract destroy(): void;\n    /**\n     * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n     * when no options are passed.\n     * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n     * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n     * There are no guarantees for clean-up because it's impossible in JS.\n     */\n    abstract _cloneInto(to?: T): T;\n    abstract clone(): T;\n}\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n    xof(bytes: number): Uint8Array;\n    xofInto(buf: Uint8Array): Uint8Array;\n};\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n/** Wraps hash function, creating an interface on top of it */\nexport declare function createHasher<T extends Hash<T>>(hashCons: () => Hash<T>): {\n    (msg: Input): Uint8Array;\n    outputLen: number;\n    blockLen: number;\n    create(): Hash<T>;\n};\nexport declare function createOptHasher<H extends Hash<H>, T extends Object>(hashCons: (opts?: T) => Hash<H>): {\n    (msg: Input, opts?: T): Uint8Array;\n    outputLen: number;\n    blockLen: number;\n    create(opts?: T): Hash<H>;\n};\nexport declare function createXOFer<H extends HashXOF<H>, T extends Object>(hashCons: (opts?: T) => HashXOF<H>): {\n    (msg: Input, opts?: T): Uint8Array;\n    outputLen: number;\n    blockLen: number;\n    create(opts?: T): HashXOF<H>;\n};\nexport declare const wrapConstructor: typeof createHasher;\nexport declare const wrapConstructorWithOpts: typeof createOptHasher;\nexport declare const wrapXOFConstructorWithOpts: typeof createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport declare function randomBytes(bytesLength?: number): Uint8Array;\nexport {};\n//# sourceMappingURL=utils.d.ts.map"
        }
    ]
}