{
    "sourceFile": "node_modules/@noble/hashes/esm/argon2.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891893423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Argon2 KDF from RFC 9106. Can be used to create a key from password and salt.\n * We suggest to use Scrypt. JS Argon is 2-10x slower than native code because of 64-bitness:\n * * argon uses uint64, but JS doesn't have fast uint64array\n * * uint64 multiplication is 1/3 of time\n * * `P` function would be very nice with u64, because most of value will be in registers,\n *   hovewer with u32 it will require 32 registers, which is too much.\n * * JS arrays do slow bound checks, so reading from `A2_BUF` slows it down\n * @module\n */\nimport { add3H, add3L, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL } from \"./_u64.js\";\nimport { blake2b } from \"./blake2.js\";\nimport { abytes, clean, kdfInputToBytes, nextTick, u32, u8 } from \"./utils.js\";\nconst AT = { Argond2d: 0, Argon2i: 1, Argon2id: 2 };\nconst ARGON2_SYNC_POINTS = 4;\nconst abytesOrZero = (buf) => {\n    if (buf === undefined)\n        return Uint8Array.of();\n    return kdfInputToBytes(buf);\n};\n// u32 * u32 = u64\nfunction mul(a, b) {\n    const aL = a & 0xffff;\n    const aH = a >>> 16;\n    const bL = b & 0xffff;\n    const bH = b >>> 16;\n    const ll = Math.imul(aL, bL);\n    const hl = Math.imul(aH, bL);\n    const lh = Math.imul(aL, bH);\n    const hh = Math.imul(aH, bH);\n    const carry = (ll >>> 16) + (hl & 0xffff) + lh;\n    const high = (hh + (hl >>> 16) + (carry >>> 16)) | 0;\n    const low = (carry << 16) | (ll & 0xffff);\n    return { h: high, l: low };\n}\nfunction mul2(a, b) {\n    // 2 * a * b (via shifts)\n    const { h, l } = mul(a, b);\n    return { h: ((h << 1) | (l >>> 31)) & 4294967295, l: (l << 1) & 4294967295 };\n}\n// BlaMka permutation for Argon2\n// A + B + (2 * u32(A) * u32(B))\nfunction blamka(Ah, Al, Bh, Bl) {\n    const { h: Ch, l: Cl } = mul2(Al, Bl);\n    // A + B + (2 * A * B)\n    const Rll = add3L(Al, Bl, Cl);\n    return { h: add3H(Rll, Ah, Bh, Ch), l: Rll | 0 };\n}\n// Temporary block buffer\nconst A2_BUF = new Uint32Array(256); // 1024 bytes (matrix 16x16)\nfunction G(a, b, c, d) {\n    let Al = A2_BUF[2 * a], Ah = A2_BUF[2 * a + 1]; // prettier-ignore\n    let Bl = A2_BUF[2 * b], Bh = A2_BUF[2 * b + 1]; // prettier-ignore\n    let Cl = A2_BUF[2 * c], Ch = A2_BUF[2 * c + 1]; // prettier-ignore\n    let Dl = A2_BUF[2 * d], Dh = A2_BUF[2 * d + 1]; // prettier-ignore\n    ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });\n    ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });\n    ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });\n    ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });\n    (A2_BUF[2 * a] = Al), (A2_BUF[2 * a + 1] = Ah);\n    (A2_BUF[2 * b] = Bl), (A2_BUF[2 * b + 1] = Bh);\n    (A2_BUF[2 * c] = Cl), (A2_BUF[2 * c + 1] = Ch);\n    (A2_BUF[2 * d] = Dl), (A2_BUF[2 * d + 1] = Dh);\n}\n// prettier-ignore\nfunction P(v00, v01, v02, v03, v04, v05, v06, v07, v08, v09, v10, v11, v12, v13, v14, v15) {\n    G(v00, v04, v08, v12);\n    G(v01, v05, v09, v13);\n    G(v02, v06, v10, v14);\n    G(v03, v07, v11, v15);\n    G(v00, v05, v10, v15);\n    G(v01, v06, v11, v12);\n    G(v02, v07, v08, v13);\n    G(v03, v04, v09, v14);\n}\nfunction block(x, xPos, yPos, outPos, needXor) {\n    for (let i = 0; i < 256; i++)\n        A2_BUF[i] = x[xPos + i] ^ x[yPos + i];\n    // columns (8)\n    for (let i = 0; i < 128; i += 16) {\n        // prettier-ignore\n        P(i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15);\n    }\n    // rows (8)\n    for (let i = 0; i < 16; i += 2) {\n        // prettier-ignore\n        P(i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49, i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113);\n    }\n    if (needXor)\n        for (let i = 0; i < 256; i++)\n            x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n    else\n        for (let i = 0; i < 256; i++)\n            x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n    clean(A2_BUF);\n}\n// Variable-Length Hash Function H'\nfunction Hp(A, dkLen) {\n    const A8 = u8(A);\n    const T = new Uint32Array(1);\n    const T8 = u8(T);\n    T[0] = dkLen;\n    // Fast path\n    if (dkLen <= 64)\n        return blake2b.create({ dkLen }).update(T8).update(A8).digest();\n    const out = new Uint8Array(dkLen);\n    let V = blake2b.create({}).update(T8).update(A8).digest();\n    let pos = 0;\n    // First block\n    out.set(V.subarray(0, 32));\n    pos += 32;\n    // Rest blocks\n    for (; dkLen - pos > 64; pos += 32) {\n        const Vh = blake2b.create({}).update(V);\n        Vh.digestInto(V);\n        Vh.destroy();\n        out.set(V.subarray(0, 32), pos);\n    }\n    // Last block\n    out.set(blake2b(V, { dkLen: dkLen - pos }), pos);\n    clean(V, T);\n    return u32(out);\n}\n// Used only inside process block!\nfunction indexAlpha(r, s, laneLen, segmentLen, index, randL, sameLane = false) {\n    // This is ugly, but close enough to reference implementation.\n    let area;\n    if (r === 0) {\n        if (s === 0)\n            area = index - 1;\n        else if (sameLane)\n            area = s * segmentLen + index - 1;\n        else\n            area = s * segmentLen + (index == 0 ? -1 : 0);\n    }\n    else if (sameLane)\n        area = laneLen - segmentLen + index - 1;\n    else\n        area = laneLen - segmentLen + (index == 0 ? -1 : 0);\n    const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;\n    const rel = area - 1 - mul(area, mul(randL, randL).h).h;\n    return (startPos + rel) % laneLen;\n}\nconst maxUint32 = Math.pow(2, 32);\nfunction isU32(num) {\n    return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;\n}\nfunction argon2Opts(opts) {\n    const merged = {\n        version: 0x13,\n        dkLen: 32,\n        maxmem: maxUint32 - 1,\n        asyncTick: 10,\n    };\n    for (let [k, v] of Object.entries(opts))\n        if (v != null)\n            merged[k] = v;\n    const { dkLen, p, m, t, version, onProgress } = merged;\n    if (!isU32(dkLen) || dkLen < 4)\n        throw new Error('dkLen should be at least 4 bytes');\n    if (!isU32(p) || p < 1 || p >= Math.pow(2, 24))\n        throw new Error('p should be 1 <= p < 2^24');\n    if (!isU32(m))\n        throw new Error('m should be 0 <= m < 2^32');\n    if (!isU32(t) || t < 1)\n        throw new Error('t (iterations) should be 1 <= t < 2^32');\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    /*\n    Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.\n    */\n    if (!isU32(m) || m < 8 * p)\n        throw new Error('memory should be at least 8*p bytes');\n    if (version !== 0x10 && version !== 0x13)\n        throw new Error('unknown version=' + version);\n    return merged;\n}\nfunction argon2Init(password, salt, type, opts) {\n    password = kdfInputToBytes(password);\n    salt = kdfInputToBytes(salt);\n    abytes(password);\n    abytes(salt);\n    if (!isU32(password.length))\n        throw new Error('password should be less than 4 GB');\n    if (!isU32(salt.length) || salt.length < 8)\n        throw new Error('salt should be at least 8 bytes and less than 4 GB');\n    if (!Object.values(AT).includes(type))\n        throw new Error('invalid type');\n    let { p, dkLen, m, t, version, key, personalization, maxmem, onProgress, asyncTick } = argon2Opts(opts);\n    // Validation\n    key = abytesOrZero(key);\n    personalization = abytesOrZero(personalization);\n    // H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n    //       LE32(v) || LE32(y) || LE32(length(P)) || P ||\n    //       LE32(length(S)) || S ||  LE32(length(K)) || K ||\n    //       LE32(length(X)) || X)\n    const h = blake2b.create({});\n    const BUF = new Uint32Array(1);\n    const BUF8 = u8(BUF);\n    for (let item of [p, dkLen, m, t, version, type]) {\n        BUF[0] = item;\n        h.update(BUF8);\n    }\n    for (let i of [password, salt, key, personalization]) {\n        BUF[0] = i.length; // BUF is u32 array, this is valid\n        h.update(BUF8).update(i);\n    }\n    const H0 = new Uint32Array(18);\n    const H0_8 = u8(H0);\n    h.digestInto(H0_8);\n    // 256 u32 = 1024 (BLOCK_SIZE), fills A2_BUF on processing\n    // Params\n    const lanes = p;\n    // m' = 4 * p * floor (m / 4p)\n    const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));\n    //q = m' / p columns\n    const laneLen = Math.floor(mP / p);\n    const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);\n    const memUsed = mP * 256;\n    if (!isU32(maxmem) || memUsed > maxmem)\n        throw new Error('mem should be less than 2**32, got: maxmem=' + maxmem + ', memused=' + memUsed);\n    const B = new Uint32Array(memUsed);\n    // Fill first blocks\n    for (let l = 0; l < p; l++) {\n        const i = 256 * laneLen * l;\n        // B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))\n        H0[17] = l;\n        H0[16] = 0;\n        B.set(Hp(H0, 1024), i);\n        // B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))\n        H0[16] = 1;\n        B.set(Hp(H0, 1024), i + 256);\n    }\n    let perBlock = () => { };\n    if (onProgress) {\n        const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlock / 10000), 1);\n        let blockCnt = 0;\n        perBlock = () => {\n            blockCnt++;\n            if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock))\n                onProgress(blockCnt / totalBlock);\n        };\n    }\n    clean(BUF, H0);\n    return { type, mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick };\n}\nfunction argon2Output(B, p, laneLen, dkLen) {\n    const B_final = new Uint32Array(256);\n    for (let l = 0; l < p; l++)\n        for (let j = 0; j < 256; j++)\n            B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];\n    const res = u8(Hp(B_final, dkLen));\n    clean(B_final);\n    return res;\n}\nfunction processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor) {\n    if (offset % laneLen)\n        prev = offset - 1;\n    let randL, randH;\n    if (dataIndependent) {\n        let i128 = index % 128;\n        if (i128 === 0) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n        }\n        randL = address[2 * i128];\n        randH = address[2 * i128 + 1];\n    }\n    else {\n        const T = 256 * prev;\n        randL = B[T];\n        randH = B[T + 1];\n    }\n    // address block\n    const refLane = r === 0 && s === 0 ? l : randH % lanes;\n    const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);\n    const refBlock = laneLen * refLane + refPos;\n    // B[i][j] = G(B[i][j-1], B[l][z])\n    block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);\n}\nfunction argon2(type, password, salt, opts) {\n    const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock } = argon2Init(password, salt, type, opts);\n    // Pre-loop setup\n    // [address, input, zero_block] format so we can pass single U32 to block function\n    const address = new Uint32Array(3 * 256);\n    address[256 + 6] = mP;\n    address[256 + 8] = t;\n    address[256 + 10] = type;\n    for (let r = 0; r < t; r++) {\n        const needXor = r !== 0 && version === 0x13;\n        address[256 + 0] = r;\n        for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n            address[256 + 4] = s;\n            const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n            for (let l = 0; l < p; l++) {\n                address[256 + 2] = l;\n                address[256 + 12] = 0;\n                let startPos = 0;\n                if (r === 0 && s === 0) {\n                    startPos = 2;\n                    if (dataIndependent) {\n                        address[256 + 12]++;\n                        block(address, 256, 2 * 256, 0, false);\n                        block(address, 0, 2 * 256, 0, false);\n                    }\n                }\n                // current block postion\n                let offset = l * laneLen + s * segmentLen + startPos;\n                // previous block position\n                let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n                for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n                    perBlock();\n                    processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor);\n                }\n            }\n        }\n    }\n    clean(address);\n    return argon2Output(B, p, laneLen, dkLen);\n}\n/** argon2d GPU-resistant version. */\nexport const argon2d = (password, salt, opts) => argon2(AT.Argond2d, password, salt, opts);\n/** argon2i side-channel-resistant version. */\nexport const argon2i = (password, salt, opts) => argon2(AT.Argon2i, password, salt, opts);\n/** argon2id, combining i+d, the most popular version from RFC 9106 */\nexport const argon2id = (password, salt, opts) => argon2(AT.Argon2id, password, salt, opts);\nasync function argon2Async(type, password, salt, opts) {\n    const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick } = argon2Init(password, salt, type, opts);\n    // Pre-loop setup\n    // [address, input, zero_block] format so we can pass single U32 to block function\n    const address = new Uint32Array(3 * 256);\n    address[256 + 6] = mP;\n    address[256 + 8] = t;\n    address[256 + 10] = type;\n    let ts = Date.now();\n    for (let r = 0; r < t; r++) {\n        const needXor = r !== 0 && version === 0x13;\n        address[256 + 0] = r;\n        for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n            address[256 + 4] = s;\n            const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n            for (let l = 0; l < p; l++) {\n                address[256 + 2] = l;\n                address[256 + 12] = 0;\n                let startPos = 0;\n                if (r === 0 && s === 0) {\n                    startPos = 2;\n                    if (dataIndependent) {\n                        address[256 + 12]++;\n                        block(address, 256, 2 * 256, 0, false);\n                        block(address, 0, 2 * 256, 0, false);\n                    }\n                }\n                // current block postion\n                let offset = l * laneLen + s * segmentLen + startPos;\n                // previous block position\n                let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n                for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n                    perBlock();\n                    processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor);\n                    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n                    const diff = Date.now() - ts;\n                    if (!(diff >= 0 && diff < asyncTick)) {\n                        await nextTick();\n                        ts += diff;\n                    }\n                }\n            }\n        }\n    }\n    clean(address);\n    return argon2Output(B, p, laneLen, dkLen);\n}\n/** argon2d async GPU-resistant version. */\nexport const argon2dAsync = (password, salt, opts) => argon2Async(AT.Argond2d, password, salt, opts);\n/** argon2i async side-channel-resistant version. */\nexport const argon2iAsync = (password, salt, opts) => argon2Async(AT.Argon2i, password, salt, opts);\n/** argon2id async, combining i+d, the most popular version from RFC 9106 */\nexport const argon2idAsync = (password, salt, opts) => argon2Async(AT.Argon2id, password, salt, opts);\n//# sourceMappingURL=argon2.js.map"
        }
    ]
}