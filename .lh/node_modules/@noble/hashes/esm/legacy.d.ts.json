{
    "sourceFile": "node_modules/@noble/hashes/esm/legacy.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891895429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { HashMD } from './_md.ts';\nimport { type CHash } from './utils.ts';\n/** SHA1 legacy hash class. */\nexport declare class SHA1 extends HashMD<SHA1> {\n    private A;\n    private B;\n    private C;\n    private D;\n    private E;\n    constructor();\n    protected get(): [number, number, number, number, number];\n    protected set(A: number, B: number, C: number, D: number, E: number): void;\n    protected process(view: DataView, offset: number): void;\n    protected roundClean(): void;\n    destroy(): void;\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport declare const sha1: CHash;\n/** MD5 legacy hash class. */\nexport declare class MD5 extends HashMD<MD5> {\n    private A;\n    private B;\n    private C;\n    private D;\n    constructor();\n    protected get(): [number, number, number, number];\n    protected set(A: number, B: number, C: number, D: number): void;\n    protected process(view: DataView, offset: number): void;\n    protected roundClean(): void;\n    destroy(): void;\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport declare const md5: CHash;\nexport declare class RIPEMD160 extends HashMD<RIPEMD160> {\n    private h0;\n    private h1;\n    private h2;\n    private h3;\n    private h4;\n    constructor();\n    protected get(): [number, number, number, number, number];\n    protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void;\n    protected process(view: DataView, offset: number): void;\n    protected roundClean(): void;\n    destroy(): void;\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport declare const ripemd160: CHash;\n//# sourceMappingURL=legacy.d.ts.map"
        }
    ]
}