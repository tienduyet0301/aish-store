{
    "sourceFile": "node_modules/es-to-primitive/test/es6.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892206744,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar test = require('tape');\nvar toPrimitive = require('../es6');\nvar is = require('object-is');\nvar forEach = require('for-each');\nvar functionName = require('function.prototype.name');\nvar debug = require('object-inspect');\nvar v = require('es-value-fixtures');\n\n/** @typedef {{ toString?: unknown, valueOf?: unknown, [Symbol.toPrimitive]?: unknown }} Coercible */\n\ntest('function properties', function (t) {\n\tt.equal(toPrimitive.length, 1, 'length is 1');\n\tt.equal(functionName(toPrimitive), 'ToPrimitive', 'name is ToPrimitive');\n\n\tt.end();\n});\n\ntest('primitives', function (t) {\n\tforEach(v.primitives, function (i) {\n\t\tt.ok(is(toPrimitive(i), i), 'toPrimitive(' + debug(i) + ') returns the same value');\n\t\tt.ok(is(toPrimitive(i, String), i), 'toPrimitive(' + debug(i) + ', String) returns the same value');\n\t\tt.ok(is(toPrimitive(i, Number), i), 'toPrimitive(' + debug(i) + ', Number) returns the same value');\n\t});\n\tt.end();\n});\n\ntest('Symbols', { skip: !v.hasSymbols }, function (t) {\n\tforEach(v.symbols, function (sym) {\n\t\tt.equal(toPrimitive(sym), sym, 'toPrimitive(' + debug(sym) + ') returns the same value');\n\t\tt.equal(toPrimitive(sym, String), sym, 'toPrimitive(' + debug(sym) + ', String) returns the same value');\n\t\tt.equal(toPrimitive(sym, Number), sym, 'toPrimitive(' + debug(sym) + ', Number) returns the same value');\n\t});\n\n\tvar primitiveSym = Symbol('primitiveSym');\n\tvar objectSym = Object(primitiveSym);\n\tt.equal(toPrimitive(objectSym), primitiveSym, 'toPrimitive(' + debug(objectSym) + ') returns ' + debug(primitiveSym));\n\tt.equal(toPrimitive(objectSym, String), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', String) returns ' + debug(primitiveSym));\n\tt.equal(toPrimitive(objectSym, Number), primitiveSym, 'toPrimitive(' + debug(objectSym) + ', Number) returns ' + debug(primitiveSym));\n\tt.end();\n});\n\ntest('Arrays', function (t) {\n\tvar arrays = [[], ['a', 'b'], [1, 2]];\n\tforEach(arrays, function (arr) {\n\t\tt.equal(toPrimitive(arr), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');\n\t\tt.equal(toPrimitive(arr, String), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');\n\t\tt.equal(toPrimitive(arr, Number), String(arr), 'toPrimitive(' + debug(arr) + ') returns the string version of the array');\n\t});\n\tt.end();\n});\n\ntest('Dates', function (t) {\n\tvar dates = [new Date(), new Date(0), new Date(NaN)];\n\tforEach(dates, function (date) {\n\t\tt.equal(toPrimitive(date), String(date), 'toPrimitive(' + debug(date) + ') returns the string version of the date');\n\t\tt.equal(toPrimitive(date, String), String(date), 'toPrimitive(' + debug(date) + ') returns the string version of the date');\n\t\tt.ok(is(toPrimitive(date, Number), Number(date)), 'toPrimitive(' + debug(date) + ') returns the number version of the date');\n\t});\n\tt.end();\n});\n\ntest('Objects', function (t) {\n\tt.equal(toPrimitive(v.coercibleObject), v.coercibleObject.valueOf(), 'coercibleObject with no hint coerces to valueOf');\n\tt.equal(toPrimitive(v.coercibleObject, Number), v.coercibleObject.valueOf(), 'coercibleObject with hint Number coerces to valueOf');\n\tt.equal(toPrimitive(v.coercibleObject, String), v.coercibleObject.toString(), 'coercibleObject with hint String coerces to non-stringified toString');\n\n\tt.equal(toPrimitive(v.coercibleFnObject), v.coercibleFnObject.toString(), 'coercibleFnObject coerces to non-stringified toString');\n\tt.equal(toPrimitive(v.coercibleFnObject, Number), v.coercibleFnObject.toString(), 'coercibleFnObject with hint Number coerces to non-stringified toString');\n\tt.equal(toPrimitive(v.coercibleFnObject, String), v.coercibleFnObject.toString(), 'coercibleFnObject with hint String coerces to non-stringified toString');\n\n\tt.equal(toPrimitive({}), '[object Object]', '{} with no hint coerces to Object#toString');\n\tt.equal(toPrimitive({}, Number), '[object Object]', '{} with hint Number coerces to Object#toString');\n\tt.equal(toPrimitive({}, String), '[object Object]', '{} with hint String coerces to Object#toString');\n\n\tt.equal(toPrimitive(v.toStringOnlyObject), v.toStringOnlyObject.toString(), 'toStringOnlyObject returns non-stringified toString');\n\tt.equal(toPrimitive(v.toStringOnlyObject, Number), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint Number returns non-stringified toString');\n\tt.equal(toPrimitive(v.toStringOnlyObject, String), v.toStringOnlyObject.toString(), 'toStringOnlyObject with hint String returns non-stringified toString');\n\n\tt.equal(toPrimitive(v.valueOfOnlyObject), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject returns valueOf');\n\tt.equal(toPrimitive(v.valueOfOnlyObject, Number), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint Number returns valueOf');\n\tt.equal(toPrimitive(v.valueOfOnlyObject, String), v.valueOfOnlyObject.valueOf(), 'valueOfOnlyObject with hint String returns non-stringified valueOf');\n\n\tt.test('Symbol.toPrimitive', { skip: !v.hasSymbols || !Symbol.toPrimitive }, function (st) {\n\t\t/** @type {Coercible} */\n\t\tvar overriddenObject = { toString: st.fail, valueOf: st.fail };\n\t\toverriddenObject[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {\n\t\t\treturn String(hint);\n\t\t};\n\n\t\tst.equal(toPrimitive(overriddenObject), 'default', 'object with Symbol.toPrimitive + no hint invokes that');\n\t\tst.equal(toPrimitive(overriddenObject, Number), 'number', 'object with Symbol.toPrimitive + hint Number invokes that');\n\t\tst.equal(toPrimitive(overriddenObject, String), 'string', 'object with Symbol.toPrimitive + hint String invokes that');\n\n\t\t/** @type {Coercible} */\n\t\tvar nullToPrimitive = { toString: v.coercibleObject.toString, valueOf: v.coercibleObject.valueOf };\n\t\tnullToPrimitive[Symbol.toPrimitive] = null;\n\t\tst.equal(toPrimitive(nullToPrimitive), toPrimitive(v.coercibleObject), 'object with no hint + null Symbol.toPrimitive ignores it');\n\t\tst.equal(toPrimitive(nullToPrimitive, Number), toPrimitive(v.coercibleObject, Number), 'object with hint Number + null Symbol.toPrimitive ignores it');\n\t\tst.equal(toPrimitive(nullToPrimitive, String), toPrimitive(v.coercibleObject, String), 'object with hint String + null Symbol.toPrimitive ignores it');\n\n\t\tst.test('exceptions', function (sst) {\n\t\t\t/** @type {Coercible} */\n\t\t\tvar nonFunctionToPrimitive = { toString: sst.fail, valueOf: sst.fail };\n\t\t\tnonFunctionToPrimitive[Symbol.toPrimitive] = {};\n\t\t\tsst['throws'](toPrimitive.bind(null, nonFunctionToPrimitive), TypeError, 'Symbol.toPrimitive returning a non-function throws');\n\n\t\t\t/** @type {Coercible} */\n\t\t\tvar uncoercibleToPrimitive = { toString: sst.fail, valueOf: sst.fail };\n\t\t\tuncoercibleToPrimitive[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {\n\t\t\t\treturn { toString: function () { return hint; } };\n\t\t\t};\n\t\t\tsst['throws'](toPrimitive.bind(null, uncoercibleToPrimitive), TypeError, 'Symbol.toPrimitive returning an object throws');\n\n\t\t\t/** @type {Coercible} */\n\t\t\tvar throwingToPrimitive = { toString: sst.fail, valueOf: sst.fail };\n\t\t\tthrowingToPrimitive[Symbol.toPrimitive] = /** @type {(hint: string) => unknown} */ function (hint) {\n\t\t\t\tthrow new RangeError(hint);\n\t\t\t};\n\t\t\tsst['throws'](toPrimitive.bind(null, throwingToPrimitive), RangeError, 'Symbol.toPrimitive throwing throws');\n\n\t\t\tsst.end();\n\t\t});\n\n\t\tst.end();\n\t});\n\n\tt.test('exceptions', function (st) {\n\t\tst['throws'](toPrimitive.bind(null, v.uncoercibleObject), TypeError, 'uncoercibleObject throws a TypeError');\n\t\tst['throws'](toPrimitive.bind(null, v.uncoercibleObject, Number), TypeError, 'uncoercibleObject with hint Number throws a TypeError');\n\t\tst['throws'](toPrimitive.bind(null, v.uncoercibleObject, String), TypeError, 'uncoercibleObject with hint String throws a TypeError');\n\n\t\tst['throws'](toPrimitive.bind(null, v.uncoercibleFnObject), TypeError, 'uncoercibleFnObject throws a TypeError');\n\t\tst['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, Number), TypeError, 'uncoercibleFnObject with hint Number throws a TypeError');\n\t\tst['throws'](toPrimitive.bind(null, v.uncoercibleFnObject, String), TypeError, 'uncoercibleFnObject with hint String throws a TypeError');\n\t\tst.end();\n\t});\n\tt.end();\n});\n"
        }
    ]
}