{
    "sourceFile": "node_modules/tsconfig-paths/src/match-path-sync.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893065353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as path from \"path\";\nimport * as Filesystem from \"./filesystem\";\nimport * as MappingEntry from \"./mapping-entry\";\nimport * as TryPath from \"./try-path\";\n\n/**\n * Function that can match a path\n */\nexport interface MatchPath {\n  (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: (name: string) => boolean,\n    extensions?: ReadonlyArray<string>\n  ): string | undefined;\n}\n\n/**\n * Creates a function that can resolve paths according to tsconfig paths property.\n * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.\n * @param paths The paths as specified in tsconfig.\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @param addMatchAll Add a match-all \"*\" rule if none is present\n * @returns a function that can resolve paths.\n */\nexport function createMatchPath(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPath {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: Filesystem.FileExistsSync,\n    extensions?: Array<string>\n  ) =>\n    matchFromAbsolutePaths(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      mainFields\n    );\n}\n\n/**\n * Finds a path from tsconfig that matches a module load request.\n * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.\n * @param requestedModule The required module name.\n * @param readJson Function that can read json from a path (useful for testing).\n * @param fileExists Function that checks for existence of a file at a path (useful for testing).\n * @param extensions File extensions to probe for (useful for testing).\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @returns the found path, or undefined if no path was found.\n */\nexport function matchFromAbsolutePaths(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,\n  extensions: Array<string> = Object.keys(require.extensions),\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return undefined;\n  }\n\n  return findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);\n}\n\nfunction findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExists: Filesystem.FileExistsSync\n): string | undefined {\n  for (let index = 0; index < mainFields.length; index++) {\n    const mainFieldName = mainFields[index];\n    const candidateMapping = packageJson[mainFieldName];\n    if (candidateMapping && typeof candidateMapping === \"string\") {\n      const candidateFilePath = path.join(\n        path.dirname(packageJsonPath),\n        candidateMapping\n      );\n      if (fileExists(candidateFilePath)) {\n        return candidateFilePath;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync,\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  for (const tryPath of tryPaths) {\n    if (\n      tryPath.type === \"file\" ||\n      tryPath.type === \"extension\" ||\n      tryPath.type === \"index\"\n    ) {\n      if (fileExists(tryPath.path)) {\n        return TryPath.getStrippedPath(tryPath);\n      }\n    } else if (tryPath.type === \"package\") {\n      const packageJson: Filesystem.PackageJson = readJson(tryPath.path);\n      if (packageJson) {\n        const mainFieldMappedFile = findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists\n        );\n        if (mainFieldMappedFile) {\n          return mainFieldMappedFile;\n        }\n      }\n    } else {\n      TryPath.exhaustiveTypeException(tryPath.type);\n    }\n  }\n  return undefined;\n}\n"
        }
    ]
}