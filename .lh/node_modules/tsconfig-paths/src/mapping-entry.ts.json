{
    "sourceFile": "node_modules/tsconfig-paths/src/mapping-entry.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893065218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as path from \"path\";\n\nexport interface MappingEntry {\n  readonly pattern: string;\n  readonly paths: ReadonlyArray<string>;\n}\n\nexport interface Paths {\n  readonly [key: string]: ReadonlyArray<string>;\n}\n\n/**\n * Converts an absolute baseUrl and paths to an array of absolute mapping entries.\n * The array is sorted by longest prefix.\n * Having an array with entries allows us to keep a sorting order rather than\n * sort by keys each time we use the mappings.\n * @param absoluteBaseUrl\n * @param paths\n * @param addMatchAll\n */\nexport function getAbsoluteMappingEntries(\n  absoluteBaseUrl: string,\n  paths: Paths,\n  addMatchAll: boolean\n): ReadonlyArray<MappingEntry> {\n  // Resolve all paths to absolute form once here, and sort them by\n  // longest prefix once here, this saves time on each request later.\n  // We need to put them in an array to preserve the sorting order.\n  const sortedKeys = sortByLongestPrefix(Object.keys(paths));\n  const absolutePaths: Array<MappingEntry> = [];\n  for (const key of sortedKeys) {\n    absolutePaths.push({\n      pattern: key,\n      paths: paths[key].map((pathToResolve) =>\n        path.join(absoluteBaseUrl, pathToResolve)\n      ),\n    });\n  }\n  // If there is no match-all path specified in the paths section of tsconfig, then try to match\n  // all paths relative to baseUrl, this is how typescript works.\n  if (!paths[\"*\"] && addMatchAll) {\n    absolutePaths.push({\n      pattern: \"*\",\n      paths: [`${absoluteBaseUrl.replace(/\\/$/, \"\")}/*`],\n    });\n  }\n\n  return absolutePaths;\n}\n\n/**\n * Sort path patterns.\n * If a module name can be matched with multiple patterns then pattern with the longest prefix will be picked.\n */\nfunction sortByLongestPrefix(arr: Array<string>): Array<string> {\n  return arr\n    .concat()\n    .sort((a: string, b: string) => getPrefixLength(b) - getPrefixLength(a));\n}\n\nfunction getPrefixLength(pattern: string): number {\n  const prefixLength = pattern.indexOf(\"*\");\n  return pattern.substr(0, prefixLength).length;\n}\n"
        }
    ]
}