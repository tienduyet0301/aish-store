{
    "sourceFile": "node_modules/tsconfig-paths/src/try-path.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893065578,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as path from \"path\";\nimport { MappingEntry } from \"./mapping-entry\";\nimport { dirname } from \"path\";\nimport { removeExtension } from \"./filesystem\";\n\nexport interface TryPath {\n  readonly type: \"file\" | \"extension\" | \"index\" | \"package\";\n  readonly path: string;\n}\n\n/**\n * Builds a list of all physical paths to try by:\n * 1. Check for file named exactly as request.\n * 2. Check for files named as request ending in any of the extensions.\n * 3. Check for file specified in package.json's main property.\n * 4. Check for files named as request ending in \"index\" with any of the extensions.\n */\nexport function getPathsToTry(\n  extensions: ReadonlyArray<string>,\n  absolutePathMappings: ReadonlyArray<MappingEntry>,\n  requestedModule: string\n): ReadonlyArray<TryPath> | undefined {\n  if (!absolutePathMappings || !requestedModule || requestedModule[0] === \".\") {\n    return undefined;\n  }\n\n  const pathsToTry: Array<TryPath> = [];\n  for (const entry of absolutePathMappings) {\n    const starMatch =\n      entry.pattern === requestedModule\n        ? \"\"\n        : matchStar(entry.pattern, requestedModule);\n    if (starMatch !== undefined) {\n      for (const physicalPathPattern of entry.paths) {\n        const physicalPath = physicalPathPattern.replace(\"*\", starMatch);\n        pathsToTry.push({ type: \"file\", path: physicalPath });\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"extension\", path: physicalPath + e } as TryPath)\n          )\n        );\n        pathsToTry.push({\n          type: \"package\",\n          path: path.join(physicalPath, \"/package.json\"),\n        });\n        const indexPath = path.join(physicalPath, \"/index\");\n        pathsToTry.push(\n          ...extensions.map(\n            (e) => ({ type: \"index\", path: indexPath + e } as TryPath)\n          )\n        );\n      }\n    }\n  }\n  return pathsToTry.length === 0 ? undefined : pathsToTry;\n}\n\n// Not sure why we don't just return the full found path?\nexport function getStrippedPath(tryPath: TryPath): string {\n  return tryPath.type === \"index\"\n    ? dirname(tryPath.path)\n    : tryPath.type === \"file\"\n    ? tryPath.path\n    : tryPath.type === \"extension\"\n    ? removeExtension(tryPath.path)\n    : tryPath.type === \"package\"\n    ? tryPath.path\n    : exhaustiveTypeException(tryPath.type);\n}\n\nexport function exhaustiveTypeException(check: never): never {\n  throw new Error(`Unknown type ${check}`);\n}\n\n/**\n * Matches pattern with a single star against search.\n * Star must match at least one character to be considered a match.\n * @param patttern for example \"foo*\"\n * @param search for example \"fooawesomebar\"\n * @returns the part of search that * matches, or undefined if no match.\n */\nfunction matchStar(pattern: string, search: string): string | undefined {\n  if (search.length < pattern.length) {\n    return undefined;\n  }\n  if (pattern === \"*\") {\n    return search;\n  }\n  const star = pattern.indexOf(\"*\");\n  if (star === -1) {\n    return undefined;\n  }\n  const part1 = pattern.substring(0, star);\n  const part2 = pattern.substring(star + 1);\n  if (search.substr(0, star) !== part1) {\n    return undefined;\n  }\n  if (search.substr(search.length - part2.length) !== part2) {\n    return undefined;\n  }\n  return search.substr(star, search.length - part2.length);\n}\n"
        }
    ]
}