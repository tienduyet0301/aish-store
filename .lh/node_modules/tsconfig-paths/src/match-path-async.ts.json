{
    "sourceFile": "node_modules/tsconfig-paths/src/match-path-async.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893065292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import * as path from \"path\";\nimport * as TryPath from \"./try-path\";\nimport * as MappingEntry from \"./mapping-entry\";\nimport * as Filesystem from \"./filesystem\";\n\n/**\n * Function that can match a path async\n */\nexport interface MatchPathAsync {\n  (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ): void;\n}\n\nexport interface MatchPathAsyncCallback {\n  (err?: Error, path?: string): void;\n}\n\n/**\n * See the sync version for docs.\n */\nexport function createMatchPathAsync(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPathAsync {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ) =>\n    matchFromAbsolutePathsAsync(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      callback,\n      mainFields\n    );\n}\n\n/**\n * See the sync version for docs.\n */\nexport function matchFromAbsolutePathsAsync(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonAsync = Filesystem.readJsonFromDiskAsync,\n  fileExists: Filesystem.FileExistsAsync = Filesystem.fileExistsAsync,\n  extensions: ReadonlyArray<string> = Object.keys(require.extensions),\n  callback: MatchPathAsyncCallback,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return callback();\n  }\n\n  findFirstExistingPath(\n    tryPaths,\n    readJson,\n    fileExists,\n    callback,\n    0,\n    mainFields\n  );\n}\n\nfunction findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExistsAsync: Filesystem.FileExistsAsync,\n  doneCallback: (err?: Error, filepath?: string) => void,\n  index: number = 0\n): void {\n  if (index >= mainFields.length) {\n    return doneCallback(undefined, undefined);\n  }\n\n  const tryNext = () =>\n    findFirstExistingMainFieldMappedFile(\n      packageJson,\n      mainFields,\n      packageJsonPath,\n      fileExistsAsync,\n      doneCallback,\n      index + 1\n    );\n\n  const mainFieldMapping = packageJson[mainFields[index]];\n  if (typeof mainFieldMapping !== \"string\") {\n    // Skip mappings that are not pointers to replacement files\n    return tryNext();\n  }\n\n  const mappedFilePath = path.join(\n    path.dirname(packageJsonPath),\n    mainFieldMapping\n  );\n  fileExistsAsync(mappedFilePath, (err?: Error, exists?: boolean) => {\n    if (err) {\n      return doneCallback(err);\n    }\n    if (exists) {\n      return doneCallback(undefined, mappedFilePath);\n    }\n    return tryNext();\n  });\n}\n\n// Recursive loop to probe for physical files\nfunction findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonAsync,\n  fileExists: Filesystem.FileExistsAsync,\n  doneCallback: MatchPathAsyncCallback,\n  index: number = 0,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPath = tryPaths[index];\n  if (\n    tryPath.type === \"file\" ||\n    tryPath.type === \"extension\" ||\n    tryPath.type === \"index\"\n  ) {\n    fileExists(tryPath.path, (err: Error, exists: boolean) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (exists) {\n        return doneCallback(undefined, TryPath.getStrippedPath(tryPath));\n      }\n      if (index === tryPaths.length - 1) {\n        return doneCallback();\n      }\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else if (tryPath.type === \"package\") {\n    readJson(tryPath.path, (err, packageJson) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (packageJson) {\n        return findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists,\n          (mainFieldErr?: Error, mainFieldMappedFile?: string) => {\n            if (mainFieldErr) {\n              return doneCallback(mainFieldErr);\n            }\n            if (mainFieldMappedFile) {\n              return doneCallback(undefined, mainFieldMappedFile);\n            }\n\n            // No field in package json was a valid option. Continue with the next path.\n            return findFirstExistingPath(\n              tryPaths,\n              readJson,\n              fileExists,\n              doneCallback,\n              index + 1,\n              mainFields\n            );\n          }\n        );\n      }\n\n      // This is async code, we need to return unconditionally, otherwise the code still falls\n      // through and keeps recursing. While this might work in general, libraries that use neo-async\n      // like Webpack will actually not allow you to call the same callback twice.\n      //\n      // An example of where this caused issues:\n      // https://github.com/dividab/tsconfig-paths-webpack-plugin/issues/11\n      //\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else {\n    TryPath.exhaustiveTypeException(tryPath.type);\n  }\n}\n"
        }
    ]
}