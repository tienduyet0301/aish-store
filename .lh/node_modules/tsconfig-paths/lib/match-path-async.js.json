{
    "sourceFile": "node_modules/tsconfig-paths/lib/match-path-async.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893060990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.matchFromAbsolutePathsAsync = exports.createMatchPathAsync = void 0;\nvar path = require(\"path\");\nvar TryPath = require(\"./try-path\");\nvar MappingEntry = require(\"./mapping-entry\");\nvar Filesystem = require(\"./filesystem\");\n/**\n * See the sync version for docs.\n */\nfunction createMatchPathAsync(absoluteBaseUrl, paths, mainFields, addMatchAll) {\n    if (mainFields === void 0) { mainFields = [\"main\"]; }\n    if (addMatchAll === void 0) { addMatchAll = true; }\n    var absolutePaths = MappingEntry.getAbsoluteMappingEntries(absoluteBaseUrl, paths, addMatchAll);\n    return function (requestedModule, readJson, fileExists, extensions, callback) {\n        return matchFromAbsolutePathsAsync(absolutePaths, requestedModule, readJson, fileExists, extensions, callback, mainFields);\n    };\n}\nexports.createMatchPathAsync = createMatchPathAsync;\n/**\n * See the sync version for docs.\n */\nfunction matchFromAbsolutePathsAsync(absolutePathMappings, requestedModule, readJson, fileExists, extensions, callback, mainFields) {\n    if (readJson === void 0) { readJson = Filesystem.readJsonFromDiskAsync; }\n    if (fileExists === void 0) { fileExists = Filesystem.fileExistsAsync; }\n    if (extensions === void 0) { extensions = Object.keys(require.extensions); }\n    if (mainFields === void 0) { mainFields = [\"main\"]; }\n    var tryPaths = TryPath.getPathsToTry(extensions, absolutePathMappings, requestedModule);\n    if (!tryPaths) {\n        return callback();\n    }\n    findFirstExistingPath(tryPaths, readJson, fileExists, callback, 0, mainFields);\n}\nexports.matchFromAbsolutePathsAsync = matchFromAbsolutePathsAsync;\nfunction findFirstExistingMainFieldMappedFile(packageJson, mainFields, packageJsonPath, fileExistsAsync, doneCallback, index) {\n    if (index === void 0) { index = 0; }\n    if (index >= mainFields.length) {\n        return doneCallback(undefined, undefined);\n    }\n    var tryNext = function () {\n        return findFirstExistingMainFieldMappedFile(packageJson, mainFields, packageJsonPath, fileExistsAsync, doneCallback, index + 1);\n    };\n    var mainFieldMapping = packageJson[mainFields[index]];\n    if (typeof mainFieldMapping !== \"string\") {\n        // Skip mappings that are not pointers to replacement files\n        return tryNext();\n    }\n    var mappedFilePath = path.join(path.dirname(packageJsonPath), mainFieldMapping);\n    fileExistsAsync(mappedFilePath, function (err, exists) {\n        if (err) {\n            return doneCallback(err);\n        }\n        if (exists) {\n            return doneCallback(undefined, mappedFilePath);\n        }\n        return tryNext();\n    });\n}\n// Recursive loop to probe for physical files\nfunction findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index, mainFields) {\n    if (index === void 0) { index = 0; }\n    if (mainFields === void 0) { mainFields = [\"main\"]; }\n    var tryPath = tryPaths[index];\n    if (tryPath.type === \"file\" ||\n        tryPath.type === \"extension\" ||\n        tryPath.type === \"index\") {\n        fileExists(tryPath.path, function (err, exists) {\n            if (err) {\n                return doneCallback(err);\n            }\n            if (exists) {\n                return doneCallback(undefined, TryPath.getStrippedPath(tryPath));\n            }\n            if (index === tryPaths.length - 1) {\n                return doneCallback();\n            }\n            // Continue with the next path\n            return findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index + 1, mainFields);\n        });\n    }\n    else if (tryPath.type === \"package\") {\n        readJson(tryPath.path, function (err, packageJson) {\n            if (err) {\n                return doneCallback(err);\n            }\n            if (packageJson) {\n                return findFirstExistingMainFieldMappedFile(packageJson, mainFields, tryPath.path, fileExists, function (mainFieldErr, mainFieldMappedFile) {\n                    if (mainFieldErr) {\n                        return doneCallback(mainFieldErr);\n                    }\n                    if (mainFieldMappedFile) {\n                        return doneCallback(undefined, mainFieldMappedFile);\n                    }\n                    // No field in package json was a valid option. Continue with the next path.\n                    return findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index + 1, mainFields);\n                });\n            }\n            // This is async code, we need to return unconditionally, otherwise the code still falls\n            // through and keeps recursing. While this might work in general, libraries that use neo-async\n            // like Webpack will actually not allow you to call the same callback twice.\n            //\n            // An example of where this caused issues:\n            // https://github.com/dividab/tsconfig-paths-webpack-plugin/issues/11\n            //\n            // Continue with the next path\n            return findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index + 1, mainFields);\n        });\n    }\n    else {\n        TryPath.exhaustiveTypeException(tryPath.type);\n    }\n}\n//# sourceMappingURL=match-path-async.js.map"
        }
    ]
}