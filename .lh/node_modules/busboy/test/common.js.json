{
    "sourceFile": "node_modules/busboy/test/common.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892065875,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nconst assert = require('assert');\nconst { inspect } = require('util');\n\nconst mustCallChecks = [];\n\nfunction noop() {}\n\nfunction runCallChecks(exitCode) {\n  if (exitCode !== 0) return;\n\n  const failed = mustCallChecks.filter((context) => {\n    if ('minimum' in context) {\n      context.messageSegment = `at least ${context.minimum}`;\n      return context.actual < context.minimum;\n    }\n    context.messageSegment = `exactly ${context.exact}`;\n    return context.actual !== context.exact;\n  });\n\n  failed.forEach((context) => {\n    console.error('Mismatched %s function calls. Expected %s, actual %d.',\n                  context.name,\n                  context.messageSegment,\n                  context.actual);\n    console.error(context.stack.split('\\n').slice(2).join('\\n'));\n  });\n\n  if (failed.length)\n    process.exit(1);\n}\n\nfunction mustCall(fn, exact) {\n  return _mustCallInner(fn, exact, 'exact');\n}\n\nfunction mustCallAtLeast(fn, minimum) {\n  return _mustCallInner(fn, minimum, 'minimum');\n}\n\nfunction _mustCallInner(fn, criteria = 1, field) {\n  if (process._exiting)\n    throw new Error('Cannot use common.mustCall*() in process exit handler');\n\n  if (typeof fn === 'number') {\n    criteria = fn;\n    fn = noop;\n  } else if (fn === undefined) {\n    fn = noop;\n  }\n\n  if (typeof criteria !== 'number')\n    throw new TypeError(`Invalid ${field} value: ${criteria}`);\n\n  const context = {\n    [field]: criteria,\n    actual: 0,\n    stack: inspect(new Error()),\n    name: fn.name || '<anonymous>'\n  };\n\n  // Add the exit listener only once to avoid listener leak warnings\n  if (mustCallChecks.length === 0)\n    process.on('exit', runCallChecks);\n\n  mustCallChecks.push(context);\n\n  function wrapped(...args) {\n    ++context.actual;\n    return fn.call(this, ...args);\n  }\n  // TODO: remove origFn?\n  wrapped.origFn = fn;\n\n  return wrapped;\n}\n\nfunction getCallSite(top) {\n  const originalStackFormatter = Error.prepareStackTrace;\n  Error.prepareStackTrace = (err, stack) =>\n    `${stack[0].getFileName()}:${stack[0].getLineNumber()}`;\n  const err = new Error();\n  Error.captureStackTrace(err, top);\n  // With the V8 Error API, the stack is not formatted until it is accessed\n  // eslint-disable-next-line no-unused-expressions\n  err.stack;\n  Error.prepareStackTrace = originalStackFormatter;\n  return err.stack;\n}\n\nfunction mustNotCall(msg) {\n  const callSite = getCallSite(mustNotCall);\n  return function mustNotCall(...args) {\n    args = args.map(inspect).join(', ');\n    const argsInfo = (args.length > 0\n                      ? `\\ncalled with arguments: ${args}`\n                      : '');\n    assert.fail(\n      `${msg || 'function should not have been called'} at ${callSite}`\n        + argsInfo);\n  };\n}\n\nmodule.exports = {\n  mustCall,\n  mustCallAtLeast,\n  mustNotCall,\n};\n"
        }
    ]
}