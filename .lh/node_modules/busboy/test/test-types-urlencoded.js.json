{
    "sourceFile": "node_modules/busboy/test/test-types-urlencoded.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892066251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nconst assert = require('assert');\nconst { transcode } = require('buffer');\nconst { inspect } = require('util');\n\nconst busboy = require('..');\n\nconst active = new Map();\n\nconst tests = [\n  { source: ['foo'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Unassigned value'\n  },\n  { source: ['foo=bar'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value'\n  },\n  { source: ['foo&bar=baz'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['bar',\n       'baz',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Unassigned and assigned value'\n  },\n  { source: ['foo=bar&baz'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned and unassigned value'\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       'bla',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two assigned values'\n  },\n  { source: ['foo&bar'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['bar',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two unassigned values'\n  },\n  { source: ['foo&bar&'],\n    expected: [\n      ['foo',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['bar',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two unassigned values and ampersand'\n  },\n  { source: ['foo+1=bar+baz%2Bquux'],\n    expected: [\n      ['foo 1',\n       'bar baz+quux',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned key and value with (plus) space'\n  },\n  { source: ['foo=bar%20baz%21'],\n    expected: [\n      ['foo',\n       'bar baz!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value with encoded bytes'\n  },\n  { source: ['foo%20bar=baz%20bla%21'],\n    expected: [\n      ['foo bar',\n       'baz bla!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value with encoded bytes #2'\n  },\n  { source: ['foo=bar%20baz%21&num=1000'],\n    expected: [\n      ['foo',\n       'bar baz!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['num',\n       '1000',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Two assigned values, one with encoded bytes'\n  },\n  { source: [\n      Array.from(transcode(Buffer.from('foo'), 'utf8', 'utf16le')).map(\n        (n) => `%${n.toString(16).padStart(2, '0')}`\n      ).join(''),\n      '=',\n      Array.from(transcode(Buffer.from('ðŸ˜€!'), 'utf8', 'utf16le')).map(\n        (n) => `%${n.toString(16).padStart(2, '0')}`\n      ).join(''),\n    ],\n    expected: [\n      ['foo',\n       'ðŸ˜€!',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'UTF-16LE',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    charset: 'UTF-16LE',\n    what: 'Encoded value with multi-byte charset'\n  },\n  { source: [\n      'foo=<',\n      Array.from(transcode(Buffer.from('Â©:^Ã¾'), 'utf8', 'latin1')).map(\n        (n) => `%${n.toString(16).padStart(2, '0')}`\n      ).join(''),\n    ],\n    expected: [\n      ['foo',\n       '<Â©:^Ã¾',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'ISO-8859-1',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    charset: 'ISO-8859-1',\n    what: 'Encoded value with single-byte, ASCII-compatible, non-UTF8 charset'\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [],\n    what: 'Limits: zero fields',\n    limits: { fields: 0 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: one field',\n    limits: { fields: 1 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'bar',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       'bla',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: field part lengths match limits',\n    limits: { fieldNameSize: 3, fieldSize: 3 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['fo',\n       'bar',\n       { nameTruncated: true,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['ba',\n       'bla',\n       { nameTruncated: true,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field name',\n    limits: { fieldNameSize: 2 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['foo',\n       'ba',\n       { nameTruncated: false,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['baz',\n       'bl',\n       { nameTruncated: false,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field value',\n    limits: { fieldSize: 2 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['fo',\n       'ba',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['ba',\n       'bl',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field name and value',\n    limits: { fieldNameSize: 2, fieldSize: 2 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['fo',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['ba',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated field name and zero value limit',\n    limits: { fieldNameSize: 2, fieldSize: 0 }\n  },\n  { source: ['foo=bar&baz=bla'],\n    expected: [\n      ['',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n      ['',\n       '',\n       { nameTruncated: true,\n         valueTruncated: true,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Limits: truncated zero field name and zero value limit',\n    limits: { fieldNameSize: 0, fieldSize: 0 }\n  },\n  { source: ['&'],\n    expected: [],\n    what: 'Ampersand'\n  },\n  { source: ['&&&&&'],\n    expected: [],\n    what: 'Many ampersands'\n  },\n  { source: ['='],\n    expected: [\n      ['',\n       '',\n       { nameTruncated: false,\n         valueTruncated: false,\n         encoding: 'utf-8',\n         mimeType: 'text/plain' },\n      ],\n    ],\n    what: 'Assigned value, empty name and value'\n  },\n  { source: [''],\n    expected: [],\n    what: 'Nothing'\n  },\n];\n\nfor (const test of tests) {\n  active.set(test, 1);\n\n  const { what } = test;\n  const charset = test.charset || 'utf-8';\n  const bb = busboy({\n    limits: test.limits,\n    headers: {\n      'content-type': `application/x-www-form-urlencoded; charset=${charset}`,\n    },\n  });\n  const results = [];\n\n  bb.on('field', (key, val, info) => {\n    results.push([key, val, info]);\n  });\n\n  bb.on('file', () => {\n    throw new Error(`[${what}] Unexpected file`);\n  });\n\n  bb.on('close', () => {\n    active.delete(test);\n\n    assert.deepStrictEqual(\n      results,\n      test.expected,\n      `[${what}] Results mismatch.\\n`\n        + `Parsed: ${inspect(results)}\\n`\n        + `Expected: ${inspect(test.expected)}`\n    );\n  });\n\n  for (const src of test.source) {\n    const buf = (typeof src === 'string' ? Buffer.from(src, 'utf8') : src);\n    bb.write(buf);\n  }\n  bb.end();\n}\n\n// Byte-by-byte versions\nfor (let test of tests) {\n  test = { ...test };\n  test.what += ' (byte-by-byte)';\n  active.set(test, 1);\n\n  const { what } = test;\n  const charset = test.charset || 'utf-8';\n  const bb = busboy({\n    limits: test.limits,\n    headers: {\n      'content-type': `application/x-www-form-urlencoded; charset=\"${charset}\"`,\n    },\n  });\n  const results = [];\n\n  bb.on('field', (key, val, info) => {\n    results.push([key, val, info]);\n  });\n\n  bb.on('file', () => {\n    throw new Error(`[${what}] Unexpected file`);\n  });\n\n  bb.on('close', () => {\n    active.delete(test);\n\n    assert.deepStrictEqual(\n      results,\n      test.expected,\n      `[${what}] Results mismatch.\\n`\n        + `Parsed: ${inspect(results)}\\n`\n        + `Expected: ${inspect(test.expected)}`\n    );\n  });\n\n  for (const src of test.source) {\n    const buf = (typeof src === 'string' ? Buffer.from(src, 'utf8') : src);\n    for (let i = 0; i < buf.length; ++i)\n      bb.write(buf.slice(i, i + 1));\n  }\n  bb.end();\n}\n\n{\n  let exception = false;\n  process.once('uncaughtException', (ex) => {\n    exception = true;\n    throw ex;\n  });\n  process.on('exit', () => {\n    if (exception || active.size === 0)\n      return;\n    process.exitCode = 1;\n    console.error('==========================');\n    console.error(`${active.size} test(s) did not finish:`);\n    console.error('==========================');\n    console.error(Array.from(active.keys()).map((v) => v.what).join('\\n'));\n  });\n}\n"
        }
    ]
}