{
    "sourceFile": "node_modules/busboy/bench/bench-multipart-fields-100mb-small.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892064738,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nfunction createMultipartBuffers(boundary, sizes) {\n  const bufs = [];\n  for (let i = 0; i < sizes.length; ++i) {\n    const mb = sizes[i] * 1024 * 1024;\n    bufs.push(Buffer.from([\n      `--${boundary}`,\n      `content-disposition: form-data; name=\"field${i + 1}\"`,\n      '',\n      '0'.repeat(mb),\n      '',\n    ].join('\\r\\n')));\n  }\n  bufs.push(Buffer.from([\n    `--${boundary}--`,\n    '',\n  ].join('\\r\\n')));\n  return bufs;\n}\n\nconst boundary = '-----------------------------168072824752491622650073';\nconst buffers = createMultipartBuffers(boundary, (new Array(100)).fill(1));\nconst calls = {\n  partBegin: 0,\n  headerField: 0,\n  headerValue: 0,\n  headerEnd: 0,\n  headersEnd: 0,\n  partData: 0,\n  partEnd: 0,\n  end: 0,\n};\n\nconst moduleName = process.argv[2];\nswitch (moduleName) {\n  case 'busboy': {\n    const busboy = require('busboy');\n\n    const parser = busboy({\n      limits: {\n        fieldSizeLimit: Infinity,\n      },\n      headers: {\n        'content-type': `multipart/form-data; boundary=${boundary}`,\n      },\n    });\n    parser.on('field', (name, val, info) => {\n      ++calls.partBegin;\n      ++calls.partData;\n      ++calls.partEnd;\n    }).on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n    break;\n  }\n\n  case 'formidable': {\n    const { MultipartParser } = require('formidable');\n\n    const parser = new MultipartParser();\n    parser.initWithBoundary(boundary);\n    parser.on('data', ({ name }) => {\n      ++calls[name];\n      if (name === 'end')\n        console.timeEnd(moduleName);\n    });\n\n    console.time(moduleName);\n    for (const buf of buffers)\n      parser.write(buf);\n\n    break;\n  }\n\n  case 'multiparty': {\n    const { Readable } = require('stream');\n\n    const { Form } = require('multiparty');\n\n    const form = new Form({\n      maxFieldsSize: Infinity,\n      maxFields: Infinity,\n      maxFilesSize: Infinity,\n      autoFields: false,\n      autoFiles: false,\n    });\n\n    const req = new Readable({ read: () => {} });\n    req.headers = {\n      'content-type': `multipart/form-data; boundary=${boundary}`,\n    };\n\n    function hijack(name, fn) {\n      const oldFn = form[name];\n      form[name] = function() {\n        fn();\n        return oldFn.apply(this, arguments);\n      };\n    }\n\n    hijack('onParseHeaderField', () => {\n      ++calls.headerField;\n    });\n    hijack('onParseHeaderValue', () => {\n      ++calls.headerValue;\n    });\n    hijack('onParsePartBegin', () => {\n      ++calls.partBegin;\n    });\n    hijack('onParsePartData', () => {\n      ++calls.partData;\n    });\n    hijack('onParsePartEnd', () => {\n      ++calls.partEnd;\n    });\n\n    form.on('close', () => {\n      ++calls.end;\n      console.timeEnd(moduleName);\n    }).on('part', (p) => p.resume());\n\n    console.time(moduleName);\n    form.parse(req);\n    for (const buf of buffers)\n      req.push(buf);\n    req.push(null);\n\n    break;\n  }\n\n  default:\n    if (moduleName === undefined)\n      console.error('Missing parser module name');\n    else\n      console.error(`Invalid parser module name: ${moduleName}`);\n    process.exit(1);\n}\n"
        }
    ]
}