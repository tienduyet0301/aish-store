{
    "sourceFile": "node_modules/typescript/lib/_tsserver.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893079131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// src/tsserver/server.ts\nvar import_os2 = __toESM(require(\"os\"));\n\n// src/typescript/typescript.ts\nvar typescript_exports = {};\n__reExport(typescript_exports, require(\"./typescript.js\"));\n\n// src/tsserver/nodeServer.ts\nvar import_child_process = __toESM(require(\"child_process\"));\nvar import_fs = __toESM(require(\"fs\"));\nvar import_net = __toESM(require(\"net\"));\nvar import_os = __toESM(require(\"os\"));\nvar import_readline = __toESM(require(\"readline\"));\n\n// src/tsserver/common.ts\nfunction getLogLevel(level) {\n  if (level) {\n    const l = level.toLowerCase();\n    for (const name in typescript_exports.server.LogLevel) {\n      if (isNaN(+name) && l === name.toLowerCase()) {\n        return typescript_exports.server.LogLevel[name];\n      }\n    }\n  }\n  return void 0;\n}\n\n// src/tsserver/nodeServer.ts\nfunction parseLoggingEnvironmentString(logEnvStr) {\n  if (!logEnvStr) {\n    return {};\n  }\n  const logEnv = { logToFile: true };\n  const args = logEnvStr.split(\" \");\n  const len = args.length - 1;\n  for (let i = 0; i < len; i += 2) {\n    const option = args[i];\n    const { value, extraPartCounter } = getEntireValue(i + 1);\n    i += extraPartCounter;\n    if (option && value) {\n      switch (option) {\n        case \"-file\":\n          logEnv.file = value;\n          break;\n        case \"-level\":\n          const level = getLogLevel(value);\n          logEnv.detailLevel = level !== void 0 ? level : typescript_exports.server.LogLevel.normal;\n          break;\n        case \"-traceToConsole\":\n          logEnv.traceToConsole = value.toLowerCase() === \"true\";\n          break;\n        case \"-logToFile\":\n          logEnv.logToFile = value.toLowerCase() === \"true\";\n          break;\n      }\n    }\n  }\n  return logEnv;\n  function getEntireValue(initialIndex) {\n    let pathStart = args[initialIndex];\n    let extraPartCounter = 0;\n    if (pathStart.charCodeAt(0) === typescript_exports.CharacterCodes.doubleQuote && pathStart.charCodeAt(pathStart.length - 1) !== typescript_exports.CharacterCodes.doubleQuote) {\n      for (let i = initialIndex + 1; i < args.length; i++) {\n        pathStart += \" \";\n        pathStart += args[i];\n        extraPartCounter++;\n        if (pathStart.charCodeAt(pathStart.length - 1) === typescript_exports.CharacterCodes.doubleQuote) break;\n      }\n    }\n    return { value: (0, typescript_exports.stripQuotes)(pathStart), extraPartCounter };\n  }\n}\nfunction parseServerMode() {\n  const mode = typescript_exports.server.findArgument(\"--serverMode\");\n  if (!mode) return void 0;\n  switch (mode.toLowerCase()) {\n    case \"semantic\":\n      return typescript_exports.LanguageServiceMode.Semantic;\n    case \"partialsemantic\":\n      return typescript_exports.LanguageServiceMode.PartialSemantic;\n    case \"syntactic\":\n      return typescript_exports.LanguageServiceMode.Syntactic;\n    default:\n      return mode;\n  }\n}\nfunction initializeNodeSystem() {\n  const sys4 = typescript_exports.Debug.checkDefined(typescript_exports.sys);\n  class Logger {\n    constructor(logFilename, traceToConsole, level) {\n      this.logFilename = logFilename;\n      this.traceToConsole = traceToConsole;\n      this.level = level;\n      this.seq = 0;\n      this.inGroup = false;\n      this.firstInGroup = true;\n      this.fd = -1;\n      if (this.logFilename) {\n        try {\n          this.fd = import_fs.default.openSync(this.logFilename, \"w\");\n        } catch {\n        }\n      }\n    }\n    static padStringRight(str, padding) {\n      return (str + padding).slice(0, padding.length);\n    }\n    close() {\n      if (this.fd >= 0) {\n        import_fs.default.close(this.fd, typescript_exports.noop);\n      }\n    }\n    getLogFileName() {\n      return this.logFilename;\n    }\n    perftrc(s) {\n      this.msg(s, typescript_exports.server.Msg.Perf);\n    }\n    info(s) {\n      this.msg(s, typescript_exports.server.Msg.Info);\n    }\n    err(s) {\n      this.msg(s, typescript_exports.server.Msg.Err);\n    }\n    startGroup() {\n      this.inGroup = true;\n      this.firstInGroup = true;\n    }\n    endGroup() {\n      this.inGroup = false;\n    }\n    loggingEnabled() {\n      return !!this.logFilename || this.traceToConsole;\n    }\n    hasLevel(level) {\n      return this.loggingEnabled() && this.level >= level;\n    }\n    msg(s, type = typescript_exports.server.Msg.Err) {\n      if (!this.canWrite()) return;\n      s = `[${typescript_exports.server.nowString()}] ${s}\n`;\n      if (!this.inGroup || this.firstInGroup) {\n        const prefix = Logger.padStringRight(type + \" \" + this.seq.toString(), \"          \");\n        s = prefix + s;\n      }\n      this.write(s, type);\n      if (!this.inGroup) {\n        this.seq++;\n      }\n    }\n    canWrite() {\n      return this.fd >= 0 || this.traceToConsole;\n    }\n    write(s, _type) {\n      if (this.fd >= 0) {\n        const buf = Buffer.from(s);\n        import_fs.default.writeSync(\n          this.fd,\n          buf,\n          0,\n          buf.length,\n          /*position*/\n          null\n        );\n      }\n      if (this.traceToConsole) {\n        console.warn(s);\n      }\n    }\n  }\n  const libDirectory = (0, typescript_exports.getDirectoryPath)((0, typescript_exports.normalizePath)(sys4.getExecutingFilePath()));\n  const useWatchGuard = process.platform === \"win32\";\n  const originalWatchDirectory = sys4.watchDirectory.bind(sys4);\n  const logger = createLogger();\n  typescript_exports.Debug.loggingHost = {\n    log(level, s) {\n      switch (level) {\n        case typescript_exports.LogLevel.Error:\n        case typescript_exports.LogLevel.Warning:\n          return logger.msg(s, typescript_exports.server.Msg.Err);\n        case typescript_exports.LogLevel.Info:\n        case typescript_exports.LogLevel.Verbose:\n          return logger.msg(s, typescript_exports.server.Msg.Info);\n      }\n    }\n  };\n  const pending = (0, typescript_exports.createQueue)();\n  let canWrite = true;\n  if (useWatchGuard) {\n    const currentDrive = extractWatchDirectoryCacheKey(\n      sys4.resolvePath(sys4.getCurrentDirectory()),\n      /*currentDriveKey*/\n      void 0\n    );\n    const statusCache = /* @__PURE__ */ new Map();\n    sys4.watchDirectory = (path, callback, recursive, options) => {\n      const cacheKey = extractWatchDirectoryCacheKey(path, currentDrive);\n      let status = cacheKey && statusCache.get(cacheKey);\n      if (status === void 0) {\n        if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {\n          logger.info(`${cacheKey} for path ${path} not found in cache...`);\n        }\n        try {\n          const args = [(0, typescript_exports.combinePaths)(libDirectory, \"watchGuard.js\"), path];\n          if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {\n            logger.info(`Starting ${process.execPath} with args:${typescript_exports.server.stringifyIndented(args)}`);\n          }\n          import_child_process.default.execFileSync(process.execPath, args, { stdio: \"ignore\", env: { ELECTRON_RUN_AS_NODE: \"1\" } });\n          status = true;\n          if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {\n            logger.info(`WatchGuard for path ${path} returned: OK`);\n          }\n        } catch (e) {\n          status = false;\n          if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {\n            logger.info(`WatchGuard for path ${path} returned: ${e.message}`);\n          }\n        }\n        if (cacheKey) {\n          statusCache.set(cacheKey, status);\n        }\n      } else if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {\n        logger.info(`watchDirectory for ${path} uses cached drive information.`);\n      }\n      if (status) {\n        return watchDirectorySwallowingException(path, callback, recursive, options);\n      } else {\n        return typescript_exports.noopFileWatcher;\n      }\n    };\n  } else {\n    sys4.watchDirectory = watchDirectorySwallowingException;\n  }\n  sys4.write = (s) => writeMessage(Buffer.from(s, \"utf8\"));\n  sys4.setTimeout = setTimeout;\n  sys4.clearTimeout = clearTimeout;\n  sys4.setImmediate = setImmediate;\n  sys4.clearImmediate = clearImmediate;\n  if (typeof global !== \"undefined\" && global.gc) {\n    sys4.gc = () => {\n      var _a;\n      return (_a = global.gc) == null ? void 0 : _a.call(global);\n    };\n  }\n  const cancellationToken = createCancellationToken(sys4.args);\n  const localeStr = typescript_exports.server.findArgument(\"--locale\");\n  if (localeStr) {\n    (0, typescript_exports.validateLocaleAndSetLanguage)(localeStr, sys4);\n  }\n  const modeOrUnknown = parseServerMode();\n  let serverMode;\n  let unknownServerMode;\n  if (modeOrUnknown !== void 0) {\n    if (typeof modeOrUnknown === \"number\") serverMode = modeOrUnknown;\n    else unknownServerMode = modeOrUnknown;\n  }\n  return {\n    args: process.argv,\n    logger,\n    cancellationToken,\n    serverMode,\n    unknownServerMode,\n    startSession: startNodeSession\n  };\n  function createLogger() {\n    const cmdLineLogFileName = typescript_exports.server.findArgument(\"--logFile\");\n    const cmdLineVerbosity = getLogLevel(typescript_exports.server.findArgument(\"--logVerbosity\"));\n    const envLogOptions = parseLoggingEnvironmentString(process.env.TSS_LOG);\n    const unsubstitutedLogFileName = cmdLineLogFileName ? (0, typescript_exports.stripQuotes)(cmdLineLogFileName) : envLogOptions.logToFile ? envLogOptions.file || libDirectory + \"/.log\" + process.pid.toString() : void 0;\n    const substitutedLogFileName = unsubstitutedLogFileName ? unsubstitutedLogFileName.replace(\"PID\", process.pid.toString()) : void 0;\n    const logVerbosity = cmdLineVerbosity || envLogOptions.detailLevel;\n    return new Logger(substitutedLogFileName, envLogOptions.traceToConsole, logVerbosity);\n  }\n  function writeMessage(buf) {\n    if (!canWrite) {\n      pending.enqueue(buf);\n    } else {\n      canWrite = false;\n      process.stdout.write(buf, setCanWriteFlagAndWriteMessageIfNecessary);\n    }\n  }\n  function setCanWriteFlagAndWriteMessageIfNecessary() {\n    canWrite = true;\n    if (!pending.isEmpty()) {\n      writeMessage(pending.dequeue());\n    }\n  }\n  function extractWatchDirectoryCacheKey(path, currentDriveKey) {\n    path = (0, typescript_exports.normalizeSlashes)(path);\n    if (isUNCPath(path)) {\n      const firstSlash = path.indexOf(typescript_exports.directorySeparator, 2);\n      return firstSlash !== -1 ? (0, typescript_exports.toFileNameLowerCase)(path.substring(0, firstSlash)) : path;\n    }\n    const rootLength = (0, typescript_exports.getRootLength)(path);\n    if (rootLength === 0) {\n      return currentDriveKey;\n    }\n    if (path.charCodeAt(1) === typescript_exports.CharacterCodes.colon && path.charCodeAt(2) === typescript_exports.CharacterCodes.slash) {\n      return (0, typescript_exports.toFileNameLowerCase)(path.charAt(0));\n    }\n    if (path.charCodeAt(0) === typescript_exports.CharacterCodes.slash && path.charCodeAt(1) !== typescript_exports.CharacterCodes.slash) {\n      return currentDriveKey;\n    }\n    return void 0;\n  }\n  function isUNCPath(s) {\n    return s.length > 2 && s.charCodeAt(0) === typescript_exports.CharacterCodes.slash && s.charCodeAt(1) === typescript_exports.CharacterCodes.slash;\n  }\n  function watchDirectorySwallowingException(path, callback, recursive, options) {\n    try {\n      return originalWatchDirectory(path, callback, recursive, options);\n    } catch (e) {\n      logger.info(`Exception when creating directory watcher: ${e.message}`);\n      return typescript_exports.noopFileWatcher;\n    }\n  }\n}\nfunction parseEventPort(eventPortStr) {\n  const eventPort = eventPortStr === void 0 ? void 0 : parseInt(eventPortStr);\n  return eventPort !== void 0 && !isNaN(eventPort) ? eventPort : void 0;\n}\nfunction startNodeSession(options, logger, cancellationToken) {\n  const rl = import_readline.default.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n    terminal: false\n  });\n  const _NodeTypingsInstallerAdapter = class _NodeTypingsInstallerAdapter extends typescript_exports.server.TypingsInstallerAdapter {\n    constructor(telemetryEnabled2, logger2, host, globalTypingsCacheLocation, typingSafeListLocation2, typesMapLocation2, npmLocation2, validateDefaultNpmLocation2, event) {\n      super(\n        telemetryEnabled2,\n        logger2,\n        host,\n        globalTypingsCacheLocation,\n        event,\n        _NodeTypingsInstallerAdapter.maxActiveRequestCount\n      );\n      this.typingSafeListLocation = typingSafeListLocation2;\n      this.typesMapLocation = typesMapLocation2;\n      this.npmLocation = npmLocation2;\n      this.validateDefaultNpmLocation = validateDefaultNpmLocation2;\n    }\n    createInstallerProcess() {\n      if (this.logger.hasLevel(typescript_exports.server.LogLevel.requestTime)) {\n        this.logger.info(\"Binding...\");\n      }\n      const args = [typescript_exports.server.Arguments.GlobalCacheLocation, this.globalTypingsCacheLocation];\n      if (this.telemetryEnabled) {\n        args.push(typescript_exports.server.Arguments.EnableTelemetry);\n      }\n      if (this.logger.loggingEnabled() && this.logger.getLogFileName()) {\n        args.push(typescript_exports.server.Arguments.LogFile, (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)((0, typescript_exports.normalizeSlashes)(this.logger.getLogFileName())), `ti-${process.pid}.log`));\n      }\n      if (this.typingSafeListLocation) {\n        args.push(typescript_exports.server.Arguments.TypingSafeListLocation, this.typingSafeListLocation);\n      }\n      if (this.typesMapLocation) {\n        args.push(typescript_exports.server.Arguments.TypesMapLocation, this.typesMapLocation);\n      }\n      if (this.npmLocation) {\n        args.push(typescript_exports.server.Arguments.NpmLocation, this.npmLocation);\n      }\n      if (this.validateDefaultNpmLocation) {\n        args.push(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);\n      }\n      const execArgv = [];\n      for (const arg of process.execArgv) {\n        const match = /^--((?:debug|inspect)(?:-brk)?)(?:=(\\d+))?$/.exec(arg);\n        if (match) {\n          const currentPort = match[2] !== void 0 ? +match[2] : match[1].charAt(0) === \"d\" ? 5858 : 9229;\n          execArgv.push(`--${match[1]}=${currentPort + 1}`);\n          break;\n        }\n      }\n      const typingsInstaller = (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), \"typingsInstaller.js\");\n      this.installer = import_child_process.default.fork(typingsInstaller, args, { execArgv });\n      this.installer.on(\"message\", (m) => this.handleMessage(m));\n      this.host.setImmediate(() => this.event({ pid: this.installer.pid }, \"typingsInstallerPid\"));\n      process.on(\"exit\", () => {\n        this.installer.kill();\n      });\n      return this.installer;\n    }\n  };\n  // This number is essentially arbitrary.  Processing more than one typings request\n  // at a time makes sense, but having too many in the pipe results in a hang\n  // (see https://github.com/nodejs/node/issues/7657).\n  // It would be preferable to base our limit on the amount of space left in the\n  // buffer, but we have yet to find a way to retrieve that value.\n  _NodeTypingsInstallerAdapter.maxActiveRequestCount = 10;\n  let NodeTypingsInstallerAdapter = _NodeTypingsInstallerAdapter;\n  class IOSession extends typescript_exports.server.Session {\n    constructor() {\n      const event = (body, eventName) => {\n        this.event(body, eventName);\n      };\n      const host = typescript_exports.sys;\n      const typingsInstaller = disableAutomaticTypingAcquisition ? void 0 : new NodeTypingsInstallerAdapter(telemetryEnabled, logger, host, getGlobalTypingsCacheLocation(), typingSafeListLocation, typesMapLocation, npmLocation, validateDefaultNpmLocation, event);\n      super({\n        host,\n        cancellationToken,\n        ...options,\n        typingsInstaller,\n        byteLength: Buffer.byteLength,\n        hrtime: process.hrtime,\n        logger,\n        canUseEvents: true,\n        typesMapLocation\n      });\n      this.eventPort = eventPort;\n      if (this.canUseEvents && this.eventPort) {\n        const s = import_net.default.connect({ port: this.eventPort }, () => {\n          this.eventSocket = s;\n          if (this.socketEventQueue) {\n            for (const event2 of this.socketEventQueue) {\n              this.writeToEventSocket(event2.body, event2.eventName);\n            }\n            this.socketEventQueue = void 0;\n          }\n        });\n      }\n      this.constructed = true;\n    }\n    event(body, eventName) {\n      typescript_exports.Debug.assert(!!this.constructed, \"Should only call `IOSession.prototype.event` on an initialized IOSession\");\n      if (this.canUseEvents && this.eventPort) {\n        if (!this.eventSocket) {\n          if (this.logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {\n            this.logger.info(`eventPort: event \"${eventName}\" queued, but socket not yet initialized`);\n          }\n          (this.socketEventQueue || (this.socketEventQueue = [])).push({ body, eventName });\n          return;\n        } else {\n          typescript_exports.Debug.assert(this.socketEventQueue === void 0);\n          this.writeToEventSocket(body, eventName);\n        }\n      } else {\n        super.event(body, eventName);\n      }\n    }\n    writeToEventSocket(body, eventName) {\n      this.eventSocket.write(typescript_exports.server.formatMessage(typescript_exports.server.toEvent(eventName, body), this.logger, this.byteLength, this.host.newLine), \"utf8\");\n    }\n    exit() {\n      var _a;\n      this.logger.info(\"Exiting...\");\n      this.projectService.closeLog();\n      (_a = typescript_exports.tracing) == null ? void 0 : _a.stopTracing();\n      process.exit(0);\n    }\n    listen() {\n      rl.on(\"line\", (input) => {\n        const message = input.trim();\n        this.onMessage(message);\n      });\n      rl.on(\"close\", () => {\n        this.exit();\n      });\n    }\n  }\n  class IpcIOSession extends IOSession {\n    writeMessage(msg) {\n      const verboseLogging = logger.hasLevel(typescript_exports.server.LogLevel.verbose);\n      if (verboseLogging) {\n        const json = JSON.stringify(msg);\n        logger.info(`${msg.type}:${typescript_exports.server.indent(json)}`);\n      }\n      process.send(msg);\n    }\n    parseMessage(message) {\n      return message;\n    }\n    toStringMessage(message) {\n      return JSON.stringify(message, void 0, 2);\n    }\n    listen() {\n      process.on(\"message\", (e) => {\n        this.onMessage(e);\n      });\n      process.on(\"disconnect\", () => {\n        this.exit();\n      });\n    }\n  }\n  const eventPort = parseEventPort(typescript_exports.server.findArgument(\"--eventPort\"));\n  const typingSafeListLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypingSafeListLocation);\n  const typesMapLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypesMapLocation) || (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), \"typesMap.json\");\n  const npmLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.NpmLocation);\n  const validateDefaultNpmLocation = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);\n  const disableAutomaticTypingAcquisition = typescript_exports.server.hasArgument(\"--disableAutomaticTypingAcquisition\");\n  const useNodeIpc = typescript_exports.server.hasArgument(\"--useNodeIpc\");\n  const telemetryEnabled = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.EnableTelemetry);\n  const commandLineTraceDir = typescript_exports.server.findArgument(\"--traceDirectory\");\n  const traceDir = commandLineTraceDir ? (0, typescript_exports.stripQuotes)(commandLineTraceDir) : process.env.TSS_TRACE;\n  if (traceDir) {\n    (0, typescript_exports.startTracing)(\"server\", traceDir);\n  }\n  const ioSession = useNodeIpc ? new IpcIOSession() : new IOSession();\n  process.on(\"uncaughtException\", (err) => {\n    ioSession.logError(err, \"unknown\");\n  });\n  process.noAsar = true;\n  ioSession.listen();\n  function getGlobalTypingsCacheLocation() {\n    switch (process.platform) {\n      case \"win32\": {\n        const basePath = process.env.LOCALAPPDATA || process.env.APPDATA || import_os.default.homedir && import_os.default.homedir() || process.env.USERPROFILE || process.env.HOMEDRIVE && process.env.HOMEPATH && (0, typescript_exports.normalizeSlashes)(process.env.HOMEDRIVE + process.env.HOMEPATH) || import_os.default.tmpdir();\n        return (0, typescript_exports.combinePaths)((0, typescript_exports.combinePaths)((0, typescript_exports.normalizeSlashes)(basePath), \"Microsoft/TypeScript\"), typescript_exports.versionMajorMinor);\n      }\n      case \"openbsd\":\n      case \"freebsd\":\n      case \"netbsd\":\n      case \"darwin\":\n      case \"linux\":\n      case \"android\": {\n        const cacheLocation = getNonWindowsCacheLocation(process.platform === \"darwin\");\n        return (0, typescript_exports.combinePaths)((0, typescript_exports.combinePaths)(cacheLocation, \"typescript\"), typescript_exports.versionMajorMinor);\n      }\n      default:\n        return typescript_exports.Debug.fail(`unsupported platform '${process.platform}'`);\n    }\n  }\n  function getNonWindowsCacheLocation(platformIsDarwin) {\n    if (process.env.XDG_CACHE_HOME) {\n      return process.env.XDG_CACHE_HOME;\n    }\n    const usersDir = platformIsDarwin ? \"Users\" : \"home\";\n    const homePath = import_os.default.homedir && import_os.default.homedir() || process.env.HOME || (process.env.LOGNAME || process.env.USER) && `/${usersDir}/${process.env.LOGNAME || process.env.USER}` || import_os.default.tmpdir();\n    const cacheFolder = platformIsDarwin ? \"Library/Caches\" : \".cache\";\n    return (0, typescript_exports.combinePaths)((0, typescript_exports.normalizeSlashes)(homePath), cacheFolder);\n  }\n}\nfunction pipeExists(name) {\n  return import_fs.default.existsSync(name);\n}\nfunction createCancellationToken(args) {\n  let cancellationPipeName;\n  for (let i = 0; i < args.length - 1; i++) {\n    if (args[i] === \"--cancellationPipeName\") {\n      cancellationPipeName = args[i + 1];\n      break;\n    }\n  }\n  if (!cancellationPipeName) {\n    return typescript_exports.server.nullCancellationToken;\n  }\n  if (cancellationPipeName.charAt(cancellationPipeName.length - 1) === \"*\") {\n    const namePrefix = cancellationPipeName.slice(0, -1);\n    if (namePrefix.length === 0 || namePrefix.includes(\"*\")) {\n      throw new Error(\"Invalid name for template cancellation pipe: it should have length greater than 2 characters and contain only one '*'.\");\n    }\n    let perRequestPipeName;\n    let currentRequestId;\n    return {\n      isCancellationRequested: () => perRequestPipeName !== void 0 && pipeExists(perRequestPipeName),\n      setRequest(requestId) {\n        currentRequestId = requestId;\n        perRequestPipeName = namePrefix + requestId;\n      },\n      resetRequest(requestId) {\n        if (currentRequestId !== requestId) {\n          throw new Error(`Mismatched request id, expected ${currentRequestId}, actual ${requestId}`);\n        }\n        perRequestPipeName = void 0;\n      }\n    };\n  } else {\n    return {\n      isCancellationRequested: () => pipeExists(cancellationPipeName),\n      setRequest: (_requestId) => void 0,\n      resetRequest: (_requestId) => void 0\n    };\n  }\n}\n\n// src/tsserver/server.ts\nfunction findArgumentStringArray(argName) {\n  const arg = typescript_exports.server.findArgument(argName);\n  if (arg === void 0) {\n    return typescript_exports.emptyArray;\n  }\n  return arg.split(\",\").filter((name) => name !== \"\");\n}\nfunction start({ args, logger, cancellationToken, serverMode, unknownServerMode, startSession: startServer }, platform) {\n  logger.info(`Starting TS Server`);\n  logger.info(`Version: ${typescript_exports.version}`);\n  logger.info(`Arguments: ${args.join(\" \")}`);\n  logger.info(`Platform: ${platform} NodeVersion: ${process.version} CaseSensitive: ${typescript_exports.sys.useCaseSensitiveFileNames}`);\n  logger.info(`ServerMode: ${serverMode} hasUnknownServerMode: ${unknownServerMode}`);\n  typescript_exports.setStackTraceLimit();\n  if (typescript_exports.Debug.isDebugging) {\n    typescript_exports.Debug.enableDebugInfo();\n  }\n  if (typescript_exports.sys.tryEnableSourceMapsForHost && /^development$/i.test(typescript_exports.sys.getEnvironmentVariable(\"NODE_ENV\"))) {\n    typescript_exports.sys.tryEnableSourceMapsForHost();\n  }\n  console.log = (...args2) => logger.msg(args2.length === 1 ? args2[0] : args2.join(\", \"), typescript_exports.server.Msg.Info);\n  console.warn = (...args2) => logger.msg(args2.length === 1 ? args2[0] : args2.join(\", \"), typescript_exports.server.Msg.Err);\n  console.error = (...args2) => logger.msg(args2.length === 1 ? args2[0] : args2.join(\", \"), typescript_exports.server.Msg.Err);\n  startServer(\n    {\n      globalPlugins: findArgumentStringArray(\"--globalPlugins\"),\n      pluginProbeLocations: findArgumentStringArray(\"--pluginProbeLocations\"),\n      allowLocalPluginLoads: typescript_exports.server.hasArgument(\"--allowLocalPluginLoads\"),\n      useSingleInferredProject: typescript_exports.server.hasArgument(\"--useSingleInferredProject\"),\n      useInferredProjectPerProjectRoot: typescript_exports.server.hasArgument(\"--useInferredProjectPerProjectRoot\"),\n      suppressDiagnosticEvents: typescript_exports.server.hasArgument(\"--suppressDiagnosticEvents\"),\n      noGetErrOnBackgroundUpdate: typescript_exports.server.hasArgument(\"--noGetErrOnBackgroundUpdate\"),\n      canUseWatchEvents: typescript_exports.server.hasArgument(\"--canUseWatchEvents\"),\n      serverMode\n    },\n    logger,\n    cancellationToken\n  );\n}\ntypescript_exports.setStackTraceLimit();\nstart(initializeNodeSystem(), import_os2.default.platform());\n//# sourceMappingURL=_tsserver.js.map\n"
        }
    ]
}