{
    "sourceFile": "node_modules/typescript/lib/typescript.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893077680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\ndeclare namespace ts {\n    namespace server {\n        namespace protocol {\n            export import ApplicableRefactorInfo = ts.ApplicableRefactorInfo;\n            export import ClassificationType = ts.ClassificationType;\n            export import CompletionsTriggerCharacter = ts.CompletionsTriggerCharacter;\n            export import CompletionTriggerKind = ts.CompletionTriggerKind;\n            export import InlayHintKind = ts.InlayHintKind;\n            export import OrganizeImportsMode = ts.OrganizeImportsMode;\n            export import RefactorActionInfo = ts.RefactorActionInfo;\n            export import RefactorTriggerReason = ts.RefactorTriggerReason;\n            export import RenameInfoFailure = ts.RenameInfoFailure;\n            export import SemicolonPreference = ts.SemicolonPreference;\n            export import SignatureHelpCharacterTypedReason = ts.SignatureHelpCharacterTypedReason;\n            export import SignatureHelpInvokedReason = ts.SignatureHelpInvokedReason;\n            export import SignatureHelpParameter = ts.SignatureHelpParameter;\n            export import SignatureHelpRetriggerCharacter = ts.SignatureHelpRetriggerCharacter;\n            export import SignatureHelpRetriggeredReason = ts.SignatureHelpRetriggeredReason;\n            export import SignatureHelpTriggerCharacter = ts.SignatureHelpTriggerCharacter;\n            export import SignatureHelpTriggerReason = ts.SignatureHelpTriggerReason;\n            export import SymbolDisplayPart = ts.SymbolDisplayPart;\n            export import UserPreferences = ts.UserPreferences;\n            type ChangePropertyTypes<\n                T,\n                Substitutions extends {\n                    [K in keyof T]?: any;\n                },\n            > = {\n                [K in keyof T]: K extends keyof Substitutions ? Substitutions[K] : T[K];\n            };\n            type ChangeStringIndexSignature<T, NewStringIndexSignatureType> = {\n                [K in keyof T]: string extends K ? NewStringIndexSignatureType : T[K];\n            };\n            export enum CommandTypes {\n                JsxClosingTag = \"jsxClosingTag\",\n                LinkedEditingRange = \"linkedEditingRange\",\n                Brace = \"brace\",\n                BraceCompletion = \"braceCompletion\",\n                GetSpanOfEnclosingComment = \"getSpanOfEnclosingComment\",\n                Change = \"change\",\n                Close = \"close\",\n                /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */\n                Completions = \"completions\",\n                CompletionInfo = \"completionInfo\",\n                CompletionDetails = \"completionEntryDetails\",\n                CompileOnSaveAffectedFileList = \"compileOnSaveAffectedFileList\",\n                CompileOnSaveEmitFile = \"compileOnSaveEmitFile\",\n                Configure = \"configure\",\n                Definition = \"definition\",\n                DefinitionAndBoundSpan = \"definitionAndBoundSpan\",\n                Implementation = \"implementation\",\n                Exit = \"exit\",\n                FileReferences = \"fileReferences\",\n                Format = \"format\",\n                Formatonkey = \"formatonkey\",\n                Geterr = \"geterr\",\n                GeterrForProject = \"geterrForProject\",\n                SemanticDiagnosticsSync = \"semanticDiagnosticsSync\",\n                SyntacticDiagnosticsSync = \"syntacticDiagnosticsSync\",\n                SuggestionDiagnosticsSync = \"suggestionDiagnosticsSync\",\n                NavBar = \"navbar\",\n                Navto = \"navto\",\n                NavTree = \"navtree\",\n                NavTreeFull = \"navtree-full\",\n                DocumentHighlights = \"documentHighlights\",\n                Open = \"open\",\n                Quickinfo = \"quickinfo\",\n                References = \"references\",\n                Reload = \"reload\",\n                Rename = \"rename\",\n                Saveto = \"saveto\",\n                SignatureHelp = \"signatureHelp\",\n                FindSourceDefinition = \"findSourceDefinition\",\n                Status = \"status\",\n                TypeDefinition = \"typeDefinition\",\n                ProjectInfo = \"projectInfo\",\n                ReloadProjects = \"reloadProjects\",\n                Unknown = \"unknown\",\n                OpenExternalProject = \"openExternalProject\",\n                OpenExternalProjects = \"openExternalProjects\",\n                CloseExternalProject = \"closeExternalProject\",\n                UpdateOpen = \"updateOpen\",\n                GetOutliningSpans = \"getOutliningSpans\",\n                TodoComments = \"todoComments\",\n                Indentation = \"indentation\",\n                DocCommentTemplate = \"docCommentTemplate\",\n                CompilerOptionsForInferredProjects = \"compilerOptionsForInferredProjects\",\n                GetCodeFixes = \"getCodeFixes\",\n                GetCombinedCodeFix = \"getCombinedCodeFix\",\n                ApplyCodeActionCommand = \"applyCodeActionCommand\",\n                GetSupportedCodeFixes = \"getSupportedCodeFixes\",\n                GetApplicableRefactors = \"getApplicableRefactors\",\n                GetEditsForRefactor = \"getEditsForRefactor\",\n                GetMoveToRefactoringFileSuggestions = \"getMoveToRefactoringFileSuggestions\",\n                PreparePasteEdits = \"preparePasteEdits\",\n                GetPasteEdits = \"getPasteEdits\",\n                OrganizeImports = \"organizeImports\",\n                GetEditsForFileRename = \"getEditsForFileRename\",\n                ConfigurePlugin = \"configurePlugin\",\n                SelectionRange = \"selectionRange\",\n                ToggleLineComment = \"toggleLineComment\",\n                ToggleMultilineComment = \"toggleMultilineComment\",\n                CommentSelection = \"commentSelection\",\n                UncommentSelection = \"uncommentSelection\",\n                PrepareCallHierarchy = \"prepareCallHierarchy\",\n                ProvideCallHierarchyIncomingCalls = \"provideCallHierarchyIncomingCalls\",\n                ProvideCallHierarchyOutgoingCalls = \"provideCallHierarchyOutgoingCalls\",\n                ProvideInlayHints = \"provideInlayHints\",\n                WatchChange = \"watchChange\",\n                MapCode = \"mapCode\",\n            }\n            /**\n             * A TypeScript Server message\n             */\n            export interface Message {\n                /**\n                 * Sequence number of the message\n                 */\n                seq: number;\n                /**\n                 * One of \"request\", \"response\", or \"event\"\n                 */\n                type: \"request\" | \"response\" | \"event\";\n            }\n            /**\n             * Client-initiated request message\n             */\n            export interface Request extends Message {\n                type: \"request\";\n                /**\n                 * The command to execute\n                 */\n                command: string;\n                /**\n                 * Object containing arguments for the command\n                 */\n                arguments?: any;\n            }\n            /**\n             * Request to reload the project structure for all the opened files\n             */\n            export interface ReloadProjectsRequest extends Request {\n                command: CommandTypes.ReloadProjects;\n            }\n            /**\n             * Server-initiated event message\n             */\n            export interface Event extends Message {\n                type: \"event\";\n                /**\n                 * Name of event\n                 */\n                event: string;\n                /**\n                 * Event-specific information\n                 */\n                body?: any;\n            }\n            /**\n             * Response by server to client request message.\n             */\n            export interface Response extends Message {\n                type: \"response\";\n                /**\n                 * Sequence number of the request message.\n                 */\n                request_seq: number;\n                /**\n                 * Outcome of the request.\n                 */\n                success: boolean;\n                /**\n                 * The command requested.\n                 */\n                command: string;\n                /**\n                 * If success === false, this should always be provided.\n                 * Otherwise, may (or may not) contain a success message.\n                 */\n                message?: string;\n                /**\n                 * Contains message body if success === true.\n                 */\n                body?: any;\n                /**\n                 * Contains extra information that plugin can include to be passed on\n                 */\n                metadata?: unknown;\n                /**\n                 * Exposes information about the performance of this request-response pair.\n                 */\n                performanceData?: PerformanceData;\n            }\n            export interface PerformanceData {\n                /**\n                 * Time spent updating the program graph, in milliseconds.\n                 */\n                updateGraphDurationMs?: number;\n                /**\n                 * The time spent creating or updating the auto-import program, in milliseconds.\n                 */\n                createAutoImportProviderProgramDurationMs?: number;\n                /**\n                 * The time spent computing diagnostics, in milliseconds.\n                 */\n                diagnosticsDuration?: FileDiagnosticPerformanceData[];\n            }\n            /**\n             * Time spent computing each kind of diagnostics, in milliseconds.\n             */\n            export type DiagnosticPerformanceData = {\n                [Kind in DiagnosticEventKind]?: number;\n            };\n            export interface FileDiagnosticPerformanceData extends DiagnosticPerformanceData {\n                /**\n                 * The file for which the performance data is reported.\n                 */\n                file: string;\n            }\n            /**\n             * Arguments for FileRequest messages.\n             */\n            export interface FileRequestArgs {\n                /**\n                 * The file for the request (absolute pathname required).\n                 */\n                file: string;\n                projectFileName?: string;\n            }\n            export interface StatusRequest extends Request {\n                command: CommandTypes.Status;\n            }\n            export interface StatusResponseBody {\n                /**\n                 * The TypeScript version (`ts.version`).\n                 */\n                version: string;\n            }\n            /**\n             * Response to StatusRequest\n             */\n            export interface StatusResponse extends Response {\n                body: StatusResponseBody;\n            }\n            /**\n             * Requests a JS Doc comment template for a given position\n             */\n            export interface DocCommentTemplateRequest extends FileLocationRequest {\n                command: CommandTypes.DocCommentTemplate;\n            }\n            /**\n             * Response to DocCommentTemplateRequest\n             */\n            export interface DocCommandTemplateResponse extends Response {\n                body?: TextInsertion;\n            }\n            /**\n             * A request to get TODO comments from the file\n             */\n            export interface TodoCommentRequest extends FileRequest {\n                command: CommandTypes.TodoComments;\n                arguments: TodoCommentRequestArgs;\n            }\n            /**\n             * Arguments for TodoCommentRequest request.\n             */\n            export interface TodoCommentRequestArgs extends FileRequestArgs {\n                /**\n                 * Array of target TodoCommentDescriptors that describes TODO comments to be found\n                 */\n                descriptors: TodoCommentDescriptor[];\n            }\n            /**\n             * Response for TodoCommentRequest request.\n             */\n            export interface TodoCommentsResponse extends Response {\n                body?: TodoComment[];\n            }\n            /**\n             * A request to determine if the caret is inside a comment.\n             */\n            export interface SpanOfEnclosingCommentRequest extends FileLocationRequest {\n                command: CommandTypes.GetSpanOfEnclosingComment;\n                arguments: SpanOfEnclosingCommentRequestArgs;\n            }\n            export interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Requires that the enclosing span be a multi-line comment, or else the request returns undefined.\n                 */\n                onlyMultiLine: boolean;\n            }\n            /**\n             * Request to obtain outlining spans in file.\n             */\n            export interface OutliningSpansRequest extends FileRequest {\n                command: CommandTypes.GetOutliningSpans;\n            }\n            export type OutliningSpan = ChangePropertyTypes<ts.OutliningSpan, {\n                textSpan: TextSpan;\n                hintSpan: TextSpan;\n            }>;\n            /**\n             * Response to OutliningSpansRequest request.\n             */\n            export interface OutliningSpansResponse extends Response {\n                body?: OutliningSpan[];\n            }\n            /**\n             * A request to get indentation for a location in file\n             */\n            export interface IndentationRequest extends FileLocationRequest {\n                command: CommandTypes.Indentation;\n                arguments: IndentationRequestArgs;\n            }\n            /**\n             * Response for IndentationRequest request.\n             */\n            export interface IndentationResponse extends Response {\n                body?: IndentationResult;\n            }\n            /**\n             * Indentation result representing where indentation should be placed\n             */\n            export interface IndentationResult {\n                /**\n                 * The base position in the document that the indent should be relative to\n                 */\n                position: number;\n                /**\n                 * The number of columns the indent should be at relative to the position's column.\n                 */\n                indentation: number;\n            }\n            /**\n             * Arguments for IndentationRequest request.\n             */\n            export interface IndentationRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * An optional set of settings to be used when computing indentation.\n                 * If argument is omitted - then it will use settings for file that were previously set via 'configure' request or global settings.\n                 */\n                options?: EditorSettings;\n            }\n            /**\n             * Arguments for ProjectInfoRequest request.\n             */\n            export interface ProjectInfoRequestArgs extends FileRequestArgs {\n                /**\n                 * Indicate if the file name list of the project is needed\n                 */\n                needFileNameList: boolean;\n                /**\n                 * if true returns details about default configured project calculation\n                 */\n                needDefaultConfiguredProjectInfo?: boolean;\n            }\n            /**\n             * A request to get the project information of the current file.\n             */\n            export interface ProjectInfoRequest extends Request {\n                command: CommandTypes.ProjectInfo;\n                arguments: ProjectInfoRequestArgs;\n            }\n            /**\n             * A request to retrieve compiler options diagnostics for a project\n             */\n            export interface CompilerOptionsDiagnosticsRequest extends Request {\n                arguments: CompilerOptionsDiagnosticsRequestArgs;\n            }\n            /**\n             * Arguments for CompilerOptionsDiagnosticsRequest request.\n             */\n            export interface CompilerOptionsDiagnosticsRequestArgs {\n                /**\n                 * Name of the project to retrieve compiler options diagnostics.\n                 */\n                projectFileName: string;\n            }\n            /**\n             * Details about the default project for the file if tsconfig file is found\n             */\n            export interface DefaultConfiguredProjectInfo {\n                /** List of config files looked and did not match because file was not part of root file names */\n                notMatchedByConfig?: readonly string[];\n                /** List of projects which were loaded but file was not part of the project or is file from referenced project */\n                notInProject?: readonly string[];\n                /** Configured project used as default */\n                defaultProject?: string;\n            }\n            /**\n             * Response message body for \"projectInfo\" request\n             */\n            export interface ProjectInfo {\n                /**\n                 * For configured project, this is the normalized path of the 'tsconfig.json' file\n                 * For inferred project, this is undefined\n                 */\n                configFileName: string;\n                /**\n                 * The list of normalized file name in the project, including 'lib.d.ts'\n                 */\n                fileNames?: string[];\n                /**\n                 * Indicates if the project has a active language service instance\n                 */\n                languageServiceDisabled?: boolean;\n                /**\n                 * Information about default project\n                 */\n                configuredProjectInfo?: DefaultConfiguredProjectInfo;\n            }\n            /**\n             * Represents diagnostic info that includes location of diagnostic in two forms\n             * - start position and length of the error span\n             * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.\n             */\n            export interface DiagnosticWithLinePosition {\n                message: string;\n                start: number;\n                length: number;\n                startLocation: Location;\n                endLocation: Location;\n                category: string;\n                code: number;\n                /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\n                reportsUnnecessary?: {};\n                reportsDeprecated?: {};\n                relatedInformation?: DiagnosticRelatedInformation[];\n            }\n            /**\n             * Response message for \"projectInfo\" request\n             */\n            export interface ProjectInfoResponse extends Response {\n                body?: ProjectInfo;\n            }\n            /**\n             * Request whose sole parameter is a file name.\n             */\n            export interface FileRequest extends Request {\n                arguments: FileRequestArgs;\n            }\n            /**\n             * Instances of this interface specify a location in a source file:\n             * (file, line, character offset), where line and character offset are 1-based.\n             */\n            export interface FileLocationRequestArgs extends FileRequestArgs {\n                /**\n                 * The line number for the request (1-based).\n                 */\n                line: number;\n                /**\n                 * The character offset (on the line) for the request (1-based).\n                 */\n                offset: number;\n            }\n            export type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;\n            /**\n             * Request refactorings at a given position or selection area.\n             */\n            export interface GetApplicableRefactorsRequest extends Request {\n                command: CommandTypes.GetApplicableRefactors;\n                arguments: GetApplicableRefactorsRequestArgs;\n            }\n            export type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs & {\n                triggerReason?: RefactorTriggerReason;\n                kind?: string;\n                /**\n                 * Include refactor actions that require additional arguments to be passed when\n                 * calling 'GetEditsForRefactor'. When true, clients should inspect the\n                 * `isInteractive` property of each returned `RefactorActionInfo`\n                 * and ensure they are able to collect the appropriate arguments for any\n                 * interactive refactor before offering it.\n                 */\n                includeInteractiveActions?: boolean;\n            };\n            /**\n             * Response is a list of available refactorings.\n             * Each refactoring exposes one or more \"Actions\"; a user selects one action to invoke a refactoring\n             */\n            export interface GetApplicableRefactorsResponse extends Response {\n                body?: ApplicableRefactorInfo[];\n            }\n            /**\n             * Request refactorings at a given position or selection area to move to an existing file.\n             */\n            export interface GetMoveToRefactoringFileSuggestionsRequest extends Request {\n                command: CommandTypes.GetMoveToRefactoringFileSuggestions;\n                arguments: GetMoveToRefactoringFileSuggestionsRequestArgs;\n            }\n            export type GetMoveToRefactoringFileSuggestionsRequestArgs = FileLocationOrRangeRequestArgs & {\n                kind?: string;\n            };\n            /**\n             * Response is a list of available files.\n             * Each refactoring exposes one or more \"Actions\"; a user selects one action to invoke a refactoring\n             */\n            export interface GetMoveToRefactoringFileSuggestions extends Response {\n                body: {\n                    newFileName: string;\n                    files: string[];\n                };\n            }\n            /**\n             * Request to check if `pasteEdits` should be provided for a given location post copying text from that location.\n             */\n            export interface PreparePasteEditsRequest extends FileRequest {\n                command: CommandTypes.PreparePasteEdits;\n                arguments: PreparePasteEditsRequestArgs;\n            }\n            export interface PreparePasteEditsRequestArgs extends FileRequestArgs {\n                copiedTextSpan: TextSpan[];\n            }\n            export interface PreparePasteEditsResponse extends Response {\n                body: boolean;\n            }\n            /**\n             * Request refactorings at a given position post pasting text from some other location.\n             */\n            export interface GetPasteEditsRequest extends Request {\n                command: CommandTypes.GetPasteEdits;\n                arguments: GetPasteEditsRequestArgs;\n            }\n            export interface GetPasteEditsRequestArgs extends FileRequestArgs {\n                /** The text that gets pasted in a file.  */\n                pastedText: string[];\n                /** Locations of where the `pastedText` gets added in a file. If the length of the `pastedText` and `pastedLocations` are not the same,\n                 *  then the `pastedText` is combined into one and added at all the `pastedLocations`.\n                 */\n                pasteLocations: TextSpan[];\n                /** The source location of each `pastedText`. If present, the length of `spans` must be equal to the length of `pastedText`. */\n                copiedFrom?: {\n                    file: string;\n                    spans: TextSpan[];\n                };\n            }\n            export interface GetPasteEditsResponse extends Response {\n                body: PasteEditsAction;\n            }\n            export interface PasteEditsAction {\n                edits: FileCodeEdits[];\n                fixId?: {};\n            }\n            export interface GetEditsForRefactorRequest extends Request {\n                command: CommandTypes.GetEditsForRefactor;\n                arguments: GetEditsForRefactorRequestArgs;\n            }\n            /**\n             * Request the edits that a particular refactoring action produces.\n             * Callers must specify the name of the refactor and the name of the action.\n             */\n            export type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {\n                refactor: string;\n                action: string;\n                interactiveRefactorArguments?: InteractiveRefactorArguments;\n            };\n            export interface GetEditsForRefactorResponse extends Response {\n                body?: RefactorEditInfo;\n            }\n            export interface RefactorEditInfo {\n                edits: FileCodeEdits[];\n                /**\n                 * An optional location where the editor should start a rename operation once\n                 * the refactoring edits have been applied\n                 */\n                renameLocation?: Location;\n                renameFilename?: string;\n                notApplicableReason?: string;\n            }\n            /**\n             * Organize imports by:\n             *   1) Removing unused imports\n             *   2) Coalescing imports from the same module\n             *   3) Sorting imports\n             */\n            export interface OrganizeImportsRequest extends Request {\n                command: CommandTypes.OrganizeImports;\n                arguments: OrganizeImportsRequestArgs;\n            }\n            export type OrganizeImportsScope = GetCombinedCodeFixScope;\n            export interface OrganizeImportsRequestArgs {\n                scope: OrganizeImportsScope;\n                /** @deprecated Use `mode` instead */\n                skipDestructiveCodeActions?: boolean;\n                mode?: OrganizeImportsMode;\n            }\n            export interface OrganizeImportsResponse extends Response {\n                body: readonly FileCodeEdits[];\n            }\n            export interface GetEditsForFileRenameRequest extends Request {\n                command: CommandTypes.GetEditsForFileRename;\n                arguments: GetEditsForFileRenameRequestArgs;\n            }\n            /** Note: Paths may also be directories. */\n            export interface GetEditsForFileRenameRequestArgs {\n                readonly oldFilePath: string;\n                readonly newFilePath: string;\n            }\n            export interface GetEditsForFileRenameResponse extends Response {\n                body: readonly FileCodeEdits[];\n            }\n            /**\n             * Request for the available codefixes at a specific position.\n             */\n            export interface CodeFixRequest extends Request {\n                command: CommandTypes.GetCodeFixes;\n                arguments: CodeFixRequestArgs;\n            }\n            export interface GetCombinedCodeFixRequest extends Request {\n                command: CommandTypes.GetCombinedCodeFix;\n                arguments: GetCombinedCodeFixRequestArgs;\n            }\n            export interface GetCombinedCodeFixResponse extends Response {\n                body: CombinedCodeActions;\n            }\n            export interface ApplyCodeActionCommandRequest extends Request {\n                command: CommandTypes.ApplyCodeActionCommand;\n                arguments: ApplyCodeActionCommandRequestArgs;\n            }\n            export interface ApplyCodeActionCommandResponse extends Response {\n            }\n            export interface FileRangeRequestArgs extends FileRequestArgs, FileRange {\n            }\n            /**\n             * Instances of this interface specify errorcodes on a specific location in a sourcefile.\n             */\n            export interface CodeFixRequestArgs extends FileRangeRequestArgs {\n                /**\n                 * Errorcodes we want to get the fixes for.\n                 */\n                errorCodes: readonly number[];\n            }\n            export interface GetCombinedCodeFixRequestArgs {\n                scope: GetCombinedCodeFixScope;\n                fixId: {};\n            }\n            export interface GetCombinedCodeFixScope {\n                type: \"file\";\n                args: FileRequestArgs;\n            }\n            export interface ApplyCodeActionCommandRequestArgs {\n                /** May also be an array of commands. */\n                command: {};\n            }\n            /**\n             * Response for GetCodeFixes request.\n             */\n            export interface GetCodeFixesResponse extends Response {\n                body?: CodeAction[];\n            }\n            /**\n             * A request whose arguments specify a file location (file, line, col).\n             */\n            export interface FileLocationRequest extends FileRequest {\n                arguments: FileLocationRequestArgs;\n            }\n            /**\n             * A request to get codes of supported code fixes.\n             */\n            export interface GetSupportedCodeFixesRequest extends Request {\n                command: CommandTypes.GetSupportedCodeFixes;\n                arguments?: Partial<FileRequestArgs>;\n            }\n            /**\n             * A response for GetSupportedCodeFixesRequest request.\n             */\n            export interface GetSupportedCodeFixesResponse extends Response {\n                /**\n                 * List of error codes supported by the server.\n                 */\n                body?: string[];\n            }\n            /**\n             * A request to get encoded semantic classifications for a span in the file\n             */\n            export interface EncodedSemanticClassificationsRequest extends FileRequest {\n                arguments: EncodedSemanticClassificationsRequestArgs;\n            }\n            /**\n             * Arguments for EncodedSemanticClassificationsRequest request.\n             */\n            export interface EncodedSemanticClassificationsRequestArgs extends FileRequestArgs {\n                /**\n                 * Start position of the span.\n                 */\n                start: number;\n                /**\n                 * Length of the span.\n                 */\n                length: number;\n                /**\n                 * Optional parameter for the semantic highlighting response, if absent it\n                 * defaults to \"original\".\n                 */\n                format?: \"original\" | \"2020\";\n            }\n            /** The response for a EncodedSemanticClassificationsRequest */\n            export interface EncodedSemanticClassificationsResponse extends Response {\n                body?: EncodedSemanticClassificationsResponseBody;\n            }\n            /**\n             * Implementation response message. Gives series of text spans depending on the format ar.\n             */\n            export interface EncodedSemanticClassificationsResponseBody {\n                endOfLineState: EndOfLineState;\n                spans: number[];\n            }\n            /**\n             * Arguments in document highlight request; include: filesToSearch, file,\n             * line, offset.\n             */\n            export interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * List of files to search for document highlights.\n                 */\n                filesToSearch: string[];\n            }\n            /**\n             * Go to definition request; value of command field is\n             * \"definition\". Return response giving the file locations that\n             * define the symbol found in file at location line, col.\n             */\n            export interface DefinitionRequest extends FileLocationRequest {\n                command: CommandTypes.Definition;\n            }\n            export interface DefinitionAndBoundSpanRequest extends FileLocationRequest {\n                readonly command: CommandTypes.DefinitionAndBoundSpan;\n            }\n            export interface FindSourceDefinitionRequest extends FileLocationRequest {\n                readonly command: CommandTypes.FindSourceDefinition;\n            }\n            export interface DefinitionAndBoundSpanResponse extends Response {\n                readonly body: DefinitionInfoAndBoundSpan;\n            }\n            /**\n             * Go to type request; value of command field is\n             * \"typeDefinition\". Return response giving the file locations that\n             * define the type for the symbol found in file at location line, col.\n             */\n            export interface TypeDefinitionRequest extends FileLocationRequest {\n                command: CommandTypes.TypeDefinition;\n            }\n            /**\n             * Go to implementation request; value of command field is\n             * \"implementation\". Return response giving the file locations that\n             * implement the symbol found in file at location line, col.\n             */\n            export interface ImplementationRequest extends FileLocationRequest {\n                command: CommandTypes.Implementation;\n            }\n            /**\n             * Location in source code expressed as (one-based) line and (one-based) column offset.\n             */\n            export interface Location {\n                line: number;\n                offset: number;\n            }\n            /**\n             * Object found in response messages defining a span of text in source code.\n             */\n            export interface TextSpan {\n                /**\n                 * First character of the definition.\n                 */\n                start: Location;\n                /**\n                 * One character past last character of the definition.\n                 */\n                end: Location;\n            }\n            /**\n             * Object found in response messages defining a span of text in a specific source file.\n             */\n            export interface FileSpan extends TextSpan {\n                /**\n                 * File containing text span.\n                 */\n                file: string;\n            }\n            export interface JSDocTagInfo {\n                /** Name of the JSDoc tag */\n                name: string;\n                /**\n                 * Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment\n                 * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.\n                 */\n                text?: string | SymbolDisplayPart[];\n            }\n            export interface TextSpanWithContext extends TextSpan {\n                contextStart?: Location;\n                contextEnd?: Location;\n            }\n            export interface FileSpanWithContext extends FileSpan, TextSpanWithContext {\n            }\n            export interface DefinitionInfo extends FileSpanWithContext {\n                /**\n                 * When true, the file may or may not exist.\n                 */\n                unverified?: boolean;\n            }\n            export interface DefinitionInfoAndBoundSpan {\n                definitions: readonly DefinitionInfo[];\n                textSpan: TextSpan;\n            }\n            /**\n             * Definition response message.  Gives text range for definition.\n             */\n            export interface DefinitionResponse extends Response {\n                body?: DefinitionInfo[];\n            }\n            export interface DefinitionInfoAndBoundSpanResponse extends Response {\n                body?: DefinitionInfoAndBoundSpan;\n            }\n            /** @deprecated Use `DefinitionInfoAndBoundSpanResponse` instead. */\n            export type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;\n            /**\n             * Definition response message.  Gives text range for definition.\n             */\n            export interface TypeDefinitionResponse extends Response {\n                body?: FileSpanWithContext[];\n            }\n            /**\n             * Implementation response message.  Gives text range for implementations.\n             */\n            export interface ImplementationResponse extends Response {\n                body?: FileSpanWithContext[];\n            }\n            /**\n             * Request to get brace completion for a location in the file.\n             */\n            export interface BraceCompletionRequest extends FileLocationRequest {\n                command: CommandTypes.BraceCompletion;\n                arguments: BraceCompletionRequestArgs;\n            }\n            /**\n             * Argument for BraceCompletionRequest request.\n             */\n            export interface BraceCompletionRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Kind of opening brace\n                 */\n                openingBrace: string;\n            }\n            export interface JsxClosingTagRequest extends FileLocationRequest {\n                readonly command: CommandTypes.JsxClosingTag;\n                readonly arguments: JsxClosingTagRequestArgs;\n            }\n            export interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {\n            }\n            export interface JsxClosingTagResponse extends Response {\n                readonly body: TextInsertion;\n            }\n            export interface LinkedEditingRangeRequest extends FileLocationRequest {\n                readonly command: CommandTypes.LinkedEditingRange;\n            }\n            export interface LinkedEditingRangesBody {\n                ranges: TextSpan[];\n                wordPattern?: string;\n            }\n            export interface LinkedEditingRangeResponse extends Response {\n                readonly body: LinkedEditingRangesBody;\n            }\n            /**\n             * Get document highlights request; value of command field is\n             * \"documentHighlights\". Return response giving spans that are relevant\n             * in the file at a given line and column.\n             */\n            export interface DocumentHighlightsRequest extends FileLocationRequest {\n                command: CommandTypes.DocumentHighlights;\n                arguments: DocumentHighlightsRequestArgs;\n            }\n            /**\n             * Span augmented with extra information that denotes the kind of the highlighting to be used for span.\n             */\n            export interface HighlightSpan extends TextSpanWithContext {\n                kind: HighlightSpanKind;\n            }\n            /**\n             * Represents a set of highligh spans for a give name\n             */\n            export interface DocumentHighlightsItem {\n                /**\n                 * File containing highlight spans.\n                 */\n                file: string;\n                /**\n                 * Spans to highlight in file.\n                 */\n                highlightSpans: HighlightSpan[];\n            }\n            /**\n             * Response for a DocumentHighlightsRequest request.\n             */\n            export interface DocumentHighlightsResponse extends Response {\n                body?: DocumentHighlightsItem[];\n            }\n            /**\n             * Find references request; value of command field is\n             * \"references\". Return response giving the file locations that\n             * reference the symbol found in file at location line, col.\n             */\n            export interface ReferencesRequest extends FileLocationRequest {\n                command: CommandTypes.References;\n            }\n            export interface ReferencesResponseItem extends FileSpanWithContext {\n                /**\n                 * Text of line containing the reference. Including this\n                 * with the response avoids latency of editor loading files\n                 * to show text of reference line (the server already has loaded the referencing files).\n                 *\n                 * If {@link UserPreferences.disableLineTextInReferences} is enabled, the property won't be filled\n                 */\n                lineText?: string;\n                /**\n                 * True if reference is a write location, false otherwise.\n                 */\n                isWriteAccess: boolean;\n                /**\n                 * Present only if the search was triggered from a declaration.\n                 * True indicates that the references refers to the same symbol\n                 * (i.e. has the same meaning) as the declaration that began the\n                 * search.\n                 */\n                isDefinition?: boolean;\n            }\n            /**\n             * The body of a \"references\" response message.\n             */\n            export interface ReferencesResponseBody {\n                /**\n                 * The file locations referencing the symbol.\n                 */\n                refs: readonly ReferencesResponseItem[];\n                /**\n                 * The name of the symbol.\n                 */\n                symbolName: string;\n                /**\n                 * The start character offset of the symbol (on the line provided by the references request).\n                 */\n                symbolStartOffset: number;\n                /**\n                 * The full display name of the symbol.\n                 */\n                symbolDisplayString: string;\n            }\n            /**\n             * Response to \"references\" request.\n             */\n            export interface ReferencesResponse extends Response {\n                body?: ReferencesResponseBody;\n            }\n            export interface FileReferencesRequest extends FileRequest {\n                command: CommandTypes.FileReferences;\n            }\n            export interface FileReferencesResponseBody {\n                /**\n                 * The file locations referencing the symbol.\n                 */\n                refs: readonly ReferencesResponseItem[];\n                /**\n                 * The name of the symbol.\n                 */\n                symbolName: string;\n            }\n            export interface FileReferencesResponse extends Response {\n                body?: FileReferencesResponseBody;\n            }\n            /**\n             * Argument for RenameRequest request.\n             */\n            export interface RenameRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Should text at specified location be found/changed in comments?\n                 */\n                findInComments?: boolean;\n                /**\n                 * Should text at specified location be found/changed in strings?\n                 */\n                findInStrings?: boolean;\n            }\n            /**\n             * Rename request; value of command field is \"rename\". Return\n             * response giving the file locations that reference the symbol\n             * found in file at location line, col. Also return full display\n             * name of the symbol so that client can print it unambiguously.\n             */\n            export interface RenameRequest extends FileLocationRequest {\n                command: CommandTypes.Rename;\n                arguments: RenameRequestArgs;\n            }\n            /**\n             * Information about the item to be renamed.\n             */\n            export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;\n            export type RenameInfoSuccess = ChangePropertyTypes<ts.RenameInfoSuccess, {\n                triggerSpan: TextSpan;\n            }>;\n            /**\n             *  A group of text spans, all in 'file'.\n             */\n            export interface SpanGroup {\n                /** The file to which the spans apply */\n                file: string;\n                /** The text spans in this group */\n                locs: RenameTextSpan[];\n            }\n            export interface RenameTextSpan extends TextSpanWithContext {\n                readonly prefixText?: string;\n                readonly suffixText?: string;\n            }\n            export interface RenameResponseBody {\n                /**\n                 * Information about the item to be renamed.\n                 */\n                info: RenameInfo;\n                /**\n                 * An array of span groups (one per file) that refer to the item to be renamed.\n                 */\n                locs: readonly SpanGroup[];\n            }\n            /**\n             * Rename response message.\n             */\n            export interface RenameResponse extends Response {\n                body?: RenameResponseBody;\n            }\n            /**\n             * Represents a file in external project.\n             * External project is project whose set of files, compilation options and open\\close state\n             * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).\n             * External project will exist even if all files in it are closed and should be closed explicitly.\n             * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will\n             * create configured project for every config file but will maintain a link that these projects were created\n             * as a result of opening external project so they should be removed once external project is closed.\n             */\n            export interface ExternalFile {\n                /**\n                 * Name of file file\n                 */\n                fileName: string;\n                /**\n                 * Script kind of the file\n                 */\n                scriptKind?: ScriptKindName | ScriptKind;\n                /**\n                 * Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)\n                 */\n                hasMixedContent?: boolean;\n                /**\n                 * Content of the file\n                 */\n                content?: string;\n            }\n            /**\n             * Represent an external project\n             */\n            export interface ExternalProject {\n                /**\n                 * Project name\n                 */\n                projectFileName: string;\n                /**\n                 * List of root files in project\n                 */\n                rootFiles: ExternalFile[];\n                /**\n                 * Compiler options for the project\n                 */\n                options: ExternalProjectCompilerOptions;\n                /**\n                 * Explicitly specified type acquisition for the project\n                 */\n                typeAcquisition?: TypeAcquisition;\n            }\n            export interface CompileOnSaveMixin {\n                /**\n                 * If compile on save is enabled for the project\n                 */\n                compileOnSave?: boolean;\n            }\n            /**\n             * For external projects, some of the project settings are sent together with\n             * compiler settings.\n             */\n            export type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;\n            export interface FileWithProjectReferenceRedirectInfo {\n                /**\n                 * Name of file\n                 */\n                fileName: string;\n                /**\n                 * True if the file is primarily included in a referenced project\n                 */\n                isSourceOfProjectReferenceRedirect: boolean;\n            }\n            /**\n             * Represents a set of changes that happen in project\n             */\n            export interface ProjectChanges {\n                /**\n                 * List of added files\n                 */\n                added: string[] | FileWithProjectReferenceRedirectInfo[];\n                /**\n                 * List of removed files\n                 */\n                removed: string[] | FileWithProjectReferenceRedirectInfo[];\n                /**\n                 * List of updated files\n                 */\n                updated: string[] | FileWithProjectReferenceRedirectInfo[];\n                /**\n                 * List of files that have had their project reference redirect status updated\n                 * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true\n                 */\n                updatedRedirects?: FileWithProjectReferenceRedirectInfo[];\n            }\n            /**\n             * Information found in a configure request.\n             */\n            export interface ConfigureRequestArguments {\n                /**\n                 * Information about the host, for example 'Emacs 24.4' or\n                 * 'Sublime Text version 3075'\n                 */\n                hostInfo?: string;\n                /**\n                 * If present, tab settings apply only to this file.\n                 */\n                file?: string;\n                /**\n                 * The format options to use during formatting and other code editing features.\n                 */\n                formatOptions?: FormatCodeSettings;\n                preferences?: UserPreferences;\n                /**\n                 * The host's additional supported .js file extensions\n                 */\n                extraFileExtensions?: FileExtensionInfo[];\n                watchOptions?: WatchOptions;\n            }\n            export enum WatchFileKind {\n                FixedPollingInterval = \"FixedPollingInterval\",\n                PriorityPollingInterval = \"PriorityPollingInterval\",\n                DynamicPriorityPolling = \"DynamicPriorityPolling\",\n                FixedChunkSizePolling = \"FixedChunkSizePolling\",\n                UseFsEvents = \"UseFsEvents\",\n                UseFsEventsOnParentDirectory = \"UseFsEventsOnParentDirectory\",\n            }\n            export enum WatchDirectoryKind {\n                UseFsEvents = \"UseFsEvents\",\n                FixedPollingInterval = \"FixedPollingInterval\",\n                DynamicPriorityPolling = \"DynamicPriorityPolling\",\n                FixedChunkSizePolling = \"FixedChunkSizePolling\",\n            }\n            export enum PollingWatchKind {\n                FixedInterval = \"FixedInterval\",\n                PriorityInterval = \"PriorityInterval\",\n                DynamicPriority = \"DynamicPriority\",\n                FixedChunkSize = \"FixedChunkSize\",\n            }\n            export interface WatchOptions {\n                watchFile?: WatchFileKind | ts.WatchFileKind;\n                watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;\n                fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;\n                synchronousWatchDirectory?: boolean;\n                excludeDirectories?: string[];\n                excludeFiles?: string[];\n                [option: string]: CompilerOptionsValue | undefined;\n            }\n            /**\n             *  Configure request; value of command field is \"configure\".  Specifies\n             *  host information, such as host type, tab size, and indent size.\n             */\n            export interface ConfigureRequest extends Request {\n                command: CommandTypes.Configure;\n                arguments: ConfigureRequestArguments;\n            }\n            /**\n             * Response to \"configure\" request.  This is just an acknowledgement, so\n             * no body field is required.\n             */\n            export interface ConfigureResponse extends Response {\n            }\n            export interface ConfigurePluginRequestArguments {\n                pluginName: string;\n                configuration: any;\n            }\n            export interface ConfigurePluginRequest extends Request {\n                command: CommandTypes.ConfigurePlugin;\n                arguments: ConfigurePluginRequestArguments;\n            }\n            export interface ConfigurePluginResponse extends Response {\n            }\n            export interface SelectionRangeRequest extends FileRequest {\n                command: CommandTypes.SelectionRange;\n                arguments: SelectionRangeRequestArgs;\n            }\n            export interface SelectionRangeRequestArgs extends FileRequestArgs {\n                locations: Location[];\n            }\n            export interface SelectionRangeResponse extends Response {\n                body?: SelectionRange[];\n            }\n            export interface SelectionRange {\n                textSpan: TextSpan;\n                parent?: SelectionRange;\n            }\n            export interface ToggleLineCommentRequest extends FileRequest {\n                command: CommandTypes.ToggleLineComment;\n                arguments: FileRangeRequestArgs;\n            }\n            export interface ToggleMultilineCommentRequest extends FileRequest {\n                command: CommandTypes.ToggleMultilineComment;\n                arguments: FileRangeRequestArgs;\n            }\n            export interface CommentSelectionRequest extends FileRequest {\n                command: CommandTypes.CommentSelection;\n                arguments: FileRangeRequestArgs;\n            }\n            export interface UncommentSelectionRequest extends FileRequest {\n                command: CommandTypes.UncommentSelection;\n                arguments: FileRangeRequestArgs;\n            }\n            /**\n             *  Information found in an \"open\" request.\n             */\n            export interface OpenRequestArgs extends FileRequestArgs {\n                /**\n                 * Used when a version of the file content is known to be more up to date than the one on disk.\n                 * Then the known content will be used upon opening instead of the disk copy\n                 */\n                fileContent?: string;\n                /**\n                 * Used to specify the script kind of the file explicitly. It could be one of the following:\n                 *      \"TS\", \"JS\", \"TSX\", \"JSX\"\n                 */\n                scriptKindName?: ScriptKindName;\n                /**\n                 * Used to limit the searching for project config file. If given the searching will stop at this\n                 * root path; otherwise it will go all the way up to the dist root path.\n                 */\n                projectRootPath?: string;\n            }\n            export type ScriptKindName = \"TS\" | \"JS\" | \"TSX\" | \"JSX\";\n            /**\n             * Open request; value of command field is \"open\". Notify the\n             * server that the client has file open.  The server will not\n             * monitor the filesystem for changes in this file and will assume\n             * that the client is updating the server (using the change and/or\n             * reload messages) when the file changes. Server does not currently\n             * send a response to an open request.\n             */\n            export interface OpenRequest extends Request {\n                command: CommandTypes.Open;\n                arguments: OpenRequestArgs;\n            }\n            /**\n             * Request to open or update external project\n             */\n            export interface OpenExternalProjectRequest extends Request {\n                command: CommandTypes.OpenExternalProject;\n                arguments: OpenExternalProjectArgs;\n            }\n            /**\n             * Arguments to OpenExternalProjectRequest request\n             */\n            export type OpenExternalProjectArgs = ExternalProject;\n            /**\n             * Request to open multiple external projects\n             */\n            export interface OpenExternalProjectsRequest extends Request {\n                command: CommandTypes.OpenExternalProjects;\n                arguments: OpenExternalProjectsArgs;\n            }\n            /**\n             * Arguments to OpenExternalProjectsRequest\n             */\n            export interface OpenExternalProjectsArgs {\n                /**\n                 * List of external projects to open or update\n                 */\n                projects: ExternalProject[];\n            }\n            /**\n             * Response to OpenExternalProjectRequest request. This is just an acknowledgement, so\n             * no body field is required.\n             */\n            export interface OpenExternalProjectResponse extends Response {\n            }\n            /**\n             * Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so\n             * no body field is required.\n             */\n            export interface OpenExternalProjectsResponse extends Response {\n            }\n            /**\n             * Request to close external project.\n             */\n            export interface CloseExternalProjectRequest extends Request {\n                command: CommandTypes.CloseExternalProject;\n                arguments: CloseExternalProjectRequestArgs;\n            }\n            /**\n             * Arguments to CloseExternalProjectRequest request\n             */\n            export interface CloseExternalProjectRequestArgs {\n                /**\n                 * Name of the project to close\n                 */\n                projectFileName: string;\n            }\n            /**\n             * Response to CloseExternalProjectRequest request. This is just an acknowledgement, so\n             * no body field is required.\n             */\n            export interface CloseExternalProjectResponse extends Response {\n            }\n            /**\n             * Request to synchronize list of open files with the client\n             */\n            export interface UpdateOpenRequest extends Request {\n                command: CommandTypes.UpdateOpen;\n                arguments: UpdateOpenRequestArgs;\n            }\n            /**\n             * Arguments to UpdateOpenRequest\n             */\n            export interface UpdateOpenRequestArgs {\n                /**\n                 * List of newly open files\n                 */\n                openFiles?: OpenRequestArgs[];\n                /**\n                 * List of open files files that were changes\n                 */\n                changedFiles?: FileCodeEdits[];\n                /**\n                 * List of files that were closed\n                 */\n                closedFiles?: string[];\n            }\n            /**\n             * External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects.\n             */\n            export type InferredProjectCompilerOptions = ExternalProjectCompilerOptions & TypeAcquisition;\n            /**\n             * Request to set compiler options for inferred projects.\n             * External projects are opened / closed explicitly.\n             * Configured projects are opened when user opens loose file that has 'tsconfig.json' or 'jsconfig.json' anywhere in one of containing folders.\n             * This configuration file will be used to obtain a list of files and configuration settings for the project.\n             * Inferred projects are created when user opens a loose file that is not the part of external project\n             * or configured project and will contain only open file and transitive closure of referenced files if 'useOneInferredProject' is false,\n             * or all open loose files and its transitive closure of referenced files if 'useOneInferredProject' is true.\n             */\n            export interface SetCompilerOptionsForInferredProjectsRequest extends Request {\n                command: CommandTypes.CompilerOptionsForInferredProjects;\n                arguments: SetCompilerOptionsForInferredProjectsArgs;\n            }\n            /**\n             * Argument for SetCompilerOptionsForInferredProjectsRequest request.\n             */\n            export interface SetCompilerOptionsForInferredProjectsArgs {\n                /**\n                 * Compiler options to be used with inferred projects.\n                 */\n                options: InferredProjectCompilerOptions;\n                /**\n                 * Specifies the project root path used to scope compiler options.\n                 * It is an error to provide this property if the server has not been started with\n                 * `useInferredProjectPerProjectRoot` enabled.\n                 */\n                projectRootPath?: string;\n            }\n            /**\n             * Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so\n             * no body field is required.\n             */\n            export interface SetCompilerOptionsForInferredProjectsResponse extends Response {\n            }\n            /**\n             *  Exit request; value of command field is \"exit\".  Ask the server process\n             *  to exit.\n             */\n            export interface ExitRequest extends Request {\n                command: CommandTypes.Exit;\n            }\n            /**\n             * Close request; value of command field is \"close\". Notify the\n             * server that the client has closed a previously open file.  If\n             * file is still referenced by open files, the server will resume\n             * monitoring the filesystem for changes to file.  Server does not\n             * currently send a response to a close request.\n             */\n            export interface CloseRequest extends FileRequest {\n                command: CommandTypes.Close;\n            }\n            export interface WatchChangeRequest extends Request {\n                command: CommandTypes.WatchChange;\n                arguments: WatchChangeRequestArgs | readonly WatchChangeRequestArgs[];\n            }\n            export interface WatchChangeRequestArgs {\n                id: number;\n                created?: string[];\n                deleted?: string[];\n                updated?: string[];\n            }\n            /**\n             * Request to obtain the list of files that should be regenerated if target file is recompiled.\n             * NOTE: this us query-only operation and does not generate any output on disk.\n             */\n            export interface CompileOnSaveAffectedFileListRequest extends FileRequest {\n                command: CommandTypes.CompileOnSaveAffectedFileList;\n            }\n            /**\n             * Contains a list of files that should be regenerated in a project\n             */\n            export interface CompileOnSaveAffectedFileListSingleProject {\n                /**\n                 * Project name\n                 */\n                projectFileName: string;\n                /**\n                 * List of files names that should be recompiled\n                 */\n                fileNames: string[];\n                /**\n                 * true if project uses outFile or out compiler option\n                 */\n                projectUsesOutFile: boolean;\n            }\n            /**\n             * Response for CompileOnSaveAffectedFileListRequest request;\n             */\n            export interface CompileOnSaveAffectedFileListResponse extends Response {\n                body: CompileOnSaveAffectedFileListSingleProject[];\n            }\n            /**\n             * Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.\n             */\n            export interface CompileOnSaveEmitFileRequest extends FileRequest {\n                command: CommandTypes.CompileOnSaveEmitFile;\n                arguments: CompileOnSaveEmitFileRequestArgs;\n            }\n            /**\n             * Arguments for CompileOnSaveEmitFileRequest\n             */\n            export interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {\n                /**\n                 * if true - then file should be recompiled even if it does not have any changes.\n                 */\n                forced?: boolean;\n                includeLinePosition?: boolean;\n                /** if true - return response as object with emitSkipped and diagnostics */\n                richResponse?: boolean;\n            }\n            export interface CompileOnSaveEmitFileResponse extends Response {\n                body: boolean | EmitResult;\n            }\n            export interface EmitResult {\n                emitSkipped: boolean;\n                diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];\n            }\n            /**\n             * Quickinfo request; value of command field is\n             * \"quickinfo\". Return response giving a quick type and\n             * documentation string for the symbol found in file at location\n             * line, col.\n             */\n            export interface QuickInfoRequest extends FileLocationRequest {\n                command: CommandTypes.Quickinfo;\n                arguments: FileLocationRequestArgs;\n            }\n            /**\n             * Body of QuickInfoResponse.\n             */\n            export interface QuickInfoResponseBody {\n                /**\n                 * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').\n                 */\n                kind: ScriptElementKind;\n                /**\n                 * Optional modifiers for the kind (such as 'public').\n                 */\n                kindModifiers: string;\n                /**\n                 * Starting file location of symbol.\n                 */\n                start: Location;\n                /**\n                 * One past last character of symbol.\n                 */\n                end: Location;\n                /**\n                 * Type and kind of symbol.\n                 */\n                displayString: string;\n                /**\n                 * Documentation associated with symbol.\n                 * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.\n                 */\n                documentation: string | SymbolDisplayPart[];\n                /**\n                 * JSDoc tags associated with symbol.\n                 */\n                tags: JSDocTagInfo[];\n            }\n            /**\n             * Quickinfo response message.\n             */\n            export interface QuickInfoResponse extends Response {\n                body?: QuickInfoResponseBody;\n            }\n            /**\n             * Arguments for format messages.\n             */\n            export interface FormatRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Last line of range for which to format text in file.\n                 */\n                endLine: number;\n                /**\n                 * Character offset on last line of range for which to format text in file.\n                 */\n                endOffset: number;\n                /**\n                 * Format options to be used.\n                 */\n                options?: FormatCodeSettings;\n            }\n            /**\n             * Format request; value of command field is \"format\".  Return\n             * response giving zero or more edit instructions.  The edit\n             * instructions will be sorted in file order.  Applying the edit\n             * instructions in reverse to file will result in correctly\n             * reformatted text.\n             */\n            export interface FormatRequest extends FileLocationRequest {\n                command: CommandTypes.Format;\n                arguments: FormatRequestArgs;\n            }\n            /**\n             * Object found in response messages defining an editing\n             * instruction for a span of text in source code.  The effect of\n             * this instruction is to replace the text starting at start and\n             * ending one character before end with newText. For an insertion,\n             * the text span is empty.  For a deletion, newText is empty.\n             */\n            export interface CodeEdit {\n                /**\n                 * First character of the text span to edit.\n                 */\n                start: Location;\n                /**\n                 * One character past last character of the text span to edit.\n                 */\n                end: Location;\n                /**\n                 * Replace the span defined above with this string (may be\n                 * the empty string).\n                 */\n                newText: string;\n            }\n            export interface FileCodeEdits {\n                fileName: string;\n                textChanges: CodeEdit[];\n            }\n            export interface CodeFixResponse extends Response {\n                /** The code actions that are available */\n                body?: CodeFixAction[];\n            }\n            export interface CodeAction {\n                /** Description of the code action to display in the UI of the editor */\n                description: string;\n                /** Text changes to apply to each file as part of the code action */\n                changes: FileCodeEdits[];\n                /** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */\n                commands?: {}[];\n            }\n            export interface CombinedCodeActions {\n                changes: readonly FileCodeEdits[];\n                commands?: readonly {}[];\n            }\n            export interface CodeFixAction extends CodeAction {\n                /** Short name to identify the fix, for use by telemetry. */\n                fixName: string;\n                /**\n                 * If present, one may call 'getCombinedCodeFix' with this fixId.\n                 * This may be omitted to indicate that the code fix can't be applied in a group.\n                 */\n                fixId?: {};\n                /** Should be present if and only if 'fixId' is. */\n                fixAllDescription?: string;\n            }\n            /**\n             * Format and format on key response message.\n             */\n            export interface FormatResponse extends Response {\n                body?: CodeEdit[];\n            }\n            /**\n             * Arguments for format on key messages.\n             */\n            export interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Key pressed (';', '\\n', or '}').\n                 */\n                key: string;\n                options?: FormatCodeSettings;\n            }\n            /**\n             * Format on key request; value of command field is\n             * \"formatonkey\". Given file location and key typed (as string),\n             * return response giving zero or more edit instructions.  The\n             * edit instructions will be sorted in file order.  Applying the\n             * edit instructions in reverse to file will result in correctly\n             * reformatted text.\n             */\n            export interface FormatOnKeyRequest extends FileLocationRequest {\n                command: CommandTypes.Formatonkey;\n                arguments: FormatOnKeyRequestArgs;\n            }\n            /**\n             * Arguments for completions messages.\n             */\n            export interface CompletionsRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Optional prefix to apply to possible completions.\n                 */\n                prefix?: string;\n                /**\n                 * Character that was responsible for triggering completion.\n                 * Should be `undefined` if a user manually requested completion.\n                 */\n                triggerCharacter?: CompletionsTriggerCharacter;\n                triggerKind?: CompletionTriggerKind;\n                /**\n                 * @deprecated Use UserPreferences.includeCompletionsForModuleExports\n                 */\n                includeExternalModuleExports?: boolean;\n                /**\n                 * @deprecated Use UserPreferences.includeCompletionsWithInsertText\n                 */\n                includeInsertTextCompletions?: boolean;\n            }\n            /**\n             * Completions request; value of command field is \"completions\".\n             * Given a file location (file, line, col) and a prefix (which may\n             * be the empty string), return the possible completions that\n             * begin with prefix.\n             */\n            export interface CompletionsRequest extends FileLocationRequest {\n                command: CommandTypes.Completions | CommandTypes.CompletionInfo;\n                arguments: CompletionsRequestArgs;\n            }\n            /**\n             * Arguments for completion details request.\n             */\n            export interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Names of one or more entries for which to obtain details.\n                 */\n                entryNames: (string | CompletionEntryIdentifier)[];\n            }\n            export interface CompletionEntryIdentifier {\n                name: string;\n                source?: string;\n                data?: unknown;\n            }\n            /**\n             * Completion entry details request; value of command field is\n             * \"completionEntryDetails\".  Given a file location (file, line,\n             * col) and an array of completion entry names return more\n             * detailed information for each completion entry.\n             */\n            export interface CompletionDetailsRequest extends FileLocationRequest {\n                command: CommandTypes.CompletionDetails;\n                arguments: CompletionDetailsRequestArgs;\n            }\n            /** A part of a symbol description that links from a jsdoc @link tag to a declaration */\n            export interface JSDocLinkDisplayPart extends SymbolDisplayPart {\n                /** The location of the declaration that the @link tag links to. */\n                target: FileSpan;\n            }\n            export type CompletionEntry = ChangePropertyTypes<Omit<ts.CompletionEntry, \"symbol\">, {\n                replacementSpan: TextSpan;\n                data: unknown;\n            }>;\n            /**\n             * Additional completion entry details, available on demand\n             */\n            export type CompletionEntryDetails = ChangePropertyTypes<ts.CompletionEntryDetails, {\n                tags: JSDocTagInfo[];\n                codeActions: CodeAction[];\n            }>;\n            /** @deprecated Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */\n            export interface CompletionsResponse extends Response {\n                body?: CompletionEntry[];\n            }\n            export interface CompletionInfoResponse extends Response {\n                body?: CompletionInfo;\n            }\n            export type CompletionInfo = ChangePropertyTypes<ts.CompletionInfo, {\n                entries: readonly CompletionEntry[];\n                optionalReplacementSpan: TextSpan;\n            }>;\n            export interface CompletionDetailsResponse extends Response {\n                body?: CompletionEntryDetails[];\n            }\n            /**\n             * Represents a single signature to show in signature help.\n             */\n            export type SignatureHelpItem = ChangePropertyTypes<ts.SignatureHelpItem, {\n                tags: JSDocTagInfo[];\n            }>;\n            /**\n             * Signature help items found in the response of a signature help request.\n             */\n            export interface SignatureHelpItems {\n                /**\n                 * The signature help items.\n                 */\n                items: SignatureHelpItem[];\n                /**\n                 * The span for which signature help should appear on a signature\n                 */\n                applicableSpan: TextSpan;\n                /**\n                 * The item selected in the set of available help items.\n                 */\n                selectedItemIndex: number;\n                /**\n                 * The argument selected in the set of parameters.\n                 */\n                argumentIndex: number;\n                /**\n                 * The argument count\n                 */\n                argumentCount: number;\n            }\n            /**\n             * Arguments of a signature help request.\n             */\n            export interface SignatureHelpRequestArgs extends FileLocationRequestArgs {\n                /**\n                 * Reason why signature help was invoked.\n                 * See each individual possible\n                 */\n                triggerReason?: SignatureHelpTriggerReason;\n            }\n            /**\n             * Signature help request; value of command field is \"signatureHelp\".\n             * Given a file location (file, line, col), return the signature\n             * help.\n             */\n            export interface SignatureHelpRequest extends FileLocationRequest {\n                command: CommandTypes.SignatureHelp;\n                arguments: SignatureHelpRequestArgs;\n            }\n            /**\n             * Response object for a SignatureHelpRequest.\n             */\n            export interface SignatureHelpResponse extends Response {\n                body?: SignatureHelpItems;\n            }\n            export interface InlayHintsRequestArgs extends FileRequestArgs {\n                /**\n                 * Start position of the span.\n                 */\n                start: number;\n                /**\n                 * Length of the span.\n                 */\n                length: number;\n            }\n            export interface InlayHintsRequest extends Request {\n                command: CommandTypes.ProvideInlayHints;\n                arguments: InlayHintsRequestArgs;\n            }\n            export type InlayHintItem = ChangePropertyTypes<ts.InlayHint, {\n                position: Location;\n                displayParts: InlayHintItemDisplayPart[];\n            }>;\n            export interface InlayHintItemDisplayPart {\n                text: string;\n                span?: FileSpan;\n            }\n            export interface InlayHintsResponse extends Response {\n                body?: InlayHintItem[];\n            }\n            export interface MapCodeRequestArgs extends FileRequestArgs {\n                /**\n                 * The files and changes to try and apply/map.\n                 */\n                mapping: MapCodeRequestDocumentMapping;\n            }\n            export interface MapCodeRequestDocumentMapping {\n                /**\n                 * The specific code to map/insert/replace in the file.\n                 */\n                contents: string[];\n                /**\n                 * Areas of \"focus\" to inform the code mapper with. For example, cursor\n                 * location, current selection, viewport, etc. Nested arrays denote\n                 * priority: toplevel arrays are more important than inner arrays, and\n                 * inner array priorities are based on items within that array. Items\n                 * earlier in the arrays have higher priority.\n                 */\n                focusLocations?: TextSpan[][];\n            }\n            export interface MapCodeRequest extends FileRequest {\n                command: CommandTypes.MapCode;\n                arguments: MapCodeRequestArgs;\n            }\n            export interface MapCodeResponse extends Response {\n                body: readonly FileCodeEdits[];\n            }\n            /**\n             * Synchronous request for semantic diagnostics of one file.\n             */\n            export interface SemanticDiagnosticsSyncRequest extends FileRequest {\n                command: CommandTypes.SemanticDiagnosticsSync;\n                arguments: SemanticDiagnosticsSyncRequestArgs;\n            }\n            export interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {\n                includeLinePosition?: boolean;\n            }\n            /**\n             * Response object for synchronous sematic diagnostics request.\n             */\n            export interface SemanticDiagnosticsSyncResponse extends Response {\n                body?: Diagnostic[] | DiagnosticWithLinePosition[];\n            }\n            export interface SuggestionDiagnosticsSyncRequest extends FileRequest {\n                command: CommandTypes.SuggestionDiagnosticsSync;\n                arguments: SuggestionDiagnosticsSyncRequestArgs;\n            }\n            export type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;\n            export type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;\n            /**\n             * Synchronous request for syntactic diagnostics of one file.\n             */\n            export interface SyntacticDiagnosticsSyncRequest extends FileRequest {\n                command: CommandTypes.SyntacticDiagnosticsSync;\n                arguments: SyntacticDiagnosticsSyncRequestArgs;\n            }\n            export interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {\n                includeLinePosition?: boolean;\n            }\n            /**\n             * Response object for synchronous syntactic diagnostics request.\n             */\n            export interface SyntacticDiagnosticsSyncResponse extends Response {\n                body?: Diagnostic[] | DiagnosticWithLinePosition[];\n            }\n            /**\n             * Arguments for GeterrForProject request.\n             */\n            export interface GeterrForProjectRequestArgs {\n                /**\n                 * the file requesting project error list\n                 */\n                file: string;\n                /**\n                 * Delay in milliseconds to wait before starting to compute\n                 * errors for the files in the file list\n                 */\n                delay: number;\n            }\n            /**\n             * GeterrForProjectRequest request; value of command field is\n             * \"geterrForProject\". It works similarly with 'Geterr', only\n             * it request for every file in this project.\n             */\n            export interface GeterrForProjectRequest extends Request {\n                command: CommandTypes.GeterrForProject;\n                arguments: GeterrForProjectRequestArgs;\n            }\n            /**\n             * Arguments for geterr messages.\n             */\n            export interface GeterrRequestArgs {\n                /**\n                 * List of file names for which to compute compiler errors.\n                 * The files will be checked in list order.\n                 */\n                files: (string | FileRangesRequestArgs)[];\n                /**\n                 * Delay in milliseconds to wait before starting to compute\n                 * errors for the files in the file list\n                 */\n                delay: number;\n            }\n            /**\n             * Geterr request; value of command field is \"geterr\". Wait for\n             * delay milliseconds and then, if during the wait no change or\n             * reload messages have arrived for the first file in the files\n             * list, get the syntactic errors for the file, field requests,\n             * and then get the semantic errors for the file.  Repeat with a\n             * smaller delay for each subsequent file on the files list.  Best\n             * practice for an editor is to send a file list containing each\n             * file that is currently visible, in most-recently-used order.\n             */\n            export interface GeterrRequest extends Request {\n                command: CommandTypes.Geterr;\n                arguments: GeterrRequestArgs;\n            }\n            export interface FileRange {\n                /**\n                 * The line number for the request (1-based).\n                 */\n                startLine: number;\n                /**\n                 * The character offset (on the line) for the request (1-based).\n                 */\n                startOffset: number;\n                /**\n                 * The line number for the request (1-based).\n                 */\n                endLine: number;\n                /**\n                 * The character offset (on the line) for the request (1-based).\n                 */\n                endOffset: number;\n            }\n            export interface FileRangesRequestArgs extends Pick<FileRequestArgs, \"file\"> {\n                ranges: FileRange[];\n            }\n            export type RequestCompletedEventName = \"requestCompleted\";\n            /**\n             * Event that is sent when server have finished processing request with specified id.\n             */\n            export interface RequestCompletedEvent extends Event {\n                event: RequestCompletedEventName;\n                body: RequestCompletedEventBody;\n            }\n            export interface RequestCompletedEventBody {\n                request_seq: number;\n                performanceData?: PerformanceData;\n            }\n            /**\n             * Item of diagnostic information found in a DiagnosticEvent message.\n             */\n            export interface Diagnostic {\n                /**\n                 * Starting file location at which text applies.\n                 */\n                start: Location;\n                /**\n                 * The last file location at which the text applies.\n                 */\n                end: Location;\n                /**\n                 * Text of diagnostic message.\n                 */\n                text: string;\n                /**\n                 * The category of the diagnostic message, e.g. \"error\", \"warning\", or \"suggestion\".\n                 */\n                category: string;\n                reportsUnnecessary?: {};\n                reportsDeprecated?: {};\n                /**\n                 * Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites\n                 */\n                relatedInformation?: DiagnosticRelatedInformation[];\n                /**\n                 * The error code of the diagnostic message.\n                 */\n                code?: number;\n                /**\n                 * The name of the plugin reporting the message.\n                 */\n                source?: string;\n            }\n            export interface DiagnosticWithFileName extends Diagnostic {\n                /**\n                 * Name of the file the diagnostic is in\n                 */\n                fileName: string;\n            }\n            /**\n             * Represents additional spans returned with a diagnostic which are relevant to it\n             */\n            export interface DiagnosticRelatedInformation {\n                /**\n                 * The category of the related information message, e.g. \"error\", \"warning\", or \"suggestion\".\n                 */\n                category: string;\n                /**\n                 * The code used ot identify the related information\n                 */\n                code: number;\n                /**\n                 * Text of related or additional information.\n                 */\n                message: string;\n                /**\n                 * Associated location\n                 */\n                span?: FileSpan;\n            }\n            export interface DiagnosticEventBody {\n                /**\n                 * The file for which diagnostic information is reported.\n                 */\n                file: string;\n                /**\n                 * An array of diagnostic information items.\n                 */\n                diagnostics: Diagnostic[];\n                /**\n                 * Spans where the region diagnostic was requested, if this is a region semantic diagnostic event.\n                 */\n                spans?: TextSpan[];\n            }\n            export type DiagnosticEventKind = \"semanticDiag\" | \"syntaxDiag\" | \"suggestionDiag\" | \"regionSemanticDiag\";\n            /**\n             * Event message for DiagnosticEventKind event types.\n             * These events provide syntactic and semantic errors for a file.\n             */\n            export interface DiagnosticEvent extends Event {\n                body?: DiagnosticEventBody;\n                event: DiagnosticEventKind;\n            }\n            export interface ConfigFileDiagnosticEventBody {\n                /**\n                 * The file which trigged the searching and error-checking of the config file\n                 */\n                triggerFile: string;\n                /**\n                 * The name of the found config file.\n                 */\n                configFile: string;\n                /**\n                 * An arry of diagnostic information items for the found config file.\n                 */\n                diagnostics: DiagnosticWithFileName[];\n            }\n            /**\n             * Event message for \"configFileDiag\" event type.\n             * This event provides errors for a found config file.\n             */\n            export interface ConfigFileDiagnosticEvent extends Event {\n                body?: ConfigFileDiagnosticEventBody;\n                event: \"configFileDiag\";\n            }\n            export type ProjectLanguageServiceStateEventName = \"projectLanguageServiceState\";\n            export interface ProjectLanguageServiceStateEvent extends Event {\n                event: ProjectLanguageServiceStateEventName;\n                body?: ProjectLanguageServiceStateEventBody;\n            }\n            export interface ProjectLanguageServiceStateEventBody {\n                /**\n                 * Project name that has changes in the state of language service.\n                 * For configured projects this will be the config file path.\n                 * For external projects this will be the name of the projects specified when project was open.\n                 * For inferred projects this event is not raised.\n                 */\n                projectName: string;\n                /**\n                 * True if language service state switched from disabled to enabled\n                 * and false otherwise.\n                 */\n                languageServiceEnabled: boolean;\n            }\n            export type ProjectsUpdatedInBackgroundEventName = \"projectsUpdatedInBackground\";\n            export interface ProjectsUpdatedInBackgroundEvent extends Event {\n                event: ProjectsUpdatedInBackgroundEventName;\n                body: ProjectsUpdatedInBackgroundEventBody;\n            }\n            export interface ProjectsUpdatedInBackgroundEventBody {\n                /**\n                 * Current set of open files\n                 */\n                openFiles: string[];\n            }\n            export type ProjectLoadingStartEventName = \"projectLoadingStart\";\n            export interface ProjectLoadingStartEvent extends Event {\n                event: ProjectLoadingStartEventName;\n                body: ProjectLoadingStartEventBody;\n            }\n            export interface ProjectLoadingStartEventBody {\n                /** name of the project */\n                projectName: string;\n                /** reason for loading */\n                reason: string;\n            }\n            export type ProjectLoadingFinishEventName = \"projectLoadingFinish\";\n            export interface ProjectLoadingFinishEvent extends Event {\n                event: ProjectLoadingFinishEventName;\n                body: ProjectLoadingFinishEventBody;\n            }\n            export interface ProjectLoadingFinishEventBody {\n                /** name of the project */\n                projectName: string;\n            }\n            export type SurveyReadyEventName = \"surveyReady\";\n            export interface SurveyReadyEvent extends Event {\n                event: SurveyReadyEventName;\n                body: SurveyReadyEventBody;\n            }\n            export interface SurveyReadyEventBody {\n                /** Name of the survey. This is an internal machine- and programmer-friendly name */\n                surveyId: string;\n            }\n            export type LargeFileReferencedEventName = \"largeFileReferenced\";\n            export interface LargeFileReferencedEvent extends Event {\n                event: LargeFileReferencedEventName;\n                body: LargeFileReferencedEventBody;\n            }\n            export interface LargeFileReferencedEventBody {\n                /**\n                 * name of the large file being loaded\n                 */\n                file: string;\n                /**\n                 * size of the file\n                 */\n                fileSize: number;\n                /**\n                 * max file size allowed on the server\n                 */\n                maxFileSize: number;\n            }\n            export type CreateFileWatcherEventName = \"createFileWatcher\";\n            export interface CreateFileWatcherEvent extends Event {\n                readonly event: CreateFileWatcherEventName;\n                readonly body: CreateFileWatcherEventBody;\n            }\n            export interface CreateFileWatcherEventBody {\n                readonly id: number;\n                readonly path: string;\n            }\n            export type CreateDirectoryWatcherEventName = \"createDirectoryWatcher\";\n            export interface CreateDirectoryWatcherEvent extends Event {\n                readonly event: CreateDirectoryWatcherEventName;\n                readonly body: CreateDirectoryWatcherEventBody;\n            }\n            export interface CreateDirectoryWatcherEventBody {\n                readonly id: number;\n                readonly path: string;\n                readonly recursive: boolean;\n                readonly ignoreUpdate?: boolean;\n            }\n            export type CloseFileWatcherEventName = \"closeFileWatcher\";\n            export interface CloseFileWatcherEvent extends Event {\n                readonly event: CloseFileWatcherEventName;\n                readonly body: CloseFileWatcherEventBody;\n            }\n            export interface CloseFileWatcherEventBody {\n                readonly id: number;\n            }\n            /**\n             * Arguments for reload request.\n             */\n            export interface ReloadRequestArgs extends FileRequestArgs {\n                /**\n                 * Name of temporary file from which to reload file\n                 * contents. May be same as file.\n                 */\n                tmpfile: string;\n            }\n            /**\n             * Reload request message; value of command field is \"reload\".\n             * Reload contents of file with name given by the 'file' argument\n             * from temporary file with name given by the 'tmpfile' argument.\n             * The two names can be identical.\n             */\n            export interface ReloadRequest extends FileRequest {\n                command: CommandTypes.Reload;\n                arguments: ReloadRequestArgs;\n            }\n            /**\n             * Response to \"reload\" request. This is just an acknowledgement, so\n             * no body field is required.\n             */\n            export interface ReloadResponse extends Response {\n            }\n            /**\n             * Arguments for saveto request.\n             */\n            export interface SavetoRequestArgs extends FileRequestArgs {\n                /**\n                 * Name of temporary file into which to save server's view of\n                 * file contents.\n                 */\n                tmpfile: string;\n            }\n            /**\n             * Saveto request message; value of command field is \"saveto\".\n             * For debugging purposes, save to a temporaryfile (named by\n             * argument 'tmpfile') the contents of file named by argument\n             * 'file'.  The server does not currently send a response to a\n             * \"saveto\" request.\n             */\n            export interface SavetoRequest extends FileRequest {\n                command: CommandTypes.Saveto;\n                arguments: SavetoRequestArgs;\n            }\n            /**\n             * Arguments for navto request message.\n             */\n            export interface NavtoRequestArgs {\n                /**\n                 * Search term to navigate to from current location; term can\n                 * be '.*' or an identifier prefix.\n                 */\n                searchValue: string;\n                /**\n                 *  Optional limit on the number of items to return.\n                 */\n                maxResultCount?: number;\n                /**\n                 * The file for the request (absolute pathname required).\n                 */\n                file?: string;\n                /**\n                 * Optional flag to indicate we want results for just the current file\n                 * or the entire project.\n                 */\n                currentFileOnly?: boolean;\n                projectFileName?: string;\n            }\n            /**\n             * Navto request message; value of command field is \"navto\".\n             * Return list of objects giving file locations and symbols that\n             * match the search term given in argument 'searchTerm'.  The\n             * context for the search is given by the named file.\n             */\n            export interface NavtoRequest extends Request {\n                command: CommandTypes.Navto;\n                arguments: NavtoRequestArgs;\n            }\n            /**\n             * An item found in a navto response.\n             */\n            export interface NavtoItem extends FileSpan {\n                /**\n                 * The symbol's name.\n                 */\n                name: string;\n                /**\n                 * The symbol's kind (such as 'className' or 'parameterName').\n                 */\n                kind: ScriptElementKind;\n                /**\n                 * exact, substring, or prefix.\n                 */\n                matchKind: string;\n                /**\n                 * If this was a case sensitive or insensitive match.\n                 */\n                isCaseSensitive: boolean;\n                /**\n                 * Optional modifiers for the kind (such as 'public').\n                 */\n                kindModifiers?: string;\n                /**\n                 * Name of symbol's container symbol (if any); for example,\n                 * the class name if symbol is a class member.\n                 */\n                containerName?: string;\n                /**\n                 * Kind of symbol's container symbol (if any).\n                 */\n                containerKind?: ScriptElementKind;\n            }\n            /**\n             * Navto response message. Body is an array of navto items.  Each\n             * item gives a symbol that matched the search term.\n             */\n            export interface NavtoResponse extends Response {\n                body?: NavtoItem[];\n            }\n            /**\n             * Arguments for change request message.\n             */\n            export interface ChangeRequestArgs extends FormatRequestArgs {\n                /**\n                 * Optional string to insert at location (file, line, offset).\n                 */\n                insertString?: string;\n            }\n            /**\n             * Change request message; value of command field is \"change\".\n             * Update the server's view of the file named by argument 'file'.\n             * Server does not currently send a response to a change request.\n             */\n            export interface ChangeRequest extends FileLocationRequest {\n                command: CommandTypes.Change;\n                arguments: ChangeRequestArgs;\n            }\n            /**\n             * Response to \"brace\" request.\n             */\n            export interface BraceResponse extends Response {\n                body?: TextSpan[];\n            }\n            /**\n             * Brace matching request; value of command field is \"brace\".\n             * Return response giving the file locations of matching braces\n             * found in file at location line, offset.\n             */\n            export interface BraceRequest extends FileLocationRequest {\n                command: CommandTypes.Brace;\n            }\n            /**\n             * NavBar items request; value of command field is \"navbar\".\n             * Return response giving the list of navigation bar entries\n             * extracted from the requested file.\n             */\n            export interface NavBarRequest extends FileRequest {\n                command: CommandTypes.NavBar;\n            }\n            /**\n             * NavTree request; value of command field is \"navtree\".\n             * Return response giving the navigation tree of the requested file.\n             */\n            export interface NavTreeRequest extends FileRequest {\n                command: CommandTypes.NavTree;\n            }\n            export interface NavigationBarItem {\n                /**\n                 * The item's display text.\n                 */\n                text: string;\n                /**\n                 * The symbol's kind (such as 'className' or 'parameterName').\n                 */\n                kind: ScriptElementKind;\n                /**\n                 * Optional modifiers for the kind (such as 'public').\n                 */\n                kindModifiers?: string;\n                /**\n                 * The definition locations of the item.\n                 */\n                spans: TextSpan[];\n                /**\n                 * Optional children.\n                 */\n                childItems?: NavigationBarItem[];\n                /**\n                 * Number of levels deep this item should appear.\n                 */\n                indent: number;\n            }\n            /** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */\n            export interface NavigationTree {\n                text: string;\n                kind: ScriptElementKind;\n                kindModifiers: string;\n                spans: TextSpan[];\n                nameSpan: TextSpan | undefined;\n                childItems?: NavigationTree[];\n            }\n            export type TelemetryEventName = \"telemetry\";\n            export interface TelemetryEvent extends Event {\n                event: TelemetryEventName;\n                body: TelemetryEventBody;\n            }\n            export interface TelemetryEventBody {\n                telemetryEventName: string;\n                payload: any;\n            }\n            export type TypesInstallerInitializationFailedEventName = \"typesInstallerInitializationFailed\";\n            export interface TypesInstallerInitializationFailedEvent extends Event {\n                event: TypesInstallerInitializationFailedEventName;\n                body: TypesInstallerInitializationFailedEventBody;\n            }\n            export interface TypesInstallerInitializationFailedEventBody {\n                message: string;\n            }\n            export type TypingsInstalledTelemetryEventName = \"typingsInstalled\";\n            export interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {\n                telemetryEventName: TypingsInstalledTelemetryEventName;\n                payload: TypingsInstalledTelemetryEventPayload;\n            }\n            export interface TypingsInstalledTelemetryEventPayload {\n                /**\n                 * Comma separated list of installed typing packages\n                 */\n                installedPackages: string;\n                /**\n                 * true if install request succeeded, otherwise - false\n                 */\n                installSuccess: boolean;\n                /**\n                 * version of typings installer\n                 */\n                typingsInstallerVersion: string;\n            }\n            export type BeginInstallTypesEventName = \"beginInstallTypes\";\n            export type EndInstallTypesEventName = \"endInstallTypes\";\n            export interface BeginInstallTypesEvent extends Event {\n                event: BeginInstallTypesEventName;\n                body: BeginInstallTypesEventBody;\n            }\n            export interface EndInstallTypesEvent extends Event {\n                event: EndInstallTypesEventName;\n                body: EndInstallTypesEventBody;\n            }\n            export interface InstallTypesEventBody {\n                /**\n                 * correlation id to match begin and end events\n                 */\n                eventId: number;\n                /**\n                 * list of packages to install\n                 */\n                packages: readonly string[];\n            }\n            export interface BeginInstallTypesEventBody extends InstallTypesEventBody {\n            }\n            export interface EndInstallTypesEventBody extends InstallTypesEventBody {\n                /**\n                 * true if installation succeeded, otherwise false\n                 */\n                success: boolean;\n            }\n            export interface NavBarResponse extends Response {\n                body?: NavigationBarItem[];\n            }\n            export interface NavTreeResponse extends Response {\n                body?: NavigationTree;\n            }\n            export type CallHierarchyItem = ChangePropertyTypes<ts.CallHierarchyItem, {\n                span: TextSpan;\n                selectionSpan: TextSpan;\n            }>;\n            export interface CallHierarchyIncomingCall {\n                from: CallHierarchyItem;\n                fromSpans: TextSpan[];\n            }\n            export interface CallHierarchyOutgoingCall {\n                to: CallHierarchyItem;\n                fromSpans: TextSpan[];\n            }\n            export interface PrepareCallHierarchyRequest extends FileLocationRequest {\n                command: CommandTypes.PrepareCallHierarchy;\n            }\n            export interface PrepareCallHierarchyResponse extends Response {\n                readonly body: CallHierarchyItem | CallHierarchyItem[];\n            }\n            export interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {\n                command: CommandTypes.ProvideCallHierarchyIncomingCalls;\n            }\n            export interface ProvideCallHierarchyIncomingCallsResponse extends Response {\n                readonly body: CallHierarchyIncomingCall[];\n            }\n            export interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {\n                command: CommandTypes.ProvideCallHierarchyOutgoingCalls;\n            }\n            export interface ProvideCallHierarchyOutgoingCallsResponse extends Response {\n                readonly body: CallHierarchyOutgoingCall[];\n            }\n            export enum IndentStyle {\n                None = \"None\",\n                Block = \"Block\",\n                Smart = \"Smart\",\n            }\n            export type EditorSettings = ChangePropertyTypes<ts.EditorSettings, {\n                indentStyle: IndentStyle | ts.IndentStyle;\n            }>;\n            export type FormatCodeSettings = ChangePropertyTypes<ts.FormatCodeSettings, {\n                indentStyle: IndentStyle | ts.IndentStyle;\n            }>;\n            export type CompilerOptions = ChangePropertyTypes<ChangeStringIndexSignature<ts.CompilerOptions, CompilerOptionsValue>, {\n                jsx: JsxEmit | ts.JsxEmit;\n                module: ModuleKind | ts.ModuleKind;\n                moduleResolution: ModuleResolutionKind | ts.ModuleResolutionKind;\n                newLine: NewLineKind | ts.NewLineKind;\n                target: ScriptTarget | ts.ScriptTarget;\n            }>;\n            export enum JsxEmit {\n                None = \"none\",\n                Preserve = \"preserve\",\n                ReactNative = \"react-native\",\n                React = \"react\",\n                ReactJSX = \"react-jsx\",\n                ReactJSXDev = \"react-jsxdev\",\n            }\n            export enum ModuleKind {\n                None = \"none\",\n                CommonJS = \"commonjs\",\n                AMD = \"amd\",\n                UMD = \"umd\",\n                System = \"system\",\n                ES6 = \"es6\",\n                ES2015 = \"es2015\",\n                ES2020 = \"es2020\",\n                ES2022 = \"es2022\",\n                ESNext = \"esnext\",\n                Node16 = \"node16\",\n                Node18 = \"node18\",\n                NodeNext = \"nodenext\",\n                Preserve = \"preserve\",\n            }\n            export enum ModuleResolutionKind {\n                Classic = \"classic\",\n                /** @deprecated Renamed to `Node10` */\n                Node = \"node\",\n                /** @deprecated Renamed to `Node10` */\n                NodeJs = \"node\",\n                Node10 = \"node10\",\n                Node16 = \"node16\",\n                NodeNext = \"nodenext\",\n                Bundler = \"bundler\",\n            }\n            export enum NewLineKind {\n                Crlf = \"Crlf\",\n                Lf = \"Lf\",\n            }\n            export enum ScriptTarget {\n                /** @deprecated */\n                ES3 = \"es3\",\n                ES5 = \"es5\",\n                ES6 = \"es6\",\n                ES2015 = \"es2015\",\n                ES2016 = \"es2016\",\n                ES2017 = \"es2017\",\n                ES2018 = \"es2018\",\n                ES2019 = \"es2019\",\n                ES2020 = \"es2020\",\n                ES2021 = \"es2021\",\n                ES2022 = \"es2022\",\n                ES2023 = \"es2023\",\n                ES2024 = \"es2024\",\n                ESNext = \"esnext\",\n                JSON = \"json\",\n                Latest = \"esnext\",\n            }\n        }\n        namespace typingsInstaller {\n            interface Log {\n                isEnabled(): boolean;\n                writeLine(text: string): void;\n            }\n            type RequestCompletedAction = (success: boolean) => void;\n            interface PendingRequest {\n                requestId: number;\n                packageNames: string[];\n                cwd: string;\n                onRequestCompleted: RequestCompletedAction;\n            }\n            abstract class TypingsInstaller {\n                protected readonly installTypingHost: InstallTypingHost;\n                private readonly globalCachePath;\n                private readonly safeListPath;\n                private readonly typesMapLocation;\n                private readonly throttleLimit;\n                protected readonly log: Log;\n                private readonly packageNameToTypingLocation;\n                private readonly missingTypingsSet;\n                private readonly knownCachesSet;\n                private readonly projectWatchers;\n                private safeList;\n                private pendingRunRequests;\n                private installRunCount;\n                private inFlightRequestCount;\n                abstract readonly typesRegistry: Map<string, MapLike<string>>;\n                constructor(installTypingHost: InstallTypingHost, globalCachePath: string, safeListPath: Path, typesMapLocation: Path, throttleLimit: number, log?: Log);\n                closeProject(req: CloseProject): void;\n                private closeWatchers;\n                install(req: DiscoverTypings): void;\n                private initializeSafeList;\n                private processCacheLocation;\n                private filterTypings;\n                protected ensurePackageDirectoryExists(directory: string): void;\n                private installTypings;\n                private ensureDirectoryExists;\n                private watchFiles;\n                private createSetTypings;\n                private installTypingsAsync;\n                private executeWithThrottling;\n                protected abstract installWorker(requestId: number, packageNames: string[], cwd: string, onRequestCompleted: RequestCompletedAction): void;\n                protected abstract sendResponse(response: SetTypings | InvalidateCachedTypings | BeginInstallTypes | EndInstallTypes | WatchTypingLocations): void;\n                protected readonly latestDistTag = \"latest\";\n            }\n        }\n        type ActionSet = \"action::set\";\n        type ActionInvalidate = \"action::invalidate\";\n        type ActionPackageInstalled = \"action::packageInstalled\";\n        type EventTypesRegistry = \"event::typesRegistry\";\n        type EventBeginInstallTypes = \"event::beginInstallTypes\";\n        type EventEndInstallTypes = \"event::endInstallTypes\";\n        type EventInitializationFailed = \"event::initializationFailed\";\n        type ActionWatchTypingLocations = \"action::watchTypingLocations\";\n        interface TypingInstallerResponse {\n            readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed | ActionWatchTypingLocations;\n        }\n        interface TypingInstallerRequestWithProjectName {\n            readonly projectName: string;\n        }\n        interface DiscoverTypings extends TypingInstallerRequestWithProjectName {\n            readonly fileNames: string[];\n            readonly projectRootPath: Path;\n            readonly compilerOptions: CompilerOptions;\n            readonly typeAcquisition: TypeAcquisition;\n            readonly unresolvedImports: SortedReadonlyArray<string>;\n            readonly cachePath?: string;\n            readonly kind: \"discover\";\n        }\n        interface CloseProject extends TypingInstallerRequestWithProjectName {\n            readonly kind: \"closeProject\";\n        }\n        interface TypesRegistryRequest {\n            readonly kind: \"typesRegistry\";\n        }\n        interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {\n            readonly kind: \"installPackage\";\n            readonly fileName: Path;\n            readonly packageName: string;\n            readonly projectRootPath: Path;\n            readonly id: number;\n        }\n        interface PackageInstalledResponse extends ProjectResponse {\n            readonly kind: ActionPackageInstalled;\n            readonly id: number;\n            readonly success: boolean;\n            readonly message: string;\n        }\n        interface InitializationFailedResponse extends TypingInstallerResponse {\n            readonly kind: EventInitializationFailed;\n            readonly message: string;\n            readonly stack?: string;\n        }\n        interface ProjectResponse extends TypingInstallerResponse {\n            readonly projectName: string;\n        }\n        interface InvalidateCachedTypings extends ProjectResponse {\n            readonly kind: ActionInvalidate;\n        }\n        interface InstallTypes extends ProjectResponse {\n            readonly kind: EventBeginInstallTypes | EventEndInstallTypes;\n            readonly eventId: number;\n            readonly typingsInstallerVersion: string;\n            readonly packagesToInstall: readonly string[];\n        }\n        interface BeginInstallTypes extends InstallTypes {\n            readonly kind: EventBeginInstallTypes;\n        }\n        interface EndInstallTypes extends InstallTypes {\n            readonly kind: EventEndInstallTypes;\n            readonly installSuccess: boolean;\n        }\n        interface InstallTypingHost extends JsTyping.TypingResolutionHost {\n            useCaseSensitiveFileNames: boolean;\n            writeFile(path: string, content: string): void;\n            createDirectory(path: string): void;\n            getCurrentDirectory?(): string;\n        }\n        interface SetTypings extends ProjectResponse {\n            readonly typeAcquisition: TypeAcquisition;\n            readonly compilerOptions: CompilerOptions;\n            readonly typings: string[];\n            readonly unresolvedImports: SortedReadonlyArray<string>;\n            readonly kind: ActionSet;\n        }\n        interface WatchTypingLocations extends ProjectResponse {\n            /** if files is undefined, retain same set of watchers */\n            readonly files: readonly string[] | undefined;\n            readonly kind: ActionWatchTypingLocations;\n        }\n        interface CompressedData {\n            length: number;\n            compressionKind: string;\n            data: any;\n        }\n        type ModuleImportResult = {\n            module: {};\n            error: undefined;\n        } | {\n            module: undefined;\n            error: {\n                stack?: string;\n                message?: string;\n            };\n        };\n        /** @deprecated Use {@link ModuleImportResult} instead. */\n        type RequireResult = ModuleImportResult;\n        interface ServerHost extends System {\n            watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;\n            watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;\n            preferNonRecursiveWatch?: boolean;\n            setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n            clearTimeout(timeoutId: any): void;\n            setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;\n            clearImmediate(timeoutId: any): void;\n            gc?(): void;\n            trace?(s: string): void;\n            require?(initialPath: string, moduleName: string): ModuleImportResult;\n        }\n        interface InstallPackageOptionsWithProject extends InstallPackageOptions {\n            projectName: string;\n            projectRootPath: Path;\n        }\n        interface ITypingsInstaller {\n            isKnownTypesPackageName(name: string): boolean;\n            installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;\n            enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string> | undefined): void;\n            attach(projectService: ProjectService): void;\n            onProjectClosed(p: Project): void;\n            readonly globalTypingsCacheLocation: string | undefined;\n        }\n        function createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, cachePath?: string): DiscoverTypings;\n        function toNormalizedPath(fileName: string): NormalizedPath;\n        function normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) => string): Path;\n        function asNormalizedPath(fileName: string): NormalizedPath;\n        function createNormalizedPathMap<T>(): NormalizedPathMap<T>;\n        function isInferredProjectName(name: string): boolean;\n        function makeInferredProjectName(counter: number): string;\n        function createSortedArray<T>(): SortedArray<T>;\n        enum LogLevel {\n            terse = 0,\n            normal = 1,\n            requestTime = 2,\n            verbose = 3,\n        }\n        const emptyArray: SortedReadonlyArray<never>;\n        interface Logger {\n            close(): void;\n            hasLevel(level: LogLevel): boolean;\n            loggingEnabled(): boolean;\n            perftrc(s: string): void;\n            info(s: string): void;\n            startGroup(): void;\n            endGroup(): void;\n            msg(s: string, type?: Msg): void;\n            getLogFileName(): string | undefined;\n        }\n        enum Msg {\n            Err = \"Err\",\n            Info = \"Info\",\n            Perf = \"Perf\",\n        }\n        namespace Errors {\n            function ThrowNoProject(): never;\n            function ThrowProjectLanguageServiceDisabled(): never;\n            function ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;\n        }\n        type NormalizedPath = string & {\n            __normalizedPathTag: any;\n        };\n        interface NormalizedPathMap<T> {\n            get(path: NormalizedPath): T | undefined;\n            set(path: NormalizedPath, value: T): void;\n            contains(path: NormalizedPath): boolean;\n            remove(path: NormalizedPath): void;\n        }\n        function isDynamicFileName(fileName: NormalizedPath): boolean;\n        class ScriptInfo {\n            private readonly host;\n            readonly fileName: NormalizedPath;\n            readonly scriptKind: ScriptKind;\n            readonly hasMixedContent: boolean;\n            readonly path: Path;\n            /**\n             * All projects that include this file\n             */\n            readonly containingProjects: Project[];\n            private formatSettings;\n            private preferences;\n            private realpath;\n            constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: number);\n            isScriptOpen(): boolean;\n            open(newText: string | undefined): void;\n            close(fileExists?: boolean): void;\n            getSnapshot(): IScriptSnapshot;\n            private ensureRealPath;\n            getFormatCodeSettings(): FormatCodeSettings | undefined;\n            getPreferences(): protocol.UserPreferences | undefined;\n            attachToProject(project: Project): boolean;\n            isAttached(project: Project): boolean;\n            detachFromProject(project: Project): void;\n            detachAllProjects(): void;\n            getDefaultProject(): Project;\n            registerFileUpdate(): void;\n            setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): void;\n            getLatestVersion(): string;\n            saveTo(fileName: string): void;\n            reloadFromFile(tempFileName?: NormalizedPath): boolean;\n            editContent(start: number, end: number, newText: string): void;\n            markContainingProjectsAsDirty(): void;\n            isOrphan(): boolean;\n            /**\n             *  @param line 1 based index\n             */\n            lineToTextSpan(line: number): TextSpan;\n            /**\n             * @param line 1 based index\n             * @param offset 1 based index\n             */\n            lineOffsetToPosition(line: number, offset: number): number;\n            positionToLineOffset(position: number): protocol.Location;\n            isJavaScript(): boolean;\n        }\n        function allRootFilesAreJsOrDts(project: Project): boolean;\n        function allFilesAreJsOrDts(project: Project): boolean;\n        enum ProjectKind {\n            Inferred = 0,\n            Configured = 1,\n            External = 2,\n            AutoImportProvider = 3,\n            Auxiliary = 4,\n        }\n        interface PluginCreateInfo {\n            project: Project;\n            languageService: LanguageService;\n            languageServiceHost: LanguageServiceHost;\n            serverHost: ServerHost;\n            session?: Session<unknown>;\n            config: any;\n        }\n        interface PluginModule {\n            create(createInfo: PluginCreateInfo): LanguageService;\n            getExternalFiles?(proj: Project, updateLevel: ProgramUpdateLevel): string[];\n            onConfigurationChanged?(config: any): void;\n        }\n        interface PluginModuleWithName {\n            name: string;\n            module: PluginModule;\n        }\n        type PluginModuleFactory = (mod: {\n            typescript: typeof ts;\n        }) => PluginModule;\n        abstract class Project implements LanguageServiceHost, ModuleResolutionHost {\n            readonly projectKind: ProjectKind;\n            readonly projectService: ProjectService;\n            private compilerOptions;\n            compileOnSaveEnabled: boolean;\n            protected watchOptions: WatchOptions | undefined;\n            private rootFilesMap;\n            private program;\n            private externalFiles;\n            private missingFilesMap;\n            private generatedFilesMap;\n            private hasAddedorRemovedFiles;\n            private hasAddedOrRemovedSymlinks;\n            protected languageService: LanguageService;\n            languageServiceEnabled: boolean;\n            readonly trace?: (s: string) => void;\n            readonly realpath?: (path: string) => string;\n            private builderState;\n            private updatedFileNames;\n            private lastReportedFileNames;\n            private lastReportedVersion;\n            protected projectErrors: Diagnostic[] | undefined;\n            private typingsCache;\n            private typingWatchers;\n            private readonly cancellationToken;\n            isNonTsProject(): boolean;\n            isJsOnlyProject(): boolean;\n            static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void): {} | undefined;\n            private exportMapCache;\n            private changedFilesForExportMapCache;\n            private moduleSpecifierCache;\n            private symlinks;\n            readonly jsDocParsingMode: JSDocParsingMode | undefined;\n            isKnownTypesPackageName(name: string): boolean;\n            installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;\n            getCompilationSettings(): CompilerOptions;\n            getCompilerOptions(): CompilerOptions;\n            getNewLine(): string;\n            getProjectVersion(): string;\n            getProjectReferences(): readonly ProjectReference[] | undefined;\n            getScriptFileNames(): string[];\n            private getOrCreateScriptInfoAndAttachToProject;\n            getScriptKind(fileName: string): ScriptKind;\n            getScriptVersion(filename: string): string;\n            getScriptSnapshot(filename: string): IScriptSnapshot | undefined;\n            getCancellationToken(): HostCancellationToken;\n            getCurrentDirectory(): string;\n            getDefaultLibFileName(): string;\n            useCaseSensitiveFileNames(): boolean;\n            readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n            readFile(fileName: string): string | undefined;\n            writeFile(fileName: string, content: string): void;\n            fileExists(file: string): boolean;\n            directoryExists(path: string): boolean;\n            getDirectories(path: string): string[];\n            log(s: string): void;\n            error(s: string): void;\n            private setInternalCompilerOptionsForEmittingJsFiles;\n            /**\n             * Get the errors that dont have any file name associated\n             */\n            getGlobalProjectErrors(): readonly Diagnostic[];\n            /**\n             * Get all the project errors\n             */\n            getAllProjectErrors(): readonly Diagnostic[];\n            setProjectErrors(projectErrors: Diagnostic[] | undefined): void;\n            getLanguageService(ensureSynchronized?: boolean): LanguageService;\n            getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];\n            /**\n             * Returns true if emit was conducted\n             */\n            emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult;\n            enableLanguageService(): void;\n            disableLanguageService(lastFileExceededProgramSize?: string): void;\n            getProjectName(): string;\n            protected removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;\n            getExternalFiles(updateLevel?: ProgramUpdateLevel): SortedReadonlyArray<string>;\n            getSourceFile(path: Path): SourceFile | undefined;\n            close(): void;\n            private detachScriptInfoIfNotRoot;\n            isClosed(): boolean;\n            hasRoots(): boolean;\n            getRootFiles(): NormalizedPath[];\n            getRootScriptInfos(): ScriptInfo[];\n            getScriptInfos(): ScriptInfo[];\n            getExcludedFiles(): readonly NormalizedPath[];\n            getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): NormalizedPath[];\n            hasConfigFile(configFilePath: NormalizedPath): boolean;\n            containsScriptInfo(info: ScriptInfo): boolean;\n            containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;\n            isRoot(info: ScriptInfo): boolean;\n            addRoot(info: ScriptInfo, fileName?: NormalizedPath): void;\n            addMissingFileRoot(fileName: NormalizedPath): void;\n            removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): void;\n            registerFileUpdate(fileName: string): void;\n            /**\n             * Updates set of files that contribute to this project\n             * @returns: true if set of files in the project stays the same and false - otherwise.\n             */\n            updateGraph(): boolean;\n            private closeWatchingTypingLocations;\n            private onTypingInstallerWatchInvoke;\n            protected removeExistingTypings(include: string[]): string[];\n            private updateGraphWorker;\n            private detachScriptInfoFromProject;\n            private addMissingFileWatcher;\n            private isWatchedMissingFile;\n            private createGeneratedFileWatcher;\n            private isValidGeneratedFileWatcher;\n            private clearGeneratedFileWatch;\n            getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;\n            getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;\n            filesToString(writeProjectFileNames: boolean): string;\n            private filesToStringWorker;\n            setCompilerOptions(compilerOptions: CompilerOptions): void;\n            setTypeAcquisition(newTypeAcquisition: TypeAcquisition | undefined): void;\n            getTypeAcquisition(): TypeAcquisition;\n            protected removeRoot(info: ScriptInfo): void;\n            protected enableGlobalPlugins(options: CompilerOptions): void;\n            protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[]): void;\n            /** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */\n            refreshDiagnostics(): void;\n            private isDefaultProjectForOpenFiles;\n        }\n        /**\n         * If a file is opened and no tsconfig (or jsconfig) is found,\n         * the file and its imports/references are put into an InferredProject.\n         */\n        class InferredProject extends Project {\n            private _isJsInferredProject;\n            toggleJsInferredProject(isJsInferredProject: boolean): void;\n            setCompilerOptions(options?: CompilerOptions): void;\n            /** this is canonical project root path */\n            readonly projectRootPath: string | undefined;\n            addRoot(info: ScriptInfo): void;\n            removeRoot(info: ScriptInfo): void;\n            isProjectWithSingleRoot(): boolean;\n            close(): void;\n            getTypeAcquisition(): TypeAcquisition;\n        }\n        class AutoImportProviderProject extends Project {\n            private hostProject;\n            private static readonly maxDependencies;\n            private rootFileNames;\n            updateGraph(): boolean;\n            hasRoots(): boolean;\n            getScriptFileNames(): string[];\n            getLanguageService(): never;\n            getHostForAutoImportProvider(): never;\n            getProjectReferences(): readonly ProjectReference[] | undefined;\n        }\n        /**\n         * If a file is opened, the server will look for a tsconfig (or jsconfig)\n         * and if successful create a ConfiguredProject for it.\n         * Otherwise it will create an InferredProject.\n         */\n        class ConfiguredProject extends Project {\n            readonly canonicalConfigFilePath: NormalizedPath;\n            private projectReferences;\n            private compilerHost?;\n            private releaseParsedConfig;\n            /**\n             * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph\n             * @returns: true if set of files in the project stays the same and false - otherwise.\n             */\n            updateGraph(): boolean;\n            getConfigFilePath(): NormalizedPath;\n            getProjectReferences(): readonly ProjectReference[] | undefined;\n            updateReferences(refs: readonly ProjectReference[] | undefined): void;\n            /**\n             * Get the errors that dont have any file name associated\n             */\n            getGlobalProjectErrors(): readonly Diagnostic[];\n            /**\n             * Get all the project errors\n             */\n            getAllProjectErrors(): readonly Diagnostic[];\n            setProjectErrors(projectErrors: Diagnostic[]): void;\n            close(): void;\n            getEffectiveTypeRoots(): string[];\n        }\n        /**\n         * Project whose configuration is handled externally, such as in a '.csproj'.\n         * These are created only if a host explicitly calls `openExternalProject`.\n         */\n        class ExternalProject extends Project {\n            externalProjectName: string;\n            compileOnSaveEnabled: boolean;\n            excludedFiles: readonly NormalizedPath[];\n            updateGraph(): boolean;\n            getExcludedFiles(): readonly NormalizedPath[];\n        }\n        function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;\n        function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin;\n        function convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions, currentDirectory?: string): WatchOptionsAndErrors | undefined;\n        function convertTypeAcquisition(protocolOptions: protocol.InferredProjectCompilerOptions): TypeAcquisition | undefined;\n        function tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;\n        function convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind;\n        const maxProgramSizeForNonTsFiles: number;\n        const ProjectsUpdatedInBackgroundEvent = \"projectsUpdatedInBackground\";\n        interface ProjectsUpdatedInBackgroundEvent {\n            eventName: typeof ProjectsUpdatedInBackgroundEvent;\n            data: {\n                openFiles: string[];\n            };\n        }\n        const ProjectLoadingStartEvent = \"projectLoadingStart\";\n        interface ProjectLoadingStartEvent {\n            eventName: typeof ProjectLoadingStartEvent;\n            data: {\n                project: Project;\n                reason: string;\n            };\n        }\n        const ProjectLoadingFinishEvent = \"projectLoadingFinish\";\n        interface ProjectLoadingFinishEvent {\n            eventName: typeof ProjectLoadingFinishEvent;\n            data: {\n                project: Project;\n            };\n        }\n        const LargeFileReferencedEvent = \"largeFileReferenced\";\n        interface LargeFileReferencedEvent {\n            eventName: typeof LargeFileReferencedEvent;\n            data: {\n                file: string;\n                fileSize: number;\n                maxFileSize: number;\n            };\n        }\n        const ConfigFileDiagEvent = \"configFileDiag\";\n        interface ConfigFileDiagEvent {\n            eventName: typeof ConfigFileDiagEvent;\n            data: {\n                triggerFile: string;\n                configFileName: string;\n                diagnostics: readonly Diagnostic[];\n            };\n        }\n        const ProjectLanguageServiceStateEvent = \"projectLanguageServiceState\";\n        interface ProjectLanguageServiceStateEvent {\n            eventName: typeof ProjectLanguageServiceStateEvent;\n            data: {\n                project: Project;\n                languageServiceEnabled: boolean;\n            };\n        }\n        const ProjectInfoTelemetryEvent = \"projectInfo\";\n        /** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */\n        interface ProjectInfoTelemetryEvent {\n            readonly eventName: typeof ProjectInfoTelemetryEvent;\n            readonly data: ProjectInfoTelemetryEventData;\n        }\n        const OpenFileInfoTelemetryEvent = \"openFileInfo\";\n        /**\n         * Info that we may send about a file that was just opened.\n         * Info about a file will only be sent once per session, even if the file changes in ways that might affect the info.\n         * Currently this is only sent for '.js' files.\n         */\n        interface OpenFileInfoTelemetryEvent {\n            readonly eventName: typeof OpenFileInfoTelemetryEvent;\n            readonly data: OpenFileInfoTelemetryEventData;\n        }\n        const CreateFileWatcherEvent: protocol.CreateFileWatcherEventName;\n        interface CreateFileWatcherEvent {\n            readonly eventName: protocol.CreateFileWatcherEventName;\n            readonly data: protocol.CreateFileWatcherEventBody;\n        }\n        const CreateDirectoryWatcherEvent: protocol.CreateDirectoryWatcherEventName;\n        interface CreateDirectoryWatcherEvent {\n            readonly eventName: protocol.CreateDirectoryWatcherEventName;\n            readonly data: protocol.CreateDirectoryWatcherEventBody;\n        }\n        const CloseFileWatcherEvent: protocol.CloseFileWatcherEventName;\n        interface CloseFileWatcherEvent {\n            readonly eventName: protocol.CloseFileWatcherEventName;\n            readonly data: protocol.CloseFileWatcherEventBody;\n        }\n        interface ProjectInfoTelemetryEventData {\n            /** Cryptographically secure hash of project file location. */\n            readonly projectId: string;\n            /** Count of file extensions seen in the project. */\n            readonly fileStats: FileStats;\n            /**\n             * Any compiler options that might contain paths will be taken out.\n             * Enum compiler options will be converted to strings.\n             */\n            readonly compilerOptions: CompilerOptions;\n            readonly extends: boolean | undefined;\n            readonly files: boolean | undefined;\n            readonly include: boolean | undefined;\n            readonly exclude: boolean | undefined;\n            readonly compileOnSave: boolean;\n            readonly typeAcquisition: ProjectInfoTypeAcquisitionData;\n            readonly configFileName: \"tsconfig.json\" | \"jsconfig.json\" | \"other\";\n            readonly projectType: \"external\" | \"configured\";\n            readonly languageServiceEnabled: boolean;\n            /** TypeScript version used by the server. */\n            readonly version: string;\n        }\n        interface OpenFileInfoTelemetryEventData {\n            readonly info: OpenFileInfo;\n        }\n        interface ProjectInfoTypeAcquisitionData {\n            readonly enable: boolean | undefined;\n            readonly include: boolean;\n            readonly exclude: boolean;\n        }\n        interface FileStats {\n            readonly js: number;\n            readonly jsSize?: number;\n            readonly jsx: number;\n            readonly jsxSize?: number;\n            readonly ts: number;\n            readonly tsSize?: number;\n            readonly tsx: number;\n            readonly tsxSize?: number;\n            readonly dts: number;\n            readonly dtsSize?: number;\n            readonly deferred: number;\n            readonly deferredSize?: number;\n        }\n        interface OpenFileInfo {\n            readonly checkJs: boolean;\n        }\n        type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent | CreateFileWatcherEvent | CreateDirectoryWatcherEvent | CloseFileWatcherEvent;\n        type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;\n        interface SafeList {\n            [name: string]: {\n                match: RegExp;\n                exclude?: (string | number)[][];\n                types?: string[];\n            };\n        }\n        interface TypesMapFile {\n            typesMap: SafeList;\n            simpleMap: {\n                [libName: string]: string;\n            };\n        }\n        interface HostConfiguration {\n            formatCodeOptions: FormatCodeSettings;\n            preferences: protocol.UserPreferences;\n            hostInfo: string;\n            extraFileExtensions?: FileExtensionInfo[];\n            watchOptions?: WatchOptions;\n        }\n        interface OpenConfiguredProjectResult {\n            configFileName?: NormalizedPath;\n            configFileErrors?: readonly Diagnostic[];\n        }\n        const nullTypingsInstaller: ITypingsInstaller;\n        interface ProjectServiceOptions {\n            host: ServerHost;\n            logger: Logger;\n            cancellationToken: HostCancellationToken;\n            useSingleInferredProject: boolean;\n            useInferredProjectPerProjectRoot: boolean;\n            typingsInstaller?: ITypingsInstaller;\n            eventHandler?: ProjectServiceEventHandler;\n            canUseWatchEvents?: boolean;\n            suppressDiagnosticEvents?: boolean;\n            throttleWaitMilliseconds?: number;\n            globalPlugins?: readonly string[];\n            pluginProbeLocations?: readonly string[];\n            allowLocalPluginLoads?: boolean;\n            typesMapLocation?: string;\n            serverMode?: LanguageServiceMode;\n            session: Session<unknown> | undefined;\n            jsDocParsingMode?: JSDocParsingMode;\n        }\n        interface WatchOptionsAndErrors {\n            watchOptions: WatchOptions;\n            errors: Diagnostic[] | undefined;\n        }\n        class ProjectService {\n            private readonly nodeModulesWatchers;\n            private readonly filenameToScriptInfoVersion;\n            private readonly allJsFilesForOpenFileTelemetry;\n            private readonly externalProjectToConfiguredProjectMap;\n            /**\n             * external projects (configuration and list of root files is not controlled by tsserver)\n             */\n            readonly externalProjects: ExternalProject[];\n            /**\n             * projects built from openFileRoots\n             */\n            readonly inferredProjects: InferredProject[];\n            /**\n             * projects specified by a tsconfig.json file\n             */\n            readonly configuredProjects: Map<string, ConfiguredProject>;\n            /**\n             * Open files: with value being project root path, and key being Path of the file that is open\n             */\n            readonly openFiles: Map<Path, NormalizedPath | undefined>;\n            private readonly configFileForOpenFiles;\n            private rootOfInferredProjects;\n            private readonly openFilesWithNonRootedDiskPath;\n            private compilerOptionsForInferredProjects;\n            private compilerOptionsForInferredProjectsPerProjectRoot;\n            private watchOptionsForInferredProjects;\n            private watchOptionsForInferredProjectsPerProjectRoot;\n            private typeAcquisitionForInferredProjects;\n            private typeAcquisitionForInferredProjectsPerProjectRoot;\n            private readonly projectToSizeMap;\n            private readonly hostConfiguration;\n            private safelist;\n            private readonly legacySafelist;\n            private pendingProjectUpdates;\n            private pendingOpenFileProjectUpdates?;\n            readonly currentDirectory: NormalizedPath;\n            readonly toCanonicalFileName: (f: string) => string;\n            readonly host: ServerHost;\n            readonly logger: Logger;\n            readonly cancellationToken: HostCancellationToken;\n            readonly useSingleInferredProject: boolean;\n            readonly useInferredProjectPerProjectRoot: boolean;\n            readonly typingsInstaller: ITypingsInstaller;\n            private readonly globalCacheLocationDirectoryPath;\n            readonly throttleWaitMilliseconds?: number;\n            private readonly suppressDiagnosticEvents?;\n            readonly globalPlugins: readonly string[];\n            readonly pluginProbeLocations: readonly string[];\n            readonly allowLocalPluginLoads: boolean;\n            readonly typesMapLocation: string | undefined;\n            readonly serverMode: LanguageServiceMode;\n            private readonly seenProjects;\n            private readonly sharedExtendedConfigFileWatchers;\n            private readonly extendedConfigCache;\n            private packageJsonFilesMap;\n            private incompleteCompletionsCache;\n            private performanceEventHandler?;\n            private pendingPluginEnablements?;\n            private currentPluginEnablementPromise?;\n            readonly jsDocParsingMode: JSDocParsingMode | undefined;\n            constructor(opts: ProjectServiceOptions);\n            toPath(fileName: string): Path;\n            private loadTypesMap;\n            updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): void;\n            private delayUpdateProjectGraph;\n            private delayUpdateProjectGraphs;\n            setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.InferredProjectCompilerOptions, projectRootPath?: string): void;\n            findProject(projectName: string): Project | undefined;\n            getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;\n            private tryGetDefaultProjectForEnsuringConfiguredProjectForFile;\n            private doEnsureDefaultProjectForFile;\n            getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;\n            private ensureProjectStructuresUptoDate;\n            getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;\n            getPreferences(file: NormalizedPath): protocol.UserPreferences;\n            getHostFormatCodeOptions(): FormatCodeSettings;\n            getHostPreferences(): protocol.UserPreferences;\n            private onSourceFileChanged;\n            private handleSourceMapProjects;\n            private delayUpdateSourceInfoProjects;\n            private delayUpdateProjectsOfScriptInfoPath;\n            private handleDeletedFile;\n            private watchWildcardDirectory;\n            private onWildCardDirectoryWatcherInvoke;\n            private delayUpdateProjectsFromParsedConfigOnConfigFileChange;\n            private onConfigFileChanged;\n            private removeProject;\n            private assignOrphanScriptInfosToInferredProject;\n            private closeOpenFile;\n            private deleteScriptInfo;\n            private configFileExists;\n            private createConfigFileWatcherForParsedConfig;\n            private ensureConfigFileWatcherForProject;\n            private forEachConfigFileLocation;\n            private getConfigFileNameForFileFromCache;\n            private setConfigFileNameForFileInCache;\n            private printProjects;\n            private getConfiguredProjectByCanonicalConfigFilePath;\n            private findExternalProjectByProjectName;\n            private getFilenameForExceededTotalSizeLimitForNonTsFiles;\n            private createExternalProject;\n            private addFilesToNonInferredProject;\n            private loadConfiguredProject;\n            private updateNonInferredProjectFiles;\n            private updateRootAndOptionsOfNonInferredProject;\n            private reloadFileNamesOfParsedConfig;\n            private setProjectForReload;\n            private clearSemanticCache;\n            private getOrCreateInferredProjectForProjectRootPathIfEnabled;\n            private getOrCreateSingleInferredProjectIfEnabled;\n            private getOrCreateSingleInferredWithoutProjectRoot;\n            private createInferredProject;\n            getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;\n            private watchClosedScriptInfo;\n            private createNodeModulesWatcher;\n            private watchClosedScriptInfoInNodeModules;\n            private getModifiedTime;\n            private refreshScriptInfo;\n            private refreshScriptInfosInDirectory;\n            private stopWatchingScriptInfo;\n            private getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;\n            getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {\n                fileExists(path: string): boolean;\n            }): ScriptInfo | undefined;\n            private getOrCreateScriptInfoWorker;\n            /**\n             * This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred\n             */\n            getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;\n            getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;\n            private addSourceInfoToSourceMap;\n            private addMissingSourceMapFile;\n            setHostConfiguration(args: protocol.ConfigureRequestArguments): void;\n            private getWatchOptionsFromProjectWatchOptions;\n            closeLog(): void;\n            private sendSourceFileChange;\n            /**\n             * This function rebuilds the project for every file opened by the client\n             * This does not reload contents of open files from disk. But we could do that if needed\n             */\n            reloadProjects(): void;\n            private removeRootOfInferredProjectIfNowPartOfOtherProject;\n            private ensureProjectForOpenFiles;\n            /**\n             * Open file whose contents is managed by the client\n             * @param filename is absolute pathname\n             * @param fileContent is a known version of the file content that is more up to date than the one on disk\n             */\n            openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;\n            private findExternalProjectContainingOpenScriptInfo;\n            private getOrCreateOpenScriptInfo;\n            private assignProjectToOpenedScriptInfo;\n            private tryFindDefaultConfiguredProjectForOpenScriptInfo;\n            private isMatchedByConfig;\n            private tryFindDefaultConfiguredProjectForOpenScriptInfoOrClosedFileInfo;\n            private tryFindDefaultConfiguredProjectAndLoadAncestorsForOpenScriptInfo;\n            private ensureProjectChildren;\n            private cleanupConfiguredProjects;\n            private cleanupProjectsAndScriptInfos;\n            private tryInvokeWildCardDirectories;\n            openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;\n            private removeOrphanScriptInfos;\n            private telemetryOnOpenFile;\n            /**\n             * Close file whose contents is managed by the client\n             * @param filename is absolute pathname\n             */\n            closeClientFile(uncheckedFileName: string): void;\n            private collectChanges;\n            closeExternalProject(uncheckedFileName: string): void;\n            openExternalProjects(projects: protocol.ExternalProject[]): void;\n            private static readonly filenameEscapeRegexp;\n            private static escapeFilenameForRegex;\n            resetSafeList(): void;\n            applySafeList(proj: protocol.ExternalProject): NormalizedPath[];\n            private applySafeListWorker;\n            openExternalProject(proj: protocol.ExternalProject): void;\n            hasDeferredExtension(): boolean;\n            private endEnablePlugin;\n            private enableRequestedPluginsAsync;\n            private enableRequestedPluginsWorker;\n            configurePlugin(args: protocol.ConfigurePluginRequestArguments): void;\n            private watchPackageJsonFile;\n            private onPackageJsonChange;\n        }\n        function formatMessage<T extends protocol.Message>(msg: T, logger: Logger, byteLength: (s: string, encoding: BufferEncoding) => number, newLine: string): string;\n        interface ServerCancellationToken extends HostCancellationToken {\n            setRequest(requestId: number): void;\n            resetRequest(requestId: number): void;\n        }\n        const nullCancellationToken: ServerCancellationToken;\n        /** @deprecated use ts.server.protocol.CommandTypes */\n        type CommandNames = protocol.CommandTypes;\n        /** @deprecated use ts.server.protocol.CommandTypes */\n        const CommandNames: any;\n        type Event = <T extends object>(body: T, eventName: string) => void;\n        interface EventSender {\n            event: Event;\n        }\n        interface SessionOptions {\n            host: ServerHost;\n            cancellationToken: ServerCancellationToken;\n            useSingleInferredProject: boolean;\n            useInferredProjectPerProjectRoot: boolean;\n            typingsInstaller?: ITypingsInstaller;\n            byteLength: (buf: string, encoding?: BufferEncoding) => number;\n            hrtime: (start?: [\n                number,\n                number,\n            ]) => [\n                number,\n                number,\n            ];\n            logger: Logger;\n            /**\n             * If falsy, all events are suppressed.\n             */\n            canUseEvents: boolean;\n            canUseWatchEvents?: boolean;\n            eventHandler?: ProjectServiceEventHandler;\n            /** Has no effect if eventHandler is also specified. */\n            suppressDiagnosticEvents?: boolean;\n            serverMode?: LanguageServiceMode;\n            throttleWaitMilliseconds?: number;\n            noGetErrOnBackgroundUpdate?: boolean;\n            globalPlugins?: readonly string[];\n            pluginProbeLocations?: readonly string[];\n            allowLocalPluginLoads?: boolean;\n            typesMapLocation?: string;\n        }\n        class Session<TMessage = string> implements EventSender {\n            private readonly gcTimer;\n            protected projectService: ProjectService;\n            private changeSeq;\n            private performanceData;\n            private currentRequestId;\n            private errorCheck;\n            protected host: ServerHost;\n            private readonly cancellationToken;\n            protected readonly typingsInstaller: ITypingsInstaller;\n            protected byteLength: (buf: string, encoding?: BufferEncoding) => number;\n            private hrtime;\n            protected logger: Logger;\n            protected canUseEvents: boolean;\n            private suppressDiagnosticEvents?;\n            private eventHandler;\n            private readonly noGetErrOnBackgroundUpdate?;\n            constructor(opts: SessionOptions);\n            private sendRequestCompletedEvent;\n            private addPerformanceData;\n            private addDiagnosticsPerformanceData;\n            private performanceEventHandler;\n            private defaultEventHandler;\n            private projectsUpdatedInBackgroundEvent;\n            logError(err: Error, cmd: string): void;\n            private logErrorWorker;\n            send(msg: protocol.Message): void;\n            protected writeMessage(msg: protocol.Message): void;\n            event<T extends object>(body: T, eventName: string): void;\n            private semanticCheck;\n            private syntacticCheck;\n            private suggestionCheck;\n            private regionSemanticCheck;\n            private sendDiagnosticsEvent;\n            private updateErrorCheck;\n            private cleanProjects;\n            private cleanup;\n            private getEncodedSyntacticClassifications;\n            private getEncodedSemanticClassifications;\n            private getProject;\n            private getConfigFileAndProject;\n            private getConfigFileDiagnostics;\n            private convertToDiagnosticsWithLinePositionFromDiagnosticFile;\n            private getCompilerOptionsDiagnostics;\n            private convertToDiagnosticsWithLinePosition;\n            private getDiagnosticsWorker;\n            private getDefinition;\n            private mapDefinitionInfoLocations;\n            private getDefinitionAndBoundSpan;\n            private findSourceDefinition;\n            private getEmitOutput;\n            private mapJSDocTagInfo;\n            private mapDisplayParts;\n            private mapSignatureHelpItems;\n            private mapDefinitionInfo;\n            private static mapToOriginalLocation;\n            private toFileSpan;\n            private toFileSpanWithContext;\n            private getTypeDefinition;\n            private mapImplementationLocations;\n            private getImplementation;\n            private getSyntacticDiagnosticsSync;\n            private getSemanticDiagnosticsSync;\n            private getSuggestionDiagnosticsSync;\n            private getJsxClosingTag;\n            private getLinkedEditingRange;\n            private getDocumentHighlights;\n            private provideInlayHints;\n            private mapCode;\n            private getCopilotRelatedInfo;\n            private setCompilerOptionsForInferredProjects;\n            private getProjectInfo;\n            private getProjectInfoWorker;\n            private getDefaultConfiguredProjectInfo;\n            private getRenameInfo;\n            private getProjects;\n            private getDefaultProject;\n            private getRenameLocations;\n            private mapRenameInfo;\n            private toSpanGroups;\n            private getReferences;\n            private getFileReferences;\n            private openClientFile;\n            private getPosition;\n            private getPositionInFile;\n            private getFileAndProject;\n            private getFileAndLanguageServiceForSyntacticOperation;\n            private getFileAndProjectWorker;\n            private getOutliningSpans;\n            private getTodoComments;\n            private getDocCommentTemplate;\n            private getSpanOfEnclosingComment;\n            private getIndentation;\n            private getBreakpointStatement;\n            private getNameOrDottedNameSpan;\n            private isValidBraceCompletion;\n            private getQuickInfoWorker;\n            private getFormattingEditsForRange;\n            private getFormattingEditsForRangeFull;\n            private getFormattingEditsForDocumentFull;\n            private getFormattingEditsAfterKeystrokeFull;\n            private getFormattingEditsAfterKeystroke;\n            private getCompletions;\n            private getCompletionEntryDetails;\n            private getCompileOnSaveAffectedFileList;\n            private emitFile;\n            private getSignatureHelpItems;\n            private toPendingErrorCheck;\n            private getDiagnostics;\n            private change;\n            private reload;\n            private saveToTmp;\n            private closeClientFile;\n            private mapLocationNavigationBarItems;\n            private getNavigationBarItems;\n            private toLocationNavigationTree;\n            private getNavigationTree;\n            private getNavigateToItems;\n            private getFullNavigateToItems;\n            private getSupportedCodeFixes;\n            private isLocation;\n            private extractPositionOrRange;\n            private getRange;\n            private getApplicableRefactors;\n            private getEditsForRefactor;\n            private getMoveToRefactoringFileSuggestions;\n            private preparePasteEdits;\n            private getPasteEdits;\n            private organizeImports;\n            private getEditsForFileRename;\n            private getCodeFixes;\n            private getCombinedCodeFix;\n            private applyCodeActionCommand;\n            private getStartAndEndPosition;\n            private mapCodeAction;\n            private mapCodeFixAction;\n            private mapPasteEditsAction;\n            private mapTextChangesToCodeEdits;\n            private mapTextChangeToCodeEdit;\n            private convertTextChangeToCodeEdit;\n            private getBraceMatching;\n            private getDiagnosticsForProject;\n            private configurePlugin;\n            private getSmartSelectionRange;\n            private toggleLineComment;\n            private toggleMultilineComment;\n            private commentSelection;\n            private uncommentSelection;\n            private mapSelectionRange;\n            private getScriptInfoFromProjectService;\n            private toProtocolCallHierarchyItem;\n            private toProtocolCallHierarchyIncomingCall;\n            private toProtocolCallHierarchyOutgoingCall;\n            private prepareCallHierarchy;\n            private provideCallHierarchyIncomingCalls;\n            private provideCallHierarchyOutgoingCalls;\n            getCanonicalFileName(fileName: string): string;\n            exit(): void;\n            private notRequired;\n            private requiredResponse;\n            private handlers;\n            addProtocolHandler(command: string, handler: (request: protocol.Request) => HandlerResponse): void;\n            private setCurrentRequest;\n            private resetCurrentRequest;\n            executeWithRequestId<T>(requestId: number, f: () => T): T;\n            executeCommand(request: protocol.Request): HandlerResponse;\n            onMessage(message: TMessage): void;\n            protected parseMessage(message: TMessage): protocol.Request;\n            protected toStringMessage(message: TMessage): string;\n            private getFormatOptions;\n            private getPreferences;\n            private getHostFormatOptions;\n            private getHostPreferences;\n        }\n        interface HandlerResponse {\n            response?: {};\n            responseRequired?: boolean;\n        }\n    }\n    namespace JsTyping {\n        interface TypingResolutionHost {\n            directoryExists(path: string): boolean;\n            fileExists(fileName: string): boolean;\n            readFile(path: string, encoding?: string): string | undefined;\n            readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[] | undefined, depth?: number): string[];\n        }\n    }\n    const versionMajorMinor = \"5.8\";\n    /** The version of the TypeScript compiler release */\n    const version: string;\n    /**\n     * Type of objects whose values are all of the same type.\n     * The `in` and `for-in` operators can *not* be safely used,\n     * since `Object.prototype` may be modified by outside code.\n     */\n    interface MapLike<T> {\n        [index: string]: T;\n    }\n    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {\n        \" __sortedArrayBrand\": any;\n    }\n    interface SortedArray<T> extends Array<T> {\n        \" __sortedArrayBrand\": any;\n    }\n    type Path = string & {\n        __pathBrand: any;\n    };\n    interface TextRange {\n        pos: number;\n        end: number;\n    }\n    interface ReadonlyTextRange {\n        readonly pos: number;\n        readonly end: number;\n    }\n    enum SyntaxKind {\n        Unknown = 0,\n        EndOfFileToken = 1,\n        SingleLineCommentTrivia = 2,\n        MultiLineCommentTrivia = 3,\n        NewLineTrivia = 4,\n        WhitespaceTrivia = 5,\n        ShebangTrivia = 6,\n        ConflictMarkerTrivia = 7,\n        NonTextFileMarkerTrivia = 8,\n        NumericLiteral = 9,\n        BigIntLiteral = 10,\n        StringLiteral = 11,\n        JsxText = 12,\n        JsxTextAllWhiteSpaces = 13,\n        RegularExpressionLiteral = 14,\n        NoSubstitutionTemplateLiteral = 15,\n        TemplateHead = 16,\n        TemplateMiddle = 17,\n        TemplateTail = 18,\n        OpenBraceToken = 19,\n        CloseBraceToken = 20,\n        OpenParenToken = 21,\n        CloseParenToken = 22,\n        OpenBracketToken = 23,\n        CloseBracketToken = 24,\n        DotToken = 25,\n        DotDotDotToken = 26,\n        SemicolonToken = 27,\n        CommaToken = 28,\n        QuestionDotToken = 29,\n        LessThanToken = 30,\n        LessThanSlashToken = 31,\n        GreaterThanToken = 32,\n        LessThanEqualsToken = 33,\n        GreaterThanEqualsToken = 34,\n        EqualsEqualsToken = 35,\n        ExclamationEqualsToken = 36,\n        EqualsEqualsEqualsToken = 37,\n        ExclamationEqualsEqualsToken = 38,\n        EqualsGreaterThanToken = 39,\n        PlusToken = 40,\n        MinusToken = 41,\n        AsteriskToken = 42,\n        AsteriskAsteriskToken = 43,\n        SlashToken = 44,\n        PercentToken = 45,\n        PlusPlusToken = 46,\n        MinusMinusToken = 47,\n        LessThanLessThanToken = 48,\n        GreaterThanGreaterThanToken = 49,\n        GreaterThanGreaterThanGreaterThanToken = 50,\n        AmpersandToken = 51,\n        BarToken = 52,\n        CaretToken = 53,\n        ExclamationToken = 54,\n        TildeToken = 55,\n        AmpersandAmpersandToken = 56,\n        BarBarToken = 57,\n        QuestionToken = 58,\n        ColonToken = 59,\n        AtToken = 60,\n        QuestionQuestionToken = 61,\n        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */\n        BacktickToken = 62,\n        /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */\n        HashToken = 63,\n        EqualsToken = 64,\n        PlusEqualsToken = 65,\n        MinusEqualsToken = 66,\n        AsteriskEqualsToken = 67,\n        AsteriskAsteriskEqualsToken = 68,\n        SlashEqualsToken = 69,\n        PercentEqualsToken = 70,\n        LessThanLessThanEqualsToken = 71,\n        GreaterThanGreaterThanEqualsToken = 72,\n        GreaterThanGreaterThanGreaterThanEqualsToken = 73,\n        AmpersandEqualsToken = 74,\n        BarEqualsToken = 75,\n        BarBarEqualsToken = 76,\n        AmpersandAmpersandEqualsToken = 77,\n        QuestionQuestionEqualsToken = 78,\n        CaretEqualsToken = 79,\n        Identifier = 80,\n        PrivateIdentifier = 81,\n        BreakKeyword = 83,\n        CaseKeyword = 84,\n        CatchKeyword = 85,\n        ClassKeyword = 86,\n        ConstKeyword = 87,\n        ContinueKeyword = 88,\n        DebuggerKeyword = 89,\n        DefaultKeyword = 90,\n        DeleteKeyword = 91,\n        DoKeyword = 92,\n        ElseKeyword = 93,\n        EnumKeyword = 94,\n        ExportKeyword = 95,\n        ExtendsKeyword = 96,\n        FalseKeyword = 97,\n        FinallyKeyword = 98,\n        ForKeyword = 99,\n        FunctionKeyword = 100,\n        IfKeyword = 101,\n        ImportKeyword = 102,\n        InKeyword = 103,\n        InstanceOfKeyword = 104,\n        NewKeyword = 105,\n        NullKeyword = 106,\n        ReturnKeyword = 107,\n        SuperKeyword = 108,\n        SwitchKeyword = 109,\n        ThisKeyword = 110,\n        ThrowKeyword = 111,\n        TrueKeyword = 112,\n        TryKeyword = 113,\n        TypeOfKeyword = 114,\n        VarKeyword = 115,\n        VoidKeyword = 116,\n        WhileKeyword = 117,\n        WithKeyword = 118,\n        ImplementsKeyword = 119,\n        InterfaceKeyword = 120,\n        LetKeyword = 121,\n        PackageKeyword = 122,\n        PrivateKeyword = 123,\n        ProtectedKeyword = 124,\n        PublicKeyword = 125,\n        StaticKeyword = 126,\n        YieldKeyword = 127,\n        AbstractKeyword = 128,\n        AccessorKeyword = 129,\n        AsKeyword = 130,\n        AssertsKeyword = 131,\n        AssertKeyword = 132,\n        AnyKeyword = 133,\n        AsyncKeyword = 134,\n        AwaitKeyword = 135,\n        BooleanKeyword = 136,\n        ConstructorKeyword = 137,\n        DeclareKeyword = 138,\n        GetKeyword = 139,\n        InferKeyword = 140,\n        IntrinsicKeyword = 141,\n        IsKeyword = 142,\n        KeyOfKeyword = 143,\n        ModuleKeyword = 144,\n        NamespaceKeyword = 145,\n        NeverKeyword = 146,\n        OutKeyword = 147,\n        ReadonlyKeyword = 148,\n        RequireKeyword = 149,\n        NumberKeyword = 150,\n        ObjectKeyword = 151,\n        SatisfiesKeyword = 152,\n        SetKeyword = 153,\n        StringKeyword = 154,\n        SymbolKeyword = 155,\n        TypeKeyword = 156,\n        UndefinedKeyword = 157,\n        UniqueKeyword = 158,\n        UnknownKeyword = 159,\n        UsingKeyword = 160,\n        FromKeyword = 161,\n        GlobalKeyword = 162,\n        BigIntKeyword = 163,\n        OverrideKeyword = 164,\n        OfKeyword = 165,\n        QualifiedName = 166,\n        ComputedPropertyName = 167,\n        TypeParameter = 168,\n        Parameter = 169,\n        Decorator = 170,\n        PropertySignature = 171,\n        PropertyDeclaration = 172,\n        MethodSignature = 173,\n        MethodDeclaration = 174,\n        ClassStaticBlockDeclaration = 175,\n        Constructor = 176,\n        GetAccessor = 177,\n        SetAccessor = 178,\n        CallSignature = 179,\n        ConstructSignature = 180,\n        IndexSignature = 181,\n        TypePredicate = 182,\n        TypeReference = 183,\n        FunctionType = 184,\n        ConstructorType = 185,\n        TypeQuery = 186,\n        TypeLiteral = 187,\n        ArrayType = 188,\n        TupleType = 189,\n        OptionalType = 190,\n        RestType = 191,\n        UnionType = 192,\n        IntersectionType = 193,\n        ConditionalType = 194,\n        InferType = 195,\n        ParenthesizedType = 196,\n        ThisType = 197,\n        TypeOperator = 198,\n        IndexedAccessType = 199,\n        MappedType = 200,\n        LiteralType = 201,\n        NamedTupleMember = 202,\n        TemplateLiteralType = 203,\n        TemplateLiteralTypeSpan = 204,\n        ImportType = 205,\n        ObjectBindingPattern = 206,\n        ArrayBindingPattern = 207,\n        BindingElement = 208,\n        ArrayLiteralExpression = 209,\n        ObjectLiteralExpression = 210,\n        PropertyAccessExpression = 211,\n        ElementAccessExpression = 212,\n        CallExpression = 213,\n        NewExpression = 214,\n        TaggedTemplateExpression = 215,\n        TypeAssertionExpression = 216,\n        ParenthesizedExpression = 217,\n        FunctionExpression = 218,\n        ArrowFunction = 219,\n        DeleteExpression = 220,\n        TypeOfExpression = 221,\n        VoidExpression = 222,\n        AwaitExpression = 223,\n        PrefixUnaryExpression = 224,\n        PostfixUnaryExpression = 225,\n        BinaryExpression = 226,\n        ConditionalExpression = 227,\n        TemplateExpression = 228,\n        YieldExpression = 229,\n        SpreadElement = 230,\n        ClassExpression = 231,\n        OmittedExpression = 232,\n        ExpressionWithTypeArguments = 233,\n        AsExpression = 234,\n        NonNullExpression = 235,\n        MetaProperty = 236,\n        SyntheticExpression = 237,\n        SatisfiesExpression = 238,\n        TemplateSpan = 239,\n        SemicolonClassElement = 240,\n        Block = 241,\n        EmptyStatement = 242,\n        VariableStatement = 243,\n        ExpressionStatement = 244,\n        IfStatement = 245,\n        DoStatement = 246,\n        WhileStatement = 247,\n        ForStatement = 248,\n        ForInStatement = 249,\n        ForOfStatement = 250,\n        ContinueStatement = 251,\n        BreakStatement = 252,\n        ReturnStatement = 253,\n        WithStatement = 254,\n        SwitchStatement = 255,\n        LabeledStatement = 256,\n        ThrowStatement = 257,\n        TryStatement = 258,\n        DebuggerStatement = 259,\n        VariableDeclaration = 260,\n        VariableDeclarationList = 261,\n        FunctionDeclaration = 262,\n        ClassDeclaration = 263,\n        InterfaceDeclaration = 264,\n        TypeAliasDeclaration = 265,\n        EnumDeclaration = 266,\n        ModuleDeclaration = 267,\n        ModuleBlock = 268,\n        CaseBlock = 269,\n        NamespaceExportDeclaration = 270,\n        ImportEqualsDeclaration = 271,\n        ImportDeclaration = 272,\n        ImportClause = 273,\n        NamespaceImport = 274,\n        NamedImports = 275,\n        ImportSpecifier = 276,\n        ExportAssignment = 277,\n        ExportDeclaration = 278,\n        NamedExports = 279,\n        NamespaceExport = 280,\n        ExportSpecifier = 281,\n        MissingDeclaration = 282,\n        ExternalModuleReference = 283,\n        JsxElement = 284,\n        JsxSelfClosingElement = 285,\n        JsxOpeningElement = 286,\n        JsxClosingElement = 287,\n        JsxFragment = 288,\n        JsxOpeningFragment = 289,\n        JsxClosingFragment = 290,\n        JsxAttribute = 291,\n        JsxAttributes = 292,\n        JsxSpreadAttribute = 293,\n        JsxExpression = 294,\n        JsxNamespacedName = 295,\n        CaseClause = 296,\n        DefaultClause = 297,\n        HeritageClause = 298,\n        CatchClause = 299,\n        ImportAttributes = 300,\n        ImportAttribute = 301,\n        /** @deprecated */ AssertClause = 300,\n        /** @deprecated */ AssertEntry = 301,\n        /** @deprecated */ ImportTypeAssertionContainer = 302,\n        PropertyAssignment = 303,\n        ShorthandPropertyAssignment = 304,\n        SpreadAssignment = 305,\n        EnumMember = 306,\n        SourceFile = 307,\n        Bundle = 308,\n        JSDocTypeExpression = 309,\n        JSDocNameReference = 310,\n        JSDocMemberName = 311,\n        JSDocAllType = 312,\n        JSDocUnknownType = 313,\n        JSDocNullableType = 314,\n        JSDocNonNullableType = 315,\n        JSDocOptionalType = 316,\n        JSDocFunctionType = 317,\n        JSDocVariadicType = 318,\n        JSDocNamepathType = 319,\n        JSDoc = 320,\n        /** @deprecated Use SyntaxKind.JSDoc */\n        JSDocComment = 320,\n        JSDocText = 321,\n        JSDocTypeLiteral = 322,\n        JSDocSignature = 323,\n        JSDocLink = 324,\n        JSDocLinkCode = 325,\n        JSDocLinkPlain = 326,\n        JSDocTag = 327,\n        JSDocAugmentsTag = 328,\n        JSDocImplementsTag = 329,\n        JSDocAuthorTag = 330,\n        JSDocDeprecatedTag = 331,\n        JSDocClassTag = 332,\n        JSDocPublicTag = 333,\n        JSDocPrivateTag = 334,\n        JSDocProtectedTag = 335,\n        JSDocReadonlyTag = 336,\n        JSDocOverrideTag = 337,\n        JSDocCallbackTag = 338,\n        JSDocOverloadTag = 339,\n        JSDocEnumTag = 340,\n        JSDocParameterTag = 341,\n        JSDocReturnTag = 342,\n        JSDocThisTag = 343,\n        JSDocTypeTag = 344,\n        JSDocTemplateTag = 345,\n        JSDocTypedefTag = 346,\n        JSDocSeeTag = 347,\n        JSDocPropertyTag = 348,\n        JSDocThrowsTag = 349,\n        JSDocSatisfiesTag = 350,\n        JSDocImportTag = 351,\n        SyntaxList = 352,\n        NotEmittedStatement = 353,\n        NotEmittedTypeElement = 354,\n        PartiallyEmittedExpression = 355,\n        CommaListExpression = 356,\n        SyntheticReferenceExpression = 357,\n        Count = 358,\n        FirstAssignment = 64,\n        LastAssignment = 79,\n        FirstCompoundAssignment = 65,\n        LastCompoundAssignment = 79,\n        FirstReservedWord = 83,\n        LastReservedWord = 118,\n        FirstKeyword = 83,\n        LastKeyword = 165,\n        FirstFutureReservedWord = 119,\n        LastFutureReservedWord = 127,\n        FirstTypeNode = 182,\n        LastTypeNode = 205,\n        FirstPunctuation = 19,\n        LastPunctuation = 79,\n        FirstToken = 0,\n        LastToken = 165,\n        FirstTriviaToken = 2,\n        LastTriviaToken = 7,\n        FirstLiteralToken = 9,\n        LastLiteralToken = 15,\n        FirstTemplateToken = 15,\n        LastTemplateToken = 18,\n        FirstBinaryOperator = 30,\n        LastBinaryOperator = 79,\n        FirstStatement = 243,\n        LastStatement = 259,\n        FirstNode = 166,\n        FirstJSDocNode = 309,\n        LastJSDocNode = 351,\n        FirstJSDocTagNode = 327,\n        LastJSDocTagNode = 351,\n    }\n    type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;\n    type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;\n    type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;\n    type PunctuationSyntaxKind =\n        | SyntaxKind.OpenBraceToken\n        | SyntaxKind.CloseBraceToken\n        | SyntaxKind.OpenParenToken\n        | SyntaxKind.CloseParenToken\n        | SyntaxKind.OpenBracketToken\n        | SyntaxKind.CloseBracketToken\n        | SyntaxKind.DotToken\n        | SyntaxKind.DotDotDotToken\n        | SyntaxKind.SemicolonToken\n        | SyntaxKind.CommaToken\n        | SyntaxKind.QuestionDotToken\n        | SyntaxKind.LessThanToken\n        | SyntaxKind.LessThanSlashToken\n        | SyntaxKind.GreaterThanToken\n        | SyntaxKind.LessThanEqualsToken\n        | SyntaxKind.GreaterThanEqualsToken\n        | SyntaxKind.EqualsEqualsToken\n        | SyntaxKind.ExclamationEqualsToken\n        | SyntaxKind.EqualsEqualsEqualsToken\n        | SyntaxKind.ExclamationEqualsEqualsToken\n        | SyntaxKind.EqualsGreaterThanToken\n        | SyntaxKind.PlusToken\n        | SyntaxKind.MinusToken\n        | SyntaxKind.AsteriskToken\n        | SyntaxKind.AsteriskAsteriskToken\n        | SyntaxKind.SlashToken\n        | SyntaxKind.PercentToken\n        | SyntaxKind.PlusPlusToken\n        | SyntaxKind.MinusMinusToken\n        | SyntaxKind.LessThanLessThanToken\n        | SyntaxKind.GreaterThanGreaterThanToken\n        | SyntaxKind.GreaterThanGreaterThanGreaterThanToken\n        | SyntaxKind.AmpersandToken\n        | SyntaxKind.BarToken\n        | SyntaxKind.CaretToken\n        | SyntaxKind.ExclamationToken\n        | SyntaxKind.TildeToken\n        | SyntaxKind.AmpersandAmpersandToken\n        | SyntaxKind.AmpersandAmpersandEqualsToken\n        | SyntaxKind.BarBarToken\n        | SyntaxKind.BarBarEqualsToken\n        | SyntaxKind.QuestionQuestionToken\n        | SyntaxKind.QuestionQuestionEqualsToken\n        | SyntaxKind.QuestionToken\n        | SyntaxKind.ColonToken\n        | SyntaxKind.AtToken\n        | SyntaxKind.BacktickToken\n        | SyntaxKind.HashToken\n        | SyntaxKind.EqualsToken\n        | SyntaxKind.PlusEqualsToken\n        | SyntaxKind.MinusEqualsToken\n        | SyntaxKind.AsteriskEqualsToken\n        | SyntaxKind.AsteriskAsteriskEqualsToken\n        | SyntaxKind.SlashEqualsToken\n        | SyntaxKind.PercentEqualsToken\n        | SyntaxKind.LessThanLessThanEqualsToken\n        | SyntaxKind.GreaterThanGreaterThanEqualsToken\n        | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken\n        | SyntaxKind.AmpersandEqualsToken\n        | SyntaxKind.BarEqualsToken\n        | SyntaxKind.CaretEqualsToken;\n    type KeywordSyntaxKind =\n        | SyntaxKind.AbstractKeyword\n        | SyntaxKind.AccessorKeyword\n        | SyntaxKind.AnyKeyword\n        | SyntaxKind.AsKeyword\n        | SyntaxKind.AssertsKeyword\n        | SyntaxKind.AssertKeyword\n        | SyntaxKind.AsyncKeyword\n        | SyntaxKind.AwaitKeyword\n        | SyntaxKind.BigIntKeyword\n        | SyntaxKind.BooleanKeyword\n        | SyntaxKind.BreakKeyword\n        | SyntaxKind.CaseKeyword\n        | SyntaxKind.CatchKeyword\n        | SyntaxKind.ClassKeyword\n        | SyntaxKind.ConstKeyword\n        | SyntaxKind.ConstructorKeyword\n        | SyntaxKind.ContinueKeyword\n        | SyntaxKind.DebuggerKeyword\n        | SyntaxKind.DeclareKeyword\n        | SyntaxKind.DefaultKeyword\n        | SyntaxKind.DeleteKeyword\n        | SyntaxKind.DoKeyword\n        | SyntaxKind.ElseKeyword\n        | SyntaxKind.EnumKeyword\n        | SyntaxKind.ExportKeyword\n        | SyntaxKind.ExtendsKeyword\n        | SyntaxKind.FalseKeyword\n        | SyntaxKind.FinallyKeyword\n        | SyntaxKind.ForKeyword\n        | SyntaxKind.FromKeyword\n        | SyntaxKind.FunctionKeyword\n        | SyntaxKind.GetKeyword\n        | SyntaxKind.GlobalKeyword\n        | SyntaxKind.IfKeyword\n        | SyntaxKind.ImplementsKeyword\n        | SyntaxKind.ImportKeyword\n        | SyntaxKind.InferKeyword\n        | SyntaxKind.InKeyword\n        | SyntaxKind.InstanceOfKeyword\n        | SyntaxKind.InterfaceKeyword\n        | SyntaxKind.IntrinsicKeyword\n        | SyntaxKind.IsKeyword\n        | SyntaxKind.KeyOfKeyword\n        | SyntaxKind.LetKeyword\n        | SyntaxKind.ModuleKeyword\n        | SyntaxKind.NamespaceKeyword\n        | SyntaxKind.NeverKeyword\n        | SyntaxKind.NewKeyword\n        | SyntaxKind.NullKeyword\n        | SyntaxKind.NumberKeyword\n        | SyntaxKind.ObjectKeyword\n        | SyntaxKind.OfKeyword\n        | SyntaxKind.PackageKeyword\n        | SyntaxKind.PrivateKeyword\n        | SyntaxKind.ProtectedKeyword\n        | SyntaxKind.PublicKeyword\n        | SyntaxKind.ReadonlyKeyword\n        | SyntaxKind.OutKeyword\n        | SyntaxKind.OverrideKeyword\n        | SyntaxKind.RequireKeyword\n        | SyntaxKind.ReturnKeyword\n        | SyntaxKind.SatisfiesKeyword\n        | SyntaxKind.SetKeyword\n        | SyntaxKind.StaticKeyword\n        | SyntaxKind.StringKeyword\n        | SyntaxKind.SuperKeyword\n        | SyntaxKind.SwitchKeyword\n        | SyntaxKind.SymbolKeyword\n        | SyntaxKind.ThisKeyword\n        | SyntaxKind.ThrowKeyword\n        | SyntaxKind.TrueKeyword\n        | SyntaxKind.TryKeyword\n        | SyntaxKind.TypeKeyword\n        | SyntaxKind.TypeOfKeyword\n        | SyntaxKind.UndefinedKeyword\n        | SyntaxKind.UniqueKeyword\n        | SyntaxKind.UnknownKeyword\n        | SyntaxKind.UsingKeyword\n        | SyntaxKind.VarKeyword\n        | SyntaxKind.VoidKeyword\n        | SyntaxKind.WhileKeyword\n        | SyntaxKind.WithKeyword\n        | SyntaxKind.YieldKeyword;\n    type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.InKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;\n    type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;\n    type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;\n    type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;\n    type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;\n    enum NodeFlags {\n        None = 0,\n        Let = 1,\n        Const = 2,\n        Using = 4,\n        AwaitUsing = 6,\n        NestedNamespace = 8,\n        Synthesized = 16,\n        Namespace = 32,\n        OptionalChain = 64,\n        ExportContext = 128,\n        ContainsThis = 256,\n        HasImplicitReturn = 512,\n        HasExplicitReturn = 1024,\n        GlobalAugmentation = 2048,\n        HasAsyncFunctions = 4096,\n        DisallowInContext = 8192,\n        YieldContext = 16384,\n        DecoratorContext = 32768,\n        AwaitContext = 65536,\n        DisallowConditionalTypesContext = 131072,\n        ThisNodeHasError = 262144,\n        JavaScriptFile = 524288,\n        ThisNodeOrAnySubNodesHasError = 1048576,\n        HasAggregatedChildData = 2097152,\n        JSDoc = 16777216,\n        JsonFile = 134217728,\n        BlockScoped = 7,\n        Constant = 6,\n        ReachabilityCheckFlags = 1536,\n        ReachabilityAndEmitFlags = 5632,\n        ContextFlags = 101441536,\n        TypeExcludesFlags = 81920,\n    }\n    enum ModifierFlags {\n        None = 0,\n        Public = 1,\n        Private = 2,\n        Protected = 4,\n        Readonly = 8,\n        Override = 16,\n        Export = 32,\n        Abstract = 64,\n        Ambient = 128,\n        Static = 256,\n        Accessor = 512,\n        Async = 1024,\n        Default = 2048,\n        Const = 4096,\n        In = 8192,\n        Out = 16384,\n        Decorator = 32768,\n        Deprecated = 65536,\n        HasComputedJSDocModifiers = 268435456,\n        HasComputedFlags = 536870912,\n        AccessibilityModifier = 7,\n        ParameterPropertyModifier = 31,\n        NonPublicAccessibilityModifier = 6,\n        TypeScriptModifier = 28895,\n        ExportDefault = 2080,\n        All = 131071,\n        Modifier = 98303,\n    }\n    enum JsxFlags {\n        None = 0,\n        /** An element from a named property of the JSX.IntrinsicElements interface */\n        IntrinsicNamedElement = 1,\n        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */\n        IntrinsicIndexedElement = 2,\n        IntrinsicElement = 3,\n    }\n    interface Node extends ReadonlyTextRange {\n        readonly kind: SyntaxKind;\n        readonly flags: NodeFlags;\n        readonly parent: Node;\n    }\n    interface Node {\n        getSourceFile(): SourceFile;\n        getChildCount(sourceFile?: SourceFile): number;\n        getChildAt(index: number, sourceFile?: SourceFile): Node;\n        getChildren(sourceFile?: SourceFile): readonly Node[];\n        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;\n        getFullStart(): number;\n        getEnd(): number;\n        getWidth(sourceFile?: SourceFileLike): number;\n        getFullWidth(): number;\n        getLeadingTriviaWidth(sourceFile?: SourceFile): number;\n        getFullText(sourceFile?: SourceFile): string;\n        getText(sourceFile?: SourceFile): string;\n        getFirstToken(sourceFile?: SourceFile): Node | undefined;\n        getLastToken(sourceFile?: SourceFile): Node | undefined;\n        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;\n    }\n    interface JSDocContainer extends Node {\n        _jsdocContainerBrand: any;\n    }\n    interface LocalsContainer extends Node {\n        _localsContainerBrand: any;\n    }\n    interface FlowContainer extends Node {\n        _flowContainerBrand: any;\n    }\n    type HasJSDoc =\n        | AccessorDeclaration\n        | ArrowFunction\n        | BinaryExpression\n        | Block\n        | BreakStatement\n        | CallSignatureDeclaration\n        | CaseClause\n        | ClassLikeDeclaration\n        | ClassStaticBlockDeclaration\n        | ConstructorDeclaration\n        | ConstructorTypeNode\n        | ConstructSignatureDeclaration\n        | ContinueStatement\n        | DebuggerStatement\n        | DoStatement\n        | ElementAccessExpression\n        | EmptyStatement\n        | EndOfFileToken\n        | EnumDeclaration\n        | EnumMember\n        | ExportAssignment\n        | ExportDeclaration\n        | ExportSpecifier\n        | ExpressionStatement\n        | ForInStatement\n        | ForOfStatement\n        | ForStatement\n        | FunctionDeclaration\n        | FunctionExpression\n        | FunctionTypeNode\n        | Identifier\n        | IfStatement\n        | ImportDeclaration\n        | ImportEqualsDeclaration\n        | IndexSignatureDeclaration\n        | InterfaceDeclaration\n        | JSDocFunctionType\n        | JSDocSignature\n        | LabeledStatement\n        | MethodDeclaration\n        | MethodSignature\n        | ModuleDeclaration\n        | NamedTupleMember\n        | NamespaceExportDeclaration\n        | ObjectLiteralExpression\n        | ParameterDeclaration\n        | ParenthesizedExpression\n        | PropertyAccessExpression\n        | PropertyAssignment\n        | PropertyDeclaration\n        | PropertySignature\n        | ReturnStatement\n        | SemicolonClassElement\n        | ShorthandPropertyAssignment\n        | SpreadAssignment\n        | SwitchStatement\n        | ThrowStatement\n        | TryStatement\n        | TypeAliasDeclaration\n        | TypeParameterDeclaration\n        | VariableDeclaration\n        | VariableStatement\n        | WhileStatement\n        | WithStatement;\n    type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;\n    type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;\n    type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;\n    type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | EnumMember;\n    type HasDecorators = ParameterDeclaration | PropertyDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassExpression | ClassDeclaration;\n    type HasModifiers = TypeParameterDeclaration | ParameterDeclaration | ConstructorTypeNode | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | IndexSignatureDeclaration | FunctionExpression | ArrowFunction | ClassExpression | VariableStatement | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | ExportAssignment | ExportDeclaration;\n    interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {\n        readonly hasTrailingComma: boolean;\n    }\n    interface Token<TKind extends SyntaxKind> extends Node {\n        readonly kind: TKind;\n    }\n    type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;\n    interface PunctuationToken<TKind extends PunctuationSyntaxKind> extends Token<TKind> {\n    }\n    type DotToken = PunctuationToken<SyntaxKind.DotToken>;\n    type DotDotDotToken = PunctuationToken<SyntaxKind.DotDotDotToken>;\n    type QuestionToken = PunctuationToken<SyntaxKind.QuestionToken>;\n    type ExclamationToken = PunctuationToken<SyntaxKind.ExclamationToken>;\n    type ColonToken = PunctuationToken<SyntaxKind.ColonToken>;\n    type EqualsToken = PunctuationToken<SyntaxKind.EqualsToken>;\n    type AmpersandAmpersandEqualsToken = PunctuationToken<SyntaxKind.AmpersandAmpersandEqualsToken>;\n    type BarBarEqualsToken = PunctuationToken<SyntaxKind.BarBarEqualsToken>;\n    type QuestionQuestionEqualsToken = PunctuationToken<SyntaxKind.QuestionQuestionEqualsToken>;\n    type AsteriskToken = PunctuationToken<SyntaxKind.AsteriskToken>;\n    type EqualsGreaterThanToken = PunctuationToken<SyntaxKind.EqualsGreaterThanToken>;\n    type PlusToken = PunctuationToken<SyntaxKind.PlusToken>;\n    type MinusToken = PunctuationToken<SyntaxKind.MinusToken>;\n    type QuestionDotToken = PunctuationToken<SyntaxKind.QuestionDotToken>;\n    interface KeywordToken<TKind extends KeywordSyntaxKind> extends Token<TKind> {\n    }\n    type AssertsKeyword = KeywordToken<SyntaxKind.AssertsKeyword>;\n    type AssertKeyword = KeywordToken<SyntaxKind.AssertKeyword>;\n    type AwaitKeyword = KeywordToken<SyntaxKind.AwaitKeyword>;\n    type CaseKeyword = KeywordToken<SyntaxKind.CaseKeyword>;\n    interface ModifierToken<TKind extends ModifierSyntaxKind> extends KeywordToken<TKind> {\n    }\n    type AbstractKeyword = ModifierToken<SyntaxKind.AbstractKeyword>;\n    type AccessorKeyword = ModifierToken<SyntaxKind.AccessorKeyword>;\n    type AsyncKeyword = ModifierToken<SyntaxKind.AsyncKeyword>;\n    type ConstKeyword = ModifierToken<SyntaxKind.ConstKeyword>;\n    type DeclareKeyword = ModifierToken<SyntaxKind.DeclareKeyword>;\n    type DefaultKeyword = ModifierToken<SyntaxKind.DefaultKeyword>;\n    type ExportKeyword = ModifierToken<SyntaxKind.ExportKeyword>;\n    type InKeyword = ModifierToken<SyntaxKind.InKeyword>;\n    type PrivateKeyword = ModifierToken<SyntaxKind.PrivateKeyword>;\n    type ProtectedKeyword = ModifierToken<SyntaxKind.ProtectedKeyword>;\n    type PublicKeyword = ModifierToken<SyntaxKind.PublicKeyword>;\n    type ReadonlyKeyword = ModifierToken<SyntaxKind.ReadonlyKeyword>;\n    type OutKeyword = ModifierToken<SyntaxKind.OutKeyword>;\n    type OverrideKeyword = ModifierToken<SyntaxKind.OverrideKeyword>;\n    type StaticKeyword = ModifierToken<SyntaxKind.StaticKeyword>;\n    type Modifier = AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;\n    type ModifierLike = Modifier | Decorator;\n    type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;\n    type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;\n    type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword | AccessorKeyword;\n    type ModifiersArray = NodeArray<Modifier>;\n    enum GeneratedIdentifierFlags {\n        None = 0,\n        ReservedInNestedScopes = 8,\n        Optimistic = 16,\n        FileLevel = 32,\n        AllowNameSubstitution = 64,\n    }\n    interface Identifier extends PrimaryExpression, Declaration, JSDocContainer, FlowContainer {\n        readonly kind: SyntaxKind.Identifier;\n        /**\n         * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)\n         * Text of identifier, but if the identifier begins with two underscores, this will begin with three.\n         */\n        readonly escapedText: __String;\n    }\n    interface Identifier {\n        readonly text: string;\n    }\n    interface TransientIdentifier extends Identifier {\n        resolvedSymbol: Symbol;\n    }\n    interface QualifiedName extends Node, FlowContainer {\n        readonly kind: SyntaxKind.QualifiedName;\n        readonly left: EntityName;\n        readonly right: Identifier;\n    }\n    type EntityName = Identifier | QualifiedName;\n    type PropertyName = Identifier | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier | BigIntLiteral;\n    type MemberName = Identifier | PrivateIdentifier;\n    type DeclarationName = PropertyName | JsxAttributeName | StringLiteralLike | ElementAccessExpression | BindingPattern | EntityNameExpression;\n    interface Declaration extends Node {\n        _declarationBrand: any;\n    }\n    interface NamedDeclaration extends Declaration {\n        readonly name?: DeclarationName;\n    }\n    interface DeclarationStatement extends NamedDeclaration, Statement {\n        readonly name?: Identifier | StringLiteral | NumericLiteral;\n    }\n    interface ComputedPropertyName extends Node {\n        readonly kind: SyntaxKind.ComputedPropertyName;\n        readonly parent: Declaration;\n        readonly expression: Expression;\n    }\n    interface PrivateIdentifier extends PrimaryExpression {\n        readonly kind: SyntaxKind.PrivateIdentifier;\n        readonly escapedText: __String;\n    }\n    interface PrivateIdentifier {\n        readonly text: string;\n    }\n    interface Decorator extends Node {\n        readonly kind: SyntaxKind.Decorator;\n        readonly parent: NamedDeclaration;\n        readonly expression: LeftHandSideExpression;\n    }\n    interface TypeParameterDeclaration extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.TypeParameter;\n        readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;\n        readonly modifiers?: NodeArray<Modifier>;\n        readonly name: Identifier;\n        /** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */\n        readonly constraint?: TypeNode;\n        readonly default?: TypeNode;\n        expression?: Expression;\n    }\n    interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {\n        readonly kind: SignatureDeclaration[\"kind\"];\n        readonly name?: PropertyName;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;\n        readonly parameters: NodeArray<ParameterDeclaration>;\n        readonly type?: TypeNode | undefined;\n    }\n    type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;\n    interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {\n        readonly kind: SyntaxKind.CallSignature;\n    }\n    interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement, LocalsContainer {\n        readonly kind: SyntaxKind.ConstructSignature;\n    }\n    type BindingName = Identifier | BindingPattern;\n    interface VariableDeclaration extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.VariableDeclaration;\n        readonly parent: VariableDeclarationList | CatchClause;\n        readonly name: BindingName;\n        readonly exclamationToken?: ExclamationToken;\n        readonly type?: TypeNode;\n        readonly initializer?: Expression;\n    }\n    interface VariableDeclarationList extends Node {\n        readonly kind: SyntaxKind.VariableDeclarationList;\n        readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;\n        readonly declarations: NodeArray<VariableDeclaration>;\n    }\n    interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.Parameter;\n        readonly parent: SignatureDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly dotDotDotToken?: DotDotDotToken;\n        readonly name: BindingName;\n        readonly questionToken?: QuestionToken;\n        readonly type?: TypeNode;\n        readonly initializer?: Expression;\n    }\n    interface BindingElement extends NamedDeclaration, FlowContainer {\n        readonly kind: SyntaxKind.BindingElement;\n        readonly parent: BindingPattern;\n        readonly propertyName?: PropertyName;\n        readonly dotDotDotToken?: DotDotDotToken;\n        readonly name: BindingName;\n        readonly initializer?: Expression;\n    }\n    interface PropertySignature extends TypeElement, JSDocContainer {\n        readonly kind: SyntaxKind.PropertySignature;\n        readonly parent: TypeLiteralNode | InterfaceDeclaration;\n        readonly modifiers?: NodeArray<Modifier>;\n        readonly name: PropertyName;\n        readonly questionToken?: QuestionToken;\n        readonly type?: TypeNode;\n    }\n    interface PropertyDeclaration extends ClassElement, JSDocContainer {\n        readonly kind: SyntaxKind.PropertyDeclaration;\n        readonly parent: ClassLikeDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: PropertyName;\n        readonly questionToken?: QuestionToken;\n        readonly exclamationToken?: ExclamationToken;\n        readonly type?: TypeNode;\n        readonly initializer?: Expression;\n    }\n    interface AutoAccessorPropertyDeclaration extends PropertyDeclaration {\n        _autoAccessorBrand: any;\n    }\n    interface ObjectLiteralElement extends NamedDeclaration {\n        _objectLiteralBrand: any;\n        readonly name?: PropertyName;\n    }\n    /** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */\n    type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;\n    interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.PropertyAssignment;\n        readonly parent: ObjectLiteralExpression;\n        readonly name: PropertyName;\n        readonly initializer: Expression;\n    }\n    interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.ShorthandPropertyAssignment;\n        readonly parent: ObjectLiteralExpression;\n        readonly name: Identifier;\n        readonly equalsToken?: EqualsToken;\n        readonly objectAssignmentInitializer?: Expression;\n    }\n    interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {\n        readonly kind: SyntaxKind.SpreadAssignment;\n        readonly parent: ObjectLiteralExpression;\n        readonly expression: Expression;\n    }\n    type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;\n    interface ObjectBindingPattern extends Node {\n        readonly kind: SyntaxKind.ObjectBindingPattern;\n        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;\n        readonly elements: NodeArray<BindingElement>;\n    }\n    interface ArrayBindingPattern extends Node {\n        readonly kind: SyntaxKind.ArrayBindingPattern;\n        readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;\n        readonly elements: NodeArray<ArrayBindingElement>;\n    }\n    type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;\n    type ArrayBindingElement = BindingElement | OmittedExpression;\n    /**\n     * Several node kinds share function-like features such as a signature,\n     * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.\n     * Examples:\n     * - FunctionDeclaration\n     * - MethodDeclaration\n     * - AccessorDeclaration\n     */\n    interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {\n        _functionLikeDeclarationBrand: any;\n        readonly asteriskToken?: AsteriskToken | undefined;\n        readonly questionToken?: QuestionToken | undefined;\n        readonly exclamationToken?: ExclamationToken | undefined;\n        readonly body?: Block | Expression | undefined;\n    }\n    type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;\n    /** @deprecated Use SignatureDeclaration */\n    type FunctionLike = SignatureDeclaration;\n    interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement, LocalsContainer {\n        readonly kind: SyntaxKind.FunctionDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name?: Identifier;\n        readonly body?: FunctionBody;\n    }\n    interface MethodSignature extends SignatureDeclarationBase, TypeElement, LocalsContainer {\n        readonly kind: SyntaxKind.MethodSignature;\n        readonly parent: TypeLiteralNode | InterfaceDeclaration;\n        readonly modifiers?: NodeArray<Modifier>;\n        readonly name: PropertyName;\n    }\n    interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.MethodDeclaration;\n        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;\n        readonly modifiers?: NodeArray<ModifierLike> | undefined;\n        readonly name: PropertyName;\n        readonly body?: FunctionBody | undefined;\n    }\n    interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer, LocalsContainer {\n        readonly kind: SyntaxKind.Constructor;\n        readonly parent: ClassLikeDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike> | undefined;\n        readonly body?: FunctionBody | undefined;\n    }\n    /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */\n    interface SemicolonClassElement extends ClassElement, JSDocContainer {\n        readonly kind: SyntaxKind.SemicolonClassElement;\n        readonly parent: ClassLikeDeclaration;\n    }\n    interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.GetAccessor;\n        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: PropertyName;\n        readonly body?: FunctionBody;\n    }\n    interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.SetAccessor;\n        readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: PropertyName;\n        readonly body?: FunctionBody;\n    }\n    type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;\n    interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement, LocalsContainer {\n        readonly kind: SyntaxKind.IndexSignature;\n        readonly parent: ObjectTypeDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly type: TypeNode;\n    }\n    interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer, LocalsContainer {\n        readonly kind: SyntaxKind.ClassStaticBlockDeclaration;\n        readonly parent: ClassDeclaration | ClassExpression;\n        readonly body: Block;\n    }\n    interface TypeNode extends Node {\n        _typeNodeBrand: any;\n    }\n    interface KeywordTypeNode<TKind extends KeywordTypeSyntaxKind = KeywordTypeSyntaxKind> extends KeywordToken<TKind>, TypeNode {\n        readonly kind: TKind;\n    }\n    /** @deprecated */\n    interface ImportTypeAssertionContainer extends Node {\n        readonly kind: SyntaxKind.ImportTypeAssertionContainer;\n        readonly parent: ImportTypeNode;\n        /** @deprecated */ readonly assertClause: AssertClause;\n        readonly multiLine?: boolean;\n    }\n    interface ImportTypeNode extends NodeWithTypeArguments {\n        readonly kind: SyntaxKind.ImportType;\n        readonly isTypeOf: boolean;\n        readonly argument: TypeNode;\n        /** @deprecated */ readonly assertions?: ImportTypeAssertionContainer;\n        readonly attributes?: ImportAttributes;\n        readonly qualifier?: EntityName;\n    }\n    interface ThisTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ThisType;\n    }\n    type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;\n    interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {\n        readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;\n        readonly type: TypeNode;\n    }\n    interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {\n        readonly kind: SyntaxKind.FunctionType;\n    }\n    interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase, LocalsContainer {\n        readonly kind: SyntaxKind.ConstructorType;\n        readonly modifiers?: NodeArray<Modifier>;\n    }\n    interface NodeWithTypeArguments extends TypeNode {\n        readonly typeArguments?: NodeArray<TypeNode>;\n    }\n    type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;\n    interface TypeReferenceNode extends NodeWithTypeArguments {\n        readonly kind: SyntaxKind.TypeReference;\n        readonly typeName: EntityName;\n    }\n    interface TypePredicateNode extends TypeNode {\n        readonly kind: SyntaxKind.TypePredicate;\n        readonly parent: SignatureDeclaration | JSDocTypeExpression;\n        readonly assertsModifier?: AssertsKeyword;\n        readonly parameterName: Identifier | ThisTypeNode;\n        readonly type?: TypeNode;\n    }\n    interface TypeQueryNode extends NodeWithTypeArguments {\n        readonly kind: SyntaxKind.TypeQuery;\n        readonly exprName: EntityName;\n    }\n    interface TypeLiteralNode extends TypeNode, Declaration {\n        readonly kind: SyntaxKind.TypeLiteral;\n        readonly members: NodeArray<TypeElement>;\n    }\n    interface ArrayTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ArrayType;\n        readonly elementType: TypeNode;\n    }\n    interface TupleTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.TupleType;\n        readonly elements: NodeArray<TypeNode | NamedTupleMember>;\n    }\n    interface NamedTupleMember extends TypeNode, Declaration, JSDocContainer {\n        readonly kind: SyntaxKind.NamedTupleMember;\n        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\n        readonly name: Identifier;\n        readonly questionToken?: Token<SyntaxKind.QuestionToken>;\n        readonly type: TypeNode;\n    }\n    interface OptionalTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.OptionalType;\n        readonly type: TypeNode;\n    }\n    interface RestTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.RestType;\n        readonly type: TypeNode;\n    }\n    type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;\n    interface UnionTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.UnionType;\n        readonly types: NodeArray<TypeNode>;\n    }\n    interface IntersectionTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.IntersectionType;\n        readonly types: NodeArray<TypeNode>;\n    }\n    interface ConditionalTypeNode extends TypeNode, LocalsContainer {\n        readonly kind: SyntaxKind.ConditionalType;\n        readonly checkType: TypeNode;\n        readonly extendsType: TypeNode;\n        readonly trueType: TypeNode;\n        readonly falseType: TypeNode;\n    }\n    interface InferTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.InferType;\n        readonly typeParameter: TypeParameterDeclaration;\n    }\n    interface ParenthesizedTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.ParenthesizedType;\n        readonly type: TypeNode;\n    }\n    interface TypeOperatorNode extends TypeNode {\n        readonly kind: SyntaxKind.TypeOperator;\n        readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;\n        readonly type: TypeNode;\n    }\n    interface IndexedAccessTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.IndexedAccessType;\n        readonly objectType: TypeNode;\n        readonly indexType: TypeNode;\n    }\n    interface MappedTypeNode extends TypeNode, Declaration, LocalsContainer {\n        readonly kind: SyntaxKind.MappedType;\n        readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;\n        readonly typeParameter: TypeParameterDeclaration;\n        readonly nameType?: TypeNode;\n        readonly questionToken?: QuestionToken | PlusToken | MinusToken;\n        readonly type?: TypeNode;\n        /** Used only to produce grammar errors */\n        readonly members?: NodeArray<TypeElement>;\n    }\n    interface LiteralTypeNode extends TypeNode {\n        readonly kind: SyntaxKind.LiteralType;\n        readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\n    }\n    interface StringLiteral extends LiteralExpression, Declaration {\n        readonly kind: SyntaxKind.StringLiteral;\n    }\n    type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;\n    type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral | JsxNamespacedName | BigIntLiteral;\n    interface TemplateLiteralTypeNode extends TypeNode {\n        kind: SyntaxKind.TemplateLiteralType;\n        readonly head: TemplateHead;\n        readonly templateSpans: NodeArray<TemplateLiteralTypeSpan>;\n    }\n    interface TemplateLiteralTypeSpan extends TypeNode {\n        readonly kind: SyntaxKind.TemplateLiteralTypeSpan;\n        readonly parent: TemplateLiteralTypeNode;\n        readonly type: TypeNode;\n        readonly literal: TemplateMiddle | TemplateTail;\n    }\n    interface Expression extends Node {\n        _expressionBrand: any;\n    }\n    interface OmittedExpression extends Expression {\n        readonly kind: SyntaxKind.OmittedExpression;\n    }\n    interface PartiallyEmittedExpression extends LeftHandSideExpression {\n        readonly kind: SyntaxKind.PartiallyEmittedExpression;\n        readonly expression: Expression;\n    }\n    interface UnaryExpression extends Expression {\n        _unaryExpressionBrand: any;\n    }\n    /** Deprecated, please use UpdateExpression */\n    type IncrementExpression = UpdateExpression;\n    interface UpdateExpression extends UnaryExpression {\n        _updateExpressionBrand: any;\n    }\n    type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;\n    interface PrefixUnaryExpression extends UpdateExpression {\n        readonly kind: SyntaxKind.PrefixUnaryExpression;\n        readonly operator: PrefixUnaryOperator;\n        readonly operand: UnaryExpression;\n    }\n    type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;\n    interface PostfixUnaryExpression extends UpdateExpression {\n        readonly kind: SyntaxKind.PostfixUnaryExpression;\n        readonly operand: LeftHandSideExpression;\n        readonly operator: PostfixUnaryOperator;\n    }\n    interface LeftHandSideExpression extends UpdateExpression {\n        _leftHandSideExpressionBrand: any;\n    }\n    interface MemberExpression extends LeftHandSideExpression {\n        _memberExpressionBrand: any;\n    }\n    interface PrimaryExpression extends MemberExpression {\n        _primaryExpressionBrand: any;\n    }\n    interface NullLiteral extends PrimaryExpression {\n        readonly kind: SyntaxKind.NullKeyword;\n    }\n    interface TrueLiteral extends PrimaryExpression {\n        readonly kind: SyntaxKind.TrueKeyword;\n    }\n    interface FalseLiteral extends PrimaryExpression {\n        readonly kind: SyntaxKind.FalseKeyword;\n    }\n    type BooleanLiteral = TrueLiteral | FalseLiteral;\n    interface ThisExpression extends PrimaryExpression, FlowContainer {\n        readonly kind: SyntaxKind.ThisKeyword;\n    }\n    interface SuperExpression extends PrimaryExpression, FlowContainer {\n        readonly kind: SyntaxKind.SuperKeyword;\n    }\n    interface ImportExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.ImportKeyword;\n    }\n    interface DeleteExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.DeleteExpression;\n        readonly expression: UnaryExpression;\n    }\n    interface TypeOfExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.TypeOfExpression;\n        readonly expression: UnaryExpression;\n    }\n    interface VoidExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.VoidExpression;\n        readonly expression: UnaryExpression;\n    }\n    interface AwaitExpression extends UnaryExpression {\n        readonly kind: SyntaxKind.AwaitExpression;\n        readonly expression: UnaryExpression;\n    }\n    interface YieldExpression extends Expression {\n        readonly kind: SyntaxKind.YieldExpression;\n        readonly asteriskToken?: AsteriskToken;\n        readonly expression?: Expression;\n    }\n    interface SyntheticExpression extends Expression {\n        readonly kind: SyntaxKind.SyntheticExpression;\n        readonly isSpread: boolean;\n        readonly type: Type;\n        readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;\n    }\n    type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;\n    type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;\n    type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;\n    type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;\n    type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;\n    type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;\n    type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;\n    type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;\n    type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;\n    type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;\n    type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;\n    type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;\n    type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;\n    type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;\n    type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;\n    type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;\n    type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;\n    type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;\n    type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;\n    type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;\n    type BinaryOperatorToken = Token<BinaryOperator>;\n    interface BinaryExpression extends Expression, Declaration, JSDocContainer {\n        readonly kind: SyntaxKind.BinaryExpression;\n        readonly left: Expression;\n        readonly operatorToken: BinaryOperatorToken;\n        readonly right: Expression;\n    }\n    type AssignmentOperatorToken = Token<AssignmentOperator>;\n    interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {\n        readonly left: LeftHandSideExpression;\n        readonly operatorToken: TOperator;\n    }\n    interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {\n        readonly left: ObjectLiteralExpression;\n    }\n    interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {\n        readonly left: ArrayLiteralExpression;\n    }\n    type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;\n    type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;\n    type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;\n    type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;\n    type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;\n    type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;\n    type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;\n    type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;\n    type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;\n    type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;\n    interface ConditionalExpression extends Expression {\n        readonly kind: SyntaxKind.ConditionalExpression;\n        readonly condition: Expression;\n        readonly questionToken: QuestionToken;\n        readonly whenTrue: Expression;\n        readonly colonToken: ColonToken;\n        readonly whenFalse: Expression;\n    }\n    type FunctionBody = Block;\n    type ConciseBody = FunctionBody | Expression;\n    interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.FunctionExpression;\n        readonly modifiers?: NodeArray<Modifier>;\n        readonly name?: Identifier;\n        readonly body: FunctionBody;\n    }\n    interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.ArrowFunction;\n        readonly modifiers?: NodeArray<Modifier>;\n        readonly equalsGreaterThanToken: EqualsGreaterThanToken;\n        readonly body: ConciseBody;\n        readonly name: never;\n    }\n    interface LiteralLikeNode extends Node {\n        text: string;\n        isUnterminated?: boolean;\n        hasExtendedUnicodeEscape?: boolean;\n    }\n    interface TemplateLiteralLikeNode extends LiteralLikeNode {\n        rawText?: string;\n    }\n    interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {\n        _literalExpressionBrand: any;\n    }\n    interface RegularExpressionLiteral extends LiteralExpression {\n        readonly kind: SyntaxKind.RegularExpressionLiteral;\n    }\n    interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {\n        readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;\n    }\n    enum TokenFlags {\n        None = 0,\n        Scientific = 16,\n        Octal = 32,\n        HexSpecifier = 64,\n        BinarySpecifier = 128,\n        OctalSpecifier = 256,\n    }\n    interface NumericLiteral extends LiteralExpression, Declaration {\n        readonly kind: SyntaxKind.NumericLiteral;\n    }\n    interface BigIntLiteral extends LiteralExpression {\n        readonly kind: SyntaxKind.BigIntLiteral;\n    }\n    type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;\n    interface TemplateHead extends TemplateLiteralLikeNode {\n        readonly kind: SyntaxKind.TemplateHead;\n        readonly parent: TemplateExpression | TemplateLiteralTypeNode;\n    }\n    interface TemplateMiddle extends TemplateLiteralLikeNode {\n        readonly kind: SyntaxKind.TemplateMiddle;\n        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;\n    }\n    interface TemplateTail extends TemplateLiteralLikeNode {\n        readonly kind: SyntaxKind.TemplateTail;\n        readonly parent: TemplateSpan | TemplateLiteralTypeSpan;\n    }\n    type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;\n    type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;\n    interface TemplateExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.TemplateExpression;\n        readonly head: TemplateHead;\n        readonly templateSpans: NodeArray<TemplateSpan>;\n    }\n    type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;\n    interface TemplateSpan extends Node {\n        readonly kind: SyntaxKind.TemplateSpan;\n        readonly parent: TemplateExpression;\n        readonly expression: Expression;\n        readonly literal: TemplateMiddle | TemplateTail;\n    }\n    interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {\n        readonly kind: SyntaxKind.ParenthesizedExpression;\n        readonly expression: Expression;\n    }\n    interface ArrayLiteralExpression extends PrimaryExpression {\n        readonly kind: SyntaxKind.ArrayLiteralExpression;\n        readonly elements: NodeArray<Expression>;\n    }\n    interface SpreadElement extends Expression {\n        readonly kind: SyntaxKind.SpreadElement;\n        readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;\n        readonly expression: Expression;\n    }\n    /**\n     * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to\n     * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be\n     * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type\n     * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)\n     */\n    interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {\n        readonly properties: NodeArray<T>;\n    }\n    interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike>, JSDocContainer {\n        readonly kind: SyntaxKind.ObjectLiteralExpression;\n    }\n    type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;\n    type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;\n    type AccessExpression = PropertyAccessExpression | ElementAccessExpression;\n    interface PropertyAccessExpression extends MemberExpression, NamedDeclaration, JSDocContainer, FlowContainer {\n        readonly kind: SyntaxKind.PropertyAccessExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly questionDotToken?: QuestionDotToken;\n        readonly name: MemberName;\n    }\n    interface PropertyAccessChain extends PropertyAccessExpression {\n        _optionalChainBrand: any;\n        readonly name: MemberName;\n    }\n    interface SuperPropertyAccessExpression extends PropertyAccessExpression {\n        readonly expression: SuperExpression;\n    }\n    /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */\n    interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {\n        _propertyAccessExpressionLikeQualifiedNameBrand?: any;\n        readonly expression: EntityNameExpression;\n        readonly name: Identifier;\n    }\n    interface ElementAccessExpression extends MemberExpression, Declaration, JSDocContainer, FlowContainer {\n        readonly kind: SyntaxKind.ElementAccessExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly questionDotToken?: QuestionDotToken;\n        readonly argumentExpression: Expression;\n    }\n    interface ElementAccessChain extends ElementAccessExpression {\n        _optionalChainBrand: any;\n    }\n    interface SuperElementAccessExpression extends ElementAccessExpression {\n        readonly expression: SuperExpression;\n    }\n    type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;\n    interface CallExpression extends LeftHandSideExpression, Declaration {\n        readonly kind: SyntaxKind.CallExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly questionDotToken?: QuestionDotToken;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly arguments: NodeArray<Expression>;\n    }\n    interface CallChain extends CallExpression {\n        _optionalChainBrand: any;\n    }\n    type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;\n    interface SuperCall extends CallExpression {\n        readonly expression: SuperExpression;\n    }\n    interface ImportCall extends CallExpression {\n        readonly expression: ImportExpression;\n    }\n    interface ExpressionWithTypeArguments extends MemberExpression, NodeWithTypeArguments {\n        readonly kind: SyntaxKind.ExpressionWithTypeArguments;\n        readonly expression: LeftHandSideExpression;\n    }\n    interface NewExpression extends PrimaryExpression, Declaration {\n        readonly kind: SyntaxKind.NewExpression;\n        readonly expression: LeftHandSideExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly arguments?: NodeArray<Expression>;\n    }\n    interface TaggedTemplateExpression extends MemberExpression {\n        readonly kind: SyntaxKind.TaggedTemplateExpression;\n        readonly tag: LeftHandSideExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly template: TemplateLiteral;\n    }\n    interface InstanceofExpression extends BinaryExpression {\n        readonly operatorToken: Token<SyntaxKind.InstanceOfKeyword>;\n    }\n    type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxCallLike | InstanceofExpression;\n    interface AsExpression extends Expression {\n        readonly kind: SyntaxKind.AsExpression;\n        readonly expression: Expression;\n        readonly type: TypeNode;\n    }\n    interface TypeAssertion extends UnaryExpression {\n        readonly kind: SyntaxKind.TypeAssertionExpression;\n        readonly type: TypeNode;\n        readonly expression: UnaryExpression;\n    }\n    interface SatisfiesExpression extends Expression {\n        readonly kind: SyntaxKind.SatisfiesExpression;\n        readonly expression: Expression;\n        readonly type: TypeNode;\n    }\n    type AssertionExpression = TypeAssertion | AsExpression;\n    interface NonNullExpression extends LeftHandSideExpression {\n        readonly kind: SyntaxKind.NonNullExpression;\n        readonly expression: Expression;\n    }\n    interface NonNullChain extends NonNullExpression {\n        _optionalChainBrand: any;\n    }\n    interface MetaProperty extends PrimaryExpression, FlowContainer {\n        readonly kind: SyntaxKind.MetaProperty;\n        readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;\n        readonly name: Identifier;\n    }\n    interface JsxElement extends PrimaryExpression {\n        readonly kind: SyntaxKind.JsxElement;\n        readonly openingElement: JsxOpeningElement;\n        readonly children: NodeArray<JsxChild>;\n        readonly closingElement: JsxClosingElement;\n    }\n    type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;\n    type JsxCallLike = JsxOpeningLikeElement | JsxOpeningFragment;\n    type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;\n    type JsxAttributeName = Identifier | JsxNamespacedName;\n    type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess | JsxNamespacedName;\n    interface JsxTagNamePropertyAccess extends PropertyAccessExpression {\n        readonly expression: Identifier | ThisExpression | JsxTagNamePropertyAccess;\n    }\n    interface JsxAttributes extends PrimaryExpression, Declaration {\n        readonly properties: NodeArray<JsxAttributeLike>;\n        readonly kind: SyntaxKind.JsxAttributes;\n        readonly parent: JsxOpeningLikeElement;\n    }\n    interface JsxNamespacedName extends Node {\n        readonly kind: SyntaxKind.JsxNamespacedName;\n        readonly name: Identifier;\n        readonly namespace: Identifier;\n    }\n    interface JsxOpeningElement extends Expression {\n        readonly kind: SyntaxKind.JsxOpeningElement;\n        readonly parent: JsxElement;\n        readonly tagName: JsxTagNameExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly attributes: JsxAttributes;\n    }\n    interface JsxSelfClosingElement extends PrimaryExpression {\n        readonly kind: SyntaxKind.JsxSelfClosingElement;\n        readonly tagName: JsxTagNameExpression;\n        readonly typeArguments?: NodeArray<TypeNode>;\n        readonly attributes: JsxAttributes;\n    }\n    interface JsxFragment extends PrimaryExpression {\n        readonly kind: SyntaxKind.JsxFragment;\n        readonly openingFragment: JsxOpeningFragment;\n        readonly children: NodeArray<JsxChild>;\n        readonly closingFragment: JsxClosingFragment;\n    }\n    interface JsxOpeningFragment extends Expression {\n        readonly kind: SyntaxKind.JsxOpeningFragment;\n        readonly parent: JsxFragment;\n    }\n    interface JsxClosingFragment extends Expression {\n        readonly kind: SyntaxKind.JsxClosingFragment;\n        readonly parent: JsxFragment;\n    }\n    interface JsxAttribute extends Declaration {\n        readonly kind: SyntaxKind.JsxAttribute;\n        readonly parent: JsxAttributes;\n        readonly name: JsxAttributeName;\n        readonly initializer?: JsxAttributeValue;\n    }\n    type JsxAttributeValue = StringLiteral | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;\n    interface JsxSpreadAttribute extends ObjectLiteralElement {\n        readonly kind: SyntaxKind.JsxSpreadAttribute;\n        readonly parent: JsxAttributes;\n        readonly expression: Expression;\n    }\n    interface JsxClosingElement extends Node {\n        readonly kind: SyntaxKind.JsxClosingElement;\n        readonly parent: JsxElement;\n        readonly tagName: JsxTagNameExpression;\n    }\n    interface JsxExpression extends Expression {\n        readonly kind: SyntaxKind.JsxExpression;\n        readonly parent: JsxElement | JsxFragment | JsxAttributeLike;\n        readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;\n        readonly expression?: Expression;\n    }\n    interface JsxText extends LiteralLikeNode {\n        readonly kind: SyntaxKind.JsxText;\n        readonly parent: JsxElement | JsxFragment;\n        readonly containsOnlyTriviaWhiteSpaces: boolean;\n    }\n    type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;\n    interface Statement extends Node, JSDocContainer {\n        _statementBrand: any;\n    }\n    interface NotEmittedStatement extends Statement {\n        readonly kind: SyntaxKind.NotEmittedStatement;\n    }\n    interface NotEmittedTypeElement extends TypeElement {\n        readonly kind: SyntaxKind.NotEmittedTypeElement;\n    }\n    /**\n     * A list of comma-separated expressions. This node is only created by transformations.\n     */\n    interface CommaListExpression extends Expression {\n        readonly kind: SyntaxKind.CommaListExpression;\n        readonly elements: NodeArray<Expression>;\n    }\n    interface EmptyStatement extends Statement {\n        readonly kind: SyntaxKind.EmptyStatement;\n    }\n    interface DebuggerStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.DebuggerStatement;\n    }\n    interface MissingDeclaration extends DeclarationStatement, PrimaryExpression {\n        readonly kind: SyntaxKind.MissingDeclaration;\n        readonly name?: Identifier;\n    }\n    type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;\n    interface Block extends Statement, LocalsContainer {\n        readonly kind: SyntaxKind.Block;\n        readonly statements: NodeArray<Statement>;\n    }\n    interface VariableStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.VariableStatement;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly declarationList: VariableDeclarationList;\n    }\n    interface ExpressionStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.ExpressionStatement;\n        readonly expression: Expression;\n    }\n    interface IfStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.IfStatement;\n        readonly expression: Expression;\n        readonly thenStatement: Statement;\n        readonly elseStatement?: Statement;\n    }\n    interface IterationStatement extends Statement {\n        readonly statement: Statement;\n    }\n    interface DoStatement extends IterationStatement, FlowContainer {\n        readonly kind: SyntaxKind.DoStatement;\n        readonly expression: Expression;\n    }\n    interface WhileStatement extends IterationStatement, FlowContainer {\n        readonly kind: SyntaxKind.WhileStatement;\n        readonly expression: Expression;\n    }\n    type ForInitializer = VariableDeclarationList | Expression;\n    interface ForStatement extends IterationStatement, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.ForStatement;\n        readonly initializer?: ForInitializer;\n        readonly condition?: Expression;\n        readonly incrementor?: Expression;\n    }\n    type ForInOrOfStatement = ForInStatement | ForOfStatement;\n    interface ForInStatement extends IterationStatement, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.ForInStatement;\n        readonly initializer: ForInitializer;\n        readonly expression: Expression;\n    }\n    interface ForOfStatement extends IterationStatement, LocalsContainer, FlowContainer {\n        readonly kind: SyntaxKind.ForOfStatement;\n        readonly awaitModifier?: AwaitKeyword;\n        readonly initializer: ForInitializer;\n        readonly expression: Expression;\n    }\n    interface BreakStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.BreakStatement;\n        readonly label?: Identifier;\n    }\n    interface ContinueStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.ContinueStatement;\n        readonly label?: Identifier;\n    }\n    type BreakOrContinueStatement = BreakStatement | ContinueStatement;\n    interface ReturnStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.ReturnStatement;\n        readonly expression?: Expression;\n    }\n    interface WithStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.WithStatement;\n        readonly expression: Expression;\n        readonly statement: Statement;\n    }\n    interface SwitchStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.SwitchStatement;\n        readonly expression: Expression;\n        readonly caseBlock: CaseBlock;\n        possiblyExhaustive?: boolean;\n    }\n    interface CaseBlock extends Node, LocalsContainer {\n        readonly kind: SyntaxKind.CaseBlock;\n        readonly parent: SwitchStatement;\n        readonly clauses: NodeArray<CaseOrDefaultClause>;\n    }\n    interface CaseClause extends Node, JSDocContainer {\n        readonly kind: SyntaxKind.CaseClause;\n        readonly parent: CaseBlock;\n        readonly expression: Expression;\n        readonly statements: NodeArray<Statement>;\n    }\n    interface DefaultClause extends Node {\n        readonly kind: SyntaxKind.DefaultClause;\n        readonly parent: CaseBlock;\n        readonly statements: NodeArray<Statement>;\n    }\n    type CaseOrDefaultClause = CaseClause | DefaultClause;\n    interface LabeledStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.LabeledStatement;\n        readonly label: Identifier;\n        readonly statement: Statement;\n    }\n    interface ThrowStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.ThrowStatement;\n        readonly expression: Expression;\n    }\n    interface TryStatement extends Statement, FlowContainer {\n        readonly kind: SyntaxKind.TryStatement;\n        readonly tryBlock: Block;\n        readonly catchClause?: CatchClause;\n        readonly finallyBlock?: Block;\n    }\n    interface CatchClause extends Node, LocalsContainer {\n        readonly kind: SyntaxKind.CatchClause;\n        readonly parent: TryStatement;\n        readonly variableDeclaration?: VariableDeclaration;\n        readonly block: Block;\n    }\n    type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;\n    type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;\n    type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;\n    interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;\n        readonly name?: Identifier;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly heritageClauses?: NodeArray<HeritageClause>;\n        readonly members: NodeArray<ClassElement>;\n    }\n    interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {\n        readonly kind: SyntaxKind.ClassDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        /** May be undefined in `export default class { ... }`. */\n        readonly name?: Identifier;\n    }\n    interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {\n        readonly kind: SyntaxKind.ClassExpression;\n        readonly modifiers?: NodeArray<ModifierLike>;\n    }\n    type ClassLikeDeclaration = ClassDeclaration | ClassExpression;\n    interface ClassElement extends NamedDeclaration {\n        _classElementBrand: any;\n        readonly name?: PropertyName;\n    }\n    interface TypeElement extends NamedDeclaration {\n        _typeElementBrand: any;\n        readonly name?: PropertyName;\n        readonly questionToken?: QuestionToken | undefined;\n    }\n    interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.InterfaceDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: Identifier;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly heritageClauses?: NodeArray<HeritageClause>;\n        readonly members: NodeArray<TypeElement>;\n    }\n    interface HeritageClause extends Node {\n        readonly kind: SyntaxKind.HeritageClause;\n        readonly parent: InterfaceDeclaration | ClassLikeDeclaration;\n        readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;\n        readonly types: NodeArray<ExpressionWithTypeArguments>;\n    }\n    interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {\n        readonly kind: SyntaxKind.TypeAliasDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: Identifier;\n        readonly typeParameters?: NodeArray<TypeParameterDeclaration>;\n        readonly type: TypeNode;\n    }\n    interface EnumMember extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.EnumMember;\n        readonly parent: EnumDeclaration;\n        readonly name: PropertyName;\n        readonly initializer?: Expression;\n    }\n    interface EnumDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.EnumDeclaration;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: Identifier;\n        readonly members: NodeArray<EnumMember>;\n    }\n    type ModuleName = Identifier | StringLiteral;\n    type ModuleBody = NamespaceBody | JSDocNamespaceBody;\n    interface ModuleDeclaration extends DeclarationStatement, JSDocContainer, LocalsContainer {\n        readonly kind: SyntaxKind.ModuleDeclaration;\n        readonly parent: ModuleBody | SourceFile;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: ModuleName;\n        readonly body?: ModuleBody | JSDocNamespaceDeclaration;\n    }\n    type NamespaceBody = ModuleBlock | NamespaceDeclaration;\n    interface NamespaceDeclaration extends ModuleDeclaration {\n        readonly name: Identifier;\n        readonly body: NamespaceBody;\n    }\n    type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;\n    interface JSDocNamespaceDeclaration extends ModuleDeclaration {\n        readonly name: Identifier;\n        readonly body?: JSDocNamespaceBody;\n    }\n    interface ModuleBlock extends Node, Statement {\n        readonly kind: SyntaxKind.ModuleBlock;\n        readonly parent: ModuleDeclaration;\n        readonly statements: NodeArray<Statement>;\n    }\n    type ModuleReference = EntityName | ExternalModuleReference;\n    /**\n     * One of:\n     * - import x = require(\"mod\");\n     * - import x = M.x;\n     */\n    interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ImportEqualsDeclaration;\n        readonly parent: SourceFile | ModuleBlock;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly name: Identifier;\n        readonly isTypeOnly: boolean;\n        readonly moduleReference: ModuleReference;\n    }\n    interface ExternalModuleReference extends Node {\n        readonly kind: SyntaxKind.ExternalModuleReference;\n        readonly parent: ImportEqualsDeclaration;\n        readonly expression: Expression;\n    }\n    interface ImportDeclaration extends Statement {\n        readonly kind: SyntaxKind.ImportDeclaration;\n        readonly parent: SourceFile | ModuleBlock;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly importClause?: ImportClause;\n        /** If this is not a StringLiteral it will be a grammar error. */\n        readonly moduleSpecifier: Expression;\n        /** @deprecated */ readonly assertClause?: AssertClause;\n        readonly attributes?: ImportAttributes;\n    }\n    type NamedImportBindings = NamespaceImport | NamedImports;\n    type NamedExportBindings = NamespaceExport | NamedExports;\n    interface ImportClause extends NamedDeclaration {\n        readonly kind: SyntaxKind.ImportClause;\n        readonly parent: ImportDeclaration | JSDocImportTag;\n        readonly isTypeOnly: boolean;\n        readonly name?: Identifier;\n        readonly namedBindings?: NamedImportBindings;\n    }\n    /** @deprecated */\n    type AssertionKey = ImportAttributeName;\n    /** @deprecated */\n    interface AssertEntry extends ImportAttribute {\n    }\n    /** @deprecated */\n    interface AssertClause extends ImportAttributes {\n    }\n    type ImportAttributeName = Identifier | StringLiteral;\n    interface ImportAttribute extends Node {\n        readonly kind: SyntaxKind.ImportAttribute;\n        readonly parent: ImportAttributes;\n        readonly name: ImportAttributeName;\n        readonly value: Expression;\n    }\n    interface ImportAttributes extends Node {\n        readonly token: SyntaxKind.WithKeyword | SyntaxKind.AssertKeyword;\n        readonly kind: SyntaxKind.ImportAttributes;\n        readonly parent: ImportDeclaration | ExportDeclaration;\n        readonly elements: NodeArray<ImportAttribute>;\n        readonly multiLine?: boolean;\n    }\n    interface NamespaceImport extends NamedDeclaration {\n        readonly kind: SyntaxKind.NamespaceImport;\n        readonly parent: ImportClause;\n        readonly name: Identifier;\n    }\n    interface NamespaceExport extends NamedDeclaration {\n        readonly kind: SyntaxKind.NamespaceExport;\n        readonly parent: ExportDeclaration;\n        readonly name: ModuleExportName;\n    }\n    interface NamespaceExportDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.NamespaceExportDeclaration;\n        readonly name: Identifier;\n    }\n    interface ExportDeclaration extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ExportDeclaration;\n        readonly parent: SourceFile | ModuleBlock;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly isTypeOnly: boolean;\n        /** Will not be assigned in the case of `export * from \"foo\";` */\n        readonly exportClause?: NamedExportBindings;\n        /** If this is not a StringLiteral it will be a grammar error. */\n        readonly moduleSpecifier?: Expression;\n        /** @deprecated */ readonly assertClause?: AssertClause;\n        readonly attributes?: ImportAttributes;\n    }\n    interface NamedImports extends Node {\n        readonly kind: SyntaxKind.NamedImports;\n        readonly parent: ImportClause;\n        readonly elements: NodeArray<ImportSpecifier>;\n    }\n    interface NamedExports extends Node {\n        readonly kind: SyntaxKind.NamedExports;\n        readonly parent: ExportDeclaration;\n        readonly elements: NodeArray<ExportSpecifier>;\n    }\n    type NamedImportsOrExports = NamedImports | NamedExports;\n    interface ImportSpecifier extends NamedDeclaration {\n        readonly kind: SyntaxKind.ImportSpecifier;\n        readonly parent: NamedImports;\n        readonly propertyName?: ModuleExportName;\n        readonly name: Identifier;\n        readonly isTypeOnly: boolean;\n    }\n    interface ExportSpecifier extends NamedDeclaration, JSDocContainer {\n        readonly kind: SyntaxKind.ExportSpecifier;\n        readonly parent: NamedExports;\n        readonly isTypeOnly: boolean;\n        readonly propertyName?: ModuleExportName;\n        readonly name: ModuleExportName;\n    }\n    type ModuleExportName = Identifier | StringLiteral;\n    type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;\n    type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier | ExportDeclaration | NamespaceExport;\n    type TypeOnlyImportDeclaration =\n        | ImportClause & {\n            readonly isTypeOnly: true;\n            readonly name: Identifier;\n        }\n        | ImportEqualsDeclaration & {\n            readonly isTypeOnly: true;\n        }\n        | NamespaceImport & {\n            readonly parent: ImportClause & {\n                readonly isTypeOnly: true;\n            };\n        }\n        | ImportSpecifier\n            & ({\n                readonly isTypeOnly: true;\n            } | {\n                readonly parent: NamedImports & {\n                    readonly parent: ImportClause & {\n                        readonly isTypeOnly: true;\n                    };\n                };\n            });\n    type TypeOnlyExportDeclaration =\n        | ExportSpecifier\n            & ({\n                readonly isTypeOnly: true;\n            } | {\n                readonly parent: NamedExports & {\n                    readonly parent: ExportDeclaration & {\n                        readonly isTypeOnly: true;\n                    };\n                };\n            })\n        | ExportDeclaration & {\n            readonly isTypeOnly: true;\n            readonly moduleSpecifier: Expression;\n        }\n        | NamespaceExport & {\n            readonly parent: ExportDeclaration & {\n                readonly isTypeOnly: true;\n                readonly moduleSpecifier: Expression;\n            };\n        };\n    type TypeOnlyAliasDeclaration = TypeOnlyImportDeclaration | TypeOnlyExportDeclaration;\n    /**\n     * This is either an `export =` or an `export default` declaration.\n     * Unless `isExportEquals` is set, this node was parsed as an `export default`.\n     */\n    interface ExportAssignment extends DeclarationStatement, JSDocContainer {\n        readonly kind: SyntaxKind.ExportAssignment;\n        readonly parent: SourceFile;\n        readonly modifiers?: NodeArray<ModifierLike>;\n        readonly isExportEquals?: boolean;\n        readonly expression: Expression;\n    }\n    interface FileReference extends TextRange {\n        fileName: string;\n        resolutionMode?: ResolutionMode;\n        preserve?: boolean;\n    }\n    interface CheckJsDirective extends TextRange {\n        enabled: boolean;\n    }\n    type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;\n    interface CommentRange extends TextRange {\n        hasTrailingNewLine?: boolean;\n        kind: CommentKind;\n    }\n    interface SynthesizedComment extends CommentRange {\n        text: string;\n        pos: -1;\n        end: -1;\n        hasLeadingNewline?: boolean;\n    }\n    interface JSDocTypeExpression extends TypeNode {\n        readonly kind: SyntaxKind.JSDocTypeExpression;\n        readonly type: TypeNode;\n    }\n    interface JSDocNameReference extends Node {\n        readonly kind: SyntaxKind.JSDocNameReference;\n        readonly name: EntityName | JSDocMemberName;\n    }\n    /** Class#method reference in JSDoc */\n    interface JSDocMemberName extends Node {\n        readonly kind: SyntaxKind.JSDocMemberName;\n        readonly left: EntityName | JSDocMemberName;\n        readonly right: Identifier;\n    }\n    interface JSDocType extends TypeNode {\n        _jsDocTypeBrand: any;\n    }\n    interface JSDocAllType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocAllType;\n    }\n    interface JSDocUnknownType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocUnknownType;\n    }\n    interface JSDocNonNullableType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocNonNullableType;\n        readonly type: TypeNode;\n        readonly postfix: boolean;\n    }\n    interface JSDocNullableType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocNullableType;\n        readonly type: TypeNode;\n        readonly postfix: boolean;\n    }\n    interface JSDocOptionalType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocOptionalType;\n        readonly type: TypeNode;\n    }\n    interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase, LocalsContainer {\n        readonly kind: SyntaxKind.JSDocFunctionType;\n    }\n    interface JSDocVariadicType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocVariadicType;\n        readonly type: TypeNode;\n    }\n    interface JSDocNamepathType extends JSDocType {\n        readonly kind: SyntaxKind.JSDocNamepathType;\n        readonly type: TypeNode;\n    }\n    type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;\n    interface JSDoc extends Node {\n        readonly kind: SyntaxKind.JSDoc;\n        readonly parent: HasJSDoc;\n        readonly tags?: NodeArray<JSDocTag>;\n        readonly comment?: string | NodeArray<JSDocComment>;\n    }\n    interface JSDocTag extends Node {\n        readonly parent: JSDoc | JSDocTypeLiteral;\n        readonly tagName: Identifier;\n        readonly comment?: string | NodeArray<JSDocComment>;\n    }\n    interface JSDocLink extends Node {\n        readonly kind: SyntaxKind.JSDocLink;\n        readonly name?: EntityName | JSDocMemberName;\n        text: string;\n    }\n    interface JSDocLinkCode extends Node {\n        readonly kind: SyntaxKind.JSDocLinkCode;\n        readonly name?: EntityName | JSDocMemberName;\n        text: string;\n    }\n    interface JSDocLinkPlain extends Node {\n        readonly kind: SyntaxKind.JSDocLinkPlain;\n        readonly name?: EntityName | JSDocMemberName;\n        text: string;\n    }\n    type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;\n    interface JSDocText extends Node {\n        readonly kind: SyntaxKind.JSDocText;\n        text: string;\n    }\n    interface JSDocUnknownTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocTag;\n    }\n    /**\n     * Note that `@extends` is a synonym of `@augments`.\n     * Both tags are represented by this interface.\n     */\n    interface JSDocAugmentsTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocAugmentsTag;\n        readonly class: ExpressionWithTypeArguments & {\n            readonly expression: Identifier | PropertyAccessEntityNameExpression;\n        };\n    }\n    interface JSDocImplementsTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocImplementsTag;\n        readonly class: ExpressionWithTypeArguments & {\n            readonly expression: Identifier | PropertyAccessEntityNameExpression;\n        };\n    }\n    interface JSDocAuthorTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocAuthorTag;\n    }\n    interface JSDocDeprecatedTag extends JSDocTag {\n        kind: SyntaxKind.JSDocDeprecatedTag;\n    }\n    interface JSDocClassTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocClassTag;\n    }\n    interface JSDocPublicTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocPublicTag;\n    }\n    interface JSDocPrivateTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocPrivateTag;\n    }\n    interface JSDocProtectedTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocProtectedTag;\n    }\n    interface JSDocReadonlyTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocReadonlyTag;\n    }\n    interface JSDocOverrideTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocOverrideTag;\n    }\n    interface JSDocEnumTag extends JSDocTag, Declaration, LocalsContainer {\n        readonly kind: SyntaxKind.JSDocEnumTag;\n        readonly parent: JSDoc;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    interface JSDocThisTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocThisTag;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    interface JSDocTemplateTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocTemplateTag;\n        readonly constraint: JSDocTypeExpression | undefined;\n        readonly typeParameters: NodeArray<TypeParameterDeclaration>;\n    }\n    interface JSDocSeeTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocSeeTag;\n        readonly name?: JSDocNameReference;\n    }\n    interface JSDocReturnTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocReturnTag;\n        readonly typeExpression?: JSDocTypeExpression;\n    }\n    interface JSDocTypeTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocTypeTag;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    interface JSDocTypedefTag extends JSDocTag, NamedDeclaration, LocalsContainer {\n        readonly kind: SyntaxKind.JSDocTypedefTag;\n        readonly parent: JSDoc;\n        readonly fullName?: JSDocNamespaceDeclaration | Identifier;\n        readonly name?: Identifier;\n        readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;\n    }\n    interface JSDocCallbackTag extends JSDocTag, NamedDeclaration, LocalsContainer {\n        readonly kind: SyntaxKind.JSDocCallbackTag;\n        readonly parent: JSDoc;\n        readonly fullName?: JSDocNamespaceDeclaration | Identifier;\n        readonly name?: Identifier;\n        readonly typeExpression: JSDocSignature;\n    }\n    interface JSDocOverloadTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocOverloadTag;\n        readonly parent: JSDoc;\n        readonly typeExpression: JSDocSignature;\n    }\n    interface JSDocThrowsTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocThrowsTag;\n        readonly typeExpression?: JSDocTypeExpression;\n    }\n    interface JSDocSignature extends JSDocType, Declaration, JSDocContainer, LocalsContainer {\n        readonly kind: SyntaxKind.JSDocSignature;\n        readonly typeParameters?: readonly JSDocTemplateTag[];\n        readonly parameters: readonly JSDocParameterTag[];\n        readonly type: JSDocReturnTag | undefined;\n    }\n    interface JSDocPropertyLikeTag extends JSDocTag, Declaration {\n        readonly parent: JSDoc;\n        readonly name: EntityName;\n        readonly typeExpression?: JSDocTypeExpression;\n        /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */\n        readonly isNameFirst: boolean;\n        readonly isBracketed: boolean;\n    }\n    interface JSDocPropertyTag extends JSDocPropertyLikeTag {\n        readonly kind: SyntaxKind.JSDocPropertyTag;\n    }\n    interface JSDocParameterTag extends JSDocPropertyLikeTag {\n        readonly kind: SyntaxKind.JSDocParameterTag;\n    }\n    interface JSDocTypeLiteral extends JSDocType, Declaration {\n        readonly kind: SyntaxKind.JSDocTypeLiteral;\n        readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];\n        /** If true, then this type literal represents an *array* of its type. */\n        readonly isArrayType: boolean;\n    }\n    interface JSDocSatisfiesTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocSatisfiesTag;\n        readonly typeExpression: JSDocTypeExpression;\n    }\n    interface JSDocImportTag extends JSDocTag {\n        readonly kind: SyntaxKind.JSDocImportTag;\n        readonly parent: JSDoc;\n        readonly importClause?: ImportClause;\n        readonly moduleSpecifier: Expression;\n        readonly attributes?: ImportAttributes;\n    }\n    type FlowType = Type | IncompleteType;\n    interface IncompleteType {\n        flags: TypeFlags | 0;\n        type: Type;\n    }\n    interface AmdDependency {\n        path: string;\n        name?: string;\n    }\n    /**\n     * Subset of properties from SourceFile that are used in multiple utility functions\n     */\n    interface SourceFileLike {\n        readonly text: string;\n    }\n    interface SourceFileLike {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n    }\n    type ResolutionMode = ModuleKind.ESNext | ModuleKind.CommonJS | undefined;\n    interface SourceFile extends Declaration, LocalsContainer {\n        readonly kind: SyntaxKind.SourceFile;\n        readonly statements: NodeArray<Statement>;\n        readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;\n        fileName: string;\n        text: string;\n        amdDependencies: readonly AmdDependency[];\n        moduleName?: string;\n        referencedFiles: readonly FileReference[];\n        typeReferenceDirectives: readonly FileReference[];\n        libReferenceDirectives: readonly FileReference[];\n        languageVariant: LanguageVariant;\n        isDeclarationFile: boolean;\n        /**\n         * lib.d.ts should have a reference comment like\n         *\n         *  /// <reference no-default-lib=\"true\"/>\n         *\n         * If any other file has this comment, it signals not to include lib.d.ts\n         * because this containing file is intended to act as a default library.\n         */\n        hasNoDefaultLib: boolean;\n        languageVersion: ScriptTarget;\n        /**\n         * When `module` is `Node16` or `NodeNext`, this field controls whether the\n         * source file in question is an ESNext-output-format file, or a CommonJS-output-format\n         * module. This is derived by the module resolver as it looks up the file, since\n         * it is derived from either the file extension of the module, or the containing\n         * `package.json` context, and affects both checking and emit.\n         *\n         * It is _public_ so that (pre)transformers can set this field,\n         * since it switches the builtin `node` module transform. Generally speaking, if unset,\n         * the field is treated as though it is `ModuleKind.CommonJS`.\n         *\n         * Note that this field is only set by the module resolution process when\n         * `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting\n         * of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution`\n         * of `node`). If so, this field will be unset and source files will be considered to be\n         * CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.\n         */\n        impliedNodeFormat?: ResolutionMode;\n    }\n    interface SourceFile {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n        getLineEndOfPosition(pos: number): number;\n        getLineStarts(): readonly number[];\n        getPositionOfLineAndCharacter(line: number, character: number): number;\n        update(newText: string, textChangeRange: TextChangeRange): SourceFile;\n    }\n    interface Bundle extends Node {\n        readonly kind: SyntaxKind.Bundle;\n        readonly sourceFiles: readonly SourceFile[];\n    }\n    interface JsonSourceFile extends SourceFile {\n        readonly statements: NodeArray<JsonObjectExpressionStatement>;\n    }\n    interface TsConfigSourceFile extends JsonSourceFile {\n        extendedSourceFiles?: string[];\n    }\n    interface JsonMinusNumericLiteral extends PrefixUnaryExpression {\n        readonly kind: SyntaxKind.PrefixUnaryExpression;\n        readonly operator: SyntaxKind.MinusToken;\n        readonly operand: NumericLiteral;\n    }\n    type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;\n    interface JsonObjectExpressionStatement extends ExpressionStatement {\n        readonly expression: JsonObjectExpression;\n    }\n    interface ScriptReferenceHost {\n        getCompilerOptions(): CompilerOptions;\n        getSourceFile(fileName: string): SourceFile | undefined;\n        getSourceFileByPath(path: Path): SourceFile | undefined;\n        getCurrentDirectory(): string;\n    }\n    interface ParseConfigHost extends ModuleResolutionHost {\n        useCaseSensitiveFileNames: boolean;\n        readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];\n        /**\n         * Gets a value indicating whether the specified path exists and is a file.\n         * @param path The path to test.\n         */\n        fileExists(path: string): boolean;\n        readFile(path: string): string | undefined;\n        trace?(s: string): void;\n    }\n    /**\n     * Branded string for keeping track of when we've turned an ambiguous path\n     * specified like \"./blah\" to an absolute path to an actual\n     * tsconfig file, e.g. \"/root/blah/tsconfig.json\"\n     */\n    type ResolvedConfigFileName = string & {\n        _isResolvedConfigFileName: never;\n    };\n    interface WriteFileCallbackData {\n    }\n    type WriteFileCallback = (fileName: string, text: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData) => void;\n    class OperationCanceledException {\n    }\n    interface CancellationToken {\n        isCancellationRequested(): boolean;\n        /** @throws OperationCanceledException if isCancellationRequested is true */\n        throwIfCancellationRequested(): void;\n    }\n    interface Program extends ScriptReferenceHost {\n        getCurrentDirectory(): string;\n        /**\n         * Get a list of root file names that were passed to a 'createProgram'\n         */\n        getRootFileNames(): readonly string[];\n        /**\n         * Get a list of files in the program\n         */\n        getSourceFiles(): readonly SourceFile[];\n        /**\n         * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then\n         * the JavaScript and declaration files will be produced for all the files in this program.\n         * If targetSourceFile is specified, then only the JavaScript and declaration for that\n         * specific file will be generated.\n         *\n         * If writeFile is not specified then the writeFile callback from the compiler host will be\n         * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter\n         * will be invoked when writing the JavaScript and declaration files.\n         */\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        /** The first time this is called, it will return global diagnostics (no location). */\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        /**\n         * Gets a type checker that can be used to semantically analyze source files in the program.\n         */\n        getTypeChecker(): TypeChecker;\n        getNodeCount(): number;\n        getIdentifierCount(): number;\n        getSymbolCount(): number;\n        getTypeCount(): number;\n        getInstantiationCount(): number;\n        getRelationCacheSizes(): {\n            assignable: number;\n            identity: number;\n            subtype: number;\n            strictSubtype: number;\n        };\n        isSourceFileFromExternalLibrary(file: SourceFile): boolean;\n        isSourceFileDefaultLibrary(file: SourceFile): boolean;\n        /**\n         * Calculates the final resolution mode for a given module reference node. This function only returns a result when module resolution\n         * settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided via import attributes,\n         * which cause an `import` or `require` condition to be used during resolution regardless of module resolution settings. In absence of\n         * overriding attributes, and in modes that support differing resolution, the result indicates the syntax the usage would emit to JavaScript.\n         * Some examples:\n         *\n         * ```ts\n         * // tsc foo.mts --module nodenext\n         * import {} from \"mod\";\n         * // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension\n         *\n         * // tsc foo.cts --module nodenext\n         * import {} from \"mod\";\n         * // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension\n         *\n         * // tsc foo.ts --module preserve --moduleResolution bundler\n         * import {} from \"mod\";\n         * // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`\n         * // supports conditional imports/exports\n         *\n         * // tsc foo.ts --module preserve --moduleResolution node10\n         * import {} from \"mod\";\n         * // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`\n         * // does not support conditional imports/exports\n         *\n         * // tsc foo.ts --module commonjs --moduleResolution node10\n         * import type {} from \"mod\" with { \"resolution-mode\": \"import\" };\n         * // Result: ESNext - conditional imports/exports always supported with \"resolution-mode\" attribute\n         * ```\n         */\n        getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike): ResolutionMode;\n        /**\n         * Calculates the final resolution mode for an import at some index within a file's `imports` list. This function only returns a result\n         * when module resolution settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided\n         * via import attributes, which cause an `import` or `require` condition to be used during resolution regardless of module resolution\n         * settings. In absence of overriding attributes, and in modes that support differing resolution, the result indicates the syntax the\n         * usage would emit to JavaScript. Some examples:\n         *\n         * ```ts\n         * // tsc foo.mts --module nodenext\n         * import {} from \"mod\";\n         * // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension\n         *\n         * // tsc foo.cts --module nodenext\n         * import {} from \"mod\";\n         * // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension\n         *\n         * // tsc foo.ts --module preserve --moduleResolution bundler\n         * import {} from \"mod\";\n         * // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`\n         * // supports conditional imports/exports\n         *\n         * // tsc foo.ts --module preserve --moduleResolution node10\n         * import {} from \"mod\";\n         * // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`\n         * // does not support conditional imports/exports\n         *\n         * // tsc foo.ts --module commonjs --moduleResolution node10\n         * import type {} from \"mod\" with { \"resolution-mode\": \"import\" };\n         * // Result: ESNext - conditional imports/exports always supported with \"resolution-mode\" attribute\n         * ```\n         */\n        getModeForResolutionAtIndex(file: SourceFile, index: number): ResolutionMode;\n        getProjectReferences(): readonly ProjectReference[] | undefined;\n        getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;\n    }\n    interface ResolvedProjectReference {\n        commandLine: ParsedCommandLine;\n        sourceFile: SourceFile;\n        references?: readonly (ResolvedProjectReference | undefined)[];\n    }\n    type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;\n    interface CustomTransformer {\n        transformSourceFile(node: SourceFile): SourceFile;\n        transformBundle(node: Bundle): Bundle;\n    }\n    interface CustomTransformers {\n        /** Custom transformers to evaluate before built-in .js transformations. */\n        before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];\n        /** Custom transformers to evaluate after built-in .js transformations. */\n        after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];\n        /** Custom transformers to evaluate after built-in .d.ts transformations. */\n        afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];\n    }\n    interface SourceMapSpan {\n        /** Line number in the .js file. */\n        emittedLine: number;\n        /** Column number in the .js file. */\n        emittedColumn: number;\n        /** Line number in the .ts file. */\n        sourceLine: number;\n        /** Column number in the .ts file. */\n        sourceColumn: number;\n        /** Optional name (index into names array) associated with this span. */\n        nameIndex?: number;\n        /** .ts file (index into sources array) associated with this span */\n        sourceIndex: number;\n    }\n    /** Return code used by getEmitOutput function to indicate status of the function */\n    enum ExitStatus {\n        Success = 0,\n        DiagnosticsPresent_OutputsSkipped = 1,\n        DiagnosticsPresent_OutputsGenerated = 2,\n        InvalidProject_OutputsSkipped = 3,\n        ProjectReferenceCycle_OutputsSkipped = 4,\n    }\n    interface EmitResult {\n        emitSkipped: boolean;\n        /** Contains declaration emit diagnostics */\n        diagnostics: readonly Diagnostic[];\n        emittedFiles?: string[];\n    }\n    interface TypeChecker {\n        getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;\n        getTypeOfSymbol(symbol: Symbol): Type;\n        getDeclaredTypeOfSymbol(symbol: Symbol): Type;\n        getPropertiesOfType(type: Type): Symbol[];\n        getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;\n        getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;\n        getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;\n        getIndexInfosOfType(type: Type): readonly IndexInfo[];\n        getIndexInfosOfIndexSymbol: (indexSymbol: Symbol, siblingSymbols?: Symbol[] | undefined) => IndexInfo[];\n        getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];\n        getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;\n        getBaseTypes(type: InterfaceType): BaseType[];\n        getBaseTypeOfLiteralType(type: Type): Type;\n        getWidenedType(type: Type): Type;\n        /**\n         * Gets the \"awaited type\" of a type.\n         *\n         * If an expression has a Promise-like type, the \"awaited type\" of the expression is\n         * derived from the type of the first argument of the fulfillment callback for that\n         * Promise's `then` method. If the \"awaited type\" is itself a Promise-like, it is\n         * recursively unwrapped in the same manner until a non-promise type is found.\n         *\n         * If an expression does not have a Promise-like type, its \"awaited type\" is the type\n         * of the expression.\n         *\n         * If the resulting \"awaited type\" is a generic object type, then it is wrapped in\n         * an `Awaited<T>`.\n         *\n         * In the event the \"awaited type\" circularly references itself, or is a non-Promise\n         * object-type with a callable `then()` method, an \"awaited type\" cannot be determined\n         * and the value `undefined` will be returned.\n         *\n         * This is used to reflect the runtime behavior of the `await` keyword.\n         */\n        getAwaitedType(type: Type): Type | undefined;\n        getReturnTypeOfSignature(signature: Signature): Type;\n        getNullableType(type: Type, flags: TypeFlags): Type;\n        getNonNullableType(type: Type): Type;\n        getTypeArguments(type: TypeReference): readonly Type[];\n        /** Note that the resulting nodes cannot be checked. */\n        typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined):\n            | SignatureDeclaration & {\n                typeArguments?: NodeArray<TypeNode>;\n            }\n            | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;\n        /** Note that the resulting nodes cannot be checked. */\n        typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;\n        getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];\n        getSymbolAtLocation(node: Node): Symbol | undefined;\n        getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];\n        /**\n         * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.\n         * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.\n         */\n        getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;\n        getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;\n        /**\n         * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.\n         * Otherwise returns its input.\n         * For example, at `export type T = number;`:\n         *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.\n         *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.\n         *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.\n         */\n        getExportSymbolOfSymbol(symbol: Symbol): Symbol;\n        getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;\n        getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;\n        getTypeAtLocation(node: Node): Type;\n        getTypeFromTypeNode(node: TypeNode): Type;\n        signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;\n        typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\n        symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;\n        typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;\n        getFullyQualifiedName(symbol: Symbol): string;\n        getAugmentedPropertiesOfType(type: Type): Symbol[];\n        getRootSymbols(symbol: Symbol): readonly Symbol[];\n        getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;\n        getContextualType(node: Expression): Type | undefined;\n        /**\n         * returns unknownSignature in the case of an error.\n         * returns undefined if the node is not valid.\n         * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.\n         */\n        getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;\n        getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;\n        isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;\n        isUndefinedSymbol(symbol: Symbol): boolean;\n        isArgumentsSymbol(symbol: Symbol): boolean;\n        isUnknownSymbol(symbol: Symbol): boolean;\n        getMergedSymbol(symbol: Symbol): Symbol;\n        getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;\n        isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;\n        /** Follow all aliases to get the original symbol. */\n        getAliasedSymbol(symbol: Symbol): Symbol;\n        /** Follow a *single* alias to get the immediately aliased symbol. */\n        getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;\n        getExportsOfModule(moduleSymbol: Symbol): Symbol[];\n        getJsxIntrinsicTagNamesAt(location: Node): Symbol[];\n        isOptionalParameter(node: ParameterDeclaration): boolean;\n        getAmbientModules(): Symbol[];\n        tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;\n        getApparentType(type: Type): Type;\n        getBaseConstraintOfType(type: Type): Type | undefined;\n        getDefaultFromTypeParameter(type: Type): Type | undefined;\n        /**\n         * Gets the intrinsic `any` type. There are multiple types that act as `any` used internally in the compiler,\n         * so the type returned by this function should not be used in equality checks to determine if another type\n         * is `any`. Instead, use `type.flags & TypeFlags.Any`.\n         */\n        getAnyType(): Type;\n        getStringType(): Type;\n        getStringLiteralType(value: string): StringLiteralType;\n        getNumberType(): Type;\n        getNumberLiteralType(value: number): NumberLiteralType;\n        getBigIntType(): Type;\n        getBigIntLiteralType(value: PseudoBigInt): BigIntLiteralType;\n        getBooleanType(): Type;\n        getUnknownType(): Type;\n        getFalseType(): Type;\n        getTrueType(): Type;\n        getVoidType(): Type;\n        /**\n         * Gets the intrinsic `undefined` type. There are multiple types that act as `undefined` used internally in the compiler\n         * depending on compiler options, so the type returned by this function should not be used in equality checks to determine\n         * if another type is `undefined`. Instead, use `type.flags & TypeFlags.Undefined`.\n         */\n        getUndefinedType(): Type;\n        /**\n         * Gets the intrinsic `null` type. There are multiple types that act as `null` used internally in the compiler,\n         * so the type returned by this function should not be used in equality checks to determine if another type\n         * is `null`. Instead, use `type.flags & TypeFlags.Null`.\n         */\n        getNullType(): Type;\n        getESSymbolType(): Type;\n        /**\n         * Gets the intrinsic `never` type. There are multiple types that act as `never` used internally in the compiler,\n         * so the type returned by this function should not be used in equality checks to determine if another type\n         * is `never`. Instead, use `type.flags & TypeFlags.Never`.\n         */\n        getNeverType(): Type;\n        /**\n         * Returns true if the \"source\" type is assignable to the \"target\" type.\n         *\n         * ```ts\n         * declare const abcLiteral: ts.Type; // Type of \"abc\"\n         * declare const stringType: ts.Type; // Type of string\n         *\n         * isTypeAssignableTo(abcLiteral, abcLiteral); // true; \"abc\" is assignable to \"abc\"\n         * isTypeAssignableTo(abcLiteral, stringType); // true; \"abc\" is assignable to string\n         * isTypeAssignableTo(stringType, abcLiteral); // false; string is not assignable to \"abc\"\n         * isTypeAssignableTo(stringType, stringType); // true; string is assignable to string\n         * ```\n         */\n        isTypeAssignableTo(source: Type, target: Type): boolean;\n        /**\n         * True if this type is the `Array` or `ReadonlyArray` type from lib.d.ts.\n         * This function will _not_ return true if passed a type which\n         * extends `Array` (for example, the TypeScript AST's `NodeArray` type).\n         */\n        isArrayType(type: Type): boolean;\n        /**\n         * True if this type is a tuple type. This function will _not_ return true if\n         * passed a type which extends from a tuple.\n         */\n        isTupleType(type: Type): boolean;\n        /**\n         * True if this type is assignable to `ReadonlyArray<any>`.\n         */\n        isArrayLikeType(type: Type): boolean;\n        resolveName(name: string, location: Node | undefined, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;\n        getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;\n        /**\n         * Depending on the operation performed, it may be appropriate to throw away the checker\n         * if the cancellation token is triggered. Typically, if it is used for error checking\n         * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.\n         */\n        runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;\n        getTypeArgumentsForResolvedSignature(signature: Signature): readonly Type[] | undefined;\n    }\n    enum NodeBuilderFlags {\n        None = 0,\n        NoTruncation = 1,\n        WriteArrayAsGenericType = 2,\n        GenerateNamesForShadowedTypeParams = 4,\n        UseStructuralFallback = 8,\n        ForbidIndexedAccessSymbolReferences = 16,\n        WriteTypeArgumentsOfSignature = 32,\n        UseFullyQualifiedType = 64,\n        UseOnlyExternalAliasing = 128,\n        SuppressAnyReturnType = 256,\n        WriteTypeParametersInQualifiedName = 512,\n        MultilineObjectLiterals = 1024,\n        WriteClassExpressionAsTypeLiteral = 2048,\n        UseTypeOfFunction = 4096,\n        OmitParameterModifiers = 8192,\n        UseAliasDefinedOutsideCurrentScope = 16384,\n        UseSingleQuotesForStringLiteralType = 268435456,\n        NoTypeReduction = 536870912,\n        OmitThisParameter = 33554432,\n        AllowThisInObjectLiteral = 32768,\n        AllowQualifiedNameInPlaceOfIdentifier = 65536,\n        AllowAnonymousIdentifier = 131072,\n        AllowEmptyUnionOrIntersection = 262144,\n        AllowEmptyTuple = 524288,\n        AllowUniqueESSymbolType = 1048576,\n        AllowEmptyIndexInfoType = 2097152,\n        AllowNodeModulesRelativePaths = 67108864,\n        IgnoreErrors = 70221824,\n        InObjectTypeLiteral = 4194304,\n        InTypeAlias = 8388608,\n        InInitialEntityName = 16777216,\n    }\n    enum TypeFormatFlags {\n        None = 0,\n        NoTruncation = 1,\n        WriteArrayAsGenericType = 2,\n        GenerateNamesForShadowedTypeParams = 4,\n        UseStructuralFallback = 8,\n        WriteTypeArgumentsOfSignature = 32,\n        UseFullyQualifiedType = 64,\n        SuppressAnyReturnType = 256,\n        MultilineObjectLiterals = 1024,\n        WriteClassExpressionAsTypeLiteral = 2048,\n        UseTypeOfFunction = 4096,\n        OmitParameterModifiers = 8192,\n        UseAliasDefinedOutsideCurrentScope = 16384,\n        UseSingleQuotesForStringLiteralType = 268435456,\n        NoTypeReduction = 536870912,\n        OmitThisParameter = 33554432,\n        AllowUniqueESSymbolType = 1048576,\n        AddUndefined = 131072,\n        WriteArrowStyleSignature = 262144,\n        InArrayType = 524288,\n        InElementType = 2097152,\n        InFirstTypeArgument = 4194304,\n        InTypeAlias = 8388608,\n        NodeBuilderFlagsMask = 848330095,\n    }\n    enum SymbolFormatFlags {\n        None = 0,\n        WriteTypeParametersOrArguments = 1,\n        UseOnlyExternalAliasing = 2,\n        AllowAnyNodeKind = 4,\n        UseAliasDefinedOutsideCurrentScope = 8,\n    }\n    enum TypePredicateKind {\n        This = 0,\n        Identifier = 1,\n        AssertsThis = 2,\n        AssertsIdentifier = 3,\n    }\n    interface TypePredicateBase {\n        kind: TypePredicateKind;\n        type: Type | undefined;\n    }\n    interface ThisTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.This;\n        parameterName: undefined;\n        parameterIndex: undefined;\n        type: Type;\n    }\n    interface IdentifierTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.Identifier;\n        parameterName: string;\n        parameterIndex: number;\n        type: Type;\n    }\n    interface AssertsThisTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.AssertsThis;\n        parameterName: undefined;\n        parameterIndex: undefined;\n        type: Type | undefined;\n    }\n    interface AssertsIdentifierTypePredicate extends TypePredicateBase {\n        kind: TypePredicateKind.AssertsIdentifier;\n        parameterName: string;\n        parameterIndex: number;\n        type: Type | undefined;\n    }\n    type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;\n    enum SymbolFlags {\n        None = 0,\n        FunctionScopedVariable = 1,\n        BlockScopedVariable = 2,\n        Property = 4,\n        EnumMember = 8,\n        Function = 16,\n        Class = 32,\n        Interface = 64,\n        ConstEnum = 128,\n        RegularEnum = 256,\n        ValueModule = 512,\n        NamespaceModule = 1024,\n        TypeLiteral = 2048,\n        ObjectLiteral = 4096,\n        Method = 8192,\n        Constructor = 16384,\n        GetAccessor = 32768,\n        SetAccessor = 65536,\n        Signature = 131072,\n        TypeParameter = 262144,\n        TypeAlias = 524288,\n        ExportValue = 1048576,\n        Alias = 2097152,\n        Prototype = 4194304,\n        ExportStar = 8388608,\n        Optional = 16777216,\n        Transient = 33554432,\n        Assignment = 67108864,\n        ModuleExports = 134217728,\n        All = -1,\n        Enum = 384,\n        Variable = 3,\n        Value = 111551,\n        Type = 788968,\n        Namespace = 1920,\n        Module = 1536,\n        Accessor = 98304,\n        FunctionScopedVariableExcludes = 111550,\n        BlockScopedVariableExcludes = 111551,\n        ParameterExcludes = 111551,\n        PropertyExcludes = 0,\n        EnumMemberExcludes = 900095,\n        FunctionExcludes = 110991,\n        ClassExcludes = 899503,\n        InterfaceExcludes = 788872,\n        RegularEnumExcludes = 899327,\n        ConstEnumExcludes = 899967,\n        ValueModuleExcludes = 110735,\n        NamespaceModuleExcludes = 0,\n        MethodExcludes = 103359,\n        GetAccessorExcludes = 46015,\n        SetAccessorExcludes = 78783,\n        AccessorExcludes = 13247,\n        TypeParameterExcludes = 526824,\n        TypeAliasExcludes = 788968,\n        AliasExcludes = 2097152,\n        ModuleMember = 2623475,\n        ExportHasLocal = 944,\n        BlockScoped = 418,\n        PropertyOrAccessor = 98308,\n        ClassMember = 106500,\n    }\n    interface Symbol {\n        flags: SymbolFlags;\n        escapedName: __String;\n        declarations?: Declaration[];\n        valueDeclaration?: Declaration;\n        members?: SymbolTable;\n        exports?: SymbolTable;\n        globalExports?: SymbolTable;\n    }\n    interface Symbol {\n        readonly name: string;\n        getFlags(): SymbolFlags;\n        getEscapedName(): __String;\n        getName(): string;\n        getDeclarations(): Declaration[] | undefined;\n        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];\n        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];\n    }\n    enum InternalSymbolName {\n        Call = \"__call\",\n        Constructor = \"__constructor\",\n        New = \"__new\",\n        Index = \"__index\",\n        ExportStar = \"__export\",\n        Global = \"__global\",\n        Missing = \"__missing\",\n        Type = \"__type\",\n        Object = \"__object\",\n        JSXAttributes = \"__jsxAttributes\",\n        Class = \"__class\",\n        Function = \"__function\",\n        Computed = \"__computed\",\n        Resolving = \"__resolving__\",\n        ExportEquals = \"export=\",\n        Default = \"default\",\n        This = \"this\",\n        InstantiationExpression = \"__instantiationExpression\",\n        ImportAttributes = \"__importAttributes\",\n    }\n    /**\n     * This represents a string whose leading underscore have been escaped by adding extra leading underscores.\n     * The shape of this brand is rather unique compared to others we've used.\n     * Instead of just an intersection of a string and an object, it is that union-ed\n     * with an intersection of void and an object. This makes it wholly incompatible\n     * with a normal string (which is good, it cannot be misused on assignment or on usage),\n     * while still being comparable with a normal string via === (also good) and castable from a string.\n     */\n    type __String =\n        | (string & {\n            __escapedIdentifier: void;\n        })\n        | (void & {\n            __escapedIdentifier: void;\n        })\n        | InternalSymbolName;\n    /** @deprecated Use ReadonlyMap<__String, T> instead. */\n    type ReadonlyUnderscoreEscapedMap<T> = ReadonlyMap<__String, T>;\n    /** @deprecated Use Map<__String, T> instead. */\n    type UnderscoreEscapedMap<T> = Map<__String, T>;\n    /** SymbolTable based on ES6 Map interface. */\n    type SymbolTable = Map<__String, Symbol>;\n    enum TypeFlags {\n        Any = 1,\n        Unknown = 2,\n        String = 4,\n        Number = 8,\n        Boolean = 16,\n        Enum = 32,\n        BigInt = 64,\n        StringLiteral = 128,\n        NumberLiteral = 256,\n        BooleanLiteral = 512,\n        EnumLiteral = 1024,\n        BigIntLiteral = 2048,\n        ESSymbol = 4096,\n        UniqueESSymbol = 8192,\n        Void = 16384,\n        Undefined = 32768,\n        Null = 65536,\n        Never = 131072,\n        TypeParameter = 262144,\n        Object = 524288,\n        Union = 1048576,\n        Intersection = 2097152,\n        Index = 4194304,\n        IndexedAccess = 8388608,\n        Conditional = 16777216,\n        Substitution = 33554432,\n        NonPrimitive = 67108864,\n        TemplateLiteral = 134217728,\n        StringMapping = 268435456,\n        Literal = 2944,\n        Unit = 109472,\n        Freshable = 2976,\n        StringOrNumberLiteral = 384,\n        PossiblyFalsy = 117724,\n        StringLike = 402653316,\n        NumberLike = 296,\n        BigIntLike = 2112,\n        BooleanLike = 528,\n        EnumLike = 1056,\n        ESSymbolLike = 12288,\n        VoidLike = 49152,\n        UnionOrIntersection = 3145728,\n        StructuredType = 3670016,\n        TypeVariable = 8650752,\n        InstantiableNonPrimitive = 58982400,\n        InstantiablePrimitive = 406847488,\n        Instantiable = 465829888,\n        StructuredOrInstantiable = 469499904,\n        Narrowable = 536624127,\n    }\n    type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;\n    interface Type {\n        flags: TypeFlags;\n        symbol: Symbol;\n        pattern?: DestructuringPattern;\n        aliasSymbol?: Symbol;\n        aliasTypeArguments?: readonly Type[];\n    }\n    interface Type {\n        getFlags(): TypeFlags;\n        getSymbol(): Symbol | undefined;\n        getProperties(): Symbol[];\n        getProperty(propertyName: string): Symbol | undefined;\n        getApparentProperties(): Symbol[];\n        getCallSignatures(): readonly Signature[];\n        getConstructSignatures(): readonly Signature[];\n        getStringIndexType(): Type | undefined;\n        getNumberIndexType(): Type | undefined;\n        getBaseTypes(): BaseType[] | undefined;\n        getNonNullableType(): Type;\n        getConstraint(): Type | undefined;\n        getDefault(): Type | undefined;\n        isUnion(): this is UnionType;\n        isIntersection(): this is IntersectionType;\n        isUnionOrIntersection(): this is UnionOrIntersectionType;\n        isLiteral(): this is LiteralType;\n        isStringLiteral(): this is StringLiteralType;\n        isNumberLiteral(): this is NumberLiteralType;\n        isTypeParameter(): this is TypeParameter;\n        isClassOrInterface(): this is InterfaceType;\n        isClass(): this is InterfaceType;\n        isIndexType(): this is IndexType;\n    }\n    interface FreshableType extends Type {\n        freshType: FreshableType;\n        regularType: FreshableType;\n    }\n    interface LiteralType extends FreshableType {\n        value: string | number | PseudoBigInt;\n    }\n    interface UniqueESSymbolType extends Type {\n        symbol: Symbol;\n        escapedName: __String;\n    }\n    interface StringLiteralType extends LiteralType {\n        value: string;\n    }\n    interface NumberLiteralType extends LiteralType {\n        value: number;\n    }\n    interface BigIntLiteralType extends LiteralType {\n        value: PseudoBigInt;\n    }\n    interface EnumType extends FreshableType {\n    }\n    enum ObjectFlags {\n        None = 0,\n        Class = 1,\n        Interface = 2,\n        Reference = 4,\n        Tuple = 8,\n        Anonymous = 16,\n        Mapped = 32,\n        Instantiated = 64,\n        ObjectLiteral = 128,\n        EvolvingArray = 256,\n        ObjectLiteralPatternWithComputedProperties = 512,\n        ReverseMapped = 1024,\n        JsxAttributes = 2048,\n        JSLiteral = 4096,\n        FreshLiteral = 8192,\n        ArrayLiteral = 16384,\n        ClassOrInterface = 3,\n        ContainsSpread = 2097152,\n        ObjectRestType = 4194304,\n        InstantiationExpressionType = 8388608,\n        SingleSignatureType = 134217728,\n    }\n    interface ObjectType extends Type {\n        objectFlags: ObjectFlags;\n    }\n    /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */\n    interface InterfaceType extends ObjectType {\n        typeParameters: TypeParameter[] | undefined;\n        outerTypeParameters: TypeParameter[] | undefined;\n        localTypeParameters: TypeParameter[] | undefined;\n        thisType: TypeParameter | undefined;\n    }\n    type BaseType = ObjectType | IntersectionType | TypeVariable;\n    interface InterfaceTypeWithDeclaredMembers extends InterfaceType {\n        declaredProperties: Symbol[];\n        declaredCallSignatures: Signature[];\n        declaredConstructSignatures: Signature[];\n        declaredIndexInfos: IndexInfo[];\n    }\n    /**\n     * Type references (ObjectFlags.Reference). When a class or interface has type parameters or\n     * a \"this\" type, references to the class or interface are made using type references. The\n     * typeArguments property specifies the types to substitute for the type parameters of the\n     * class or interface and optionally includes an extra element that specifies the type to\n     * substitute for \"this\" in the resulting instantiation. When no extra argument is present,\n     * the type reference itself is substituted for \"this\". The typeArguments property is undefined\n     * if the class or interface has no type parameters and the reference isn't specifying an\n     * explicit \"this\" argument.\n     */\n    interface TypeReference extends ObjectType {\n        target: GenericType;\n        node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;\n    }\n    interface TypeReference {\n        typeArguments?: readonly Type[];\n    }\n    interface DeferredTypeReference extends TypeReference {\n    }\n    interface GenericType extends InterfaceType, TypeReference {\n    }\n    enum ElementFlags {\n        Required = 1,\n        Optional = 2,\n        Rest = 4,\n        Variadic = 8,\n        Fixed = 3,\n        Variable = 12,\n        NonRequired = 14,\n        NonRest = 11,\n    }\n    interface TupleType extends GenericType {\n        elementFlags: readonly ElementFlags[];\n        /** Number of required or variadic elements */\n        minLength: number;\n        /** Number of initial required or optional elements */\n        fixedLength: number;\n        /**\n         * True if tuple has any rest or variadic elements\n         *\n         * @deprecated Use `.combinedFlags & ElementFlags.Variable` instead\n         */\n        hasRestElement: boolean;\n        combinedFlags: ElementFlags;\n        readonly: boolean;\n        labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];\n    }\n    interface TupleTypeReference extends TypeReference {\n        target: TupleType;\n    }\n    interface UnionOrIntersectionType extends Type {\n        types: Type[];\n    }\n    interface UnionType extends UnionOrIntersectionType {\n    }\n    interface IntersectionType extends UnionOrIntersectionType {\n    }\n    type StructuredType = ObjectType | UnionType | IntersectionType;\n    interface EvolvingArrayType extends ObjectType {\n        elementType: Type;\n        finalArrayType?: Type;\n    }\n    interface InstantiableType extends Type {\n    }\n    interface TypeParameter extends InstantiableType {\n    }\n    interface IndexedAccessType extends InstantiableType {\n        objectType: Type;\n        indexType: Type;\n        constraint?: Type;\n        simplifiedForReading?: Type;\n        simplifiedForWriting?: Type;\n    }\n    type TypeVariable = TypeParameter | IndexedAccessType;\n    interface IndexType extends InstantiableType {\n        type: InstantiableType | UnionOrIntersectionType;\n    }\n    interface ConditionalRoot {\n        node: ConditionalTypeNode;\n        checkType: Type;\n        extendsType: Type;\n        isDistributive: boolean;\n        inferTypeParameters?: TypeParameter[];\n        outerTypeParameters?: TypeParameter[];\n        instantiations?: Map<string, Type>;\n        aliasSymbol?: Symbol;\n        aliasTypeArguments?: Type[];\n    }\n    interface ConditionalType extends InstantiableType {\n        root: ConditionalRoot;\n        checkType: Type;\n        extendsType: Type;\n        resolvedTrueType?: Type;\n        resolvedFalseType?: Type;\n    }\n    interface TemplateLiteralType extends InstantiableType {\n        texts: readonly string[];\n        types: readonly Type[];\n    }\n    interface StringMappingType extends InstantiableType {\n        symbol: Symbol;\n        type: Type;\n    }\n    interface SubstitutionType extends InstantiableType {\n        objectFlags: ObjectFlags;\n        baseType: Type;\n        constraint: Type;\n    }\n    enum SignatureKind {\n        Call = 0,\n        Construct = 1,\n    }\n    interface Signature {\n        declaration?: SignatureDeclaration | JSDocSignature;\n        typeParameters?: readonly TypeParameter[];\n        parameters: readonly Symbol[];\n        thisParameter?: Symbol;\n    }\n    interface Signature {\n        getDeclaration(): SignatureDeclaration;\n        getTypeParameters(): TypeParameter[] | undefined;\n        getParameters(): Symbol[];\n        getTypeParameterAtPosition(pos: number): Type;\n        getReturnType(): Type;\n        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];\n        getJsDocTags(): JSDocTagInfo[];\n    }\n    enum IndexKind {\n        String = 0,\n        Number = 1,\n    }\n    type ElementWithComputedPropertyName = (ClassElement | ObjectLiteralElement) & {\n        name: ComputedPropertyName;\n    };\n    interface IndexInfo {\n        keyType: Type;\n        type: Type;\n        isReadonly: boolean;\n        declaration?: IndexSignatureDeclaration;\n        components?: ElementWithComputedPropertyName[];\n    }\n    enum InferencePriority {\n        None = 0,\n        NakedTypeVariable = 1,\n        SpeculativeTuple = 2,\n        SubstituteSource = 4,\n        HomomorphicMappedType = 8,\n        PartialHomomorphicMappedType = 16,\n        MappedTypeConstraint = 32,\n        ContravariantConditional = 64,\n        ReturnType = 128,\n        LiteralKeyof = 256,\n        NoConstraints = 512,\n        AlwaysStrict = 1024,\n        MaxValue = 2048,\n        PriorityImpliesCombination = 416,\n        Circularity = -1,\n    }\n    interface FileExtensionInfo {\n        extension: string;\n        isMixedContent: boolean;\n        scriptKind?: ScriptKind;\n    }\n    interface DiagnosticMessage {\n        key: string;\n        category: DiagnosticCategory;\n        code: number;\n        message: string;\n        reportsUnnecessary?: {};\n        reportsDeprecated?: {};\n    }\n    /**\n     * A linked list of formatted diagnostic messages to be used as part of a multiline message.\n     * It is built from the bottom up, leaving the head to be the \"main\" diagnostic.\n     * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,\n     * the difference is that messages are all preformatted in DMC.\n     */\n    interface DiagnosticMessageChain {\n        messageText: string;\n        category: DiagnosticCategory;\n        code: number;\n        next?: DiagnosticMessageChain[];\n    }\n    interface Diagnostic extends DiagnosticRelatedInformation {\n        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */\n        reportsUnnecessary?: {};\n        reportsDeprecated?: {};\n        source?: string;\n        relatedInformation?: DiagnosticRelatedInformation[];\n    }\n    interface DiagnosticRelatedInformation {\n        category: DiagnosticCategory;\n        code: number;\n        file: SourceFile | undefined;\n        start: number | undefined;\n        length: number | undefined;\n        messageText: string | DiagnosticMessageChain;\n    }\n    interface DiagnosticWithLocation extends Diagnostic {\n        file: SourceFile;\n        start: number;\n        length: number;\n    }\n    enum DiagnosticCategory {\n        Warning = 0,\n        Error = 1,\n        Suggestion = 2,\n        Message = 3,\n    }\n    enum ModuleResolutionKind {\n        Classic = 1,\n        /**\n         * @deprecated\n         * `NodeJs` was renamed to `Node10` to better reflect the version of Node that it targets.\n         * Use the new name or consider switching to a modern module resolution target.\n         */\n        NodeJs = 2,\n        Node10 = 2,\n        Node16 = 3,\n        NodeNext = 99,\n        Bundler = 100,\n    }\n    enum ModuleDetectionKind {\n        /**\n         * Files with imports, exports and/or import.meta are considered modules\n         */\n        Legacy = 1,\n        /**\n         * Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+\n         */\n        Auto = 2,\n        /**\n         * Consider all non-declaration files modules, regardless of present syntax\n         */\n        Force = 3,\n    }\n    interface PluginImport {\n        name: string;\n    }\n    interface ProjectReference {\n        /** A normalized path on disk */\n        path: string;\n        /** The path as the user originally wrote it */\n        originalPath?: string;\n        /** @deprecated */\n        prepend?: boolean;\n        /** True if it is intended that this reference form a circularity */\n        circular?: boolean;\n    }\n    enum WatchFileKind {\n        FixedPollingInterval = 0,\n        PriorityPollingInterval = 1,\n        DynamicPriorityPolling = 2,\n        FixedChunkSizePolling = 3,\n        UseFsEvents = 4,\n        UseFsEventsOnParentDirectory = 5,\n    }\n    enum WatchDirectoryKind {\n        UseFsEvents = 0,\n        FixedPollingInterval = 1,\n        DynamicPriorityPolling = 2,\n        FixedChunkSizePolling = 3,\n    }\n    enum PollingWatchKind {\n        FixedInterval = 0,\n        PriorityInterval = 1,\n        DynamicPriority = 2,\n        FixedChunkSize = 3,\n    }\n    type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;\n    interface CompilerOptions {\n        allowImportingTsExtensions?: boolean;\n        allowJs?: boolean;\n        allowArbitraryExtensions?: boolean;\n        allowSyntheticDefaultImports?: boolean;\n        allowUmdGlobalAccess?: boolean;\n        allowUnreachableCode?: boolean;\n        allowUnusedLabels?: boolean;\n        alwaysStrict?: boolean;\n        baseUrl?: string;\n        /** @deprecated */\n        charset?: string;\n        checkJs?: boolean;\n        customConditions?: string[];\n        declaration?: boolean;\n        declarationMap?: boolean;\n        emitDeclarationOnly?: boolean;\n        declarationDir?: string;\n        disableSizeLimit?: boolean;\n        disableSourceOfProjectReferenceRedirect?: boolean;\n        disableSolutionSearching?: boolean;\n        disableReferencedProjectLoad?: boolean;\n        downlevelIteration?: boolean;\n        emitBOM?: boolean;\n        emitDecoratorMetadata?: boolean;\n        exactOptionalPropertyTypes?: boolean;\n        experimentalDecorators?: boolean;\n        forceConsistentCasingInFileNames?: boolean;\n        ignoreDeprecations?: string;\n        importHelpers?: boolean;\n        /** @deprecated */\n        importsNotUsedAsValues?: ImportsNotUsedAsValues;\n        inlineSourceMap?: boolean;\n        inlineSources?: boolean;\n        isolatedModules?: boolean;\n        isolatedDeclarations?: boolean;\n        jsx?: JsxEmit;\n        /** @deprecated */\n        keyofStringsOnly?: boolean;\n        lib?: string[];\n        libReplacement?: boolean;\n        locale?: string;\n        mapRoot?: string;\n        maxNodeModuleJsDepth?: number;\n        module?: ModuleKind;\n        moduleResolution?: ModuleResolutionKind;\n        moduleSuffixes?: string[];\n        moduleDetection?: ModuleDetectionKind;\n        newLine?: NewLineKind;\n        noEmit?: boolean;\n        noCheck?: boolean;\n        noEmitHelpers?: boolean;\n        noEmitOnError?: boolean;\n        noErrorTruncation?: boolean;\n        noFallthroughCasesInSwitch?: boolean;\n        noImplicitAny?: boolean;\n        noImplicitReturns?: boolean;\n        noImplicitThis?: boolean;\n        /** @deprecated */\n        noStrictGenericChecks?: boolean;\n        noUnusedLocals?: boolean;\n        noUnusedParameters?: boolean;\n        /** @deprecated */\n        noImplicitUseStrict?: boolean;\n        noPropertyAccessFromIndexSignature?: boolean;\n        assumeChangesOnlyAffectDirectDependencies?: boolean;\n        noLib?: boolean;\n        noResolve?: boolean;\n        noUncheckedIndexedAccess?: boolean;\n        /** @deprecated */\n        out?: string;\n        outDir?: string;\n        outFile?: string;\n        paths?: MapLike<string[]>;\n        preserveConstEnums?: boolean;\n        noImplicitOverride?: boolean;\n        preserveSymlinks?: boolean;\n        /** @deprecated */\n        preserveValueImports?: boolean;\n        project?: string;\n        reactNamespace?: string;\n        jsxFactory?: string;\n        jsxFragmentFactory?: string;\n        jsxImportSource?: string;\n        composite?: boolean;\n        incremental?: boolean;\n        tsBuildInfoFile?: string;\n        removeComments?: boolean;\n        resolvePackageJsonExports?: boolean;\n        resolvePackageJsonImports?: boolean;\n        rewriteRelativeImportExtensions?: boolean;\n        rootDir?: string;\n        rootDirs?: string[];\n        skipLibCheck?: boolean;\n        skipDefaultLibCheck?: boolean;\n        sourceMap?: boolean;\n        sourceRoot?: string;\n        strict?: boolean;\n        strictFunctionTypes?: boolean;\n        strictBindCallApply?: boolean;\n        strictNullChecks?: boolean;\n        strictPropertyInitialization?: boolean;\n        strictBuiltinIteratorReturn?: boolean;\n        stripInternal?: boolean;\n        /** @deprecated */\n        suppressExcessPropertyErrors?: boolean;\n        /** @deprecated */\n        suppressImplicitAnyIndexErrors?: boolean;\n        target?: ScriptTarget;\n        traceResolution?: boolean;\n        useUnknownInCatchVariables?: boolean;\n        noUncheckedSideEffectImports?: boolean;\n        resolveJsonModule?: boolean;\n        types?: string[];\n        /** Paths used to compute primary types search locations */\n        typeRoots?: string[];\n        verbatimModuleSyntax?: boolean;\n        erasableSyntaxOnly?: boolean;\n        esModuleInterop?: boolean;\n        useDefineForClassFields?: boolean;\n        [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;\n    }\n    interface WatchOptions {\n        watchFile?: WatchFileKind;\n        watchDirectory?: WatchDirectoryKind;\n        fallbackPolling?: PollingWatchKind;\n        synchronousWatchDirectory?: boolean;\n        excludeDirectories?: string[];\n        excludeFiles?: string[];\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    interface TypeAcquisition {\n        enable?: boolean;\n        include?: string[];\n        exclude?: string[];\n        disableFilenameBasedTypeAcquisition?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    enum ModuleKind {\n        None = 0,\n        CommonJS = 1,\n        AMD = 2,\n        UMD = 3,\n        System = 4,\n        ES2015 = 5,\n        ES2020 = 6,\n        ES2022 = 7,\n        ESNext = 99,\n        Node16 = 100,\n        Node18 = 101,\n        NodeNext = 199,\n        Preserve = 200,\n    }\n    enum JsxEmit {\n        None = 0,\n        Preserve = 1,\n        React = 2,\n        ReactNative = 3,\n        ReactJSX = 4,\n        ReactJSXDev = 5,\n    }\n    /** @deprecated */\n    enum ImportsNotUsedAsValues {\n        Remove = 0,\n        Preserve = 1,\n        Error = 2,\n    }\n    enum NewLineKind {\n        CarriageReturnLineFeed = 0,\n        LineFeed = 1,\n    }\n    interface LineAndCharacter {\n        /** 0-based. */\n        line: number;\n        character: number;\n    }\n    enum ScriptKind {\n        Unknown = 0,\n        JS = 1,\n        JSX = 2,\n        TS = 3,\n        TSX = 4,\n        External = 5,\n        JSON = 6,\n        /**\n         * Used on extensions that doesn't define the ScriptKind but the content defines it.\n         * Deferred extensions are going to be included in all project contexts.\n         */\n        Deferred = 7,\n    }\n    enum ScriptTarget {\n        /** @deprecated */\n        ES3 = 0,\n        ES5 = 1,\n        ES2015 = 2,\n        ES2016 = 3,\n        ES2017 = 4,\n        ES2018 = 5,\n        ES2019 = 6,\n        ES2020 = 7,\n        ES2021 = 8,\n        ES2022 = 9,\n        ES2023 = 10,\n        ES2024 = 11,\n        ESNext = 99,\n        JSON = 100,\n        Latest = 99,\n    }\n    enum LanguageVariant {\n        Standard = 0,\n        JSX = 1,\n    }\n    /** Either a parsed command line or a parsed tsconfig.json */\n    interface ParsedCommandLine {\n        options: CompilerOptions;\n        typeAcquisition?: TypeAcquisition;\n        fileNames: string[];\n        projectReferences?: readonly ProjectReference[];\n        watchOptions?: WatchOptions;\n        raw?: any;\n        errors: Diagnostic[];\n        wildcardDirectories?: MapLike<WatchDirectoryFlags>;\n        compileOnSave?: boolean;\n    }\n    enum WatchDirectoryFlags {\n        None = 0,\n        Recursive = 1,\n    }\n    interface CreateProgramOptions {\n        rootNames: readonly string[];\n        options: CompilerOptions;\n        projectReferences?: readonly ProjectReference[];\n        host?: CompilerHost;\n        oldProgram?: Program;\n        configFileParsingDiagnostics?: readonly Diagnostic[];\n    }\n    interface ModuleResolutionHost {\n        fileExists(fileName: string): boolean;\n        readFile(fileName: string): string | undefined;\n        trace?(s: string): void;\n        directoryExists?(directoryName: string): boolean;\n        /**\n         * Resolve a symbolic link.\n         * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options\n         */\n        realpath?(path: string): string;\n        getCurrentDirectory?(): string;\n        getDirectories?(path: string): string[];\n        useCaseSensitiveFileNames?: boolean | (() => boolean) | undefined;\n    }\n    /**\n     * Used by services to specify the minimum host area required to set up source files under any compilation settings\n     */\n    interface MinimalResolutionCacheHost extends ModuleResolutionHost {\n        getCompilationSettings(): CompilerOptions;\n        getCompilerHost?(): CompilerHost | undefined;\n    }\n    /**\n     * Represents the result of module resolution.\n     * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.\n     * The Program will then filter results based on these flags.\n     *\n     * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.\n     */\n    interface ResolvedModule {\n        /** Path of the file the module was resolved to. */\n        resolvedFileName: string;\n        /** True if `resolvedFileName` comes from `node_modules`. */\n        isExternalLibraryImport?: boolean;\n        /**\n         * True if the original module reference used a .ts extension to refer directly to a .ts file,\n         * which should produce an error during checking if emit is enabled.\n         */\n        resolvedUsingTsExtension?: boolean;\n    }\n    /**\n     * ResolvedModule with an explicitly provided `extension` property.\n     * Prefer this over `ResolvedModule`.\n     * If changing this, remember to change `moduleResolutionIsEqualTo`.\n     */\n    interface ResolvedModuleFull extends ResolvedModule {\n        /**\n         * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.\n         * This is optional for backwards-compatibility, but will be added if not provided.\n         */\n        extension: string;\n        packageId?: PackageId;\n    }\n    /**\n     * Unique identifier with a package name and version.\n     * If changing this, remember to change `packageIdIsEqual`.\n     */\n    interface PackageId {\n        /**\n         * Name of the package.\n         * Should not include `@types`.\n         * If accessing a non-index file, this should include its name e.g. \"foo/bar\".\n         */\n        name: string;\n        /**\n         * Name of a submodule within this package.\n         * May be \"\".\n         */\n        subModuleName: string;\n        /** Version of the package, e.g. \"1.2.3\" */\n        version: string;\n    }\n    enum Extension {\n        Ts = \".ts\",\n        Tsx = \".tsx\",\n        Dts = \".d.ts\",\n        Js = \".js\",\n        Jsx = \".jsx\",\n        Json = \".json\",\n        TsBuildInfo = \".tsbuildinfo\",\n        Mjs = \".mjs\",\n        Mts = \".mts\",\n        Dmts = \".d.mts\",\n        Cjs = \".cjs\",\n        Cts = \".cts\",\n        Dcts = \".d.cts\",\n    }\n    interface ResolvedModuleWithFailedLookupLocations {\n        readonly resolvedModule: ResolvedModuleFull | undefined;\n    }\n    interface ResolvedTypeReferenceDirective {\n        primary: boolean;\n        resolvedFileName: string | undefined;\n        packageId?: PackageId;\n        /** True if `resolvedFileName` comes from `node_modules`. */\n        isExternalLibraryImport?: boolean;\n    }\n    interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {\n        readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;\n    }\n    interface CompilerHost extends ModuleResolutionHost {\n        getSourceFile(fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\n        getSourceFileByPath?(fileName: string, path: Path, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;\n        getCancellationToken?(): CancellationToken;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        getDefaultLibLocation?(): string;\n        writeFile: WriteFileCallback;\n        getCurrentDirectory(): string;\n        getCanonicalFileName(fileName: string): string;\n        useCaseSensitiveFileNames(): boolean;\n        getNewLine(): string;\n        readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];\n        /** @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];\n        /**\n         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it\n         */\n        getModuleResolutionCache?(): ModuleResolutionCache | undefined;\n        /**\n         * @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext\n         *\n         * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files\n         */\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];\n        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];\n        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];\n        getEnvironmentVariable?(name: string): string | undefined;\n        /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */\n        hasInvalidatedResolutions?(filePath: Path): boolean;\n        createHash?(data: string): string;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        jsDocParsingMode?: JSDocParsingMode;\n    }\n    interface SourceMapRange extends TextRange {\n        source?: SourceMapSource;\n    }\n    interface SourceMapSource {\n        fileName: string;\n        text: string;\n        skipTrivia?: (pos: number) => number;\n    }\n    interface SourceMapSource {\n        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;\n    }\n    enum EmitFlags {\n        None = 0,\n        SingleLine = 1,\n        MultiLine = 2,\n        AdviseOnEmitNode = 4,\n        NoSubstitution = 8,\n        CapturesThis = 16,\n        NoLeadingSourceMap = 32,\n        NoTrailingSourceMap = 64,\n        NoSourceMap = 96,\n        NoNestedSourceMaps = 128,\n        NoTokenLeadingSourceMaps = 256,\n        NoTokenTrailingSourceMaps = 512,\n        NoTokenSourceMaps = 768,\n        NoLeadingComments = 1024,\n        NoTrailingComments = 2048,\n        NoComments = 3072,\n        NoNestedComments = 4096,\n        HelperName = 8192,\n        ExportName = 16384,\n        LocalName = 32768,\n        InternalName = 65536,\n        Indented = 131072,\n        NoIndentation = 262144,\n        AsyncFunctionBody = 524288,\n        ReuseTempVariableScope = 1048576,\n        CustomPrologue = 2097152,\n        NoHoisting = 4194304,\n        Iterator = 8388608,\n        NoAsciiEscaping = 16777216,\n    }\n    interface EmitHelperBase {\n        readonly name: string;\n        readonly scoped: boolean;\n        readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);\n        readonly priority?: number;\n        readonly dependencies?: EmitHelper[];\n    }\n    interface ScopedEmitHelper extends EmitHelperBase {\n        readonly scoped: true;\n    }\n    interface UnscopedEmitHelper extends EmitHelperBase {\n        readonly scoped: false;\n        readonly text: string;\n    }\n    type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;\n    type EmitHelperUniqueNameCallback = (name: string) => string;\n    enum EmitHint {\n        SourceFile = 0,\n        Expression = 1,\n        IdentifierName = 2,\n        MappedTypeParameter = 3,\n        Unspecified = 4,\n        EmbeddedStatement = 5,\n        JsxAttributeValue = 6,\n        ImportTypeNodeAttributes = 7,\n    }\n    enum OuterExpressionKinds {\n        Parentheses = 1,\n        TypeAssertions = 2,\n        NonNullAssertions = 4,\n        PartiallyEmittedExpressions = 8,\n        ExpressionsWithTypeArguments = 16,\n        Satisfies = 32,\n        Assertions = 38,\n        All = 63,\n        ExcludeJSDocTypeAssertion = -2147483648,\n    }\n    type ImmediatelyInvokedFunctionExpression = CallExpression & {\n        readonly expression: FunctionExpression;\n    };\n    type ImmediatelyInvokedArrowFunction = CallExpression & {\n        readonly expression: ParenthesizedExpression & {\n            readonly expression: ArrowFunction;\n        };\n    };\n    interface NodeFactory {\n        createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;\n        createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;\n        createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;\n        createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;\n        createStringLiteralFromNode(sourceNode: PropertyNameLiteral | PrivateIdentifier, isSingleQuote?: boolean): StringLiteral;\n        createRegularExpressionLiteral(text: string): RegularExpressionLiteral;\n        createIdentifier(text: string): Identifier;\n        /**\n         * Create a unique temporary variable.\n         * @param recordTempVariable An optional callback used to record the temporary variable name. This\n         * should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but\n         * can be `undefined` if you plan to record the temporary variable manually.\n         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes\n         * during emit so that the variable can be referenced in a nested function body. This is an alternative to\n         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.\n         */\n        createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean): Identifier;\n        /**\n         * Create a unique temporary variable for use in a loop.\n         * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes\n         * during emit so that the variable can be referenced in a nested function body. This is an alternative to\n         * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.\n         */\n        createLoopVariable(reservedInNestedScopes?: boolean): Identifier;\n        /** Create a unique name based on the supplied text. */\n        createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;\n        /** Create a unique name generated for a node. */\n        getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;\n        createPrivateIdentifier(text: string): PrivateIdentifier;\n        createUniquePrivateName(text?: string): PrivateIdentifier;\n        getGeneratedPrivateNameForNode(node: Node): PrivateIdentifier;\n        createToken(token: SyntaxKind.SuperKeyword): SuperExpression;\n        createToken(token: SyntaxKind.ThisKeyword): ThisExpression;\n        createToken(token: SyntaxKind.NullKeyword): NullLiteral;\n        createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;\n        createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;\n        createToken(token: SyntaxKind.EndOfFileToken): EndOfFileToken;\n        createToken(token: SyntaxKind.Unknown): Token<SyntaxKind.Unknown>;\n        createToken<TKind extends PunctuationSyntaxKind>(token: TKind): PunctuationToken<TKind>;\n        createToken<TKind extends KeywordTypeSyntaxKind>(token: TKind): KeywordTypeNode<TKind>;\n        createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;\n        createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;\n        createSuper(): SuperExpression;\n        createThis(): ThisExpression;\n        createNull(): NullLiteral;\n        createTrue(): TrueLiteral;\n        createFalse(): FalseLiteral;\n        createModifier<T extends ModifierSyntaxKind>(kind: T): ModifierToken<T>;\n        createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;\n        createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;\n        updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;\n        createComputedPropertyName(expression: Expression): ComputedPropertyName;\n        updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;\n        createTypeParameterDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;\n        updateTypeParameterDeclaration(node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;\n        createParameterDeclaration(modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;\n        updateParameterDeclaration(node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;\n        createDecorator(expression: Expression): Decorator;\n        updateDecorator(node: Decorator, expression: Expression): Decorator;\n        createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;\n        updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;\n        createPropertyDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;\n        updatePropertyDeclaration(node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;\n        createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;\n        updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): MethodSignature;\n        createMethodDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;\n        updateMethodDeclaration(node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;\n        createConstructorDeclaration(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;\n        updateConstructorDeclaration(node: ConstructorDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;\n        createGetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;\n        updateGetAccessorDeclaration(node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;\n        createSetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;\n        updateSetAccessorDeclaration(node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;\n        createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;\n        updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;\n        createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;\n        updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;\n        createIndexSignature(modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;\n        updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly ModifierLike[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;\n        createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;\n        updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;\n        createClassStaticBlockDeclaration(body: Block): ClassStaticBlockDeclaration;\n        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, body: Block): ClassStaticBlockDeclaration;\n        createKeywordTypeNode<TKind extends KeywordTypeSyntaxKind>(kind: TKind): KeywordTypeNode<TKind>;\n        createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;\n        updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;\n        createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;\n        updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;\n        createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;\n        updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): FunctionTypeNode;\n        createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;\n        updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;\n        createTypeQueryNode(exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;\n        updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;\n        createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;\n        updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;\n        createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;\n        updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;\n        createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;\n        updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;\n        createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;\n        updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;\n        createOptionalTypeNode(type: TypeNode): OptionalTypeNode;\n        updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;\n        createRestTypeNode(type: TypeNode): RestTypeNode;\n        updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;\n        createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;\n        updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;\n        createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;\n        updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;\n        createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;\n        updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;\n        createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;\n        updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;\n        createImportTypeNode(argument: TypeNode, attributes?: ImportAttributes, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;\n        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, attributes: ImportAttributes | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;\n        createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;\n        updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;\n        createThisTypeNode(): ThisTypeNode;\n        createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;\n        updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;\n        createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;\n        updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;\n        createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;\n        updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;\n        createLiteralTypeNode(literal: LiteralTypeNode[\"literal\"]): LiteralTypeNode;\n        updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode[\"literal\"]): LiteralTypeNode;\n        createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;\n        updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;\n        createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;\n        updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;\n        createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;\n        updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;\n        createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;\n        updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;\n        createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;\n        updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;\n        createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;\n        updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;\n        createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;\n        updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;\n        createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;\n        updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;\n        createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;\n        updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;\n        createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;\n        updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;\n        createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;\n        updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;\n        createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;\n        updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;\n        createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;\n        updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;\n        createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n        updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;\n        createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;\n        updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;\n        createParenthesizedExpression(expression: Expression): ParenthesizedExpression;\n        updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;\n        createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;\n        updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;\n        createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;\n        updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;\n        createDeleteExpression(expression: Expression): DeleteExpression;\n        updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;\n        createTypeOfExpression(expression: Expression): TypeOfExpression;\n        updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;\n        createVoidExpression(expression: Expression): VoidExpression;\n        updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;\n        createAwaitExpression(expression: Expression): AwaitExpression;\n        updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;\n        createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;\n        updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;\n        createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;\n        updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;\n        createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;\n        updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;\n        createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;\n        updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;\n        createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;\n        updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;\n        createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;\n        createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;\n        createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;\n        createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;\n        createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;\n        createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;\n        createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;\n        createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;\n        createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;\n        createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;\n        updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;\n        createSpreadElement(expression: Expression): SpreadElement;\n        updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;\n        createClassExpression(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;\n        updateClassExpression(node: ClassExpression, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;\n        createOmittedExpression(): OmittedExpression;\n        createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;\n        updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;\n        createAsExpression(expression: Expression, type: TypeNode): AsExpression;\n        updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;\n        createNonNullExpression(expression: Expression): NonNullExpression;\n        updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;\n        createNonNullChain(expression: Expression): NonNullChain;\n        updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;\n        createMetaProperty(keywordToken: MetaProperty[\"keywordToken\"], name: Identifier): MetaProperty;\n        updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;\n        createSatisfiesExpression(expression: Expression, type: TypeNode): SatisfiesExpression;\n        updateSatisfiesExpression(node: SatisfiesExpression, expression: Expression, type: TypeNode): SatisfiesExpression;\n        createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;\n        updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;\n        createSemicolonClassElement(): SemicolonClassElement;\n        createBlock(statements: readonly Statement[], multiLine?: boolean): Block;\n        updateBlock(node: Block, statements: readonly Statement[]): Block;\n        createVariableStatement(modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;\n        updateVariableStatement(node: VariableStatement, modifiers: readonly ModifierLike[] | undefined, declarationList: VariableDeclarationList): VariableStatement;\n        createEmptyStatement(): EmptyStatement;\n        createExpressionStatement(expression: Expression): ExpressionStatement;\n        updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;\n        createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;\n        updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;\n        createDoStatement(statement: Statement, expression: Expression): DoStatement;\n        updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;\n        createWhileStatement(expression: Expression, statement: Statement): WhileStatement;\n        updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;\n        createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;\n        updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;\n        createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;\n        updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;\n        createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;\n        updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;\n        createContinueStatement(label?: string | Identifier): ContinueStatement;\n        updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;\n        createBreakStatement(label?: string | Identifier): BreakStatement;\n        updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;\n        createReturnStatement(expression?: Expression): ReturnStatement;\n        updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;\n        createWithStatement(expression: Expression, statement: Statement): WithStatement;\n        updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;\n        createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;\n        updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;\n        createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;\n        updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;\n        createThrowStatement(expression: Expression): ThrowStatement;\n        updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;\n        createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;\n        updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;\n        createDebuggerStatement(): DebuggerStatement;\n        createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;\n        updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;\n        createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;\n        updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;\n        createFunctionDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;\n        updateFunctionDeclaration(node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;\n        createClassDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;\n        updateClassDeclaration(node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;\n        createInterfaceDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;\n        updateInterfaceDeclaration(node: InterfaceDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;\n        createTypeAliasDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;\n        updateTypeAliasDeclaration(node: TypeAliasDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;\n        createEnumDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;\n        updateEnumDeclaration(node: EnumDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;\n        createModuleDeclaration(modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;\n        updateModuleDeclaration(node: ModuleDeclaration, modifiers: readonly ModifierLike[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;\n        createModuleBlock(statements: readonly Statement[]): ModuleBlock;\n        updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;\n        createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;\n        updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;\n        createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;\n        updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;\n        createImportEqualsDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;\n        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;\n        createImportDeclaration(modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes?: ImportAttributes): ImportDeclaration;\n        updateImportDeclaration(node: ImportDeclaration, modifiers: readonly ModifierLike[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes: ImportAttributes | undefined): ImportDeclaration;\n        createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;\n        updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;\n        /** @deprecated */ createAssertClause(elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;\n        /** @deprecated */ updateAssertClause(node: AssertClause, elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;\n        /** @deprecated */ createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;\n        /** @deprecated */ updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;\n        /** @deprecated */ createImportTypeAssertionContainer(clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;\n        /** @deprecated */ updateImportTypeAssertionContainer(node: ImportTypeAssertionContainer, clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;\n        createImportAttributes(elements: NodeArray<ImportAttribute>, multiLine?: boolean): ImportAttributes;\n        updateImportAttributes(node: ImportAttributes, elements: NodeArray<ImportAttribute>, multiLine?: boolean): ImportAttributes;\n        createImportAttribute(name: ImportAttributeName, value: Expression): ImportAttribute;\n        updateImportAttribute(node: ImportAttribute, name: ImportAttributeName, value: Expression): ImportAttribute;\n        createNamespaceImport(name: Identifier): NamespaceImport;\n        updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;\n        createNamespaceExport(name: ModuleExportName): NamespaceExport;\n        updateNamespaceExport(node: NamespaceExport, name: ModuleExportName): NamespaceExport;\n        createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;\n        updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;\n        createImportSpecifier(isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: Identifier): ImportSpecifier;\n        updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: Identifier): ImportSpecifier;\n        createExportAssignment(modifiers: readonly ModifierLike[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;\n        updateExportAssignment(node: ExportAssignment, modifiers: readonly ModifierLike[] | undefined, expression: Expression): ExportAssignment;\n        createExportDeclaration(modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, attributes?: ImportAttributes): ExportDeclaration;\n        updateExportDeclaration(node: ExportDeclaration, modifiers: readonly ModifierLike[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, attributes: ImportAttributes | undefined): ExportDeclaration;\n        createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;\n        updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;\n        createExportSpecifier(isTypeOnly: boolean, propertyName: string | ModuleExportName | undefined, name: string | ModuleExportName): ExportSpecifier;\n        updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: ModuleExportName | undefined, name: ModuleExportName): ExportSpecifier;\n        createExternalModuleReference(expression: Expression): ExternalModuleReference;\n        updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;\n        createJSDocAllType(): JSDocAllType;\n        createJSDocUnknownType(): JSDocUnknownType;\n        createJSDocNonNullableType(type: TypeNode, postfix?: boolean): JSDocNonNullableType;\n        updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;\n        createJSDocNullableType(type: TypeNode, postfix?: boolean): JSDocNullableType;\n        updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;\n        createJSDocOptionalType(type: TypeNode): JSDocOptionalType;\n        updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;\n        createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;\n        updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;\n        createJSDocVariadicType(type: TypeNode): JSDocVariadicType;\n        updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;\n        createJSDocNamepathType(type: TypeNode): JSDocNamepathType;\n        updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;\n        createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;\n        updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;\n        createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;\n        updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;\n        createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;\n        updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;\n        createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;\n        updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;\n        createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;\n        updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;\n        createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;\n        updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;\n        createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;\n        updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;\n        createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;\n        updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;\n        createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment>): JSDocTemplateTag;\n        updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray<JSDocComment> | undefined): JSDocTemplateTag;\n        createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocTypedefTag;\n        updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypedefTag;\n        createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocParameterTag;\n        updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocParameterTag;\n        createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocPropertyTag;\n        updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocPropertyTag;\n        createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocTypeTag;\n        updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypeTag;\n        createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;\n        updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;\n        createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocReturnTag;\n        updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReturnTag;\n        createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocThisTag;\n        updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocThisTag;\n        createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocEnumTag;\n        updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocEnumTag;\n        createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocCallbackTag;\n        updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocCallbackTag;\n        createJSDocOverloadTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, comment?: string | NodeArray<JSDocComment>): JSDocOverloadTag;\n        updateJSDocOverloadTag(node: JSDocOverloadTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, comment: string | NodeArray<JSDocComment> | undefined): JSDocOverloadTag;\n        createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag[\"class\"], comment?: string | NodeArray<JSDocComment>): JSDocAugmentsTag;\n        updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag[\"class\"], comment: string | NodeArray<JSDocComment> | undefined): JSDocAugmentsTag;\n        createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag[\"class\"], comment?: string | NodeArray<JSDocComment>): JSDocImplementsTag;\n        updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag[\"class\"], comment: string | NodeArray<JSDocComment> | undefined): JSDocImplementsTag;\n        createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocAuthorTag;\n        updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocAuthorTag;\n        createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocClassTag;\n        updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocClassTag;\n        createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPublicTag;\n        updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPublicTag;\n        createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPrivateTag;\n        updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPrivateTag;\n        createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocProtectedTag;\n        updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocProtectedTag;\n        createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocReadonlyTag;\n        updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReadonlyTag;\n        createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocUnknownTag;\n        updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray<JSDocComment> | undefined): JSDocUnknownTag;\n        createJSDocDeprecatedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;\n        updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;\n        createJSDocOverrideTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;\n        updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;\n        createJSDocThrowsTag(tagName: Identifier, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment>): JSDocThrowsTag;\n        updateJSDocThrowsTag(node: JSDocThrowsTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined): JSDocThrowsTag;\n        createJSDocSatisfiesTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocSatisfiesTag;\n        updateJSDocSatisfiesTag(node: JSDocSatisfiesTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocSatisfiesTag;\n        createJSDocImportTag(tagName: Identifier | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes?: ImportAttributes, comment?: string | NodeArray<JSDocComment>): JSDocImportTag;\n        updateJSDocImportTag(node: JSDocImportTag, tagName: Identifier | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, attributes: ImportAttributes | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocImportTag;\n        createJSDocText(text: string): JSDocText;\n        updateJSDocText(node: JSDocText, text: string): JSDocText;\n        createJSDocComment(comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;\n        updateJSDocComment(node: JSDoc, comment: string | NodeArray<JSDocComment> | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;\n        createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;\n        updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;\n        createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;\n        updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;\n        createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;\n        updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;\n        createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;\n        updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;\n        createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;\n        createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;\n        updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;\n        createJsxOpeningFragment(): JsxOpeningFragment;\n        createJsxJsxClosingFragment(): JsxClosingFragment;\n        updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;\n        createJsxAttribute(name: JsxAttributeName, initializer: JsxAttributeValue | undefined): JsxAttribute;\n        updateJsxAttribute(node: JsxAttribute, name: JsxAttributeName, initializer: JsxAttributeValue | undefined): JsxAttribute;\n        createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;\n        updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;\n        createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;\n        updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;\n        createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;\n        updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;\n        createJsxNamespacedName(namespace: Identifier, name: Identifier): JsxNamespacedName;\n        updateJsxNamespacedName(node: JsxNamespacedName, namespace: Identifier, name: Identifier): JsxNamespacedName;\n        createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;\n        updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;\n        createDefaultClause(statements: readonly Statement[]): DefaultClause;\n        updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;\n        createHeritageClause(token: HeritageClause[\"token\"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;\n        updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;\n        createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;\n        updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;\n        createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;\n        updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;\n        createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;\n        updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;\n        createSpreadAssignment(expression: Expression): SpreadAssignment;\n        updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;\n        createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;\n        updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;\n        createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;\n        updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;\n        createNotEmittedStatement(original: Node): NotEmittedStatement;\n        createNotEmittedTypeElement(): NotEmittedTypeElement;\n        createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;\n        updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;\n        createCommaListExpression(elements: readonly Expression[]): CommaListExpression;\n        updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;\n        createBundle(sourceFiles: readonly SourceFile[]): Bundle;\n        updateBundle(node: Bundle, sourceFiles: readonly SourceFile[]): Bundle;\n        createComma(left: Expression, right: Expression): BinaryExpression;\n        createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;\n        createAssignment(left: Expression, right: Expression): AssignmentExpression<EqualsToken>;\n        createLogicalOr(left: Expression, right: Expression): BinaryExpression;\n        createLogicalAnd(left: Expression, right: Expression): BinaryExpression;\n        createBitwiseOr(left: Expression, right: Expression): BinaryExpression;\n        createBitwiseXor(left: Expression, right: Expression): BinaryExpression;\n        createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;\n        createStrictEquality(left: Expression, right: Expression): BinaryExpression;\n        createStrictInequality(left: Expression, right: Expression): BinaryExpression;\n        createEquality(left: Expression, right: Expression): BinaryExpression;\n        createInequality(left: Expression, right: Expression): BinaryExpression;\n        createLessThan(left: Expression, right: Expression): BinaryExpression;\n        createLessThanEquals(left: Expression, right: Expression): BinaryExpression;\n        createGreaterThan(left: Expression, right: Expression): BinaryExpression;\n        createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;\n        createLeftShift(left: Expression, right: Expression): BinaryExpression;\n        createRightShift(left: Expression, right: Expression): BinaryExpression;\n        createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;\n        createAdd(left: Expression, right: Expression): BinaryExpression;\n        createSubtract(left: Expression, right: Expression): BinaryExpression;\n        createMultiply(left: Expression, right: Expression): BinaryExpression;\n        createDivide(left: Expression, right: Expression): BinaryExpression;\n        createModulo(left: Expression, right: Expression): BinaryExpression;\n        createExponent(left: Expression, right: Expression): BinaryExpression;\n        createPrefixPlus(operand: Expression): PrefixUnaryExpression;\n        createPrefixMinus(operand: Expression): PrefixUnaryExpression;\n        createPrefixIncrement(operand: Expression): PrefixUnaryExpression;\n        createPrefixDecrement(operand: Expression): PrefixUnaryExpression;\n        createBitwiseNot(operand: Expression): PrefixUnaryExpression;\n        createLogicalNot(operand: Expression): PrefixUnaryExpression;\n        createPostfixIncrement(operand: Expression): PostfixUnaryExpression;\n        createPostfixDecrement(operand: Expression): PostfixUnaryExpression;\n        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;\n        createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;\n        createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): ImmediatelyInvokedArrowFunction;\n        createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): ImmediatelyInvokedArrowFunction;\n        createVoidZero(): VoidExpression;\n        createExportDefault(expression: Expression): ExportAssignment;\n        createExternalModuleExport(exportName: Identifier): ExportDeclaration;\n        restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;\n        /**\n         * Updates a node that may contain modifiers, replacing only the modifiers of the node.\n         */\n        replaceModifiers<T extends HasModifiers>(node: T, modifiers: readonly Modifier[] | ModifierFlags | undefined): T;\n        /**\n         * Updates a node that may contain decorators or modifiers, replacing only the decorators and modifiers of the node.\n         */\n        replaceDecoratorsAndModifiers<T extends HasModifiers & HasDecorators>(node: T, modifiers: readonly ModifierLike[] | undefined): T;\n        /**\n         * Updates a node that contains a property name, replacing only the name of the node.\n         */\n        replacePropertyName<T extends AccessorDeclaration | MethodDeclaration | MethodSignature | PropertyDeclaration | PropertySignature | PropertyAssignment>(node: T, name: T[\"name\"]): T;\n    }\n    interface CoreTransformationContext {\n        readonly factory: NodeFactory;\n        /** Gets the compiler options supplied to the transformer. */\n        getCompilerOptions(): CompilerOptions;\n        /** Starts a new lexical environment. */\n        startLexicalEnvironment(): void;\n        /** Suspends the current lexical environment, usually after visiting a parameter list. */\n        suspendLexicalEnvironment(): void;\n        /** Resumes a suspended lexical environment, usually before visiting a function body. */\n        resumeLexicalEnvironment(): void;\n        /** Ends a lexical environment, returning any declarations. */\n        endLexicalEnvironment(): Statement[] | undefined;\n        /** Hoists a function declaration to the containing scope. */\n        hoistFunctionDeclaration(node: FunctionDeclaration): void;\n        /** Hoists a variable declaration to the containing scope. */\n        hoistVariableDeclaration(node: Identifier): void;\n    }\n    interface TransformationContext extends CoreTransformationContext {\n        /** Records a request for a non-scoped emit helper in the current context. */\n        requestEmitHelper(helper: EmitHelper): void;\n        /** Gets and resets the requested non-scoped emit helpers. */\n        readEmitHelpers(): EmitHelper[] | undefined;\n        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */\n        enableSubstitution(kind: SyntaxKind): void;\n        /** Determines whether expression substitutions are enabled for the provided node. */\n        isSubstitutionEnabled(node: Node): boolean;\n        /**\n         * Hook used by transformers to substitute expressions just before they\n         * are emitted by the pretty printer.\n         *\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\n         * before returning the `NodeTransformer` callback.\n         */\n        onSubstituteNode: (hint: EmitHint, node: Node) => Node;\n        /**\n         * Enables before/after emit notifications in the pretty printer for the provided\n         * SyntaxKind.\n         */\n        enableEmitNotification(kind: SyntaxKind): void;\n        /**\n         * Determines whether before/after emit notifications should be raised in the pretty\n         * printer when it emits a node.\n         */\n        isEmitNotificationEnabled(node: Node): boolean;\n        /**\n         * Hook used to allow transformers to capture state before or after\n         * the printer emits a node.\n         *\n         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,\n         * before returning the `NodeTransformer` callback.\n         */\n        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;\n    }\n    interface TransformationResult<T extends Node> {\n        /** Gets the transformed source files. */\n        transformed: T[];\n        /** Gets diagnostics for the transformation. */\n        diagnostics?: DiagnosticWithLocation[];\n        /**\n         * Gets a substitute for a node, if one is available; otherwise, returns the original node.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to substitute.\n         */\n        substituteNode(hint: EmitHint, node: Node): Node;\n        /**\n         * Emits a node with possible notification.\n         *\n         * @param hint A hint as to the intended usage of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback used to emit the node.\n         */\n        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\n        /**\n         * Indicates if a given node needs an emit notification\n         *\n         * @param node The node to emit.\n         */\n        isEmitNotificationEnabled?(node: Node): boolean;\n        /**\n         * Clean up EmitNode entries on any parse-tree nodes.\n         */\n        dispose(): void;\n    }\n    /**\n     * A function that is used to initialize and return a `Transformer` callback, which in turn\n     * will be used to transform one or more nodes.\n     */\n    type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;\n    /**\n     * A function that transforms a node.\n     */\n    type Transformer<T extends Node> = (node: T) => T;\n    /**\n     * A function that accepts and possibly transforms a node.\n     */\n    type Visitor<TIn extends Node = Node, TOut extends Node | undefined = TIn | undefined> = (node: TIn) => VisitResult<TOut>;\n    /**\n     * A function that walks a node using the given visitor, lifting node arrays into single nodes,\n     * returning an node which satisfies the test.\n     *\n     * - If the input node is undefined, then the output is undefined.\n     * - If the visitor returns undefined, then the output is undefined.\n     * - If the output node is not undefined, then it will satisfy the test function.\n     * - In order to obtain a return type that is more specific than `Node`, a test\n     *   function _must_ be provided, and that function must be a type predicate.\n     *\n     * For the canonical implementation of this type, @see {visitNode}.\n     */\n    interface NodeVisitor {\n        <TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);\n        <TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);\n    }\n    /**\n     * A function that walks a node array using the given visitor, returning an array whose contents satisfy the test.\n     *\n     * - If the input node array is undefined, the output is undefined.\n     * - If the visitor can return undefined, the node it visits in the array will be reused.\n     * - If the output node array is not undefined, then its contents will satisfy the test.\n     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test\n     *   function _must_ be provided, and that function must be a type predicate.\n     *\n     * For the canonical implementation of this type, @see {visitNodes}.\n     */\n    interface NodesVisitor {\n        <TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);\n        <TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);\n    }\n    type VisitResult<T extends Node | undefined> = T | readonly Node[];\n    interface Printer {\n        /**\n         * Print a node and its subtree as-is, without any emit transformations.\n         * @param hint A value indicating the purpose of a node. This is primarily used to\n         * distinguish between an `Identifier` used in an expression position, versus an\n         * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you\n         * should just pass `Unspecified`.\n         * @param node The node to print. The node and its subtree are printed as-is, without any\n         * emit transformations.\n         * @param sourceFile A source file that provides context for the node. The source text of\n         * the file is used to emit the original source content for literals and identifiers, while\n         * the identifiers of the source file are used when generating unique names to avoid\n         * collisions.\n         */\n        printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;\n        /**\n         * Prints a list of nodes using the given format flags\n         */\n        printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;\n        /**\n         * Prints a source file as-is, without any emit transformations.\n         */\n        printFile(sourceFile: SourceFile): string;\n        /**\n         * Prints a bundle of source files as-is, without any emit transformations.\n         */\n        printBundle(bundle: Bundle): string;\n    }\n    interface PrintHandlers {\n        /**\n         * A hook used by the Printer when generating unique names to avoid collisions with\n         * globally defined names that exist outside of the current source file.\n         */\n        hasGlobalName?(name: string): boolean;\n        /**\n         * A hook used by the Printer to provide notifications prior to emitting a node. A\n         * compatible implementation **must** invoke `emitCallback` with the provided `hint` and\n         * `node` values.\n         * @param hint A hint indicating the intended purpose of the node.\n         * @param node The node to emit.\n         * @param emitCallback A callback that, when invoked, will emit the node.\n         * @example\n         * ```ts\n         * var printer = createPrinter(printerOptions, {\n         *   onEmitNode(hint, node, emitCallback) {\n         *     // set up or track state prior to emitting the node...\n         *     emitCallback(hint, node);\n         *     // restore state after emitting the node...\n         *   }\n         * });\n         * ```\n         */\n        onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;\n        /**\n         * A hook used to check if an emit notification is required for a node.\n         * @param node The node to emit.\n         */\n        isEmitNotificationEnabled?(node: Node): boolean;\n        /**\n         * A hook used by the Printer to perform just-in-time substitution of a node. This is\n         * primarily used by node transformations that need to substitute one node for another,\n         * such as replacing `myExportedVar` with `exports.myExportedVar`.\n         * @param hint A hint indicating the intended purpose of the node.\n         * @param node The node to emit.\n         * @example\n         * ```ts\n         * var printer = createPrinter(printerOptions, {\n         *   substituteNode(hint, node) {\n         *     // perform substitution if necessary...\n         *     return node;\n         *   }\n         * });\n         * ```\n         */\n        substituteNode?(hint: EmitHint, node: Node): Node;\n    }\n    interface PrinterOptions {\n        removeComments?: boolean;\n        newLine?: NewLineKind;\n        omitTrailingSemicolon?: boolean;\n        noEmitHelpers?: boolean;\n    }\n    interface GetEffectiveTypeRootsHost {\n        getCurrentDirectory?(): string;\n    }\n    interface TextSpan {\n        start: number;\n        length: number;\n    }\n    interface TextChangeRange {\n        span: TextSpan;\n        newLength: number;\n    }\n    interface SyntaxList extends Node {\n        kind: SyntaxKind.SyntaxList;\n    }\n    enum ListFormat {\n        None = 0,\n        SingleLine = 0,\n        MultiLine = 1,\n        PreserveLines = 2,\n        LinesMask = 3,\n        NotDelimited = 0,\n        BarDelimited = 4,\n        AmpersandDelimited = 8,\n        CommaDelimited = 16,\n        AsteriskDelimited = 32,\n        DelimitersMask = 60,\n        AllowTrailingComma = 64,\n        Indented = 128,\n        SpaceBetweenBraces = 256,\n        SpaceBetweenSiblings = 512,\n        Braces = 1024,\n        Parenthesis = 2048,\n        AngleBrackets = 4096,\n        SquareBrackets = 8192,\n        BracketsMask = 15360,\n        OptionalIfUndefined = 16384,\n        OptionalIfEmpty = 32768,\n        Optional = 49152,\n        PreferNewLine = 65536,\n        NoTrailingNewLine = 131072,\n        NoInterveningComments = 262144,\n        NoSpaceIfEmpty = 524288,\n        SingleElement = 1048576,\n        SpaceAfterList = 2097152,\n        Modifiers = 2359808,\n        HeritageClauses = 512,\n        SingleLineTypeLiteralMembers = 768,\n        MultiLineTypeLiteralMembers = 32897,\n        SingleLineTupleTypeElements = 528,\n        MultiLineTupleTypeElements = 657,\n        UnionTypeConstituents = 516,\n        IntersectionTypeConstituents = 520,\n        ObjectBindingPatternElements = 525136,\n        ArrayBindingPatternElements = 524880,\n        ObjectLiteralExpressionProperties = 526226,\n        ImportAttributes = 526226,\n        /** @deprecated */ ImportClauseEntries = 526226,\n        ArrayLiteralExpressionElements = 8914,\n        CommaListElements = 528,\n        CallExpressionArguments = 2576,\n        NewExpressionArguments = 18960,\n        TemplateExpressionSpans = 262144,\n        SingleLineBlockStatements = 768,\n        MultiLineBlockStatements = 129,\n        VariableDeclarationList = 528,\n        SingleLineFunctionBodyStatements = 768,\n        MultiLineFunctionBodyStatements = 1,\n        ClassHeritageClauses = 0,\n        ClassMembers = 129,\n        InterfaceMembers = 129,\n        EnumMembers = 145,\n        CaseBlockClauses = 129,\n        NamedImportsOrExportsElements = 525136,\n        JsxElementOrFragmentChildren = 262144,\n        JsxElementAttributes = 262656,\n        CaseOrDefaultClauseStatements = 163969,\n        HeritageClauseTypes = 528,\n        SourceFileStatements = 131073,\n        Decorators = 2146305,\n        TypeArguments = 53776,\n        TypeParameters = 53776,\n        Parameters = 2576,\n        IndexSignatureParameters = 8848,\n        JSDocComment = 33,\n    }\n    enum JSDocParsingMode {\n        /**\n         * Always parse JSDoc comments and include them in the AST.\n         *\n         * This is the default if no mode is provided.\n         */\n        ParseAll = 0,\n        /**\n         * Never parse JSDoc comments, mo matter the file type.\n         */\n        ParseNone = 1,\n        /**\n         * Parse only JSDoc comments which are needed to provide correct type errors.\n         *\n         * This will always parse JSDoc in non-TS files, but only parse JSDoc comments\n         * containing `@see` and `@link` in TS files.\n         */\n        ParseForTypeErrors = 2,\n        /**\n         * Parse only JSDoc comments which are needed to provide correct type info.\n         *\n         * This will always parse JSDoc in non-TS files, but never in TS files.\n         *\n         * Note: Do not use this mode if you require accurate type errors; use {@link ParseForTypeErrors} instead.\n         */\n        ParseForTypeInfo = 3,\n    }\n    interface UserPreferences {\n        readonly disableSuggestions?: boolean;\n        readonly quotePreference?: \"auto\" | \"double\" | \"single\";\n        /**\n         * If enabled, TypeScript will search through all external modules' exports and add them to the completions list.\n         * This affects lone identifier completions but not completions on the right hand side of `obj.`.\n         */\n        readonly includeCompletionsForModuleExports?: boolean;\n        /**\n         * Enables auto-import-style completions on partially-typed import statements. E.g., allows\n         * `import write|` to be completed to `import { writeFile } from \"fs\"`.\n         */\n        readonly includeCompletionsForImportStatements?: boolean;\n        /**\n         * Allows completions to be formatted with snippet text, indicated by `CompletionItem[\"isSnippet\"]`.\n         */\n        readonly includeCompletionsWithSnippetText?: boolean;\n        /**\n         * Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,\n         * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined\n         * values, with insertion text to replace preceding `.` tokens with `?.`.\n         */\n        readonly includeAutomaticOptionalChainCompletions?: boolean;\n        /**\n         * If enabled, the completion list will include completions with invalid identifier names.\n         * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `[\"x\"]`.\n         */\n        readonly includeCompletionsWithInsertText?: boolean;\n        /**\n         * If enabled, completions for class members (e.g. methods and properties) will include\n         * a whole declaration for the member.\n         * E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of\n         * `class A { foo }`.\n         */\n        readonly includeCompletionsWithClassMemberSnippets?: boolean;\n        /**\n         * If enabled, object literal methods will have a method declaration completion entry in addition\n         * to the regular completion entry containing just the method name.\n         * E.g., `const objectLiteral: T = { f| }` could be completed to `const objectLiteral: T = { foo(): void {} }`,\n         * in addition to `const objectLiteral: T = { foo }`.\n         */\n        readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;\n        /**\n         * Indicates whether {@link CompletionEntry.labelDetails completion entry label details} are supported.\n         * If not, contents of `labelDetails` may be included in the {@link CompletionEntry.name} property.\n         */\n        readonly useLabelDetailsInCompletionEntries?: boolean;\n        readonly allowIncompleteCompletions?: boolean;\n        readonly importModuleSpecifierPreference?: \"shortest\" | \"project-relative\" | \"relative\" | \"non-relative\";\n        /** Determines whether we import `foo/index.ts` as \"foo\", \"foo/index\", or \"foo/index.js\" */\n        readonly importModuleSpecifierEnding?: \"auto\" | \"minimal\" | \"index\" | \"js\";\n        readonly allowTextChangesInNewFiles?: boolean;\n        readonly providePrefixAndSuffixTextForRename?: boolean;\n        readonly includePackageJsonAutoImports?: \"auto\" | \"on\" | \"off\";\n        readonly provideRefactorNotApplicableReason?: boolean;\n        readonly jsxAttributeCompletionStyle?: \"auto\" | \"braces\" | \"none\";\n        readonly includeInlayParameterNameHints?: \"none\" | \"literals\" | \"all\";\n        readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;\n        readonly includeInlayFunctionParameterTypeHints?: boolean;\n        readonly includeInlayVariableTypeHints?: boolean;\n        readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;\n        readonly includeInlayPropertyDeclarationTypeHints?: boolean;\n        readonly includeInlayFunctionLikeReturnTypeHints?: boolean;\n        readonly includeInlayEnumMemberValueHints?: boolean;\n        readonly interactiveInlayHints?: boolean;\n        readonly allowRenameOfImportPath?: boolean;\n        readonly autoImportFileExcludePatterns?: string[];\n        readonly autoImportSpecifierExcludeRegexes?: string[];\n        readonly preferTypeOnlyAutoImports?: boolean;\n        /**\n         * Indicates whether imports should be organized in a case-insensitive manner.\n         */\n        readonly organizeImportsIgnoreCase?: \"auto\" | boolean;\n        /**\n         * Indicates whether imports should be organized via an \"ordinal\" (binary) comparison using the numeric value\n         * of their code points, or via \"unicode\" collation (via the\n         * [Unicode Collation Algorithm](https://unicode.org/reports/tr10/#Scope)) using rules associated with the locale\n         * specified in {@link organizeImportsCollationLocale}.\n         *\n         * Default: `\"ordinal\"`.\n         */\n        readonly organizeImportsCollation?: \"ordinal\" | \"unicode\";\n        /**\n         * Indicates the locale to use for \"unicode\" collation. If not specified, the locale `\"en\"` is used as an invariant\n         * for the sake of consistent sorting. Use `\"auto\"` to use the detected UI locale.\n         *\n         * This preference is ignored if {@link organizeImportsCollation} is not `\"unicode\"`.\n         *\n         * Default: `\"en\"`\n         */\n        readonly organizeImportsLocale?: string;\n        /**\n         * Indicates whether numeric collation should be used for digit sequences in strings. When `true`, will collate\n         * strings such that `a1z < a2z < a100z`. When `false`, will collate strings such that `a1z < a100z < a2z`.\n         *\n         * This preference is ignored if {@link organizeImportsCollation} is not `\"unicode\"`.\n         *\n         * Default: `false`\n         */\n        readonly organizeImportsNumericCollation?: boolean;\n        /**\n         * Indicates whether accents and other diacritic marks are considered unequal for the purpose of collation. When\n         * `true`, characters with accents and other diacritics will be collated in the order defined by the locale specified\n         * in {@link organizeImportsCollationLocale}.\n         *\n         * This preference is ignored if {@link organizeImportsCollation} is not `\"unicode\"`.\n         *\n         * Default: `true`\n         */\n        readonly organizeImportsAccentCollation?: boolean;\n        /**\n         * Indicates whether upper case or lower case should sort first. When `false`, the default order for the locale\n         * specified in {@link organizeImportsCollationLocale} is used.\n         *\n         * This preference is ignored if {@link organizeImportsCollation} is not `\"unicode\"`. This preference is also\n         * ignored if we are using case-insensitive sorting, which occurs when {@link organizeImportsIgnoreCase} is `true`,\n         * or if {@link organizeImportsIgnoreCase} is `\"auto\"` and the auto-detected case sensitivity is determined to be\n         * case-insensitive.\n         *\n         * Default: `false`\n         */\n        readonly organizeImportsCaseFirst?: \"upper\" | \"lower\" | false;\n        /**\n         * Indicates where named type-only imports should sort. \"inline\" sorts named imports without regard to if the import is\n         * type-only.\n         *\n         * Default: `last`\n         */\n        readonly organizeImportsTypeOrder?: OrganizeImportsTypeOrder;\n        /**\n         * Indicates whether to exclude standard library and node_modules file symbols from navTo results.\n         */\n        readonly excludeLibrarySymbolsInNavTo?: boolean;\n        readonly lazyConfiguredProjectsFromExternalProject?: boolean;\n        readonly displayPartsForJSDoc?: boolean;\n        readonly generateReturnInDocTemplate?: boolean;\n        readonly disableLineTextInReferences?: boolean;\n    }\n    type OrganizeImportsTypeOrder = \"last\" | \"inline\" | \"first\";\n    /** Represents a bigint literal value without requiring bigint support */\n    interface PseudoBigInt {\n        negative: boolean;\n        base10Value: string;\n    }\n    enum FileWatcherEventKind {\n        Created = 0,\n        Changed = 1,\n        Deleted = 2,\n    }\n    type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) => void;\n    type DirectoryWatcherCallback = (fileName: string) => void;\n    type BufferEncoding = \"ascii\" | \"utf8\" | \"utf-8\" | \"utf16le\" | \"ucs2\" | \"ucs-2\" | \"base64\" | \"latin1\" | \"binary\" | \"hex\";\n    interface System {\n        args: string[];\n        newLine: string;\n        useCaseSensitiveFileNames: boolean;\n        write(s: string): void;\n        writeOutputIsTTY?(): boolean;\n        getWidthOfTerminal?(): number;\n        readFile(path: string, encoding?: string): string | undefined;\n        getFileSize?(path: string): number;\n        writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;\n        /**\n         * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that\n         * use native OS file watching\n         */\n        watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;\n        watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;\n        resolvePath(path: string): string;\n        fileExists(path: string): boolean;\n        directoryExists(path: string): boolean;\n        createDirectory(path: string): void;\n        getExecutingFilePath(): string;\n        getCurrentDirectory(): string;\n        getDirectories(path: string): string[];\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        getModifiedTime?(path: string): Date | undefined;\n        setModifiedTime?(path: string, time: Date): void;\n        deleteFile?(path: string): void;\n        /**\n         * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)\n         */\n        createHash?(data: string): string;\n        /** This must be cryptographically secure. Only implement this method using `crypto.createHash(\"sha256\")`. */\n        createSHA256Hash?(data: string): string;\n        getMemoryUsage?(): number;\n        exit(exitCode?: number): void;\n        realpath?(path: string): string;\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        clearTimeout?(timeoutId: any): void;\n        clearScreen?(): void;\n        base64decode?(input: string): string;\n        base64encode?(input: string): string;\n    }\n    interface FileWatcher {\n        close(): void;\n    }\n    let sys: System;\n    function tokenToString(t: SyntaxKind): string | undefined;\n    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;\n    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;\n    function isWhiteSpaceLike(ch: number): boolean;\n    /** Does not include line breaks. For that, see isWhiteSpaceLike. */\n    function isWhiteSpaceSingleLine(ch: number): boolean;\n    function isLineBreak(ch: number): boolean;\n    function couldStartTrivia(text: string, pos: number): boolean;\n    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\n    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\n    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;\n    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;\n    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;\n    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T, initial: U): U | undefined;\n    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;\n    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;\n    /** Optionally, get the shebang */\n    function getShebang(text: string): string | undefined;\n    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;\n    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;\n    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;\n    type ErrorCallback = (message: DiagnosticMessage, length: number, arg0?: any) => void;\n    interface Scanner {\n        /** @deprecated use {@link getTokenFullStart} */\n        getStartPos(): number;\n        getToken(): SyntaxKind;\n        getTokenFullStart(): number;\n        getTokenStart(): number;\n        getTokenEnd(): number;\n        /** @deprecated use {@link getTokenEnd} */\n        getTextPos(): number;\n        /** @deprecated use {@link getTokenStart} */\n        getTokenPos(): number;\n        getTokenText(): string;\n        getTokenValue(): string;\n        hasUnicodeEscape(): boolean;\n        hasExtendedUnicodeEscape(): boolean;\n        hasPrecedingLineBreak(): boolean;\n        isIdentifier(): boolean;\n        isReservedWord(): boolean;\n        isUnterminated(): boolean;\n        reScanGreaterToken(): SyntaxKind;\n        reScanSlashToken(): SyntaxKind;\n        reScanAsteriskEqualsToken(): SyntaxKind;\n        reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;\n        /** @deprecated use {@link reScanTemplateToken}(false) */\n        reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;\n        scanJsxIdentifier(): SyntaxKind;\n        scanJsxAttributeValue(): SyntaxKind;\n        reScanJsxAttributeValue(): SyntaxKind;\n        reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;\n        reScanLessThanToken(): SyntaxKind;\n        reScanHashToken(): SyntaxKind;\n        reScanQuestionToken(): SyntaxKind;\n        reScanInvalidIdentifier(): SyntaxKind;\n        scanJsxToken(): JsxTokenSyntaxKind;\n        scanJsDocToken(): JSDocSyntaxKind;\n        scan(): SyntaxKind;\n        getText(): string;\n        setText(text: string | undefined, start?: number, length?: number): void;\n        setOnError(onError: ErrorCallback | undefined): void;\n        setScriptTarget(scriptTarget: ScriptTarget): void;\n        setLanguageVariant(variant: LanguageVariant): void;\n        setScriptKind(scriptKind: ScriptKind): void;\n        setJSDocParsingMode(kind: JSDocParsingMode): void;\n        /** @deprecated use {@link resetTokenState} */\n        setTextPos(textPos: number): void;\n        resetTokenState(pos: number): void;\n        lookAhead<T>(callback: () => T): T;\n        scanRange<T>(start: number, length: number, callback: () => T): T;\n        tryScan<T>(callback: () => T): T;\n    }\n    function isExternalModuleNameRelative(moduleName: string): boolean;\n    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;\n    function getDefaultLibFileName(options: CompilerOptions): string;\n    function textSpanEnd(span: TextSpan): number;\n    function textSpanIsEmpty(span: TextSpan): boolean;\n    function textSpanContainsPosition(span: TextSpan, position: number): boolean;\n    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;\n    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;\n    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;\n    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;\n    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;\n    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;\n    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;\n    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;\n    function createTextSpan(start: number, length: number): TextSpan;\n    function createTextSpanFromBounds(start: number, end: number): TextSpan;\n    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;\n    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;\n    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;\n    /**\n     * Called to merge all the changes that occurred across several versions of a script snapshot\n     * into a single change.  i.e. if a user keeps making successive edits to a script we will\n     * have a text change from V1 to V2, V2 to V3, ..., Vn.\n     *\n     * This function will then merge those changes into a single change range valid between V1 and\n     * Vn.\n     */\n    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;\n    function getTypeParameterOwner(d: Declaration): Declaration | undefined;\n    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;\n    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;\n    function isEmptyBindingElement(node: BindingElement | ArrayBindingElement): boolean;\n    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;\n    function getCombinedModifierFlags(node: Declaration): ModifierFlags;\n    function getCombinedNodeFlags(node: Node): NodeFlags;\n    /**\n     * Checks to see if the locale is in the appropriate format,\n     * and if it is, attempts to set the appropriate language.\n     */\n    function validateLocaleAndSetLanguage(locale: string, sys: {\n        getExecutingFilePath(): string;\n        resolvePath(path: string): string;\n        fileExists(fileName: string): boolean;\n        readFile(fileName: string): string | undefined;\n    }, errors?: Diagnostic[]): void;\n    function getOriginalNode(node: Node): Node;\n    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;\n    function getOriginalNode(node: Node | undefined): Node | undefined;\n    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node) => node is T): T | undefined;\n    /**\n     * Iterates through the parent chain of a node and performs the callback on each parent until the callback\n     * returns a truthy value, then returns that value.\n     * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns \"quit\"\n     * At that point findAncestor returns undefined.\n     */\n    function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;\n    function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | \"quit\"): Node | undefined;\n    /**\n     * Gets a value indicating whether a node originated in the parse tree.\n     *\n     * @param node The node to test.\n     */\n    function isParseTreeNode(node: Node): boolean;\n    /**\n     * Gets the original parse tree node for a node.\n     *\n     * @param node The original node.\n     * @returns The original parse tree node if found; otherwise, undefined.\n     */\n    function getParseTreeNode(node: Node | undefined): Node | undefined;\n    /**\n     * Gets the original parse tree node for a node.\n     *\n     * @param node The original node.\n     * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.\n     * @returns The original parse tree node if found; otherwise, undefined.\n     */\n    function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;\n    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */\n    function escapeLeadingUnderscores(identifier: string): __String;\n    /**\n     * Remove extra underscore from escaped identifier text content.\n     *\n     * @param identifier The escaped identifier text.\n     * @returns The unescaped identifier text.\n     */\n    function unescapeLeadingUnderscores(identifier: __String): string;\n    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;\n    /**\n     * If the text of an Identifier matches a keyword (including contextual and TypeScript-specific keywords), returns the\n     * SyntaxKind for the matching keyword.\n     */\n    function identifierToKeywordKind(node: Identifier): KeywordSyntaxKind | undefined;\n    function symbolName(symbol: Symbol): string;\n    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;\n    function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;\n    function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;\n    function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;\n    /**\n     * Gets the JSDoc parameter tags for the node if present.\n     *\n     * @remarks Returns any JSDoc param tag whose name matches the provided\n     * parameter, whether a param tag on a containing function\n     * expression, or a param tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are returned first, so in the previous example, the param\n     * tag on the containing function expression would be first.\n     *\n     * For binding patterns, parameter tags are matched by position.\n     */\n    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];\n    /**\n     * Gets the JSDoc type parameter tags for the node if present.\n     *\n     * @remarks Returns any JSDoc template tag whose names match the provided\n     * parameter, whether a template tag on a containing function\n     * expression, or a template tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are returned first, so in the previous example, the template\n     * tag on the containing function expression would be first.\n     */\n    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];\n    /**\n     * Return true if the node has JSDoc parameter tags.\n     *\n     * @remarks Includes parameter tags that are not directly on the node,\n     * for example on a variable declaration whose initializer is a function expression.\n     */\n    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;\n    /** Gets the JSDoc augments tag for the node if present */\n    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;\n    /** Gets the JSDoc implements tags for the node if present */\n    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];\n    /** Gets the JSDoc class tag for the node if present */\n    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;\n    /** Gets the JSDoc public tag for the node if present */\n    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;\n    /** Gets the JSDoc private tag for the node if present */\n    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;\n    /** Gets the JSDoc protected tag for the node if present */\n    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;\n    /** Gets the JSDoc protected tag for the node if present */\n    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;\n    function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;\n    /** Gets the JSDoc deprecated tag for the node if present */\n    function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;\n    /** Gets the JSDoc enum tag for the node if present */\n    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;\n    /** Gets the JSDoc this tag for the node if present */\n    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;\n    /** Gets the JSDoc return tag for the node if present */\n    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;\n    /** Gets the JSDoc template tag for the node if present */\n    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;\n    function getJSDocSatisfiesTag(node: Node): JSDocSatisfiesTag | undefined;\n    /** Gets the JSDoc type tag for the node if present and valid */\n    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;\n    /**\n     * Gets the type node for the node if provided via JSDoc.\n     *\n     * @remarks The search includes any JSDoc param tag that relates\n     * to the provided parameter, for example a type tag on the\n     * parameter itself, or a param tag on a containing function\n     * expression, or a param tag on a variable declaration whose\n     * initializer is the containing function. The tags closest to the\n     * node are examined first, so in the previous example, the type\n     * tag directly on the node would be returned.\n     */\n    function getJSDocType(node: Node): TypeNode | undefined;\n    /**\n     * Gets the return type node for the node if provided via JSDoc return tag or type tag.\n     *\n     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function\n     * gets the type from inside the braces, after the fat arrow, etc.\n     */\n    function getJSDocReturnType(node: Node): TypeNode | undefined;\n    /** Get all JSDoc tags related to a node, including those on parent nodes. */\n    function getJSDocTags(node: Node): readonly JSDocTag[];\n    /** Gets all JSDoc tags that match a specified predicate */\n    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];\n    /** Gets all JSDoc tags of a specified kind */\n    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];\n    /** Gets the text of a jsdoc comment, flattening links to their text. */\n    function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;\n    /**\n     * Gets the effective type parameters. If the node was parsed in a\n     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.\n     *\n     * This does *not* return type parameters from a jsdoc reference to a generic type, eg\n     *\n     * type Id = <T>(x: T) => T\n     * /** @type {Id} /\n     * function id(x) { return x }\n     */\n    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];\n    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;\n    function isMemberName(node: Node): node is MemberName;\n    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;\n    function isElementAccessChain(node: Node): node is ElementAccessChain;\n    function isCallChain(node: Node): node is CallChain;\n    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;\n    function isNullishCoalesce(node: Node): boolean;\n    function isConstTypeReference(node: Node): boolean;\n    function skipPartiallyEmittedExpressions(node: Expression): Expression;\n    function skipPartiallyEmittedExpressions(node: Node): Node;\n    function isNonNullChain(node: Node): node is NonNullChain;\n    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;\n    function isNamedExportBindings(node: Node): node is NamedExportBindings;\n    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;\n    /**\n     * True if kind is of some token syntax kind.\n     * For example, this is true for an IfKeyword but not for an IfStatement.\n     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.\n     */\n    function isTokenKind(kind: SyntaxKind): boolean;\n    /**\n     * True if node is of some token syntax kind.\n     * For example, this is true for an IfKeyword but not for an IfStatement.\n     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.\n     */\n    function isToken(n: Node): boolean;\n    function isLiteralExpression(node: Node): node is LiteralExpression;\n    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;\n    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;\n    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;\n    function isTypeOnlyImportDeclaration(node: Node): node is TypeOnlyImportDeclaration;\n    function isTypeOnlyExportDeclaration(node: Node): node is TypeOnlyExportDeclaration;\n    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;\n    function isPartOfTypeOnlyImportOrExportDeclaration(node: Node): boolean;\n    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;\n    function isImportAttributeName(node: Node): node is ImportAttributeName;\n    function isModifier(node: Node): node is Modifier;\n    function isEntityName(node: Node): node is EntityName;\n    function isPropertyName(node: Node): node is PropertyName;\n    function isBindingName(node: Node): node is BindingName;\n    function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;\n    function isClassElement(node: Node): node is ClassElement;\n    function isClassLike(node: Node): node is ClassLikeDeclaration;\n    function isAccessor(node: Node): node is AccessorDeclaration;\n    function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;\n    function isModifierLike(node: Node): node is ModifierLike;\n    function isTypeElement(node: Node): node is TypeElement;\n    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;\n    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;\n    /**\n     * Node test that determines whether a node is a valid type node.\n     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*\n     * of a TypeNode.\n     */\n    function isTypeNode(node: Node): node is TypeNode;\n    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;\n    function isArrayBindingElement(node: Node): node is ArrayBindingElement;\n    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;\n    function isCallLikeExpression(node: Node): node is CallLikeExpression;\n    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;\n    function isTemplateLiteral(node: Node): node is TemplateLiteral;\n    function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression;\n    function isLiteralTypeLiteral(node: Node): node is NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;\n    /**\n     * Determines whether a node is an expression based only on its kind.\n     */\n    function isExpression(node: Node): node is Expression;\n    function isAssertionExpression(node: Node): node is AssertionExpression;\n    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;\n    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;\n    function isConciseBody(node: Node): node is ConciseBody;\n    function isForInitializer(node: Node): node is ForInitializer;\n    function isModuleBody(node: Node): node is ModuleBody;\n    function isNamedImportBindings(node: Node): node is NamedImportBindings;\n    function isDeclarationStatement(node: Node): node is DeclarationStatement;\n    function isStatement(node: Node): node is Statement;\n    function isModuleReference(node: Node): node is ModuleReference;\n    function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression;\n    function isJsxChild(node: Node): node is JsxChild;\n    function isJsxAttributeLike(node: Node): node is JsxAttributeLike;\n    function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression;\n    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;\n    function isJsxCallLike(node: Node): node is JsxCallLike;\n    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;\n    /** True if node is of a kind that may contain comment text. */\n    function isJSDocCommentContainingNode(node: Node): boolean;\n    function isSetAccessor(node: Node): node is SetAccessorDeclaration;\n    function isGetAccessor(node: Node): node is GetAccessorDeclaration;\n    /** True if has initializer node attached to it. */\n    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;\n    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;\n    function isStringLiteralLike(node: Node | FileReference): node is StringLiteralLike;\n    function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;\n    function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;\n    function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;\n    function isInternalDeclaration(node: Node, sourceFile?: SourceFile): boolean;\n    const unchangedTextChangeRange: TextChangeRange;\n    type ParameterPropertyDeclaration = ParameterDeclaration & {\n        parent: ConstructorDeclaration;\n        name: Identifier;\n    };\n    function isPartOfTypeNode(node: Node): boolean;\n    /**\n     * This function checks multiple locations for JSDoc comments that apply to a host node.\n     * At each location, the whole comment may apply to the node, or only a specific tag in\n     * the comment. In the first case, location adds the entire {@link JSDoc} object. In the\n     * second case, it adds the applicable {@link JSDocTag}.\n     *\n     * For example, a JSDoc comment before a parameter adds the entire {@link JSDoc}. But a\n     * `@param` tag on the parent function only adds the {@link JSDocTag} for the `@param`.\n     *\n     * ```ts\n     * /** JSDoc will be returned for `a` *\\/\n     * const a = 0\n     * /**\n     *  * Entire JSDoc will be returned for `b`\n     *  * @param c JSDocTag will be returned for `c`\n     *  *\\/\n     * function b(/** JSDoc will be returned for `c` *\\/ c) {}\n     * ```\n     */\n    function getJSDocCommentsAndTags(hostNode: Node): readonly (JSDoc | JSDocTag)[];\n    /**\n     * Create an external source map source file reference\n     */\n    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;\n    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;\n    const factory: NodeFactory;\n    /**\n     * Clears any `EmitNode` entries from parse-tree nodes.\n     * @param sourceFile A source file.\n     */\n    function disposeEmitNodes(sourceFile: SourceFile | undefined): void;\n    /**\n     * Sets flags that control emit behavior of a node.\n     */\n    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;\n    /**\n     * Gets a custom text range to use when emitting source maps.\n     */\n    function getSourceMapRange(node: Node): SourceMapRange;\n    /**\n     * Sets a custom text range to use when emitting source maps.\n     */\n    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;\n    /**\n     * Gets the TextRange to use for source maps for a token of a node.\n     */\n    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;\n    /**\n     * Sets the TextRange to use for source maps for a token of a node.\n     */\n    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;\n    /**\n     * Gets a custom text range to use when emitting comments.\n     */\n    function getCommentRange(node: Node): TextRange;\n    /**\n     * Sets a custom text range to use when emitting comments.\n     */\n    function setCommentRange<T extends Node>(node: T, range: TextRange): T;\n    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;\n    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;\n    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;\n    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;\n    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;\n    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;\n    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;\n    /**\n     * Gets the constant value to emit for an expression representing an enum.\n     */\n    function getConstantValue(node: AccessExpression): string | number | undefined;\n    /**\n     * Sets the constant value to emit for an expression.\n     */\n    function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;\n    /**\n     * Adds an EmitHelper to a node.\n     */\n    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;\n    /**\n     * Add EmitHelpers to a node.\n     */\n    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;\n    /**\n     * Removes an EmitHelper from a node.\n     */\n    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;\n    /**\n     * Gets the EmitHelpers of a node.\n     */\n    function getEmitHelpers(node: Node): EmitHelper[] | undefined;\n    /**\n     * Moves matching emit helpers from a source node to a target node.\n     */\n    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;\n    function isNumericLiteral(node: Node): node is NumericLiteral;\n    function isBigIntLiteral(node: Node): node is BigIntLiteral;\n    function isStringLiteral(node: Node): node is StringLiteral;\n    function isJsxText(node: Node): node is JsxText;\n    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;\n    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;\n    function isTemplateHead(node: Node): node is TemplateHead;\n    function isTemplateMiddle(node: Node): node is TemplateMiddle;\n    function isTemplateTail(node: Node): node is TemplateTail;\n    function isDotDotDotToken(node: Node): node is DotDotDotToken;\n    function isPlusToken(node: Node): node is PlusToken;\n    function isMinusToken(node: Node): node is MinusToken;\n    function isAsteriskToken(node: Node): node is AsteriskToken;\n    function isExclamationToken(node: Node): node is ExclamationToken;\n    function isQuestionToken(node: Node): node is QuestionToken;\n    function isColonToken(node: Node): node is ColonToken;\n    function isQuestionDotToken(node: Node): node is QuestionDotToken;\n    function isEqualsGreaterThanToken(node: Node): node is EqualsGreaterThanToken;\n    function isIdentifier(node: Node): node is Identifier;\n    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;\n    function isAssertsKeyword(node: Node): node is AssertsKeyword;\n    function isAwaitKeyword(node: Node): node is AwaitKeyword;\n    function isQualifiedName(node: Node): node is QualifiedName;\n    function isComputedPropertyName(node: Node): node is ComputedPropertyName;\n    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;\n    function isParameter(node: Node): node is ParameterDeclaration;\n    function isDecorator(node: Node): node is Decorator;\n    function isPropertySignature(node: Node): node is PropertySignature;\n    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;\n    function isMethodSignature(node: Node): node is MethodSignature;\n    function isMethodDeclaration(node: Node): node is MethodDeclaration;\n    function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;\n    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;\n    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;\n    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;\n    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;\n    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;\n    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;\n    function isTypePredicateNode(node: Node): node is TypePredicateNode;\n    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;\n    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;\n    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;\n    function isTypeQueryNode(node: Node): node is TypeQueryNode;\n    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;\n    function isArrayTypeNode(node: Node): node is ArrayTypeNode;\n    function isTupleTypeNode(node: Node): node is TupleTypeNode;\n    function isNamedTupleMember(node: Node): node is NamedTupleMember;\n    function isOptionalTypeNode(node: Node): node is OptionalTypeNode;\n    function isRestTypeNode(node: Node): node is RestTypeNode;\n    function isUnionTypeNode(node: Node): node is UnionTypeNode;\n    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;\n    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;\n    function isInferTypeNode(node: Node): node is InferTypeNode;\n    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;\n    function isThisTypeNode(node: Node): node is ThisTypeNode;\n    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;\n    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;\n    function isMappedTypeNode(node: Node): node is MappedTypeNode;\n    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;\n    function isImportTypeNode(node: Node): node is ImportTypeNode;\n    function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;\n    function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;\n    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;\n    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;\n    function isBindingElement(node: Node): node is BindingElement;\n    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;\n    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;\n    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;\n    function isElementAccessExpression(node: Node): node is ElementAccessExpression;\n    function isCallExpression(node: Node): node is CallExpression;\n    function isNewExpression(node: Node): node is NewExpression;\n    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;\n    function isTypeAssertionExpression(node: Node): node is TypeAssertion;\n    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;\n    function isFunctionExpression(node: Node): node is FunctionExpression;\n    function isArrowFunction(node: Node): node is ArrowFunction;\n    function isDeleteExpression(node: Node): node is DeleteExpression;\n    function isTypeOfExpression(node: Node): node is TypeOfExpression;\n    function isVoidExpression(node: Node): node is VoidExpression;\n    function isAwaitExpression(node: Node): node is AwaitExpression;\n    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;\n    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;\n    function isBinaryExpression(node: Node): node is BinaryExpression;\n    function isConditionalExpression(node: Node): node is ConditionalExpression;\n    function isTemplateExpression(node: Node): node is TemplateExpression;\n    function isYieldExpression(node: Node): node is YieldExpression;\n    function isSpreadElement(node: Node): node is SpreadElement;\n    function isClassExpression(node: Node): node is ClassExpression;\n    function isOmittedExpression(node: Node): node is OmittedExpression;\n    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;\n    function isAsExpression(node: Node): node is AsExpression;\n    function isSatisfiesExpression(node: Node): node is SatisfiesExpression;\n    function isNonNullExpression(node: Node): node is NonNullExpression;\n    function isMetaProperty(node: Node): node is MetaProperty;\n    function isSyntheticExpression(node: Node): node is SyntheticExpression;\n    function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;\n    function isCommaListExpression(node: Node): node is CommaListExpression;\n    function isTemplateSpan(node: Node): node is TemplateSpan;\n    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;\n    function isBlock(node: Node): node is Block;\n    function isVariableStatement(node: Node): node is VariableStatement;\n    function isEmptyStatement(node: Node): node is EmptyStatement;\n    function isExpressionStatement(node: Node): node is ExpressionStatement;\n    function isIfStatement(node: Node): node is IfStatement;\n    function isDoStatement(node: Node): node is DoStatement;\n    function isWhileStatement(node: Node): node is WhileStatement;\n    function isForStatement(node: Node): node is ForStatement;\n    function isForInStatement(node: Node): node is ForInStatement;\n    function isForOfStatement(node: Node): node is ForOfStatement;\n    function isContinueStatement(node: Node): node is ContinueStatement;\n    function isBreakStatement(node: Node): node is BreakStatement;\n    function isReturnStatement(node: Node): node is ReturnStatement;\n    function isWithStatement(node: Node): node is WithStatement;\n    function isSwitchStatement(node: Node): node is SwitchStatement;\n    function isLabeledStatement(node: Node): node is LabeledStatement;\n    function isThrowStatement(node: Node): node is ThrowStatement;\n    function isTryStatement(node: Node): node is TryStatement;\n    function isDebuggerStatement(node: Node): node is DebuggerStatement;\n    function isVariableDeclaration(node: Node): node is VariableDeclaration;\n    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;\n    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;\n    function isClassDeclaration(node: Node): node is ClassDeclaration;\n    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;\n    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;\n    function isEnumDeclaration(node: Node): node is EnumDeclaration;\n    function isModuleDeclaration(node: Node): node is ModuleDeclaration;\n    function isModuleBlock(node: Node): node is ModuleBlock;\n    function isCaseBlock(node: Node): node is CaseBlock;\n    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;\n    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;\n    function isImportDeclaration(node: Node): node is ImportDeclaration;\n    function isImportClause(node: Node): node is ImportClause;\n    function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;\n    /** @deprecated */\n    function isAssertClause(node: Node): node is AssertClause;\n    /** @deprecated */\n    function isAssertEntry(node: Node): node is AssertEntry;\n    function isImportAttributes(node: Node): node is ImportAttributes;\n    function isImportAttribute(node: Node): node is ImportAttribute;\n    function isNamespaceImport(node: Node): node is NamespaceImport;\n    function isNamespaceExport(node: Node): node is NamespaceExport;\n    function isNamedImports(node: Node): node is NamedImports;\n    function isImportSpecifier(node: Node): node is ImportSpecifier;\n    function isExportAssignment(node: Node): node is ExportAssignment;\n    function isExportDeclaration(node: Node): node is ExportDeclaration;\n    function isNamedExports(node: Node): node is NamedExports;\n    function isExportSpecifier(node: Node): node is ExportSpecifier;\n    function isModuleExportName(node: Node): node is ModuleExportName;\n    function isMissingDeclaration(node: Node): node is MissingDeclaration;\n    function isNotEmittedStatement(node: Node): node is NotEmittedStatement;\n    function isExternalModuleReference(node: Node): node is ExternalModuleReference;\n    function isJsxElement(node: Node): node is JsxElement;\n    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;\n    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;\n    function isJsxClosingElement(node: Node): node is JsxClosingElement;\n    function isJsxFragment(node: Node): node is JsxFragment;\n    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;\n    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;\n    function isJsxAttribute(node: Node): node is JsxAttribute;\n    function isJsxAttributes(node: Node): node is JsxAttributes;\n    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;\n    function isJsxExpression(node: Node): node is JsxExpression;\n    function isJsxNamespacedName(node: Node): node is JsxNamespacedName;\n    function isCaseClause(node: Node): node is CaseClause;\n    function isDefaultClause(node: Node): node is DefaultClause;\n    function isHeritageClause(node: Node): node is HeritageClause;\n    function isCatchClause(node: Node): node is CatchClause;\n    function isPropertyAssignment(node: Node): node is PropertyAssignment;\n    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;\n    function isSpreadAssignment(node: Node): node is SpreadAssignment;\n    function isEnumMember(node: Node): node is EnumMember;\n    function isSourceFile(node: Node): node is SourceFile;\n    function isBundle(node: Node): node is Bundle;\n    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;\n    function isJSDocNameReference(node: Node): node is JSDocNameReference;\n    function isJSDocMemberName(node: Node): node is JSDocMemberName;\n    function isJSDocLink(node: Node): node is JSDocLink;\n    function isJSDocLinkCode(node: Node): node is JSDocLinkCode;\n    function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;\n    function isJSDocAllType(node: Node): node is JSDocAllType;\n    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;\n    function isJSDocNullableType(node: Node): node is JSDocNullableType;\n    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;\n    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;\n    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;\n    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;\n    function isJSDocNamepathType(node: Node): node is JSDocNamepathType;\n    function isJSDoc(node: Node): node is JSDoc;\n    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;\n    function isJSDocSignature(node: Node): node is JSDocSignature;\n    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;\n    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;\n    function isJSDocClassTag(node: Node): node is JSDocClassTag;\n    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;\n    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;\n    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;\n    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;\n    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;\n    function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;\n    function isJSDocOverloadTag(node: Node): node is JSDocOverloadTag;\n    function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;\n    function isJSDocSeeTag(node: Node): node is JSDocSeeTag;\n    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;\n    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;\n    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;\n    function isJSDocThisTag(node: Node): node is JSDocThisTag;\n    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;\n    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;\n    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;\n    function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;\n    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;\n    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;\n    function isJSDocSatisfiesTag(node: Node): node is JSDocSatisfiesTag;\n    function isJSDocThrowsTag(node: Node): node is JSDocThrowsTag;\n    function isJSDocImportTag(node: Node): node is JSDocImportTag;\n    function isQuestionOrExclamationToken(node: Node): node is QuestionToken | ExclamationToken;\n    function isIdentifierOrThisTypeNode(node: Node): node is Identifier | ThisTypeNode;\n    function isReadonlyKeywordOrPlusOrMinusToken(node: Node): node is ReadonlyKeyword | PlusToken | MinusToken;\n    function isQuestionOrPlusOrMinusToken(node: Node): node is QuestionToken | PlusToken | MinusToken;\n    function isModuleName(node: Node): node is ModuleName;\n    function isBinaryOperatorToken(node: Node): node is BinaryOperatorToken;\n    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;\n    function canHaveModifiers(node: Node): node is HasModifiers;\n    function canHaveDecorators(node: Node): node is HasDecorators;\n    /**\n     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes\n     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,\n     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns\n     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\n     *\n     * @param node a given node to visit its children\n     * @param cbNode a callback to be invoked for all child nodes\n     * @param cbNodes a callback to be invoked for embedded array\n     *\n     * @remarks `forEachChild` must visit the children of a node in the order\n     * that they appear in the source code. The language service depends on this property to locate nodes by position.\n     */\n    function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;\n    function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;\n    function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;\n    /**\n     * Parse json text into SyntaxTree and return node and parse errors if any\n     * @param fileName\n     * @param sourceText\n     */\n    function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;\n    function isExternalModule(file: SourceFile): boolean;\n    function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;\n    interface CreateSourceFileOptions {\n        languageVersion: ScriptTarget;\n        /**\n         * Controls the format the file is detected as - this can be derived from only the path\n         * and files on disk, but needs to be done with a module resolution cache in scope to be performant.\n         * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.\n         */\n        impliedNodeFormat?: ResolutionMode;\n        /**\n         * Controls how module-y-ness is set for the given file. Usually the result of calling\n         * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default\n         * check specified by `isFileProbablyExternalModule` will be used to set the field.\n         */\n        setExternalModuleIndicator?: (file: SourceFile) => void;\n        jsDocParsingMode?: JSDocParsingMode;\n    }\n    function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;\n    function parseBuildCommand(commandLine: readonly string[]): ParsedBuildCommand;\n    /**\n     * Reads the config file, reports errors if any and exits if the config file cannot be found\n     */\n    function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;\n    /**\n     * Read tsconfig.json file\n     * @param fileName The path to the config file\n     */\n    function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {\n        config?: any;\n        error?: Diagnostic;\n    };\n    /**\n     * Parse the text of the tsconfig.json file\n     * @param fileName The path to the config file\n     * @param jsonText The text of the config file\n     */\n    function parseConfigFileTextToJson(fileName: string, jsonText: string): {\n        config?: any;\n        error?: Diagnostic;\n    };\n    /**\n     * Read tsconfig.json file\n     * @param fileName The path to the config file\n     */\n    function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;\n    /**\n     * Convert the json syntax tree into the json value\n     */\n    function convertToObject(sourceFile: JsonSourceFile, errors: Diagnostic[]): any;\n    /**\n     * Parse the contents of a config file (tsconfig.json).\n     * @param json The contents of the config file to parse\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\n     * @param basePath A root directory to resolve relative path entries in the config\n     *    file to. e.g. outDir\n     */\n    function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;\n    /**\n     * Parse the contents of a config file (tsconfig.json).\n     * @param jsonNode The contents of the config file to parse\n     * @param host Instance of ParseConfigHost used to enumerate files in folder.\n     * @param basePath A root directory to resolve relative path entries in the config\n     *    file to. e.g. outDir\n     */\n    function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<string, ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;\n    function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {\n        options: CompilerOptions;\n        errors: Diagnostic[];\n    };\n    function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {\n        options: TypeAcquisition;\n        errors: Diagnostic[];\n    };\n    /** Parsed command line for build */\n    interface ParsedBuildCommand {\n        buildOptions: BuildOptions;\n        watchOptions: WatchOptions | undefined;\n        projects: string[];\n        errors: Diagnostic[];\n    }\n    type DiagnosticReporter = (diagnostic: Diagnostic) => void;\n    /**\n     * Reports config file diagnostics\n     */\n    interface ConfigFileDiagnosticsReporter {\n        /**\n         * Reports unrecoverable error when parsing config file\n         */\n        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;\n    }\n    /**\n     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors\n     */\n    interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {\n        getCurrentDirectory(): string;\n    }\n    interface ParsedTsconfig {\n        raw: any;\n        options?: CompilerOptions;\n        watchOptions?: WatchOptions;\n        typeAcquisition?: TypeAcquisition;\n        /**\n         * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet\n         */\n        extendedConfigPath?: string | string[];\n    }\n    interface ExtendedConfigCacheEntry {\n        extendedResult: TsConfigSourceFile;\n        extendedConfig: ParsedTsconfig | undefined;\n    }\n    function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;\n    /**\n     * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.\n     * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups\n     * is assumed to be the same as root directory of the project.\n     */\n    function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache, resolutionMode?: ResolutionMode): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;\n    /**\n     * Given a set of options, returns the set of type directive names\n     *   that should be included for this program automatically.\n     * This list could either come from the config file,\n     *   or from enumerating the types root + initial secondary types lookup location.\n     * More type directives might appear in the program later as a result of loading actual source files;\n     *   this list is only the set of defaults that are implicitly included.\n     */\n    function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];\n    function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): ModuleResolutionCache;\n    function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;\n    function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;\n    function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations;\n    function bundlerModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;\n    interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, NonRelativeNameResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {\n    }\n    interface ModeAwareCache<T> {\n        get(key: string, mode: ResolutionMode): T | undefined;\n        set(key: string, mode: ResolutionMode, value: T): this;\n        delete(key: string, mode: ResolutionMode): this;\n        has(key: string, mode: ResolutionMode): boolean;\n        forEach(cb: (elem: T, key: string, mode: ResolutionMode) => void): void;\n        size(): number;\n    }\n    /**\n     * Cached resolutions per containing directory.\n     * This assumes that any module id will have the same resolution for sibling files located in the same folder.\n     */\n    interface PerDirectoryResolutionCache<T> {\n        getFromDirectoryCache(name: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;\n        getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache<T>;\n        clear(): void;\n        /**\n         *  Updates with the current compilerOptions the cache will operate with.\n         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects\n         */\n        update(options: CompilerOptions): void;\n    }\n    interface NonRelativeNameResolutionCache<T> {\n        getFromNonRelativeNameCache(nonRelativeName: string, mode: ResolutionMode, directoryName: string, redirectedReference: ResolvedProjectReference | undefined): T | undefined;\n        getOrCreateCacheForNonRelativeName(nonRelativeName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerNonRelativeNameCache<T>;\n        clear(): void;\n        /**\n         *  Updates with the current compilerOptions the cache will operate with.\n         *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects\n         */\n        update(options: CompilerOptions): void;\n    }\n    interface PerNonRelativeNameCache<T> {\n        get(directory: string): T | undefined;\n        set(directory: string, result: T): void;\n    }\n    interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {\n        getPackageJsonInfoCache(): PackageJsonInfoCache;\n    }\n    /**\n     * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory\n     * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.\n     */\n    interface NonRelativeModuleNameResolutionCache extends NonRelativeNameResolutionCache<ResolvedModuleWithFailedLookupLocations>, PackageJsonInfoCache {\n        /** @deprecated Use getOrCreateCacheForNonRelativeName */\n        getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ResolutionMode, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;\n    }\n    interface PackageJsonInfoCache {\n        clear(): void;\n    }\n    type PerModuleNameCache = PerNonRelativeNameCache<ResolvedModuleWithFailedLookupLocations>;\n    /**\n     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.\n     *\n     * - If the input node is undefined, then the output is undefined.\n     * - If the visitor returns undefined, then the output is undefined.\n     * - If the output node is not undefined, then it will satisfy the test function.\n     * - In order to obtain a return type that is more specific than `Node`, a test\n     *   function _must_ be provided, and that function must be a type predicate.\n     *\n     * @param node The Node to visit.\n     * @param visitor The callback used to visit the Node.\n     * @param test A callback to execute to verify the Node is valid.\n     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.\n     */\n    function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined, TOut extends Node>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test: (node: Node) => node is TOut, lift?: (node: readonly Node[]) => Node): TOut | (TIn & undefined) | (TVisited & undefined);\n    /**\n     * Visits a Node using the supplied visitor, possibly returning a new Node in its place.\n     *\n     * - If the input node is undefined, then the output is undefined.\n     * - If the visitor returns undefined, then the output is undefined.\n     * - If the output node is not undefined, then it will satisfy the test function.\n     * - In order to obtain a return type that is more specific than `Node`, a test\n     *   function _must_ be provided, and that function must be a type predicate.\n     *\n     * @param node The Node to visit.\n     * @param visitor The callback used to visit the Node.\n     * @param test A callback to execute to verify the Node is valid.\n     * @param lift An optional callback to execute to lift a NodeArray into a valid Node.\n     */\n    function visitNode<TIn extends Node | undefined, TVisited extends Node | undefined>(node: TIn, visitor: Visitor<NonNullable<TIn>, TVisited>, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => Node): Node | (TIn & undefined) | (TVisited & undefined);\n    /**\n     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.\n     *\n     * - If the input node array is undefined, the output is undefined.\n     * - If the visitor can return undefined, the node it visits in the array will be reused.\n     * - If the output node array is not undefined, then its contents will satisfy the test.\n     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test\n     *   function _must_ be provided, and that function must be a type predicate.\n     *\n     * @param nodes The NodeArray to visit.\n     * @param visitor The callback used to visit a Node.\n     * @param test A node test to execute for each node.\n     * @param start An optional value indicating the starting offset at which to start visiting.\n     * @param count An optional value indicating the maximum number of nodes to visit.\n     */\n    function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined, TOut extends Node>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test: (node: Node) => node is TOut, start?: number, count?: number): NodeArray<TOut> | (TInArray & undefined);\n    /**\n     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.\n     *\n     * - If the input node array is undefined, the output is undefined.\n     * - If the visitor can return undefined, the node it visits in the array will be reused.\n     * - If the output node array is not undefined, then its contents will satisfy the test.\n     * - In order to obtain a return type that is more specific than `NodeArray<Node>`, a test\n     *   function _must_ be provided, and that function must be a type predicate.\n     *\n     * @param nodes The NodeArray to visit.\n     * @param visitor The callback used to visit a Node.\n     * @param test A node test to execute for each node.\n     * @param start An optional value indicating the starting offset at which to start visiting.\n     * @param count An optional value indicating the maximum number of nodes to visit.\n     */\n    function visitNodes<TIn extends Node, TInArray extends NodeArray<TIn> | undefined>(nodes: TInArray, visitor: Visitor<TIn, Node | undefined>, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<Node> | (TInArray & undefined);\n    /**\n     * Starts a new lexical environment and visits a statement list, ending the lexical environment\n     * and merging hoisted declarations upon completion.\n     */\n    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;\n    /**\n     * Starts a new lexical environment and visits a parameter list, suspending the lexical\n     * environment upon completion.\n     */\n    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;\n    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;\n    /**\n     * Resumes a suspended lexical environment and visits a function body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;\n    /**\n     * Resumes a suspended lexical environment and visits a function body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;\n    /**\n     * Resumes a suspended lexical environment and visits a concise body, ending the lexical\n     * environment and merging hoisted declarations upon completion.\n     */\n    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;\n    /**\n     * Visits an iteration body, adding any block-scoped variables required by the transformation.\n     */\n    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;\n    /**\n     * Visits the elements of a {@link CommaListExpression}.\n     * @param visitor The visitor to use when visiting expressions whose result will not be discarded at runtime.\n     * @param discardVisitor The visitor to use when visiting expressions whose result will be discarded at runtime. Defaults to {@link visitor}.\n     */\n    function visitCommaListElements(elements: NodeArray<Expression>, visitor: Visitor, discardVisitor?: Visitor): NodeArray<Expression>;\n    /**\n     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.\n     *\n     * @param node The Node whose children will be visited.\n     * @param visitor The callback used to visit each child.\n     * @param context A lexical environment context for the visitor.\n     */\n    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext | undefined): T;\n    /**\n     * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.\n     *\n     * @param node The Node whose children will be visited.\n     * @param visitor The callback used to visit each child.\n     * @param context A lexical environment context for the visitor.\n     */\n    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext | undefined, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;\n    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;\n    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];\n    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;\n    enum ProgramUpdateLevel {\n        /** Program is updated with same root file names and options */\n        Update = 0,\n        /** Loads program after updating root file names from the disk */\n        RootNamesAndUpdate = 1,\n        /**\n         * Loads program completely, including:\n         *  - re-reading contents of config file from disk\n         *  - calculating root file names for the program\n         *  - Updating the program\n         */\n        Full = 2,\n    }\n    function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;\n    function resolveTripleslashReference(moduleName: string, containingFile: string): string;\n    function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;\n    function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n    function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;\n    function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;\n    function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;\n    function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;\n    /**\n     * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly\n     * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.\n     */\n    function getModeForFileReference(ref: FileReference | string, containingFileMode: ResolutionMode): ResolutionMode;\n    /**\n     * Use `program.getModeForResolutionAtIndex`, which retrieves the correct `compilerOptions`, instead of this function whenever possible.\n     * Calculates the final resolution mode for an import at some index within a file's `imports` list. This is the resolution mode\n     * explicitly provided via import attributes, if present, or the syntax the usage would have if emitted to JavaScript. In\n     * `--module node16` or `nodenext`, this may depend on the file's `impliedNodeFormat`. In `--module preserve`, it depends only on the\n     * input syntax of the reference. In other `module` modes, when overriding import attributes are not provided, this function returns\n     * `undefined`, as the result would have no impact on module resolution, emit, or type checking.\n     * @param file File to fetch the resolution mode within\n     * @param index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations\n     * @param compilerOptions The compiler options for the program that owns the file. If the file belongs to a referenced project, the compiler options\n     * should be the options of the referenced project, not the referencing project.\n     */\n    function getModeForResolutionAtIndex(file: SourceFile, index: number, compilerOptions: CompilerOptions): ResolutionMode;\n    /**\n     * Use `program.getModeForUsageLocation`, which retrieves the correct `compilerOptions`, instead of this function whenever possible.\n     * Calculates the final resolution mode for a given module reference node. This function only returns a result when module resolution\n     * settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided via import attributes,\n     * which cause an `import` or `require` condition to be used during resolution regardless of module resolution settings. In absence of\n     * overriding attributes, and in modes that support differing resolution, the result indicates the syntax the usage would emit to JavaScript.\n     * Some examples:\n     *\n     * ```ts\n     * // tsc foo.mts --module nodenext\n     * import {} from \"mod\";\n     * // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension\n     *\n     * // tsc foo.cts --module nodenext\n     * import {} from \"mod\";\n     * // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension\n     *\n     * // tsc foo.ts --module preserve --moduleResolution bundler\n     * import {} from \"mod\";\n     * // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`\n     * // supports conditional imports/exports\n     *\n     * // tsc foo.ts --module preserve --moduleResolution node10\n     * import {} from \"mod\";\n     * // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`\n     * // does not support conditional imports/exports\n     *\n     * // tsc foo.ts --module commonjs --moduleResolution node10\n     * import type {} from \"mod\" with { \"resolution-mode\": \"import\" };\n     * // Result: ESNext - conditional imports/exports always supported with \"resolution-mode\" attribute\n     * ```\n     *\n     * @param file The file the import or import-like reference is contained within\n     * @param usage The module reference string\n     * @param compilerOptions The compiler options for the program that owns the file. If the file belongs to a referenced project, the compiler options\n     * should be the options of the referenced project, not the referencing project.\n     * @returns The final resolution mode of the import\n     */\n    function getModeForUsageLocation(file: SourceFile, usage: StringLiteralLike, compilerOptions: CompilerOptions): ResolutionMode;\n    function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];\n    /**\n     * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the\n     * `options` parameter.\n     *\n     * @param fileName The file name to check the format of (it need not exist on disk)\n     * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often\n     * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data\n     * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`\n     * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format\n     */\n    function getImpliedNodeFormatForFile(fileName: string, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ResolutionMode;\n    /**\n     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.\n     *\n     * @param createProgramOptions - The options for creating a program.\n     * @returns A 'Program' object.\n     */\n    function createProgram(createProgramOptions: CreateProgramOptions): Program;\n    /**\n     * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'\n     * that represent a compilation unit.\n     *\n     * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and\n     * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.\n     *\n     * @param rootNames - A set of root files.\n     * @param options - The compiler options which should be used.\n     * @param host - The host interacts with the underlying file system.\n     * @param oldProgram - Reuses an old program structure.\n     * @param configFileParsingDiagnostics - error during config file parsing\n     * @returns A 'Program' object.\n     */\n    function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;\n    /**\n     * Returns the target config filename of a project reference.\n     * Note: The file might not exist.\n     */\n    function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;\n    interface FormatDiagnosticsHost {\n        getCurrentDirectory(): string;\n        getCanonicalFileName(fileName: string): string;\n        getNewLine(): string;\n    }\n    interface EmitOutput {\n        outputFiles: OutputFile[];\n        emitSkipped: boolean;\n        diagnostics: readonly Diagnostic[];\n    }\n    interface OutputFile {\n        name: string;\n        writeByteOrderMark: boolean;\n        text: string;\n    }\n    /**\n     * Create the builder to manage semantic diagnostics and cache them\n     */\n    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;\n    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;\n    /**\n     * Create the builder that can handle the changes in program and iterate through changed files\n     * to emit the those files and manage semantic diagnostics cache as well\n     */\n    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;\n    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;\n    /**\n     * Creates a builder thats just abstraction over program and can be used with watch\n     */\n    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;\n    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;\n    type AffectedFileResult<T> = {\n        result: T;\n        affected: SourceFile | Program;\n    } | undefined;\n    interface BuilderProgramHost {\n        /**\n         * If provided this would be used this hash instead of actual file shape text for detecting changes\n         */\n        createHash?: (data: string) => string;\n        /**\n         * When emit or emitNextAffectedFile are called without writeFile,\n         * this callback if present would be used to write files\n         */\n        writeFile?: WriteFileCallback;\n    }\n    /**\n     * Builder to manage the program state changes\n     */\n    interface BuilderProgram {\n        /**\n         * Returns current program\n         */\n        getProgram(): Program;\n        /**\n         * Get compiler options of the program\n         */\n        getCompilerOptions(): CompilerOptions;\n        /**\n         * Get the source file in the program with file name\n         */\n        getSourceFile(fileName: string): SourceFile | undefined;\n        /**\n         * Get a list of files in the program\n         */\n        getSourceFiles(): readonly SourceFile[];\n        /**\n         * Get the diagnostics for compiler options\n         */\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the diagnostics that dont belong to any file\n         */\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the diagnostics from config file parsing\n         */\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        /**\n         * Get the syntax diagnostics, for all source files if source file is not supplied\n         */\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Get the declaration diagnostics, for all source files if source file is not supplied\n         */\n        getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];\n        /**\n         * Get all the dependencies of the file\n         */\n        getAllDependencies(sourceFile: SourceFile): readonly string[];\n        /**\n         * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program\n         * The semantic diagnostics are cached and managed here\n         * Note that it is assumed that when asked about semantic diagnostics through this API,\n         * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics\n         * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,\n         * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics\n         */\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        /**\n         * Emits the JavaScript and declaration files.\n         * When targetSource file is specified, emits the files corresponding to that source file,\n         * otherwise for the whole program.\n         * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,\n         * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,\n         * it will only emit all the affected files instead of whole program\n         *\n         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host\n         * in that order would be used to write the files\n         */\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;\n        /**\n         * Get the current directory of the program\n         */\n        getCurrentDirectory(): string;\n    }\n    /**\n     * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files\n     */\n    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {\n        /**\n         * Gets the semantic diagnostics from the program for the next affected file and caches it\n         * Returns undefined if the iteration is complete\n         */\n        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;\n    }\n    /**\n     * The builder that can handle the changes in program and iterate through changed file to emit the files\n     * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files\n     */\n    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {\n        /**\n         * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete\n         * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host\n         * in that order would be used to write the files\n         */\n        emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;\n    }\n    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;\n    function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;\n    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;\n    /**\n     * Create the watch compiler host for either configFile or fileNames and its options\n     */\n    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;\n    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;\n    /**\n     * Creates the watch from the host for root files and compiler options\n     */\n    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;\n    /**\n     * Creates the watch from the host for config file\n     */\n    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;\n    interface ReadBuildProgramHost {\n        useCaseSensitiveFileNames(): boolean;\n        getCurrentDirectory(): string;\n        readFile(fileName: string): string | undefined;\n    }\n    interface IncrementalProgramOptions<T extends BuilderProgram> {\n        rootNames: readonly string[];\n        options: CompilerOptions;\n        configFileParsingDiagnostics?: readonly Diagnostic[];\n        projectReferences?: readonly ProjectReference[];\n        host?: CompilerHost;\n        createProgram?: CreateProgram<T>;\n    }\n    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;\n    /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */\n    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;\n    /** Host that has watch functionality used in --watch mode */\n    interface WatchHost {\n        /** If provided, called with Diagnostic message that informs about change in watch status */\n        onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;\n        /** Used to watch changes in source files, missing files needed to update the program or config file */\n        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;\n        /** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */\n        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;\n        /** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */\n        setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;\n        /** If provided, will be used to reset existing delayed compilation */\n        clearTimeout?(timeoutId: any): void;\n        preferNonRecursiveWatch?: boolean;\n    }\n    interface ProgramHost<T extends BuilderProgram> {\n        /**\n         * Used to create the program when need for program creation or recreation detected\n         */\n        createProgram: CreateProgram<T>;\n        useCaseSensitiveFileNames(): boolean;\n        getNewLine(): string;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        getDefaultLibLocation?(): string;\n        createHash?(data: string): string;\n        /**\n         * Use to check file presence for source files and\n         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well\n         */\n        fileExists(path: string): boolean;\n        /**\n         * Use to read file text for source files and\n         * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well\n         */\n        readFile(path: string, encoding?: string): string | undefined;\n        /** If provided, used for module resolution as well as to handle directory structure */\n        directoryExists?(path: string): boolean;\n        /** If provided, used in resolutions as well as handling directory structure */\n        getDirectories?(path: string): string[];\n        /** If provided, used to cache and handle directory structure modifications */\n        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        /** Symbol links resolution */\n        realpath?(path: string): string;\n        /** If provided would be used to write log about compilation */\n        trace?(s: string): void;\n        /** If provided is used to get the environment variable */\n        getEnvironmentVariable?(name: string): string | undefined;\n        /**\n         * @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext\n         *\n         * If provided, used to resolve the module names, otherwise typescript's default module resolution\n         */\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];\n        /**\n         * @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext\n         *\n         * If provided, used to resolve type reference directives, otherwise typescript's default resolution\n         */\n        resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];\n        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];\n        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];\n        /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */\n        hasInvalidatedResolutions?(filePath: Path): boolean;\n        /**\n         * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it\n         */\n        getModuleResolutionCache?(): ModuleResolutionCache | undefined;\n        jsDocParsingMode?: JSDocParsingMode;\n    }\n    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {\n        /** Instead of using output d.ts file from project reference, use its source file */\n        useSourceOfProjectReferenceRedirect?(): boolean;\n        /** If provided, use this method to get parsed command lines for referenced projects */\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        /** If provided, callback to invoke after every new program creation */\n        afterProgramCreate?(program: T): void;\n    }\n    /**\n     * Host to create watch with root files and options\n     */\n    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {\n        /** root files to use to generate program */\n        rootFiles: string[];\n        /** Compiler options */\n        options: CompilerOptions;\n        watchOptions?: WatchOptions;\n        /** Project References */\n        projectReferences?: readonly ProjectReference[];\n    }\n    /**\n     * Host to create watch with config file\n     */\n    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {\n        /** Name of the config file to compile */\n        configFileName: string;\n        /** Options to extend */\n        optionsToExtend?: CompilerOptions;\n        watchOptionsToExtend?: WatchOptions;\n        extraFileExtensions?: readonly FileExtensionInfo[];\n        /**\n         * Used to generate source file names from the config file and its include, exclude, files rules\n         * and also to cache the directory stucture\n         */\n        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n    }\n    interface Watch<T> {\n        /** Synchronize with host and get updated program */\n        getProgram(): T;\n        /** Closes the watch */\n        close(): void;\n    }\n    /**\n     * Creates the watch what generates program using the config file\n     */\n    interface WatchOfConfigFile<T> extends Watch<T> {\n    }\n    /**\n     * Creates the watch that generates program using the root files and compiler options\n     */\n    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {\n        /** Updates the root files in the program, only if this is not config file compilation */\n        updateRootFileNames(fileNames: string[]): void;\n    }\n    /**\n     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic\n     */\n    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;\n    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;\n    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;\n    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;\n    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;\n    interface BuildOptions {\n        dry?: boolean;\n        force?: boolean;\n        verbose?: boolean;\n        stopBuildOnErrors?: boolean;\n        incremental?: boolean;\n        assumeChangesOnlyAffectDirectDependencies?: boolean;\n        declaration?: boolean;\n        declarationMap?: boolean;\n        emitDeclarationOnly?: boolean;\n        sourceMap?: boolean;\n        inlineSourceMap?: boolean;\n        traceResolution?: boolean;\n        [option: string]: CompilerOptionsValue | undefined;\n    }\n    type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;\n    interface ReportFileInError {\n        fileName: string;\n        line: number;\n    }\n    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {\n        createDirectory?(path: string): void;\n        /**\n         * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with\n         * writeFileCallback\n         */\n        writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;\n        getCustomTransformers?: (project: string) => CustomTransformers | undefined;\n        getModifiedTime(fileName: string): Date | undefined;\n        setModifiedTime(fileName: string, date: Date): void;\n        deleteFile(fileName: string): void;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        reportDiagnostic: DiagnosticReporter;\n        reportSolutionBuilderStatus: DiagnosticReporter;\n        afterProgramEmitAndDiagnostics?(program: T): void;\n    }\n    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {\n        reportErrorSummary?: ReportEmitErrorSummary;\n    }\n    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {\n    }\n    interface SolutionBuilder<T extends BuilderProgram> {\n        build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;\n        clean(project?: string): ExitStatus;\n        buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;\n        cleanReferences(project?: string): ExitStatus;\n        getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;\n    }\n    enum InvalidatedProjectKind {\n        Build = 0,\n        UpdateOutputFileStamps = 1,\n    }\n    interface InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind;\n        readonly project: ResolvedConfigFileName;\n        /**\n         *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly\n         */\n        done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;\n        getCompilerOptions(): CompilerOptions;\n        getCurrentDirectory(): string;\n    }\n    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;\n        updateOutputFileStatmps(): void;\n    }\n    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {\n        readonly kind: InvalidatedProjectKind.Build;\n        getBuilderProgram(): T | undefined;\n        getProgram(): Program | undefined;\n        getSourceFile(fileName: string): SourceFile | undefined;\n        getSourceFiles(): readonly SourceFile[];\n        getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getConfigFileParsingDiagnostics(): readonly Diagnostic[];\n        getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getAllDependencies(sourceFile: SourceFile): readonly string[];\n        getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];\n        getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;\n        emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;\n    }\n    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T>;\n    /** Returns true if commandline is --build and needs to be parsed useing parseBuildCommand */\n    function isBuildCommand(commandLineArgs: readonly string[]): boolean;\n    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;\n    /**\n     * Represents an immutable snapshot of a script at a specified time.Once acquired, the\n     * snapshot is observably immutable. i.e. the same calls with the same parameters will return\n     * the same values.\n     */\n    interface IScriptSnapshot {\n        /** Gets a portion of the script snapshot specified by [start, end). */\n        getText(start: number, end: number): string;\n        /** Gets the length of this script snapshot. */\n        getLength(): number;\n        /**\n         * Gets the TextChangeRange that describe how the text changed between this text and\n         * an older version.  This information is used by the incremental parser to determine\n         * what sections of the script need to be re-parsed.  'undefined' can be returned if the\n         * change range cannot be determined.  However, in that case, incremental parsing will\n         * not happen and the entire document will be re - parsed.\n         */\n        getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;\n        /** Releases all resources held by this script snapshot */\n        dispose?(): void;\n    }\n    namespace ScriptSnapshot {\n        function fromString(text: string): IScriptSnapshot;\n    }\n    interface PreProcessedFileInfo {\n        referencedFiles: FileReference[];\n        typeReferenceDirectives: FileReference[];\n        libReferenceDirectives: FileReference[];\n        importedFiles: FileReference[];\n        ambientExternalModules?: string[];\n        isLibFile: boolean;\n    }\n    interface HostCancellationToken {\n        isCancellationRequested(): boolean;\n    }\n    interface InstallPackageOptions {\n        fileName: Path;\n        packageName: string;\n    }\n    interface PerformanceEvent {\n        kind: \"UpdateGraph\" | \"CreatePackageJsonAutoImportProvider\";\n        durationMs: number;\n    }\n    enum LanguageServiceMode {\n        Semantic = 0,\n        PartialSemantic = 1,\n        Syntactic = 2,\n    }\n    interface IncompleteCompletionsCache {\n        get(): CompletionInfo | undefined;\n        set(response: CompletionInfo): void;\n        clear(): void;\n    }\n    interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {\n        getCompilationSettings(): CompilerOptions;\n        getNewLine?(): string;\n        getProjectVersion?(): string;\n        getScriptFileNames(): string[];\n        getScriptKind?(fileName: string): ScriptKind;\n        getScriptVersion(fileName: string): string;\n        getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;\n        getProjectReferences?(): readonly ProjectReference[] | undefined;\n        getLocalizedDiagnosticMessages?(): any;\n        getCancellationToken?(): HostCancellationToken;\n        getCurrentDirectory(): string;\n        getDefaultLibFileName(options: CompilerOptions): string;\n        log?(s: string): void;\n        trace?(s: string): void;\n        error?(s: string): void;\n        useCaseSensitiveFileNames?(): boolean;\n        readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];\n        realpath?(path: string): string;\n        readFile(path: string, encoding?: string): string | undefined;\n        fileExists(path: string): boolean;\n        getTypeRootsVersion?(): number;\n        /** @deprecated supply resolveModuleNameLiterals instead for resolution that can handle newer resolution modes like nodenext */\n        resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];\n        getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ResolutionMode): ResolvedModuleWithFailedLookupLocations | undefined;\n        /** @deprecated supply resolveTypeReferenceDirectiveReferences instead for resolution that can handle newer resolution modes like nodenext */\n        resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: ResolutionMode): (ResolvedTypeReferenceDirective | undefined)[];\n        resolveModuleNameLiterals?(moduleLiterals: readonly StringLiteralLike[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile, reusedNames: readonly StringLiteralLike[] | undefined): readonly ResolvedModuleWithFailedLookupLocations[];\n        resolveTypeReferenceDirectiveReferences?<T extends FileReference | string>(typeDirectiveReferences: readonly T[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile: SourceFile | undefined, reusedNames: readonly T[] | undefined): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[];\n        getDirectories?(directoryName: string): string[];\n        /**\n         * Gets a set of custom transformers to use during emit.\n         */\n        getCustomTransformers?(): CustomTransformers | undefined;\n        isKnownTypesPackageName?(name: string): boolean;\n        installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;\n        writeFile?(fileName: string, content: string): void;\n        getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;\n        jsDocParsingMode?: JSDocParsingMode | undefined;\n    }\n    type WithMetadata<T> = T & {\n        metadata?: unknown;\n    };\n    enum SemanticClassificationFormat {\n        Original = \"original\",\n        TwentyTwenty = \"2020\",\n    }\n    interface LanguageService {\n        /** This is used as a part of restarting the language service. */\n        cleanupSemanticCache(): void;\n        /**\n         * Gets errors indicating invalid syntax in a file.\n         *\n         * In English, \"this cdeo have, erorrs\" is syntactically invalid because it has typos,\n         * grammatical errors, and misplaced punctuation. Likewise, examples of syntax\n         * errors in TypeScript are missing parentheses in an `if` statement, mismatched\n         * curly braces, and using a reserved keyword as a variable name.\n         *\n         * These diagnostics are inexpensive to compute and don't require knowledge of\n         * other files. Note that a non-empty result increases the likelihood of false positives\n         * from `getSemanticDiagnostics`.\n         *\n         * While these represent the majority of syntax-related diagnostics, there are some\n         * that require the type system, which will be present in `getSemanticDiagnostics`.\n         *\n         * @param fileName A path to the file you want syntactic diagnostics for\n         */\n        getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];\n        /**\n         * Gets warnings or errors indicating type system issues in a given file.\n         * Requesting semantic diagnostics may start up the type system and\n         * run deferred work, so the first call may take longer than subsequent calls.\n         *\n         * Unlike the other get*Diagnostics functions, these diagnostics can potentially not\n         * include a reference to a source file. Specifically, the first time this is called,\n         * it will return global diagnostics with no associated location.\n         *\n         * To contrast the differences between semantic and syntactic diagnostics, consider the\n         * sentence: \"The sun is green.\" is syntactically correct; those are real English words with\n         * correct sentence structure. However, it is semantically invalid, because it is not true.\n         *\n         * @param fileName A path to the file you want semantic diagnostics for\n         */\n        getSemanticDiagnostics(fileName: string): Diagnostic[];\n        /**\n         * Gets suggestion diagnostics for a specific file. These diagnostics tend to\n         * proactively suggest refactors, as opposed to diagnostics that indicate\n         * potentially incorrect runtime behavior.\n         *\n         * @param fileName A path to the file you want semantic diagnostics for\n         */\n        getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];\n        /**\n         * Gets global diagnostics related to the program configuration and compiler options.\n         */\n        getCompilerOptionsDiagnostics(): Diagnostic[];\n        /** @deprecated Use getEncodedSyntacticClassifications instead. */\n        getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n        getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];\n        /** @deprecated Use getEncodedSemanticClassifications instead. */\n        getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n        getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];\n        /** Encoded as triples of [start, length, ClassificationType]. */\n        getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;\n        /**\n         * Gets semantic highlights information for a particular file. Has two formats, an older\n         * version used by VS and a format used by VS Code.\n         *\n         * @param fileName The path to the file\n         * @param position A text span to return results within\n         * @param format Which format to use, defaults to \"original\"\n         * @returns a number array encoded as triples of [start, length, ClassificationType, ...].\n         */\n        getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;\n        /**\n         * Gets completion entries at a particular position in a file.\n         *\n         * @param fileName The path to the file\n         * @param position A zero-based index of the character where you want the entries\n         * @param options An object describing how the request was triggered and what kinds\n         * of code actions can be returned with the completions.\n         * @param formattingSettings settings needed for calling formatting functions.\n         */\n        getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata<CompletionInfo> | undefined;\n        /**\n         * Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.\n         *\n         * @param fileName The path to the file\n         * @param position A zero based index of the character where you want the entries\n         * @param entryName The `name` from an existing completion which came from `getCompletionsAtPosition`\n         * @param formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility\n         * @param source `source` property from the completion entry\n         * @param preferences User settings, can be undefined for backwards compatibility\n         * @param data `data` property from the completion entry\n         */\n        getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;\n        getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;\n        /**\n         * Gets semantic information about the identifier at a particular position in a\n         * file. Quick info is what you typically see when you hover in an editor.\n         *\n         * @param fileName The path to the file\n         * @param position A zero-based index of the character where you want the quick info\n         */\n        getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;\n        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;\n        getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;\n        getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;\n        getRenameInfo(fileName: string, position: number, preferences: UserPreferences): RenameInfo;\n        /** @deprecated Use the signature with `UserPreferences` instead. */\n        getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;\n        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, preferences: UserPreferences): readonly RenameLocation[] | undefined;\n        /** @deprecated Pass `providePrefixAndSuffixTextForRename` as part of a `UserPreferences` parameter. */\n        findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;\n        getSmartSelectionRange(fileName: string, position: number): SelectionRange;\n        getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;\n        getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;\n        getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;\n        getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;\n        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;\n        findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;\n        getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;\n        getFileReferences(fileName: string): ReferenceEntry[];\n        getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean, excludeLibFiles?: boolean): NavigateToItem[];\n        getNavigationBarItems(fileName: string): NavigationBarItem[];\n        getNavigationTree(fileName: string): NavigationTree;\n        prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;\n        provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];\n        provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];\n        provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];\n        getOutliningSpans(fileName: string): OutliningSpan[];\n        getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];\n        getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];\n        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;\n        getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];\n        getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions, formatOptions?: FormatCodeSettings): TextInsertion | undefined;\n        isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;\n        /**\n         * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.\n         * Editors should call this after `>` is typed.\n         */\n        getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;\n        getLinkedEditingRangeAtPosition(fileName: string, position: number): LinkedEditingInfo | undefined;\n        getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;\n        toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;\n        getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];\n        getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;\n        applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;\n        applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;\n        applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;\n        /** @deprecated `fileName` will be ignored */\n        applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;\n        /**\n         * @param includeInteractiveActions Include refactor actions that require additional arguments to be\n         * passed when calling `getEditsForRefactor`. When true, clients should inspect the `isInteractive`\n         * property of each returned `RefactorActionInfo` and ensure they are able to collect the appropriate\n         * arguments for any interactive action before offering it.\n         */\n        getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string, includeInteractiveActions?: boolean): ApplicableRefactorInfo[];\n        getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined, interactiveRefactorArguments?: InteractiveRefactorArguments): RefactorEditInfo | undefined;\n        getMoveToRefactoringFileSuggestions(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): {\n            newFileName: string;\n            files: string[];\n        };\n        organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];\n        getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];\n        getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;\n        getProgram(): Program | undefined;\n        toggleLineComment(fileName: string, textRange: TextRange): TextChange[];\n        toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];\n        commentSelection(fileName: string, textRange: TextRange): TextChange[];\n        uncommentSelection(fileName: string, textRange: TextRange): TextChange[];\n        getSupportedCodeFixes(fileName?: string): readonly string[];\n        dispose(): void;\n        preparePasteEditsForFile(fileName: string, copiedTextRanges: TextRange[]): boolean;\n        getPasteEdits(args: PasteEditsArgs, formatOptions: FormatCodeSettings): PasteEdits;\n    }\n    interface JsxClosingTagInfo {\n        readonly newText: string;\n    }\n    interface LinkedEditingInfo {\n        readonly ranges: TextSpan[];\n        wordPattern?: string;\n    }\n    interface CombinedCodeFixScope {\n        type: \"file\";\n        fileName: string;\n    }\n    enum OrganizeImportsMode {\n        All = \"All\",\n        SortAndCombine = \"SortAndCombine\",\n        RemoveUnused = \"RemoveUnused\",\n    }\n    interface PasteEdits {\n        edits: readonly FileTextChanges[];\n        fixId?: {};\n    }\n    interface PasteEditsArgs {\n        targetFile: string;\n        pastedText: string[];\n        pasteLocations: TextRange[];\n        copiedFrom: {\n            file: string;\n            range: TextRange[];\n        } | undefined;\n        preferences: UserPreferences;\n    }\n    interface OrganizeImportsArgs extends CombinedCodeFixScope {\n        /** @deprecated Use `mode` instead */\n        skipDestructiveCodeActions?: boolean;\n        mode?: OrganizeImportsMode;\n    }\n    type CompletionsTriggerCharacter = \".\" | '\"' | \"'\" | \"`\" | \"/\" | \"@\" | \"<\" | \"#\" | \" \";\n    enum CompletionTriggerKind {\n        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */\n        Invoked = 1,\n        /** Completion was triggered by a trigger character. */\n        TriggerCharacter = 2,\n        /** Completion was re-triggered as the current completion list is incomplete. */\n        TriggerForIncompleteCompletions = 3,\n    }\n    interface GetCompletionsAtPositionOptions extends UserPreferences {\n        /**\n         * If the editor is asking for completions because a certain character was typed\n         * (as opposed to when the user explicitly requested them) this should be set.\n         */\n        triggerCharacter?: CompletionsTriggerCharacter;\n        triggerKind?: CompletionTriggerKind;\n        /**\n         * Include a `symbol` property on each completion entry object.\n         * Symbols reference cyclic data structures and sometimes an entire TypeChecker instance,\n         * so use caution when serializing or retaining completion entries retrieved with this option.\n         * @default false\n         */\n        includeSymbol?: boolean;\n        /** @deprecated Use includeCompletionsForModuleExports */\n        includeExternalModuleExports?: boolean;\n        /** @deprecated Use includeCompletionsWithInsertText */\n        includeInsertTextCompletions?: boolean;\n    }\n    type SignatureHelpTriggerCharacter = \",\" | \"(\" | \"<\";\n    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | \")\";\n    interface SignatureHelpItemsOptions {\n        triggerReason?: SignatureHelpTriggerReason;\n    }\n    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;\n    /**\n     * Signals that the user manually requested signature help.\n     * The language service will unconditionally attempt to provide a result.\n     */\n    interface SignatureHelpInvokedReason {\n        kind: \"invoked\";\n        triggerCharacter?: undefined;\n    }\n    /**\n     * Signals that the signature help request came from a user typing a character.\n     * Depending on the character and the syntactic context, the request may or may not be served a result.\n     */\n    interface SignatureHelpCharacterTypedReason {\n        kind: \"characterTyped\";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter: SignatureHelpTriggerCharacter;\n    }\n    /**\n     * Signals that this signature help request came from typing a character or moving the cursor.\n     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.\n     * The language service will unconditionally attempt to provide a result.\n     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.\n     */\n    interface SignatureHelpRetriggeredReason {\n        kind: \"retrigger\";\n        /**\n         * Character that was responsible for triggering signature help.\n         */\n        triggerCharacter?: SignatureHelpRetriggerCharacter;\n    }\n    interface ApplyCodeActionCommandResult {\n        successMessage: string;\n    }\n    interface Classifications {\n        spans: number[];\n        endOfLineState: EndOfLineState;\n    }\n    interface ClassifiedSpan {\n        textSpan: TextSpan;\n        classificationType: ClassificationTypeNames;\n    }\n    interface ClassifiedSpan2020 {\n        textSpan: TextSpan;\n        classificationType: number;\n    }\n    /**\n     * Navigation bar interface designed for visual studio's dual-column layout.\n     * This does not form a proper tree.\n     * The navbar is returned as a list of top-level items, each of which has a list of child items.\n     * Child items always have an empty array for their `childItems`.\n     */\n    interface NavigationBarItem {\n        text: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        spans: TextSpan[];\n        childItems: NavigationBarItem[];\n        indent: number;\n        bolded: boolean;\n        grayed: boolean;\n    }\n    /**\n     * Node in a tree of nested declarations in a file.\n     * The top node is always a script or module node.\n     */\n    interface NavigationTree {\n        /** Name of the declaration, or a short description, e.g. \"<class>\". */\n        text: string;\n        kind: ScriptElementKind;\n        /** ScriptElementKindModifier separated by commas, e.g. \"public,abstract\" */\n        kindModifiers: string;\n        /**\n         * Spans of the nodes that generated this declaration.\n         * There will be more than one if this is the result of merging.\n         */\n        spans: TextSpan[];\n        nameSpan: TextSpan | undefined;\n        /** Present if non-empty */\n        childItems?: NavigationTree[];\n    }\n    interface CallHierarchyItem {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers?: string;\n        file: string;\n        span: TextSpan;\n        selectionSpan: TextSpan;\n        containerName?: string;\n    }\n    interface CallHierarchyIncomingCall {\n        from: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    interface CallHierarchyOutgoingCall {\n        to: CallHierarchyItem;\n        fromSpans: TextSpan[];\n    }\n    enum InlayHintKind {\n        Type = \"Type\",\n        Parameter = \"Parameter\",\n        Enum = \"Enum\",\n    }\n    interface InlayHint {\n        /** This property will be the empty string when displayParts is set. */\n        text: string;\n        position: number;\n        kind: InlayHintKind;\n        whitespaceBefore?: boolean;\n        whitespaceAfter?: boolean;\n        displayParts?: InlayHintDisplayPart[];\n    }\n    interface InlayHintDisplayPart {\n        text: string;\n        span?: TextSpan;\n        file?: string;\n    }\n    interface TodoCommentDescriptor {\n        text: string;\n        priority: number;\n    }\n    interface TodoComment {\n        descriptor: TodoCommentDescriptor;\n        message: string;\n        position: number;\n    }\n    interface TextChange {\n        span: TextSpan;\n        newText: string;\n    }\n    interface FileTextChanges {\n        fileName: string;\n        textChanges: readonly TextChange[];\n        isNewFile?: boolean;\n    }\n    interface CodeAction {\n        /** Description of the code action to display in the UI of the editor */\n        description: string;\n        /** Text changes to apply to each file as part of the code action */\n        changes: FileTextChanges[];\n        /**\n         * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.\n         * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.\n         */\n        commands?: CodeActionCommand[];\n    }\n    interface CodeFixAction extends CodeAction {\n        /** Short name to identify the fix, for use by telemetry. */\n        fixName: string;\n        /**\n         * If present, one may call 'getCombinedCodeFix' with this fixId.\n         * This may be omitted to indicate that the code fix can't be applied in a group.\n         */\n        fixId?: {};\n        fixAllDescription?: string;\n    }\n    interface CombinedCodeActions {\n        changes: readonly FileTextChanges[];\n        commands?: readonly CodeActionCommand[];\n    }\n    type CodeActionCommand = InstallPackageAction;\n    interface InstallPackageAction {\n    }\n    /**\n     * A set of one or more available refactoring actions, grouped under a parent refactoring.\n     */\n    interface ApplicableRefactorInfo {\n        /**\n         * The programmatic name of the refactoring\n         */\n        name: string;\n        /**\n         * A description of this refactoring category to show to the user.\n         * If the refactoring gets inlined (see below), this text will not be visible.\n         */\n        description: string;\n        /**\n         * Inlineable refactorings can have their actions hoisted out to the top level\n         * of a context menu. Non-inlineanable refactorings should always be shown inside\n         * their parent grouping.\n         *\n         * If not specified, this value is assumed to be 'true'\n         */\n        inlineable?: boolean;\n        actions: RefactorActionInfo[];\n    }\n    /**\n     * Represents a single refactoring action - for example, the \"Extract Method...\" refactor might\n     * offer several actions, each corresponding to a surround class or closure to extract into.\n     */\n    interface RefactorActionInfo {\n        /**\n         * The programmatic name of the refactoring action\n         */\n        name: string;\n        /**\n         * A description of this refactoring action to show to the user.\n         * If the parent refactoring is inlined away, this will be the only text shown,\n         * so this description should make sense by itself if the parent is inlineable=true\n         */\n        description: string;\n        /**\n         * A message to show to the user if the refactoring cannot be applied in\n         * the current context.\n         */\n        notApplicableReason?: string;\n        /**\n         * The hierarchical dotted name of the refactor action.\n         */\n        kind?: string;\n        /**\n         * Indicates that the action requires additional arguments to be passed\n         * when calling `getEditsForRefactor`.\n         */\n        isInteractive?: boolean;\n        /**\n         * Range of code the refactoring will be applied to.\n         */\n        range?: {\n            start: {\n                line: number;\n                offset: number;\n            };\n            end: {\n                line: number;\n                offset: number;\n            };\n        };\n    }\n    /**\n     * A set of edits to make in response to a refactor action, plus an optional\n     * location where renaming should be invoked from\n     */\n    interface RefactorEditInfo {\n        edits: FileTextChanges[];\n        renameFilename?: string;\n        renameLocation?: number;\n        commands?: CodeActionCommand[];\n        notApplicableReason?: string;\n    }\n    type RefactorTriggerReason = \"implicit\" | \"invoked\";\n    interface TextInsertion {\n        newText: string;\n        /** The position in newText the caret should point to after the insertion. */\n        caretOffset: number;\n    }\n    interface DocumentSpan {\n        textSpan: TextSpan;\n        fileName: string;\n        /**\n         * If the span represents a location that was remapped (e.g. via a .d.ts.map file),\n         * then the original filename and span will be specified here\n         */\n        originalTextSpan?: TextSpan;\n        originalFileName?: string;\n        /**\n         * If DocumentSpan.textSpan is the span for name of the declaration,\n         * then this is the span for relevant declaration\n         */\n        contextSpan?: TextSpan;\n        originalContextSpan?: TextSpan;\n    }\n    interface RenameLocation extends DocumentSpan {\n        readonly prefixText?: string;\n        readonly suffixText?: string;\n    }\n    interface ReferenceEntry extends DocumentSpan {\n        isWriteAccess: boolean;\n        isInString?: true;\n    }\n    interface ImplementationLocation extends DocumentSpan {\n        kind: ScriptElementKind;\n        displayParts: SymbolDisplayPart[];\n    }\n    enum HighlightSpanKind {\n        none = \"none\",\n        definition = \"definition\",\n        reference = \"reference\",\n        writtenReference = \"writtenReference\",\n    }\n    interface HighlightSpan {\n        fileName?: string;\n        isInString?: true;\n        textSpan: TextSpan;\n        contextSpan?: TextSpan;\n        kind: HighlightSpanKind;\n    }\n    interface NavigateToItem {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        matchKind: \"exact\" | \"prefix\" | \"substring\" | \"camelCase\";\n        isCaseSensitive: boolean;\n        fileName: string;\n        textSpan: TextSpan;\n        containerName: string;\n        containerKind: ScriptElementKind;\n    }\n    enum IndentStyle {\n        None = 0,\n        Block = 1,\n        Smart = 2,\n    }\n    enum SemicolonPreference {\n        Ignore = \"ignore\",\n        Insert = \"insert\",\n        Remove = \"remove\",\n    }\n    /** @deprecated - consider using EditorSettings instead */\n    interface EditorOptions {\n        BaseIndentSize?: number;\n        IndentSize: number;\n        TabSize: number;\n        NewLineCharacter: string;\n        ConvertTabsToSpaces: boolean;\n        IndentStyle: IndentStyle;\n    }\n    interface EditorSettings {\n        baseIndentSize?: number;\n        indentSize?: number;\n        tabSize?: number;\n        newLineCharacter?: string;\n        convertTabsToSpaces?: boolean;\n        indentStyle?: IndentStyle;\n        trimTrailingWhitespace?: boolean;\n    }\n    /** @deprecated - consider using FormatCodeSettings instead */\n    interface FormatCodeOptions extends EditorOptions {\n        InsertSpaceAfterCommaDelimiter: boolean;\n        InsertSpaceAfterSemicolonInForStatements: boolean;\n        InsertSpaceBeforeAndAfterBinaryOperators: boolean;\n        InsertSpaceAfterConstructor?: boolean;\n        InsertSpaceAfterKeywordsInControlFlowStatements: boolean;\n        InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;\n        InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        InsertSpaceAfterTypeAssertion?: boolean;\n        InsertSpaceBeforeFunctionParenthesis?: boolean;\n        PlaceOpenBraceOnNewLineForFunctions: boolean;\n        PlaceOpenBraceOnNewLineForControlBlocks: boolean;\n        insertSpaceBeforeTypeAnnotation?: boolean;\n    }\n    interface FormatCodeSettings extends EditorSettings {\n        readonly insertSpaceAfterCommaDelimiter?: boolean;\n        readonly insertSpaceAfterSemicolonInForStatements?: boolean;\n        readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;\n        readonly insertSpaceAfterConstructor?: boolean;\n        readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;\n        readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;\n        readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;\n        readonly insertSpaceAfterTypeAssertion?: boolean;\n        readonly insertSpaceBeforeFunctionParenthesis?: boolean;\n        readonly placeOpenBraceOnNewLineForFunctions?: boolean;\n        readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;\n        readonly insertSpaceBeforeTypeAnnotation?: boolean;\n        readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;\n        readonly semicolons?: SemicolonPreference;\n        readonly indentSwitchCase?: boolean;\n    }\n    interface DefinitionInfo extends DocumentSpan {\n        kind: ScriptElementKind;\n        name: string;\n        containerKind: ScriptElementKind;\n        containerName: string;\n        unverified?: boolean;\n    }\n    interface DefinitionInfoAndBoundSpan {\n        definitions?: readonly DefinitionInfo[];\n        textSpan: TextSpan;\n    }\n    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {\n        displayParts: SymbolDisplayPart[];\n    }\n    interface ReferencedSymbol {\n        definition: ReferencedSymbolDefinitionInfo;\n        references: ReferencedSymbolEntry[];\n    }\n    interface ReferencedSymbolEntry extends ReferenceEntry {\n        isDefinition?: boolean;\n    }\n    enum SymbolDisplayPartKind {\n        aliasName = 0,\n        className = 1,\n        enumName = 2,\n        fieldName = 3,\n        interfaceName = 4,\n        keyword = 5,\n        lineBreak = 6,\n        numericLiteral = 7,\n        stringLiteral = 8,\n        localName = 9,\n        methodName = 10,\n        moduleName = 11,\n        operator = 12,\n        parameterName = 13,\n        propertyName = 14,\n        punctuation = 15,\n        space = 16,\n        text = 17,\n        typeParameterName = 18,\n        enumMemberName = 19,\n        functionName = 20,\n        regularExpressionLiteral = 21,\n        link = 22,\n        linkName = 23,\n        linkText = 24,\n    }\n    interface SymbolDisplayPart {\n        /**\n         * Text of an item describing the symbol.\n         */\n        text: string;\n        /**\n         * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').\n         */\n        kind: string;\n    }\n    interface JSDocLinkDisplayPart extends SymbolDisplayPart {\n        target: DocumentSpan;\n    }\n    interface JSDocTagInfo {\n        name: string;\n        text?: SymbolDisplayPart[];\n    }\n    interface QuickInfo {\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        textSpan: TextSpan;\n        displayParts?: SymbolDisplayPart[];\n        documentation?: SymbolDisplayPart[];\n        tags?: JSDocTagInfo[];\n    }\n    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;\n    interface RenameInfoSuccess {\n        canRename: true;\n        /**\n         * File or directory to rename.\n         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.\n         */\n        fileToRename?: string;\n        displayName: string;\n        /**\n         * Full display name of item to be renamed.\n         * If item to be renamed is a file, then this is the original text of the module specifer\n         */\n        fullDisplayName: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        triggerSpan: TextSpan;\n    }\n    interface RenameInfoFailure {\n        canRename: false;\n        localizedErrorMessage: string;\n    }\n    /**\n     * @deprecated Use `UserPreferences` instead.\n     */\n    interface RenameInfoOptions {\n        readonly allowRenameOfImportPath?: boolean;\n    }\n    interface DocCommentTemplateOptions {\n        readonly generateReturnInDocTemplate?: boolean;\n    }\n    interface InteractiveRefactorArguments {\n        targetFile: string;\n    }\n    /**\n     * Signature help information for a single parameter\n     */\n    interface SignatureHelpParameter {\n        name: string;\n        documentation: SymbolDisplayPart[];\n        displayParts: SymbolDisplayPart[];\n        isOptional: boolean;\n        isRest?: boolean;\n    }\n    interface SelectionRange {\n        textSpan: TextSpan;\n        parent?: SelectionRange;\n    }\n    /**\n     * Represents a single signature to show in signature help.\n     * The id is used for subsequent calls into the language service to ask questions about the\n     * signature help item in the context of any documents that have been updated.  i.e. after\n     * an edit has happened, while signature help is still active, the host can ask important\n     * questions like 'what parameter is the user currently contained within?'.\n     */\n    interface SignatureHelpItem {\n        isVariadic: boolean;\n        prefixDisplayParts: SymbolDisplayPart[];\n        suffixDisplayParts: SymbolDisplayPart[];\n        separatorDisplayParts: SymbolDisplayPart[];\n        parameters: SignatureHelpParameter[];\n        documentation: SymbolDisplayPart[];\n        tags: JSDocTagInfo[];\n    }\n    /**\n     * Represents a set of signature help items, and the preferred item that should be selected.\n     */\n    interface SignatureHelpItems {\n        items: SignatureHelpItem[];\n        applicableSpan: TextSpan;\n        selectedItemIndex: number;\n        argumentIndex: number;\n        argumentCount: number;\n    }\n    enum CompletionInfoFlags {\n        None = 0,\n        MayIncludeAutoImports = 1,\n        IsImportStatementCompletion = 2,\n        IsContinuation = 4,\n        ResolvedModuleSpecifiers = 8,\n        ResolvedModuleSpecifiersBeyondLimit = 16,\n        MayIncludeMethodSnippets = 32,\n    }\n    interface CompletionInfo {\n        /** For performance telemetry. */\n        flags?: CompletionInfoFlags;\n        /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */\n        isGlobalCompletion: boolean;\n        isMemberCompletion: boolean;\n        /**\n         * In the absence of `CompletionEntry[\"replacementSpan\"]`, the editor may choose whether to use\n         * this span or its default one. If `CompletionEntry[\"replacementSpan\"]` is defined, that span\n         * must be used to commit that completion entry.\n         */\n        optionalReplacementSpan?: TextSpan;\n        /**\n         * true when the current location also allows for a new identifier\n         */\n        isNewIdentifierLocation: boolean;\n        /**\n         * Indicates to client to continue requesting completions on subsequent keystrokes.\n         */\n        isIncomplete?: true;\n        entries: CompletionEntry[];\n        /**\n         * Default commit characters for the completion entries.\n         */\n        defaultCommitCharacters?: string[];\n    }\n    interface CompletionEntryDataAutoImport {\n        /**\n         * The name of the property or export in the module's symbol table. Differs from the completion name\n         * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.\n         */\n        exportName: string;\n        exportMapKey?: ExportMapInfoKey;\n        moduleSpecifier?: string;\n        /** The file name declaring the export's module symbol, if it was an external module */\n        fileName?: string;\n        /** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */\n        ambientModuleName?: string;\n        /** True if the export was found in the package.json AutoImportProvider */\n        isPackageJsonImport?: true;\n    }\n    interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {\n        exportMapKey: ExportMapInfoKey;\n    }\n    interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {\n        moduleSpecifier: string;\n    }\n    type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;\n    interface CompletionEntry {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers?: string;\n        /**\n         * A string that is used for comparing completion items so that they can be ordered. This\n         * is often the same as the name but may be different in certain circumstances.\n         */\n        sortText: string;\n        /**\n         * Text to insert instead of `name`.\n         * This is used to support bracketed completions; If `name` might be \"a-b\" but `insertText` would be `[\"a-b\"]`,\n         * coupled with `replacementSpan` to replace a dotted access with a bracket access.\n         */\n        insertText?: string;\n        /**\n         * A string that should be used when filtering a set of\n         * completion items.\n         */\n        filterText?: string;\n        /**\n         * `insertText` should be interpreted as a snippet if true.\n         */\n        isSnippet?: true;\n        /**\n         * An optional span that indicates the text to be replaced by this completion item.\n         * If present, this span should be used instead of the default one.\n         * It will be set if the required span differs from the one generated by the default replacement behavior.\n         */\n        replacementSpan?: TextSpan;\n        /**\n         * Indicates whether commiting this completion entry will require additional code actions to be\n         * made to avoid errors. The CompletionEntryDetails will have these actions.\n         */\n        hasAction?: true;\n        /**\n         * Identifier (not necessarily human-readable) identifying where this completion came from.\n         */\n        source?: string;\n        /**\n         * Human-readable description of the `source`.\n         */\n        sourceDisplay?: SymbolDisplayPart[];\n        /**\n         * Additional details for the label.\n         */\n        labelDetails?: CompletionEntryLabelDetails;\n        /**\n         * If true, this completion should be highlighted as recommended. There will only be one of these.\n         * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.\n         * Then either that enum/class or a namespace containing it will be the recommended symbol.\n         */\n        isRecommended?: true;\n        /**\n         * If true, this completion was generated from traversing the name table of an unchecked JS file,\n         * and therefore may not be accurate.\n         */\n        isFromUncheckedFile?: true;\n        /**\n         * If true, this completion was for an auto-import of a module not yet in the program, but listed\n         * in the project package.json. Used for telemetry reporting.\n         */\n        isPackageJsonImport?: true;\n        /**\n         * If true, this completion was an auto-import-style completion of an import statement (i.e., the\n         * module specifier was inserted along with the imported identifier). Used for telemetry reporting.\n         */\n        isImportStatementCompletion?: true;\n        /**\n         * For API purposes.\n         * Included for non-string completions only when `includeSymbol: true` option is passed to `getCompletionsAtPosition`.\n         * @example Get declaration of completion: `symbol.valueDeclaration`\n         */\n        symbol?: Symbol;\n        /**\n         * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,\n         * that allows TS Server to look up the symbol represented by the completion item, disambiguating\n         * items with the same name. Currently only defined for auto-import completions, but the type is\n         * `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.\n         * The presence of this property should generally not be used to assume that this completion entry\n         * is an auto-import.\n         */\n        data?: CompletionEntryData;\n        /**\n         * If this completion entry is selected, typing a commit character will cause the entry to be accepted.\n         */\n        commitCharacters?: string[];\n    }\n    interface CompletionEntryLabelDetails {\n        /**\n         * An optional string which is rendered less prominently directly after\n         * {@link CompletionEntry.name name}, without any spacing. Should be\n         * used for function signatures or type annotations.\n         */\n        detail?: string;\n        /**\n         * An optional string which is rendered less prominently after\n         * {@link CompletionEntryLabelDetails.detail}. Should be used for fully qualified\n         * names or file path.\n         */\n        description?: string;\n    }\n    interface CompletionEntryDetails {\n        name: string;\n        kind: ScriptElementKind;\n        kindModifiers: string;\n        displayParts: SymbolDisplayPart[];\n        documentation?: SymbolDisplayPart[];\n        tags?: JSDocTagInfo[];\n        codeActions?: CodeAction[];\n        /** @deprecated Use `sourceDisplay` instead. */\n        source?: SymbolDisplayPart[];\n        sourceDisplay?: SymbolDisplayPart[];\n    }\n    interface OutliningSpan {\n        /** The span of the document to actually collapse. */\n        textSpan: TextSpan;\n        /** The span of the document to display when the user hovers over the collapsed span. */\n        hintSpan: TextSpan;\n        /** The text to display in the editor for the collapsed region. */\n        bannerText: string;\n        /**\n         * Whether or not this region should be automatically collapsed when\n         * the 'Collapse to Definitions' command is invoked.\n         */\n        autoCollapse: boolean;\n        /**\n         * Classification of the contents of the span\n         */\n        kind: OutliningSpanKind;\n    }\n    enum OutliningSpanKind {\n        /** Single or multi-line comments */\n        Comment = \"comment\",\n        /** Sections marked by '// #region' and '// #endregion' comments */\n        Region = \"region\",\n        /** Declarations and expressions */\n        Code = \"code\",\n        /** Contiguous blocks of import declarations */\n        Imports = \"imports\",\n    }\n    enum OutputFileType {\n        JavaScript = 0,\n        SourceMap = 1,\n        Declaration = 2,\n    }\n    enum EndOfLineState {\n        None = 0,\n        InMultiLineCommentTrivia = 1,\n        InSingleQuoteStringLiteral = 2,\n        InDoubleQuoteStringLiteral = 3,\n        InTemplateHeadOrNoSubstitutionTemplate = 4,\n        InTemplateMiddleOrTail = 5,\n        InTemplateSubstitutionPosition = 6,\n    }\n    enum TokenClass {\n        Punctuation = 0,\n        Keyword = 1,\n        Operator = 2,\n        Comment = 3,\n        Whitespace = 4,\n        Identifier = 5,\n        NumberLiteral = 6,\n        BigIntLiteral = 7,\n        StringLiteral = 8,\n        RegExpLiteral = 9,\n    }\n    interface ClassificationResult {\n        finalLexState: EndOfLineState;\n        entries: ClassificationInfo[];\n    }\n    interface ClassificationInfo {\n        length: number;\n        classification: TokenClass;\n    }\n    interface Classifier {\n        /**\n         * Gives lexical classifications of tokens on a line without any syntactic context.\n         * For instance, a token consisting of the text 'string' can be either an identifier\n         * named 'string' or the keyword 'string', however, because this classifier is not aware,\n         * it relies on certain heuristics to give acceptable results. For classifications where\n         * speed trumps accuracy, this function is preferable; however, for true accuracy, the\n         * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the\n         * lexical, syntactic, and semantic classifiers may issue the best user experience.\n         *\n         * @param text                      The text of a line to classify.\n         * @param lexState                  The state of the lexical classifier at the end of the previous line.\n         * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.\n         *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),\n         *                                  certain heuristics may be used in its place; however, if there is a\n         *                                  syntactic classifier (syntacticClassifierAbsent=false), certain\n         *                                  classifications which may be incorrectly categorized will be given\n         *                                  back as Identifiers in order to allow the syntactic classifier to\n         *                                  subsume the classification.\n         * @deprecated Use getLexicalClassifications instead.\n         */\n        getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;\n        getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;\n    }\n    enum ScriptElementKind {\n        unknown = \"\",\n        warning = \"warning\",\n        /** predefined type (void) or keyword (class) */\n        keyword = \"keyword\",\n        /** top level script node */\n        scriptElement = \"script\",\n        /** module foo {} */\n        moduleElement = \"module\",\n        /** class X {} */\n        classElement = \"class\",\n        /** var x = class X {} */\n        localClassElement = \"local class\",\n        /** interface Y {} */\n        interfaceElement = \"interface\",\n        /** type T = ... */\n        typeElement = \"type\",\n        /** enum E */\n        enumElement = \"enum\",\n        enumMemberElement = \"enum member\",\n        /**\n         * Inside module and script only\n         * const v = ..\n         */\n        variableElement = \"var\",\n        /** Inside function */\n        localVariableElement = \"local var\",\n        /** using foo = ... */\n        variableUsingElement = \"using\",\n        /** await using foo = ... */\n        variableAwaitUsingElement = \"await using\",\n        /**\n         * Inside module and script only\n         * function f() { }\n         */\n        functionElement = \"function\",\n        /** Inside function */\n        localFunctionElement = \"local function\",\n        /** class X { [public|private]* foo() {} } */\n        memberFunctionElement = \"method\",\n        /** class X { [public|private]* [get|set] foo:number; } */\n        memberGetAccessorElement = \"getter\",\n        memberSetAccessorElement = \"setter\",\n        /**\n         * class X { [public|private]* foo:number; }\n         * interface Y { foo:number; }\n         */\n        memberVariableElement = \"property\",\n        /** class X { [public|private]* accessor foo: number; } */\n        memberAccessorVariableElement = \"accessor\",\n        /**\n         * class X { constructor() { } }\n         * class X { static { } }\n         */\n        constructorImplementationElement = \"constructor\",\n        /** interface Y { ():number; } */\n        callSignatureElement = \"call\",\n        /** interface Y { []:number; } */\n        indexSignatureElement = \"index\",\n        /** interface Y { new():Y; } */\n        constructSignatureElement = \"construct\",\n        /** function foo(*Y*: string) */\n        parameterElement = \"parameter\",\n        typeParameterElement = \"type parameter\",\n        primitiveType = \"primitive type\",\n        label = \"label\",\n        alias = \"alias\",\n        constElement = \"const\",\n        letElement = \"let\",\n        directory = \"directory\",\n        externalModuleName = \"external module name\",\n        /**\n         * <JsxTagName attribute1 attribute2={0} />\n         * @deprecated\n         */\n        jsxAttribute = \"JSX attribute\",\n        /** String literal */\n        string = \"string\",\n        /** Jsdoc @link: in `{@link C link text}`, the before and after text \"{@link \" and \"}\" */\n        link = \"link\",\n        /** Jsdoc @link: in `{@link C link text}`, the entity name \"C\" */\n        linkName = \"link name\",\n        /** Jsdoc @link: in `{@link C link text}`, the link text \"link text\" */\n        linkText = \"link text\",\n    }\n    enum ScriptElementKindModifier {\n        none = \"\",\n        publicMemberModifier = \"public\",\n        privateMemberModifier = \"private\",\n        protectedMemberModifier = \"protected\",\n        exportedModifier = \"export\",\n        ambientModifier = \"declare\",\n        staticModifier = \"static\",\n        abstractModifier = \"abstract\",\n        optionalModifier = \"optional\",\n        deprecatedModifier = \"deprecated\",\n        dtsModifier = \".d.ts\",\n        tsModifier = \".ts\",\n        tsxModifier = \".tsx\",\n        jsModifier = \".js\",\n        jsxModifier = \".jsx\",\n        jsonModifier = \".json\",\n        dmtsModifier = \".d.mts\",\n        mtsModifier = \".mts\",\n        mjsModifier = \".mjs\",\n        dctsModifier = \".d.cts\",\n        ctsModifier = \".cts\",\n        cjsModifier = \".cjs\",\n    }\n    enum ClassificationTypeNames {\n        comment = \"comment\",\n        identifier = \"identifier\",\n        keyword = \"keyword\",\n        numericLiteral = \"number\",\n        bigintLiteral = \"bigint\",\n        operator = \"operator\",\n        stringLiteral = \"string\",\n        whiteSpace = \"whitespace\",\n        text = \"text\",\n        punctuation = \"punctuation\",\n        className = \"class name\",\n        enumName = \"enum name\",\n        interfaceName = \"interface name\",\n        moduleName = \"module name\",\n        typeParameterName = \"type parameter name\",\n        typeAliasName = \"type alias name\",\n        parameterName = \"parameter name\",\n        docCommentTagName = \"doc comment tag name\",\n        jsxOpenTagName = \"jsx open tag name\",\n        jsxCloseTagName = \"jsx close tag name\",\n        jsxSelfClosingTagName = \"jsx self closing tag name\",\n        jsxAttribute = \"jsx attribute\",\n        jsxText = \"jsx text\",\n        jsxAttributeStringLiteralValue = \"jsx attribute string literal value\",\n    }\n    enum ClassificationType {\n        comment = 1,\n        identifier = 2,\n        keyword = 3,\n        numericLiteral = 4,\n        operator = 5,\n        stringLiteral = 6,\n        regularExpressionLiteral = 7,\n        whiteSpace = 8,\n        text = 9,\n        punctuation = 10,\n        className = 11,\n        enumName = 12,\n        interfaceName = 13,\n        moduleName = 14,\n        typeParameterName = 15,\n        typeAliasName = 16,\n        parameterName = 17,\n        docCommentTagName = 18,\n        jsxOpenTagName = 19,\n        jsxCloseTagName = 20,\n        jsxSelfClosingTagName = 21,\n        jsxAttribute = 22,\n        jsxText = 23,\n        jsxAttributeStringLiteralValue = 24,\n        bigintLiteral = 25,\n    }\n    interface InlayHintsContext {\n        file: SourceFile;\n        program: Program;\n        cancellationToken: CancellationToken;\n        host: LanguageServiceHost;\n        span: TextSpan;\n        preferences: UserPreferences;\n    }\n    type ExportMapInfoKey = string & {\n        __exportInfoKey: void;\n    };\n    /** The classifier is used for syntactic highlighting in editors via the TSServer */\n    function createClassifier(): Classifier;\n    interface DocumentHighlights {\n        fileName: string;\n        highlightSpans: HighlightSpan[];\n    }\n    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string, jsDocParsingMode?: JSDocParsingMode): DocumentRegistry;\n    /**\n     * The document registry represents a store of SourceFile objects that can be shared between\n     * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)\n     * of files in the context.\n     * SourceFile objects account for most of the memory usage by the language service. Sharing\n     * the same DocumentRegistry instance between different instances of LanguageService allow\n     * for more efficient memory utilization since all projects will share at least the library\n     * file (lib.d.ts).\n     *\n     * A more advanced use of the document registry is to serialize sourceFile objects to disk\n     * and re-hydrate them when needed.\n     *\n     * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it\n     * to all subsequent createLanguageService calls.\n     */\n    interface DocumentRegistry {\n        /**\n         * Request a stored SourceFile with a given fileName and compilationSettings.\n         * The first call to acquire will call createLanguageServiceSourceFile to generate\n         * the SourceFile if was not found in the registry.\n         *\n         * @param fileName The name of the file requested\n         * @param compilationSettingsOrHost Some compilation settings like target affects the\n         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store\n         * multiple copies of the same file for different compilation settings. A minimal\n         * resolution cache is needed to fully define a source file's shape when\n         * the compilation settings include `module: node16`+, so providing a cache host\n         * object should be preferred. A common host is a language service `ConfiguredProject`.\n         * @param scriptSnapshot Text of the file. Only used if the file was not found\n         * in the registry and a new one was created.\n         * @param version Current version of the file. Only used if the file was not found\n         * in the registry and a new one was created.\n         */\n        acquireDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;\n        acquireDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;\n        /**\n         * Request an updated version of an already existing SourceFile with a given fileName\n         * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile\n         * to get an updated SourceFile.\n         *\n         * @param fileName The name of the file requested\n         * @param compilationSettingsOrHost Some compilation settings like target affects the\n         * shape of a the resulting SourceFile. This allows the DocumentRegistry to store\n         * multiple copies of the same file for different compilation settings. A minimal\n         * resolution cache is needed to fully define a source file's shape when\n         * the compilation settings include `module: node16`+, so providing a cache host\n         * object should be preferred. A common host is a language service `ConfiguredProject`.\n         * @param scriptSnapshot Text of the file.\n         * @param version Current version of the file.\n         */\n        updateDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;\n        updateDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;\n        getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;\n        /**\n         * Informs the DocumentRegistry that a file is not needed any longer.\n         *\n         * Note: It is not allowed to call release on a SourceFile that was not acquired from\n         * this registry originally.\n         *\n         * @param fileName The name of the file to be released\n         * @param compilationSettings The compilation settings used to acquire the file\n         * @param scriptKind The script kind of the file to be released\n         *\n         * @deprecated pass scriptKind and impliedNodeFormat for correctness\n         */\n        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;\n        /**\n         * Informs the DocumentRegistry that a file is not needed any longer.\n         *\n         * Note: It is not allowed to call release on a SourceFile that was not acquired from\n         * this registry originally.\n         *\n         * @param fileName The name of the file to be released\n         * @param compilationSettings The compilation settings used to acquire the file\n         * @param scriptKind The script kind of the file to be released\n         * @param impliedNodeFormat The implied source file format of the file to be released\n         */\n        releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;\n        /**\n         * @deprecated pass scriptKind for and impliedNodeFormat correctness */\n        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): void;\n        releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: ResolutionMode): void;\n        reportStats(): string;\n    }\n    type DocumentRegistryBucketKey = string & {\n        __bucketKey: any;\n    };\n    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;\n    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;\n    function transpileDeclaration(input: string, transpileOptions: TranspileOptions): TranspileOutput;\n    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;\n    interface TranspileOptions {\n        compilerOptions?: CompilerOptions;\n        fileName?: string;\n        reportDiagnostics?: boolean;\n        moduleName?: string;\n        renamedDependencies?: MapLike<string>;\n        transformers?: CustomTransformers;\n        jsDocParsingMode?: JSDocParsingMode;\n    }\n    interface TranspileOutput {\n        outputText: string;\n        diagnostics?: Diagnostic[];\n        sourceMapText?: string;\n    }\n    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;\n    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;\n    function getDefaultCompilerOptions(): CompilerOptions;\n    function getSupportedCodeFixes(): readonly string[];\n    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;\n    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;\n    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;\n    /**\n     * Get the path of the default library files (lib.d.ts) as distributed with the typescript\n     * node package.\n     * The functionality is not supported if the ts module is consumed outside of a node module.\n     */\n    function getDefaultLibFilePath(options: CompilerOptions): string;\n    /** The version of the language service API */\n    const servicesVersion = \"0.8\";\n    /**\n     * Transform one or more nodes using the supplied transformers.\n     * @param source A single `Node` or an array of `Node` objects.\n     * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.\n     * @param compilerOptions Optional compiler options.\n     */\n    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;\n}\nexport = ts;\n"
        }
    ]
}