{
    "sourceFile": "node_modules/typescript/lib/_typingsInstaller.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893079198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n\n\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// src/typingsInstaller/nodeTypingsInstaller.ts\nvar import_child_process = require(\"child_process\");\nvar fs = __toESM(require(\"fs\"));\nvar path = __toESM(require(\"path\"));\n\n// src/typescript/typescript.ts\nvar typescript_exports = {};\n__reExport(typescript_exports, require(\"./typescript.js\"));\n\n// src/typingsInstaller/nodeTypingsInstaller.ts\nvar FileLog = class {\n  constructor(logFile) {\n    this.logFile = logFile;\n    this.isEnabled = () => {\n      return typeof this.logFile === \"string\";\n    };\n    this.writeLine = (text) => {\n      if (typeof this.logFile !== \"string\") return;\n      try {\n        fs.appendFileSync(this.logFile, `[${typescript_exports.server.nowString()}] ${text}${typescript_exports.sys.newLine}`);\n      } catch {\n        this.logFile = void 0;\n      }\n    };\n  }\n};\nfunction getDefaultNPMLocation(processName, validateDefaultNpmLocation2, host) {\n  if (path.basename(processName).indexOf(\"node\") === 0) {\n    const npmPath = path.join(path.dirname(process.argv[0]), \"npm\");\n    if (!validateDefaultNpmLocation2) {\n      return npmPath;\n    }\n    if (host.fileExists(npmPath)) {\n      return `\"${npmPath}\"`;\n    }\n  }\n  return \"npm\";\n}\nfunction loadTypesRegistryFile(typesRegistryFilePath, host, log2) {\n  if (!host.fileExists(typesRegistryFilePath)) {\n    if (log2.isEnabled()) {\n      log2.writeLine(`Types registry file '${typesRegistryFilePath}' does not exist`);\n    }\n    return /* @__PURE__ */ new Map();\n  }\n  try {\n    const content = JSON.parse(host.readFile(typesRegistryFilePath));\n    return new Map(Object.entries(content.entries));\n  } catch (e) {\n    if (log2.isEnabled()) {\n      log2.writeLine(`Error when loading types registry file '${typesRegistryFilePath}': ${e.message}, ${e.stack}`);\n    }\n    return /* @__PURE__ */ new Map();\n  }\n}\nvar typesRegistryPackageName = \"types-registry\";\nfunction getTypesRegistryFileLocation(globalTypingsCacheLocation2) {\n  return (0, typescript_exports.combinePaths)((0, typescript_exports.normalizeSlashes)(globalTypingsCacheLocation2), `node_modules/${typesRegistryPackageName}/index.json`);\n}\nvar NodeTypingsInstaller = class extends typescript_exports.server.typingsInstaller.TypingsInstaller {\n  constructor(globalTypingsCacheLocation2, typingSafeListLocation2, typesMapLocation2, npmLocation2, validateDefaultNpmLocation2, throttleLimit, log2) {\n    const libDirectory = (0, typescript_exports.getDirectoryPath)((0, typescript_exports.normalizePath)(typescript_exports.sys.getExecutingFilePath()));\n    super(\n      typescript_exports.sys,\n      globalTypingsCacheLocation2,\n      typingSafeListLocation2 ? (0, typescript_exports.toPath)(typingSafeListLocation2, \"\", (0, typescript_exports.createGetCanonicalFileName)(typescript_exports.sys.useCaseSensitiveFileNames)) : (0, typescript_exports.toPath)(\"typingSafeList.json\", libDirectory, (0, typescript_exports.createGetCanonicalFileName)(typescript_exports.sys.useCaseSensitiveFileNames)),\n      typesMapLocation2 ? (0, typescript_exports.toPath)(typesMapLocation2, \"\", (0, typescript_exports.createGetCanonicalFileName)(typescript_exports.sys.useCaseSensitiveFileNames)) : (0, typescript_exports.toPath)(\"typesMap.json\", libDirectory, (0, typescript_exports.createGetCanonicalFileName)(typescript_exports.sys.useCaseSensitiveFileNames)),\n      throttleLimit,\n      log2\n    );\n    this.npmPath = npmLocation2 !== void 0 ? npmLocation2 : getDefaultNPMLocation(process.argv[0], validateDefaultNpmLocation2, this.installTypingHost);\n    if (this.npmPath.includes(\" \") && this.npmPath[0] !== `\"`) {\n      this.npmPath = `\"${this.npmPath}\"`;\n    }\n    if (this.log.isEnabled()) {\n      this.log.writeLine(`Process id: ${process.pid}`);\n      this.log.writeLine(`NPM location: ${this.npmPath} (explicit '${typescript_exports.server.Arguments.NpmLocation}' ${npmLocation2 === void 0 ? \"not \" : \"\"} provided)`);\n      this.log.writeLine(`validateDefaultNpmLocation: ${validateDefaultNpmLocation2}`);\n    }\n    this.ensurePackageDirectoryExists(globalTypingsCacheLocation2);\n    try {\n      if (this.log.isEnabled()) {\n        this.log.writeLine(`Updating ${typesRegistryPackageName} npm package...`);\n      }\n      this.execSyncAndLog(`${this.npmPath} install --ignore-scripts ${typesRegistryPackageName}@${this.latestDistTag}`, { cwd: globalTypingsCacheLocation2 });\n      if (this.log.isEnabled()) {\n        this.log.writeLine(`Updated ${typesRegistryPackageName} npm package`);\n      }\n    } catch (e) {\n      if (this.log.isEnabled()) {\n        this.log.writeLine(`Error updating ${typesRegistryPackageName} package: ${e.message}`);\n      }\n      this.delayedInitializationError = {\n        kind: \"event::initializationFailed\",\n        message: e.message,\n        stack: e.stack\n      };\n    }\n    this.typesRegistry = loadTypesRegistryFile(getTypesRegistryFileLocation(globalTypingsCacheLocation2), this.installTypingHost, this.log);\n  }\n  handleRequest(req) {\n    if (this.delayedInitializationError) {\n      this.sendResponse(this.delayedInitializationError);\n      this.delayedInitializationError = void 0;\n    }\n    super.handleRequest(req);\n  }\n  sendResponse(response) {\n    if (this.log.isEnabled()) {\n      this.log.writeLine(`Sending response:${typescript_exports.server.stringifyIndented(response)}`);\n    }\n    process.send(response);\n    if (this.log.isEnabled()) {\n      this.log.writeLine(`Response has been sent.`);\n    }\n  }\n  installWorker(requestId, packageNames, cwd, onRequestCompleted) {\n    if (this.log.isEnabled()) {\n      this.log.writeLine(`#${requestId} with cwd: ${cwd} arguments: ${JSON.stringify(packageNames)}`);\n    }\n    const start = Date.now();\n    const hasError = typescript_exports.server.typingsInstaller.installNpmPackages(this.npmPath, typescript_exports.version, packageNames, (command) => this.execSyncAndLog(command, { cwd }));\n    if (this.log.isEnabled()) {\n      this.log.writeLine(`npm install #${requestId} took: ${Date.now() - start} ms`);\n    }\n    onRequestCompleted(!hasError);\n  }\n  /** Returns 'true' in case of error. */\n  execSyncAndLog(command, options) {\n    if (this.log.isEnabled()) {\n      this.log.writeLine(`Exec: ${command}`);\n    }\n    try {\n      const stdout = (0, import_child_process.execSync)(command, { ...options, encoding: \"utf-8\" });\n      if (this.log.isEnabled()) {\n        this.log.writeLine(`    Succeeded. stdout:${indent(typescript_exports.sys.newLine, stdout)}`);\n      }\n      return false;\n    } catch (error) {\n      const { stdout, stderr } = error;\n      this.log.writeLine(`    Failed. stdout:${indent(typescript_exports.sys.newLine, stdout)}${typescript_exports.sys.newLine}    stderr:${indent(typescript_exports.sys.newLine, stderr)}`);\n      return true;\n    }\n  }\n};\nvar logFilePath = typescript_exports.server.findArgument(typescript_exports.server.Arguments.LogFile);\nvar globalTypingsCacheLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.GlobalCacheLocation);\nvar typingSafeListLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypingSafeListLocation);\nvar typesMapLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypesMapLocation);\nvar npmLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.NpmLocation);\nvar validateDefaultNpmLocation = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);\nvar log = new FileLog(logFilePath);\nif (log.isEnabled()) {\n  process.on(\"uncaughtException\", (e) => {\n    log.writeLine(`Unhandled exception: ${e} at ${e.stack}`);\n  });\n}\nprocess.on(\"disconnect\", () => {\n  if (log.isEnabled()) {\n    log.writeLine(`Parent process has exited, shutting down...`);\n  }\n  process.exit(0);\n});\nvar installer;\nprocess.on(\"message\", (req) => {\n  installer ?? (installer = new NodeTypingsInstaller(\n    globalTypingsCacheLocation,\n    typingSafeListLocation,\n    typesMapLocation,\n    npmLocation,\n    validateDefaultNpmLocation,\n    /*throttleLimit*/\n    5,\n    log\n  ));\n  installer.handleRequest(req);\n});\nfunction indent(newline, str) {\n  return str && str.length ? `${newline}    ` + str.replace(/\\r?\\n/, `${newline}    `) : \"\";\n}\n//# sourceMappingURL=_typingsInstaller.js.map\n"
        }
    ]
}