{
    "sourceFile": "node_modules/array-includes/test/tests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892027221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nmodule.exports = function (includes, t) {\n\tvar sparseish = { length: 5, 0: 'a', 1: 'b' };\n\tvar overfullarrayish = { length: 2, 0: 'a', 1: 'b', 2: 'c' };\n\tvar thrower = { valueOf: function () { throw new RangeError('whoa'); } };\n\tvar numberish = { valueOf: function () { return 2; } };\n\n\tt.test('simple examples', function (st) {\n\t\tst.equal(true, includes([1, 2, 3], 1), '[1, 2, 3] includes 1');\n\t\tst.equal(false, includes([1, 2, 3], 4), '[1, 2, 3] does not include 4');\n\t\tst.equal(true, includes([NaN], NaN), '[NaN] includes NaN');\n\t\tst.end();\n\t});\n\n\tt.test('does not skip holes', function (st) {\n\t\tst.equal(true, includes(Array(1)), 'Array(1) includes undefined');\n\t\tst.end();\n\t});\n\n\tt.test('exceptions', function (et) {\n\t\tet.test('fromIndex conversion', function (st) {\n\t\t\tst['throws'](function () { includes([0], 0, thrower); }, RangeError, 'fromIndex conversion throws');\n\t\t\tst.end();\n\t\t});\n\n\t\tet.test('ToLength', function (st) {\n\t\t\tst['throws'](function () { includes({ length: thrower, 0: true }, true); }, RangeError, 'ToLength conversion throws');\n\t\t\tst.end();\n\t\t});\n\n\t\tet.end();\n\t});\n\n\tt.test('arraylike', function (st) {\n\t\tst.equal(true, includes(sparseish, 'a'), 'sparse array-like object includes \"a\"');\n\t\tst.equal(false, includes(sparseish, 'c'), 'sparse array-like object does not include \"c\"');\n\n\t\tst.equal(true, includes(overfullarrayish, 'b'), 'sparse array-like object includes \"b\"');\n\t\tst.equal(false, includes(overfullarrayish, 'c'), 'sparse array-like object does not include \"c\"');\n\t\tst.end();\n\t});\n\n\tt.test('fromIndex', function (ft) {\n\t\tft.equal(true, includes([1], 1, NaN), 'NaN fromIndex -> 0 fromIndex');\n\n\t\tft.equal(true, includes([0, 1, 2], 1, 0), 'starting from 0 finds index 1');\n\t\tft.equal(true, includes([0, 1, 2], 1, 1), 'starting from 1 finds index 1');\n\t\tft.equal(false, includes([0, 1, 2], 1, 2), 'starting from 2 does not find index 1');\n\n\t\tft.test('number coercion', function (st) {\n\t\t\tst.equal(false, includes(['a', 'b', 'c'], 'a', numberish), 'does not find \"a\" with object fromIndex coercing to 2');\n\t\t\tst.equal(false, includes(['a', 'b', 'c'], 'a', '2'), 'does not find \"a\" with string fromIndex coercing to 2');\n\t\t\tst.equal(true, includes(['a', 'b', 'c'], 'c', numberish), 'finds \"c\" with object fromIndex coercing to 2');\n\t\t\tst.equal(true, includes(['a', 'b', 'c'], 'c', '2'), 'finds \"c\" with string fromIndex coercing to 2');\n\t\t\tst.end();\n\t\t});\n\n\t\tft.test('fromIndex greater than length', function (st) {\n\t\t\tst.equal(false, includes([1], 1, 2), 'array of length 1 is not searched if fromIndex is > 1');\n\t\t\tst.equal(false, includes([1], 1, 1), 'array of length 1 is not searched if fromIndex is >= 1');\n\t\t\tst.equal(false, includes([1], 1, 1.1), 'array of length 1 is not searched if fromIndex is 1.1');\n\t\t\tst.equal(false, includes([1], 1, Infinity), 'array of length 1 is not searched if fromIndex is Infinity');\n\t\t\tst.end();\n\t\t});\n\n\t\tft.test('negative fromIndex', function (st) {\n\t\t\tst.equal(true, includes([1, 3], 1, -4), 'computed length would be negative; fromIndex is thus 0');\n\t\t\tst.equal(true, includes([1, 3], 3, -4), 'computed length would be negative; fromIndex is thus 0');\n\t\t\tst.equal(true, includes([1, 3], 1, -Infinity), 'computed length would be negative; fromIndex is thus 0');\n\n\t\t\tst.equal(true, includes([12, 13], 13, -1), 'finds -1st item with -1 fromIndex');\n\t\t\tst.equal(false, includes([12, 13], 12, -1), 'does not find -2nd item with -1 fromIndex');\n\t\t\tst.equal(true, includes([12, 13], 13, -2), 'finds -2nd item with -2 fromIndex');\n\n\t\t\tst.equal(true, includes(sparseish, 'b', -4), 'finds -4th item with -4 fromIndex');\n\t\t\tst.equal(false, includes(sparseish, 'a', -4), 'does not find -5th item with -4 fromIndex');\n\t\t\tst.equal(true, includes(sparseish, 'a', -5), 'finds -5th item with -5 fromIndex');\n\t\t\tst.end();\n\t\t});\n\n\t\tft.end();\n\t});\n\n\tt.test('strings', function (st) {\n\t\tst.equal(true, includes('abc', 'c'), 'string includes one of its chars');\n\t\tst.equal(false, includes('abc', 'd'), 'string does not include a char it should not');\n\n\t\tst.equal(true, includes(Object('abc'), 'c'), 'boxed string includes one of its chars');\n\t\tst.equal(false, includes(Object('abc'), 'd'), 'boxed string does not include a char it should not');\n\n\t\tst.end();\n\t});\n};\n"
        }
    ]
}