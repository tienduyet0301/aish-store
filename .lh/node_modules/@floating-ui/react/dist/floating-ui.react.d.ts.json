{
    "sourceFile": "node_modules/@floating-ui/react/dist/floating-ui.react.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891761158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { AlignedPlacement } from '@floating-ui/react-dom';\r\nimport { Alignment } from '@floating-ui/react-dom';\r\nimport { arrow } from '@floating-ui/react-dom';\r\nimport { ArrowOptions } from '@floating-ui/react-dom';\r\nimport { autoPlacement } from '@floating-ui/react-dom';\r\nimport { AutoPlacementOptions } from '@floating-ui/react-dom';\r\nimport { autoUpdate } from '@floating-ui/react-dom';\r\nimport { AutoUpdateOptions } from '@floating-ui/react-dom';\r\nimport { Axis } from '@floating-ui/react-dom';\r\nimport { Boundary } from '@floating-ui/react-dom';\r\nimport { ClientRectObject } from '@floating-ui/react-dom';\r\nimport { computePosition } from '@floating-ui/react-dom';\r\nimport { ComputePositionConfig } from '@floating-ui/react-dom';\r\nimport { ComputePositionReturn } from '@floating-ui/react-dom';\r\nimport { Coords } from '@floating-ui/react-dom';\r\nimport { Derivable } from '@floating-ui/react-dom';\r\nimport { detectOverflow } from '@floating-ui/react-dom';\r\nimport { DetectOverflowOptions } from '@floating-ui/react-dom';\r\nimport { Dimensions } from '@floating-ui/react-dom';\r\nimport { ElementContext } from '@floating-ui/react-dom';\r\nimport { ElementRects } from '@floating-ui/react-dom';\r\nimport { Elements } from '@floating-ui/react-dom';\r\nimport { flip } from '@floating-ui/react-dom';\r\nimport { FlipOptions } from '@floating-ui/react-dom';\r\nimport { FloatingElement } from '@floating-ui/react-dom';\r\nimport { getOverflowAncestors } from '@floating-ui/react-dom';\r\nimport { hide } from '@floating-ui/react-dom';\r\nimport { HideOptions } from '@floating-ui/react-dom';\r\nimport { inline } from '@floating-ui/react-dom';\r\nimport { InlineOptions } from '@floating-ui/react-dom';\r\nimport { Length } from '@floating-ui/react-dom';\r\nimport { limitShift } from '@floating-ui/react-dom';\r\nimport { Middleware } from '@floating-ui/react-dom';\r\nimport { MiddlewareArguments } from '@floating-ui/react-dom';\r\nimport { MiddlewareData } from '@floating-ui/react-dom';\r\nimport { MiddlewareReturn } from '@floating-ui/react-dom';\r\nimport { MiddlewareState } from '@floating-ui/react-dom';\r\nimport { NodeScroll } from '@floating-ui/react-dom';\r\nimport { offset } from '@floating-ui/react-dom';\r\nimport { OffsetOptions } from '@floating-ui/react-dom';\r\nimport { Padding } from '@floating-ui/react-dom';\r\nimport { Placement } from '@floating-ui/react-dom';\r\nimport { Platform } from '@floating-ui/react-dom';\r\nimport { platform } from '@floating-ui/react-dom';\r\nimport * as React from 'react';\r\nimport { Rect } from '@floating-ui/react-dom';\r\nimport { ReferenceElement } from '@floating-ui/react-dom';\r\nimport { RootBoundary } from '@floating-ui/react-dom';\r\nimport { shift } from '@floating-ui/react-dom';\r\nimport { ShiftOptions } from '@floating-ui/react-dom';\r\nimport { Side } from '@floating-ui/react-dom';\r\nimport { SideObject } from '@floating-ui/react-dom';\r\nimport { size } from '@floating-ui/react-dom';\r\nimport { SizeOptions } from '@floating-ui/react-dom';\r\nimport { Strategy } from '@floating-ui/react-dom';\r\nimport type { UseFloatingOptions as UseFloatingOptions_2 } from '@floating-ui/react-dom';\r\nimport type { UseFloatingReturn as UseFloatingReturn_2 } from '@floating-ui/react-dom';\r\nimport { VirtualElement } from '@floating-ui/react-dom';\r\n\r\ndeclare const ACTIVE_KEY = \"active\";\r\n\r\nexport { AlignedPlacement }\r\n\r\nexport { Alignment }\r\n\r\ndeclare type AriaRole = 'tooltip' | 'dialog' | 'alertdialog' | 'menu' | 'listbox' | 'grid' | 'tree';\r\n\r\nexport { arrow }\r\n\r\nexport { ArrowOptions }\r\n\r\nexport { autoPlacement }\r\n\r\nexport { AutoPlacementOptions }\r\n\r\nexport { autoUpdate }\r\n\r\nexport { AutoUpdateOptions }\r\n\r\nexport { Axis }\r\n\r\nexport { Boundary }\r\n\r\nexport { ClientRectObject }\r\n\r\ndeclare type ComponentRole = 'select' | 'label' | 'combobox';\r\n\r\n/**\r\n * Creates a single tab stop whose items are navigated by arrow keys, which\r\n * provides list navigation outside of floating element contexts.\r\n *\r\n * This is useful to enable navigation of a list of items that aren’t part of a\r\n * floating element. A menubar is an example of a composite, with each reference\r\n * element being an item.\r\n * @see https://floating-ui.com/docs/Composite\r\n */\r\nexport declare const Composite: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & CompositeProps, \"ref\"> & React.RefAttributes<HTMLElement>>;\r\n\r\n/**\r\n * @see https://floating-ui.com/docs/Composite\r\n */\r\nexport declare const CompositeItem: React.ForwardRefExoticComponent<Omit<React.HTMLProps<HTMLElement> & CompositeItemProps, \"ref\"> & React.RefAttributes<HTMLElement>>;\r\n\r\nexport declare interface CompositeItemProps {\r\n    /**\r\n     * Determines the element to render.\r\n     * @example\r\n     * ```jsx\r\n     * <CompositeItem render={<li />} />\r\n     * <CompositeItem render={(htmlProps) => <li {...htmlProps} />} />\r\n     * ```\r\n     */\r\n    render?: RenderProp;\r\n}\r\n\r\nexport declare interface CompositeProps {\r\n    /**\r\n     * Determines the element to render.\r\n     * @example\r\n     * ```jsx\r\n     * <Composite render={<ul />} />\r\n     * <Composite render={(htmlProps) => <ul {...htmlProps} />} />\r\n     * ```\r\n     */\r\n    render?: RenderProp;\r\n    /**\r\n     * Determines the orientation of the composite.\r\n     */\r\n    orientation?: 'horizontal' | 'vertical' | 'both';\r\n    /**\r\n     * Determines whether focus should loop around when navigating past the first\r\n     * or last item.\r\n     */\r\n    loop?: boolean;\r\n    /**\r\n     * Whether the direction of the composite’s navigation is in RTL layout.\r\n     */\r\n    rtl?: boolean;\r\n    /**\r\n     * Determines the number of columns there are in the composite\r\n     * (i.e. it’s a grid).\r\n     */\r\n    cols?: number;\r\n    /**\r\n     * Determines which items are disabled. The `disabled` or `aria-disabled`\r\n     * attributes are used by default.\r\n     */\r\n    disabledIndices?: number[];\r\n    /**\r\n     * Determines which item is active. Used to externally control the active\r\n     * item.\r\n     */\r\n    activeIndex?: number;\r\n    /**\r\n     * Called when the user navigates to a new item. Used to externally control\r\n     * the active item.\r\n     */\r\n    onNavigate?(index: number): void;\r\n    /**\r\n     * Only for `cols > 1`, specify sizes for grid items.\r\n     * `{ width: 2, height: 2 }` means an item is 2 columns wide and 2 rows tall.\r\n     */\r\n    itemSizes?: Dimensions[];\r\n    /**\r\n     * Only relevant for `cols > 1` and items with different sizes, specify if\r\n     * the grid is dense (as defined in the CSS spec for grid-auto-flow).\r\n     */\r\n    dense?: boolean;\r\n}\r\n\r\nexport { computePosition }\r\n\r\nexport { ComputePositionConfig }\r\n\r\nexport { ComputePositionReturn }\r\n\r\nexport declare interface ContextData {\r\n    openEvent?: Event;\r\n    floatingContext?: FloatingContext;\r\n    /** @deprecated use `onTypingChange` prop in `useTypeahead` */\r\n    typing?: boolean;\r\n    [key: string]: any;\r\n}\r\n\r\nexport { Coords }\r\n\r\ndeclare type CSSStylesProperty = React.CSSProperties | ((params: {\r\n    side: Side;\r\n    placement: Placement;\r\n}) => React.CSSProperties);\r\n\r\ndeclare type Delay = number | Partial<{\r\n    open: number;\r\n    close: number;\r\n}>;\r\n\r\nexport { detectOverflow }\r\n\r\nexport { DetectOverflowOptions }\r\n\r\nexport { Dimensions }\r\n\r\nexport { ElementContext }\r\n\r\nexport declare interface ElementProps {\r\n    reference?: React.HTMLProps<Element>;\r\n    floating?: React.HTMLProps<HTMLElement>;\r\n    item?: React.HTMLProps<HTMLElement> | ((props: ExtendedUserProps) => React.HTMLProps<HTMLElement>);\r\n}\r\n\r\nexport { ElementRects }\r\n\r\nexport { Elements }\r\n\r\nexport declare interface ExtendedElements<RT> {\r\n    reference: ReferenceType | null;\r\n    floating: HTMLElement | null;\r\n    domReference: NarrowedElement<RT> | null;\r\n}\r\n\r\nexport declare interface ExtendedRefs<RT> {\r\n    reference: React.MutableRefObject<ReferenceType | null>;\r\n    floating: React.MutableRefObject<HTMLElement | null>;\r\n    domReference: React.MutableRefObject<NarrowedElement<RT> | null>;\r\n    setReference(node: RT | null): void;\r\n    setFloating(node: HTMLElement | null): void;\r\n    setPositionReference(node: ReferenceType | null): void;\r\n}\r\n\r\ndeclare type ExtendedUserProps = {\r\n    [ACTIVE_KEY]?: boolean;\r\n    [SELECTED_KEY]?: boolean;\r\n};\r\n\r\nexport { flip }\r\n\r\nexport { FlipOptions }\r\n\r\n/**\r\n * Renders a pointing arrow triangle.\r\n * @see https://floating-ui.com/docs/FloatingArrow\r\n */\r\nexport declare const FloatingArrow: React.ForwardRefExoticComponent<Omit<FloatingArrowProps, \"ref\"> & React.RefAttributes<SVGSVGElement>>;\r\n\r\nexport declare interface FloatingArrowProps extends React.ComponentPropsWithRef<'svg'> {\r\n    /**\r\n     * The floating context.\r\n     */\r\n    context: Omit<FloatingContext, 'refs'> & {\r\n        refs: any;\r\n    };\r\n    /**\r\n     * Width of the arrow.\r\n     * @default 14\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Height of the arrow.\r\n     * @default 7\r\n     */\r\n    height?: number;\r\n    /**\r\n     * The corner radius (rounding) of the arrow tip.\r\n     * @default 0 (sharp)\r\n     */\r\n    tipRadius?: number;\r\n    /**\r\n     * Forces a static offset over dynamic positioning under a certain condition.\r\n     * If the shift() middleware causes the popover to shift, this value will be\r\n     * ignored.\r\n     */\r\n    staticOffset?: string | number | null;\r\n    /**\r\n     * Custom path string.\r\n     */\r\n    d?: string;\r\n    /**\r\n     * Stroke (border) color of the arrow.\r\n     */\r\n    stroke?: string;\r\n    /**\r\n     * Stroke (border) width of the arrow.\r\n     */\r\n    strokeWidth?: number;\r\n}\r\n\r\nexport declare type FloatingContext<RT extends ReferenceType = ReferenceType> = Omit<UseFloatingReturn_2<RT>, 'refs' | 'elements'> & {\r\n    open: boolean;\r\n    onOpenChange(open: boolean, event?: Event, reason?: OpenChangeReason): void;\r\n    events: FloatingEvents;\r\n    dataRef: React.MutableRefObject<ContextData>;\r\n    nodeId: string | undefined;\r\n    floatingId: string;\r\n    refs: ExtendedRefs<RT>;\r\n    elements: ExtendedElements<RT>;\r\n};\r\n\r\n/**\r\n * Provides context for a group of floating elements that should share a\r\n * `delay`.\r\n * @see https://floating-ui.com/docs/FloatingDelayGroup\r\n */\r\nexport declare function FloatingDelayGroup(props: FloatingDelayGroupProps): React.JSX.Element;\r\n\r\ndeclare interface FloatingDelayGroupProps {\r\n    children?: React.ReactNode;\r\n    /**\r\n     * The delay to use for the group.\r\n     */\r\n    delay: Delay;\r\n    /**\r\n     * An optional explicit timeout to use for the group, which represents when\r\n     * grouping logic will no longer be active after the close delay completes.\r\n     * This is useful if you want grouping to “last” longer than the close delay,\r\n     * for example if there is no close delay at all.\r\n     */\r\n    timeoutMs?: number;\r\n}\r\n\r\nexport { FloatingElement }\r\n\r\nexport declare interface FloatingEvents {\r\n    emit<T extends string>(event: T, data?: any): void;\r\n    on(event: string, handler: (data: any) => void): void;\r\n    off(event: string, handler: (data: any) => void): void;\r\n}\r\n\r\n/**\r\n * Provides focus management for the floating element.\r\n * @see https://floating-ui.com/docs/FloatingFocusManager\r\n */\r\nexport declare function FloatingFocusManager(props: FloatingFocusManagerProps): React.JSX.Element;\r\n\r\nexport declare interface FloatingFocusManagerProps {\r\n    children: React.JSX.Element;\r\n    /**\r\n     * The floating context returned from `useFloating`.\r\n     */\r\n    context: FloatingContext;\r\n    /**\r\n     * Whether or not the focus manager should be disabled. Useful to delay focus\r\n     * management until after a transition completes or some other conditional\r\n     * state.\r\n     * @default false\r\n     */\r\n    disabled?: boolean;\r\n    /**\r\n     * The order in which focus cycles.\r\n     * @default ['content']\r\n     */\r\n    order?: Array<'reference' | 'floating' | 'content'>;\r\n    /**\r\n     * Which element to initially focus. Can be either a number (tabbable index as\r\n     * specified by the `order`) or a ref.\r\n     * @default 0\r\n     */\r\n    initialFocus?: number | React.MutableRefObject<HTMLElement | null>;\r\n    /**\r\n     * Determines if the focus guards are rendered. If not, focus can escape into\r\n     * the address bar/console/browser UI, like in native dialogs.\r\n     * @default true\r\n     */\r\n    guards?: boolean;\r\n    /**\r\n     * Determines if focus should be returned to the reference element once the\r\n     * floating element closes/unmounts (or if that is not available, the\r\n     * previously focused element). This prop is ignored if the floating element\r\n     * lost focus.\r\n     * It can be also set to a ref to explicitly control the element to return focus to.\r\n     * @default true\r\n     */\r\n    returnFocus?: boolean | React.MutableRefObject<HTMLElement | null>;\r\n    /**\r\n     * Determines if focus should be restored to the nearest tabbable element if\r\n     * focus inside the floating element is lost (such as due to the removal of\r\n     * the currently focused element from the DOM).\r\n     * @default false\r\n     */\r\n    restoreFocus?: boolean;\r\n    /**\r\n     * Determines if focus is “modal”, meaning focus is fully trapped inside the\r\n     * floating element and outside content cannot be accessed. This includes\r\n     * screen reader virtual cursors.\r\n     * @default true\r\n     */\r\n    modal?: boolean;\r\n    /**\r\n     * If your focus management is modal and there is no explicit close button\r\n     * available, you can use this prop to render a visually-hidden dismiss\r\n     * button at the start and end of the floating element. This allows\r\n     * touch-based screen readers to escape the floating element due to lack of\r\n     * an `esc` key.\r\n     * @default undefined\r\n     */\r\n    visuallyHiddenDismiss?: boolean | string;\r\n    /**\r\n     * Determines whether `focusout` event listeners that control whether the\r\n     * floating element should be closed if the focus moves outside of it are\r\n     * attached to the reference and floating elements. This affects non-modal\r\n     * focus management.\r\n     * @default true\r\n     */\r\n    closeOnFocusOut?: boolean;\r\n}\r\n\r\n/**\r\n * Provides context for a list of items within the floating element.\r\n * @see https://floating-ui.com/docs/FloatingList\r\n */\r\nexport declare function FloatingList(props: FloatingListProps): React.JSX.Element;\r\n\r\ndeclare interface FloatingListProps {\r\n    children: React.ReactNode;\r\n    /**\r\n     * A ref to the list of HTML elements, ordered by their index.\r\n     * `useListNavigation`'s `listRef` prop.\r\n     */\r\n    elementsRef: React.MutableRefObject<Array<HTMLElement | null>>;\r\n    /**\r\n     * A ref to the list of element labels, ordered by their index.\r\n     * `useTypeahead`'s `listRef` prop.\r\n     */\r\n    labelsRef?: React.MutableRefObject<Array<string | null>>;\r\n}\r\n\r\n/**\r\n * Provides parent node context for nested floating elements.\r\n * @see https://floating-ui.com/docs/FloatingTree\r\n */\r\nexport declare function FloatingNode(props: FloatingNodeProps): React.JSX.Element;\r\n\r\nexport declare interface FloatingNodeProps {\r\n    children?: React.ReactNode;\r\n    id: string;\r\n}\r\n\r\nexport declare interface FloatingNodeType<RT extends ReferenceType = ReferenceType> {\r\n    id: string;\r\n    parentId: string | null;\r\n    context?: FloatingContext<RT>;\r\n}\r\n\r\n/**\r\n * Provides base styling for a fixed overlay element to dim content or block\r\n * pointer events behind a floating element.\r\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\r\n * @see https://floating-ui.com/docs/FloatingOverlay\r\n */\r\nexport declare const FloatingOverlay: React.ForwardRefExoticComponent<Omit<React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, \"ref\"> & FloatingOverlayProps & React.RefAttributes<HTMLDivElement>>;\r\n\r\nexport declare interface FloatingOverlayProps {\r\n    /**\r\n     * Whether the overlay should lock scrolling on the document body.\r\n     * @default false\r\n     */\r\n    lockScroll?: boolean;\r\n}\r\n\r\n/**\r\n * Portals the floating element into a given container element — by default,\r\n * outside of the app root and into the body.\r\n * This is necessary to ensure the floating element can appear outside any\r\n * potential parent containers that cause clipping (such as `overflow: hidden`),\r\n * while retaining its location in the React tree.\r\n * @see https://floating-ui.com/docs/FloatingPortal\r\n */\r\nexport declare function FloatingPortal(props: FloatingPortalProps): React.JSX.Element;\r\n\r\nexport declare interface FloatingPortalProps {\r\n    children?: React.ReactNode;\r\n    /**\r\n     * Optionally selects the node with the id if it exists, or create it and\r\n     * append it to the specified `root` (by default `document.body`).\r\n     */\r\n    id?: string;\r\n    /**\r\n     * Specifies the root node the portal container will be appended to.\r\n     */\r\n    root?: HTMLElement | null | React.MutableRefObject<HTMLElement | null>;\r\n    /**\r\n     * When using non-modal focus management using `FloatingFocusManager`, this\r\n     * will preserve the tab order context based on the React tree instead of the\r\n     * DOM tree.\r\n     */\r\n    preserveTabOrder?: boolean;\r\n}\r\n\r\nexport declare interface FloatingRootContext<RT extends ReferenceType = ReferenceType> {\r\n    dataRef: React.MutableRefObject<ContextData>;\r\n    open: boolean;\r\n    onOpenChange: (open: boolean, event?: Event, reason?: OpenChangeReason) => void;\r\n    elements: {\r\n        domReference: Element | null;\r\n        reference: RT | null;\r\n        floating: HTMLElement | null;\r\n    };\r\n    events: FloatingEvents;\r\n    floatingId: string;\r\n    refs: {\r\n        setPositionReference(node: ReferenceType | null): void;\r\n    };\r\n}\r\n\r\n/**\r\n * Provides context for nested floating elements when they are not children of\r\n * each other on the DOM.\r\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\r\n * - The `bubbles` option in the `useDismiss()` Hook\r\n * - Nested virtual list navigation\r\n * - Nested floating elements that each open on hover\r\n * - Custom communication between parent and child floating elements\r\n * @see https://floating-ui.com/docs/FloatingTree\r\n */\r\nexport declare function FloatingTree(props: FloatingTreeProps): React.JSX.Element;\r\n\r\nexport declare interface FloatingTreeProps {\r\n    children?: React.ReactNode;\r\n}\r\n\r\nexport declare interface FloatingTreeType<RT extends ReferenceType = ReferenceType> {\r\n    nodesRef: React.MutableRefObject<Array<FloatingNodeType<RT>>>;\r\n    events: FloatingEvents;\r\n    addNode(node: FloatingNodeType): void;\r\n    removeNode(node: FloatingNodeType): void;\r\n}\r\n\r\nexport { getOverflowAncestors }\r\n\r\ndeclare interface GroupContext extends GroupState {\r\n    setCurrentId: React.Dispatch<React.SetStateAction<any>>;\r\n    setState: React.Dispatch<Partial<GroupState>>;\r\n}\r\n\r\ndeclare interface GroupState {\r\n    delay: Delay;\r\n    initialDelay: Delay;\r\n    currentId: any;\r\n    timeoutMs: number;\r\n    isInstantPhase: boolean;\r\n}\r\n\r\ndeclare interface HandleCloseFn {\r\n    (context: FloatingContext & {\r\n        onClose: () => void;\r\n        tree?: FloatingTreeType | null;\r\n        leave?: boolean;\r\n    }): (event: MouseEvent) => void;\r\n    __options: {\r\n        blockPointerEvents: boolean;\r\n    };\r\n}\r\n\r\nexport { hide }\r\n\r\nexport { HideOptions }\r\n\r\nexport { inline }\r\n\r\nexport { InlineOptions }\r\n\r\n/**\r\n * Positions the floating element such that an inner element inside of it is\r\n * anchored to the reference element.\r\n * @see https://floating-ui.com/docs/inner\r\n */\r\nexport declare const inner: (props: InnerProps | Derivable<InnerProps>) => Middleware;\r\n\r\nexport declare interface InnerProps extends DetectOverflowOptions {\r\n    /**\r\n     * A ref which contains an array of HTML elements.\r\n     * @default empty list\r\n     */\r\n    listRef: React.MutableRefObject<Array<HTMLElement | null>>;\r\n    /**\r\n     * The index of the active (focused or highlighted) item in the list.\r\n     * @default 0\r\n     */\r\n    index: number;\r\n    /**\r\n     * Callback invoked when the fallback state changes.\r\n     */\r\n    onFallbackChange?: null | ((fallback: boolean) => void);\r\n    /**\r\n     * The offset to apply to the floating element.\r\n     * @default 0\r\n     */\r\n    offset?: number;\r\n    /**\r\n     * A ref which contains the overflow of the floating element.\r\n     */\r\n    overflowRef?: React.MutableRefObject<SideObject | null>;\r\n    /**\r\n     * An optional ref containing an HTMLElement. This may be used as the\r\n     * scrolling container instead of the floating element — for instance,\r\n     * to position inner elements as direct children without being interfered by\r\n     * scrolling layout.\r\n     */\r\n    scrollRef?: React.MutableRefObject<HTMLElement | null>;\r\n    /**\r\n     * The minimum number of items that should be visible in the list.\r\n     * @default 4\r\n     */\r\n    minItemsVisible?: number;\r\n    /**\r\n     * The threshold for the reference element's overflow in pixels.\r\n     * @default 0\r\n     */\r\n    referenceOverflowThreshold?: number;\r\n}\r\n\r\nexport { Length }\r\n\r\nexport { limitShift }\r\n\r\nexport { Middleware }\r\n\r\nexport { MiddlewareArguments }\r\n\r\nexport { MiddlewareData }\r\n\r\nexport { MiddlewareReturn }\r\n\r\nexport { MiddlewareState }\r\n\r\nexport declare type NarrowedElement<T> = T extends Element ? T : Element;\r\n\r\nexport { NodeScroll }\r\n\r\nexport { offset }\r\n\r\nexport { OffsetOptions }\r\n\r\nexport declare type OpenChangeReason = 'outside-press' | 'escape-key' | 'ancestor-scroll' | 'reference-press' | 'click' | 'hover' | 'focus' | 'focus-out' | 'list-navigation' | 'safe-polygon';\r\n\r\nexport { Padding }\r\n\r\nexport { Placement }\r\n\r\nexport { Platform }\r\n\r\nexport { platform }\r\n\r\ndeclare type Prettify<T> = {\r\n    [K in keyof T]: T[K];\r\n} & {};\r\n\r\nexport { Rect }\r\n\r\nexport { ReferenceElement }\r\n\r\nexport declare type ReferenceType = Element | VirtualElement;\r\n\r\ndeclare type RenderProp = React.JSX.Element | ((props: React.HTMLAttributes<HTMLElement>) => React.JSX.Element);\r\n\r\nexport { RootBoundary }\r\n\r\n/**\r\n * Generates a safe polygon area that the user can traverse without closing the\r\n * floating element once leaving the reference element.\r\n * @see https://floating-ui.com/docs/useHover#safepolygon\r\n */\r\nexport declare function safePolygon(options?: SafePolygonOptions): HandleCloseFn;\r\n\r\nexport declare interface SafePolygonOptions {\r\n    buffer?: number;\r\n    blockPointerEvents?: boolean;\r\n    requireIntent?: boolean;\r\n}\r\n\r\ndeclare const SELECTED_KEY = \"selected\";\r\n\r\nexport { shift }\r\n\r\nexport { ShiftOptions }\r\n\r\nexport { Side }\r\n\r\nexport { SideObject }\r\n\r\nexport { size }\r\n\r\nexport { SizeOptions }\r\n\r\nexport { Strategy }\r\n\r\ndeclare type TransitionStatus = 'unmounted' | 'initial' | 'open' | 'close';\r\n\r\n/**\r\n * Opens or closes the floating element when clicking the reference element.\r\n * @see https://floating-ui.com/docs/useClick\r\n */\r\nexport declare function useClick(context: FloatingRootContext, props?: UseClickProps): ElementProps;\r\n\r\nexport declare interface UseClickProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * The type of event to use to determine a “click” with mouse input.\r\n     * Keyboard clicks work as normal.\r\n     * @default 'click'\r\n     */\r\n    event?: 'click' | 'mousedown';\r\n    /**\r\n     * Whether to toggle the open state with repeated clicks.\r\n     * @default true\r\n     */\r\n    toggle?: boolean;\r\n    /**\r\n     * Whether to ignore the logic for mouse input (for example, if `useHover()`\r\n     * is also being used).\r\n     * @default false\r\n     */\r\n    ignoreMouse?: boolean;\r\n    /**\r\n     * Whether to add keyboard handlers (Enter and Space key functionality) for\r\n     * non-button elements (to open/close the floating element via keyboard\r\n     * “click”).\r\n     * @default true\r\n     */\r\n    keyboardHandlers?: boolean;\r\n    /**\r\n     * If already open from another event such as the `useHover()` Hook,\r\n     * determines whether to keep the floating element open when clicking the\r\n     * reference element for the first time.\r\n     * @default true\r\n     */\r\n    stickIfOpen?: boolean;\r\n}\r\n\r\n/**\r\n * Positions the floating element relative to a client point (in the viewport),\r\n * such as the mouse position. By default, it follows the mouse cursor.\r\n * @see https://floating-ui.com/docs/useClientPoint\r\n */\r\nexport declare function useClientPoint(context: FloatingRootContext, props?: UseClientPointProps): ElementProps;\r\n\r\nexport declare interface UseClientPointProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * Whether to restrict the client point to an axis and use the reference\r\n     * element (if it exists) as the other axis. This can be useful if the\r\n     * floating element is also interactive.\r\n     * @default 'both'\r\n     */\r\n    axis?: 'x' | 'y' | 'both';\r\n    /**\r\n     * An explicitly defined `x` client coordinate.\r\n     * @default null\r\n     */\r\n    x?: number | null;\r\n    /**\r\n     * An explicitly defined `y` client coordinate.\r\n     * @default null\r\n     */\r\n    y?: number | null;\r\n}\r\n\r\n/**\r\n * Enables grouping when called inside a component that's a child of a\r\n * `FloatingDelayGroup`.\r\n * @see https://floating-ui.com/docs/FloatingDelayGroup\r\n */\r\nexport declare function useDelayGroup(context: FloatingRootContext, options?: UseGroupOptions): GroupContext;\r\n\r\n/**\r\n * @deprecated\r\n * Use the return value of `useDelayGroup()` instead.\r\n */\r\nexport declare const useDelayGroupContext: () => GroupContext;\r\n\r\n/**\r\n * Closes the floating element when a dismissal is requested — by default, when\r\n * the user presses the `escape` key or outside of the floating element.\r\n * @see https://floating-ui.com/docs/useDismiss\r\n */\r\nexport declare function useDismiss(context: FloatingRootContext, props?: UseDismissProps): ElementProps;\r\n\r\nexport declare interface UseDismissProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * Whether to dismiss the floating element upon pressing the `esc` key.\r\n     * @default true\r\n     */\r\n    escapeKey?: boolean;\r\n    /**\r\n     * Whether to dismiss the floating element upon pressing the reference\r\n     * element. You likely want to ensure the `move` option in the `useHover()`\r\n     * Hook has been disabled when this is in use.\r\n     * @default false\r\n     */\r\n    referencePress?: boolean;\r\n    /**\r\n     * The type of event to use to determine a “press”.\r\n     * - `pointerdown` is eager on both mouse + touch input.\r\n     * - `mousedown` is eager on mouse input, but lazy on touch input.\r\n     * - `click` is lazy on both mouse + touch input.\r\n     * @default 'pointerdown'\r\n     */\r\n    referencePressEvent?: 'pointerdown' | 'mousedown' | 'click';\r\n    /**\r\n     * Whether to dismiss the floating element upon pressing outside of the\r\n     * floating element.\r\n     * If you have another element, like a toast, that is rendered outside the\r\n     * floating element’s React tree and don’t want the floating element to close\r\n     * when pressing it, you can guard the check like so:\r\n     * ```jsx\r\n     * useDismiss(context, {\r\n     *   outsidePress: (event) => !event.target.closest('.toast'),\r\n     * });\r\n     * ```\r\n     * @default true\r\n     */\r\n    outsidePress?: boolean | ((event: MouseEvent) => boolean);\r\n    /**\r\n     * The type of event to use to determine an outside “press”.\r\n     * - `pointerdown` is eager on both mouse + touch input.\r\n     * - `mousedown` is eager on mouse input, but lazy on touch input.\r\n     * - `click` is lazy on both mouse + touch input.\r\n     * @default 'pointerdown'\r\n     */\r\n    outsidePressEvent?: 'pointerdown' | 'mousedown' | 'click';\r\n    /**\r\n     * Whether to dismiss the floating element upon scrolling an overflow\r\n     * ancestor.\r\n     * @default false\r\n     */\r\n    ancestorScroll?: boolean;\r\n    /**\r\n     * Determines whether event listeners bubble upwards through a tree of\r\n     * floating elements.\r\n     */\r\n    bubbles?: boolean | {\r\n        escapeKey?: boolean;\r\n        outsidePress?: boolean;\r\n    };\r\n    /**\r\n     * Determines whether to use capture phase event listeners.\r\n     */\r\n    capture?: boolean | {\r\n        escapeKey?: boolean;\r\n        outsidePress?: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Provides data to position a floating element and context to add interactions.\r\n * @see https://floating-ui.com/docs/useFloating\r\n */\r\nexport declare function useFloating<RT extends ReferenceType = ReferenceType>(options?: UseFloatingOptions): UseFloatingReturn<RT>;\r\n\r\nexport declare type UseFloatingData = Prettify<UseFloatingReturn>;\r\n\r\n/**\r\n * Registers a node into the `FloatingTree`, returning its id.\r\n * @see https://floating-ui.com/docs/FloatingTree\r\n */\r\nexport declare function useFloatingNodeId(customParentId?: string): string;\r\n\r\nexport declare interface UseFloatingOptions<RT extends ReferenceType = ReferenceType> extends Omit<UseFloatingOptions_2<RT>, 'elements'> {\r\n    rootContext?: FloatingRootContext<RT>;\r\n    /**\r\n     * Object of external elements as an alternative to the `refs` object setters.\r\n     */\r\n    elements?: {\r\n        /**\r\n         * Externally passed reference element. Store in state.\r\n         */\r\n        reference?: Element | null;\r\n        /**\r\n         * Externally passed floating element. Store in state.\r\n         */\r\n        floating?: HTMLElement | null;\r\n    };\r\n    /**\r\n     * An event callback that is invoked when the floating element is opened or\r\n     * closed.\r\n     */\r\n    onOpenChange?(open: boolean, event?: Event, reason?: OpenChangeReason): void;\r\n    /**\r\n     * Unique node id when using `FloatingTree`.\r\n     */\r\n    nodeId?: string;\r\n}\r\n\r\n/**\r\n * Returns the parent node id for nested floating elements, if available.\r\n * Returns `null` for top-level floating elements.\r\n */\r\nexport declare const useFloatingParentNodeId: () => string | null;\r\n\r\n/**\r\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\r\n */\r\nexport declare function useFloatingPortalNode(props?: UseFloatingPortalNodeProps): HTMLElement | null;\r\n\r\nexport declare interface UseFloatingPortalNodeProps {\r\n    id?: string;\r\n    root?: HTMLElement | null | React.MutableRefObject<HTMLElement | null>;\r\n}\r\n\r\nexport declare type UseFloatingReturn<RT extends ReferenceType = ReferenceType> = Prettify<UseFloatingReturn_2 & {\r\n    /**\r\n     * `FloatingContext`\r\n     */\r\n    context: Prettify<FloatingContext<RT>>;\r\n    /**\r\n     * Object containing the reference and floating refs and reactive setters.\r\n     */\r\n    refs: ExtendedRefs<RT>;\r\n    elements: ExtendedElements<RT>;\r\n}>;\r\n\r\nexport declare function useFloatingRootContext(options: UseFloatingRootContextOptions): FloatingRootContext;\r\n\r\nexport declare interface UseFloatingRootContextOptions {\r\n    open?: boolean;\r\n    onOpenChange?: (open: boolean, event?: Event, reason?: OpenChangeReason) => void;\r\n    elements: {\r\n        reference: Element | null;\r\n        floating: HTMLElement | null;\r\n    };\r\n}\r\n\r\n/**\r\n * Returns the nearest floating tree context, if available.\r\n */\r\nexport declare const useFloatingTree: <RT extends ReferenceType = ReferenceType>() => FloatingTreeType<RT> | null;\r\n\r\n/**\r\n * Opens the floating element while the reference element has focus, like CSS\r\n * `:focus`.\r\n * @see https://floating-ui.com/docs/useFocus\r\n */\r\nexport declare function useFocus(context: FloatingRootContext, props?: UseFocusProps): ElementProps;\r\n\r\nexport declare interface UseFocusProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * Whether the open state only changes if the focus event is considered\r\n     * visible (`:focus-visible` CSS selector).\r\n     * @default true\r\n     */\r\n    visibleOnly?: boolean;\r\n}\r\n\r\ndeclare interface UseGroupOptions {\r\n    /**\r\n     * Whether delay grouping should be enabled.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    id?: any;\r\n}\r\n\r\n/**\r\n * Opens the floating element while hovering over the reference element, like\r\n * CSS `:hover`.\r\n * @see https://floating-ui.com/docs/useHover\r\n */\r\nexport declare function useHover(context: FloatingRootContext, props?: UseHoverProps): ElementProps;\r\n\r\nexport declare interface UseHoverProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * Instead of closing the floating element when the cursor leaves its\r\n     * reference, we can leave it open until a certain condition is satisfied,\r\n     * e.g. to let them traverse into the floating element.\r\n     * @default null\r\n     */\r\n    handleClose?: HandleCloseFn | null;\r\n    /**\r\n     * Waits until the user’s cursor is at “rest” over the reference element\r\n     *  before changing the `open` state.\r\n     * @default 0\r\n     */\r\n    restMs?: number;\r\n    /**\r\n     * Waits for the specified time when the event listener runs before changing\r\n     * the `open` state.\r\n     * @default 0\r\n     */\r\n    delay?: number | {\r\n        open?: number;\r\n        close?: number;\r\n    };\r\n    /**\r\n     * Whether the logic only runs for mouse input, ignoring touch input.\r\n     * Note: due to a bug with Linux Chrome, \"pen\" inputs are considered \"mouse\".\r\n     * @default false\r\n     */\r\n    mouseOnly?: boolean;\r\n    /**\r\n     * Whether moving the cursor over the floating element will open it, without a\r\n     * regular hover event required.\r\n     * @default true\r\n     */\r\n    move?: boolean;\r\n}\r\n\r\n/**\r\n * Uses React 18's built-in `useId()` when available, or falls back to a\r\n * slightly less performant (requiring a double render) implementation for\r\n * earlier React versions.\r\n * @see https://floating-ui.com/docs/react-utils#useid\r\n */\r\nexport declare const useId: () => string;\r\n\r\n/**\r\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\r\n * expand the floating element's height, revealing more list items.\r\n * @see https://floating-ui.com/docs/inner\r\n */\r\nexport declare function useInnerOffset(context: FloatingRootContext, props: UseInnerOffsetProps): ElementProps;\r\n\r\nexport declare interface UseInnerOffsetProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * A ref which contains the overflow of the floating element.\r\n     */\r\n    overflowRef: React.MutableRefObject<SideObject | null>;\r\n    /**\r\n     * An optional ref containing an HTMLElement. This may be used as the\r\n     * scrolling container instead of the floating element — for instance,\r\n     * to position inner elements as direct children without being interfered by\r\n     * scrolling layout.\r\n     */\r\n    scrollRef?: React.MutableRefObject<HTMLElement | null>;\r\n    /**\r\n     * Callback invoked when the offset changes.\r\n     */\r\n    onChange: (offset: number | ((offset: number) => number)) => void;\r\n}\r\n\r\n/**\r\n * Merges an array of interaction hooks' props into prop getters, allowing\r\n * event handler functions to be composed together without overwriting one\r\n * another.\r\n * @see https://floating-ui.com/docs/useInteractions\r\n */\r\nexport declare function useInteractions(propsList?: Array<ElementProps | void>): UseInteractionsReturn;\r\n\r\nexport declare interface UseInteractionsReturn {\r\n    getReferenceProps: (userProps?: React.HTMLProps<Element>) => Record<string, unknown>;\r\n    getFloatingProps: (userProps?: React.HTMLProps<HTMLElement>) => Record<string, unknown>;\r\n    getItemProps: (userProps?: Omit<React.HTMLProps<HTMLElement>, 'selected' | 'active'> & ExtendedUserProps) => Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Used to register a list item and its index (DOM position) in the\r\n * `FloatingList`.\r\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\r\n */\r\nexport declare function useListItem(props?: UseListItemProps): {\r\n    ref: (node: HTMLElement | null) => void;\r\n    index: number;\r\n};\r\n\r\ndeclare interface UseListItemProps {\r\n    label?: string | null;\r\n}\r\n\r\n/**\r\n * Adds arrow key-based navigation of a list of items, either using real DOM\r\n * focus or virtual focus.\r\n * @see https://floating-ui.com/docs/useListNavigation\r\n */\r\nexport declare function useListNavigation(context: FloatingRootContext, props: UseListNavigationProps): ElementProps;\r\n\r\nexport declare interface UseListNavigationProps {\r\n    /**\r\n     * A ref that holds an array of list items.\r\n     * @default empty list\r\n     */\r\n    listRef: React.MutableRefObject<Array<HTMLElement | null>>;\r\n    /**\r\n     * The index of the currently active (focused or highlighted) item, which may\r\n     * or may not be selected.\r\n     * @default null\r\n     */\r\n    activeIndex: number | null;\r\n    /**\r\n     * A callback that is called when the user navigates to a new active item,\r\n     * passed in a new `activeIndex`.\r\n     */\r\n    onNavigate?: (activeIndex: number | null) => void;\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * The currently selected item index, which may or may not be active.\r\n     * @default null\r\n     */\r\n    selectedIndex?: number | null;\r\n    /**\r\n     * Whether to focus the item upon opening the floating element. 'auto' infers\r\n     * what to do based on the input type (keyboard vs. pointer), while a boolean\r\n     * value will force the value.\r\n     * @default 'auto'\r\n     */\r\n    focusItemOnOpen?: boolean | 'auto';\r\n    /**\r\n     * Whether hovering an item synchronizes the focus.\r\n     * @default true\r\n     */\r\n    focusItemOnHover?: boolean;\r\n    /**\r\n     * Whether pressing an arrow key on the navigation’s main axis opens the\r\n     * floating element.\r\n     * @default true\r\n     */\r\n    openOnArrowKeyDown?: boolean;\r\n    /**\r\n     * By default elements with either a `disabled` or `aria-disabled` attribute\r\n     * are skipped in the list navigation — however, this requires the items to\r\n     * be rendered.\r\n     * This prop allows you to manually specify indices which should be disabled,\r\n     * overriding the default logic.\r\n     * For Windows-style select menus, where the menu does not open when\r\n     * navigating via arrow keys, specify an empty array.\r\n     * @default undefined\r\n     */\r\n    disabledIndices?: Array<number>;\r\n    /**\r\n     * Determines whether focus can escape the list, such that nothing is selected\r\n     * after navigating beyond the boundary of the list. In some\r\n     * autocomplete/combobox components, this may be desired, as screen\r\n     * readers will return to the input.\r\n     * `loop` must be `true`.\r\n     * @default false\r\n     */\r\n    allowEscape?: boolean;\r\n    /**\r\n     * Determines whether focus should loop around when navigating past the first\r\n     * or last item.\r\n     * @default false\r\n     */\r\n    loop?: boolean;\r\n    /**\r\n     * If the list is nested within another one (e.g. a nested submenu), the\r\n     * navigation semantics change.\r\n     * @default false\r\n     */\r\n    nested?: boolean;\r\n    /**\r\n     * Whether the direction of the floating element’s navigation is in RTL\r\n     * layout.\r\n     * @default false\r\n     */\r\n    rtl?: boolean;\r\n    /**\r\n     * Whether the focus is virtual (using `aria-activedescendant`).\r\n     * Use this if you need focus to remain on the reference element\r\n     * (such as an input), but allow arrow keys to navigate list items.\r\n     * This is common in autocomplete listbox components.\r\n     * Your virtually-focused list items must have a unique `id` set on them.\r\n     * If you’re using a component role with the `useRole()` Hook, then an `id` is\r\n     * generated automatically.\r\n     * @default false\r\n     */\r\n    virtual?: boolean;\r\n    /**\r\n     * The orientation in which navigation occurs.\r\n     * @default 'vertical'\r\n     */\r\n    orientation?: 'vertical' | 'horizontal' | 'both';\r\n    /**\r\n     * Specifies how many columns the list has (i.e., it’s a grid). Use an\r\n     * orientation of 'horizontal' (e.g. for an emoji picker/date picker, where\r\n     * pressing ArrowRight or ArrowLeft can change rows), or 'both' (where the\r\n     * current row cannot be escaped with ArrowRight or ArrowLeft, only ArrowUp\r\n     * and ArrowDown).\r\n     * @default 1\r\n     */\r\n    cols?: number;\r\n    /**\r\n     * Whether to scroll the active item into view when navigating. The default\r\n     * value uses nearest options.\r\n     */\r\n    scrollItemIntoView?: boolean | ScrollIntoViewOptions;\r\n    /**\r\n     * When using virtual focus management, this holds a ref to the\r\n     * virtually-focused item. This allows nested virtual navigation to be\r\n     * enabled, and lets you know when a nested element is virtually focused from\r\n     * the root reference handling the events. Requires `FloatingTree` to be\r\n     * setup.\r\n     */\r\n    virtualItemRef?: React.MutableRefObject<HTMLElement | null>;\r\n    /**\r\n     * Only for `cols > 1`, specify sizes for grid items.\r\n     * `{ width: 2, height: 2 }` means an item is 2 columns wide and 2 rows tall.\r\n     */\r\n    itemSizes?: Dimensions[];\r\n    /**\r\n     * Only relevant for `cols > 1` and items with different sizes, specify if\r\n     * the grid is dense (as defined in the CSS spec for `grid-auto-flow`).\r\n     * @default false\r\n     */\r\n    dense?: boolean;\r\n}\r\n\r\n/**\r\n * Merges an array of refs into a single memoized callback ref or `null`.\r\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\r\n */\r\nexport declare function useMergeRefs<Instance>(refs: Array<React.Ref<Instance> | undefined>): React.RefCallback<Instance> | null;\r\n\r\n/**\r\n * Adds base screen reader props to the reference and floating elements for a\r\n * given floating element `role`.\r\n * @see https://floating-ui.com/docs/useRole\r\n */\r\nexport declare function useRole(context: FloatingRootContext, props?: UseRoleProps): ElementProps;\r\n\r\nexport declare interface UseRoleProps {\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * The role of the floating element.\r\n     * @default 'dialog'\r\n     */\r\n    role?: AriaRole | ComponentRole;\r\n}\r\n\r\n/**\r\n * Provides a status string to apply CSS transitions to a floating element,\r\n * correctly handling placement-aware transitions.\r\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\r\n */\r\nexport declare function useTransitionStatus(context: FloatingContext, props?: UseTransitionStatusProps): {\r\n    isMounted: boolean;\r\n    status: TransitionStatus;\r\n};\r\n\r\nexport declare interface UseTransitionStatusProps {\r\n    /**\r\n     * The duration of the transition in milliseconds, or an object containing\r\n     * `open` and `close` keys for different durations.\r\n     */\r\n    duration?: number | {\r\n        open?: number;\r\n        close?: number;\r\n    };\r\n}\r\n\r\n/**\r\n * Provides styles to apply CSS transitions to a floating element, correctly\r\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\r\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\r\n */\r\nexport declare function useTransitionStyles<RT extends ReferenceType = ReferenceType>(context: FloatingContext<RT>, props?: UseTransitionStylesProps): {\r\n    isMounted: boolean;\r\n    styles: React.CSSProperties;\r\n};\r\n\r\nexport declare interface UseTransitionStylesProps extends UseTransitionStatusProps {\r\n    /**\r\n     * The styles to apply when the floating element is initially mounted.\r\n     */\r\n    initial?: CSSStylesProperty;\r\n    /**\r\n     * The styles to apply when the floating element is transitioning to the\r\n     * `open` state.\r\n     */\r\n    open?: CSSStylesProperty;\r\n    /**\r\n     * The styles to apply when the floating element is transitioning to the\r\n     * `close` state.\r\n     */\r\n    close?: CSSStylesProperty;\r\n    /**\r\n     * The styles to apply to all states.\r\n     */\r\n    common?: CSSStylesProperty;\r\n}\r\n\r\n/**\r\n * Provides a matching callback that can be used to focus an item as the user\r\n * types, often used in tandem with `useListNavigation()`.\r\n * @see https://floating-ui.com/docs/useTypeahead\r\n */\r\nexport declare function useTypeahead(context: FloatingRootContext, props: UseTypeaheadProps): ElementProps;\r\n\r\nexport declare interface UseTypeaheadProps {\r\n    /**\r\n     * A ref which contains an array of strings whose indices match the HTML\r\n     * elements of the list.\r\n     * @default empty list\r\n     */\r\n    listRef: React.MutableRefObject<Array<string | null>>;\r\n    /**\r\n     * The index of the active (focused or highlighted) item in the list.\r\n     * @default null\r\n     */\r\n    activeIndex: number | null;\r\n    /**\r\n     * Callback invoked with the matching index if found as the user types.\r\n     */\r\n    onMatch?: (index: number) => void;\r\n    /**\r\n     * Callback invoked with the typing state as the user types.\r\n     */\r\n    onTypingChange?: (isTyping: boolean) => void;\r\n    /**\r\n     * Whether the Hook is enabled, including all internal Effects and event\r\n     * handlers.\r\n     * @default true\r\n     */\r\n    enabled?: boolean;\r\n    /**\r\n     * A function that returns the matching string from the list.\r\n     * @default lowercase-finder\r\n     */\r\n    findMatch?: null | ((list: Array<string | null>, typedString: string) => string | null | undefined);\r\n    /**\r\n     * The number of milliseconds to wait before resetting the typed string.\r\n     * @default 750\r\n     */\r\n    resetMs?: number;\r\n    /**\r\n     * An array of keys to ignore when typing.\r\n     * @default []\r\n     */\r\n    ignoreKeys?: Array<string>;\r\n    /**\r\n     * The index of the selected item in the list, if available.\r\n     * @default null\r\n     */\r\n    selectedIndex?: number | null;\r\n}\r\n\r\nexport { VirtualElement }\r\n\r\nexport { }\r\n"
        }
    ]
}