{
    "sourceFile": "node_modules/@floating-ui/react/dist/floating-ui.react.umd.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891761398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom'), require('@floating-ui/react-dom')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom', '@floating-ui/react-dom'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIReact = {}, global.React, global.ReactDOM, global.FloatingUIReactDOM));\n})(this, (function (exports, React, ReactDOM, reactDom) { 'use strict';\n\n  function _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n.default = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\n  var ReactDOM__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM);\n\n  /**\n   * Merges an array of refs into a single memoized callback ref or `null`.\n   * @see https://floating-ui.com/docs/react-utils#usemergerefs\n   */\n  function useMergeRefs(refs) {\n    return React__namespace.useMemo(() => {\n      if (refs.every(ref => ref == null)) {\n        return null;\n      }\n      return value => {\n        refs.forEach(ref => {\n          if (typeof ref === 'function') {\n            ref(value);\n          } else if (ref != null) {\n            ref.current = value;\n          }\n        });\n      };\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n  }\n\n  // https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\n  const SafeReact = {\n    ...React__namespace\n  };\n\n  const useInsertionEffect = SafeReact.useInsertionEffect;\n  const useSafeInsertionEffect = useInsertionEffect || (fn => fn());\n  function useEffectEvent(callback) {\n    const ref = React__namespace.useRef(() => {\n      {\n        throw new Error('Cannot call an event handler while rendering.');\n      }\n    });\n    useSafeInsertionEffect(() => {\n      ref.current = callback;\n    });\n    return React__namespace.useCallback(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n  }\n\n  function hasWindow() {\n    return typeof window !== 'undefined';\n  }\n  function getNodeName(node) {\n    if (isNode(node)) {\n      return (node.nodeName || '').toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return '#document';\n  }\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n  function getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n  }\n  function isNode(value) {\n    if (!hasWindow()) {\n      return false;\n    }\n    return value instanceof Node || value instanceof getWindow(value).Node;\n  }\n  function isElement(value) {\n    if (!hasWindow()) {\n      return false;\n    }\n    return value instanceof Element || value instanceof getWindow(value).Element;\n  }\n  function isHTMLElement(value) {\n    if (!hasWindow()) {\n      return false;\n    }\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n  }\n  function isShadowRoot(value) {\n    if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n  }\n  function isWebKit() {\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\n    return CSS.supports('-webkit-backdrop-filter', 'none');\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n\n  function activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n      var _activeElement;\n      activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n  }\n  function contains(parent, child) {\n    if (!parent || !child) {\n      return false;\n    }\n    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n      return true;\n    }\n\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && isShadowRoot(rootNode)) {\n      let next = child;\n      while (next) {\n        if (parent === next) {\n          return true;\n        }\n        // @ts-ignore\n        next = next.parentNode || next.host;\n      }\n    }\n\n    // Give up, the result is false\n    return false;\n  }\n  // Avoid Chrome DevTools blue warning.\n  function getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n      return uaData.platform;\n    }\n    return navigator.platform;\n  }\n  function getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n      return uaData.brands.map(_ref => {\n        let {\n          brand,\n          version\n        } = _ref;\n        return brand + \"/\" + version;\n      }).join(' ');\n    }\n    return navigator.userAgent;\n  }\n\n  // License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\n  function isVirtualClick(event) {\n    // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n    // Try to find a workaround for this. `react-aria` source still has the check.\n    if (event.mozInputSource === 0 && event.isTrusted) {\n      return true;\n    }\n    if (isAndroid() && event.pointerType) {\n      return event.type === 'click' && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n  }\n  function isVirtualPointerEvent(event) {\n    if (isJSDOM()) return false;\n    return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n    // iOS VoiceOver returns 0.333• for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n  }\n  function isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n  }\n  function isAndroid() {\n    const re = /android/i;\n    return re.test(getPlatform()) || re.test(getUserAgent());\n  }\n  function isMac() {\n    return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n  }\n  function isJSDOM() {\n    return getUserAgent().includes('jsdom/');\n  }\n  function isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = ['mouse', 'pen'];\n    if (!strict) {\n      values.push('', undefined);\n    }\n    return values.includes(pointerType);\n  }\n  function isReactEvent(event) {\n    return 'nativeEvent' in event;\n  }\n  function isRootElement(element) {\n    return element.matches('html,body');\n  }\n  function getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n  }\n  function isEventTargetWithin(event, node) {\n    if (node == null) {\n      return false;\n    }\n    if ('composedPath' in event) {\n      return event.composedPath().includes(node);\n    }\n\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n  }\n  function getTarget(event) {\n    if ('composedPath' in event) {\n      return event.composedPath()[0];\n    }\n\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n  }\n  const TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\n  function isTypeableElement(element) {\n    return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n  }\n  function stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  function isTypeableCombobox(element) {\n    if (!element) return false;\n    return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n  }\n\n  /**\n   * Custom positioning reference element.\n   * @see https://floating-ui.com/docs/virtual-elements\n   */\n\n  const min = Math.min;\n  const max = Math.max;\n  const round = Math.round;\n  const floor = Math.floor;\n  function evaluate(value, param) {\n    return typeof value === 'function' ? value(param) : value;\n  }\n\n  const ARROW_UP = 'ArrowUp';\n  const ARROW_DOWN = 'ArrowDown';\n  const ARROW_LEFT = 'ArrowLeft';\n  const ARROW_RIGHT = 'ArrowRight';\n  function isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n  }\n  function isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n  }\n  function getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n      disabledIndices\n    });\n  }\n  function getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n      decrement: true,\n      startingIndex: listRef.current.length,\n      disabledIndices\n    });\n  }\n  function findNonDisabledIndex(listRef, _temp) {\n    let {\n      startingIndex = -1,\n      decrement = false,\n      disabledIndices,\n      amount = 1\n    } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    let index = startingIndex;\n    do {\n      index += decrement ? -amount : amount;\n    } while (index >= 0 && index <= list.length - 1 && isDisabled(list, index, disabledIndices));\n    return index;\n  }\n  function getGridNavigatedIndex(elementsRef, _ref) {\n    let {\n      event,\n      orientation,\n      loop,\n      rtl,\n      cols,\n      disabledIndices,\n      minIndex,\n      maxIndex,\n      prevIndex,\n      stopEvent: stop = false\n    } = _ref;\n    let nextIndex = prevIndex;\n    if (event.key === ARROW_UP) {\n      stop && stopEvent(event);\n      if (prevIndex === -1) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          amount: cols,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n          const col = prevIndex % cols;\n          const maxCol = maxIndex % cols;\n          const offset = maxIndex - (maxCol - col);\n          if (maxCol === col) {\n            nextIndex = maxIndex;\n          } else {\n            nextIndex = maxCol > col ? offset : offset - cols;\n          }\n        }\n      }\n      if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_DOWN) {\n      stop && stopEvent(event);\n      if (prevIndex === -1) {\n        nextIndex = minIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          amount: cols,\n          disabledIndices\n        });\n        if (loop && prevIndex + cols > maxIndex) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex % cols - cols,\n            amount: cols,\n            disabledIndices\n          });\n        }\n      }\n      if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n        nextIndex = prevIndex;\n      }\n    }\n\n    // Remains on the same row/column.\n    if (orientation === 'both') {\n      const prevRow = floor(prevIndex / cols);\n      if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n        stop && stopEvent(event);\n        if (prevIndex % cols !== cols - 1) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex,\n            disabledIndices\n          });\n          if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n              startingIndex: prevIndex - prevIndex % cols - 1,\n              disabledIndices\n            });\n          }\n        } else if (loop) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n        if (isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = prevIndex;\n        }\n      }\n      if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n        stop && stopEvent(event);\n        if (prevIndex % cols !== 0) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex,\n            decrement: true,\n            disabledIndices\n          });\n          if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n              startingIndex: prevIndex + (cols - prevIndex % cols),\n              decrement: true,\n              disabledIndices\n            });\n          }\n        } else if (loop) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n        if (isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = prevIndex;\n        }\n      }\n      const lastRow = floor(maxIndex / cols) === prevRow;\n      if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n        if (loop && lastRow) {\n          nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        } else {\n          nextIndex = prevIndex;\n        }\n      }\n    }\n    return nextIndex;\n  }\n\n  /** For each cell index, gets the item index that occupies that cell */\n  function buildCellMap(sizes, cols, dense) {\n    const cellMap = [];\n    let startIndex = 0;\n    sizes.forEach((_ref2, index) => {\n      let {\n        width,\n        height\n      } = _ref2;\n      if (width > cols) {\n        {\n          throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n        }\n      }\n      let itemPlaced = false;\n      if (dense) {\n        startIndex = 0;\n      }\n      while (!itemPlaced) {\n        const targetCells = [];\n        for (let i = 0; i < width; i++) {\n          for (let j = 0; j < height; j++) {\n            targetCells.push(startIndex + i + j * cols);\n          }\n        }\n        if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n          targetCells.forEach(cell => {\n            cellMap[cell] = index;\n          });\n          itemPlaced = true;\n        } else {\n          startIndex++;\n        }\n      }\n    });\n\n    // convert into a non-sparse array\n    return [...cellMap];\n  }\n\n  /** Gets cell index of an item's corner or -1 when index is -1. */\n  function getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n    if (index === -1) return -1;\n    const firstCellIndex = cellMap.indexOf(index);\n    const sizeItem = sizes[index];\n    switch (corner) {\n      case 'tl':\n        return firstCellIndex;\n      case 'tr':\n        if (!sizeItem) {\n          return firstCellIndex;\n        }\n        return firstCellIndex + sizeItem.width - 1;\n      case 'bl':\n        if (!sizeItem) {\n          return firstCellIndex;\n        }\n        return firstCellIndex + (sizeItem.height - 1) * cols;\n      case 'br':\n        return cellMap.lastIndexOf(index);\n    }\n  }\n\n  /** Gets all cell indices that correspond to the specified indices */\n  function getCellIndices(indices, cellMap) {\n    return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n  }\n  function isDisabled(list, index, disabledIndices) {\n    if (disabledIndices) {\n      return disabledIndices.includes(index);\n    }\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  }\n\n  var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\n  function sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1;\n    }\n    return 0;\n  }\n  function areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n      return false;\n    }\n    for (const [key, value] of map1.entries()) {\n      if (value !== map2.get(key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const FloatingListContext = /*#__PURE__*/React__namespace.createContext({\n    register: () => {},\n    unregister: () => {},\n    map: /*#__PURE__*/new Map(),\n    elementsRef: {\n      current: []\n    }\n  });\n  /**\n   * Provides context for a list of items within the floating element.\n   * @see https://floating-ui.com/docs/FloatingList\n   */\n  function FloatingList(props) {\n    const {\n      children,\n      elementsRef,\n      labelsRef\n    } = props;\n    const [map, setMap] = React__namespace.useState(() => new Map());\n    const register = React__namespace.useCallback(node => {\n      setMap(prevMap => new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = React__namespace.useCallback(node => {\n      setMap(prevMap => {\n        const map = new Map(prevMap);\n        map.delete(node);\n        return map;\n      });\n    }, []);\n    index(() => {\n      const newMap = new Map(map);\n      const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n      nodes.forEach((node, index) => {\n        newMap.set(node, index);\n      });\n      if (!areMapsEqual(map, newMap)) {\n        setMap(newMap);\n      }\n    }, [map]);\n    return /*#__PURE__*/React__namespace.createElement(FloatingListContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        register,\n        unregister,\n        map,\n        elementsRef,\n        labelsRef\n      }), [register, unregister, map, elementsRef, labelsRef])\n    }, children);\n  }\n  /**\n   * Used to register a list item and its index (DOM position) in the\n   * `FloatingList`.\n   * @see https://floating-ui.com/docs/FloatingList#uselistitem\n   */\n  function useListItem(props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      label\n    } = props;\n    const {\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    } = React__namespace.useContext(FloatingListContext);\n    const [index$1, setIndex] = React__namespace.useState(null);\n    const componentRef = React__namespace.useRef(null);\n    const ref = React__namespace.useCallback(node => {\n      componentRef.current = node;\n      if (index$1 !== null) {\n        elementsRef.current[index$1] = node;\n        if (labelsRef) {\n          var _node$textContent;\n          const isLabelDefined = label !== undefined;\n          labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n        }\n      }\n    }, [index$1, elementsRef, labelsRef, label]);\n    index(() => {\n      const node = componentRef.current;\n      if (node) {\n        register(node);\n        return () => {\n          unregister(node);\n        };\n      }\n    }, [register, unregister]);\n    index(() => {\n      const index = componentRef.current ? map.get(componentRef.current) : null;\n      if (index != null) {\n        setIndex(index);\n      }\n    }, [map]);\n    return React__namespace.useMemo(() => ({\n      ref,\n      index: index$1 == null ? -1 : index$1\n    }), [index$1, ref]);\n  }\n\n  function renderJsx(render, computedProps) {\n    if (typeof render === 'function') {\n      return render(computedProps);\n    }\n    if (render) {\n      return /*#__PURE__*/React__namespace.cloneElement(render, computedProps);\n    }\n    return /*#__PURE__*/React__namespace.createElement(\"div\", computedProps);\n  }\n  const CompositeContext = /*#__PURE__*/React__namespace.createContext({\n    activeIndex: 0,\n    onNavigate: () => {}\n  });\n  const horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\n  const verticalKeys = [ARROW_UP, ARROW_DOWN];\n  const allKeys = [...horizontalKeys, ...verticalKeys];\n\n  /**\n   * Creates a single tab stop whose items are navigated by arrow keys, which\n   * provides list navigation outside of floating element contexts.\n   *\n   * This is useful to enable navigation of a list of items that aren’t part of a\n   * floating element. A menubar is an example of a composite, with each reference\n   * element being an item.\n   * @see https://floating-ui.com/docs/Composite\n   */\n  const Composite = /*#__PURE__*/React__namespace.forwardRef(function Composite(props, forwardedRef) {\n    const {\n      render,\n      orientation = 'both',\n      loop = true,\n      rtl = false,\n      cols = 1,\n      disabledIndices,\n      activeIndex: externalActiveIndex,\n      onNavigate: externalSetActiveIndex,\n      itemSizes,\n      dense = false,\n      ...domProps\n    } = props;\n    const [internalActiveIndex, internalSetActiveIndex] = React__namespace.useState(0);\n    const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n    const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n    const elementsRef = React__namespace.useRef([]);\n    const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n    const contextValue = React__namespace.useMemo(() => ({\n      activeIndex,\n      onNavigate\n    }), [activeIndex, onNavigate]);\n    const isGrid = cols > 1;\n    function handleKeyDown(event) {\n      if (!allKeys.includes(event.key)) return;\n      let nextIndex = activeIndex;\n      const minIndex = getMinIndex(elementsRef, disabledIndices);\n      const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n      const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;\n      const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;\n      if (isGrid) {\n        const sizes = itemSizes || Array.from({\n          length: elementsRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(elementsRef.current, index, disabledIndices));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);\n        const maybeNextIndex = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          rtl,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || elementsRef.current.map((_, index) => isDisabled(elementsRef.current, index) ? index : undefined)), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction we're\n          // moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === horizontalEndKey ? 'tr' : 'tl')\n        })];\n        if (maybeNextIndex != null) {\n          nextIndex = maybeNextIndex;\n        }\n      }\n      const toEndKeys = {\n        horizontal: [horizontalEndKey],\n        vertical: [ARROW_DOWN],\n        both: [horizontalEndKey, ARROW_DOWN]\n      }[orientation];\n      const toStartKeys = {\n        horizontal: [horizontalStartKey],\n        vertical: [ARROW_UP],\n        both: [horizontalStartKey, ARROW_UP]\n      }[orientation];\n      const preventedKeys = isGrid ? allKeys : {\n        horizontal: horizontalKeys,\n        vertical: verticalKeys,\n        both: allKeys\n      }[orientation];\n      if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n        if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n          nextIndex = minIndex;\n        } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: nextIndex,\n            decrement: toStartKeys.includes(event.key),\n            disabledIndices\n          });\n        }\n      }\n      if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n        var _elementsRef$current$;\n        event.stopPropagation();\n        if (preventedKeys.includes(event.key)) {\n          event.preventDefault();\n        }\n        onNavigate(nextIndex);\n        (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();\n      }\n    }\n    const computedProps = {\n      ...domProps,\n      ...renderElementProps,\n      ref: forwardedRef,\n      'aria-orientation': orientation === 'both' ? undefined : orientation,\n      onKeyDown(e) {\n        domProps.onKeyDown == null || domProps.onKeyDown(e);\n        renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n        handleKeyDown(e);\n      }\n    };\n    return /*#__PURE__*/React__namespace.createElement(CompositeContext.Provider, {\n      value: contextValue\n    }, /*#__PURE__*/React__namespace.createElement(FloatingList, {\n      elementsRef: elementsRef\n    }, renderJsx(render, computedProps)));\n  });\n  /**\n   * @see https://floating-ui.com/docs/Composite\n   */\n  const CompositeItem = /*#__PURE__*/React__namespace.forwardRef(function CompositeItem(props, forwardedRef) {\n    const {\n      render,\n      ...domProps\n    } = props;\n    const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n    const {\n      activeIndex,\n      onNavigate\n    } = React__namespace.useContext(CompositeContext);\n    const {\n      ref,\n      index\n    } = useListItem();\n    const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n    const isActive = activeIndex === index;\n    const computedProps = {\n      ...domProps,\n      ...renderElementProps,\n      ref: mergedRef,\n      tabIndex: isActive ? 0 : -1,\n      'data-active': isActive ? '' : undefined,\n      onFocus(e) {\n        domProps.onFocus == null || domProps.onFocus(e);\n        renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n        onNavigate(index);\n      }\n    };\n    return renderJsx(render, computedProps);\n  });\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n\n  let serverHandoffComplete = false;\n  let count = 0;\n  const genId = () => // Ensure the id is unique with multiple independent versions of Floating UI\n  // on <React 18\n  \"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\n  function useFloatingId() {\n    const [id, setId] = React__namespace.useState(() => serverHandoffComplete ? genId() : undefined);\n    index(() => {\n      if (id == null) {\n        setId(genId());\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    React__namespace.useEffect(() => {\n      serverHandoffComplete = true;\n    }, []);\n    return id;\n  }\n  const useReactId = SafeReact.useId;\n\n  /**\n   * Uses React 18's built-in `useId()` when available, or falls back to a\n   * slightly less performant (requiring a double render) implementation for\n   * earlier React versions.\n   * @see https://floating-ui.com/docs/react-utils#useid\n   */\n  const useId = useReactId || useFloatingId;\n\n  let devMessageSet;\n  {\n    devMessageSet = /*#__PURE__*/new Set();\n  }\n  function warn() {\n    var _devMessageSet;\n    for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n      messages[_key] = arguments[_key];\n    }\n    const message = \"Floating UI: \" + messages.join(' ');\n    if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n      var _devMessageSet2;\n      (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n      console.warn(message);\n    }\n  }\n  function error() {\n    var _devMessageSet3;\n    for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      messages[_key2] = arguments[_key2];\n    }\n    const message = \"Floating UI: \" + messages.join(' ');\n    if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n      var _devMessageSet4;\n      (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n      console.error(message);\n    }\n  }\n\n  /**\n   * Renders a pointing arrow triangle.\n   * @see https://floating-ui.com/docs/FloatingArrow\n   */\n  const FloatingArrow = /*#__PURE__*/React__namespace.forwardRef(function FloatingArrow(props, ref) {\n    const {\n      context: {\n        placement,\n        elements: {\n          floating\n        },\n        middlewareData: {\n          arrow,\n          shift\n        }\n      },\n      width = 14,\n      height = 7,\n      tipRadius = 0,\n      strokeWidth = 0,\n      staticOffset,\n      stroke,\n      d,\n      style: {\n        transform,\n        ...restStyle\n      } = {},\n      ...rest\n    } = props;\n    {\n      if (!ref) {\n        warn('The `ref` prop is required for `FloatingArrow`.');\n      }\n    }\n    const clipPathId = useId();\n    const [isRTL, setIsRTL] = React__namespace.useState(false);\n\n    // https://github.com/floating-ui/floating-ui/issues/2932\n    index(() => {\n      if (!floating) return;\n      const isRTL = getComputedStyle$1(floating).direction === 'rtl';\n      if (isRTL) {\n        setIsRTL(true);\n      }\n    }, [floating]);\n    if (!floating) {\n      return null;\n    }\n    const [side, alignment] = placement.split('-');\n    const isVerticalSide = side === 'top' || side === 'bottom';\n    let computedStaticOffset = staticOffset;\n    if (isVerticalSide && shift != null && shift.x || !isVerticalSide && shift != null && shift.y) {\n      computedStaticOffset = null;\n    }\n\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    const computedStrokeWidth = strokeWidth * 2;\n    const halfStrokeWidth = computedStrokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const isCustomShape = !!d;\n    const yOffsetProp = computedStaticOffset && alignment === 'end' ? 'bottom' : 'top';\n    let xOffsetProp = computedStaticOffset && alignment === 'end' ? 'right' : 'left';\n    if (computedStaticOffset && isRTL) {\n      xOffsetProp = alignment === 'end' ? 'left' : 'right';\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? computedStaticOffset || arrow.x : '';\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? computedStaticOffset || arrow.y : '';\n    const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n    const rotation = {\n      top: isCustomShape ? 'rotate(180deg)' : '',\n      left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n      bottom: isCustomShape ? '' : 'rotate(180deg)',\n      right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n    }[side];\n    return /*#__PURE__*/React__namespace.createElement(\"svg\", _extends({}, rest, {\n      \"aria-hidden\": true,\n      ref: ref,\n      width: isCustomShape ? width : width + computedStrokeWidth,\n      height: width,\n      viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n      style: {\n        position: 'absolute',\n        pointerEvents: 'none',\n        [xOffsetProp]: arrowX,\n        [yOffsetProp]: arrowY,\n        [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n        transform: [rotation, transform].filter(t => !!t).join(' '),\n        ...restStyle\n      }\n    }), computedStrokeWidth > 0 && /*#__PURE__*/React__namespace.createElement(\"path\", {\n      clipPath: \"url(#\" + clipPathId + \")\",\n      fill: \"none\",\n      stroke: stroke\n      // Account for the stroke on the fill path rendered below.\n      ,\n      strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n      d: dValue\n    }), /*#__PURE__*/React__namespace.createElement(\"path\", {\n      stroke: computedStrokeWidth && !d ? rest.fill : 'none',\n      d: dValue\n    }), /*#__PURE__*/React__namespace.createElement(\"clipPath\", {\n      id: clipPathId\n    }, /*#__PURE__*/React__namespace.createElement(\"rect\", {\n      x: -halfStrokeWidth,\n      y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n      width: width + computedStrokeWidth,\n      height: width\n    })));\n  });\n\n  function createPubSub() {\n    const map = new Map();\n    return {\n      emit(event, data) {\n        var _map$get;\n        (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n      },\n      on(event, listener) {\n        map.set(event, [...(map.get(event) || []), listener]);\n      },\n      off(event, listener) {\n        var _map$get2;\n        map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n      }\n    };\n  }\n\n  const FloatingNodeContext = /*#__PURE__*/React__namespace.createContext(null);\n  const FloatingTreeContext = /*#__PURE__*/React__namespace.createContext(null);\n\n  /**\n   * Returns the parent node id for nested floating elements, if available.\n   * Returns `null` for top-level floating elements.\n   */\n  const useFloatingParentNodeId = () => {\n    var _React$useContext;\n    return ((_React$useContext = React__namespace.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n  };\n\n  /**\n   * Returns the nearest floating tree context, if available.\n   */\n  const useFloatingTree = () => React__namespace.useContext(FloatingTreeContext);\n\n  /**\n   * Registers a node into the `FloatingTree`, returning its id.\n   * @see https://floating-ui.com/docs/FloatingTree\n   */\n  function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(() => {\n      const node = {\n        id,\n        parentId\n      };\n      tree == null || tree.addNode(node);\n      return () => {\n        tree == null || tree.removeNode(node);\n      };\n    }, [tree, id, parentId]);\n    return id;\n  }\n  /**\n   * Provides parent node context for nested floating elements.\n   * @see https://floating-ui.com/docs/FloatingTree\n   */\n  function FloatingNode(props) {\n    const {\n      children,\n      id\n    } = props;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/React__namespace.createElement(FloatingNodeContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        id,\n        parentId\n      }), [id, parentId])\n    }, children);\n  }\n  /**\n   * Provides context for nested floating elements when they are not children of\n   * each other on the DOM.\n   * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n   * - The `bubbles` option in the `useDismiss()` Hook\n   * - Nested virtual list navigation\n   * - Nested floating elements that each open on hover\n   * - Custom communication between parent and child floating elements\n   * @see https://floating-ui.com/docs/FloatingTree\n   */\n  function FloatingTree(props) {\n    const {\n      children\n    } = props;\n    const nodesRef = React__namespace.useRef([]);\n    const addNode = React__namespace.useCallback(node => {\n      nodesRef.current = [...nodesRef.current, node];\n    }, []);\n    const removeNode = React__namespace.useCallback(node => {\n      nodesRef.current = nodesRef.current.filter(n => n !== node);\n    }, []);\n    const events = React__namespace.useState(() => createPubSub())[0];\n    return /*#__PURE__*/React__namespace.createElement(FloatingTreeContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        nodesRef,\n        addNode,\n        removeNode,\n        events\n      }), [addNode, removeNode, events])\n    }, children);\n  }\n\n  function createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n  }\n\n  function useLatestRef(value) {\n    const ref = React.useRef(value);\n    index(() => {\n      ref.current = value;\n    });\n    return ref;\n  }\n\n  const safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\n  function getDelay(value, prop, pointerType) {\n    if (pointerType && !isMouseLikePointerType(pointerType)) {\n      return 0;\n    }\n    if (typeof value === 'number') {\n      return value;\n    }\n    return value == null ? void 0 : value[prop];\n  }\n  /**\n   * Opens the floating element while hovering over the reference element, like\n   * CSS `:hover`.\n   * @see https://floating-ui.com/docs/useHover\n   */\n  function useHover(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      dataRef,\n      events,\n      elements\n    } = context;\n    const {\n      enabled = true,\n      delay = 0,\n      handleClose = null,\n      mouseOnly = false,\n      restMs = 0,\n      move = true\n    } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const openRef = useLatestRef(open);\n    const pointerTypeRef = React__namespace.useRef();\n    const timeoutRef = React__namespace.useRef(-1);\n    const handlerRef = React__namespace.useRef();\n    const restTimeoutRef = React__namespace.useRef(-1);\n    const blockMouseMoveRef = React__namespace.useRef(true);\n    const performedPointerEventsMutationRef = React__namespace.useRef(false);\n    const unbindMouseMoveRef = React__namespace.useRef(() => {});\n    const restTimeoutPendingRef = React__namespace.useRef(false);\n    const isHoverOpen = React__namespace.useCallback(() => {\n      var _dataRef$current$open;\n      const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n      return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n    }, [dataRef]);\n\n    // When closing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    React__namespace.useEffect(() => {\n      if (!enabled) return;\n      function onOpenChange(_ref) {\n        let {\n          open\n        } = _ref;\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n          clearTimeout(restTimeoutRef.current);\n          blockMouseMoveRef.current = true;\n          restTimeoutPendingRef.current = false;\n        }\n      }\n      events.on('openchange', onOpenChange);\n      return () => {\n        events.off('openchange', onOpenChange);\n      };\n    }, [enabled, events]);\n    React__namespace.useEffect(() => {\n      if (!enabled) return;\n      if (!handleCloseRef.current) return;\n      if (!open) return;\n      function onLeave(event) {\n        if (isHoverOpen()) {\n          onOpenChange(false, event, 'hover');\n        }\n      }\n      const html = getDocument(elements.floating).documentElement;\n      html.addEventListener('mouseleave', onLeave);\n      return () => {\n        html.removeEventListener('mouseleave', onLeave);\n      };\n    }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n    const closeWithDelay = React__namespace.useCallback(function (event, runElseBranch, reason) {\n      if (runElseBranch === void 0) {\n        runElseBranch = true;\n      }\n      if (reason === void 0) {\n        reason = 'hover';\n      }\n      const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n      if (closeDelay && !handlerRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n      } else if (runElseBranch) {\n        clearTimeout(timeoutRef.current);\n        onOpenChange(false, event, reason);\n      }\n    }, [delayRef, onOpenChange]);\n    const cleanupMouseMoveHandler = useEffectEvent(() => {\n      unbindMouseMoveRef.current();\n      handlerRef.current = undefined;\n    });\n    const clearPointerEvents = useEffectEvent(() => {\n      if (performedPointerEventsMutationRef.current) {\n        const body = getDocument(elements.floating).body;\n        body.style.pointerEvents = '';\n        body.removeAttribute(safePolygonIdentifier);\n        performedPointerEventsMutationRef.current = false;\n      }\n    });\n    const isClickLikeOpenEvent = useEffectEvent(() => {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    });\n\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    React__namespace.useEffect(() => {\n      if (!enabled) return;\n      function onMouseEnter(event) {\n        clearTimeout(timeoutRef.current);\n        blockMouseMoveRef.current = false;\n        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || restMs > 0 && !getDelay(delayRef.current, 'open')) {\n          return;\n        }\n        const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n        if (openDelay) {\n          timeoutRef.current = window.setTimeout(() => {\n            if (!openRef.current) {\n              onOpenChange(true, event, 'hover');\n            }\n          }, openDelay);\n        } else if (!open) {\n          onOpenChange(true, event, 'hover');\n        }\n      }\n      function onMouseLeave(event) {\n        if (isClickLikeOpenEvent()) return;\n        unbindMouseMoveRef.current();\n        const doc = getDocument(elements.floating);\n        clearTimeout(restTimeoutRef.current);\n        restTimeoutPendingRef.current = false;\n        if (handleCloseRef.current && dataRef.current.floatingContext) {\n          // Prevent clearing `onScrollMouseLeave` timeout.\n          if (!open) {\n            clearTimeout(timeoutRef.current);\n          }\n          handlerRef.current = handleCloseRef.current({\n            ...dataRef.current.floatingContext,\n            tree,\n            x: event.clientX,\n            y: event.clientY,\n            onClose() {\n              clearPointerEvents();\n              cleanupMouseMoveHandler();\n              if (!isClickLikeOpenEvent()) {\n                closeWithDelay(event, true, 'safe-polygon');\n              }\n            }\n          });\n          const handler = handlerRef.current;\n          doc.addEventListener('mousemove', handler);\n          unbindMouseMoveRef.current = () => {\n            doc.removeEventListener('mousemove', handler);\n          };\n          return;\n        }\n\n        // Allow interactivity without `safePolygon` on touch devices. With a\n        // pointer, a short close delay is an alternative, so it should work\n        // consistently.\n        const shouldClose = pointerTypeRef.current === 'touch' ? !contains(elements.floating, event.relatedTarget) : true;\n        if (shouldClose) {\n          closeWithDelay(event);\n        }\n      }\n\n      // Ensure the floating element closes after scrolling even if the pointer\n      // did not move.\n      // https://github.com/floating-ui/floating-ui/discussions/1692\n      function onScrollMouseLeave(event) {\n        if (isClickLikeOpenEvent()) return;\n        if (!dataRef.current.floatingContext) return;\n        handleCloseRef.current == null || handleCloseRef.current({\n          ...dataRef.current.floatingContext,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            if (!isClickLikeOpenEvent()) {\n              closeWithDelay(event);\n            }\n          }\n        })(event);\n      }\n      if (isElement(elements.domReference)) {\n        var _elements$floating;\n        const ref = elements.domReference;\n        open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n        (_elements$floating = elements.floating) == null || _elements$floating.addEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.addEventListener('mousemove', onMouseEnter, {\n          once: true\n        });\n        ref.addEventListener('mouseenter', onMouseEnter);\n        ref.addEventListener('mouseleave', onMouseLeave);\n        return () => {\n          var _elements$floating2;\n          open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n          (_elements$floating2 = elements.floating) == null || _elements$floating2.removeEventListener('mouseleave', onScrollMouseLeave);\n          move && ref.removeEventListener('mousemove', onMouseEnter);\n          ref.removeEventListener('mouseenter', onMouseEnter);\n          ref.removeEventListener('mouseleave', onMouseLeave);\n        };\n      }\n    }, [elements, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent]);\n\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(() => {\n      var _handleCloseRef$curre;\n      if (!enabled) return;\n      if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n        performedPointerEventsMutationRef.current = true;\n        const floatingEl = elements.floating;\n        if (isElement(elements.domReference) && floatingEl) {\n          var _tree$nodesRef$curren;\n          const body = getDocument(elements.floating).body;\n          body.setAttribute(safePolygonIdentifier, '');\n          const ref = elements.domReference;\n          const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n          if (parentFloating) {\n            parentFloating.style.pointerEvents = '';\n          }\n          body.style.pointerEvents = 'none';\n          ref.style.pointerEvents = 'auto';\n          floatingEl.style.pointerEvents = 'auto';\n          return () => {\n            body.style.pointerEvents = '';\n            ref.style.pointerEvents = '';\n            floatingEl.style.pointerEvents = '';\n          };\n        }\n      }\n    }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);\n    index(() => {\n      if (!open) {\n        pointerTypeRef.current = undefined;\n        restTimeoutPendingRef.current = false;\n        cleanupMouseMoveHandler();\n        clearPointerEvents();\n      }\n    }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n    React__namespace.useEffect(() => {\n      return () => {\n        cleanupMouseMoveHandler();\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        clearPointerEvents();\n      };\n    }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n    const reference = React__namespace.useMemo(() => {\n      function setPointerRef(event) {\n        pointerTypeRef.current = event.pointerType;\n      }\n      return {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          const {\n            nativeEvent\n          } = event;\n          function handleMouseMove() {\n            if (!blockMouseMoveRef.current && !openRef.current) {\n              onOpenChange(true, nativeEvent, 'hover');\n            }\n          }\n          if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {\n            return;\n          }\n          if (open || restMs === 0) {\n            return;\n          }\n\n          // Ignore insignificant movements to account for tremors.\n          if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          if (pointerTypeRef.current === 'touch') {\n            handleMouseMove();\n          } else {\n            restTimeoutPendingRef.current = true;\n            restTimeoutRef.current = window.setTimeout(handleMouseMove, restMs);\n          }\n        }\n      };\n    }, [mouseOnly, onOpenChange, open, openRef, restMs]);\n    const floating = React__namespace.useMemo(() => ({\n      onMouseEnter() {\n        clearTimeout(timeoutRef.current);\n      },\n      onMouseLeave(event) {\n        if (!isClickLikeOpenEvent()) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    }), [closeWithDelay, isClickLikeOpenEvent]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference,\n      floating\n    } : {}, [enabled, reference, floating]);\n  }\n\n  const NOOP = () => {};\n  const FloatingDelayGroupContext = /*#__PURE__*/React__namespace.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: NOOP,\n    setState: NOOP,\n    isInstantPhase: false\n  });\n\n  /**\n   * @deprecated\n   * Use the return value of `useDelayGroup()` instead.\n   */\n  const useDelayGroupContext = () => React__namespace.useContext(FloatingDelayGroupContext);\n  /**\n   * Provides context for a group of floating elements that should share a\n   * `delay`.\n   * @see https://floating-ui.com/docs/FloatingDelayGroup\n   */\n  function FloatingDelayGroup(props) {\n    const {\n      children,\n      delay,\n      timeoutMs = 0\n    } = props;\n    const [state, setState] = React__namespace.useReducer((prev, next) => ({\n      ...prev,\n      ...next\n    }), {\n      delay,\n      timeoutMs,\n      initialDelay: delay,\n      currentId: null,\n      isInstantPhase: false\n    });\n    const initialCurrentIdRef = React__namespace.useRef(null);\n    const setCurrentId = React__namespace.useCallback(currentId => {\n      setState({\n        currentId\n      });\n    }, []);\n    index(() => {\n      if (state.currentId) {\n        if (initialCurrentIdRef.current === null) {\n          initialCurrentIdRef.current = state.currentId;\n        } else if (!state.isInstantPhase) {\n          setState({\n            isInstantPhase: true\n          });\n        }\n      } else {\n        if (state.isInstantPhase) {\n          setState({\n            isInstantPhase: false\n          });\n        }\n        initialCurrentIdRef.current = null;\n      }\n    }, [state.currentId, state.isInstantPhase]);\n    return /*#__PURE__*/React__namespace.createElement(FloatingDelayGroupContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        ...state,\n        setState,\n        setCurrentId\n      }), [state, setCurrentId])\n    }, children);\n  }\n  /**\n   * Enables grouping when called inside a component that's a child of a\n   * `FloatingDelayGroup`.\n   * @see https://floating-ui.com/docs/FloatingDelayGroup\n   */\n  function useDelayGroup(context, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      floatingId\n    } = context;\n    const {\n      id: optionId,\n      enabled = true\n    } = options;\n    const id = optionId != null ? optionId : floatingId;\n    const groupContext = useDelayGroupContext();\n    const {\n      currentId,\n      setCurrentId,\n      initialDelay,\n      setState,\n      timeoutMs\n    } = groupContext;\n    index(() => {\n      if (!enabled) return;\n      if (!currentId) return;\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }, [enabled, id, onOpenChange, setState, currentId, initialDelay]);\n    index(() => {\n      function unset() {\n        onOpenChange(false);\n        setState({\n          delay: initialDelay,\n          currentId: null\n        });\n      }\n      if (!enabled) return;\n      if (!currentId) return;\n      if (!open && currentId === id) {\n        if (timeoutMs) {\n          const timeout = window.setTimeout(unset, timeoutMs);\n          return () => {\n            clearTimeout(timeout);\n          };\n        }\n        unset();\n      }\n    }, [enabled, open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n    index(() => {\n      if (!enabled) return;\n      if (setCurrentId === NOOP || !open) return;\n      setCurrentId(id);\n    }, [enabled, open, setCurrentId, id]);\n    return groupContext;\n  }\n\n  /*!\n  * tabbable 6.2.0\n  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n  */\n  // NOTE: separate `:not()` selectors has broader browser support than the newer\n  //  `:not([inert], [inert] *)` (Feb 2023)\n  // CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n  //  the entire query to fail, resulting in no nodes found, which will break a lot\n  //  of things... so we have to rely on JS to identify nodes inside an inert container\n  var candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\n  var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\n  var NoElement = typeof Element === 'undefined';\n  var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n  var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n    var _element$getRootNode;\n    return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n  } : function (element) {\n    return element === null || element === void 0 ? void 0 : element.ownerDocument;\n  };\n\n  /**\n   * Determines if a node is inert or in an inert ancestor.\n   * @param {Element} [node]\n   * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n   *  see if any of them are inert. If false, only `node` itself is considered.\n   * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n   *  False if `node` is falsy.\n   */\n  var isInert = function isInert(node, lookUp) {\n    var _node$getAttribute;\n    if (lookUp === void 0) {\n      lookUp = true;\n    }\n    // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n    //  JS API property; we have to check the attribute, which can either be empty or 'true';\n    //  if it's `null` (not specified) or 'false', it's an active element\n    var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n    var inert = inertAtt === '' || inertAtt === 'true';\n\n    // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n    //  if it weren't for `matches()` not being a function on shadow roots; the following\n    //  code works for any kind of node\n    // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n    //  so it likely would not support `:is([inert] *)` either...\n    var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n    return result;\n  };\n\n  /**\n   * Determines if a node's content is editable.\n   * @param {Element} [node]\n   * @returns True if it's content-editable; false if it's not or `node` is falsy.\n   */\n  var isContentEditable = function isContentEditable(node) {\n    var _node$getAttribute2;\n    // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n    //  to use the attribute directly to check for this, which can either be empty or 'true';\n    //  if it's `null` (not specified) or 'false', it's a non-editable element\n    var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n    return attValue === '' || attValue === 'true';\n  };\n\n  /**\n   * @param {Element} el container to check in\n   * @param {boolean} includeContainer add container to check\n   * @param {(node: Element) => boolean} filter filter candidates\n   * @returns {Element[]}\n   */\n  var getCandidates = function getCandidates(el, includeContainer, filter) {\n    // even if `includeContainer=false`, we still have to check it for inertness because\n    //  if it's inert, all its children are inert\n    if (isInert(el)) {\n      return [];\n    }\n    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n    if (includeContainer && matches.call(el, candidateSelector)) {\n      candidates.unshift(el);\n    }\n    candidates = candidates.filter(filter);\n    return candidates;\n  };\n\n  /**\n   * @callback GetShadowRoot\n   * @param {Element} element to check for shadow root\n   * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n   */\n\n  /**\n   * @callback ShadowRootFilter\n   * @param {Element} shadowHostNode the element which contains shadow content\n   * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n   */\n\n  /**\n   * @typedef {Object} CandidateScope\n   * @property {Element} scopeParent contains inner candidates\n   * @property {Element[]} candidates list of candidates found in the scope parent\n   */\n\n  /**\n   * @typedef {Object} IterativeOptions\n   * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n   *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n   *  or a boolean stating if it has an undisclosed shadow root\n   * @property {(node: Element) => boolean} filter filter candidates\n   * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n   * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n   */\n\n  /**\n   * @param {Element[]} elements list of element containers to match candidates from\n   * @param {boolean} includeContainer add container list to check\n   * @param {IterativeOptions} options\n   * @returns {Array.<Element|CandidateScope>}\n   */\n  var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n    var candidates = [];\n    var elementsToCheck = Array.from(elements);\n    while (elementsToCheck.length) {\n      var element = elementsToCheck.shift();\n      if (isInert(element, false)) {\n        // no need to look up since we're drilling down\n        // anything inside this container will also be inert\n        continue;\n      }\n      if (element.tagName === 'SLOT') {\n        // add shadow dom slot scope (slot itself cannot be focusable)\n        var assigned = element.assignedElements();\n        var content = assigned.length ? assigned : element.children;\n        var nestedCandidates = getCandidatesIteratively(content, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: nestedCandidates\n          });\n        }\n      } else {\n        // check candidate element\n        var validCandidate = matches.call(element, candidateSelector);\n        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n          candidates.push(element);\n        }\n\n        // iterate over shadow content if possible\n        var shadowRoot = element.shadowRoot ||\n        // check for an undisclosed shadow\n        typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n        // no inert look up because we're already drilling down and checking for inertness\n        //  on the way down, so all containers to this root node should have already been\n        //  vetted as non-inert\n        var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n        if (shadowRoot && validShadowRoot) {\n          // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n          //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n          //  child candidates found because they're likely slotted elements (elements that are\n          //  children of the web component element (which has the shadow), in the light dom, but\n          //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n          //  _after_ we return from this recursive call\n          var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n          if (options.flatten) {\n            candidates.push.apply(candidates, _nestedCandidates);\n          } else {\n            candidates.push({\n              scopeParent: element,\n              candidates: _nestedCandidates\n            });\n          }\n        } else {\n          // there's not shadow so just dig into the element's (light dom) children\n          //  __without__ giving the element special scope treatment\n          elementsToCheck.unshift.apply(elementsToCheck, element.children);\n        }\n      }\n    }\n    return candidates;\n  };\n\n  /**\n   * @private\n   * Determines if the node has an explicitly specified `tabindex` attribute.\n   * @param {HTMLElement} node\n   * @returns {boolean} True if so; false if not.\n   */\n  var hasTabIndex = function hasTabIndex(node) {\n    return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n  };\n\n  /**\n   * Determine the tab index of a given node.\n   * @param {HTMLElement} node\n   * @returns {number} Tab order (negative, 0, or positive number).\n   * @throws {Error} If `node` is falsy.\n   */\n  var getTabIndex = function getTabIndex(node) {\n    if (!node) {\n      throw new Error('No node provided');\n    }\n    if (node.tabIndex < 0) {\n      // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n      // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n      // yet they are still part of the regular tab order; in FF, they get a default\n      // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n      // order, consider their tab index to be 0.\n      // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n      // so if they don't have a tabindex attribute specifically set, assume it's 0.\n      if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n        return 0;\n      }\n    }\n    return node.tabIndex;\n  };\n\n  /**\n   * Determine the tab index of a given node __for sort order purposes__.\n   * @param {HTMLElement} node\n   * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n   *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n   *  inserted into the correct sort position.\n   * @returns {number} Tab order (negative, 0, or positive number).\n   */\n  var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n    var tabIndex = getTabIndex(node);\n    if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n      return 0;\n    }\n    return tabIndex;\n  };\n  var sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n  };\n  var isInput = function isInput(node) {\n    return node.tagName === 'INPUT';\n  };\n  var isHiddenInput = function isHiddenInput(node) {\n    return isInput(node) && node.type === 'hidden';\n  };\n  var isDetailsWithSummary = function isDetailsWithSummary(node) {\n    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n      return child.tagName === 'SUMMARY';\n    });\n    return r;\n  };\n  var getCheckedRadio = function getCheckedRadio(nodes, form) {\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].checked && nodes[i].form === form) {\n        return nodes[i];\n      }\n    }\n  };\n  var isTabbableRadio = function isTabbableRadio(node) {\n    if (!node.name) {\n      return true;\n    }\n    var radioScope = node.form || getRootNode(node);\n    var queryRadios = function queryRadios(name) {\n      return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n    };\n    var radioSet;\n    if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n      radioSet = queryRadios(window.CSS.escape(node.name));\n    } else {\n      try {\n        radioSet = queryRadios(node.name);\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n        return false;\n      }\n    }\n    var checked = getCheckedRadio(radioSet, node.form);\n    return !checked || checked === node;\n  };\n  var isRadio = function isRadio(node) {\n    return isInput(node) && node.type === 'radio';\n  };\n  var isNonTabbableRadio = function isNonTabbableRadio(node) {\n    return isRadio(node) && !isTabbableRadio(node);\n  };\n\n  // determines if a node is ultimately attached to the window's document\n  var isNodeAttached = function isNodeAttached(node) {\n    var _nodeRoot;\n    // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n    //  (but NOT _the_ document; see second 'If' comment below for more).\n    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n    //  is attached, and the one we need to check if it's in the document or not (because the\n    //  shadow, and all nodes it contains, is never considered in the document since shadows\n    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n    //  visibility, including all the nodes it contains). The host could be any normal node,\n    //  or a custom element (i.e. web component). Either way, that's the one that is considered\n    //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n    //  tested).\n    // To further complicate things, we have to look all the way up until we find a shadow HOST\n    //  that is attached (or find none) because the node might be in nested shadows...\n    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n    //  document (per the docs) and while it's a Document-type object, that document does not\n    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n    //  node is actually detached.\n    // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n    //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n    //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n    //  `ownerDocument` will be `null`, hence the optional chaining on it.\n    var nodeRoot = node && getRootNode(node);\n    var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n    // in some cases, a detached node will return itself as the root instead of a document or\n    //  shadow root object, in which case, we shouldn't try to look further up the host chain\n    var attached = false;\n    if (nodeRoot && nodeRoot !== node) {\n      var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n      attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n      while (!attached && nodeRootHost) {\n        var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n        // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n        //  which means we need to get the host's host and check if that parent host is contained\n        //  in (i.e. attached to) the document\n        nodeRoot = getRootNode(nodeRootHost);\n        nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n      }\n    }\n    return attached;\n  };\n  var isZeroArea = function isZeroArea(node) {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n    return width === 0 && height === 0;\n  };\n  var isHidden = function isHidden(node, _ref) {\n    var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n    // NOTE: visibility will be `undefined` if node is detached from the document\n    //  (see notes about this further down), which means we will consider it visible\n    //  (this is legacy behavior from a very long way back)\n    // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n    //  _visibility_ check, not a _display_ check\n    if (getComputedStyle(node).visibility === 'hidden') {\n      return true;\n    }\n    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n      return true;\n    }\n    if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n      if (typeof getShadowRoot === 'function') {\n        // figure out if we should consider the node to be in an undisclosed shadow and use the\n        //  'non-zero-area' fallback\n        var originalNode = node;\n        while (node) {\n          var parentElement = node.parentElement;\n          var rootNode = getRootNode(node);\n          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n          ) {\n            // node has an undisclosed shadow which means we can only treat it as a black box, so we\n            //  fall back to a non-zero-area test\n            return isZeroArea(node);\n          } else if (node.assignedSlot) {\n            // iterate up slot\n            node = node.assignedSlot;\n          } else if (!parentElement && rootNode !== node.ownerDocument) {\n            // cross shadow boundary\n            node = rootNode.host;\n          } else {\n            // iterate up normal dom\n            node = parentElement;\n          }\n        }\n        node = originalNode;\n      }\n      // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n      //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n      //  it might be a falsy value, which means shadow DOM support is disabled\n\n      // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n      //  now we can just test to see if it would normally be visible or not, provided it's\n      //  attached to the main document.\n      // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n      //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n      if (isNodeAttached(node)) {\n        // this works wherever the node is: if there's at least one client rect, it's\n        //  somehow displayed; it also covers the CSS 'display: contents' case where the\n        //  node itself is hidden in place of its contents; and there's no need to search\n        //  up the hierarchy either\n        return !node.getClientRects().length;\n      }\n\n      // Else, the node isn't attached to the document, which means the `getClientRects()`\n      //  API will __always__ return zero rects (this can happen, for example, if React\n      //  is used to render nodes onto a detached tree, as confirmed in this thread:\n      //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n      //\n      // It also means that even window.getComputedStyle(node).display will return `undefined`\n      //  because styles are only computed for nodes that are in the document.\n      //\n      // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n      //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n      //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n      //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n      //  considering __everything__ to be visible because of the innability to determine styles.\n      //\n      // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n      //  nodes as visible with the 'none' fallback.__\n      if (displayCheck !== 'legacy-full') {\n        return true; // hidden\n      }\n      // else, fallback to 'none' mode and consider the node visible\n    } else if (displayCheck === 'non-zero-area') {\n      // NOTE: Even though this tests that the node's client rect is non-zero to determine\n      //  whether it's displayed, and that a detached node will __always__ have a zero-area\n      //  client rect, we don't special-case for whether the node is attached or not. In\n      //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n      //  times, and that includes attached or not.\n      return isZeroArea(node);\n    }\n\n    // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n    //  it's visible\n    return false;\n  };\n\n  // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n  //  unless they are in the _first_ <legend> element of the top-most disabled\n  //  fieldset\n  var isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n      var parentNode = node.parentElement;\n      // check if `node` is contained in a disabled <fieldset>\n      while (parentNode) {\n        if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n          // look for the first <legend> among the children of the disabled <fieldset>\n          for (var i = 0; i < parentNode.children.length; i++) {\n            var child = parentNode.children.item(i);\n            // when the first <legend> (in document order) is found\n            if (child.tagName === 'LEGEND') {\n              // if its parent <fieldset> is not nested in another disabled <fieldset>,\n              // return whether `node` is a descendant of its first <legend>\n              return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n            }\n          }\n          // the disabled <fieldset> containing `node` has no <legend>\n          return true;\n        }\n        parentNode = parentNode.parentElement;\n      }\n    }\n\n    // else, node's tabbable/focusable state should not be affected by a fieldset's\n    //  enabled/disabled state\n    return false;\n  };\n  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n    if (node.disabled ||\n    // we must do an inert look up to filter out any elements inside an inert ancestor\n    //  because we're limited in the type of selectors we can use in JSDom (see related\n    //  note related to `candidateSelectors`)\n    isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n      return false;\n    }\n    return true;\n  };\n  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n    if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n      return false;\n    }\n    return true;\n  };\n  var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n    var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n    if (isNaN(tabIndex) || tabIndex >= 0) {\n      return true;\n    }\n    // If a custom element has an explicit negative tabindex,\n    // browsers will not allow tab targeting said element's children.\n    return false;\n  };\n\n  /**\n   * @param {Array.<Element|CandidateScope>} candidates\n   * @returns Element[]\n   */\n  var sortByOrder = function sortByOrder(candidates) {\n    var regularTabbables = [];\n    var orderedTabbables = [];\n    candidates.forEach(function (item, i) {\n      var isScope = !!item.scopeParent;\n      var element = isScope ? item.scopeParent : item;\n      var candidateTabindex = getSortOrderTabIndex(element, isScope);\n      var elements = isScope ? sortByOrder(item.candidates) : element;\n      if (candidateTabindex === 0) {\n        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n      } else {\n        orderedTabbables.push({\n          documentOrder: i,\n          tabIndex: candidateTabindex,\n          item: item,\n          isScope: isScope,\n          content: elements\n        });\n      }\n    });\n    return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n      return acc;\n    }, []).concat(regularTabbables);\n  };\n  var tabbable = function tabbable(container, options) {\n    options = options || {};\n    var candidates;\n    if (options.getShadowRoot) {\n      candidates = getCandidatesIteratively([container], options.includeContainer, {\n        filter: isNodeMatchingSelectorTabbable.bind(null, options),\n        flatten: false,\n        getShadowRoot: options.getShadowRoot,\n        shadowRootFilter: isValidShadowRootTabbable\n      });\n    } else {\n      candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n    }\n    return sortByOrder(candidates);\n  };\n  var isTabbable = function isTabbable(node, options) {\n    options = options || {};\n    if (!node) {\n      throw new Error('No node provided');\n    }\n    if (matches.call(node, candidateSelector) === false) {\n      return false;\n    }\n    return isNodeMatchingSelectorTabbable(options, node);\n  };\n\n  let rafId = 0;\n  function enqueueFocus(el, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      preventScroll = false,\n      cancelPrevious = true,\n      sync = false\n    } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = () => el == null ? void 0 : el.focus({\n      preventScroll\n    });\n    if (sync) {\n      exec();\n    } else {\n      rafId = requestAnimationFrame(exec);\n    }\n  }\n\n  function getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while (currentParentId) {\n      const currentNode = nodes.find(node => node.id === currentParentId);\n      currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n      if (currentNode) {\n        allAncestors = allAncestors.concat(currentNode);\n      }\n    }\n    return allAncestors;\n  }\n\n  function getChildren(nodes, id) {\n    let allChildren = nodes.filter(node => {\n      var _node$context;\n      return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while (currentChildren.length) {\n      currentChildren = nodes.filter(node => {\n        var _currentChildren;\n        return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n          var _node$context2;\n          return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n        });\n      });\n      allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n  }\n  function getDeepestNode(nodes, id) {\n    let deepestNodeId;\n    let maxDepth = -1;\n    function findDeepest(nodeId, depth) {\n      if (depth > maxDepth) {\n        deepestNodeId = nodeId;\n        maxDepth = depth;\n      }\n      const children = getChildren(nodes, nodeId);\n      children.forEach(child => {\n        findDeepest(child.id, depth + 1);\n      });\n    }\n    findDeepest(id, 0);\n    return nodes.find(node => node.id === deepestNodeId);\n  }\n\n  // Modified to add conditional `aria-hidden` support:\n  // https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\n  let counterMap = /*#__PURE__*/new WeakMap();\n  let uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\n  let markerMap = {};\n  let lockCount$1 = 0;\n  const supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\n  const unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\n  const correctElements = (parent, targets) => targets.map(target => {\n    if (parent.contains(target)) {\n      return target;\n    }\n    const correctedTarget = unwrapHost(target);\n    if (parent.contains(correctedTarget)) {\n      return correctedTarget;\n    }\n    return null;\n  }).filter(x => x != null);\n  function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n    const markerName = 'data-floating-ui-inert';\n    const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n    const avoidElements = correctElements(body, uncorrectedAvoidElements);\n    const elementsToKeep = new Set();\n    const elementsToStop = new Set(avoidElements);\n    const hiddenElements = [];\n    if (!markerMap[markerName]) {\n      markerMap[markerName] = new WeakMap();\n    }\n    const markerCounter = markerMap[markerName];\n    avoidElements.forEach(keep);\n    deep(body);\n    elementsToKeep.clear();\n    function keep(el) {\n      if (!el || elementsToKeep.has(el)) {\n        return;\n      }\n      elementsToKeep.add(el);\n      el.parentNode && keep(el.parentNode);\n    }\n    function deep(parent) {\n      if (!parent || elementsToStop.has(parent)) {\n        return;\n      }\n      [].forEach.call(parent.children, node => {\n        if (getNodeName(node) === 'script') return;\n        if (elementsToKeep.has(node)) {\n          deep(node);\n        } else {\n          const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n          const alreadyHidden = attr !== null && attr !== 'false';\n          const counterValue = (counterMap.get(node) || 0) + 1;\n          const markerValue = (markerCounter.get(node) || 0) + 1;\n          counterMap.set(node, counterValue);\n          markerCounter.set(node, markerValue);\n          hiddenElements.push(node);\n          if (counterValue === 1 && alreadyHidden) {\n            uncontrolledElementsSet.add(node);\n          }\n          if (markerValue === 1) {\n            node.setAttribute(markerName, '');\n          }\n          if (!alreadyHidden && controlAttribute) {\n            node.setAttribute(controlAttribute, 'true');\n          }\n        }\n      });\n    }\n    lockCount$1++;\n    return () => {\n      hiddenElements.forEach(element => {\n        const counterValue = (counterMap.get(element) || 0) - 1;\n        const markerValue = (markerCounter.get(element) || 0) - 1;\n        counterMap.set(element, counterValue);\n        markerCounter.set(element, markerValue);\n        if (!counterValue) {\n          if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n            element.removeAttribute(controlAttribute);\n          }\n          uncontrolledElementsSet.delete(element);\n        }\n        if (!markerValue) {\n          element.removeAttribute(markerName);\n        }\n      });\n      lockCount$1--;\n      if (!lockCount$1) {\n        counterMap = new WeakMap();\n        counterMap = new WeakMap();\n        uncontrolledElementsSet = new WeakSet();\n        markerMap = {};\n      }\n    };\n  }\n  function markOthers(avoidElements, ariaHidden, inert) {\n    if (ariaHidden === void 0) {\n      ariaHidden = false;\n    }\n    if (inert === void 0) {\n      inert = false;\n    }\n    const body = getDocument(avoidElements[0]).body;\n    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n  }\n\n  const getTabbableOptions = () => ({\n    getShadowRoot: true,\n    displayCheck:\n    // JSDOM does not support the `tabbable` library. To solve this we can\n    // check if `ResizeObserver` is a real function (not polyfilled), which\n    // determines if the current environment is JSDOM-like.\n    typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n  });\n  function getTabbableIn(container, direction) {\n    const allTabbable = tabbable(container, getTabbableOptions());\n    if (direction === 'prev') {\n      allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf(activeElement(getDocument(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n  }\n  function getNextTabbable() {\n    return getTabbableIn(document.body, 'next');\n  }\n  function getPreviousTabbable() {\n    return getTabbableIn(document.body, 'prev');\n  }\n  function isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !contains(containerElement, relatedTarget);\n  }\n  function disableFocusInside(container) {\n    const tabbableElements = tabbable(container, getTabbableOptions());\n    tabbableElements.forEach(element => {\n      element.dataset.tabindex = element.getAttribute('tabindex') || '';\n      element.setAttribute('tabindex', '-1');\n    });\n  }\n  function enableFocusInside(container) {\n    const elements = container.querySelectorAll('[data-tabindex]');\n    elements.forEach(element => {\n      const tabindex = element.dataset.tabindex;\n      delete element.dataset.tabindex;\n      if (tabindex) {\n        element.setAttribute('tabindex', tabindex);\n      } else {\n        element.removeAttribute('tabindex');\n      }\n    });\n  }\n\n  // See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\n  const HIDDEN_STYLES = {\n    border: 0,\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: 0,\n    position: 'fixed',\n    whiteSpace: 'nowrap',\n    width: '1px',\n    top: 0,\n    left: 0\n  };\n  let timeoutId;\n  function setActiveElementOnTab(event) {\n    if (event.key === 'Tab') {\n      event.target;\n      clearTimeout(timeoutId);\n    }\n  }\n  const FocusGuard = /*#__PURE__*/React__namespace.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = React__namespace.useState();\n    index(() => {\n      if (isSafari()) {\n        // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n        // on VoiceOver does trigger the onFocus event, so we can use the focus\n        // trap element. On Safari, only buttons trigger the onFocus event.\n        // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n        // button role.\n        setRole('button');\n      }\n      document.addEventListener('keydown', setActiveElementOnTab);\n      return () => {\n        document.removeEventListener('keydown', setActiveElementOnTab);\n      };\n    }, []);\n    const restProps = {\n      ref,\n      tabIndex: 0,\n      // Role is only for VoiceOver\n      role,\n      'aria-hidden': role ? undefined : true,\n      [createAttribute('focus-guard')]: '',\n      style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/React__namespace.createElement(\"span\", _extends({}, props, restProps));\n  });\n\n  const PortalContext = /*#__PURE__*/React__namespace.createContext(null);\n  const attr = /*#__PURE__*/createAttribute('portal');\n  /**\n   * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n   */\n  function useFloatingPortalNode(props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      id,\n      root\n    } = props;\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const [portalNode, setPortalNode] = React__namespace.useState(null);\n    const portalNodeRef = React__namespace.useRef(null);\n    index(() => {\n      return () => {\n        portalNode == null || portalNode.remove();\n        // Allow the subsequent layout effects to create a new node on updates.\n        // The portal node will still be cleaned up on unmount.\n        // https://github.com/floating-ui/floating-ui/issues/2454\n        queueMicrotask(() => {\n          portalNodeRef.current = null;\n        });\n      };\n    }, [portalNode]);\n    index(() => {\n      // Wait for the uniqueId to be generated before creating the portal node in\n      // React <18 (using `useFloatingId` instead of the native `useId`).\n      // https://github.com/floating-ui/floating-ui/issues/2778\n      if (!uniqueId) return;\n      if (portalNodeRef.current) return;\n      const existingIdRoot = id ? document.getElementById(id) : null;\n      if (!existingIdRoot) return;\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      existingIdRoot.appendChild(subRoot);\n      portalNodeRef.current = subRoot;\n      setPortalNode(subRoot);\n    }, [id, uniqueId]);\n    index(() => {\n      // Wait for the root to exist before creating the portal node. The root must\n      // be stored in state, not a ref, for this to work reactively.\n      if (root === null) return;\n      if (!uniqueId) return;\n      if (portalNodeRef.current) return;\n      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n      if (container && !isElement(container)) container = container.current;\n      container = container || document.body;\n      let idWrapper = null;\n      if (id) {\n        idWrapper = document.createElement('div');\n        idWrapper.id = id;\n        container.appendChild(idWrapper);\n      }\n      const subRoot = document.createElement('div');\n      subRoot.id = uniqueId;\n      subRoot.setAttribute(attr, '');\n      container = idWrapper || container;\n      container.appendChild(subRoot);\n      portalNodeRef.current = subRoot;\n      setPortalNode(subRoot);\n    }, [id, root, uniqueId, portalContext]);\n    return portalNode;\n  }\n  /**\n   * Portals the floating element into a given container element — by default,\n   * outside of the app root and into the body.\n   * This is necessary to ensure the floating element can appear outside any\n   * potential parent containers that cause clipping (such as `overflow: hidden`),\n   * while retaining its location in the React tree.\n   * @see https://floating-ui.com/docs/FloatingPortal\n   */\n  function FloatingPortal(props) {\n    const {\n      children,\n      id,\n      root,\n      preserveTabOrder = true\n    } = props;\n    const portalNode = useFloatingPortalNode({\n      id,\n      root\n    });\n    const [focusManagerState, setFocusManagerState] = React__namespace.useState(null);\n    const beforeOutsideRef = React__namespace.useRef(null);\n    const afterOutsideRef = React__namespace.useRef(null);\n    const beforeInsideRef = React__namespace.useRef(null);\n    const afterInsideRef = React__namespace.useRef(null);\n    const modal = focusManagerState == null ? void 0 : focusManagerState.modal;\n    const open = focusManagerState == null ? void 0 : focusManagerState.open;\n    const shouldRenderGuards =\n    // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState &&\n    // Guards are only for non-modal focus management.\n    !focusManagerState.modal &&\n    // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    React__namespace.useEffect(() => {\n      if (!portalNode || !preserveTabOrder || modal) {\n        return;\n      }\n\n      // Make sure elements inside the portal element are tabbable only when the\n      // portal has already been focused, either by tabbing into a focus trap\n      // element outside or using the mouse.\n      function onFocus(event) {\n        if (portalNode && isOutsideEvent(event)) {\n          const focusing = event.type === 'focusin';\n          const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n          manageFocus(portalNode);\n        }\n      }\n      // Listen to the event on the capture phase so they run before the focus\n      // trap elements onFocus prop is called.\n      portalNode.addEventListener('focusin', onFocus, true);\n      portalNode.addEventListener('focusout', onFocus, true);\n      return () => {\n        portalNode.removeEventListener('focusin', onFocus, true);\n        portalNode.removeEventListener('focusout', onFocus, true);\n      };\n    }, [portalNode, preserveTabOrder, modal]);\n    React__namespace.useEffect(() => {\n      if (!portalNode) return;\n      if (open) return;\n      enableFocusInside(portalNode);\n    }, [open, portalNode]);\n    return /*#__PURE__*/React__namespace.createElement(PortalContext.Provider, {\n      value: React__namespace.useMemo(() => ({\n        preserveTabOrder,\n        beforeOutsideRef,\n        afterOutsideRef,\n        beforeInsideRef,\n        afterInsideRef,\n        portalNode,\n        setFocusManagerState\n      }), [preserveTabOrder, portalNode])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"outside\",\n      ref: beforeOutsideRef,\n      onFocus: event => {\n        if (isOutsideEvent(event, portalNode)) {\n          var _beforeInsideRef$curr;\n          (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n        } else {\n          const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n          prevTabbable == null || prevTabbable.focus();\n        }\n      }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/React__namespace.createElement(\"span\", {\n      \"aria-owns\": portalNode.id,\n      style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/ReactDOM__namespace.createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"outside\",\n      ref: afterOutsideRef,\n      onFocus: event => {\n        if (isOutsideEvent(event, portalNode)) {\n          var _afterInsideRef$curre;\n          (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n        } else {\n          const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n          nextTabbable == null || nextTabbable.focus();\n          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, 'focus-out'));\n        }\n      }\n    }));\n  }\n  const usePortalContext = () => React__namespace.useContext(PortalContext);\n\n  const FOCUSABLE_ATTRIBUTE = 'data-floating-ui-focusable';\n  function getFloatingFocusElement(floatingElement) {\n    if (!floatingElement) {\n      return null;\n    }\n    // Try to find the element that has `{...getFloatingProps()}` spread on it.\n    // This indicates the floating element is acting as a positioning wrapper, and\n    // so focus should be managed on the child element with the event handlers and\n    // aria props.\n    return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(\"[\" + FOCUSABLE_ATTRIBUTE + \"]\") || floatingElement;\n  }\n\n  const LIST_LIMIT = 20;\n  let previouslyFocusedElements = [];\n  function addPreviouslyFocusedElement(element) {\n    previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n    let tabbableEl = element;\n    if (!tabbableEl || getNodeName(tabbableEl) === 'body') return;\n    if (!isTabbable(tabbableEl, getTabbableOptions())) {\n      const tabbableChild = tabbable(tabbableEl, getTabbableOptions())[0];\n      if (tabbableChild) {\n        tabbableEl = tabbableChild;\n      }\n    }\n    previouslyFocusedElements.push(tabbableEl);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n  }\n  function getPreviouslyFocusedElement() {\n    return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n  }\n  const VisuallyHiddenDismiss = /*#__PURE__*/React__namespace.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/React__namespace.createElement(\"button\", _extends({}, props, {\n      type: \"button\",\n      ref: ref,\n      tabIndex: -1,\n      style: HIDDEN_STYLES\n    }));\n  });\n  /**\n   * Provides focus management for the floating element.\n   * @see https://floating-ui.com/docs/FloatingFocusManager\n   */\n  function FloatingFocusManager(props) {\n    const {\n      context,\n      children,\n      disabled = false,\n      order = ['content'],\n      guards: _guards = true,\n      initialFocus = 0,\n      returnFocus = true,\n      restoreFocus = false,\n      modal = true,\n      visuallyHiddenDismiss = false,\n      closeOnFocusOut = true\n    } = props;\n    const {\n      open,\n      refs,\n      nodeId,\n      onOpenChange,\n      events,\n      dataRef,\n      floatingId,\n      elements: {\n        domReference,\n        floating\n      }\n    } = context;\n    const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;\n\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = supportsInert() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const startDismissButtonRef = React__namespace.useRef(null);\n    const endDismissButtonRef = React__namespace.useRef(null);\n    const preventReturnFocusRef = React__namespace.useRef(false);\n    const isPointerDownRef = React__namespace.useRef(false);\n    const tabbableIndexRef = React__namespace.useRef(-1);\n    const isInsidePortal = portalContext != null;\n    const floatingFocusElement = getFloatingFocusElement(floating);\n    const getTabbableContent = useEffectEvent(function (container) {\n      if (container === void 0) {\n        container = floatingFocusElement;\n      }\n      return container ? tabbable(container, getTabbableOptions()) : [];\n    });\n    const getTabbableElements = useEffectEvent(container => {\n      const content = getTabbableContent(container);\n      return orderRef.current.map(type => {\n        if (domReference && type === 'reference') {\n          return domReference;\n        }\n        if (floatingFocusElement && type === 'floating') {\n          return floatingFocusElement;\n        }\n        return content;\n      }).filter(Boolean).flat();\n    });\n    React__namespace.useEffect(() => {\n      if (disabled) return;\n      if (!modal) return;\n      function onKeyDown(event) {\n        if (event.key === 'Tab') {\n          // The focus guards have nothing to focus, so we need to stop the event.\n          if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n            stopEvent(event);\n          }\n          const els = getTabbableElements();\n          const target = getTarget(event);\n          if (orderRef.current[0] === 'reference' && target === domReference) {\n            stopEvent(event);\n            if (event.shiftKey) {\n              enqueueFocus(els[els.length - 1]);\n            } else {\n              enqueueFocus(els[1]);\n            }\n          }\n          if (orderRef.current[1] === 'floating' && target === floatingFocusElement && event.shiftKey) {\n            stopEvent(event);\n            enqueueFocus(els[0]);\n          }\n        }\n      }\n      const doc = getDocument(floatingFocusElement);\n      doc.addEventListener('keydown', onKeyDown);\n      return () => {\n        doc.removeEventListener('keydown', onKeyDown);\n      };\n    }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n    React__namespace.useEffect(() => {\n      if (disabled) return;\n      if (!floating) return;\n      function handleFocusIn(event) {\n        const target = getTarget(event);\n        const tabbableContent = getTabbableContent();\n        const tabbableIndex = tabbableContent.indexOf(target);\n        if (tabbableIndex !== -1) {\n          tabbableIndexRef.current = tabbableIndex;\n        }\n      }\n      floating.addEventListener('focusin', handleFocusIn);\n      return () => {\n        floating.removeEventListener('focusin', handleFocusIn);\n      };\n    }, [disabled, floating, getTabbableContent]);\n    React__namespace.useEffect(() => {\n      if (disabled) return;\n      if (!closeOnFocusOut) return;\n\n      // In Safari, buttons lose focus when pressing them.\n      function handlePointerDown() {\n        isPointerDownRef.current = true;\n        setTimeout(() => {\n          isPointerDownRef.current = false;\n        });\n      }\n      function handleFocusOutside(event) {\n        const relatedTarget = event.relatedTarget;\n        queueMicrotask(() => {\n          const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n            var _node$context, _node$context2;\n            return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n          }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n            var _node$context3, _node$context4;\n            return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n          })));\n\n          // Restore focus to the previous tabbable element index to prevent\n          // focus from being lost outside the floating tree.\n          if (restoreFocus && movedToUnrelatedNode && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {\n            // Let `FloatingPortal` effect knows that focus is still inside the\n            // floating tree.\n            if (isHTMLElement(floatingFocusElement)) {\n              floatingFocusElement.focus();\n            }\n            const prevTabbableIndex = tabbableIndexRef.current;\n            const tabbableContent = getTabbableContent();\n            const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n            if (isHTMLElement(nodeToFocus)) {\n              nodeToFocus.focus();\n            }\n          }\n\n          // Focus did not move inside the floating tree, and there are no tabbable\n          // portal guards to handle closing.\n          if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n          // Fix React 18 Strict Mode returnFocus due to double rendering.\n          relatedTarget !== getPreviouslyFocusedElement()) {\n            preventReturnFocusRef.current = true;\n            onOpenChange(false, event, 'focus-out');\n          }\n        });\n      }\n      if (floating && isHTMLElement(domReference)) {\n        domReference.addEventListener('focusout', handleFocusOutside);\n        domReference.addEventListener('pointerdown', handlePointerDown);\n        floating.addEventListener('focusout', handleFocusOutside);\n        return () => {\n          domReference.removeEventListener('focusout', handleFocusOutside);\n          domReference.removeEventListener('pointerdown', handlePointerDown);\n          floating.removeEventListener('focusout', handleFocusOutside);\n        };\n      }\n    }, [disabled, domReference, floating, floatingFocusElement, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox]);\n    React__namespace.useEffect(() => {\n      var _portalContext$portal;\n      if (disabled) return;\n\n      // Don't hide portals nested within the parent portal.\n      const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n      if (floating) {\n        const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n        const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n        return () => {\n          cleanup();\n        };\n      }\n    }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n    index(() => {\n      if (disabled || !isHTMLElement(floatingFocusElement)) return;\n      const doc = getDocument(floatingFocusElement);\n      const previouslyFocusedElement = activeElement(doc);\n\n      // Wait for any layout effect state setters to execute to set `tabIndex`.\n      queueMicrotask(() => {\n        const focusableElements = getTabbableElements(floatingFocusElement);\n        const initialFocusValue = initialFocusRef.current;\n        const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;\n        const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);\n        if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n          enqueueFocus(elToFocus, {\n            preventScroll: elToFocus === floatingFocusElement\n          });\n        }\n      });\n    }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n    index(() => {\n      if (disabled || !floatingFocusElement) return;\n      let preventReturnFocusScroll = false;\n      const doc = getDocument(floatingFocusElement);\n      const previouslyFocusedElement = activeElement(doc);\n      const contextData = dataRef.current;\n      let openEvent = contextData.openEvent;\n      addPreviouslyFocusedElement(previouslyFocusedElement);\n\n      // Dismissing via outside press should always ignore `returnFocus` to\n      // prevent unwanted scrolling.\n      function onOpenChange(_ref) {\n        let {\n          open,\n          reason,\n          event,\n          nested\n        } = _ref;\n        if (open) {\n          openEvent = event;\n        }\n        if (reason === 'escape-key' && refs.domReference.current) {\n          addPreviouslyFocusedElement(refs.domReference.current);\n        }\n        if (reason === 'hover' && event.type === 'mouseleave') {\n          preventReturnFocusRef.current = true;\n        }\n        if (reason !== 'outside-press') return;\n        if (nested) {\n          preventReturnFocusRef.current = false;\n          preventReturnFocusScroll = true;\n        } else {\n          preventReturnFocusRef.current = !(isVirtualClick(event) || isVirtualPointerEvent(event));\n        }\n      }\n      events.on('openchange', onOpenChange);\n      const fallbackEl = doc.createElement('span');\n      fallbackEl.setAttribute('tabindex', '-1');\n      fallbackEl.setAttribute('aria-hidden', 'true');\n      Object.assign(fallbackEl.style, HIDDEN_STYLES);\n      if (isInsidePortal && domReference) {\n        domReference.insertAdjacentElement('afterend', fallbackEl);\n      }\n      function getReturnElement() {\n        if (typeof returnFocusRef.current === 'boolean') {\n          return getPreviouslyFocusedElement() || fallbackEl;\n        }\n        return returnFocusRef.current.current || fallbackEl;\n      }\n      return () => {\n        events.off('openchange', onOpenChange);\n        const activeEl = activeElement(doc);\n        const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n          var _node$context5;\n          return contains((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n        });\n        const shouldFocusReference = isFocusInsideFloatingTree || openEvent && ['click', 'mousedown'].includes(openEvent.type);\n        if (shouldFocusReference && refs.domReference.current) {\n          addPreviouslyFocusedElement(refs.domReference.current);\n        }\n        const returnElement = getReturnElement();\n        queueMicrotask(() => {\n          if (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(returnElement) && (\n          // If the focus moved somewhere else after mount, avoid returning focus\n          // since it likely entered a different element which should be\n          // respected: https://github.com/floating-ui/floating-ui/issues/2607\n          returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n            returnElement.focus({\n              preventScroll: preventReturnFocusScroll\n            });\n          }\n          fallbackEl.remove();\n        });\n      };\n    }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, refs, events, tree, nodeId, isInsidePortal, domReference]);\n    React__namespace.useEffect(() => {\n      // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n      // wait for it to complete before resetting the flag.\n      queueMicrotask(() => {\n        preventReturnFocusRef.current = false;\n      });\n    }, [disabled]);\n\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(() => {\n      if (disabled) return;\n      if (!portalContext) return;\n      portalContext.setFocusManagerState({\n        modal,\n        closeOnFocusOut,\n        open,\n        onOpenChange,\n        refs\n      });\n      return () => {\n        portalContext.setFocusManagerState(null);\n      };\n    }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n    index(() => {\n      if (disabled) return;\n      if (!floatingFocusElement) return;\n      if (typeof MutationObserver !== 'function') return;\n      if (ignoreInitialFocus) return;\n      const handleMutation = () => {\n        const tabIndex = floatingFocusElement.getAttribute('tabindex');\n        const tabbableContent = getTabbableContent();\n        const activeEl = activeElement(getDocument(floating));\n        const tabbableIndex = tabbableContent.indexOf(activeEl);\n        if (tabbableIndex !== -1) {\n          tabbableIndexRef.current = tabbableIndex;\n        }\n        if (orderRef.current.includes('floating') || activeEl !== refs.domReference.current && tabbableContent.length === 0) {\n          if (tabIndex !== '0') {\n            floatingFocusElement.setAttribute('tabindex', '0');\n          }\n        } else if (tabIndex !== '-1') {\n          floatingFocusElement.setAttribute('tabindex', '-1');\n        }\n      };\n      handleMutation();\n      const observer = new MutationObserver(handleMutation);\n      observer.observe(floatingFocusElement, {\n        childList: true,\n        subtree: true,\n        attributes: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [disabled, floating, floatingFocusElement, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n    function renderDismissButton(location) {\n      if (disabled || !visuallyHiddenDismiss || !modal) {\n        return null;\n      }\n      return /*#__PURE__*/React__namespace.createElement(VisuallyHiddenDismiss, {\n        ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n        onClick: event => onOpenChange(false, event.nativeEvent)\n      }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n    }\n    const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n    return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, shouldRenderGuards && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n      onFocus: event => {\n        if (modal) {\n          const els = getTabbableElements();\n          enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n          preventReturnFocusRef.current = false;\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const nextTabbable = getNextTabbable() || domReference;\n            nextTabbable == null || nextTabbable.focus();\n          } else {\n            var _portalContext$before;\n            (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n          }\n        }\n      }\n    }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/React__namespace.createElement(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n      onFocus: event => {\n        if (modal) {\n          enqueueFocus(getTabbableElements()[0]);\n        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n          if (closeOnFocusOut) {\n            preventReturnFocusRef.current = true;\n          }\n          if (isOutsideEvent(event, portalContext.portalNode)) {\n            const prevTabbable = getPreviousTabbable() || domReference;\n            prevTabbable == null || prevTabbable.focus();\n          } else {\n            var _portalContext$afterO;\n            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n          }\n        }\n      }\n    }));\n  }\n\n  let lockCount = 0;\n  function enableScrollLock() {\n    const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      Object.assign(bodyStyle, {\n        overflow: '',\n        [paddingProp]: ''\n      });\n      if (isIOS) {\n        Object.assign(bodyStyle, {\n          position: '',\n          top: '',\n          left: '',\n          right: ''\n        });\n        window.scrollTo(scrollX, scrollY);\n      }\n    };\n  }\n  let cleanup = () => {};\n\n  /**\n   * Provides base styling for a fixed overlay element to dim content or block\n   * pointer events behind a floating element.\n   * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n   * @see https://floating-ui.com/docs/FloatingOverlay\n   */\n  const FloatingOverlay = /*#__PURE__*/React__namespace.forwardRef(function FloatingOverlay(props, ref) {\n    const {\n      lockScroll = false,\n      ...rest\n    } = props;\n    index(() => {\n      if (!lockScroll) return;\n      lockCount++;\n      if (lockCount === 1) {\n        cleanup = enableScrollLock();\n      }\n      return () => {\n        lockCount--;\n        if (lockCount === 0) {\n          cleanup();\n        }\n      };\n    }, [lockScroll]);\n    return /*#__PURE__*/React__namespace.createElement(\"div\", _extends({\n      ref: ref\n    }, rest, {\n      style: {\n        position: 'fixed',\n        overflow: 'auto',\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...rest.style\n      }\n    }));\n  });\n\n  function isButtonTarget(event) {\n    return isHTMLElement(event.target) && event.target.tagName === 'BUTTON';\n  }\n  function isSpaceIgnored(element) {\n    return isTypeableElement(element);\n  }\n  /**\n   * Opens or closes the floating element when clicking the reference element.\n   * @see https://floating-ui.com/docs/useClick\n   */\n  function useClick(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      dataRef,\n      elements: {\n        domReference\n      }\n    } = context;\n    const {\n      enabled = true,\n      event: eventOption = 'click',\n      toggle = true,\n      ignoreMouse = false,\n      keyboardHandlers = true,\n      stickIfOpen = true\n    } = props;\n    const pointerTypeRef = React__namespace.useRef();\n    const didKeyDownRef = React__namespace.useRef(false);\n    const reference = React__namespace.useMemo(() => ({\n      onPointerDown(event) {\n        pointerTypeRef.current = event.pointerType;\n      },\n      onMouseDown(event) {\n        const pointerType = pointerTypeRef.current;\n\n        // Ignore all buttons except for the \"main\" button.\n        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n        if (event.button !== 0) return;\n        if (eventOption === 'click') return;\n        if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;\n        if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n          onOpenChange(false, event.nativeEvent, 'click');\n        } else {\n          // Prevent stealing focus from the floating element\n          event.preventDefault();\n          onOpenChange(true, event.nativeEvent, 'click');\n        }\n      },\n      onClick(event) {\n        const pointerType = pointerTypeRef.current;\n        if (eventOption === 'mousedown' && pointerTypeRef.current) {\n          pointerTypeRef.current = undefined;\n          return;\n        }\n        if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;\n        if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === 'click' : true)) {\n          onOpenChange(false, event.nativeEvent, 'click');\n        } else {\n          onOpenChange(true, event.nativeEvent, 'click');\n        }\n      },\n      onKeyDown(event) {\n        pointerTypeRef.current = undefined;\n        if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n          return;\n        }\n        if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n          // Prevent scrolling\n          event.preventDefault();\n          didKeyDownRef.current = true;\n        }\n        if (event.key === 'Enter') {\n          if (open && toggle) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        }\n      },\n      onKeyUp(event) {\n        if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n          return;\n        }\n        if (event.key === ' ' && didKeyDownRef.current) {\n          didKeyDownRef.current = false;\n          if (open && toggle) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        }\n      }\n    }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open, stickIfOpen, toggle]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference\n    } : {}, [enabled, reference]);\n  }\n\n  function createVirtualElement(domElement, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n      contextElement: domElement || undefined,\n      getBoundingClientRect() {\n        var _data$dataRef$current;\n        const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0\n        };\n        const isXAxis = data.axis === 'x' || data.axis === 'both';\n        const isYAxis = data.axis === 'y' || data.axis === 'both';\n        const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n        let width = domRect.width;\n        let height = domRect.height;\n        let x = domRect.x;\n        let y = domRect.y;\n        if (offsetX == null && data.x && isXAxis) {\n          offsetX = domRect.x - data.x;\n        }\n        if (offsetY == null && data.y && isYAxis) {\n          offsetY = domRect.y - data.y;\n        }\n        x -= offsetX || 0;\n        y -= offsetY || 0;\n        width = 0;\n        height = 0;\n        if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n          width = data.axis === 'y' ? domRect.width : 0;\n          height = data.axis === 'x' ? domRect.height : 0;\n          x = isXAxis && data.x != null ? data.x : x;\n          y = isYAxis && data.y != null ? data.y : y;\n        } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n          height = data.axis === 'x' ? domRect.height : height;\n          width = data.axis === 'y' ? domRect.width : width;\n        }\n        isAutoUpdateEvent = true;\n        return {\n          width,\n          height,\n          x,\n          y,\n          top: y,\n          right: x + width,\n          bottom: y + height,\n          left: x\n        };\n      }\n    };\n  }\n  function isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n  }\n  /**\n   * Positions the floating element relative to a client point (in the viewport),\n   * such as the mouse position. By default, it follows the mouse cursor.\n   * @see https://floating-ui.com/docs/useClientPoint\n   */\n  function useClientPoint(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      dataRef,\n      elements: {\n        floating,\n        domReference\n      },\n      refs\n    } = context;\n    const {\n      enabled = true,\n      axis = 'both',\n      x = null,\n      y = null\n    } = props;\n    const initialRef = React__namespace.useRef(false);\n    const cleanupListenerRef = React__namespace.useRef(null);\n    const [pointerType, setPointerType] = React__namespace.useState();\n    const [reactive, setReactive] = React__namespace.useState([]);\n    const setReference = useEffectEvent((x, y) => {\n      if (initialRef.current) return;\n\n      // Prevent setting if the open event was not a mouse-like one\n      // (e.g. focus to open, then hover over the reference element).\n      // Only apply if the event exists.\n      if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n        return;\n      }\n      refs.setPositionReference(createVirtualElement(domReference, {\n        x,\n        y,\n        axis,\n        dataRef,\n        pointerType\n      }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent(event => {\n      if (x != null || y != null) return;\n      if (!open) {\n        setReference(event.clientX, event.clientY);\n      } else if (!cleanupListenerRef.current) {\n        // If there's no cleanup, there's no listener, but we want to ensure\n        // we add the listener if the cursor landed on the floating element and\n        // then back on the reference (i.e. it's interactive).\n        setReactive([]);\n      }\n    });\n\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = isMouseLikePointerType(pointerType) ? floating : open;\n    const addListener = React__namespace.useCallback(() => {\n      // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n      if (!openCheck || !enabled || x != null || y != null) return;\n      const win = getWindow(floating);\n      function handleMouseMove(event) {\n        const target = getTarget(event);\n        if (!contains(floating, target)) {\n          setReference(event.clientX, event.clientY);\n        } else {\n          win.removeEventListener('mousemove', handleMouseMove);\n          cleanupListenerRef.current = null;\n        }\n      }\n      if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n        win.addEventListener('mousemove', handleMouseMove);\n        const cleanup = () => {\n          win.removeEventListener('mousemove', handleMouseMove);\n          cleanupListenerRef.current = null;\n        };\n        cleanupListenerRef.current = cleanup;\n        return cleanup;\n      }\n      refs.setPositionReference(domReference);\n    }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);\n    React__namespace.useEffect(() => {\n      return addListener();\n    }, [addListener, reactive]);\n    React__namespace.useEffect(() => {\n      if (enabled && !floating) {\n        initialRef.current = false;\n      }\n    }, [enabled, floating]);\n    React__namespace.useEffect(() => {\n      if (!enabled && open) {\n        initialRef.current = true;\n      }\n    }, [enabled, open]);\n    index(() => {\n      if (enabled && (x != null || y != null)) {\n        initialRef.current = false;\n        setReference(x, y);\n      }\n    }, [enabled, x, y, setReference]);\n    const reference = React__namespace.useMemo(() => {\n      function setPointerTypeRef(_ref) {\n        let {\n          pointerType\n        } = _ref;\n        setPointerType(pointerType);\n      }\n      return {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      };\n    }, [handleReferenceEnterOrMove]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference\n    } : {}, [enabled, reference]);\n  }\n\n  const bubbleHandlerKeys = {\n    pointerdown: 'onPointerDown',\n    mousedown: 'onMouseDown',\n    click: 'onClick'\n  };\n  const captureHandlerKeys = {\n    pointerdown: 'onPointerDownCapture',\n    mousedown: 'onMouseDownCapture',\n    click: 'onClickCapture'\n  };\n  const normalizeProp = normalizable => {\n    var _normalizable$escapeK, _normalizable$outside;\n    return {\n      escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n      outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n    };\n  };\n  /**\n   * Closes the floating element when a dismissal is requested — by default, when\n   * the user presses the `escape` key or outside of the floating element.\n   * @see https://floating-ui.com/docs/useDismiss\n   */\n  function useDismiss(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      elements,\n      dataRef\n    } = context;\n    const {\n      enabled = true,\n      escapeKey = true,\n      outsidePress: unstable_outsidePress = true,\n      outsidePressEvent = 'pointerdown',\n      referencePress = false,\n      referencePressEvent = 'pointerdown',\n      ancestorScroll = false,\n      bubbles,\n      capture\n    } = props;\n    const tree = useFloatingTree();\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n    const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = React__namespace.useRef(false);\n    const endedOrStartedInsideRef = React__namespace.useRef(false);\n    const {\n      escapeKey: escapeKeyBubbles,\n      outsidePress: outsidePressBubbles\n    } = normalizeProp(bubbles);\n    const {\n      escapeKey: escapeKeyCapture,\n      outsidePress: outsidePressCapture\n    } = normalizeProp(capture);\n    const isComposingRef = React__namespace.useRef(false);\n    const closeOnEscapeKeyDown = useEffectEvent(event => {\n      var _dataRef$current$floa;\n      if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n        return;\n      }\n\n      // Wait until IME is settled. Pressing `Escape` while composing should\n      // close the compose menu, but not the floating element.\n      if (isComposingRef.current) {\n        return;\n      }\n      const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n      const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n      if (!escapeKeyBubbles) {\n        event.stopPropagation();\n        if (children.length > 0) {\n          let shouldDismiss = true;\n          children.forEach(child => {\n            var _child$context;\n            if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n              shouldDismiss = false;\n              return;\n            }\n          });\n          if (!shouldDismiss) {\n            return;\n          }\n        }\n      }\n      onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, 'escape-key');\n    });\n    const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n      var _getTarget2;\n      const callback = () => {\n        var _getTarget;\n        closeOnEscapeKeyDown(event);\n        (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener('keydown', callback);\n      };\n      (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener('keydown', callback);\n    });\n    const closeOnPressOutside = useEffectEvent(event => {\n      var _dataRef$current$floa2;\n      // Given developers can stop the propagation of the synthetic event,\n      // we can only be confident with a positive value.\n      const insideReactTree = insideReactTreeRef.current;\n      insideReactTreeRef.current = false;\n\n      // When click outside is lazy (`click` event), handle dragging.\n      // Don't close if:\n      // - The click started inside the floating element.\n      // - The click ended inside the floating element.\n      const endedOrStartedInside = endedOrStartedInsideRef.current;\n      endedOrStartedInsideRef.current = false;\n      if (outsidePressEvent === 'click' && endedOrStartedInside) {\n        return;\n      }\n      if (insideReactTree) {\n        return;\n      }\n      if (typeof outsidePress === 'function' && !outsidePress(event)) {\n        return;\n      }\n      const target = getTarget(event);\n      const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n      const markers = getDocument(elements.floating).querySelectorAll(inertSelector);\n      let targetRootAncestor = isElement(target) ? target : null;\n      while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {\n        const nextParent = getParentNode(targetRootAncestor);\n        if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {\n          break;\n        }\n        targetRootAncestor = nextParent;\n      }\n\n      // Check if the click occurred on a third-party element injected after the\n      // floating element rendered.\n      if (markers.length && isElement(target) && !isRootElement(target) &&\n      // Clicked on a direct ancestor (e.g. FloatingOverlay).\n      !contains(target, elements.floating) &&\n      // If the target root element contains none of the markers, then the\n      // element was injected after the floating element rendered.\n      Array.from(markers).every(marker => !contains(targetRootAncestor, marker))) {\n        return;\n      }\n\n      // Check if the click occurred on the scrollbar\n      if (isHTMLElement(target) && floating) {\n        // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n        // elements.\n        const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n        const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n        let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n        // In some browsers it is possible to change the <body> (or window)\n        // scrollbar to the left side, but is very rare and is difficult to\n        // check for. Plus, for modal dialogs with backdrops, it is more\n        // important that the backdrop is checked but not so much the window.\n        if (canScrollY) {\n          const isRTL = getComputedStyle$1(target).direction === 'rtl';\n          if (isRTL) {\n            xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n          }\n        }\n        if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n          return;\n        }\n      }\n      const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;\n      const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context;\n        return isEventTargetWithin(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n      });\n      if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {\n        return;\n      }\n      const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context2;\n          if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n      onOpenChange(false, event, 'outside-press');\n    });\n    const closeOnPressOutsideCapture = useEffectEvent(event => {\n      var _getTarget4;\n      const callback = () => {\n        var _getTarget3;\n        closeOnPressOutside(event);\n        (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n      };\n      (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n    });\n    React__namespace.useEffect(() => {\n      if (!open || !enabled) {\n        return;\n      }\n      dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n      dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n      let compositionTimeout = -1;\n      function onScroll(event) {\n        onOpenChange(false, event, 'ancestor-scroll');\n      }\n      function handleCompositionStart() {\n        window.clearTimeout(compositionTimeout);\n        isComposingRef.current = true;\n      }\n      function handleCompositionEnd() {\n        // Safari fires `compositionend` before `keydown`, so we need to wait\n        // until the next tick to set `isComposing` to `false`.\n        // https://bugs.webkit.org/show_bug.cgi?id=165004\n        compositionTimeout = window.setTimeout(() => {\n          isComposingRef.current = false;\n        },\n        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n        // Only apply to WebKit for the test to remain 0ms.\n        isWebKit() ? 5 : 0);\n      }\n      const doc = getDocument(elements.floating);\n      if (escapeKey) {\n        doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        doc.addEventListener('compositionstart', handleCompositionStart);\n        doc.addEventListener('compositionend', handleCompositionEnd);\n      }\n      outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      let ancestors = [];\n      if (ancestorScroll) {\n        if (isElement(elements.domReference)) {\n          ancestors = reactDom.getOverflowAncestors(elements.domReference);\n        }\n        if (isElement(elements.floating)) {\n          ancestors = ancestors.concat(reactDom.getOverflowAncestors(elements.floating));\n        }\n        if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {\n          ancestors = ancestors.concat(reactDom.getOverflowAncestors(elements.reference.contextElement));\n        }\n      }\n\n      // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n      ancestors = ancestors.filter(ancestor => {\n        var _doc$defaultView;\n        return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n      });\n      ancestors.forEach(ancestor => {\n        ancestor.addEventListener('scroll', onScroll, {\n          passive: true\n        });\n      });\n      return () => {\n        if (escapeKey) {\n          doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n          doc.removeEventListener('compositionstart', handleCompositionStart);\n          doc.removeEventListener('compositionend', handleCompositionEnd);\n        }\n        outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        ancestors.forEach(ancestor => {\n          ancestor.removeEventListener('scroll', onScroll);\n        });\n        window.clearTimeout(compositionTimeout);\n      };\n    }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n    React__namespace.useEffect(() => {\n      insideReactTreeRef.current = false;\n    }, [outsidePress, outsidePressEvent]);\n    const reference = React__namespace.useMemo(() => ({\n      onKeyDown: closeOnEscapeKeyDown,\n      [bubbleHandlerKeys[referencePressEvent]]: event => {\n        if (referencePress) {\n          onOpenChange(false, event.nativeEvent, 'reference-press');\n        }\n      }\n    }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);\n    const floating = React__namespace.useMemo(() => ({\n      onKeyDown: closeOnEscapeKeyDown,\n      onMouseDown() {\n        endedOrStartedInsideRef.current = true;\n      },\n      onMouseUp() {\n        endedOrStartedInsideRef.current = true;\n      },\n      [captureHandlerKeys[outsidePressEvent]]: () => {\n        insideReactTreeRef.current = true;\n      }\n    }), [closeOnEscapeKeyDown, outsidePressEvent]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference,\n      floating\n    } : {}, [enabled, reference, floating]);\n  }\n\n  function useFloatingRootContext(options) {\n    const {\n      open = false,\n      onOpenChange: onOpenChangeProp,\n      elements: elementsProp\n    } = options;\n    const floatingId = useId();\n    const dataRef = React__namespace.useRef({});\n    const [events] = React__namespace.useState(() => createPubSub());\n    const nested = useFloatingParentNodeId() != null;\n    {\n      const optionDomReference = elementsProp.reference;\n      if (optionDomReference && !isElement(optionDomReference)) {\n        error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');\n      }\n    }\n    const [positionReference, setPositionReference] = React__namespace.useState(elementsProp.reference);\n    const onOpenChange = useEffectEvent((open, event, reason) => {\n      dataRef.current.openEvent = open ? event : undefined;\n      events.emit('openchange', {\n        open,\n        event,\n        reason,\n        nested\n      });\n      onOpenChangeProp == null || onOpenChangeProp(open, event, reason);\n    });\n    const refs = React__namespace.useMemo(() => ({\n      setPositionReference\n    }), []);\n    const elements = React__namespace.useMemo(() => ({\n      reference: positionReference || elementsProp.reference || null,\n      floating: elementsProp.floating || null,\n      domReference: elementsProp.reference\n    }), [positionReference, elementsProp.reference, elementsProp.floating]);\n    return React__namespace.useMemo(() => ({\n      dataRef,\n      open,\n      onOpenChange,\n      elements,\n      events,\n      floatingId,\n      refs\n    }), [open, onOpenChange, elements, events, floatingId, refs]);\n  }\n\n  /**\n   * Provides data to position a floating element and context to add interactions.\n   * @see https://floating-ui.com/docs/useFloating\n   */\n  function useFloating(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      nodeId\n    } = options;\n    const internalRootContext = useFloatingRootContext({\n      ...options,\n      elements: {\n        reference: null,\n        floating: null,\n        ...options.elements\n      }\n    });\n    const rootContext = options.rootContext || internalRootContext;\n    const computedElements = rootContext.elements;\n    const [_domReference, setDomReference] = React__namespace.useState(null);\n    const [positionReference, _setPositionReference] = React__namespace.useState(null);\n    const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;\n    const domReference = optionDomReference || _domReference;\n    const domReferenceRef = React__namespace.useRef(null);\n    const tree = useFloatingTree();\n    index(() => {\n      if (domReference) {\n        domReferenceRef.current = domReference;\n      }\n    }, [domReference]);\n    const position = reactDom.useFloating({\n      ...options,\n      elements: {\n        ...computedElements,\n        ...(positionReference && {\n          reference: positionReference\n        })\n      }\n    });\n    const setPositionReference = React__namespace.useCallback(node => {\n      const computedPositionReference = isElement(node) ? {\n        getBoundingClientRect: () => node.getBoundingClientRect(),\n        contextElement: node\n      } : node;\n      // Store the positionReference in state if the DOM reference is specified externally via the\n      // `elements.reference` option. This ensures that it won't be overridden on future renders.\n      _setPositionReference(computedPositionReference);\n      position.refs.setReference(computedPositionReference);\n    }, [position.refs]);\n    const setReference = React__namespace.useCallback(node => {\n      if (isElement(node) || node === null) {\n        domReferenceRef.current = node;\n        setDomReference(node);\n      }\n\n      // Backwards-compatibility for passing a virtual element to `reference`\n      // after it has set the DOM reference.\n      if (isElement(position.refs.reference.current) || position.refs.reference.current === null ||\n      // Don't allow setting virtual elements using the old technique back to\n      // `null` to support `positionReference` + an unstable `reference`\n      // callback ref.\n      node !== null && !isElement(node)) {\n        position.refs.setReference(node);\n      }\n    }, [position.refs]);\n    const refs = React__namespace.useMemo(() => ({\n      ...position.refs,\n      setReference,\n      setPositionReference,\n      domReference: domReferenceRef\n    }), [position.refs, setReference, setPositionReference]);\n    const elements = React__namespace.useMemo(() => ({\n      ...position.elements,\n      domReference: domReference\n    }), [position.elements, domReference]);\n    const context = React__namespace.useMemo(() => ({\n      ...position,\n      ...rootContext,\n      refs,\n      elements,\n      nodeId\n    }), [position, refs, elements, nodeId, rootContext]);\n    index(() => {\n      rootContext.dataRef.current.floatingContext = context;\n      const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n      if (node) {\n        node.context = context;\n      }\n    });\n    return React__namespace.useMemo(() => ({\n      ...position,\n      context,\n      refs,\n      elements\n    }), [position, refs, elements, context]);\n  }\n\n  /**\n   * Opens the floating element while the reference element has focus, like CSS\n   * `:focus`.\n   * @see https://floating-ui.com/docs/useFocus\n   */\n  function useFocus(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      onOpenChange,\n      events,\n      dataRef,\n      elements\n    } = context;\n    const {\n      enabled = true,\n      visibleOnly = true\n    } = props;\n    const blockFocusRef = React__namespace.useRef(false);\n    const timeoutRef = React__namespace.useRef();\n    const keyboardModalityRef = React__namespace.useRef(true);\n    React__namespace.useEffect(() => {\n      if (!enabled) return;\n      const win = getWindow(elements.domReference);\n\n      // If the reference was focused and the user left the tab/window, and the\n      // floating element was not open, the focus should be blocked when they\n      // return to the tab/window.\n      function onBlur() {\n        if (!open && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference))) {\n          blockFocusRef.current = true;\n        }\n      }\n      function onKeyDown() {\n        keyboardModalityRef.current = true;\n      }\n      win.addEventListener('blur', onBlur);\n      win.addEventListener('keydown', onKeyDown, true);\n      return () => {\n        win.removeEventListener('blur', onBlur);\n        win.removeEventListener('keydown', onKeyDown, true);\n      };\n    }, [elements.domReference, open, enabled]);\n    React__namespace.useEffect(() => {\n      if (!enabled) return;\n      function onOpenChange(_ref) {\n        let {\n          reason\n        } = _ref;\n        if (reason === 'reference-press' || reason === 'escape-key') {\n          blockFocusRef.current = true;\n        }\n      }\n      events.on('openchange', onOpenChange);\n      return () => {\n        events.off('openchange', onOpenChange);\n      };\n    }, [events, enabled]);\n    React__namespace.useEffect(() => {\n      return () => {\n        clearTimeout(timeoutRef.current);\n      };\n    }, []);\n    const reference = React__namespace.useMemo(() => ({\n      onPointerDown(event) {\n        if (isVirtualPointerEvent(event.nativeEvent)) return;\n        keyboardModalityRef.current = false;\n      },\n      onMouseLeave() {\n        blockFocusRef.current = false;\n      },\n      onFocus(event) {\n        if (blockFocusRef.current) return;\n        const target = getTarget(event.nativeEvent);\n        if (visibleOnly && isElement(target)) {\n          try {\n            // Mac Safari unreliably matches `:focus-visible` on the reference\n            // if focus was outside the page initially - use the fallback\n            // instead.\n            if (isSafari() && isMac()) throw Error();\n            if (!target.matches(':focus-visible')) return;\n          } catch (e) {\n            // Old browsers will throw an error when using `:focus-visible`.\n            if (!keyboardModalityRef.current && !isTypeableElement(target)) {\n              return;\n            }\n          }\n        }\n        onOpenChange(true, event.nativeEvent, 'focus');\n      },\n      onBlur(event) {\n        blockFocusRef.current = false;\n        const relatedTarget = event.relatedTarget;\n        const nativeEvent = event.nativeEvent;\n\n        // Hit the non-modal focus management portal guard. Focus will be\n        // moved into the floating element immediately after.\n        const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n        // Wait for the window blur listener to fire.\n        timeoutRef.current = window.setTimeout(() => {\n          var _dataRef$current$floa;\n          const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);\n\n          // Focus left the page, keep it open.\n          if (!relatedTarget && activeEl === elements.domReference) return;\n\n          // When focusing the reference element (e.g. regular click), then\n          // clicking into the floating element, prevent it from hiding.\n          // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n          // We can not rely on relatedTarget to point to the correct element\n          // as it will only point to the shadow host of the newly focused element\n          // and not the element that actually has received focus if it is located\n          // inside a shadow root.\n          if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard) {\n            return;\n          }\n          onOpenChange(false, nativeEvent, 'focus');\n        });\n      }\n    }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference\n    } : {}, [enabled, reference]);\n  }\n\n  const ACTIVE_KEY = 'active';\n  const SELECTED_KEY = 'selected';\n  function mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    const isItem = elementKey === 'item';\n    let domUserProps = userProps;\n    if (isItem && userProps) {\n      const {\n        [ACTIVE_KEY]: _,\n        [SELECTED_KEY]: __,\n        ...validProps\n      } = userProps;\n      domUserProps = validProps;\n    }\n    return {\n      ...(elementKey === 'floating' && {\n        tabIndex: -1,\n        [FOCUSABLE_ATTRIBUTE]: ''\n      }),\n      ...domUserProps,\n      ...propsList.map(value => {\n        const propsOrGetProps = value ? value[elementKey] : null;\n        if (typeof propsOrGetProps === 'function') {\n          return userProps ? propsOrGetProps(userProps) : null;\n        }\n        return propsOrGetProps;\n      }).concat(userProps).reduce((acc, props) => {\n        if (!props) {\n          return acc;\n        }\n        Object.entries(props).forEach(_ref => {\n          let [key, value] = _ref;\n          if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n            return;\n          }\n          if (key.indexOf('on') === 0) {\n            if (!map.has(key)) {\n              map.set(key, []);\n            }\n            if (typeof value === 'function') {\n              var _map$get;\n              (_map$get = map.get(key)) == null || _map$get.push(value);\n              acc[key] = function () {\n                var _map$get2;\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n              };\n            }\n          } else {\n            acc[key] = value;\n          }\n        });\n        return acc;\n      }, {})\n    };\n  }\n  /**\n   * Merges an array of interaction hooks' props into prop getters, allowing\n   * event handler functions to be composed together without overwriting one\n   * another.\n   * @see https://floating-ui.com/docs/useInteractions\n   */\n  function useInteractions(propsList) {\n    if (propsList === void 0) {\n      propsList = [];\n    }\n    const referenceDeps = propsList.map(key => key == null ? void 0 : key.reference);\n    const floatingDeps = propsList.map(key => key == null ? void 0 : key.floating);\n    const itemDeps = propsList.map(key => key == null ? void 0 : key.item);\n    const getReferenceProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    referenceDeps);\n    const getFloatingProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    floatingDeps);\n    const getItemProps = React__namespace.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    itemDeps);\n    return React__namespace.useMemo(() => ({\n      getReferenceProps,\n      getFloatingProps,\n      getItemProps\n    }), [getReferenceProps, getFloatingProps, getItemProps]);\n  }\n\n  let isPreventScrollSupported = false;\n  function doSwitch(orientation, vertical, horizontal) {\n    switch (orientation) {\n      case 'vertical':\n        return vertical;\n      case 'horizontal':\n        return horizontal;\n      default:\n        return vertical || horizontal;\n    }\n  }\n  function isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n  }\n  function isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n  }\n  function isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n  }\n  function isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n  }\n  /**\n   * Adds arrow key-based navigation of a list of items, either using real DOM\n   * focus or virtual focus.\n   * @see https://floating-ui.com/docs/useListNavigation\n   */\n  function useListNavigation(context, props) {\n    const {\n      open,\n      onOpenChange,\n      elements\n    } = context;\n    const {\n      listRef,\n      activeIndex,\n      onNavigate: unstable_onNavigate = () => {},\n      enabled = true,\n      selectedIndex = null,\n      allowEscape = false,\n      loop = false,\n      nested = false,\n      rtl = false,\n      virtual = false,\n      focusItemOnOpen = 'auto',\n      focusItemOnHover = true,\n      openOnArrowKeyDown = true,\n      disabledIndices = undefined,\n      orientation = 'vertical',\n      cols = 1,\n      scrollItemIntoView = true,\n      virtualItemRef,\n      itemSizes,\n      dense = false\n    } = props;\n    {\n      if (allowEscape) {\n        if (!loop) {\n          warn('`useListNavigation` looping must be enabled to allow escaping.');\n        }\n        if (!virtual) {\n          warn('`useListNavigation` must be virtual to allow escaping.');\n        }\n      }\n      if (orientation === 'vertical' && cols > 1) {\n        warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n      }\n    }\n    const floatingFocusElement = getFloatingFocusElement(elements.floating);\n    const floatingFocusElementRef = useLatestRef(floatingFocusElement);\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const typeableComboboxReference = isTypeableCombobox(elements.domReference);\n    const focusItemOnOpenRef = React__namespace.useRef(focusItemOnOpen);\n    const indexRef = React__namespace.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = React__namespace.useRef(null);\n    const isPointerModalityRef = React__namespace.useRef(true);\n    const previousOnNavigateRef = React__namespace.useRef(onNavigate);\n    const previousMountedRef = React__namespace.useRef(!!elements.floating);\n    const previousOpenRef = React__namespace.useRef(open);\n    const forceSyncFocus = React__namespace.useRef(false);\n    const forceScrollIntoViewRef = React__namespace.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const selectedIndexRef = useLatestRef(selectedIndex);\n    const [activeId, setActiveId] = React__namespace.useState();\n    const [virtualId, setVirtualId] = React__namespace.useState();\n    const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n      if (forceScrollIntoView === void 0) {\n        forceScrollIntoView = false;\n      }\n      function runFocus(item) {\n        if (virtual) {\n          setActiveId(item.id);\n          tree == null || tree.events.emit('virtualfocus', item);\n          if (virtualItemRef) {\n            virtualItemRef.current = item;\n          }\n        } else {\n          enqueueFocus(item, {\n            preventScroll: true,\n            // Mac Safari does not move the virtual cursor unless the focus call\n            // is sync. However, for the very first focus call, we need to wait\n            // for the position to be ready in order to prevent unwanted\n            // scrolling. This means the virtual cursor will not move to the first\n            // item when first opening the floating element, but will on\n            // subsequent calls. `preventScroll` is supported in modern Safari,\n            // so we can use that instead.\n            // iOS Safari must be async or the first item will not be focused.\n            sync: isMac() && isSafari() ? isPreventScrollSupported || forceSyncFocus.current : false\n          });\n        }\n      }\n      const initialItem = listRef.current[indexRef.current];\n      if (initialItem) {\n        runFocus(initialItem);\n      }\n      requestAnimationFrame(() => {\n        const waitedItem = listRef.current[indexRef.current] || initialItem;\n        if (!waitedItem) return;\n        if (!initialItem) {\n          runFocus(waitedItem);\n        }\n        const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n        const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n        if (shouldScrollIntoView) {\n          // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n          // by all browsers.\n          waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n            block: 'nearest',\n            inline: 'nearest'\n          } : scrollIntoViewOptions);\n        }\n      });\n    });\n    index(() => {\n      document.createElement('div').focus({\n        get preventScroll() {\n          isPreventScrollSupported = true;\n          return false;\n        }\n      });\n    }, []);\n\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(() => {\n      if (!enabled) return;\n      if (open && elements.floating) {\n        if (focusItemOnOpenRef.current && selectedIndex != null) {\n          // Regardless of the pointer modality, we want to ensure the selected\n          // item comes into view when the floating element is opened.\n          forceScrollIntoViewRef.current = true;\n          indexRef.current = selectedIndex;\n          onNavigate(selectedIndex);\n        }\n      } else if (previousMountedRef.current) {\n        // Since the user can specify `onNavigate` conditionally\n        // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n        // we store and call the previous function.\n        indexRef.current = -1;\n        previousOnNavigateRef.current(null);\n      }\n    }, [enabled, open, elements.floating, selectedIndex, onNavigate]);\n\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(() => {\n      if (!enabled) return;\n      if (open && elements.floating) {\n        if (activeIndex == null) {\n          forceSyncFocus.current = false;\n          if (selectedIndexRef.current != null) {\n            return;\n          }\n\n          // Reset while the floating element was open (e.g. the list changed).\n          if (previousMountedRef.current) {\n            indexRef.current = -1;\n            focusItem(listRef, indexRef);\n          }\n\n          // Initial sync.\n          if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n            let runs = 0;\n            const waitForListPopulated = () => {\n              if (listRef.current[0] == null) {\n                // Avoid letting the browser paint if possible on the first try,\n                // otherwise use rAF. Don't try more than twice, since something\n                // is wrong otherwise.\n                if (runs < 2) {\n                  const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                  scheduler(waitForListPopulated);\n                }\n                runs++;\n              } else {\n                indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                keyRef.current = null;\n                onNavigate(indexRef.current);\n              }\n            };\n            waitForListPopulated();\n          }\n        } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n          indexRef.current = activeIndex;\n          focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n          forceScrollIntoViewRef.current = false;\n        }\n      }\n    }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(() => {\n      var _nodes$find;\n      if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n        return;\n      }\n      const nodes = tree.nodesRef.current;\n      const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n      const activeEl = activeElement(getDocument(elements.floating));\n      const treeContainsActiveEl = nodes.some(node => node.context && contains(node.context.elements.floating, activeEl));\n      if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n        parent.focus({\n          preventScroll: true\n        });\n      }\n    }, [enabled, elements.floating, tree, parentId, virtual]);\n    index(() => {\n      if (!enabled) return;\n      if (!tree) return;\n      if (!virtual) return;\n      if (parentId) return;\n      function handleVirtualFocus(item) {\n        setVirtualId(item.id);\n        if (virtualItemRef) {\n          virtualItemRef.current = item;\n        }\n      }\n      tree.events.on('virtualfocus', handleVirtualFocus);\n      return () => {\n        tree.events.off('virtualfocus', handleVirtualFocus);\n      };\n    }, [enabled, tree, virtual, parentId, virtualItemRef]);\n    index(() => {\n      previousOnNavigateRef.current = onNavigate;\n      previousMountedRef.current = !!elements.floating;\n    });\n    index(() => {\n      if (!open) {\n        keyRef.current = null;\n      }\n    }, [open]);\n    index(() => {\n      previousOpenRef.current = open;\n    }, [open]);\n    const hasActiveIndex = activeIndex != null;\n    const item = React__namespace.useMemo(() => {\n      function syncCurrentTarget(currentTarget) {\n        if (!open) return;\n        const index = listRef.current.indexOf(currentTarget);\n        if (index !== -1) {\n          onNavigate(index);\n        }\n      }\n      const props = {\n        onFocus(_ref) {\n          let {\n            currentTarget\n          } = _ref;\n          syncCurrentTarget(currentTarget);\n        },\n        onClick: _ref2 => {\n          let {\n            currentTarget\n          } = _ref2;\n          return currentTarget.focus({\n            preventScroll: true\n          });\n        },\n        // Safari\n        ...(focusItemOnHover && {\n          onMouseMove(_ref3) {\n            let {\n              currentTarget\n            } = _ref3;\n            syncCurrentTarget(currentTarget);\n          },\n          onPointerLeave(_ref4) {\n            let {\n              pointerType\n            } = _ref4;\n            if (!isPointerModalityRef.current || pointerType === 'touch') {\n              return;\n            }\n            indexRef.current = -1;\n            focusItem(listRef, indexRef);\n            onNavigate(null);\n            if (!virtual) {\n              enqueueFocus(floatingFocusElementRef.current, {\n                preventScroll: true\n              });\n            }\n          }\n        })\n      };\n      return props;\n    }, [open, floatingFocusElementRef, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n    const commonOnKeyDown = useEffectEvent(event => {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n      // don't appear to suffer from this. `event.isComposing` is avoided due to\n      // Safari not supporting it properly (although it's not needed in the first\n      // place for Safari, just avoiding any possible issues).\n      if (event.which === 229) {\n        return;\n      }\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        stopEvent(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if (isHTMLElement(elements.domReference)) {\n          if (virtual) {\n            tree == null || tree.events.emit('virtualfocus', elements.domReference);\n          } else {\n            elements.domReference.focus();\n          }\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (!typeableComboboxReference) {\n        if (event.key === 'Home') {\n          stopEvent(event);\n          indexRef.current = minIndex;\n          onNavigate(indexRef.current);\n        }\n        if (event.key === 'End') {\n          stopEvent(event);\n          indexRef.current = maxIndex;\n          onNavigate(indexRef.current);\n        }\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const sizes = itemSizes || Array.from({\n          length: listRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !isDisabled(listRef.current, index, disabledIndices));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !isDisabled(listRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);\n        const index = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          rtl,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || listRef.current.map((_, index) => isDisabled(listRef.current, index) ? index : undefined)), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction\n          // we're moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? 'tr' : 'tl'),\n          stopEvent: true\n        })];\n        if (index != null) {\n          indexRef.current = index;\n          onNavigate(indexRef.current);\n        }\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        stopEvent(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    });\n    const ariaActiveDescendantProp = React__namespace.useMemo(() => {\n      return virtual && open && hasActiveIndex && {\n        'aria-activedescendant': virtualId || activeId\n      };\n    }, [virtual, open, hasActiveIndex, virtualId, activeId]);\n    const floating = React__namespace.useMemo(() => {\n      return {\n        'aria-orientation': orientation === 'both' ? undefined : orientation,\n        ...(!isTypeableCombobox(elements.domReference) && ariaActiveDescendantProp),\n        onKeyDown: commonOnKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      };\n    }, [ariaActiveDescendantProp, commonOnKeyDown, elements.domReference, orientation]);\n    const reference = React__namespace.useMemo(() => {\n      function checkVirtualMouse(event) {\n        if (focusItemOnOpen === 'auto' && isVirtualClick(event.nativeEvent)) {\n          focusItemOnOpenRef.current = true;\n        }\n      }\n      function checkVirtualPointer(event) {\n        // `pointerdown` fires first, reset the state then perform the checks.\n        focusItemOnOpenRef.current = focusItemOnOpen;\n        if (focusItemOnOpen === 'auto' && isVirtualPointerEvent(event.nativeEvent)) {\n          focusItemOnOpenRef.current = true;\n        }\n      }\n      return {\n        ...ariaActiveDescendantProp,\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.startsWith('Arrow');\n          const isHomeOrEndKey = ['Home', 'End'].includes(event.key);\n          const isMoveKey = isArrowKey || isHomeOrEndKey;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isMoveKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find(item => (item == null ? void 0 : item.id) === activeId) : null;\n                if (dispatchItem) {\n                  stopEvent(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  stopEvent(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return commonOnKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              stopEvent(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndicesRef.current);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            stopEvent(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              commonOnKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open && !virtual) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      };\n    }, [activeId, ariaActiveDescendantProp, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference,\n      floating,\n      item\n    } : {}, [enabled, reference, floating, item]);\n  }\n\n  const componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n  /**\n   * Adds base screen reader props to the reference and floating elements for a\n   * given floating element `role`.\n   * @see https://floating-ui.com/docs/useRole\n   */\n  function useRole(context, props) {\n    var _componentRoleToAriaR;\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      floatingId\n    } = context;\n    const {\n      enabled = true,\n      role = 'dialog'\n    } = props;\n    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n    const referenceId = useId();\n    const parentId = useFloatingParentNodeId();\n    const isNested = parentId != null;\n    const reference = React__namespace.useMemo(() => {\n      if (ariaRole === 'tooltip' || role === 'label') {\n        return {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        };\n      }\n      return {\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined,\n        ...(ariaRole === 'listbox' && {\n          role: 'combobox'\n        }),\n        ...(ariaRole === 'menu' && {\n          id: referenceId\n        }),\n        ...(ariaRole === 'menu' && isNested && {\n          role: 'menuitem'\n        }),\n        ...(role === 'select' && {\n          'aria-autocomplete': 'none'\n        }),\n        ...(role === 'combobox' && {\n          'aria-autocomplete': 'list'\n        })\n      };\n    }, [ariaRole, floatingId, isNested, open, referenceId, role]);\n    const floating = React__namespace.useMemo(() => {\n      const floatingProps = {\n        id: floatingId,\n        ...(ariaRole && {\n          role: ariaRole\n        })\n      };\n      if (ariaRole === 'tooltip' || role === 'label') {\n        return floatingProps;\n      }\n      return {\n        ...floatingProps,\n        ...(ariaRole === 'menu' && {\n          'aria-labelledby': referenceId\n        })\n      };\n    }, [ariaRole, floatingId, referenceId, role]);\n    const item = React__namespace.useCallback(_ref => {\n      let {\n        active,\n        selected\n      } = _ref;\n      const commonProps = {\n        role: 'option',\n        ...(active && {\n          id: floatingId + \"-option\"\n        })\n      };\n\n      // For `menu`, we are unable to tell if the item is a `menuitemradio`\n      // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n      // avoid defaulting to `menuitem` as it may overwrite custom role props.\n      switch (role) {\n        case 'select':\n          return {\n            ...commonProps,\n            'aria-selected': active && selected\n          };\n        case 'combobox':\n          {\n            return {\n              ...commonProps,\n              ...(active && {\n                'aria-selected': true\n              })\n            };\n          }\n      }\n      return {};\n    }, [floatingId, role]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference,\n      floating,\n      item\n    } : {}, [enabled, reference, floating, item]);\n  }\n\n  // Converts a JS style key like `backgroundColor` to a CSS transition-property\n  // like `background-color`.\n  const camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\n  function execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n  }\n  function useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = React__namespace.useState(open);\n    if (open && !isMounted) {\n      setIsMounted(true);\n    }\n    React__namespace.useEffect(() => {\n      if (!open && isMounted) {\n        const timeout = setTimeout(() => setIsMounted(false), durationMs);\n        return () => clearTimeout(timeout);\n      }\n    }, [open, isMounted, durationMs]);\n    return isMounted;\n  }\n  /**\n   * Provides a status string to apply CSS transitions to a floating element,\n   * correctly handling placement-aware transitions.\n   * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n   */\n  function useTransitionStatus(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      open,\n      elements: {\n        floating\n      }\n    } = context;\n    const {\n      duration = 250\n    } = props;\n    const isNumberDuration = typeof duration === 'number';\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [status, setStatus] = React__namespace.useState('unmounted');\n    const isMounted = useDelayUnmount(open, closeDuration);\n    if (!isMounted && status === 'close') {\n      setStatus('unmounted');\n    }\n    index(() => {\n      if (!floating) return;\n      if (open) {\n        setStatus('initial');\n        const frame = requestAnimationFrame(() => {\n          setStatus('open');\n        });\n        return () => {\n          cancelAnimationFrame(frame);\n        };\n      }\n      setStatus('close');\n    }, [open, floating]);\n    return {\n      isMounted,\n      status\n    };\n  }\n  /**\n   * Provides styles to apply CSS transitions to a floating element, correctly\n   * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n   * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n   */\n  function useTransitionStyles(context, props) {\n    if (props === void 0) {\n      props = {};\n    }\n    const {\n      initial: unstable_initial = {\n        opacity: 0\n      },\n      open: unstable_open,\n      close: unstable_close,\n      common: unstable_common,\n      duration = 250\n    } = props;\n    const placement = context.placement;\n    const side = placement.split('-')[0];\n    const fnArgs = React__namespace.useMemo(() => ({\n      side,\n      placement\n    }), [side, placement]);\n    const isNumberDuration = typeof duration === 'number';\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = React__namespace.useState(() => ({\n      ...execWithArgsOrReturn(unstable_common, fnArgs),\n      ...execWithArgsOrReturn(unstable_initial, fnArgs)\n    }));\n    const {\n      isMounted,\n      status\n    } = useTransitionStatus(context, {\n      duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(() => {\n      const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n      const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n      const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n      const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n        acc[key] = '';\n        return acc;\n      }, {});\n      if (status === 'initial') {\n        setStyles(styles => ({\n          transitionProperty: styles.transitionProperty,\n          ...commonStyles,\n          ...initialStyles\n        }));\n      }\n      if (status === 'open') {\n        setStyles({\n          transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n          transitionDuration: openDuration + \"ms\",\n          ...commonStyles,\n          ...openStyles\n        });\n      }\n      if (status === 'close') {\n        const styles = closeStyles || initialStyles;\n        setStyles({\n          transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n          transitionDuration: closeDuration + \"ms\",\n          ...commonStyles,\n          ...styles\n        });\n      }\n    }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n    return {\n      isMounted,\n      styles\n    };\n  }\n\n  /**\n   * Provides a matching callback that can be used to focus an item as the user\n   * types, often used in tandem with `useListNavigation()`.\n   * @see https://floating-ui.com/docs/useTypeahead\n   */\n  function useTypeahead(context, props) {\n    var _ref;\n    const {\n      open,\n      dataRef\n    } = context;\n    const {\n      listRef,\n      activeIndex,\n      onMatch: unstable_onMatch,\n      onTypingChange: unstable_onTypingChange,\n      enabled = true,\n      findMatch = null,\n      resetMs = 750,\n      ignoreKeys = [],\n      selectedIndex = null\n    } = props;\n    const timeoutIdRef = React__namespace.useRef();\n    const stringRef = React__namespace.useRef('');\n    const prevIndexRef = React__namespace.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = React__namespace.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(() => {\n      if (open) {\n        clearTimeout(timeoutIdRef.current);\n        matchIndexRef.current = null;\n        stringRef.current = '';\n      }\n    }, [open]);\n    index(() => {\n      // Sync arrow key navigation but not typeahead navigation.\n      if (open && stringRef.current === '') {\n        var _ref2;\n        prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n      }\n    }, [open, selectedIndex, activeIndex]);\n    const setTypingChange = useEffectEvent(value => {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    });\n    const onKeyDown = useEffectEvent(event => {\n      function getMatchingIndex(list, orderedList, string) {\n        const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n        return str ? list.indexOf(str) : -1;\n      }\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          stopEvent(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        stopEvent(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    });\n    const reference = React__namespace.useMemo(() => ({\n      onKeyDown\n    }), [onKeyDown]);\n    const floating = React__namespace.useMemo(() => {\n      return {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      };\n    }, [onKeyDown, setTypingChange]);\n    return React__namespace.useMemo(() => enabled ? {\n      reference,\n      floating\n    } : {}, [enabled, reference, floating]);\n  }\n\n  function getArgsWithCustomFloatingHeight(state, height) {\n    return {\n      ...state,\n      rects: {\n        ...state.rects,\n        floating: {\n          ...state.rects.floating,\n          height\n        }\n      }\n    };\n  }\n  /**\n   * Positions the floating element such that an inner element inside of it is\n   * anchored to the reference element.\n   * @see https://floating-ui.com/docs/inner\n   */\n  const inner = props => ({\n    name: 'inner',\n    options: props,\n    async fn(state) {\n      const {\n        listRef,\n        overflowRef,\n        onFallbackChange,\n        offset: innerOffset = 0,\n        index = 0,\n        minItemsVisible = 4,\n        referenceOverflowThreshold = 0,\n        scrollRef,\n        ...detectOverflowOptions\n      } = evaluate(props, state);\n      const {\n        rects,\n        elements: {\n          floating\n        }\n      } = state;\n      const item = listRef.current[index];\n      const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n\n      // Valid combinations:\n      // 1. Floating element is the scrollRef and has a border (default)\n      // 2. Floating element is not the scrollRef, floating element has a border\n      // 3. Floating element is not the scrollRef, scrollRef has a border\n      // Floating > {...getFloatingProps()} wrapper > scrollRef > items is not\n      // allowed as VoiceOver doesn't work.\n      const clientTop = floating.clientTop || scrollEl.clientTop;\n      const floatingIsBordered = floating.clientTop !== 0;\n      const scrollElIsBordered = scrollEl.clientTop !== 0;\n      const floatingIsScrollEl = floating === scrollEl;\n      {\n        if (!state.placement.startsWith('bottom')) {\n          warn('`placement` side must be \"bottom\" when using the `inner`', 'middleware.');\n        }\n      }\n      if (!item) {\n        return {};\n      }\n      const nextArgs = {\n        ...state,\n        ...(await reactDom.offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n      };\n      const overflow = await reactDom.detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);\n      const refOverflow = await reactDom.detectOverflow(nextArgs, {\n        ...detectOverflowOptions,\n        elementContext: 'reference'\n      });\n      const diffY = max(0, overflow.top);\n      const nextY = nextArgs.y + diffY;\n      const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;\n      const rounder = isScrollable ? v => v : round;\n      const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));\n      scrollEl.style.maxHeight = maxHeight + \"px\";\n      scrollEl.scrollTop = diffY;\n\n      // There is not enough space, fallback to standard anchored positioning\n      if (onFallbackChange) {\n        const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;\n        ReactDOM__namespace.flushSync(() => onFallbackChange(shouldFallback));\n      }\n      if (overflowRef) {\n        overflowRef.current = await reactDom.detectOverflow(getArgsWithCustomFloatingHeight({\n          ...nextArgs,\n          y: nextY\n        }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);\n      }\n      return {\n        y: nextY\n      };\n    }\n  });\n  /**\n   * Changes the `inner` middleware's `offset` upon a `wheel` event to\n   * expand the floating element's height, revealing more list items.\n   * @see https://floating-ui.com/docs/inner\n   */\n  function useInnerOffset(context, props) {\n    const {\n      open,\n      elements\n    } = context;\n    const {\n      enabled = true,\n      overflowRef,\n      scrollRef,\n      onChange: unstable_onChange\n    } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = React__namespace.useRef(false);\n    const prevScrollTopRef = React__namespace.useRef(null);\n    const initialOverflowRef = React__namespace.useRef(null);\n    React__namespace.useEffect(() => {\n      if (!enabled) return;\n      function onWheel(e) {\n        if (e.ctrlKey || !el || overflowRef.current == null) {\n          return;\n        }\n        const dY = e.deltaY;\n        const isAtTop = overflowRef.current.top >= -0.5;\n        const isAtBottom = overflowRef.current.bottom >= -0.5;\n        const remainingScroll = el.scrollHeight - el.clientHeight;\n        const sign = dY < 0 ? -1 : 1;\n        const method = dY < 0 ? 'max' : 'min';\n        if (el.scrollHeight <= el.clientHeight) {\n          return;\n        }\n        if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n          e.preventDefault();\n          ReactDOM__namespace.flushSync(() => {\n            onChange(d => d + Math[method](dY, remainingScroll * sign));\n          });\n        } else if (/firefox/i.test(getUserAgent())) {\n          // Needed to propagate scrolling during momentum scrolling phase once\n          // it gets limited by the boundary. UX improvement, not critical.\n          el.scrollTop += dY;\n        }\n      }\n      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n      if (open && el) {\n        el.addEventListener('wheel', onWheel);\n\n        // Wait for the position to be ready.\n        requestAnimationFrame(() => {\n          prevScrollTopRef.current = el.scrollTop;\n          if (overflowRef.current != null) {\n            initialOverflowRef.current = {\n              ...overflowRef.current\n            };\n          }\n        });\n        return () => {\n          prevScrollTopRef.current = null;\n          initialOverflowRef.current = null;\n          el.removeEventListener('wheel', onWheel);\n        };\n      }\n    }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n    const floating = React__namespace.useMemo(() => ({\n      onKeyDown() {\n        controlledScrollingRef.current = true;\n      },\n      onWheel() {\n        controlledScrollingRef.current = false;\n      },\n      onPointerMove() {\n        controlledScrollingRef.current = false;\n      },\n      onScroll() {\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n          return;\n        }\n        if (prevScrollTopRef.current !== null) {\n          const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n          if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n            ReactDOM__namespace.flushSync(() => onChange(d => d + scrollDiff));\n          }\n        }\n\n        // [Firefox] Wait for the height change to have been applied.\n        requestAnimationFrame(() => {\n          prevScrollTopRef.current = el.scrollTop;\n        });\n      }\n    }), [elements.floating, onChange, overflowRef, scrollRef]);\n    return React__namespace.useMemo(() => enabled ? {\n      floating\n    } : {}, [enabled, floating]);\n  }\n\n  function isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const [xi, yi] = polygon[i] || [0, 0];\n      const [xj, yj] = polygon[j] || [0, 0];\n      const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n      if (intersect) {\n        isInside = !isInside;\n      }\n    }\n    return isInside;\n  }\n  function isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n  }\n  /**\n   * Generates a safe polygon area that the user can traverse without closing the\n   * floating element once leaving the reference element.\n   * @see https://floating-ui.com/docs/useHover#safepolygon\n   */\n  function safePolygon(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      buffer = 0.5,\n      blockPointerEvents = false,\n      requireIntent = true\n    } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n      const currentTime = performance.now();\n      const elapsedTime = currentTime - lastCursorTime;\n      if (lastX === null || lastY === null || elapsedTime === 0) {\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return null;\n      }\n      const deltaX = x - lastX;\n      const deltaY = y - lastY;\n      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n      const speed = distance / elapsedTime; // px / ms\n\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return speed;\n    }\n    const fn = _ref => {\n      let {\n        x,\n        y,\n        placement,\n        elements,\n        onClose,\n        nodeId,\n        tree\n      } = _ref;\n      return function onMouseMove(event) {\n        function close() {\n          clearTimeout(timeoutId);\n          onClose();\n        }\n        clearTimeout(timeoutId);\n        if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n          return;\n        }\n        const {\n          clientX,\n          clientY\n        } = event;\n        const clientPoint = [clientX, clientY];\n        const target = getTarget(event);\n        const isLeave = event.type === 'mouseleave';\n        const isOverFloatingEl = contains(elements.floating, target);\n        const isOverReferenceEl = contains(elements.domReference, target);\n        const refRect = elements.domReference.getBoundingClientRect();\n        const rect = elements.floating.getBoundingClientRect();\n        const side = placement.split('-')[0];\n        const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n        const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n        const isOverReferenceRect = isInside(clientPoint, refRect);\n        const isFloatingWider = rect.width > refRect.width;\n        const isFloatingTaller = rect.height > refRect.height;\n        const left = (isFloatingWider ? refRect : rect).left;\n        const right = (isFloatingWider ? refRect : rect).right;\n        const top = (isFloatingTaller ? refRect : rect).top;\n        const bottom = (isFloatingTaller ? refRect : rect).bottom;\n        if (isOverFloatingEl) {\n          hasLanded = true;\n          if (!isLeave) {\n            return;\n          }\n        }\n        if (isOverReferenceEl) {\n          hasLanded = false;\n        }\n        if (isOverReferenceEl && !isLeave) {\n          hasLanded = true;\n          return;\n        }\n\n        // Prevent overlapping floating element from being stuck in an open-close\n        // loop: https://github.com/floating-ui/floating-ui/issues/1910\n        if (isLeave && isElement(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n          return;\n        }\n\n        // If any nested child is open, abort.\n        if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n          let {\n            context\n          } = _ref2;\n          return context == null ? void 0 : context.open;\n        })) {\n          return;\n        }\n\n        // If the pointer is leaving from the opposite side, the \"buffer\" logic\n        // creates a point where the floating element remains open, but should be\n        // ignored.\n        // A constant of 1 handles floating point rounding errors.\n        if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n          return close();\n        }\n\n        // Ignore when the cursor is within the rectangular trough between the\n        // two elements. Since the triangle is created from the cursor point,\n        // which can start beyond the ref element's edge, traversing back and\n        // forth from the ref to the floating element can cause it to close. This\n        // ensures it always remains open in that case.\n        let rectPoly = [];\n        switch (side) {\n          case 'top':\n            rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n            break;\n          case 'bottom':\n            rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n            break;\n          case 'left':\n            rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n            break;\n          case 'right':\n            rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n            break;\n        }\n        function getPolygon(_ref3) {\n          let [x, y] = _ref3;\n          switch (side) {\n            case 'top':\n              {\n                const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n                const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n                const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n                return [cursorPointOne, cursorPointTwo, ...commonPoints];\n              }\n            case 'bottom':\n              {\n                const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n                const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n                const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n                return [cursorPointOne, cursorPointTwo, ...commonPoints];\n              }\n            case 'left':\n              {\n                const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n                return [...commonPoints, cursorPointOne, cursorPointTwo];\n              }\n            case 'right':\n              {\n                const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n                const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n                return [cursorPointOne, cursorPointTwo, ...commonPoints];\n              }\n          }\n        }\n        if (isPointInPolygon([clientX, clientY], rectPoly)) {\n          return;\n        }\n        if (hasLanded && !isOverReferenceRect) {\n          return close();\n        }\n        if (!isLeave && requireIntent) {\n          const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n          const cursorSpeedThreshold = 0.1;\n          if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n            return close();\n          }\n        }\n        if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n          close();\n        } else if (!hasLanded && requireIntent) {\n          timeoutId = window.setTimeout(close, 40);\n        }\n      };\n    };\n    fn.__options = {\n      blockPointerEvents\n    };\n    return fn;\n  }\n\n  Object.defineProperty(exports, \"arrow\", {\n    enumerable: true,\n    get: function () { return reactDom.arrow; }\n  });\n  Object.defineProperty(exports, \"autoPlacement\", {\n    enumerable: true,\n    get: function () { return reactDom.autoPlacement; }\n  });\n  Object.defineProperty(exports, \"autoUpdate\", {\n    enumerable: true,\n    get: function () { return reactDom.autoUpdate; }\n  });\n  Object.defineProperty(exports, \"computePosition\", {\n    enumerable: true,\n    get: function () { return reactDom.computePosition; }\n  });\n  Object.defineProperty(exports, \"detectOverflow\", {\n    enumerable: true,\n    get: function () { return reactDom.detectOverflow; }\n  });\n  Object.defineProperty(exports, \"flip\", {\n    enumerable: true,\n    get: function () { return reactDom.flip; }\n  });\n  Object.defineProperty(exports, \"getOverflowAncestors\", {\n    enumerable: true,\n    get: function () { return reactDom.getOverflowAncestors; }\n  });\n  Object.defineProperty(exports, \"hide\", {\n    enumerable: true,\n    get: function () { return reactDom.hide; }\n  });\n  Object.defineProperty(exports, \"inline\", {\n    enumerable: true,\n    get: function () { return reactDom.inline; }\n  });\n  Object.defineProperty(exports, \"limitShift\", {\n    enumerable: true,\n    get: function () { return reactDom.limitShift; }\n  });\n  Object.defineProperty(exports, \"offset\", {\n    enumerable: true,\n    get: function () { return reactDom.offset; }\n  });\n  Object.defineProperty(exports, \"platform\", {\n    enumerable: true,\n    get: function () { return reactDom.platform; }\n  });\n  Object.defineProperty(exports, \"shift\", {\n    enumerable: true,\n    get: function () { return reactDom.shift; }\n  });\n  Object.defineProperty(exports, \"size\", {\n    enumerable: true,\n    get: function () { return reactDom.size; }\n  });\n  exports.Composite = Composite;\n  exports.CompositeItem = CompositeItem;\n  exports.FloatingArrow = FloatingArrow;\n  exports.FloatingDelayGroup = FloatingDelayGroup;\n  exports.FloatingFocusManager = FloatingFocusManager;\n  exports.FloatingList = FloatingList;\n  exports.FloatingNode = FloatingNode;\n  exports.FloatingOverlay = FloatingOverlay;\n  exports.FloatingPortal = FloatingPortal;\n  exports.FloatingTree = FloatingTree;\n  exports.inner = inner;\n  exports.safePolygon = safePolygon;\n  exports.useClick = useClick;\n  exports.useClientPoint = useClientPoint;\n  exports.useDelayGroup = useDelayGroup;\n  exports.useDelayGroupContext = useDelayGroupContext;\n  exports.useDismiss = useDismiss;\n  exports.useFloating = useFloating;\n  exports.useFloatingNodeId = useFloatingNodeId;\n  exports.useFloatingParentNodeId = useFloatingParentNodeId;\n  exports.useFloatingPortalNode = useFloatingPortalNode;\n  exports.useFloatingRootContext = useFloatingRootContext;\n  exports.useFloatingTree = useFloatingTree;\n  exports.useFocus = useFocus;\n  exports.useHover = useHover;\n  exports.useId = useId;\n  exports.useInnerOffset = useInnerOffset;\n  exports.useInteractions = useInteractions;\n  exports.useListItem = useListItem;\n  exports.useListNavigation = useListNavigation;\n  exports.useMergeRefs = useMergeRefs;\n  exports.useRole = useRole;\n  exports.useTransitionStatus = useTransitionStatus;\n  exports.useTransitionStyles = useTransitionStyles;\n  exports.useTypeahead = useTypeahead;\n\n}));\n"
        }
    ]
}