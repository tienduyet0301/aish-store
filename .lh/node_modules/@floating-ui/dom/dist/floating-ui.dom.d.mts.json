{
    "sourceFile": "node_modules/@floating-ui/dom/dist/floating-ui.dom.d.mts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891760903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { AlignedPlacement } from '@floating-ui/core';\r\nimport { Alignment } from '@floating-ui/core';\r\nimport type { ArrowOptions as ArrowOptions_2 } from '@floating-ui/core';\r\nimport type { AutoPlacementOptions as AutoPlacementOptions_2 } from '@floating-ui/core';\r\nimport { Axis } from '@floating-ui/core';\r\nimport { ClientRectObject } from '@floating-ui/core';\r\nimport type { ComputePositionConfig as ComputePositionConfig_2 } from '@floating-ui/core';\r\nimport { ComputePositionReturn } from '@floating-ui/core';\r\nimport { Coords } from '@floating-ui/core';\r\nimport type { DetectOverflowOptions as DetectOverflowOptions_2 } from '@floating-ui/core';\r\nimport { Dimensions } from '@floating-ui/core';\r\nimport { ElementContext } from '@floating-ui/core';\r\nimport { ElementRects } from '@floating-ui/core';\r\nimport type { FlipOptions as FlipOptions_2 } from '@floating-ui/core';\r\nimport { getOverflowAncestors } from '@floating-ui/utils/dom';\r\nimport type { HideOptions as HideOptions_2 } from '@floating-ui/core';\r\nimport { InlineOptions } from '@floating-ui/core';\r\nimport { Length } from '@floating-ui/core';\r\nimport { LimitShiftOptions } from '@floating-ui/core';\r\nimport type { Middleware as Middleware_2 } from '@floating-ui/core';\r\nimport { MiddlewareData } from '@floating-ui/core';\r\nimport { MiddlewareReturn } from '@floating-ui/core';\r\nimport type { MiddlewareState as MiddlewareState_2 } from '@floating-ui/core';\r\nimport { Padding } from '@floating-ui/core';\r\nimport { Placement } from '@floating-ui/core';\r\nimport { Rect } from '@floating-ui/core';\r\nimport { RootBoundary } from '@floating-ui/core';\r\nimport type { ShiftOptions as ShiftOptions_2 } from '@floating-ui/core';\r\nimport { Side } from '@floating-ui/core';\r\nimport { SideObject } from '@floating-ui/core';\r\nimport type { SizeOptions as SizeOptions_2 } from '@floating-ui/core';\r\nimport { Strategy } from '@floating-ui/core';\r\n\r\nexport { AlignedPlacement }\r\n\r\nexport { Alignment }\r\n\r\n/**\r\n * Provides data to position an inner element of the floating element so that it\r\n * appears centered to the reference element.\r\n * @see https://floating-ui.com/docs/arrow\r\n */\r\nexport declare const arrow: (options: ArrowOptions | Derivable<ArrowOptions>) => Middleware;\r\n\r\nexport declare type ArrowOptions = Prettify<Omit<ArrowOptions_2, 'element'> & {\r\n    element: Element;\r\n}>;\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by choosing the placement\r\n * that has the most space available automatically, without needing to specify a\r\n * preferred placement. Alternative to `flip`.\r\n * @see https://floating-ui.com/docs/autoPlacement\r\n */\r\nexport declare const autoPlacement: (options?: AutoPlacementOptions | Derivable<AutoPlacementOptions>) => Middleware;\r\n\r\nexport declare type AutoPlacementOptions = Prettify<Omit<AutoPlacementOptions_2, 'boundary'> & DetectOverflowOptions>;\r\n\r\n/**\r\n * Automatically updates the position of the floating element when necessary.\r\n * Should only be called when the floating element is mounted on the DOM or\r\n * visible on the screen.\r\n * @returns cleanup function that should be invoked when the floating element is\r\n * removed from the DOM or hidden from the screen.\r\n * @see https://floating-ui.com/docs/autoUpdate\r\n */\r\nexport declare function autoUpdate(reference: ReferenceElement, floating: FloatingElement, update: () => void, options?: AutoUpdateOptions): () => void;\r\n\r\nexport declare interface AutoUpdateOptions {\r\n    /**\r\n     * Whether to update the position when an overflow ancestor is scrolled.\r\n     * @default true\r\n     */\r\n    ancestorScroll?: boolean;\r\n    /**\r\n     * Whether to update the position when an overflow ancestor is resized. This\r\n     * uses the native `resize` event.\r\n     * @default true\r\n     */\r\n    ancestorResize?: boolean;\r\n    /**\r\n     * Whether to update the position when either the reference or floating\r\n     * elements resized. This uses a `ResizeObserver`.\r\n     * @default true\r\n     */\r\n    elementResize?: boolean;\r\n    /**\r\n     * Whether to update the position when the reference relocated on the screen\r\n     * due to layout shift.\r\n     * @default true\r\n     */\r\n    layoutShift?: boolean;\r\n    /**\r\n     * Whether to update on every animation frame if necessary. Only use if you\r\n     * need to update the position in response to an animation using transforms.\r\n     * @default false\r\n     */\r\n    animationFrame?: boolean;\r\n}\r\n\r\nexport { Axis }\r\n\r\n/**\r\n * The clipping boundary area of the floating element.\r\n */\r\nexport declare type Boundary = 'clippingAncestors' | Element | Array<Element> | Rect;\r\n\r\nexport { ClientRectObject }\r\n\r\n/**\r\n * Computes the `x` and `y` coordinates that will place the floating element\r\n * next to a given reference element.\r\n */\r\nexport declare const computePosition: (reference: ReferenceElement, floating: FloatingElement, options?: Partial<ComputePositionConfig>) => Promise<ComputePositionReturn>;\r\n\r\nexport declare type ComputePositionConfig = Prettify<Omit<ComputePositionConfig_2, 'middleware' | 'platform'> & {\r\n    /**\r\n     * Array of middleware objects to modify the positioning or provide data for\r\n     * rendering.\r\n     */\r\n    middleware?: Array<Middleware | null | undefined | false>;\r\n    /**\r\n     * Custom or extended platform object.\r\n     */\r\n    platform?: Platform;\r\n}>;\r\n\r\nexport { ComputePositionReturn }\r\n\r\nexport { Coords }\r\n\r\nexport declare type Derivable<T> = (state: MiddlewareState) => T;\r\n\r\n/**\r\n * Resolves with an object of overflow side offsets that determine how much the\r\n * element is overflowing a given clipping boundary on each side.\r\n * - positive = overflowing the boundary by that number of pixels\r\n * - negative = how many pixels left before it will overflow\r\n * - 0 = lies flush with the boundary\r\n * @see https://floating-ui.com/docs/detectOverflow\r\n */\r\nexport declare const detectOverflow: (state: MiddlewareState, options?: DetectOverflowOptions | Derivable<DetectOverflowOptions>) => Promise<SideObject>;\r\n\r\nexport declare type DetectOverflowOptions = Prettify<Omit<DetectOverflowOptions_2, 'boundary'> & {\r\n    boundary?: Boundary;\r\n}>;\r\n\r\nexport { Dimensions }\r\n\r\nexport { ElementContext }\r\n\r\nexport { ElementRects }\r\n\r\nexport declare interface Elements {\r\n    reference: ReferenceElement;\r\n    floating: FloatingElement;\r\n}\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by flipping the `placement`\r\n * in order to keep it in view when the preferred placement(s) will overflow the\r\n * clipping boundary. Alternative to `autoPlacement`.\r\n * @see https://floating-ui.com/docs/flip\r\n */\r\nexport declare const flip: (options?: FlipOptions | Derivable<FlipOptions>) => Middleware;\r\n\r\nexport declare type FlipOptions = Prettify<Omit<FlipOptions_2, 'boundary'> & DetectOverflowOptions>;\r\n\r\nexport declare type FloatingElement = HTMLElement;\r\n\r\nexport { getOverflowAncestors }\r\n\r\n/**\r\n * Provides data to hide the floating element in applicable situations, such as\r\n * when it is not in the same clipping context as the reference element.\r\n * @see https://floating-ui.com/docs/hide\r\n */\r\nexport declare const hide: (options?: HideOptions | Derivable<HideOptions>) => Middleware;\r\n\r\nexport declare type HideOptions = Prettify<Omit<HideOptions_2, 'boundary'> & DetectOverflowOptions>;\r\n\r\n/**\r\n * Provides improved positioning for inline reference elements that can span\r\n * over multiple lines, such as hyperlinks or range selections.\r\n * @see https://floating-ui.com/docs/inline\r\n */\r\nexport declare const inline: (options?: InlineOptions | Derivable<InlineOptions>) => Middleware;\r\n\r\nexport { InlineOptions }\r\n\r\nexport { Length }\r\n\r\n/**\r\n * Built-in `limiter` that will stop `shift()` at a certain point.\r\n */\r\nexport declare const limitShift: (options?: LimitShiftOptions | Derivable<LimitShiftOptions>) => {\r\n    options: any;\r\n    fn: (state: MiddlewareState) => Coords;\r\n};\r\n\r\nexport { LimitShiftOptions }\r\n\r\nexport declare type Middleware = Prettify<Omit<Middleware_2, 'fn'> & {\r\n    fn(state: MiddlewareState): Promisable<MiddlewareReturn>;\r\n}>;\r\n\r\n/**\r\n * @deprecated use `MiddlewareState` instead.\r\n */\r\nexport declare type MiddlewareArguments = MiddlewareState;\r\n\r\nexport { MiddlewareData }\r\n\r\nexport { MiddlewareReturn }\r\n\r\nexport declare type MiddlewareState = Prettify<Omit<MiddlewareState_2, 'elements'> & {\r\n    elements: Elements;\r\n}>;\r\n\r\nexport declare interface NodeScroll {\r\n    scrollLeft: number;\r\n    scrollTop: number;\r\n}\r\n\r\n/**\r\n * Modifies the placement by translating the floating element along the\r\n * specified axes.\r\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\r\n * object may be passed.\r\n * @see https://floating-ui.com/docs/offset\r\n */\r\nexport declare const offset: (options?: OffsetOptions) => Middleware;\r\n\r\nexport declare type OffsetOptions = OffsetValue | Derivable<OffsetValue>;\r\n\r\ndeclare type OffsetValue = number | {\r\n    /**\r\n     * The axis that runs along the side of the floating element. Represents\r\n     * the distance (gutter or margin) between the reference and floating\r\n     * element.\r\n     * @default 0\r\n     */\r\n    mainAxis?: number;\r\n    /**\r\n     * The axis that runs along the alignment of the floating element.\r\n     * Represents the skidding between the reference and floating element.\r\n     * @default 0\r\n     */\r\n    crossAxis?: number;\r\n    /**\r\n     * The same axis as `crossAxis` but applies only to aligned placements\r\n     * and inverts the `end` alignment. When set to a number, it overrides the\r\n     * `crossAxis` value.\r\n     *\r\n     * A positive number will move the floating element in the direction of\r\n     * the opposite edge to the one that is aligned, while a negative number\r\n     * the reverse.\r\n     * @default null\r\n     */\r\n    alignmentAxis?: number | null;\r\n};\r\n\r\nexport { Padding }\r\n\r\nexport { Placement }\r\n\r\nexport declare interface Platform {\r\n    getElementRects: (args: {\r\n        reference: ReferenceElement;\r\n        floating: FloatingElement;\r\n        strategy: Strategy;\r\n    }) => Promisable<ElementRects>;\r\n    getClippingRect: (args: {\r\n        element: Element;\r\n        boundary: Boundary;\r\n        rootBoundary: RootBoundary;\r\n        strategy: Strategy;\r\n    }) => Promisable<Rect>;\r\n    getDimensions: (element: Element) => Promisable<Dimensions>;\r\n    convertOffsetParentRelativeRectToViewportRelativeRect: (args: {\r\n        elements?: Elements;\r\n        rect: Rect;\r\n        offsetParent: Element;\r\n        strategy: Strategy;\r\n    }) => Promisable<Rect>;\r\n    getOffsetParent: (element: Element, polyfill?: (element: HTMLElement) => Element | null) => Promisable<Element | Window>;\r\n    isElement: (value: unknown) => Promisable<boolean>;\r\n    getDocumentElement: (element: Element) => Promisable<HTMLElement>;\r\n    getClientRects: (element: Element) => Promisable<Array<ClientRectObject>>;\r\n    isRTL: (element: Element) => Promisable<boolean>;\r\n    getScale: (element: HTMLElement) => Promisable<{\r\n        x: number;\r\n        y: number;\r\n    }>;\r\n}\r\n\r\nexport declare const platform: Platform;\r\n\r\ndeclare type Prettify<T> = {\r\n    [K in keyof T]: T[K];\r\n} & {};\r\n\r\ndeclare type Promisable<T> = T | Promise<T>;\r\n\r\nexport { Rect }\r\n\r\nexport declare type ReferenceElement = Element | VirtualElement;\r\n\r\nexport { RootBoundary }\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by shifting it in order to\r\n * keep it in view when it will overflow the clipping boundary.\r\n * @see https://floating-ui.com/docs/shift\r\n */\r\nexport declare const shift: (options?: ShiftOptions | Derivable<ShiftOptions>) => Middleware;\r\n\r\nexport declare type ShiftOptions = Prettify<Omit<ShiftOptions_2, 'boundary'> & DetectOverflowOptions>;\r\n\r\nexport { Side }\r\n\r\nexport { SideObject }\r\n\r\n/**\r\n * Provides data that allows you to change the size of the floating element â€”\r\n * for instance, prevent it from overflowing the clipping boundary or match the\r\n * width of the reference element.\r\n * @see https://floating-ui.com/docs/size\r\n */\r\nexport declare const size: (options?: SizeOptions | Derivable<SizeOptions>) => Middleware;\r\n\r\nexport declare type SizeOptions = Prettify<Omit<SizeOptions_2, 'apply' | 'boundary'> & DetectOverflowOptions & {\r\n    /**\r\n     * Function that is called to perform style mutations to the floating element\r\n     * to change its size.\r\n     * @default undefined\r\n     */\r\n    apply?(args: MiddlewareState & {\r\n        availableWidth: number;\r\n        availableHeight: number;\r\n    }): Promisable<void>;\r\n}>;\r\n\r\nexport { Strategy }\r\n\r\n/**\r\n * Custom positioning reference element.\r\n * @see https://floating-ui.com/docs/virtual-elements\r\n */\r\nexport declare interface VirtualElement {\r\n    getBoundingClientRect(): ClientRectObject;\r\n    getClientRects?(): Array<ClientRectObject> | DOMRectList;\r\n    contextElement?: Element;\r\n}\r\n\r\nexport { }\r\n"
        }
    ]
}