{
    "sourceFile": "node_modules/@floating-ui/core/dist/floating-ui.core.d.mts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891760534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { AlignedPlacement } from '@floating-ui/utils';\r\nimport { Alignment } from '@floating-ui/utils';\r\nimport { Axis } from '@floating-ui/utils';\r\nimport { ClientRectObject } from '@floating-ui/utils';\r\nimport { Coords } from '@floating-ui/utils';\r\nimport { Dimensions } from '@floating-ui/utils';\r\nimport { ElementRects } from '@floating-ui/utils';\r\nimport { Length } from '@floating-ui/utils';\r\nimport { Padding } from '@floating-ui/utils';\r\nimport { Placement } from '@floating-ui/utils';\r\nimport { Rect } from '@floating-ui/utils';\r\nimport { rectToClientRect } from '@floating-ui/utils';\r\nimport { Side } from '@floating-ui/utils';\r\nimport { SideObject } from '@floating-ui/utils';\r\nimport { Strategy } from '@floating-ui/utils';\r\nimport { VirtualElement } from '@floating-ui/utils';\r\n\r\nexport { AlignedPlacement }\r\n\r\nexport { Alignment }\r\n\r\n/**\r\n * Provides data to position an inner element of the floating element so that it\r\n * appears centered to the reference element.\r\n * @see https://floating-ui.com/docs/arrow\r\n */\r\nexport declare const arrow: (options: ArrowOptions | Derivable<ArrowOptions>) => Middleware;\r\n\r\nexport declare interface ArrowOptions {\r\n    /**\r\n     * The arrow element to be positioned.\r\n     * @default undefined\r\n     */\r\n    element: any;\r\n    /**\r\n     * The padding between the arrow element and the floating element edges.\r\n     * Useful when the floating element has rounded corners.\r\n     * @default 0\r\n     */\r\n    padding?: Padding;\r\n}\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by choosing the placement\r\n * that has the most space available automatically, without needing to specify a\r\n * preferred placement. Alternative to `flip`.\r\n * @see https://floating-ui.com/docs/autoPlacement\r\n */\r\nexport declare const autoPlacement: (options?: AutoPlacementOptions | Derivable<AutoPlacementOptions>) => Middleware;\r\n\r\nexport declare interface AutoPlacementOptions extends DetectOverflowOptions {\r\n    /**\r\n     * The axis that runs along the alignment of the floating element. Determines\r\n     * whether to check for most space along this axis.\r\n     * @default false\r\n     */\r\n    crossAxis?: boolean;\r\n    /**\r\n     * Choose placements with a particular alignment.\r\n     * @default undefined\r\n     */\r\n    alignment?: Alignment | null;\r\n    /**\r\n     * Whether to choose placements with the opposite alignment if the preferred\r\n     * alignment does not fit.\r\n     * @default true\r\n     */\r\n    autoAlignment?: boolean;\r\n    /**\r\n     * Which placements are allowed to be chosen. Placements must be within the\r\n     * `alignment` option if explicitly set.\r\n     * @default allPlacements (variable)\r\n     */\r\n    allowedPlacements?: Array<Placement>;\r\n}\r\n\r\nexport { Axis }\r\n\r\nexport declare type Boundary = any;\r\n\r\nexport { ClientRectObject }\r\n\r\nexport declare type ComputePosition = (reference: unknown, floating: unknown, config: ComputePositionConfig) => Promise<ComputePositionReturn>;\r\n\r\n/**\r\n * Computes the `x` and `y` coordinates that will place the floating element\r\n * next to a given reference element.\r\n *\r\n * This export does not have any `platform` interface logic. You will need to\r\n * write one for the platform you are using Floating UI with.\r\n */\r\nexport declare const computePosition: ComputePosition;\r\n\r\nexport declare interface ComputePositionConfig {\r\n    /**\r\n     * Object to interface with the current platform.\r\n     */\r\n    platform: Platform;\r\n    /**\r\n     * Where to place the floating element relative to the reference element.\r\n     */\r\n    placement?: Placement;\r\n    /**\r\n     * The strategy to use when positioning the floating element.\r\n     */\r\n    strategy?: Strategy;\r\n    /**\r\n     * Array of middleware objects to modify the positioning or provide data for\r\n     * rendering.\r\n     */\r\n    middleware?: Array<Middleware | null | undefined | false>;\r\n}\r\n\r\nexport declare interface ComputePositionReturn extends Coords {\r\n    /**\r\n     * The final chosen placement of the floating element.\r\n     */\r\n    placement: Placement;\r\n    /**\r\n     * The strategy used to position the floating element.\r\n     */\r\n    strategy: Strategy;\r\n    /**\r\n     * Object containing data returned from all middleware, keyed by their name.\r\n     */\r\n    middlewareData: MiddlewareData;\r\n}\r\n\r\nexport { Coords }\r\n\r\n/**\r\n * Function option to derive middleware options from state.\r\n */\r\nexport declare type Derivable<T> = (state: MiddlewareState) => T;\r\n\r\n/**\r\n * Resolves with an object of overflow side offsets that determine how much the\r\n * element is overflowing a given clipping boundary on each side.\r\n * - positive = overflowing the boundary by that number of pixels\r\n * - negative = how many pixels left before it will overflow\r\n * - 0 = lies flush with the boundary\r\n * @see https://floating-ui.com/docs/detectOverflow\r\n */\r\nexport declare function detectOverflow(state: MiddlewareState, options?: DetectOverflowOptions | Derivable<DetectOverflowOptions>): Promise<SideObject>;\r\n\r\nexport declare interface DetectOverflowOptions {\r\n    /**\r\n     * The clipping element(s) or area in which overflow will be checked.\r\n     * @default 'clippingAncestors'\r\n     */\r\n    boundary?: Boundary;\r\n    /**\r\n     * The root clipping area in which overflow will be checked.\r\n     * @default 'viewport'\r\n     */\r\n    rootBoundary?: RootBoundary;\r\n    /**\r\n     * The element in which overflow is being checked relative to a boundary.\r\n     * @default 'floating'\r\n     */\r\n    elementContext?: ElementContext;\r\n    /**\r\n     * Whether to check for overflow using the alternate element's boundary\r\n     * (`clippingAncestors` boundary only).\r\n     * @default false\r\n     */\r\n    altBoundary?: boolean;\r\n    /**\r\n     * Virtual padding for the resolved overflow detection offsets.\r\n     * @default 0\r\n     */\r\n    padding?: Padding;\r\n}\r\n\r\nexport { Dimensions }\r\n\r\nexport declare type ElementContext = 'reference' | 'floating';\r\n\r\nexport { ElementRects }\r\n\r\nexport declare interface Elements {\r\n    reference: ReferenceElement;\r\n    floating: FloatingElement;\r\n}\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by flipping the `placement`\r\n * in order to keep it in view when the preferred placement(s) will overflow the\r\n * clipping boundary. Alternative to `autoPlacement`.\r\n * @see https://floating-ui.com/docs/flip\r\n */\r\nexport declare const flip: (options?: FlipOptions | Derivable<FlipOptions>) => Middleware;\r\n\r\nexport declare interface FlipOptions extends DetectOverflowOptions {\r\n    /**\r\n     * The axis that runs along the side of the floating element. Determines\r\n     * whether overflow along this axis is checked to perform a flip.\r\n     * @default true\r\n     */\r\n    mainAxis?: boolean;\r\n    /**\r\n     * The axis that runs along the alignment of the floating element. Determines\r\n     * whether overflow along this axis is checked to perform a flip.\r\n     * @default true\r\n     */\r\n    crossAxis?: boolean;\r\n    /**\r\n     * Placements to try sequentially if the preferred `placement` does not fit.\r\n     * @default [oppositePlacement] (computed)\r\n     */\r\n    fallbackPlacements?: Array<Placement>;\r\n    /**\r\n     * What strategy to use when no placements fit.\r\n     * @default 'bestFit'\r\n     */\r\n    fallbackStrategy?: 'bestFit' | 'initialPlacement';\r\n    /**\r\n     * Whether to allow fallback to the perpendicular axis of the preferred\r\n     * placement, and if so, which side direction along the axis to prefer.\r\n     * @default 'none' (disallow fallback)\r\n     */\r\n    fallbackAxisSideDirection?: 'none' | 'start' | 'end';\r\n    /**\r\n     * Whether to flip to placements with the opposite alignment if they fit\r\n     * better.\r\n     * @default true\r\n     */\r\n    flipAlignment?: boolean;\r\n}\r\n\r\nexport declare type FloatingElement = any;\r\n\r\n/**\r\n * Provides data to hide the floating element in applicable situations, such as\r\n * when it is not in the same clipping context as the reference element.\r\n * @see https://floating-ui.com/docs/hide\r\n */\r\nexport declare const hide: (options?: HideOptions | Derivable<HideOptions>) => Middleware;\r\n\r\nexport declare interface HideOptions extends DetectOverflowOptions {\r\n    /**\r\n     * The strategy used to determine when to hide the floating element.\r\n     */\r\n    strategy?: 'referenceHidden' | 'escaped';\r\n}\r\n\r\n/**\r\n * Provides improved positioning for inline reference elements that can span\r\n * over multiple lines, such as hyperlinks or range selections.\r\n * @see https://floating-ui.com/docs/inline\r\n */\r\nexport declare const inline: (options?: InlineOptions | Derivable<InlineOptions>) => Middleware;\r\n\r\nexport declare interface InlineOptions {\r\n    /**\r\n     * Viewport-relative `x` coordinate to choose a `ClientRect`.\r\n     * @default undefined\r\n     */\r\n    x?: number;\r\n    /**\r\n     * Viewport-relative `y` coordinate to choose a `ClientRect`.\r\n     * @default undefined\r\n     */\r\n    y?: number;\r\n    /**\r\n     * Represents the padding around a disjoined rect when choosing it.\r\n     * @default 2\r\n     */\r\n    padding?: Padding;\r\n}\r\n\r\nexport { Length }\r\n\r\n/**\r\n * Built-in `limiter` that will stop `shift()` at a certain point.\r\n */\r\nexport declare const limitShift: (options?: LimitShiftOptions | Derivable<LimitShiftOptions>) => {\r\n    options: any;\r\n    fn: (state: MiddlewareState) => Coords;\r\n};\r\n\r\ndeclare type LimitShiftOffset = number | {\r\n    /**\r\n     * Offset the limiting of the axis that runs along the alignment of the\r\n     * floating element.\r\n     */\r\n    mainAxis?: number;\r\n    /**\r\n     * Offset the limiting of the axis that runs along the side of the\r\n     * floating element.\r\n     */\r\n    crossAxis?: number;\r\n};\r\n\r\nexport declare interface LimitShiftOptions {\r\n    /**\r\n     * Offset when limiting starts. `0` will limit when the opposite edges of the\r\n     * reference and floating elements are aligned.\r\n     * - positive = start limiting earlier\r\n     * - negative = start limiting later\r\n     */\r\n    offset?: LimitShiftOffset | Derivable<LimitShiftOffset>;\r\n    /**\r\n     * Whether to limit the axis that runs along the alignment of the floating\r\n     * element.\r\n     */\r\n    mainAxis?: boolean;\r\n    /**\r\n     * Whether to limit the axis that runs along the side of the floating element.\r\n     */\r\n    crossAxis?: boolean;\r\n}\r\n\r\nexport declare type Middleware = {\r\n    name: string;\r\n    options?: any;\r\n    fn: (state: MiddlewareState) => Promisable<MiddlewareReturn>;\r\n};\r\n\r\n/**\r\n * @deprecated use `MiddlewareState` instead.\r\n */\r\nexport declare type MiddlewareArguments = MiddlewareState;\r\n\r\nexport declare interface MiddlewareData {\r\n    [key: string]: any;\r\n    arrow?: Partial<Coords> & {\r\n        centerOffset: number;\r\n        alignmentOffset?: number;\r\n    };\r\n    autoPlacement?: {\r\n        index?: number;\r\n        overflows: Array<{\r\n            placement: Placement;\r\n            overflows: Array<number>;\r\n        }>;\r\n    };\r\n    flip?: {\r\n        index?: number;\r\n        overflows: Array<{\r\n            placement: Placement;\r\n            overflows: Array<number>;\r\n        }>;\r\n    };\r\n    hide?: {\r\n        referenceHidden?: boolean;\r\n        escaped?: boolean;\r\n        referenceHiddenOffsets?: SideObject;\r\n        escapedOffsets?: SideObject;\r\n    };\r\n    offset?: Coords & {\r\n        placement: Placement;\r\n    };\r\n    shift?: Coords & {\r\n        enabled: {\r\n            [key in Axis]: boolean;\r\n        };\r\n    };\r\n}\r\n\r\nexport declare interface MiddlewareReturn extends Partial<Coords> {\r\n    data?: {\r\n        [key: string]: any;\r\n    };\r\n    reset?: boolean | {\r\n        placement?: Placement;\r\n        rects?: boolean | ElementRects;\r\n    };\r\n}\r\n\r\nexport declare interface MiddlewareState extends Coords {\r\n    initialPlacement: Placement;\r\n    placement: Placement;\r\n    strategy: Strategy;\r\n    middlewareData: MiddlewareData;\r\n    elements: Elements;\r\n    rects: ElementRects;\r\n    platform: Platform;\r\n}\r\n\r\n/**\r\n * Modifies the placement by translating the floating element along the\r\n * specified axes.\r\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\r\n * object may be passed.\r\n * @see https://floating-ui.com/docs/offset\r\n */\r\nexport declare const offset: (options?: OffsetOptions) => Middleware;\r\n\r\nexport declare type OffsetOptions = OffsetValue | Derivable<OffsetValue>;\r\n\r\ndeclare type OffsetValue = number | {\r\n    /**\r\n     * The axis that runs along the side of the floating element. Represents\r\n     * the distance (gutter or margin) between the reference and floating\r\n     * element.\r\n     * @default 0\r\n     */\r\n    mainAxis?: number;\r\n    /**\r\n     * The axis that runs along the alignment of the floating element.\r\n     * Represents the skidding between the reference and floating element.\r\n     * @default 0\r\n     */\r\n    crossAxis?: number;\r\n    /**\r\n     * The same axis as `crossAxis` but applies only to aligned placements\r\n     * and inverts the `end` alignment. When set to a number, it overrides the\r\n     * `crossAxis` value.\r\n     *\r\n     * A positive number will move the floating element in the direction of\r\n     * the opposite edge to the one that is aligned, while a negative number\r\n     * the reverse.\r\n     * @default null\r\n     */\r\n    alignmentAxis?: number | null;\r\n};\r\n\r\nexport { Padding }\r\n\r\nexport { Placement }\r\n\r\n/**\r\n * Platform interface methods to work with the current platform.\r\n * @see https://floating-ui.com/docs/platform\r\n */\r\nexport declare interface Platform {\r\n    getElementRects: (args: {\r\n        reference: ReferenceElement;\r\n        floating: FloatingElement;\r\n        strategy: Strategy;\r\n    }) => Promisable<ElementRects>;\r\n    getClippingRect: (args: {\r\n        element: any;\r\n        boundary: Boundary;\r\n        rootBoundary: RootBoundary;\r\n        strategy: Strategy;\r\n    }) => Promisable<Rect>;\r\n    getDimensions: (element: any) => Promisable<Dimensions>;\r\n    convertOffsetParentRelativeRectToViewportRelativeRect?: (args: {\r\n        elements?: Elements;\r\n        rect: Rect;\r\n        offsetParent: any;\r\n        strategy: Strategy;\r\n    }) => Promisable<Rect>;\r\n    getOffsetParent?: (element: any) => Promisable<any>;\r\n    isElement?: (value: any) => Promisable<boolean>;\r\n    getDocumentElement?: (element: any) => Promisable<any>;\r\n    getClientRects?: (element: any) => Promisable<Array<ClientRectObject>>;\r\n    isRTL?: (element: any) => Promisable<boolean>;\r\n    getScale?: (element: any) => Promisable<{\r\n        x: number;\r\n        y: number;\r\n    }>;\r\n}\r\n\r\ndeclare type Promisable<T> = T | Promise<T>;\r\n\r\nexport { Rect }\r\n\r\nexport { rectToClientRect }\r\n\r\nexport declare type ReferenceElement = any;\r\n\r\nexport declare type RootBoundary = 'viewport' | 'document' | Rect;\r\n\r\n/**\r\n * Optimizes the visibility of the floating element by shifting it in order to\r\n * keep it in view when it will overflow the clipping boundary.\r\n * @see https://floating-ui.com/docs/shift\r\n */\r\nexport declare const shift: (options?: ShiftOptions | Derivable<ShiftOptions>) => Middleware;\r\n\r\nexport declare interface ShiftOptions extends DetectOverflowOptions {\r\n    /**\r\n     * The axis that runs along the alignment of the floating element. Determines\r\n     * whether overflow along this axis is checked to perform shifting.\r\n     * @default true\r\n     */\r\n    mainAxis?: boolean;\r\n    /**\r\n     * The axis that runs along the side of the floating element. Determines\r\n     * whether overflow along this axis is checked to perform shifting.\r\n     * @default false\r\n     */\r\n    crossAxis?: boolean;\r\n    /**\r\n     * Accepts a function that limits the shifting done in order to prevent\r\n     * detachment.\r\n     */\r\n    limiter?: {\r\n        fn: (state: MiddlewareState) => Coords;\r\n        options?: any;\r\n    };\r\n}\r\n\r\nexport { Side }\r\n\r\nexport { SideObject }\r\n\r\n/**\r\n * Provides data that allows you to change the size of the floating element —\r\n * for instance, prevent it from overflowing the clipping boundary or match the\r\n * width of the reference element.\r\n * @see https://floating-ui.com/docs/size\r\n */\r\nexport declare const size: (options?: SizeOptions | Derivable<SizeOptions>) => Middleware;\r\n\r\nexport declare interface SizeOptions extends DetectOverflowOptions {\r\n    /**\r\n     * Function that is called to perform style mutations to the floating element\r\n     * to change its size.\r\n     * @default undefined\r\n     */\r\n    apply?(args: MiddlewareState & {\r\n        availableWidth: number;\r\n        availableHeight: number;\r\n    }): void | Promise<void>;\r\n}\r\n\r\nexport { Strategy }\r\n\r\nexport { VirtualElement }\r\n\r\nexport { }\r\n"
        }
    ]
}