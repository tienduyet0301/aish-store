{
    "sourceFile": "node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.umd.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891761936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/dom'), require('react'), require('react-dom')) :\n  typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/dom', 'react', 'react-dom'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIReactDOM = {}, global.FloatingUIDOM, global.React, global.ReactDOM));\n})(this, (function (exports, dom, React, ReactDOM) { 'use strict';\n\n  function _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () { return e[k]; }\n          });\n        }\n      });\n    }\n    n.default = e;\n    return Object.freeze(n);\n  }\n\n  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);\n  var ReactDOM__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM);\n\n  var index = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\n  // Fork of `fast-deep-equal` that only does the comparisons we need and compares\n  // functions\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (typeof a !== typeof b) {\n      return false;\n    }\n    if (typeof a === 'function' && a.toString() === b.toString()) {\n      return true;\n    }\n    let length;\n    let i;\n    let keys;\n    if (a && b && typeof a === 'object') {\n      if (Array.isArray(a)) {\n        length = a.length;\n        if (length !== b.length) return false;\n        for (i = length; i-- !== 0;) {\n          if (!deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      keys = Object.keys(a);\n      length = keys.length;\n      if (length !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length; i-- !== 0;) {\n        if (!{}.hasOwnProperty.call(b, keys[i])) {\n          return false;\n        }\n      }\n      for (i = length; i-- !== 0;) {\n        const key = keys[i];\n        if (key === '_owner' && a.$$typeof) {\n          continue;\n        }\n        if (!deepEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return a !== a && b !== b;\n  }\n\n  function getDPR(element) {\n    if (typeof window === 'undefined') {\n      return 1;\n    }\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n  }\n\n  function roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n  }\n\n  function useLatestRef(value) {\n    const ref = React__namespace.useRef(value);\n    index(() => {\n      ref.current = value;\n    });\n    return ref;\n  }\n\n  /**\n   * Provides data to position a floating element.\n   * @see https://floating-ui.com/docs/useFloating\n   */\n  function useFloating(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      placement = 'bottom',\n      strategy = 'absolute',\n      middleware = [],\n      platform,\n      elements: {\n        reference: externalReference,\n        floating: externalFloating\n      } = {},\n      transform = true,\n      whileElementsMounted,\n      open\n    } = options;\n    const [data, setData] = React__namespace.useState({\n      x: 0,\n      y: 0,\n      strategy,\n      placement,\n      middlewareData: {},\n      isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n      setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = React__namespace.useState(null);\n    const [_floating, _setFloating] = React__namespace.useState(null);\n    const setReference = React__namespace.useCallback(node => {\n      if (node !== referenceRef.current) {\n        referenceRef.current = node;\n        _setReference(node);\n      }\n    }, []);\n    const setFloating = React__namespace.useCallback(node => {\n      if (node !== floatingRef.current) {\n        floatingRef.current = node;\n        _setFloating(node);\n      }\n    }, []);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = React__namespace.useRef(null);\n    const floatingRef = React__namespace.useRef(null);\n    const dataRef = React__namespace.useRef(data);\n    const hasWhileElementsMounted = whileElementsMounted != null;\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const openRef = useLatestRef(open);\n    const update = React__namespace.useCallback(() => {\n      if (!referenceRef.current || !floatingRef.current) {\n        return;\n      }\n      const config = {\n        placement,\n        strategy,\n        middleware: latestMiddleware\n      };\n      if (platformRef.current) {\n        config.platform = platformRef.current;\n      }\n      dom.computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n        const fullData = {\n          ...data,\n          // The floating element's position may be recomputed while it's closed\n          // but still mounted (such as when transitioning out). To ensure\n          // `isPositioned` will be `false` initially on the next open, avoid\n          // setting it to `true` when `open === false` (must be specified).\n          isPositioned: openRef.current !== false\n        };\n        if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n          dataRef.current = fullData;\n          ReactDOM__namespace.flushSync(() => {\n            setData(fullData);\n          });\n        }\n      });\n    }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n    index(() => {\n      if (open === false && dataRef.current.isPositioned) {\n        dataRef.current.isPositioned = false;\n        setData(data => ({\n          ...data,\n          isPositioned: false\n        }));\n      }\n    }, [open]);\n    const isMountedRef = React__namespace.useRef(false);\n    index(() => {\n      isMountedRef.current = true;\n      return () => {\n        isMountedRef.current = false;\n      };\n    }, []);\n    index(() => {\n      if (referenceEl) referenceRef.current = referenceEl;\n      if (floatingEl) floatingRef.current = floatingEl;\n      if (referenceEl && floatingEl) {\n        if (whileElementsMountedRef.current) {\n          return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n        }\n        update();\n      }\n    }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n    const refs = React__namespace.useMemo(() => ({\n      reference: referenceRef,\n      floating: floatingRef,\n      setReference,\n      setFloating\n    }), [setReference, setFloating]);\n    const elements = React__namespace.useMemo(() => ({\n      reference: referenceEl,\n      floating: floatingEl\n    }), [referenceEl, floatingEl]);\n    const floatingStyles = React__namespace.useMemo(() => {\n      const initialStyles = {\n        position: strategy,\n        left: 0,\n        top: 0\n      };\n      if (!elements.floating) {\n        return initialStyles;\n      }\n      const x = roundByDPR(elements.floating, data.x);\n      const y = roundByDPR(elements.floating, data.y);\n      if (transform) {\n        return {\n          ...initialStyles,\n          transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n          ...(getDPR(elements.floating) >= 1.5 && {\n            willChange: 'transform'\n          })\n        };\n      }\n      return {\n        position: strategy,\n        left: x,\n        top: y\n      };\n    }, [strategy, transform, elements.floating, data.x, data.y]);\n    return React__namespace.useMemo(() => ({\n      ...data,\n      update,\n      refs,\n      elements,\n      floatingStyles\n    }), [data, update, refs, elements, floatingStyles]);\n  }\n\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * This wraps the core `arrow` middleware to allow React refs as the element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  const arrow$1 = options => {\n    function isRef(value) {\n      return {}.hasOwnProperty.call(value, 'current');\n    }\n    return {\n      name: 'arrow',\n      options,\n      fn(state) {\n        const {\n          element,\n          padding\n        } = typeof options === 'function' ? options(state) : options;\n        if (element && isRef(element)) {\n          if (element.current != null) {\n            return dom.arrow({\n              element: element.current,\n              padding\n            }).fn(state);\n          }\n          return {};\n        }\n        if (element) {\n          return dom.arrow({\n            element,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n    };\n  };\n\n  /**\n   * Modifies the placement by translating the floating element along the\n   * specified axes.\n   * A number (shorthand for `mainAxis` or distance), or an axes configuration\n   * object may be passed.\n   * @see https://floating-ui.com/docs/offset\n   */\n  const offset = (options, deps) => ({\n    ...dom.offset(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Optimizes the visibility of the floating element by shifting it in order to\n   * keep it in view when it will overflow the clipping boundary.\n   * @see https://floating-ui.com/docs/shift\n   */\n  const shift = (options, deps) => ({\n    ...dom.shift(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Built-in `limiter` that will stop `shift()` at a certain point.\n   */\n  const limitShift = (options, deps) => ({\n    ...dom.limitShift(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Optimizes the visibility of the floating element by flipping the `placement`\n   * in order to keep it in view when the preferred placement(s) will overflow the\n   * clipping boundary. Alternative to `autoPlacement`.\n   * @see https://floating-ui.com/docs/flip\n   */\n  const flip = (options, deps) => ({\n    ...dom.flip(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Provides data that allows you to change the size of the floating element â€”\n   * for instance, prevent it from overflowing the clipping boundary or match the\n   * width of the reference element.\n   * @see https://floating-ui.com/docs/size\n   */\n  const size = (options, deps) => ({\n    ...dom.size(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Optimizes the visibility of the floating element by choosing the placement\n   * that has the most space available automatically, without needing to specify a\n   * preferred placement. Alternative to `flip`.\n   * @see https://floating-ui.com/docs/autoPlacement\n   */\n  const autoPlacement = (options, deps) => ({\n    ...dom.autoPlacement(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Provides data to hide the floating element in applicable situations, such as\n   * when it is not in the same clipping context as the reference element.\n   * @see https://floating-ui.com/docs/hide\n   */\n  const hide = (options, deps) => ({\n    ...dom.hide(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Provides improved positioning for inline reference elements that can span\n   * over multiple lines, such as hyperlinks or range selections.\n   * @see https://floating-ui.com/docs/inline\n   */\n  const inline = (options, deps) => ({\n    ...dom.inline(options),\n    options: [options, deps]\n  });\n\n  /**\n   * Provides data to position an inner element of the floating element so that it\n   * appears centered to the reference element.\n   * This wraps the core `arrow` middleware to allow React refs as the element.\n   * @see https://floating-ui.com/docs/arrow\n   */\n  const arrow = (options, deps) => ({\n    ...arrow$1(options),\n    options: [options, deps]\n  });\n\n  Object.defineProperty(exports, \"autoUpdate\", {\n    enumerable: true,\n    get: function () { return dom.autoUpdate; }\n  });\n  Object.defineProperty(exports, \"computePosition\", {\n    enumerable: true,\n    get: function () { return dom.computePosition; }\n  });\n  Object.defineProperty(exports, \"detectOverflow\", {\n    enumerable: true,\n    get: function () { return dom.detectOverflow; }\n  });\n  Object.defineProperty(exports, \"getOverflowAncestors\", {\n    enumerable: true,\n    get: function () { return dom.getOverflowAncestors; }\n  });\n  Object.defineProperty(exports, \"platform\", {\n    enumerable: true,\n    get: function () { return dom.platform; }\n  });\n  exports.arrow = arrow;\n  exports.autoPlacement = autoPlacement;\n  exports.flip = flip;\n  exports.hide = hide;\n  exports.inline = inline;\n  exports.limitShift = limitShift;\n  exports.offset = offset;\n  exports.shift = shift;\n  exports.size = size;\n  exports.useFloating = useFloating;\n\n}));\n"
        }
    ]
}