{
    "sourceFile": "node_modules/preact/hooks/src/internal.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892967657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import {\n\tOptions as PreactOptions,\n\tComponent as PreactComponent,\n\tVNode as PreactVNode,\n\tPreactContext,\n\tHookType,\n\tErrorInfo,\n} from '../../src/internal';\nimport { Reducer, StateUpdater } from '.';\n\nexport { PreactContext };\n\nexport interface Options extends PreactOptions {\n\t/** Attach a hook that is invoked before a vnode is diffed. */\n\t_diff?(vnode: VNode): void;\n\tdiffed?(vnode: VNode): void;\n\t/** Attach a hook that is invoked before a vnode has rendered. */\n\t_render?(vnode: VNode): void;\n\t/** Attach a hook that is invoked after a tree was mounted or was updated. */\n\t_commit?(vnode: VNode, commitQueue: Component[]): void;\n\t_unmount?(vnode: VNode): void;\n\t/** Attach a hook that is invoked before a hook's state is queried. */\n\t_hook?(component: Component, index: number, type: HookType): void;\n}\n\n// Hook tracking\n\nexport interface ComponentHooks {\n\t/** The list of hooks a component uses */\n\t_list: HookState[];\n\t/** List of Effects to be invoked after the next frame is rendered */\n\t_pendingEffects: EffectHookState[];\n}\n\nexport interface Component extends Omit<PreactComponent<any, any>, '_renderCallbacks'> {\n\t__hooks?: ComponentHooks;\n\t// Extend to include HookStates\n\t_renderCallbacks?: Array<HookState | (() => void)>;\n\t_hasScuFromHooks?: boolean;\n}\n\nexport interface VNode extends Omit<PreactVNode, '_component'> {\n\t_mask?: [number, number];\n\t_component?: Component; // Override with our specific Component type\n}\n\nexport type HookState =\n\t| EffectHookState\n\t| MemoHookState\n\t| ReducerHookState\n\t| ContextHookState\n\t| ErrorBoundaryHookState\n\t| IdHookState;\n\ninterface BaseHookState {\n\t_value?: unknown;\n\t_nextValue?: unknown;\n\t_pendingValue?: unknown;\n\t_args?: unknown;\n\t_pendingArgs?: unknown;\n\t_component?: unknown;\n\t_cleanup?: unknown;\n}\n\nexport type Effect = () => void | Cleanup;\nexport type Cleanup = () => void;\n\nexport interface EffectHookState extends BaseHookState {\n\t_value?: Effect;\n\t_args?: unknown[];\n\t_pendingArgs?: unknown[];\n\t_cleanup?: Cleanup | void;\n}\n\nexport interface MemoHookState<T = unknown> extends BaseHookState {\n\t_value?: T;\n\t_pendingValue?: T;\n\t_args?: unknown[];\n\t_pendingArgs?: unknown[];\n\t_factory?: () => T;\n}\n\nexport interface ReducerHookState<S = unknown, A = unknown>\n\textends BaseHookState {\n\t_nextValue?: [S, StateUpdater<S>];\n\t_value?: [S, StateUpdater<S>];\n\t_component?: Component;\n\t_reducer?: Reducer<S, A>;\n}\n\nexport interface ContextHookState extends BaseHookState {\n\t/** Whether this hooks as subscribed to updates yet */\n\t_value?: boolean;\n\t_context?: PreactContext;\n}\n\nexport interface ErrorBoundaryHookState extends BaseHookState {\n\t_value?: (error: unknown, errorInfo: ErrorInfo) => void;\n}\n\nexport interface IdHookState extends BaseHookState {\n\t_value?: string;\n}\n"
        }
    ]
}