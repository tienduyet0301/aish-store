{
    "sourceFile": "node_modules/preact/src/internal.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892969613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Intentionally not using a relative path to take advantage of\n// the TS version resolution mechanism\nimport * as preact from 'preact';\n\nexport enum HookType {\n\tuseState = 1,\n\tuseReducer = 2,\n\tuseEffect = 3,\n\tuseLayoutEffect = 4,\n\tuseRef = 5,\n\tuseImperativeHandle = 6,\n\tuseMemo = 7,\n\tuseCallback = 8,\n\tuseContext = 9,\n\tuseErrorBoundary = 10,\n\t// Not a real hook, but the devtools treat is as such\n\tuseDebugvalue = 11\n}\n\nexport interface DevSource {\n\tfileName: string;\n\tlineNumber: number;\n}\n\nexport interface ErrorInfo {\n\tcomponentStack?: string;\n}\n\nexport interface Options extends preact.Options {\n\t/** Attach a hook that is invoked before render, mainly to check the arguments. */\n\t_root?(vnode: ComponentChild, parent: preact.ContainerNode): void;\n\t/** Attach a hook that is invoked before a vnode is diffed. */\n\t_diff?(vnode: VNode): void;\n\t/** Attach a hook that is invoked after a tree was mounted or was updated. */\n\t_commit?(vnode: VNode, commitQueue: Component[]): void;\n\t/** Attach a hook that is invoked before a vnode has rendered. */\n\t_render?(vnode: VNode): void;\n\t/** Attach a hook that is invoked before a hook's state is queried. */\n\t_hook?(component: Component, index: number, type: HookType): void;\n\t/** Bypass effect execution. Currenty only used in devtools for hooks inspection */\n\t_skipEffects?: boolean;\n\t/** Attach a hook that is invoked after an error is caught in a component but before calling lifecycle hooks */\n\t_catchError(\n\t\terror: any,\n\t\tvnode: VNode,\n\t\toldVNode?: VNode | undefined,\n\t\terrorInfo?: ErrorInfo | undefined\n\t): void;\n\t/** Attach a hook that fires when hydration can't find a proper DOM-node to match with */\n\t_hydrationMismatch?(\n\t\tvnode: VNode,\n\t\texcessDomChildren: Array<PreactElement | null>\n\t): void;\n}\n\nexport type ComponentChild =\n\t| VNode<any>\n\t| string\n\t| number\n\t| boolean\n\t| null\n\t| undefined;\nexport type ComponentChildren = ComponentChild[] | ComponentChild;\n\nexport interface FunctionComponent<P = {}>\n\textends preact.FunctionComponent<P> {\n\t// Internally, createContext uses `contextType` on a Function component to\n\t// implement the Consumer component\n\tcontextType?: PreactContext;\n\n\t// Internally, createContext stores a ref to the context object on the Provider\n\t// Function component to help devtools\n\t_contextRef?: PreactContext;\n\n\t// Define these properties as undefined on FunctionComponent to get rid of\n\t// some errors in `diff()`\n\tgetDerivedStateFromProps?: undefined;\n\tgetDerivedStateFromError?: undefined;\n}\n\nexport interface ComponentClass<P = {}> extends preact.ComponentClass<P> {\n\t_contextRef?: any;\n\n\t// Override public contextType with internal PreactContext type\n\tcontextType?: PreactContext;\n}\n\n// Redefine ComponentType using our new internal FunctionComponent interface above\nexport type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\n\nexport interface PreactElement extends preact.ContainerNode {\n\t// Namespace detection\n\treadonly namespaceURI?: string;\n\t// Property used to update Text nodes\n\tdata?: CharacterData['data'];\n\t// Property to set __dangerouslySetInnerHTML\n\tinnerHTML?: Element['innerHTML'];\n\n\t// Attribute reading and setting\n\treadonly attributes?: Element['attributes'];\n\tsetAttribute?: Element['setAttribute'];\n\tremoveAttribute?: Element['removeAttribute'];\n\n\t// Event listeners\n\taddEventListener?: Element['addEventListener'];\n\tremoveEventListener?: Element['removeEventListener'];\n\n\t// Setting styles\n\treadonly style?: CSSStyleDeclaration;\n\n\t// nextSibling required for inserting nodes\n\treadonly nextSibling: PreactElement | null;\n\n\t// Used to match DOM nodes to VNodes during hydration. Note: doesn't exist\n\t// on Text nodes\n\treadonly localName?: string;\n\n\t// Input handling\n\tvalue?: HTMLInputElement['value'];\n\tchecked?: HTMLInputElement['checked'];\n\n\t// Internal properties\n\t_children?: VNode<any> | null;\n\t/** Event listeners to support event delegation */\n\t_listeners?: Record<string, (e: Event) => void>;\n}\n\nexport interface PreactEvent extends Event {\n\t_dispatched?: number;\n}\n\n// We use the `current` property to differentiate between the two kinds of Refs so\n// internally we'll define `current` on both to make TypeScript happy\ntype RefObject<T> = { current: T | null };\ntype RefCallback<T> = {\n\t(instance: T | null): void | (() => void);\n\tcurrent: undefined;\n};\nexport type Ref<T> = RefObject<T> | RefCallback<T>;\n\nexport interface VNode<P = {}> extends preact.VNode<P> {\n\t// Redefine type here using our internal ComponentType type, and specify\n\t// string has an undefined `defaultProps` property to make TS happy\n\ttype: (string & { defaultProps: undefined }) | ComponentType<P>;\n\tprops: P & { children: ComponentChildren };\n\tref?: Ref<any> | null;\n\t_children: Array<VNode<any>> | null;\n\t_parent: VNode | null;\n\t_depth: number | null;\n\t/**\n\t * The [first (for Fragments)] DOM child of a VNode\n\t */\n\t_dom: PreactElement | null;\n\t_component: Component | null;\n\tconstructor: undefined;\n\t_original: number;\n\t_index: number;\n\t_flags: number;\n}\n\nexport interface Component<P = {}, S = {}> extends Omit<preact.Component<P, S>, 'base'> {\n\t// When component is functional component, this is reset to functional component\n\tconstructor: ComponentType<P>;\n\tstate: S; // Override Component[\"state\"] to not be readonly for internal use, specifically Hooks\n\tbase?: PreactElement;\n\n\t_dirty: boolean;\n\t_force?: boolean;\n\t_renderCallbacks: Array<() => void>; // Only class components\n\t_stateCallbacks: Array<() => void>; // Only class components\n\t_globalContext?: any;\n\t_vnode?: VNode<P> | null;\n\t_nextState?: S | null; // Only class components\n\t/** Only used in the devtools to later dirty check if state has changed */\n\t_prevState?: S | null;\n\t/**\n\t * Pointer to the parent dom node. This is only needed for top-level Fragment\n\t * components or array returns.\n\t */\n\t_parentDom?: PreactElement | null;\n\t// Always read, set only when handling error\n\t_processingException?: Component<any, any> | null;\n\t// Always read, set only when handling error. This is used to indicate at diffTime to set _processingException\n\t_pendingError?: Component<any, any> | null;\n}\n\nexport interface PreactContext extends preact.Context<any> {\n\t_id: string;\n\t_defaultValue: any;\n}\n"
        }
    ]
}