{
    "sourceFile": "node_modules/arraybuffer.prototype.slice/implementation.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892036176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);\nvar $Uint8Array = GetIntrinsic('%Uint8Array%', true);\n\nvar IsDetachedBuffer = require('es-abstract/2024/IsDetachedBuffer');\nvar IsSharedArrayBuffer = require('es-abstract/2024/IsSharedArrayBuffer');\nvar max = require('es-abstract/2024/max');\nvar min = require('es-abstract/2024/min');\nvar SpeciesConstructor = require('es-abstract/2024/SpeciesConstructor');\nvar ToIntegerOrInfinity = require('es-abstract/2024/ToIntegerOrInfinity');\n\nvar arrayBufferByteLength = require('array-buffer-byte-length');\nvar isArrayBuffer = require('is-array-buffer');\nvar $TypeError = require('es-errors/type');\n\nmodule.exports = function slice(start, end) {\n\tvar O = this; // step 1\n\n\tif (!isArrayBuffer(O) || IsSharedArrayBuffer(O) || IsDetachedBuffer(O)) {\n\t\tthrow new $TypeError('receiver must be a non-detached, non-shared ArrayBuffer'); // steps 2-4\n\t}\n\n\tvar len = arrayBufferByteLength(O); // step 5\n\n\tvar relativeStart = ToIntegerOrInfinity(start); // step 6\n\n\tvar first;\n\tif (relativeStart === -Infinity) {\n\t\tfirst = 0; // step 7\n\t} else if (relativeStart < 0) {\n\t\tfirst = max(len + relativeStart, 0); // step 8\n\t} else {\n\t\tfirst = min(relativeStart, len); // step 9\n\t}\n\n\tvar relativeEnd = typeof end === 'undefined' ? len : ToIntegerOrInfinity(end); // step 10\n\n\tvar final;\n\tif (relativeEnd === -Infinity) {\n\t\tfinal = 0; // step 11\n\t} else if (relativeEnd < 0) {\n\t\tfinal = max(len + relativeEnd, 0); // step 12\n\t} else {\n\t\tfinal = min(relativeEnd, len); // step 13\n\t}\n\n\tvar newLen = max(final - first, 0); // step 14\n\n\tvar Ctor = SpeciesConstructor(O, $ArrayBuffer); // step 15\n\n\tvar new$ = new Ctor(newLen); // step 16\n\n\tif (!isArrayBuffer(new$) || IsSharedArrayBuffer(new$) || IsDetachedBuffer(new$)) {\n\t\tthrow new $TypeError('Species constructor must produce a non-detached, non-shared Array Buffer'); // steps 17-19\n\t}\n\n\tif (new$ === O) {\n\t\tthrow new $TypeError('new ArrayBuffer should not have been the same as the receiver'); // step 20\n\t}\n\n\tif (arrayBufferByteLength(new$) < newLen) {\n\t\tthrow new $TypeError('new ArrayBuffer\\'s byteLength must be at least the requested length'); // step 21\n\t}\n\n\tif (IsDetachedBuffer(O)) {\n\t\tthrow new $TypeError('receiver became an detached ArrayBuffer'); // step 23\n\t}\n\n\t/*\n\t24. Let fromBuf be O.[[ArrayBufferData]].\n\t25. Let toBuf be new.[[ArrayBufferData]].\n\t26. Perform CopyDataBlockBytes(toBuf, 0, fromBuf, first, newLen).\n\t*/\n\tvar sourceArr = new $Uint8Array(O);\n\tvar destArr = new $Uint8Array(new$);\n\tfor (var i = start, ii = 0; i < end; i++, ii++) {\n\t\tdestArr[ii] = sourceArr[i];\n\t}\n\n\treturn new$; // step 27\n};\n"
        }
    ]
}