{
    "sourceFile": "node_modules/arraybuffer.prototype.slice/test/tests.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892036864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nvar inspect = require('object-inspect');\nvar IsDetachedBuffer = require('es-abstract/2024/IsDetachedBuffer');\n\nvar forEach = require('for-each');\nvar v = require('es-value-fixtures');\n\nvar byteLength = require('array-buffer-byte-length');\n\nmodule.exports = function runTests(slice, t) {\n\tforEach(v.primitives.concat(v.objects), function (nonAB) {\n\t\tt['throws'](\n\t\t\tfunction () { slice(nonAB); },\n\t\t\tTypeError,\n\t\t\tinspect(nonAB) + ' is not an ArrayBuffer'\n\t\t);\n\t});\n\n\tt.test('ArrayBuffers', { skip: typeof ArrayBuffer === 'undefined' }, function (st) {\n\t\tvar ab = new ArrayBuffer(0);\n\n\t\tst.equal(IsDetachedBuffer(ab), false, 'ArrayBuffer is not detached');\n\n\t\ttry {\n\t\t\tvar nb = slice(ab);\n\t\t} catch (e) {\n\t\t\tif (e instanceof SyntaxError) {\n\t\t\t\tst.skip('Detaching ArrayBuffer is not supported');\n\t\t\t\treturn st.end();\n\t\t\t}\n\t\t\tconsole.log(e.stack);\n\t\t}\n\n\t\tst.notEqual(nb, ab, 'new ArrayBuffer is not the same as the original');\n\t\tst.equal(IsDetachedBuffer(ab), false, 'old ArrayBuffer is not detached');\n\t\tst.equal(IsDetachedBuffer(nb), false, 'new ArrayBuffer is not detached');\n\n\t\tvar ab2 = new ArrayBuffer(8);\n\t\tst.equal(byteLength(ab2), 8, 'original ArrayBuffer has length 8');\n\t\ttry {\n\t\t\tvar nbLen = slice(ab2, 4);\n\t\t} catch (e) {\n\t\t\tif (e instanceof SyntaxError) {\n\t\t\t\tst.skip('Detaching ArrayBuffer is not supported');\n\t\t\t\treturn st.end();\n\t\t\t}\n\t\t}\n\t\tst.equal(IsDetachedBuffer(ab2), false, 'old ArrayBuffer is not detached');\n\t\tst.equal(IsDetachedBuffer(nbLen), false, 'new ArrayBuffer is not detached');\n\n\t\tst.equal(byteLength(ab2), 8, 'original ArrayBuffer has length 8');\n\t\tst.equal(byteLength(nbLen), 4, 'newly sliced ArrayBuffer has length 4');\n\n\t\tvar one = new ArrayBuffer(1);\n\t\tvar arr = new Uint8Array(one);\n\t\tarr[0] = 123;\n\n\t\tvar two = slice(one);\n\n\t\tvar arr2 = new Uint8Array(two);\n\t\tarr2[0] = 234;\n\n\t\tst.deepEqual(arr, new Uint8Array([123]), 'original buffer is unchanged');\n\t\tst.deepEqual(arr2, new Uint8Array([234]), 'sliced buffer is changed');\n\n\t\treturn st.end();\n\t});\n\n\tt.test('SharedArrayBuffers', { skip: typeof SharedArrayBuffer === 'undefined' }, function (st) {\n\t\tvar sab = new SharedArrayBuffer(0);\n\n\t\tst['throws'](\n\t\t\tfunction () { slice(sab); },\n\t\t\tTypeError,\n\t\t\tinspect(sab) + ' is not an ArrayBuffer'\n\t\t);\n\n\t\tst.end();\n\t});\n};\n"
        }
    ]
}