{
    "sourceFile": "node_modules/@types/node/readline/promises.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @since v17.0.0\n * @experimental\n */\ndeclare module \"readline/promises\" {\n    import { Abortable } from \"node:events\";\n    import {\n        CompleterResult,\n        Direction,\n        Interface as _Interface,\n        ReadLineOptions as _ReadLineOptions,\n    } from \"node:readline\";\n    /**\n     * Instances of the `readlinePromises.Interface` class are constructed using the `readlinePromises.createInterface()` method. Every instance is associated with a\n     * single `input` `Readable` stream and a single `output` `Writable` stream.\n     * The `output` stream is used to print prompts for user input that arrives on,\n     * and is read from, the `input` stream.\n     * @since v17.0.0\n     */\n    class Interface extends _Interface {\n        /**\n         * The `rl.question()` method displays the `query` by writing it to the `output`,\n         * waits for user input to be provided on `input`, then invokes the `callback` function passing the provided input as the first argument.\n         *\n         * When called, `rl.question()` will resume the `input` stream if it has been\n         * paused.\n         *\n         * If the `Interface` was created with `output` set to `null` or `undefined` the `query` is not written.\n         *\n         * If the question is called after `rl.close()`, it returns a rejected promise.\n         *\n         * Example usage:\n         *\n         * ```js\n         * const answer = await rl.question('What is your favorite food? ');\n         * console.log(`Oh, so your favorite food is ${answer}`);\n         * ```\n         *\n         * Using an `AbortSignal` to cancel a question.\n         *\n         * ```js\n         * const signal = AbortSignal.timeout(10_000);\n         *\n         * signal.addEventListener('abort', () => {\n         *   console.log('The food question timed out');\n         * }, { once: true });\n         *\n         * const answer = await rl.question('What is your favorite food? ', { signal });\n         * console.log(`Oh, so your favorite food is ${answer}`);\n         * ```\n         * @since v17.0.0\n         * @param query A statement or query to write to `output`, prepended to the prompt.\n         * @return A promise that is fulfilled with the user's input in response to the `query`.\n         */\n        question(query: string): Promise<string>;\n        question(query: string, options: Abortable): Promise<string>;\n    }\n    /**\n     * @since v17.0.0\n     */\n    class Readline {\n        /**\n         * @param stream A TTY stream.\n         */\n        constructor(\n            stream: NodeJS.WritableStream,\n            options?: {\n                autoCommit?: boolean;\n            },\n        );\n        /**\n         * The `rl.clearLine()` method adds to the internal list of pending action an\n         * action that clears current line of the associated `stream` in a specified\n         * direction identified by `dir`.\n         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.\n         * @since v17.0.0\n         * @return this\n         */\n        clearLine(dir: Direction): this;\n        /**\n         * The `rl.clearScreenDown()` method adds to the internal list of pending action an\n         * action that clears the associated stream from the current position of the\n         * cursor down.\n         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.\n         * @since v17.0.0\n         * @return this\n         */\n        clearScreenDown(): this;\n        /**\n         * The `rl.commit()` method sends all the pending actions to the associated `stream` and clears the internal list of pending actions.\n         * @since v17.0.0\n         */\n        commit(): Promise<void>;\n        /**\n         * The `rl.cursorTo()` method adds to the internal list of pending action an action\n         * that moves cursor to the specified position in the associated `stream`.\n         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.\n         * @since v17.0.0\n         * @return this\n         */\n        cursorTo(x: number, y?: number): this;\n        /**\n         * The `rl.moveCursor()` method adds to the internal list of pending action an\n         * action that moves the cursor _relative_ to its current position in the\n         * associated `stream`.\n         * Call `rl.commit()` to see the effect of this method, unless `autoCommit: true` was passed to the constructor.\n         * @since v17.0.0\n         * @return this\n         */\n        moveCursor(dx: number, dy: number): this;\n        /**\n         * The `rl.rollback` methods clears the internal list of pending actions without\n         * sending it to the associated `stream`.\n         * @since v17.0.0\n         * @return this\n         */\n        rollback(): this;\n    }\n    type Completer = (line: string) => CompleterResult | Promise<CompleterResult>;\n    interface ReadLineOptions extends Omit<_ReadLineOptions, \"completer\"> {\n        /**\n         * An optional function used for Tab autocompletion.\n         */\n        completer?: Completer | undefined;\n    }\n    /**\n     * The `readlinePromises.createInterface()` method creates a new `readlinePromises.Interface` instance.\n     *\n     * ```js\n     * import readlinePromises from 'node:readline/promises';\n     * const rl = readlinePromises.createInterface({\n     *   input: process.stdin,\n     *   output: process.stdout,\n     * });\n     * ```\n     *\n     * Once the `readlinePromises.Interface` instance is created, the most common case\n     * is to listen for the `'line'` event:\n     *\n     * ```js\n     * rl.on('line', (line) => {\n     *   console.log(`Received: ${line}`);\n     * });\n     * ```\n     *\n     * If `terminal` is `true` for this instance then the `output` stream will get\n     * the best compatibility if it defines an `output.columns` property and emits\n     * a `'resize'` event on the `output` if or when the columns ever change\n     * (`process.stdout` does this automatically when it is a TTY).\n     * @since v17.0.0\n     */\n    function createInterface(\n        input: NodeJS.ReadableStream,\n        output?: NodeJS.WritableStream,\n        completer?: Completer,\n        terminal?: boolean,\n    ): Interface;\n    function createInterface(options: ReadLineOptions): Interface;\n}\ndeclare module \"node:readline/promises\" {\n    export * from \"readline/promises\";\n}\n"
        }
    ]
}