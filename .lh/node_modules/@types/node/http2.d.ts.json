{
    "sourceFile": "node_modules/@types/node/http2.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.\n * It can be accessed using:\n *\n * ```js\n * import http2 from 'node:http2';\n * ```\n * @since v8.4.0\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/http2.js)\n */\ndeclare module \"http2\" {\n    import EventEmitter = require(\"node:events\");\n    import * as fs from \"node:fs\";\n    import * as net from \"node:net\";\n    import * as stream from \"node:stream\";\n    import * as tls from \"node:tls\";\n    import * as url from \"node:url\";\n    import {\n        IncomingHttpHeaders as Http1IncomingHttpHeaders,\n        IncomingMessage,\n        OutgoingHttpHeaders,\n        ServerResponse,\n    } from \"node:http\";\n    export { OutgoingHttpHeaders } from \"node:http\";\n    export interface IncomingHttpStatusHeader {\n        \":status\"?: number | undefined;\n    }\n    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {\n        \":path\"?: string | undefined;\n        \":method\"?: string | undefined;\n        \":authority\"?: string | undefined;\n        \":scheme\"?: string | undefined;\n    }\n    // Http2Stream\n    export interface StreamPriorityOptions {\n        exclusive?: boolean | undefined;\n        parent?: number | undefined;\n        weight?: number | undefined;\n        silent?: boolean | undefined;\n    }\n    export interface StreamState {\n        localWindowSize?: number | undefined;\n        state?: number | undefined;\n        localClose?: number | undefined;\n        remoteClose?: number | undefined;\n        sumDependencyWeight?: number | undefined;\n        weight?: number | undefined;\n    }\n    export interface ServerStreamResponseOptions {\n        endStream?: boolean | undefined;\n        waitForTrailers?: boolean | undefined;\n    }\n    export interface StatOptions {\n        offset: number;\n        length: number;\n    }\n    export interface ServerStreamFileResponseOptions {\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;\n        waitForTrailers?: boolean | undefined;\n        offset?: number | undefined;\n        length?: number | undefined;\n    }\n    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {\n        onError?(err: NodeJS.ErrnoException): void;\n    }\n    export interface Http2Stream extends stream.Duplex {\n        /**\n         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,\n         * the `'aborted'` event will have been emitted.\n         * @since v8.4.0\n         */\n        readonly aborted: boolean;\n        /**\n         * This property shows the number of characters currently buffered to be written.\n         * See `net.Socket.bufferSize` for details.\n         * @since v11.2.0, v10.16.0\n         */\n        readonly bufferSize: number;\n        /**\n         * Set to `true` if the `Http2Stream` instance has been closed.\n         * @since v9.4.0\n         */\n        readonly closed: boolean;\n        /**\n         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer\n         * usable.\n         * @since v8.4.0\n         */\n        readonly destroyed: boolean;\n        /**\n         * Set to `true` if the `END_STREAM` flag was set in the request or response\n         * HEADERS frame received, indicating that no additional data should be received\n         * and the readable side of the `Http2Stream` will be closed.\n         * @since v10.11.0\n         */\n        readonly endAfterHeaders: boolean;\n        /**\n         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.\n         * @since v8.4.0\n         */\n        readonly id?: number | undefined;\n        /**\n         * Set to `true` if the `Http2Stream` instance has not yet been assigned a\n         * numeric stream identifier.\n         * @since v9.4.0\n         */\n        readonly pending: boolean;\n        /**\n         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is\n         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,\n         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.\n         * @since v8.4.0\n         */\n        readonly rstCode: number;\n        /**\n         * An object containing the outbound headers sent for this `Http2Stream`.\n         * @since v9.5.0\n         */\n        readonly sentHeaders: OutgoingHttpHeaders;\n        /**\n         * An array of objects containing the outbound informational (additional) headers\n         * sent for this `Http2Stream`.\n         * @since v9.5.0\n         */\n        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;\n        /**\n         * An object containing the outbound trailers sent for this `HttpStream`.\n         * @since v9.5.0\n         */\n        readonly sentTrailers?: OutgoingHttpHeaders | undefined;\n        /**\n         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The\n         * value will be `undefined` after the `Http2Stream` instance is destroyed.\n         * @since v8.4.0\n         */\n        readonly session: Http2Session | undefined;\n        /**\n         * Provides miscellaneous information about the current state of the `Http2Stream`.\n         *\n         * A current state of this `Http2Stream`.\n         * @since v8.4.0\n         */\n        readonly state: StreamState;\n        /**\n         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the\n         * connected HTTP/2 peer.\n         * @since v8.4.0\n         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.\n         * @param callback An optional function registered to listen for the `'close'` event.\n         */\n        close(code?: number, callback?: () => void): void;\n        /**\n         * Updates the priority for this `Http2Stream` instance.\n         * @since v8.4.0\n         */\n        priority(options: StreamPriorityOptions): void;\n        /**\n         * ```js\n         * import http2 from 'node:http2';\n         * const client = http2.connect('http://example.org:8000');\n         * const { NGHTTP2_CANCEL } = http2.constants;\n         * const req = client.request({ ':path': '/' });\n         *\n         * // Cancel the stream if there's no activity after 5 seconds\n         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));\n         * ```\n         * @since v8.4.0\n         */\n        setTimeout(msecs: number, callback?: () => void): void;\n        /**\n         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method\n         * will cause the `Http2Stream` to be immediately closed and must only be\n         * called after the `'wantTrailers'` event has been emitted. When sending a\n         * request or sending a response, the `options.waitForTrailers` option must be set\n         * in order to keep the `Http2Stream` open after the final `DATA` frame so that\n         * trailers can be sent.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   stream.respond(undefined, { waitForTrailers: true });\n         *   stream.on('wantTrailers', () => {\n         *     stream.sendTrailers({ xyz: 'abc' });\n         *   });\n         *   stream.end('Hello World');\n         * });\n         * ```\n         *\n         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header\n         * fields (e.g. `':method'`, `':path'`, etc).\n         * @since v10.0.0\n         */\n        sendTrailers(headers: OutgoingHttpHeaders): void;\n        addListener(event: \"aborted\", listener: () => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(event: \"wantTrailers\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"aborted\"): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"data\", chunk: Buffer | string): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"finish\"): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number): boolean;\n        emit(event: \"pipe\", src: stream.Readable): boolean;\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\n        emit(event: \"streamClosed\", code: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"trailers\", trailers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"wantTrailers\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"aborted\", listener: () => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"streamClosed\", listener: (code: number) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        on(event: \"wantTrailers\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: () => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"streamClosed\", listener: (code: number) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        once(event: \"wantTrailers\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: () => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(event: \"wantTrailers\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: () => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"frameError\", listener: (frameType: number, errorCode: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"streamClosed\", listener: (code: number) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"trailers\", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(event: \"wantTrailers\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    export interface ClientHttp2Stream extends Http2Stream {\n        addListener(event: \"continue\", listener: () => {}): this;\n        addListener(\n            event: \"headers\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        addListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        addListener(\n            event: \"response\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"continue\"): boolean;\n        emit(event: \"headers\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: \"push\", headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"response\", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"continue\", listener: () => {}): this;\n        on(\n            event: \"headers\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        on(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        on(\n            event: \"response\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"continue\", listener: () => {}): this;\n        once(\n            event: \"headers\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        once(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        once(\n            event: \"response\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"continue\", listener: () => {}): this;\n        prependListener(\n            event: \"headers\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        prependListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependListener(\n            event: \"response\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"continue\", listener: () => {}): this;\n        prependOnceListener(\n            event: \"headers\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        prependOnceListener(event: \"push\", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;\n        prependOnceListener(\n            event: \"response\",\n            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,\n        ): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    export interface ServerHttp2Stream extends Http2Stream {\n        /**\n         * True if headers were sent, false otherwise (read-only).\n         * @since v8.4.0\n         */\n        readonly headersSent: boolean;\n        /**\n         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote\n         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer\n         * accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.\n         * @since v8.4.0\n         */\n        readonly pushAllowed: boolean;\n        /**\n         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.\n         * @since v8.4.0\n         */\n        additionalHeaders(headers: OutgoingHttpHeaders): void;\n        /**\n         * Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   stream.respond({ ':status': 200 });\n         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {\n         *     if (err) throw err;\n         *     pushStream.respond({ ':status': 200 });\n         *     pushStream.end('some pushed data');\n         *   });\n         *   stream.end('some data');\n         * });\n         * ```\n         *\n         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass\n         * a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.\n         *\n         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted\n         * and will throw an error.\n         * @since v8.4.0\n         * @param callback Callback that is called once the push stream has been initiated.\n         */\n        pushStream(\n            headers: OutgoingHttpHeaders,\n            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,\n        ): void;\n        pushStream(\n            headers: OutgoingHttpHeaders,\n            options?: StreamPriorityOptions,\n            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,\n        ): void;\n        /**\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   stream.respond({ ':status': 200 });\n         *   stream.end('some data');\n         * });\n         * ```\n         *\n         * Initiates a response. When the `options.waitForTrailers` option is set, the `'wantTrailers'` event\n         * will be emitted immediately after queuing the last chunk of payload data to be sent.\n         * The `http2stream.sendTrailers()` method can then be used to send trailing header fields to the peer.\n         *\n         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically\n         * close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });\n         *   stream.on('wantTrailers', () => {\n         *     stream.sendTrailers({ ABC: 'some value to send' });\n         *   });\n         *   stream.end('some data');\n         * });\n         * ```\n         * @since v8.4.0\n         */\n        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;\n        /**\n         * Initiates a response whose data is read from the given file descriptor. No\n         * validation is performed on the given file descriptor. If an error occurs while\n         * attempting to read data using the file descriptor, the `Http2Stream` will be\n         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.\n         *\n         * When used, the `Http2Stream` object's `Duplex` interface will be closed\n         * automatically.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * import fs from 'node:fs';\n         *\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   const fd = fs.openSync('/some/file', 'r');\n         *\n         *   const stat = fs.fstatSync(fd);\n         *   const headers = {\n         *     'content-length': stat.size,\n         *     'last-modified': stat.mtime.toUTCString(),\n         *     'content-type': 'text/plain; charset=utf-8',\n         *   };\n         *   stream.respondWithFD(fd, headers);\n         *   stream.on('close', () => fs.closeSync(fd));\n         * });\n         * ```\n         *\n         * The optional `options.statCheck` function may be specified to give user code\n         * an opportunity to set additional content headers based on the `fs.Stat` details\n         * of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will\n         * perform an `fs.fstat()` call to collect details on the provided file descriptor.\n         *\n         * The `offset` and `length` options may be used to limit the response to a\n         * specific range subset. This can be used, for instance, to support HTTP Range\n         * requests.\n         *\n         * The file descriptor or `FileHandle` is not closed when the stream is closed,\n         * so it will need to be closed manually once it is no longer needed.\n         * Using the same file descriptor concurrently for multiple streams\n         * is not supported and may result in data loss. Re-using a file descriptor\n         * after a stream has finished is supported.\n         *\n         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event\n         * will be emitted immediately after queuing the last chunk of payload data to be\n         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing\n         * header fields to the peer.\n         *\n         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically\n         * close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()`\n         * or `http2stream.close()` to close the `Http2Stream`.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * import fs from 'node:fs';\n         *\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   const fd = fs.openSync('/some/file', 'r');\n         *\n         *   const stat = fs.fstatSync(fd);\n         *   const headers = {\n         *     'content-length': stat.size,\n         *     'last-modified': stat.mtime.toUTCString(),\n         *     'content-type': 'text/plain; charset=utf-8',\n         *   };\n         *   stream.respondWithFD(fd, headers, { waitForTrailers: true });\n         *   stream.on('wantTrailers', () => {\n         *     stream.sendTrailers({ ABC: 'some value to send' });\n         *   });\n         *\n         *   stream.on('close', () => fs.closeSync(fd));\n         * });\n         * ```\n         * @since v8.4.0\n         * @param fd A readable file descriptor.\n         */\n        respondWithFD(\n            fd: number | fs.promises.FileHandle,\n            headers?: OutgoingHttpHeaders,\n            options?: ServerStreamFileResponseOptions,\n        ): void;\n        /**\n         * Sends a regular file as the response. The `path` must specify a regular file\n         * or an `'error'` event will be emitted on the `Http2Stream` object.\n         *\n         * When used, the `Http2Stream` object's `Duplex` interface will be closed\n         * automatically.\n         *\n         * The optional `options.statCheck` function may be specified to give user code\n         * an opportunity to set additional content headers based on the `fs.Stat` details\n         * of the given file:\n         *\n         * If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an\n         * `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.\n         * If the `onError` callback is defined, then it will be called. Otherwise, the stream will be destroyed.\n         *\n         * Example using a file path:\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   function statCheck(stat, headers) {\n         *     headers['last-modified'] = stat.mtime.toUTCString();\n         *   }\n         *\n         *   function onError(err) {\n         *     // stream.respond() can throw if the stream has been destroyed by\n         *     // the other side.\n         *     try {\n         *       if (err.code === 'ENOENT') {\n         *         stream.respond({ ':status': 404 });\n         *       } else {\n         *         stream.respond({ ':status': 500 });\n         *       }\n         *     } catch (err) {\n         *       // Perform actual error handling.\n         *       console.error(err);\n         *     }\n         *     stream.end();\n         *   }\n         *\n         *   stream.respondWithFile('/some/file',\n         *                          { 'content-type': 'text/plain; charset=utf-8' },\n         *                          { statCheck, onError });\n         * });\n         * ```\n         *\n         * The `options.statCheck` function may also be used to cancel the send operation\n         * by returning `false`. For instance, a conditional request may check the stat\n         * results to determine if the file has been modified to return an appropriate `304` response:\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   function statCheck(stat, headers) {\n         *     // Check the stat here...\n         *     stream.respond({ ':status': 304 });\n         *     return false; // Cancel the send operation\n         *   }\n         *   stream.respondWithFile('/some/file',\n         *                          { 'content-type': 'text/plain; charset=utf-8' },\n         *                          { statCheck });\n         * });\n         * ```\n         *\n         * The `content-length` header field will be automatically set.\n         *\n         * The `offset` and `length` options may be used to limit the response to a\n         * specific range subset. This can be used, for instance, to support HTTP Range\n         * requests.\n         *\n         * The `options.onError` function may also be used to handle all the errors\n         * that could happen before the delivery of the file is initiated. The\n         * default behavior is to destroy the stream.\n         *\n         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event\n         * will be emitted immediately after queuing the last chunk of payload data to be\n         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing\n         * header fields to the peer.\n         *\n         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically\n         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer();\n         * server.on('stream', (stream) => {\n         *   stream.respondWithFile('/some/file',\n         *                          { 'content-type': 'text/plain; charset=utf-8' },\n         *                          { waitForTrailers: true });\n         *   stream.on('wantTrailers', () => {\n         *     stream.sendTrailers({ ABC: 'some value to send' });\n         *   });\n         * });\n         * ```\n         * @since v8.4.0\n         */\n        respondWithFile(\n            path: string,\n            headers?: OutgoingHttpHeaders,\n            options?: ServerStreamFileResponseOptionsWithError,\n        ): void;\n    }\n    // Http2Session\n    export interface Settings {\n        headerTableSize?: number | undefined;\n        enablePush?: boolean | undefined;\n        initialWindowSize?: number | undefined;\n        maxFrameSize?: number | undefined;\n        maxConcurrentStreams?: number | undefined;\n        maxHeaderListSize?: number | undefined;\n        enableConnectProtocol?: boolean | undefined;\n    }\n    export interface ClientSessionRequestOptions {\n        endStream?: boolean | undefined;\n        exclusive?: boolean | undefined;\n        parent?: number | undefined;\n        weight?: number | undefined;\n        waitForTrailers?: boolean | undefined;\n        signal?: AbortSignal | undefined;\n    }\n    export interface SessionState {\n        effectiveLocalWindowSize?: number | undefined;\n        effectiveRecvDataLength?: number | undefined;\n        nextStreamID?: number | undefined;\n        localWindowSize?: number | undefined;\n        lastProcStreamID?: number | undefined;\n        remoteWindowSize?: number | undefined;\n        outboundQueueSize?: number | undefined;\n        deflateDynamicTableSize?: number | undefined;\n        inflateDynamicTableSize?: number | undefined;\n    }\n    export interface Http2Session extends EventEmitter {\n        /**\n         * Value will be `undefined` if the `Http2Session` is not yet connected to a\n         * socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or\n         * will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.\n         * @since v9.4.0\n         */\n        readonly alpnProtocol?: string | undefined;\n        /**\n         * Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.\n         * @since v9.4.0\n         */\n        readonly closed: boolean;\n        /**\n         * Will be `true` if this `Http2Session` instance is still connecting, will be set\n         * to `false` before emitting `connect` event and/or calling the `http2.connect` callback.\n         * @since v10.0.0\n         */\n        readonly connecting: boolean;\n        /**\n         * Will be `true` if this `Http2Session` instance has been destroyed and must no\n         * longer be used, otherwise `false`.\n         * @since v8.4.0\n         */\n        readonly destroyed: boolean;\n        /**\n         * Value is `undefined` if the `Http2Session` session socket has not yet been\n         * connected, `true` if the `Http2Session` is connected with a `TLSSocket`,\n         * and `false` if the `Http2Session` is connected to any other kind of socket\n         * or stream.\n         * @since v9.4.0\n         */\n        readonly encrypted?: boolean | undefined;\n        /**\n         * A prototype-less object describing the current local settings of this `Http2Session`.\n         * The local settings are local to _this_`Http2Session` instance.\n         * @since v8.4.0\n         */\n        readonly localSettings: Settings;\n        /**\n         * If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property\n         * will return an `Array` of origins for which the `Http2Session` may be\n         * considered authoritative.\n         *\n         * The `originSet` property is only available when using a secure TLS connection.\n         * @since v9.4.0\n         */\n        readonly originSet?: string[] | undefined;\n        /**\n         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of\n         * a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method.\n         * Will be `false` once all sent `SETTINGS` frames have been acknowledged.\n         * @since v8.4.0\n         */\n        readonly pendingSettingsAck: boolean;\n        /**\n         * A prototype-less object describing the current remote settings of this`Http2Session`.\n         * The remote settings are set by the _connected_ HTTP/2 peer.\n         * @since v8.4.0\n         */\n        readonly remoteSettings: Settings;\n        /**\n         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but\n         * limits available methods to ones safe to use with HTTP/2.\n         *\n         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw\n         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.\n         *\n         * `setTimeout` method will be called on this `Http2Session`.\n         *\n         * All other interactions will be routed directly to the socket.\n         * @since v8.4.0\n         */\n        readonly socket: net.Socket | tls.TLSSocket;\n        /**\n         * Provides miscellaneous information about the current state of the`Http2Session`.\n         *\n         * An object describing the current status of this `Http2Session`.\n         * @since v8.4.0\n         */\n        readonly state: SessionState;\n        /**\n         * The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a\n         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a\n         * client.\n         * @since v8.4.0\n         */\n        readonly type: number;\n        /**\n         * Gracefully closes the `Http2Session`, allowing any existing streams to\n         * complete on their own and preventing new `Http2Stream` instances from being\n         * created. Once closed, `http2session.destroy()`_might_ be called if there\n         * are no open `Http2Stream` instances.\n         *\n         * If specified, the `callback` function is registered as a handler for the`'close'` event.\n         * @since v9.4.0\n         */\n        close(callback?: () => void): void;\n        /**\n         * Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.\n         *\n         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.\n         *\n         * If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.\n         * @since v8.4.0\n         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.\n         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.\n         */\n        destroy(error?: Error, code?: number): void;\n        /**\n         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.\n         * @since v9.4.0\n         * @param code An HTTP/2 error code\n         * @param lastStreamID The numeric ID of the last processed `Http2Stream`\n         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.\n         */\n        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;\n        /**\n         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must\n         * be provided. The method will return `true` if the `PING` was sent, `false` otherwise.\n         *\n         * The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.\n         *\n         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and\n         * returned with the ping acknowledgment.\n         *\n         * The callback will be invoked with three arguments: an error argument that will\n         * be `null` if the `PING` was successfully acknowledged, a `duration` argument\n         * that reports the number of milliseconds elapsed since the ping was sent and the\n         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.\n         *\n         * ```js\n         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {\n         *   if (!err) {\n         *     console.log(`Ping acknowledged in ${duration} milliseconds`);\n         *     console.log(`With payload '${payload.toString()}'`);\n         *   }\n         * });\n         * ```\n         *\n         * If the `payload` argument is not specified, the default payload will be the\n         * 64-bit timestamp (little endian) marking the start of the `PING` duration.\n         * @since v8.9.3\n         * @param payload Optional ping payload.\n         */\n        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;\n        ping(\n            payload: NodeJS.ArrayBufferView,\n            callback: (err: Error | null, duration: number, payload: Buffer) => void,\n        ): boolean;\n        /**\n         * Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.\n         * @since v9.4.0\n         */\n        ref(): void;\n        /**\n         * Sets the local endpoint's window size.\n         * The `windowSize` is the total window size to set, not\n         * the delta.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         *\n         * const server = http2.createServer();\n         * const expectedWindowSize = 2 ** 20;\n         * server.on('connect', (session) => {\n         *\n         *   // Set local window size to be 2 ** 20\n         *   session.setLocalWindowSize(expectedWindowSize);\n         * });\n         * ```\n         * @since v15.3.0, v14.18.0\n         */\n        setLocalWindowSize(windowSize: number): void;\n        /**\n         * Used to set a callback function that is called when there is no activity on\n         * the `Http2Session` after `msecs` milliseconds. The given `callback` is\n         * registered as a listener on the `'timeout'` event.\n         * @since v8.4.0\n         */\n        setTimeout(msecs: number, callback?: () => void): void;\n        /**\n         * Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.\n         *\n         * Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new\n         * settings.\n         *\n         * The new settings will not become effective until the `SETTINGS` acknowledgment\n         * is received and the `'localSettings'` event is emitted. It is possible to send\n         * multiple `SETTINGS` frames while acknowledgment is still pending.\n         * @since v8.4.0\n         * @param callback Callback that is called once the session is connected or right away if the session is already connected.\n         */\n        settings(\n            settings: Settings,\n            callback?: (err: Error | null, settings: Settings, duration: number) => void,\n        ): void;\n        /**\n         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.\n         * @since v9.4.0\n         */\n        unref(): void;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(\n            event: \"frameError\",\n            listener: (frameType: number, errorCode: number, streamID: number) => void,\n        ): this;\n        addListener(\n            event: \"goaway\",\n            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,\n        ): this;\n        addListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"ping\", listener: () => void): this;\n        addListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"close\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"frameError\", frameType: number, errorCode: number, streamID: number): boolean;\n        emit(event: \"goaway\", errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;\n        emit(event: \"localSettings\", settings: Settings): boolean;\n        emit(event: \"ping\"): boolean;\n        emit(event: \"remoteSettings\", settings: Settings): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        on(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;\n        on(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"ping\", listener: () => void): this;\n        on(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"frameError\", listener: (frameType: number, errorCode: number, streamID: number) => void): this;\n        once(event: \"goaway\", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;\n        once(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"ping\", listener: () => void): this;\n        once(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(\n            event: \"frameError\",\n            listener: (frameType: number, errorCode: number, streamID: number) => void,\n        ): this;\n        prependListener(\n            event: \"goaway\",\n            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,\n        ): this;\n        prependListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"ping\", listener: () => void): this;\n        prependListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(\n            event: \"frameError\",\n            listener: (frameType: number, errorCode: number, streamID: number) => void,\n        ): this;\n        prependOnceListener(\n            event: \"goaway\",\n            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,\n        ): this;\n        prependOnceListener(event: \"localSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"ping\", listener: () => void): this;\n        prependOnceListener(event: \"remoteSettings\", listener: (settings: Settings) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    export interface ClientHttp2Session extends Http2Session {\n        /**\n         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an\n         * HTTP/2 request to the connected server.\n         *\n         * When a `ClientHttp2Session` is first created, the socket may not yet be\n         * connected. if `clienthttp2session.request()` is called during this time, the\n         * actual request will be deferred until the socket is ready to go.\n         * If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.\n         *\n         * This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const clientSession = http2.connect('https://localhost:1234');\n         * const {\n         *   HTTP2_HEADER_PATH,\n         *   HTTP2_HEADER_STATUS,\n         * } = http2.constants;\n         *\n         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });\n         * req.on('response', (headers) => {\n         *   console.log(headers[HTTP2_HEADER_STATUS]);\n         *   req.on('data', (chunk) => { // ..  });\n         *   req.on('end', () => { // ..  });\n         * });\n         * ```\n         *\n         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event\n         * is emitted immediately after queuing the last chunk of payload data to be sent.\n         * The `http2stream.sendTrailers()` method can then be called to send trailing\n         * headers to the peer.\n         *\n         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically\n         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.\n         *\n         * When `options.signal` is set with an `AbortSignal` and then `abort` on the\n         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.\n         *\n         * The `:method` and `:path` pseudo-headers are not specified within `headers`,\n         * they respectively default to:\n         *\n         * * `:method` \\= `'GET'`\n         * * `:path` \\= `/`\n         * @since v8.4.0\n         */\n        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;\n        addListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        addListener(event: \"origin\", listener: (origins: string[]) => void): this;\n        addListener(\n            event: \"connect\",\n            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n        ): this;\n        addListener(\n            event: \"stream\",\n            listener: (\n                stream: ClientHttp2Stream,\n                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,\n                flags: number,\n            ) => void,\n        ): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"altsvc\", alt: string, origin: string, stream: number): boolean;\n        emit(event: \"origin\", origins: readonly string[]): boolean;\n        emit(event: \"connect\", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;\n        emit(\n            event: \"stream\",\n            stream: ClientHttp2Stream,\n            headers: IncomingHttpHeaders & IncomingHttpStatusHeader,\n            flags: number,\n        ): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        on(event: \"origin\", listener: (origins: string[]) => void): this;\n        on(event: \"connect\", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;\n        on(\n            event: \"stream\",\n            listener: (\n                stream: ClientHttp2Stream,\n                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,\n                flags: number,\n            ) => void,\n        ): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        once(event: \"origin\", listener: (origins: string[]) => void): this;\n        once(\n            event: \"connect\",\n            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n        ): this;\n        once(\n            event: \"stream\",\n            listener: (\n                stream: ClientHttp2Stream,\n                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,\n                flags: number,\n            ) => void,\n        ): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependListener(event: \"origin\", listener: (origins: string[]) => void): this;\n        prependListener(\n            event: \"connect\",\n            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n        ): this;\n        prependListener(\n            event: \"stream\",\n            listener: (\n                stream: ClientHttp2Stream,\n                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,\n                flags: number,\n            ) => void,\n        ): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"altsvc\", listener: (alt: string, origin: string, stream: number) => void): this;\n        prependOnceListener(event: \"origin\", listener: (origins: string[]) => void): this;\n        prependOnceListener(\n            event: \"connect\",\n            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n        ): this;\n        prependOnceListener(\n            event: \"stream\",\n            listener: (\n                stream: ClientHttp2Stream,\n                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,\n                flags: number,\n            ) => void,\n        ): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    export interface AlternativeServiceOptions {\n        origin: number | string | url.URL;\n    }\n    export interface ServerHttp2Session<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends Http2Session {\n        readonly server:\n            | Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>\n            | Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;\n        /**\n         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         *\n         * const server = http2.createServer();\n         * server.on('session', (session) => {\n         *   // Set altsvc for origin https://example.org:80\n         *   session.altsvc('h2=\":8000\"', 'https://example.org:80');\n         * });\n         *\n         * server.on('stream', (stream) => {\n         *   // Set altsvc for a specific stream\n         *   stream.session.altsvc('h2=\":8000\"', stream.id);\n         * });\n         * ```\n         *\n         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate\n         * service is associated with the origin of the given `Http2Stream`.\n         *\n         * The `alt` and origin string _must_ contain only ASCII bytes and are\n         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given\n         * domain.\n         *\n         * When a string is passed for the `originOrStream` argument, it will be parsed as\n         * a URL and the origin will be derived. For instance, the origin for the\n         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string\n         * cannot be parsed as a URL or if a valid origin cannot be derived.\n         *\n         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be\n         * used. The value of the `origin` property _must_ be a properly serialized\n         * ASCII origin.\n         * @since v9.4.0\n         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.\n         * @param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the\n         * `http2stream.id` property.\n         */\n        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;\n        /**\n         * Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client\n         * to advertise the set of origins for which the server is capable of providing\n         * authoritative responses.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const options = getSecureOptionsSomehow();\n         * const server = http2.createSecureServer(options);\n         * server.on('stream', (stream) => {\n         *   stream.respond();\n         *   stream.end('ok');\n         * });\n         * server.on('session', (session) => {\n         *   session.origin('https://example.com', 'https://example.org');\n         * });\n         * ```\n         *\n         * When a string is passed as an `origin`, it will be parsed as a URL and the\n         * origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given\n         * string\n         * cannot be parsed as a URL or if a valid origin cannot be derived.\n         *\n         * A `URL` object, or any object with an `origin` property, may be passed as\n         * an `origin`, in which case the value of the `origin` property will be\n         * used. The value of the `origin` property _must_ be a properly serialized\n         * ASCII origin.\n         *\n         * Alternatively, the `origins` option may be used when creating a new HTTP/2\n         * server using the `http2.createSecureServer()` method:\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const options = getSecureOptionsSomehow();\n         * options.origins = ['https://example.com', 'https://example.org'];\n         * const server = http2.createSecureServer(options);\n         * server.on('stream', (stream) => {\n         *   stream.respond();\n         *   stream.end('ok');\n         * });\n         * ```\n         * @since v10.12.0\n         * @param origins One or more URL Strings passed as separate arguments.\n         */\n        origin(\n            ...origins: Array<\n                | string\n                | url.URL\n                | {\n                    origin: string;\n                }\n            >\n        ): void;\n        addListener(\n            event: \"connect\",\n            listener: (\n                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n                socket: net.Socket | tls.TLSSocket,\n            ) => void,\n        ): this;\n        addListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(\n            event: \"connect\",\n            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n            socket: net.Socket | tls.TLSSocket,\n        ): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(\n            event: \"connect\",\n            listener: (\n                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n                socket: net.Socket | tls.TLSSocket,\n            ) => void,\n        ): this;\n        on(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(\n            event: \"connect\",\n            listener: (\n                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n                socket: net.Socket | tls.TLSSocket,\n            ) => void,\n        ): this;\n        once(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(\n            event: \"connect\",\n            listener: (\n                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n                socket: net.Socket | tls.TLSSocket,\n            ) => void,\n        ): this;\n        prependListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(\n            event: \"connect\",\n            listener: (\n                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n                socket: net.Socket | tls.TLSSocket,\n            ) => void,\n        ): this;\n        prependOnceListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    // Http2Server\n    export interface SessionOptions {\n        maxDeflateDynamicTableSize?: number | undefined;\n        maxSessionMemory?: number | undefined;\n        maxHeaderListPairs?: number | undefined;\n        maxOutstandingPings?: number | undefined;\n        maxSendHeaderBlockLength?: number | undefined;\n        paddingStrategy?: number | undefined;\n        peerMaxConcurrentStreams?: number | undefined;\n        settings?: Settings | undefined;\n        remoteCustomSettings?: number[] | undefined;\n        /**\n         * Specifies a timeout in milliseconds that\n         * a server should wait when an [`'unknownProtocol'`][] is emitted. If the\n         * socket has not been destroyed by that time the server will destroy it.\n         * @default 100000\n         */\n        unknownProtocolTimeout?: number | undefined;\n        selectPadding?(frameLen: number, maxFrameLen: number): number;\n    }\n    export interface ClientSessionOptions extends SessionOptions {\n        maxReservedRemoteStreams?: number | undefined;\n        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;\n        protocol?: \"http:\" | \"https:\" | undefined;\n    }\n    export interface ServerSessionOptions<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends SessionOptions {\n        streamResetBurst?: number | undefined;\n        streamResetRate?: number | undefined;\n        Http1IncomingMessage?: Http1Request | undefined;\n        Http1ServerResponse?: Http1Response | undefined;\n        Http2ServerRequest?: Http2Request | undefined;\n        Http2ServerResponse?: Http2Response | undefined;\n    }\n    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}\n    export interface SecureServerSessionOptions<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>, tls.TlsOptions {}\n    export interface ServerOptions<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {}\n    export interface SecureServerOptions<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {\n        allowHTTP1?: boolean | undefined;\n        origins?: string[] | undefined;\n    }\n    interface HTTP2ServerCommon {\n        setTimeout(msec?: number, callback?: () => void): this;\n        /**\n         * Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.\n         * Throws ERR_INVALID_ARG_TYPE for invalid settings argument.\n         */\n        updateSettings(settings: Settings): void;\n    }\n    export interface Http2Server<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends net.Server, HTTP2ServerCommon {\n        addListener(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        addListener(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        addListener(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(\n            event: \"checkContinue\",\n            request: InstanceType<Http2Request>,\n            response: InstanceType<Http2Response>,\n        ): boolean;\n        emit(event: \"request\", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;\n        emit(\n            event: \"session\",\n            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n        ): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        on(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        on(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        once(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        once(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependListener(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependListener(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependOnceListener(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependOnceListener(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    export interface Http2SecureServer<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    > extends tls.Server, HTTP2ServerCommon {\n        addListener(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        addListener(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        addListener(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        addListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        addListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(\n            event: \"checkContinue\",\n            request: InstanceType<Http2Request>,\n            response: InstanceType<Http2Response>,\n        ): boolean;\n        emit(event: \"request\", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;\n        emit(\n            event: \"session\",\n            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,\n        ): boolean;\n        emit(event: \"sessionError\", err: Error): boolean;\n        emit(event: \"stream\", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;\n        emit(event: \"timeout\"): boolean;\n        emit(event: \"unknownProtocol\", socket: tls.TLSSocket): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        on(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        on(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        on(event: \"sessionError\", listener: (err: Error) => void): this;\n        on(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        once(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        once(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        once(event: \"sessionError\", listener: (err: Error) => void): this;\n        once(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependListener(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependListener(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        prependListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(\n            event: \"checkContinue\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependOnceListener(\n            event: \"request\",\n            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n        ): this;\n        prependOnceListener(\n            event: \"session\",\n            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,\n        ): this;\n        prependOnceListener(event: \"sessionError\", listener: (err: Error) => void): this;\n        prependOnceListener(\n            event: \"stream\",\n            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,\n        ): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: \"unknownProtocol\", listener: (socket: tls.TLSSocket) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    /**\n     * A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,\n     * headers, and\n     * data.\n     * @since v8.4.0\n     */\n    export class Http2ServerRequest extends stream.Readable {\n        constructor(\n            stream: ServerHttp2Stream,\n            headers: IncomingHttpHeaders,\n            options: stream.ReadableOptions,\n            rawHeaders: readonly string[],\n        );\n        /**\n         * The `request.aborted` property will be `true` if the request has\n         * been aborted.\n         * @since v10.1.0\n         */\n        readonly aborted: boolean;\n        /**\n         * The request authority pseudo header field. Because HTTP/2 allows requests\n         * to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.\n         * @since v8.4.0\n         */\n        readonly authority: string;\n        /**\n         * See `request.socket`.\n         * @since v8.4.0\n         * @deprecated Since v13.0.0 - Use `socket`.\n         */\n        readonly connection: net.Socket | tls.TLSSocket;\n        /**\n         * The `request.complete` property will be `true` if the request has\n         * been completed, aborted, or destroyed.\n         * @since v12.10.0\n         */\n        readonly complete: boolean;\n        /**\n         * The request/response headers object.\n         *\n         * Key-value pairs of header names and values. Header names are lower-cased.\n         *\n         * ```js\n         * // Prints something like:\n         * //\n         * // { 'user-agent': 'curl/7.22.0',\n         * //   host: '127.0.0.1:8000',\n         * //   accept: '*' }\n         * console.log(request.headers);\n         * ```\n         *\n         * See `HTTP/2 Headers Object`.\n         *\n         * In HTTP/2, the request path, host name, protocol, and method are represented as\n         * special headers prefixed with the `:` character (e.g. `':path'`). These special\n         * headers will be included in the `request.headers` object. Care must be taken not\n         * to inadvertently modify these special headers or errors may occur. For instance,\n         * removing all headers from the request will cause errors to occur:\n         *\n         * ```js\n         * removeAllHeaders(request.headers);\n         * assert(request.url);   // Fails because the :path header has been removed\n         * ```\n         * @since v8.4.0\n         */\n        readonly headers: IncomingHttpHeaders;\n        /**\n         * In case of server request, the HTTP version sent by the client. In the case of\n         * client response, the HTTP version of the connected-to server. Returns `'2.0'`.\n         *\n         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.\n         * @since v8.4.0\n         */\n        readonly httpVersion: string;\n        readonly httpVersionMinor: number;\n        readonly httpVersionMajor: number;\n        /**\n         * The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.\n         * @since v8.4.0\n         */\n        readonly method: string;\n        /**\n         * The raw request/response headers list exactly as they were received.\n         *\n         * The keys and values are in the same list. It is _not_ a\n         * list of tuples. So, the even-numbered offsets are key values, and the\n         * odd-numbered offsets are the associated values.\n         *\n         * Header names are not lowercased, and duplicates are not merged.\n         *\n         * ```js\n         * // Prints something like:\n         * //\n         * // [ 'user-agent',\n         * //   'this is invalid because there can be only one',\n         * //   'User-Agent',\n         * //   'curl/7.22.0',\n         * //   'Host',\n         * //   '127.0.0.1:8000',\n         * //   'ACCEPT',\n         * //   '*' ]\n         * console.log(request.rawHeaders);\n         * ```\n         * @since v8.4.0\n         */\n        readonly rawHeaders: string[];\n        /**\n         * The raw request/response trailer keys and values exactly as they were\n         * received. Only populated at the `'end'` event.\n         * @since v8.4.0\n         */\n        readonly rawTrailers: string[];\n        /**\n         * The request scheme pseudo header field indicating the scheme\n         * portion of the target URL.\n         * @since v8.4.0\n         */\n        readonly scheme: string;\n        /**\n         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but\n         * applies getters, setters, and methods based on HTTP/2 logic.\n         *\n         * `destroyed`, `readable`, and `writable` properties will be retrieved from and\n         * set on `request.stream`.\n         *\n         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.\n         *\n         * `setTimeout` method will be called on `request.stream.session`.\n         *\n         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for\n         * more information.\n         *\n         * All other interactions will be routed directly to the socket. With TLS support,\n         * use `request.socket.getPeerCertificate()` to obtain the client's\n         * authentication details.\n         * @since v8.4.0\n         */\n        readonly socket: net.Socket | tls.TLSSocket;\n        /**\n         * The `Http2Stream` object backing the request.\n         * @since v8.4.0\n         */\n        readonly stream: ServerHttp2Stream;\n        /**\n         * The request/response trailers object. Only populated at the `'end'` event.\n         * @since v8.4.0\n         */\n        readonly trailers: IncomingHttpHeaders;\n        /**\n         * Request URL string. This contains only the URL that is present in the actual\n         * HTTP request. If the request is:\n         *\n         * ```http\n         * GET /status?name=ryan HTTP/1.1\n         * Accept: text/plain\n         * ```\n         *\n         * Then `request.url` will be:\n         *\n         * ```js\n         * '/status?name=ryan'\n         * ```\n         *\n         * To parse the url into its parts, `new URL()` can be used:\n         *\n         * ```console\n         * $ node\n         * > new URL('/status?name=ryan', 'http://example.com')\n         * URL {\n         *   href: 'http://example.com/status?name=ryan',\n         *   origin: 'http://example.com',\n         *   protocol: 'http:',\n         *   username: '',\n         *   password: '',\n         *   host: 'example.com',\n         *   hostname: 'example.com',\n         *   port: '',\n         *   pathname: '/status',\n         *   search: '?name=ryan',\n         *   searchParams: URLSearchParams { 'name' => 'ryan' },\n         *   hash: ''\n         * }\n         * ```\n         * @since v8.4.0\n         */\n        url: string;\n        /**\n         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is\n         * provided, then it is added as a listener on the `'timeout'` event on\n         * the response object.\n         *\n         * If no `'timeout'` listener is added to the request, the response, or\n         * the server, then `Http2Stream`s are destroyed when they time out. If a\n         * handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.\n         * @since v8.4.0\n         */\n        setTimeout(msecs: number, callback?: () => void): void;\n        read(size?: number): Buffer | string | null;\n        addListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"readable\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"aborted\", hadError: boolean, code: number): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"data\", chunk: Buffer | string): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"readable\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"readable\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"readable\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"readable\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"aborted\", listener: (hadError: boolean, code: number) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"readable\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    /**\n     * This object is created internally by an HTTP server, not by the user. It is\n     * passed as the second parameter to the `'request'` event.\n     * @since v8.4.0\n     */\n    export class Http2ServerResponse<Request extends Http2ServerRequest = Http2ServerRequest> extends stream.Writable {\n        constructor(stream: ServerHttp2Stream);\n        /**\n         * See `response.socket`.\n         * @since v8.4.0\n         * @deprecated Since v13.0.0 - Use `socket`.\n         */\n        readonly connection: net.Socket | tls.TLSSocket;\n        /**\n         * Append a single header value to the header object.\n         *\n         * If the value is an array, this is equivalent to calling this method multiple times.\n         *\n         * If there were no previous values for the header, this is equivalent to calling {@link setHeader}.\n         *\n         * Attempting to set a header field name or value that contains invalid characters will result in a\n         * [TypeError](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-typeerror) being thrown.\n         *\n         * ```js\n         * // Returns headers including \"set-cookie: a\" and \"set-cookie: b\"\n         * const server = http2.createServer((req, res) => {\n         *   res.setHeader('set-cookie', 'a');\n         *   res.appendHeader('set-cookie', 'b');\n         *   res.writeHead(200);\n         *   res.end('ok');\n         * });\n         * ```\n         * @since v20.12.0\n         */\n        appendHeader(name: string, value: string | string[]): void;\n        /**\n         * Boolean value that indicates whether the response has completed. Starts\n         * as `false`. After `response.end()` executes, the value will be `true`.\n         * @since v8.4.0\n         * @deprecated Since v13.4.0,v12.16.0 - Use `writableEnded`.\n         */\n        readonly finished: boolean;\n        /**\n         * True if headers were sent, false otherwise (read-only).\n         * @since v8.4.0\n         */\n        readonly headersSent: boolean;\n        /**\n         * A reference to the original HTTP2 `request` object.\n         * @since v15.7.0\n         */\n        readonly req: Request;\n        /**\n         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but\n         * applies getters, setters, and methods based on HTTP/2 logic.\n         *\n         * `destroyed`, `readable`, and `writable` properties will be retrieved from and\n         * set on `response.stream`.\n         *\n         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.\n         *\n         * `setTimeout` method will be called on `response.stream.session`.\n         *\n         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for\n         * more information.\n         *\n         * All other interactions will be routed directly to the socket.\n         *\n         * ```js\n         * import http2 from 'node:http2';\n         * const server = http2.createServer((req, res) => {\n         *   const ip = req.socket.remoteAddress;\n         *   const port = req.socket.remotePort;\n         *   res.end(`Your IP address is ${ip} and your source port is ${port}.`);\n         * }).listen(3000);\n         * ```\n         * @since v8.4.0\n         */\n        readonly socket: net.Socket | tls.TLSSocket;\n        /**\n         * The `Http2Stream` object backing the response.\n         * @since v8.4.0\n         */\n        readonly stream: ServerHttp2Stream;\n        /**\n         * When true, the Date header will be automatically generated and sent in\n         * the response if it is not already present in the headers. Defaults to true.\n         *\n         * This should only be disabled for testing; HTTP requires the Date header\n         * in responses.\n         * @since v8.4.0\n         */\n        sendDate: boolean;\n        /**\n         * When using implicit headers (not calling `response.writeHead()` explicitly),\n         * this property controls the status code that will be sent to the client when\n         * the headers get flushed.\n         *\n         * ```js\n         * response.statusCode = 404;\n         * ```\n         *\n         * After response header was sent to the client, this property indicates the\n         * status code which was sent out.\n         * @since v8.4.0\n         */\n        statusCode: number;\n        /**\n         * Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns\n         * an empty string.\n         * @since v8.4.0\n         */\n        statusMessage: \"\";\n        /**\n         * This method adds HTTP trailing headers (a header but at the end of the\n         * message) to the response.\n         *\n         * Attempting to set a header field name or value that contains invalid characters\n         * will result in a `TypeError` being thrown.\n         * @since v8.4.0\n         */\n        addTrailers(trailers: OutgoingHttpHeaders): void;\n        /**\n         * This method signals to the server that all of the response headers and body\n         * have been sent; that server should consider this message complete.\n         * The method, `response.end()`, MUST be called on each response.\n         *\n         * If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.\n         *\n         * If `callback` is specified, it will be called when the response stream\n         * is finished.\n         * @since v8.4.0\n         */\n        end(callback?: () => void): this;\n        end(data: string | Uint8Array, callback?: () => void): this;\n        end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () => void): this;\n        /**\n         * Reads out a header that has already been queued but not sent to the client.\n         * The name is case-insensitive.\n         *\n         * ```js\n         * const contentType = response.getHeader('content-type');\n         * ```\n         * @since v8.4.0\n         */\n        getHeader(name: string): string;\n        /**\n         * Returns an array containing the unique names of the current outgoing headers.\n         * All header names are lowercase.\n         *\n         * ```js\n         * response.setHeader('Foo', 'bar');\n         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n         *\n         * const headerNames = response.getHeaderNames();\n         * // headerNames === ['foo', 'set-cookie']\n         * ```\n         * @since v8.4.0\n         */\n        getHeaderNames(): string[];\n        /**\n         * Returns a shallow copy of the current outgoing headers. Since a shallow copy\n         * is used, array values may be mutated without additional calls to various\n         * header-related http module methods. The keys of the returned object are the\n         * header names and the values are the respective header values. All header names\n         * are lowercase.\n         *\n         * The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,\n         * `obj.hasOwnProperty()`, and others\n         * are not defined and _will not work_.\n         *\n         * ```js\n         * response.setHeader('Foo', 'bar');\n         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n         *\n         * const headers = response.getHeaders();\n         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n         * ```\n         * @since v8.4.0\n         */\n        getHeaders(): OutgoingHttpHeaders;\n        /**\n         * Returns `true` if the header identified by `name` is currently set in the\n         * outgoing headers. The header name matching is case-insensitive.\n         *\n         * ```js\n         * const hasContentType = response.hasHeader('content-type');\n         * ```\n         * @since v8.4.0\n         */\n        hasHeader(name: string): boolean;\n        /**\n         * Removes a header that has been queued for implicit sending.\n         *\n         * ```js\n         * response.removeHeader('Content-Encoding');\n         * ```\n         * @since v8.4.0\n         */\n        removeHeader(name: string): void;\n        /**\n         * Sets a single header value for implicit headers. If this header already exists\n         * in the to-be-sent headers, its value will be replaced. Use an array of strings\n         * here to send multiple headers with the same name.\n         *\n         * ```js\n         * response.setHeader('Content-Type', 'text/html; charset=utf-8');\n         * ```\n         *\n         * or\n         *\n         * ```js\n         * response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);\n         * ```\n         *\n         * Attempting to set a header field name or value that contains invalid characters\n         * will result in a `TypeError` being thrown.\n         *\n         * When headers have been set with `response.setHeader()`, they will be merged\n         * with any headers passed to `response.writeHead()`, with the headers passed\n         * to `response.writeHead()` given precedence.\n         *\n         * ```js\n         * // Returns content-type = text/plain\n         * const server = http2.createServer((req, res) => {\n         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');\n         *   res.setHeader('X-Foo', 'bar');\n         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });\n         *   res.end('ok');\n         * });\n         * ```\n         * @since v8.4.0\n         */\n        setHeader(name: string, value: number | string | readonly string[]): void;\n        /**\n         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is\n         * provided, then it is added as a listener on the `'timeout'` event on\n         * the response object.\n         *\n         * If no `'timeout'` listener is added to the request, the response, or\n         * the server, then `Http2Stream` s are destroyed when they time out. If a\n         * handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.\n         * @since v8.4.0\n         */\n        setTimeout(msecs: number, callback?: () => void): void;\n        /**\n         * If this method is called and `response.writeHead()` has not been called,\n         * it will switch to implicit header mode and flush the implicit headers.\n         *\n         * This sends a chunk of the response body. This method may\n         * be called multiple times to provide successive parts of the body.\n         *\n         * In the `node:http` module, the response body is omitted when the\n         * request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.\n         *\n         * `chunk` can be a string or a buffer. If `chunk` is a string,\n         * the second parameter specifies how to encode it into a byte stream.\n         * By default the `encoding` is `'utf8'`. `callback` will be called when this chunk\n         * of data is flushed.\n         *\n         * This is the raw HTTP body and has nothing to do with higher-level multi-part\n         * body encodings that may be used.\n         *\n         * The first time `response.write()` is called, it will send the buffered\n         * header information and the first chunk of the body to the client. The second\n         * time `response.write()` is called, Node.js assumes data will be streamed,\n         * and sends the new data separately. That is, the response is buffered up to the\n         * first chunk of the body.\n         *\n         * Returns `true` if the entire data was flushed successfully to the kernel\n         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.\n         * @since v8.4.0\n         */\n        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;\n        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;\n        /**\n         * Sends a status `100 Continue` to the client, indicating that the request body\n         * should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.\n         * @since v8.4.0\n         */\n        writeContinue(): void;\n        /**\n         * Sends a status `103 Early Hints` to the client with a Link header,\n         * indicating that the user agent can preload/preconnect the linked resources.\n         * The `hints` is an object containing the values of headers to be sent with\n         * early hints message.\n         *\n         * **Example**\n         *\n         * ```js\n         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';\n         * response.writeEarlyHints({\n         *   'link': earlyHintsLink,\n         * });\n         *\n         * const earlyHintsLinks = [\n         *   '</styles.css>; rel=preload; as=style',\n         *   '</scripts.js>; rel=preload; as=script',\n         * ];\n         * response.writeEarlyHints({\n         *   'link': earlyHintsLinks,\n         * });\n         * ```\n         * @since v18.11.0\n         */\n        writeEarlyHints(hints: Record<string, string | string[]>): void;\n        /**\n         * Sends a response header to the request. The status code is a 3-digit HTTP\n         * status code, like `404`. The last argument, `headers`, are the response headers.\n         *\n         * Returns a reference to the `Http2ServerResponse`, so that calls can be chained.\n         *\n         * For compatibility with `HTTP/1`, a human-readable `statusMessage` may be\n         * passed as the second argument. However, because the `statusMessage` has no\n         * meaning within HTTP/2, the argument will have no effect and a process warning\n         * will be emitted.\n         *\n         * ```js\n         * const body = 'hello world';\n         * response.writeHead(200, {\n         *   'Content-Length': Buffer.byteLength(body),\n         *   'Content-Type': 'text/plain; charset=utf-8',\n         * });\n         * ```\n         *\n         * `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a\n         * given encoding. On outbound messages, Node.js does not check if Content-Length\n         * and the length of the body being transmitted are equal or not. However, when\n         * receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.\n         *\n         * This method may be called at most one time on a message before `response.end()` is called.\n         *\n         * If `response.write()` or `response.end()` are called before calling\n         * this, the implicit/mutable headers will be calculated and call this function.\n         *\n         * When headers have been set with `response.setHeader()`, they will be merged\n         * with any headers passed to `response.writeHead()`, with the headers passed\n         * to `response.writeHead()` given precedence.\n         *\n         * ```js\n         * // Returns content-type = text/plain\n         * const server = http2.createServer((req, res) => {\n         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');\n         *   res.setHeader('X-Foo', 'bar');\n         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });\n         *   res.end('ok');\n         * });\n         * ```\n         *\n         * Attempting to set a header field name or value that contains invalid characters\n         * will result in a `TypeError` being thrown.\n         * @since v8.4.0\n         */\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;\n        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;\n        /**\n         * Call `http2stream.pushStream()` with the given headers, and wrap the\n         * given `Http2Stream` on a newly created `Http2ServerResponse` as the callback\n         * parameter if successful. When `Http2ServerRequest` is closed, the callback is\n         * called with an error `ERR_HTTP2_INVALID_STREAM`.\n         * @since v8.4.0\n         * @param headers An object describing the headers\n         * @param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of\n         * `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method\n         */\n        createPushResponse(\n            headers: OutgoingHttpHeaders,\n            callback: (err: Error | null, res: Http2ServerResponse) => void,\n        ): void;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"close\"): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"finish\"): boolean;\n        emit(event: \"pipe\", src: stream.Readable): boolean;\n        emit(event: \"unpipe\", src: stream.Readable): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    export namespace constants {\n        const NGHTTP2_SESSION_SERVER: number;\n        const NGHTTP2_SESSION_CLIENT: number;\n        const NGHTTP2_STREAM_STATE_IDLE: number;\n        const NGHTTP2_STREAM_STATE_OPEN: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;\n        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;\n        const NGHTTP2_STREAM_STATE_CLOSED: number;\n        const NGHTTP2_NO_ERROR: number;\n        const NGHTTP2_PROTOCOL_ERROR: number;\n        const NGHTTP2_INTERNAL_ERROR: number;\n        const NGHTTP2_FLOW_CONTROL_ERROR: number;\n        const NGHTTP2_SETTINGS_TIMEOUT: number;\n        const NGHTTP2_STREAM_CLOSED: number;\n        const NGHTTP2_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_REFUSED_STREAM: number;\n        const NGHTTP2_CANCEL: number;\n        const NGHTTP2_COMPRESSION_ERROR: number;\n        const NGHTTP2_CONNECT_ERROR: number;\n        const NGHTTP2_ENHANCE_YOUR_CALM: number;\n        const NGHTTP2_INADEQUATE_SECURITY: number;\n        const NGHTTP2_HTTP_1_1_REQUIRED: number;\n        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;\n        const NGHTTP2_FLAG_NONE: number;\n        const NGHTTP2_FLAG_END_STREAM: number;\n        const NGHTTP2_FLAG_END_HEADERS: number;\n        const NGHTTP2_FLAG_ACK: number;\n        const NGHTTP2_FLAG_PADDED: number;\n        const NGHTTP2_FLAG_PRIORITY: number;\n        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;\n        const DEFAULT_SETTINGS_ENABLE_PUSH: number;\n        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;\n        const MAX_MAX_FRAME_SIZE: number;\n        const MIN_MAX_FRAME_SIZE: number;\n        const MAX_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_DEFAULT_WEIGHT: number;\n        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;\n        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;\n        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;\n        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;\n        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;\n        const PADDING_STRATEGY_NONE: number;\n        const PADDING_STRATEGY_MAX: number;\n        const PADDING_STRATEGY_CALLBACK: number;\n        const HTTP2_HEADER_STATUS: string;\n        const HTTP2_HEADER_METHOD: string;\n        const HTTP2_HEADER_AUTHORITY: string;\n        const HTTP2_HEADER_SCHEME: string;\n        const HTTP2_HEADER_PATH: string;\n        const HTTP2_HEADER_ACCEPT_CHARSET: string;\n        const HTTP2_HEADER_ACCEPT_ENCODING: string;\n        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;\n        const HTTP2_HEADER_ACCEPT_RANGES: string;\n        const HTTP2_HEADER_ACCEPT: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;\n        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;\n        const HTTP2_HEADER_AGE: string;\n        const HTTP2_HEADER_ALLOW: string;\n        const HTTP2_HEADER_AUTHORIZATION: string;\n        const HTTP2_HEADER_CACHE_CONTROL: string;\n        const HTTP2_HEADER_CONNECTION: string;\n        const HTTP2_HEADER_CONTENT_DISPOSITION: string;\n        const HTTP2_HEADER_CONTENT_ENCODING: string;\n        const HTTP2_HEADER_CONTENT_LANGUAGE: string;\n        const HTTP2_HEADER_CONTENT_LENGTH: string;\n        const HTTP2_HEADER_CONTENT_LOCATION: string;\n        const HTTP2_HEADER_CONTENT_MD5: string;\n        const HTTP2_HEADER_CONTENT_RANGE: string;\n        const HTTP2_HEADER_CONTENT_TYPE: string;\n        const HTTP2_HEADER_COOKIE: string;\n        const HTTP2_HEADER_DATE: string;\n        const HTTP2_HEADER_ETAG: string;\n        const HTTP2_HEADER_EXPECT: string;\n        const HTTP2_HEADER_EXPIRES: string;\n        const HTTP2_HEADER_FROM: string;\n        const HTTP2_HEADER_HOST: string;\n        const HTTP2_HEADER_IF_MATCH: string;\n        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;\n        const HTTP2_HEADER_IF_NONE_MATCH: string;\n        const HTTP2_HEADER_IF_RANGE: string;\n        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;\n        const HTTP2_HEADER_LAST_MODIFIED: string;\n        const HTTP2_HEADER_LINK: string;\n        const HTTP2_HEADER_LOCATION: string;\n        const HTTP2_HEADER_MAX_FORWARDS: string;\n        const HTTP2_HEADER_PREFER: string;\n        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;\n        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;\n        const HTTP2_HEADER_RANGE: string;\n        const HTTP2_HEADER_REFERER: string;\n        const HTTP2_HEADER_REFRESH: string;\n        const HTTP2_HEADER_RETRY_AFTER: string;\n        const HTTP2_HEADER_SERVER: string;\n        const HTTP2_HEADER_SET_COOKIE: string;\n        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;\n        const HTTP2_HEADER_TRANSFER_ENCODING: string;\n        const HTTP2_HEADER_TE: string;\n        const HTTP2_HEADER_UPGRADE: string;\n        const HTTP2_HEADER_USER_AGENT: string;\n        const HTTP2_HEADER_VARY: string;\n        const HTTP2_HEADER_VIA: string;\n        const HTTP2_HEADER_WWW_AUTHENTICATE: string;\n        const HTTP2_HEADER_HTTP2_SETTINGS: string;\n        const HTTP2_HEADER_KEEP_ALIVE: string;\n        const HTTP2_HEADER_PROXY_CONNECTION: string;\n        const HTTP2_METHOD_ACL: string;\n        const HTTP2_METHOD_BASELINE_CONTROL: string;\n        const HTTP2_METHOD_BIND: string;\n        const HTTP2_METHOD_CHECKIN: string;\n        const HTTP2_METHOD_CHECKOUT: string;\n        const HTTP2_METHOD_CONNECT: string;\n        const HTTP2_METHOD_COPY: string;\n        const HTTP2_METHOD_DELETE: string;\n        const HTTP2_METHOD_GET: string;\n        const HTTP2_METHOD_HEAD: string;\n        const HTTP2_METHOD_LABEL: string;\n        const HTTP2_METHOD_LINK: string;\n        const HTTP2_METHOD_LOCK: string;\n        const HTTP2_METHOD_MERGE: string;\n        const HTTP2_METHOD_MKACTIVITY: string;\n        const HTTP2_METHOD_MKCALENDAR: string;\n        const HTTP2_METHOD_MKCOL: string;\n        const HTTP2_METHOD_MKREDIRECTREF: string;\n        const HTTP2_METHOD_MKWORKSPACE: string;\n        const HTTP2_METHOD_MOVE: string;\n        const HTTP2_METHOD_OPTIONS: string;\n        const HTTP2_METHOD_ORDERPATCH: string;\n        const HTTP2_METHOD_PATCH: string;\n        const HTTP2_METHOD_POST: string;\n        const HTTP2_METHOD_PRI: string;\n        const HTTP2_METHOD_PROPFIND: string;\n        const HTTP2_METHOD_PROPPATCH: string;\n        const HTTP2_METHOD_PUT: string;\n        const HTTP2_METHOD_REBIND: string;\n        const HTTP2_METHOD_REPORT: string;\n        const HTTP2_METHOD_SEARCH: string;\n        const HTTP2_METHOD_TRACE: string;\n        const HTTP2_METHOD_UNBIND: string;\n        const HTTP2_METHOD_UNCHECKOUT: string;\n        const HTTP2_METHOD_UNLINK: string;\n        const HTTP2_METHOD_UNLOCK: string;\n        const HTTP2_METHOD_UPDATE: string;\n        const HTTP2_METHOD_UPDATEREDIRECTREF: string;\n        const HTTP2_METHOD_VERSION_CONTROL: string;\n        const HTTP_STATUS_CONTINUE: number;\n        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;\n        const HTTP_STATUS_PROCESSING: number;\n        const HTTP_STATUS_OK: number;\n        const HTTP_STATUS_CREATED: number;\n        const HTTP_STATUS_ACCEPTED: number;\n        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;\n        const HTTP_STATUS_NO_CONTENT: number;\n        const HTTP_STATUS_RESET_CONTENT: number;\n        const HTTP_STATUS_PARTIAL_CONTENT: number;\n        const HTTP_STATUS_MULTI_STATUS: number;\n        const HTTP_STATUS_ALREADY_REPORTED: number;\n        const HTTP_STATUS_IM_USED: number;\n        const HTTP_STATUS_MULTIPLE_CHOICES: number;\n        const HTTP_STATUS_MOVED_PERMANENTLY: number;\n        const HTTP_STATUS_FOUND: number;\n        const HTTP_STATUS_SEE_OTHER: number;\n        const HTTP_STATUS_NOT_MODIFIED: number;\n        const HTTP_STATUS_USE_PROXY: number;\n        const HTTP_STATUS_TEMPORARY_REDIRECT: number;\n        const HTTP_STATUS_PERMANENT_REDIRECT: number;\n        const HTTP_STATUS_BAD_REQUEST: number;\n        const HTTP_STATUS_UNAUTHORIZED: number;\n        const HTTP_STATUS_PAYMENT_REQUIRED: number;\n        const HTTP_STATUS_FORBIDDEN: number;\n        const HTTP_STATUS_NOT_FOUND: number;\n        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;\n        const HTTP_STATUS_NOT_ACCEPTABLE: number;\n        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;\n        const HTTP_STATUS_REQUEST_TIMEOUT: number;\n        const HTTP_STATUS_CONFLICT: number;\n        const HTTP_STATUS_GONE: number;\n        const HTTP_STATUS_LENGTH_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_FAILED: number;\n        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;\n        const HTTP_STATUS_URI_TOO_LONG: number;\n        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;\n        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;\n        const HTTP_STATUS_EXPECTATION_FAILED: number;\n        const HTTP_STATUS_TEAPOT: number;\n        const HTTP_STATUS_MISDIRECTED_REQUEST: number;\n        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;\n        const HTTP_STATUS_LOCKED: number;\n        const HTTP_STATUS_FAILED_DEPENDENCY: number;\n        const HTTP_STATUS_UNORDERED_COLLECTION: number;\n        const HTTP_STATUS_UPGRADE_REQUIRED: number;\n        const HTTP_STATUS_PRECONDITION_REQUIRED: number;\n        const HTTP_STATUS_TOO_MANY_REQUESTS: number;\n        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;\n        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;\n        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;\n        const HTTP_STATUS_NOT_IMPLEMENTED: number;\n        const HTTP_STATUS_BAD_GATEWAY: number;\n        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;\n        const HTTP_STATUS_GATEWAY_TIMEOUT: number;\n        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;\n        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;\n        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;\n        const HTTP_STATUS_LOOP_DETECTED: number;\n        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;\n        const HTTP_STATUS_NOT_EXTENDED: number;\n        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;\n    }\n    /**\n     * This symbol can be set as a property on the HTTP/2 headers object with\n     * an array value in order to provide a list of headers considered sensitive.\n     */\n    export const sensitiveHeaders: symbol;\n    /**\n     * Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called\n     * so instances returned may be safely modified for use.\n     * @since v8.4.0\n     */\n    export function getDefaultSettings(): Settings;\n    /**\n     * Returns a `Buffer` instance containing serialized representation of the given\n     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended\n     * for use with the `HTTP2-Settings` header field.\n     *\n     * ```js\n     * import http2 from 'node:http2';\n     *\n     * const packed = http2.getPackedSettings({ enablePush: false });\n     *\n     * console.log(packed.toString('base64'));\n     * // Prints: AAIAAAAA\n     * ```\n     * @since v8.4.0\n     */\n    export function getPackedSettings(settings: Settings): Buffer;\n    /**\n     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from\n     * the given `Buffer` as generated by `http2.getPackedSettings()`.\n     * @since v8.4.0\n     * @param buf The packed settings.\n     */\n    export function getUnpackedSettings(buf: Uint8Array): Settings;\n    /**\n     * Returns a `net.Server` instance that creates and manages `Http2Session` instances.\n     *\n     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when\n     * communicating\n     * with browser clients.\n     *\n     * ```js\n     * import http2 from 'node:http2';\n     *\n     * // Create an unencrypted HTTP/2 server.\n     * // Since there are no browsers known that support\n     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`\n     * // is necessary when communicating with browser clients.\n     * const server = http2.createServer();\n     *\n     * server.on('stream', (stream, headers) => {\n     *   stream.respond({\n     *     'content-type': 'text/html; charset=utf-8',\n     *     ':status': 200,\n     *   });\n     *   stream.end('<h1>Hello World</h1>');\n     * });\n     *\n     * server.listen(8000);\n     * ```\n     * @since v8.4.0\n     * @param onRequestHandler See `Compatibility API`\n     */\n    export function createServer(\n        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,\n    ): Http2Server;\n    export function createServer<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    >(\n        options: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,\n        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n    ): Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>;\n    /**\n     * Returns a `tls.Server` instance that creates and manages `Http2Session` instances.\n     *\n     * ```js\n     * import http2 from 'node:http2';\n     * import fs from 'node:fs';\n     *\n     * const options = {\n     *   key: fs.readFileSync('server-key.pem'),\n     *   cert: fs.readFileSync('server-cert.pem'),\n     * };\n     *\n     * // Create a secure HTTP/2 server\n     * const server = http2.createSecureServer(options);\n     *\n     * server.on('stream', (stream, headers) => {\n     *   stream.respond({\n     *     'content-type': 'text/html; charset=utf-8',\n     *     ':status': 200,\n     *   });\n     *   stream.end('<h1>Hello World</h1>');\n     * });\n     *\n     * server.listen(8443);\n     * ```\n     * @since v8.4.0\n     * @param onRequestHandler See `Compatibility API`\n     */\n    export function createSecureServer(\n        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,\n    ): Http2SecureServer;\n    export function createSecureServer<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    >(\n        options: SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,\n        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,\n    ): Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;\n    /**\n     * Returns a `ClientHttp2Session` instance.\n     *\n     * ```js\n     * import http2 from 'node:http2';\n     * const client = http2.connect('https://localhost:1234');\n     *\n     * // Use the client\n     *\n     * client.close();\n     * ```\n     * @since v8.4.0\n     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port\n     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.\n     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.\n     */\n    export function connect(\n        authority: string | url.URL,\n        listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n    ): ClientHttp2Session;\n    export function connect(\n        authority: string | url.URL,\n        options?: ClientSessionOptions | SecureClientSessionOptions,\n        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,\n    ): ClientHttp2Session;\n    /**\n     * Create an HTTP/2 server session from an existing socket.\n     * @param socket A Duplex Stream\n     * @param options Any `{@link createServer}` options can be provided.\n     * @since v20.12.0\n     */\n    export function performServerHandshake<\n        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,\n        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,\n        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,\n    >(\n        socket: stream.Duplex,\n        options?: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,\n    ): ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;\n}\ndeclare module \"node:http2\" {\n    export * from \"http2\";\n}\n"
        }
    ]
}