{
    "sourceFile": "node_modules/@types/node/http.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * To use the HTTP server and client one must import the `node:http` module.\n *\n * The HTTP interfaces in Node.js are designed to support many features\n * of the protocol which have been traditionally difficult to use.\n * In particular, large, possibly chunk-encoded, messages. The interface is\n * careful to never buffer entire requests or responses, so the\n * user is able to stream data.\n *\n * HTTP message headers are represented by an object like this:\n *\n * ```json\n * { \"content-length\": \"123\",\n *   \"content-type\": \"text/plain\",\n *   \"connection\": \"keep-alive\",\n *   \"host\": \"example.com\",\n *   \"accept\": \"*\" }\n * ```\n *\n * Keys are lowercased. Values are not modified.\n *\n * In order to support the full spectrum of possible HTTP applications, the Node.js\n * HTTP API is very low-level. It deals with stream handling and message\n * parsing only. It parses a message into headers and body but it does not\n * parse the actual headers or the body.\n *\n * See `message.headers` for details on how duplicate headers are handled.\n *\n * The raw headers as they were received are retained in the `rawHeaders` property, which is an array of `[key, value, key2, value2, ...]`. For\n * example, the previous message header object might have a `rawHeaders` list like the following:\n *\n * ```js\n * [ 'ConTent-Length', '123456',\n *   'content-LENGTH', '123',\n *   'content-type', 'text/plain',\n *   'CONNECTION', 'keep-alive',\n *   'Host', 'example.com',\n *   'accepT', '*' ]\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/http.js)\n */\ndeclare module \"http\" {\n    import * as stream from \"node:stream\";\n    import { URL } from \"node:url\";\n    import { LookupOptions } from \"node:dns\";\n    import { EventEmitter } from \"node:events\";\n    import { LookupFunction, Server as NetServer, Socket, TcpSocketConnectOpts } from \"node:net\";\n    // incoming headers will never contain number\n    interface IncomingHttpHeaders extends NodeJS.Dict<string | string[]> {\n        accept?: string | undefined;\n        \"accept-language\"?: string | undefined;\n        \"accept-patch\"?: string | undefined;\n        \"accept-ranges\"?: string | undefined;\n        \"access-control-allow-credentials\"?: string | undefined;\n        \"access-control-allow-headers\"?: string | undefined;\n        \"access-control-allow-methods\"?: string | undefined;\n        \"access-control-allow-origin\"?: string | undefined;\n        \"access-control-expose-headers\"?: string | undefined;\n        \"access-control-max-age\"?: string | undefined;\n        \"access-control-request-headers\"?: string | undefined;\n        \"access-control-request-method\"?: string | undefined;\n        age?: string | undefined;\n        allow?: string | undefined;\n        \"alt-svc\"?: string | undefined;\n        authorization?: string | undefined;\n        \"cache-control\"?: string | undefined;\n        connection?: string | undefined;\n        \"content-disposition\"?: string | undefined;\n        \"content-encoding\"?: string | undefined;\n        \"content-language\"?: string | undefined;\n        \"content-length\"?: string | undefined;\n        \"content-location\"?: string | undefined;\n        \"content-range\"?: string | undefined;\n        \"content-type\"?: string | undefined;\n        cookie?: string | undefined;\n        date?: string | undefined;\n        etag?: string | undefined;\n        expect?: string | undefined;\n        expires?: string | undefined;\n        forwarded?: string | undefined;\n        from?: string | undefined;\n        host?: string | undefined;\n        \"if-match\"?: string | undefined;\n        \"if-modified-since\"?: string | undefined;\n        \"if-none-match\"?: string | undefined;\n        \"if-unmodified-since\"?: string | undefined;\n        \"last-modified\"?: string | undefined;\n        location?: string | undefined;\n        origin?: string | undefined;\n        pragma?: string | undefined;\n        \"proxy-authenticate\"?: string | undefined;\n        \"proxy-authorization\"?: string | undefined;\n        \"public-key-pins\"?: string | undefined;\n        range?: string | undefined;\n        referer?: string | undefined;\n        \"retry-after\"?: string | undefined;\n        \"sec-websocket-accept\"?: string | undefined;\n        \"sec-websocket-extensions\"?: string | undefined;\n        \"sec-websocket-key\"?: string | undefined;\n        \"sec-websocket-protocol\"?: string | undefined;\n        \"sec-websocket-version\"?: string | undefined;\n        \"set-cookie\"?: string[] | undefined;\n        \"strict-transport-security\"?: string | undefined;\n        tk?: string | undefined;\n        trailer?: string | undefined;\n        \"transfer-encoding\"?: string | undefined;\n        upgrade?: string | undefined;\n        \"user-agent\"?: string | undefined;\n        vary?: string | undefined;\n        via?: string | undefined;\n        warning?: string | undefined;\n        \"www-authenticate\"?: string | undefined;\n    }\n    // outgoing headers allows numbers (as they are converted internally to strings)\n    type OutgoingHttpHeader = number | string | string[];\n    interface OutgoingHttpHeaders extends NodeJS.Dict<OutgoingHttpHeader> {\n        accept?: string | string[] | undefined;\n        \"accept-charset\"?: string | string[] | undefined;\n        \"accept-encoding\"?: string | string[] | undefined;\n        \"accept-language\"?: string | string[] | undefined;\n        \"accept-ranges\"?: string | undefined;\n        \"access-control-allow-credentials\"?: string | undefined;\n        \"access-control-allow-headers\"?: string | undefined;\n        \"access-control-allow-methods\"?: string | undefined;\n        \"access-control-allow-origin\"?: string | undefined;\n        \"access-control-expose-headers\"?: string | undefined;\n        \"access-control-max-age\"?: string | undefined;\n        \"access-control-request-headers\"?: string | undefined;\n        \"access-control-request-method\"?: string | undefined;\n        age?: string | undefined;\n        allow?: string | undefined;\n        authorization?: string | undefined;\n        \"cache-control\"?: string | undefined;\n        \"cdn-cache-control\"?: string | undefined;\n        connection?: string | string[] | undefined;\n        \"content-disposition\"?: string | undefined;\n        \"content-encoding\"?: string | undefined;\n        \"content-language\"?: string | undefined;\n        \"content-length\"?: string | number | undefined;\n        \"content-location\"?: string | undefined;\n        \"content-range\"?: string | undefined;\n        \"content-security-policy\"?: string | undefined;\n        \"content-security-policy-report-only\"?: string | undefined;\n        \"content-type\"?: string | undefined;\n        cookie?: string | string[] | undefined;\n        dav?: string | string[] | undefined;\n        dnt?: string | undefined;\n        date?: string | undefined;\n        etag?: string | undefined;\n        expect?: string | undefined;\n        expires?: string | undefined;\n        forwarded?: string | undefined;\n        from?: string | undefined;\n        host?: string | undefined;\n        \"if-match\"?: string | undefined;\n        \"if-modified-since\"?: string | undefined;\n        \"if-none-match\"?: string | undefined;\n        \"if-range\"?: string | undefined;\n        \"if-unmodified-since\"?: string | undefined;\n        \"last-modified\"?: string | undefined;\n        link?: string | string[] | undefined;\n        location?: string | undefined;\n        \"max-forwards\"?: string | undefined;\n        origin?: string | undefined;\n        pragma?: string | string[] | undefined;\n        \"proxy-authenticate\"?: string | string[] | undefined;\n        \"proxy-authorization\"?: string | undefined;\n        \"public-key-pins\"?: string | undefined;\n        \"public-key-pins-report-only\"?: string | undefined;\n        range?: string | undefined;\n        referer?: string | undefined;\n        \"referrer-policy\"?: string | undefined;\n        refresh?: string | undefined;\n        \"retry-after\"?: string | undefined;\n        \"sec-websocket-accept\"?: string | undefined;\n        \"sec-websocket-extensions\"?: string | string[] | undefined;\n        \"sec-websocket-key\"?: string | undefined;\n        \"sec-websocket-protocol\"?: string | string[] | undefined;\n        \"sec-websocket-version\"?: string | undefined;\n        server?: string | undefined;\n        \"set-cookie\"?: string | string[] | undefined;\n        \"strict-transport-security\"?: string | undefined;\n        te?: string | undefined;\n        trailer?: string | undefined;\n        \"transfer-encoding\"?: string | undefined;\n        \"user-agent\"?: string | undefined;\n        upgrade?: string | undefined;\n        \"upgrade-insecure-requests\"?: string | undefined;\n        vary?: string | undefined;\n        via?: string | string[] | undefined;\n        warning?: string | undefined;\n        \"www-authenticate\"?: string | string[] | undefined;\n        \"x-content-type-options\"?: string | undefined;\n        \"x-dns-prefetch-control\"?: string | undefined;\n        \"x-frame-options\"?: string | undefined;\n        \"x-xss-protection\"?: string | undefined;\n    }\n    interface ClientRequestArgs {\n        _defaultAgent?: Agent | undefined;\n        agent?: Agent | boolean | undefined;\n        auth?: string | null | undefined;\n        createConnection?:\n            | ((\n                options: ClientRequestArgs,\n                oncreate: (err: Error | null, socket: stream.Duplex) => void,\n            ) => stream.Duplex | null | undefined)\n            | undefined;\n        defaultPort?: number | string | undefined;\n        family?: number | undefined;\n        headers?: OutgoingHttpHeaders | undefined;\n        hints?: LookupOptions[\"hints\"];\n        host?: string | null | undefined;\n        hostname?: string | null | undefined;\n        insecureHTTPParser?: boolean | undefined;\n        localAddress?: string | undefined;\n        localPort?: number | undefined;\n        lookup?: LookupFunction | undefined;\n        /**\n         * @default 16384\n         */\n        maxHeaderSize?: number | undefined;\n        method?: string | undefined;\n        path?: string | null | undefined;\n        port?: number | string | null | undefined;\n        protocol?: string | null | undefined;\n        setDefaultHeaders?: boolean | undefined;\n        setHost?: boolean | undefined;\n        signal?: AbortSignal | undefined;\n        socketPath?: string | undefined;\n        timeout?: number | undefined;\n        uniqueHeaders?: Array<string | string[]> | undefined;\n        joinDuplicateHeaders?: boolean;\n    }\n    interface ServerOptions<\n        Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,\n    > {\n        /**\n         * Specifies the `IncomingMessage` class to be used. Useful for extending the original `IncomingMessage`.\n         */\n        IncomingMessage?: Request | undefined;\n        /**\n         * Specifies the `ServerResponse` class to be used. Useful for extending the original `ServerResponse`.\n         */\n        ServerResponse?: Response | undefined;\n        /**\n         * Sets the timeout value in milliseconds for receiving the entire request from the client.\n         * @see Server.requestTimeout for more information.\n         * @default 300000\n         * @since v18.0.0\n         */\n        requestTimeout?: number | undefined;\n        /**\n         * It joins the field line values of multiple headers in a request with `, ` instead of discarding the duplicates.\n         * @default false\n         * @since v18.14.0\n         */\n        joinDuplicateHeaders?: boolean;\n        /**\n         * The number of milliseconds of inactivity a server needs to wait for additional incoming data,\n         * after it has finished writing the last response, before a socket will be destroyed.\n         * @see Server.keepAliveTimeout for more information.\n         * @default 5000\n         * @since v18.0.0\n         */\n        keepAliveTimeout?: number | undefined;\n        /**\n         * Sets the interval value in milliseconds to check for request and headers timeout in incomplete requests.\n         * @default 30000\n         */\n        connectionsCheckingInterval?: number | undefined;\n        /**\n         * Optionally overrides all `socket`s' `readableHighWaterMark` and `writableHighWaterMark`.\n         * This affects `highWaterMark` property of both `IncomingMessage` and `ServerResponse`.\n         * Default: @see stream.getDefaultHighWaterMark().\n         * @since v20.1.0\n         */\n        highWaterMark?: number | undefined;\n        /**\n         * Use an insecure HTTP parser that accepts invalid HTTP headers when `true`.\n         * Using the insecure parser should be avoided.\n         * See --insecure-http-parser for more information.\n         * @default false\n         */\n        insecureHTTPParser?: boolean | undefined;\n        /**\n         * Optionally overrides the value of `--max-http-header-size` for requests received by\n         * this server, i.e. the maximum length of request headers in bytes.\n         * @default 16384\n         * @since v13.3.0\n         */\n        maxHeaderSize?: number | undefined;\n        /**\n         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.\n         * @default true\n         * @since v16.5.0\n         */\n        noDelay?: boolean | undefined;\n        /**\n         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,\n         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.\n         * @default false\n         * @since v16.5.0\n         */\n        keepAlive?: boolean | undefined;\n        /**\n         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.\n         * @default 0\n         * @since v16.5.0\n         */\n        keepAliveInitialDelay?: number | undefined;\n        /**\n         * A list of response headers that should be sent only once.\n         * If the header's value is an array, the items will be joined using `; `.\n         */\n        uniqueHeaders?: Array<string | string[]> | undefined;\n    }\n    type RequestListener<\n        Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,\n    > = (req: InstanceType<Request>, res: InstanceType<Response> & { req: InstanceType<Request> }) => void;\n    /**\n     * @since v0.1.17\n     */\n    class Server<\n        Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,\n    > extends NetServer {\n        constructor(requestListener?: RequestListener<Request, Response>);\n        constructor(options: ServerOptions<Request, Response>, requestListener?: RequestListener<Request, Response>);\n        /**\n         * Sets the timeout value for sockets, and emits a `'timeout'` event on\n         * the Server object, passing the socket as an argument, if a timeout\n         * occurs.\n         *\n         * If there is a `'timeout'` event listener on the Server object, then it\n         * will be called with the timed-out socket as an argument.\n         *\n         * By default, the Server does not timeout sockets. However, if a callback\n         * is assigned to the Server's `'timeout'` event, timeouts must be handled\n         * explicitly.\n         * @since v0.9.12\n         * @param [msecs=0 (no timeout)]\n         */\n        setTimeout(msecs?: number, callback?: (socket: Socket) => void): this;\n        setTimeout(callback: (socket: Socket) => void): this;\n        /**\n         * Limits maximum incoming headers count. If set to 0, no limit will be applied.\n         * @since v0.7.0\n         */\n        maxHeadersCount: number | null;\n        /**\n         * The maximum number of requests socket can handle\n         * before closing keep alive connection.\n         *\n         * A value of `0` will disable the limit.\n         *\n         * When the limit is reached it will set the `Connection` header value to `close`,\n         * but will not actually close the connection, subsequent requests sent\n         * after the limit is reached will get `503 Service Unavailable` as a response.\n         * @since v16.10.0\n         */\n        maxRequestsPerSocket: number | null;\n        /**\n         * The number of milliseconds of inactivity before a socket is presumed\n         * to have timed out.\n         *\n         * A value of `0` will disable the timeout behavior on incoming connections.\n         *\n         * The socket timeout logic is set up on connection, so changing this\n         * value only affects new connections to the server, not any existing connections.\n         * @since v0.9.12\n         */\n        timeout: number;\n        /**\n         * Limit the amount of time the parser will wait to receive the complete HTTP\n         * headers.\n         *\n         * If the timeout expires, the server responds with status 408 without\n         * forwarding the request to the request listener and then closes the connection.\n         *\n         * It must be set to a non-zero value (e.g. 120 seconds) to protect against\n         * potential Denial-of-Service attacks in case the server is deployed without a\n         * reverse proxy in front.\n         * @since v11.3.0, v10.14.0\n         */\n        headersTimeout: number;\n        /**\n         * The number of milliseconds of inactivity a server needs to wait for additional\n         * incoming data, after it has finished writing the last response, before a socket\n         * will be destroyed. If the server receives new data before the keep-alive\n         * timeout has fired, it will reset the regular inactivity timeout, i.e., `server.timeout`.\n         *\n         * A value of `0` will disable the keep-alive timeout behavior on incoming\n         * connections.\n         * A value of `0` makes the http server behave similarly to Node.js versions prior\n         * to 8.0.0, which did not have a keep-alive timeout.\n         *\n         * The socket timeout logic is set up on connection, so changing this value only\n         * affects new connections to the server, not any existing connections.\n         * @since v8.0.0\n         */\n        keepAliveTimeout: number;\n        /**\n         * Sets the timeout value in milliseconds for receiving the entire request from\n         * the client.\n         *\n         * If the timeout expires, the server responds with status 408 without\n         * forwarding the request to the request listener and then closes the connection.\n         *\n         * It must be set to a non-zero value (e.g. 120 seconds) to protect against\n         * potential Denial-of-Service attacks in case the server is deployed without a\n         * reverse proxy in front.\n         * @since v14.11.0\n         */\n        requestTimeout: number;\n        /**\n         * Closes all connections connected to this server.\n         * @since v18.2.0\n         */\n        closeAllConnections(): void;\n        /**\n         * Closes all connections connected to this server which are not sending a request\n         * or waiting for a response.\n         * @since v18.2.0\n         */\n        closeIdleConnections(): void;\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"checkContinue\", listener: RequestListener<Request, Response>): this;\n        addListener(event: \"checkExpectation\", listener: RequestListener<Request, Response>): this;\n        addListener(event: \"clientError\", listener: (err: Error, socket: stream.Duplex) => void): this;\n        addListener(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        addListener(event: \"dropRequest\", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;\n        addListener(event: \"request\", listener: RequestListener<Request, Response>): this;\n        addListener(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        emit(event: string, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connection\", socket: Socket): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(\n            event: \"checkContinue\",\n            req: InstanceType<Request>,\n            res: InstanceType<Response> & { req: InstanceType<Request> },\n        ): boolean;\n        emit(\n            event: \"checkExpectation\",\n            req: InstanceType<Request>,\n            res: InstanceType<Response> & { req: InstanceType<Request> },\n        ): boolean;\n        emit(event: \"clientError\", err: Error, socket: stream.Duplex): boolean;\n        emit(event: \"connect\", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;\n        emit(event: \"dropRequest\", req: InstanceType<Request>, socket: stream.Duplex): boolean;\n        emit(\n            event: \"request\",\n            req: InstanceType<Request>,\n            res: InstanceType<Response> & { req: InstanceType<Request> },\n        ): boolean;\n        emit(event: \"upgrade\", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"checkContinue\", listener: RequestListener<Request, Response>): this;\n        on(event: \"checkExpectation\", listener: RequestListener<Request, Response>): this;\n        on(event: \"clientError\", listener: (err: Error, socket: stream.Duplex) => void): this;\n        on(event: \"connect\", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;\n        on(event: \"dropRequest\", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;\n        on(event: \"request\", listener: RequestListener<Request, Response>): this;\n        on(event: \"upgrade\", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"checkContinue\", listener: RequestListener<Request, Response>): this;\n        once(event: \"checkExpectation\", listener: RequestListener<Request, Response>): this;\n        once(event: \"clientError\", listener: (err: Error, socket: stream.Duplex) => void): this;\n        once(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        once(event: \"dropRequest\", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;\n        once(event: \"request\", listener: RequestListener<Request, Response>): this;\n        once(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"checkContinue\", listener: RequestListener<Request, Response>): this;\n        prependListener(event: \"checkExpectation\", listener: RequestListener<Request, Response>): this;\n        prependListener(event: \"clientError\", listener: (err: Error, socket: stream.Duplex) => void): this;\n        prependListener(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        prependListener(\n            event: \"dropRequest\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,\n        ): this;\n        prependListener(event: \"request\", listener: RequestListener<Request, Response>): this;\n        prependListener(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"checkContinue\", listener: RequestListener<Request, Response>): this;\n        prependOnceListener(event: \"checkExpectation\", listener: RequestListener<Request, Response>): this;\n        prependOnceListener(event: \"clientError\", listener: (err: Error, socket: stream.Duplex) => void): this;\n        prependOnceListener(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n        prependOnceListener(\n            event: \"dropRequest\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,\n        ): this;\n        prependOnceListener(event: \"request\", listener: RequestListener<Request, Response>): this;\n        prependOnceListener(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,\n        ): this;\n    }\n    /**\n     * This class serves as the parent class of {@link ClientRequest} and {@link ServerResponse}. It is an abstract outgoing message from\n     * the perspective of the participants of an HTTP transaction.\n     * @since v0.1.17\n     */\n    class OutgoingMessage<Request extends IncomingMessage = IncomingMessage> extends stream.Writable {\n        readonly req: Request;\n        chunkedEncoding: boolean;\n        shouldKeepAlive: boolean;\n        useChunkedEncodingByDefault: boolean;\n        sendDate: boolean;\n        /**\n         * @deprecated Use `writableEnded` instead.\n         */\n        finished: boolean;\n        /**\n         * Read-only. `true` if the headers were sent, otherwise `false`.\n         * @since v0.9.3\n         */\n        readonly headersSent: boolean;\n        /**\n         * Alias of `outgoingMessage.socket`.\n         * @since v0.3.0\n         * @deprecated Since v15.12.0,v14.17.1 - Use `socket` instead.\n         */\n        readonly connection: Socket | null;\n        /**\n         * Reference to the underlying socket. Usually, users will not want to access\n         * this property.\n         *\n         * After calling `outgoingMessage.end()`, this property will be nulled.\n         * @since v0.3.0\n         */\n        readonly socket: Socket | null;\n        constructor();\n        /**\n         * Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.\n         * @since v0.9.12\n         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `timeout` event.\n         */\n        setTimeout(msecs: number, callback?: () => void): this;\n        /**\n         * Sets a single header value. If the header already exists in the to-be-sent\n         * headers, its value will be replaced. Use an array of strings to send multiple\n         * headers with the same name.\n         * @since v0.4.0\n         * @param name Header name\n         * @param value Header value\n         */\n        setHeader(name: string, value: number | string | readonly string[]): this;\n        /**\n         * Sets multiple header values for implicit headers. headers must be an instance of\n         * `Headers` or `Map`, if a header already exists in the to-be-sent headers, its\n         * value will be replaced.\n         *\n         * ```js\n         * const headers = new Headers({ foo: 'bar' });\n         * outgoingMessage.setHeaders(headers);\n         * ```\n         *\n         * or\n         *\n         * ```js\n         * const headers = new Map([['foo', 'bar']]);\n         * outgoingMessage.setHeaders(headers);\n         * ```\n         *\n         * When headers have been set with `outgoingMessage.setHeaders()`, they will be\n         * merged with any headers passed to `response.writeHead()`, with the headers passed\n         * to `response.writeHead()` given precedence.\n         *\n         * ```js\n         * // Returns content-type = text/plain\n         * const server = http.createServer((req, res) => {\n         *   const headers = new Headers({ 'Content-Type': 'text/html' });\n         *   res.setHeaders(headers);\n         *   res.writeHead(200, { 'Content-Type': 'text/plain' });\n         *   res.end('ok');\n         * });\n         * ```\n         *\n         * @since v19.6.0, v18.15.0\n         * @param name Header name\n         * @param value Header value\n         */\n        setHeaders(headers: Headers | Map<string, number | string | readonly string[]>): this;\n        /**\n         * Append a single header value to the header object.\n         *\n         * If the value is an array, this is equivalent to calling this method multiple\n         * times.\n         *\n         * If there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n         *\n         * Depending of the value of `options.uniqueHeaders` when the client request or the\n         * server were created, this will end up in the header being sent multiple times or\n         * a single time with values joined using `; `.\n         * @since v18.3.0, v16.17.0\n         * @param name Header name\n         * @param value Header value\n         */\n        appendHeader(name: string, value: string | readonly string[]): this;\n        /**\n         * Gets the value of the HTTP header with the given name. If that header is not\n         * set, the returned value will be `undefined`.\n         * @since v0.4.0\n         * @param name Name of header\n         */\n        getHeader(name: string): number | string | string[] | undefined;\n        /**\n         * Returns a shallow copy of the current outgoing headers. Since a shallow\n         * copy is used, array values may be mutated without additional calls to\n         * various header-related HTTP module methods. The keys of the returned\n         * object are the header names and the values are the respective header\n         * values. All header names are lowercase.\n         *\n         * The object returned by the `outgoingMessage.getHeaders()` method does\n         * not prototypically inherit from the JavaScript `Object`. This means that\n         * typical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\n         * and others are not defined and will not work.\n         *\n         * ```js\n         * outgoingMessage.setHeader('Foo', 'bar');\n         * outgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n         *\n         * const headers = outgoingMessage.getHeaders();\n         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n         * ```\n         * @since v7.7.0\n         */\n        getHeaders(): OutgoingHttpHeaders;\n        /**\n         * Returns an array containing the unique names of the current outgoing headers.\n         * All names are lowercase.\n         * @since v7.7.0\n         */\n        getHeaderNames(): string[];\n        /**\n         * Returns `true` if the header identified by `name` is currently set in the\n         * outgoing headers. The header name is case-insensitive.\n         *\n         * ```js\n         * const hasContentType = outgoingMessage.hasHeader('content-type');\n         * ```\n         * @since v7.7.0\n         */\n        hasHeader(name: string): boolean;\n        /**\n         * Removes a header that is queued for implicit sending.\n         *\n         * ```js\n         * outgoingMessage.removeHeader('Content-Encoding');\n         * ```\n         * @since v0.4.0\n         * @param name Header name\n         */\n        removeHeader(name: string): void;\n        /**\n         * Adds HTTP trailers (headers but at the end of the message) to the message.\n         *\n         * Trailers will **only** be emitted if the message is chunked encoded. If not,\n         * the trailers will be silently discarded.\n         *\n         * HTTP requires the `Trailer` header to be sent to emit trailers,\n         * with a list of header field names in its value, e.g.\n         *\n         * ```js\n         * message.writeHead(200, { 'Content-Type': 'text/plain',\n         *                          'Trailer': 'Content-MD5' });\n         * message.write(fileData);\n         * message.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\n         * message.end();\n         * ```\n         *\n         * Attempting to set a header field name or value that contains invalid characters\n         * will result in a `TypeError` being thrown.\n         * @since v0.3.0\n         */\n        addTrailers(headers: OutgoingHttpHeaders | ReadonlyArray<[string, string]>): void;\n        /**\n         * Flushes the message headers.\n         *\n         * For efficiency reason, Node.js normally buffers the message headers\n         * until `outgoingMessage.end()` is called or the first chunk of message data\n         * is written. It then tries to pack the headers and data into a single TCP\n         * packet.\n         *\n         * It is usually desired (it saves a TCP round-trip), but not when the first\n         * data is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.\n         * @since v1.6.0\n         */\n        flushHeaders(): void;\n    }\n    /**\n     * This object is created internally by an HTTP server, not by the user. It is\n     * passed as the second parameter to the `'request'` event.\n     * @since v0.1.17\n     */\n    class ServerResponse<Request extends IncomingMessage = IncomingMessage> extends OutgoingMessage<Request> {\n        /**\n         * When using implicit headers (not calling `response.writeHead()` explicitly),\n         * this property controls the status code that will be sent to the client when\n         * the headers get flushed.\n         *\n         * ```js\n         * response.statusCode = 404;\n         * ```\n         *\n         * After response header was sent to the client, this property indicates the\n         * status code which was sent out.\n         * @since v0.4.0\n         */\n        statusCode: number;\n        /**\n         * When using implicit headers (not calling `response.writeHead()` explicitly),\n         * this property controls the status message that will be sent to the client when\n         * the headers get flushed. If this is left as `undefined` then the standard\n         * message for the status code will be used.\n         *\n         * ```js\n         * response.statusMessage = 'Not found';\n         * ```\n         *\n         * After response header was sent to the client, this property indicates the\n         * status message which was sent out.\n         * @since v0.11.8\n         */\n        statusMessage: string;\n        /**\n         * If set to `true`, Node.js will check whether the `Content-Length` header value and the size of the body, in bytes, are equal.\n         * Mismatching the `Content-Length` header value will result\n         * in an `Error` being thrown, identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.\n         * @since v18.10.0, v16.18.0\n         */\n        strictContentLength: boolean;\n        constructor(req: Request);\n        assignSocket(socket: Socket): void;\n        detachSocket(socket: Socket): void;\n        /**\n         * Sends an HTTP/1.1 100 Continue message to the client, indicating that\n         * the request body should be sent. See the `'checkContinue'` event on `Server`.\n         * @since v0.3.0\n         */\n        writeContinue(callback?: () => void): void;\n        /**\n         * Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\n         * indicating that the user agent can preload/preconnect the linked resources.\n         * The `hints` is an object containing the values of headers to be sent with\n         * early hints message. The optional `callback` argument will be called when\n         * the response message has been written.\n         *\n         * **Example**\n         *\n         * ```js\n         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';\n         * response.writeEarlyHints({\n         *   'link': earlyHintsLink,\n         * });\n         *\n         * const earlyHintsLinks = [\n         *   '</styles.css>; rel=preload; as=style',\n         *   '</scripts.js>; rel=preload; as=script',\n         * ];\n         * response.writeEarlyHints({\n         *   'link': earlyHintsLinks,\n         *   'x-trace-id': 'id for diagnostics',\n         * });\n         *\n         * const earlyHintsCallback = () => console.log('early hints message sent');\n         * response.writeEarlyHints({\n         *   'link': earlyHintsLinks,\n         * }, earlyHintsCallback);\n         * ```\n         * @since v18.11.0\n         * @param hints An object containing the values of headers\n         * @param callback Will be called when the response message has been written\n         */\n        writeEarlyHints(hints: Record<string, string | string[]>, callback?: () => void): void;\n        /**\n         * Sends a response header to the request. The status code is a 3-digit HTTP\n         * status code, like `404`. The last argument, `headers`, are the response headers.\n         * Optionally one can give a human-readable `statusMessage` as the second\n         * argument.\n         *\n         * `headers` may be an `Array` where the keys and values are in the same list.\n         * It is _not_ a list of tuples. So, the even-numbered offsets are key values,\n         * and the odd-numbered offsets are the associated values. The array is in the same\n         * format as `request.rawHeaders`.\n         *\n         * Returns a reference to the `ServerResponse`, so that calls can be chained.\n         *\n         * ```js\n         * const body = 'hello world';\n         * response\n         *   .writeHead(200, {\n         *     'Content-Length': Buffer.byteLength(body),\n         *     'Content-Type': 'text/plain',\n         *   })\n         *   .end(body);\n         * ```\n         *\n         * This method must only be called once on a message and it must\n         * be called before `response.end()` is called.\n         *\n         * If `response.write()` or `response.end()` are called before calling\n         * this, the implicit/mutable headers will be calculated and call this function.\n         *\n         * When headers have been set with `response.setHeader()`, they will be merged\n         * with any headers passed to `response.writeHead()`, with the headers passed\n         * to `response.writeHead()` given precedence.\n         *\n         * If this method is called and `response.setHeader()` has not been called,\n         * it will directly write the supplied header values onto the network channel\n         * without caching internally, and the `response.getHeader()` on the header\n         * will not yield the expected result. If progressive population of headers is\n         * desired with potential future retrieval and modification, use `response.setHeader()` instead.\n         *\n         * ```js\n         * // Returns content-type = text/plain\n         * const server = http.createServer((req, res) => {\n         *   res.setHeader('Content-Type', 'text/html');\n         *   res.setHeader('X-Foo', 'bar');\n         *   res.writeHead(200, { 'Content-Type': 'text/plain' });\n         *   res.end('ok');\n         * });\n         * ```\n         *\n         * `Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\n         * will check whether `Content-Length` and the length of the body which has\n         * been transmitted are equal or not.\n         *\n         * Attempting to set a header field name or value that contains invalid characters\n         * will result in a \\[`Error`\\]\\[\\] being thrown.\n         * @since v0.1.30\n         */\n        writeHead(\n            statusCode: number,\n            statusMessage?: string,\n            headers?: OutgoingHttpHeaders | OutgoingHttpHeader[],\n        ): this;\n        writeHead(statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): this;\n        /**\n         * Sends a HTTP/1.1 102 Processing message to the client, indicating that\n         * the request body should be sent.\n         * @since v10.0.0\n         */\n        writeProcessing(): void;\n    }\n    interface InformationEvent {\n        statusCode: number;\n        statusMessage: string;\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        headers: IncomingHttpHeaders;\n        rawHeaders: string[];\n    }\n    /**\n     * This object is created internally and returned from {@link request}. It\n     * represents an _in-progress_ request whose header has already been queued. The\n     * header is still mutable using the `setHeader(name, value)`, `getHeader(name)`, `removeHeader(name)` API. The actual header will\n     * be sent along with the first data chunk or when calling `request.end()`.\n     *\n     * To get the response, add a listener for `'response'` to the request object. `'response'` will be emitted from the request object when the response\n     * headers have been received. The `'response'` event is executed with one\n     * argument which is an instance of {@link IncomingMessage}.\n     *\n     * During the `'response'` event, one can add listeners to the\n     * response object; particularly to listen for the `'data'` event.\n     *\n     * If no `'response'` handler is added, then the response will be\n     * entirely discarded. However, if a `'response'` event handler is added,\n     * then the data from the response object **must** be consumed, either by\n     * calling `response.read()` whenever there is a `'readable'` event, or\n     * by adding a `'data'` handler, or by calling the `.resume()` method.\n     * Until the data is consumed, the `'end'` event will not fire. Also, until\n     * the data is read it will consume memory that can eventually lead to a\n     * 'process out of memory' error.\n     *\n     * For backward compatibility, `res` will only emit `'error'` if there is an `'error'` listener registered.\n     *\n     * Set `Content-Length` header to limit the response body size.\n     * If `response.strictContentLength` is set to `true`, mismatching the `Content-Length` header value will result in an `Error` being thrown,\n     * identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.\n     *\n     * `Content-Length` value should be in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes.\n     * @since v0.1.17\n     */\n    class ClientRequest extends OutgoingMessage {\n        /**\n         * The `request.aborted` property will be `true` if the request has\n         * been aborted.\n         * @since v0.11.14\n         * @deprecated Since v17.0.0, v16.12.0 - Check `destroyed` instead.\n         */\n        aborted: boolean;\n        /**\n         * The request host.\n         * @since v14.5.0, v12.19.0\n         */\n        host: string;\n        /**\n         * The request protocol.\n         * @since v14.5.0, v12.19.0\n         */\n        protocol: string;\n        /**\n         * When sending request through a keep-alive enabled agent, the underlying socket\n         * might be reused. But if server closes connection at unfortunate time, client\n         * may run into a 'ECONNRESET' error.\n         *\n         * ```js\n         * import http from 'node:http';\n         *\n         * // Server has a 5 seconds keep-alive timeout by default\n         * http\n         *   .createServer((req, res) => {\n         *     res.write('hello\\n');\n         *     res.end();\n         *   })\n         *   .listen(3000);\n         *\n         * setInterval(() => {\n         *   // Adapting a keep-alive agent\n         *   http.get('http://localhost:3000', { agent }, (res) => {\n         *     res.on('data', (data) => {\n         *       // Do nothing\n         *     });\n         *   });\n         * }, 5000); // Sending request on 5s interval so it's easy to hit idle timeout\n         * ```\n         *\n         * By marking a request whether it reused socket or not, we can do\n         * automatic error retry base on it.\n         *\n         * ```js\n         * import http from 'node:http';\n         * const agent = new http.Agent({ keepAlive: true });\n         *\n         * function retriableRequest() {\n         *   const req = http\n         *     .get('http://localhost:3000', { agent }, (res) => {\n         *       // ...\n         *     })\n         *     .on('error', (err) => {\n         *       // Check if retry is needed\n         *       if (req.reusedSocket &#x26;&#x26; err.code === 'ECONNRESET') {\n         *         retriableRequest();\n         *       }\n         *     });\n         * }\n         *\n         * retriableRequest();\n         * ```\n         * @since v13.0.0, v12.16.0\n         */\n        reusedSocket: boolean;\n        /**\n         * Limits maximum response headers count. If set to 0, no limit will be applied.\n         */\n        maxHeadersCount: number;\n        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);\n        /**\n         * The request method.\n         * @since v0.1.97\n         */\n        method: string;\n        /**\n         * The request path.\n         * @since v0.4.0\n         */\n        path: string;\n        /**\n         * Marks the request as aborting. Calling this will cause remaining data\n         * in the response to be dropped and the socket to be destroyed.\n         * @since v0.3.8\n         * @deprecated Since v14.1.0,v13.14.0 - Use `destroy` instead.\n         */\n        abort(): void;\n        onSocket(socket: Socket): void;\n        /**\n         * Once a socket is assigned to this request and is connected `socket.setTimeout()` will be called.\n         * @since v0.5.9\n         * @param timeout Milliseconds before a request times out.\n         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `'timeout'` event.\n         */\n        setTimeout(timeout: number, callback?: () => void): this;\n        /**\n         * Once a socket is assigned to this request and is connected `socket.setNoDelay()` will be called.\n         * @since v0.5.9\n         */\n        setNoDelay(noDelay?: boolean): void;\n        /**\n         * Once a socket is assigned to this request and is connected `socket.setKeepAlive()` will be called.\n         * @since v0.5.9\n         */\n        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;\n        /**\n         * Returns an array containing the unique names of the current outgoing raw\n         * headers. Header names are returned with their exact casing being set.\n         *\n         * ```js\n         * request.setHeader('Foo', 'bar');\n         * request.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n         *\n         * const headerNames = request.getRawHeaderNames();\n         * // headerNames === ['Foo', 'Set-Cookie']\n         * ```\n         * @since v15.13.0, v14.17.0\n         */\n        getRawHeaderNames(): string[];\n        /**\n         * @deprecated\n         */\n        addListener(event: \"abort\", listener: () => void): this;\n        addListener(\n            event: \"connect\",\n            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,\n        ): this;\n        addListener(event: \"continue\", listener: () => void): this;\n        addListener(event: \"information\", listener: (info: InformationEvent) => void): this;\n        addListener(event: \"response\", listener: (response: IncomingMessage) => void): this;\n        addListener(event: \"socket\", listener: (socket: Socket) => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        addListener(\n            event: \"upgrade\",\n            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,\n        ): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        /**\n         * @deprecated\n         */\n        on(event: \"abort\", listener: () => void): this;\n        on(event: \"connect\", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        on(event: \"continue\", listener: () => void): this;\n        on(event: \"information\", listener: (info: InformationEvent) => void): this;\n        on(event: \"response\", listener: (response: IncomingMessage) => void): this;\n        on(event: \"socket\", listener: (socket: Socket) => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        on(event: \"upgrade\", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        /**\n         * @deprecated\n         */\n        once(event: \"abort\", listener: () => void): this;\n        once(event: \"connect\", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        once(event: \"continue\", listener: () => void): this;\n        once(event: \"information\", listener: (info: InformationEvent) => void): this;\n        once(event: \"response\", listener: (response: IncomingMessage) => void): this;\n        once(event: \"socket\", listener: (socket: Socket) => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        once(event: \"upgrade\", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        /**\n         * @deprecated\n         */\n        prependListener(event: \"abort\", listener: () => void): this;\n        prependListener(\n            event: \"connect\",\n            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,\n        ): this;\n        prependListener(event: \"continue\", listener: () => void): this;\n        prependListener(event: \"information\", listener: (info: InformationEvent) => void): this;\n        prependListener(event: \"response\", listener: (response: IncomingMessage) => void): this;\n        prependListener(event: \"socket\", listener: (socket: Socket) => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependListener(\n            event: \"upgrade\",\n            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,\n        ): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        /**\n         * @deprecated\n         */\n        prependOnceListener(event: \"abort\", listener: () => void): this;\n        prependOnceListener(\n            event: \"connect\",\n            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,\n        ): this;\n        prependOnceListener(event: \"continue\", listener: () => void): this;\n        prependOnceListener(event: \"information\", listener: (info: InformationEvent) => void): this;\n        prependOnceListener(event: \"response\", listener: (response: IncomingMessage) => void): this;\n        prependOnceListener(event: \"socket\", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(\n            event: \"upgrade\",\n            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,\n        ): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    /**\n     * An `IncomingMessage` object is created by {@link Server} or {@link ClientRequest} and passed as the first argument to the `'request'` and `'response'` event respectively. It may be used to\n     * access response\n     * status, headers, and data.\n     *\n     * Different from its `socket` value which is a subclass of `stream.Duplex`, the `IncomingMessage` itself extends `stream.Readable` and is created separately to\n     * parse and emit the incoming HTTP headers and payload, as the underlying socket\n     * may be reused multiple times in case of keep-alive.\n     * @since v0.1.17\n     */\n    class IncomingMessage extends stream.Readable {\n        constructor(socket: Socket);\n        /**\n         * The `message.aborted` property will be `true` if the request has\n         * been aborted.\n         * @since v10.1.0\n         * @deprecated Since v17.0.0,v16.12.0 - Check `message.destroyed` from <a href=\"stream.html#class-streamreadable\" class=\"type\">stream.Readable</a>.\n         */\n        aborted: boolean;\n        /**\n         * In case of server request, the HTTP version sent by the client. In the case of\n         * client response, the HTTP version of the connected-to server.\n         * Probably either `'1.1'` or `'1.0'`.\n         *\n         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.\n         * @since v0.1.1\n         */\n        httpVersion: string;\n        httpVersionMajor: number;\n        httpVersionMinor: number;\n        /**\n         * The `message.complete` property will be `true` if a complete HTTP message has\n         * been received and successfully parsed.\n         *\n         * This property is particularly useful as a means of determining if a client or\n         * server fully transmitted a message before a connection was terminated:\n         *\n         * ```js\n         * const req = http.request({\n         *   host: '127.0.0.1',\n         *   port: 8080,\n         *   method: 'POST',\n         * }, (res) => {\n         *   res.resume();\n         *   res.on('end', () => {\n         *     if (!res.complete)\n         *       console.error(\n         *         'The connection was terminated while the message was still being sent');\n         *   });\n         * });\n         * ```\n         * @since v0.3.0\n         */\n        complete: boolean;\n        /**\n         * Alias for `message.socket`.\n         * @since v0.1.90\n         * @deprecated Since v16.0.0 - Use `socket`.\n         */\n        connection: Socket;\n        /**\n         * The `net.Socket` object associated with the connection.\n         *\n         * With HTTPS support, use `request.socket.getPeerCertificate()` to obtain the\n         * client's authentication details.\n         *\n         * This property is guaranteed to be an instance of the `net.Socket` class,\n         * a subclass of `stream.Duplex`, unless the user specified a socket\n         * type other than `net.Socket` or internally nulled.\n         * @since v0.3.0\n         */\n        socket: Socket;\n        /**\n         * The request/response headers object.\n         *\n         * Key-value pairs of header names and values. Header names are lower-cased.\n         *\n         * ```js\n         * // Prints something like:\n         * //\n         * // { 'user-agent': 'curl/7.22.0',\n         * //   host: '127.0.0.1:8000',\n         * //   accept: '*' }\n         * console.log(request.headers);\n         * ```\n         *\n         * Duplicates in raw headers are handled in the following ways, depending on the\n         * header name:\n         *\n         * * Duplicates of `age`, `authorization`, `content-length`, `content-type`, `etag`, `expires`, `from`, `host`, `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,\n         * `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`, or `user-agent` are discarded.\n         * To allow duplicate values of the headers listed above to be joined,\n         * use the option `joinDuplicateHeaders` in {@link request} and {@link createServer}. See RFC 9110 Section 5.3 for more\n         * information.\n         * * `set-cookie` is always an array. Duplicates are added to the array.\n         * * For duplicate `cookie` headers, the values are joined together with `; `.\n         * * For all other headers, the values are joined together with `, `.\n         * @since v0.1.5\n         */\n        headers: IncomingHttpHeaders;\n        /**\n         * Similar to `message.headers`, but there is no join logic and the values are\n         * always arrays of strings, even for headers received just once.\n         *\n         * ```js\n         * // Prints something like:\n         * //\n         * // { 'user-agent': ['curl/7.22.0'],\n         * //   host: ['127.0.0.1:8000'],\n         * //   accept: ['*'] }\n         * console.log(request.headersDistinct);\n         * ```\n         * @since v18.3.0, v16.17.0\n         */\n        headersDistinct: NodeJS.Dict<string[]>;\n        /**\n         * The raw request/response headers list exactly as they were received.\n         *\n         * The keys and values are in the same list. It is _not_ a\n         * list of tuples. So, the even-numbered offsets are key values, and the\n         * odd-numbered offsets are the associated values.\n         *\n         * Header names are not lowercased, and duplicates are not merged.\n         *\n         * ```js\n         * // Prints something like:\n         * //\n         * // [ 'user-agent',\n         * //   'this is invalid because there can be only one',\n         * //   'User-Agent',\n         * //   'curl/7.22.0',\n         * //   'Host',\n         * //   '127.0.0.1:8000',\n         * //   'ACCEPT',\n         * //   '*' ]\n         * console.log(request.rawHeaders);\n         * ```\n         * @since v0.11.6\n         */\n        rawHeaders: string[];\n        /**\n         * The request/response trailers object. Only populated at the `'end'` event.\n         * @since v0.3.0\n         */\n        trailers: NodeJS.Dict<string>;\n        /**\n         * Similar to `message.trailers`, but there is no join logic and the values are\n         * always arrays of strings, even for headers received just once.\n         * Only populated at the `'end'` event.\n         * @since v18.3.0, v16.17.0\n         */\n        trailersDistinct: NodeJS.Dict<string[]>;\n        /**\n         * The raw request/response trailer keys and values exactly as they were\n         * received. Only populated at the `'end'` event.\n         * @since v0.11.6\n         */\n        rawTrailers: string[];\n        /**\n         * Calls `message.socket.setTimeout(msecs, callback)`.\n         * @since v0.5.9\n         */\n        setTimeout(msecs: number, callback?: () => void): this;\n        /**\n         * **Only valid for request obtained from {@link Server}.**\n         *\n         * The request method as a string. Read only. Examples: `'GET'`, `'DELETE'`.\n         * @since v0.1.1\n         */\n        method?: string | undefined;\n        /**\n         * **Only valid for request obtained from {@link Server}.**\n         *\n         * Request URL string. This contains only the URL that is present in the actual\n         * HTTP request. Take the following request:\n         *\n         * ```http\n         * GET /status?name=ryan HTTP/1.1\n         * Accept: text/plain\n         * ```\n         *\n         * To parse the URL into its parts:\n         *\n         * ```js\n         * new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);\n         * ```\n         *\n         * When `request.url` is `'/status?name=ryan'` and `process.env.HOST` is undefined:\n         *\n         * ```console\n         * $ node\n         * > new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);\n         * URL {\n         *   href: 'http://localhost/status?name=ryan',\n         *   origin: 'http://localhost',\n         *   protocol: 'http:',\n         *   username: '',\n         *   password: '',\n         *   host: 'localhost',\n         *   hostname: 'localhost',\n         *   port: '',\n         *   pathname: '/status',\n         *   search: '?name=ryan',\n         *   searchParams: URLSearchParams { 'name' => 'ryan' },\n         *   hash: ''\n         * }\n         * ```\n         *\n         * Ensure that you set `process.env.HOST` to the server's host name, or consider replacing this part entirely. If using `req.headers.host`, ensure proper\n         * validation is used, as clients may specify a custom `Host` header.\n         * @since v0.1.90\n         */\n        url?: string | undefined;\n        /**\n         * **Only valid for response obtained from {@link ClientRequest}.**\n         *\n         * The 3-digit HTTP response status code. E.G. `404`.\n         * @since v0.1.1\n         */\n        statusCode?: number | undefined;\n        /**\n         * **Only valid for response obtained from {@link ClientRequest}.**\n         *\n         * The HTTP response status message (reason phrase). E.G. `OK` or `Internal Server Error`.\n         * @since v0.11.10\n         */\n        statusMessage?: string | undefined;\n        /**\n         * Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\n         * as an argument to any listeners on the event.\n         * @since v0.3.0\n         */\n        destroy(error?: Error): this;\n    }\n    interface AgentOptions extends Partial<TcpSocketConnectOpts> {\n        /**\n         * Keep sockets around in a pool to be used by other requests in the future. Default = false\n         */\n        keepAlive?: boolean | undefined;\n        /**\n         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.\n         * Only relevant if keepAlive is set to true.\n         */\n        keepAliveMsecs?: number | undefined;\n        /**\n         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity\n         */\n        maxSockets?: number | undefined;\n        /**\n         * Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity.\n         */\n        maxTotalSockets?: number | undefined;\n        /**\n         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.\n         */\n        maxFreeSockets?: number | undefined;\n        /**\n         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.\n         */\n        timeout?: number | undefined;\n        /**\n         * Scheduling strategy to apply when picking the next free socket to use.\n         * @default `lifo`\n         */\n        scheduling?: \"fifo\" | \"lifo\" | undefined;\n    }\n    /**\n     * An `Agent` is responsible for managing connection persistence\n     * and reuse for HTTP clients. It maintains a queue of pending requests\n     * for a given host and port, reusing a single socket connection for each\n     * until the queue is empty, at which time the socket is either destroyed\n     * or put into a pool where it is kept to be used again for requests to the\n     * same host and port. Whether it is destroyed or pooled depends on the `keepAlive` `option`.\n     *\n     * Pooled connections have TCP Keep-Alive enabled for them, but servers may\n     * still close idle connections, in which case they will be removed from the\n     * pool and a new connection will be made when a new HTTP request is made for\n     * that host and port. Servers may also refuse to allow multiple requests\n     * over the same connection, in which case the connection will have to be\n     * remade for every request and cannot be pooled. The `Agent` will still make\n     * the requests to that server, but each one will occur over a new connection.\n     *\n     * When a connection is closed by the client or the server, it is removed\n     * from the pool. Any unused sockets in the pool will be unrefed so as not\n     * to keep the Node.js process running when there are no outstanding requests.\n     * (see `socket.unref()`).\n     *\n     * It is good practice, to `destroy()` an `Agent` instance when it is no\n     * longer in use, because unused sockets consume OS resources.\n     *\n     * Sockets are removed from an agent when the socket emits either\n     * a `'close'` event or an `'agentRemove'` event. When intending to keep one\n     * HTTP request open for a long time without keeping it in the agent, something\n     * like the following may be done:\n     *\n     * ```js\n     * http.get(options, (res) => {\n     *   // Do stuff\n     * }).on('socket', (socket) => {\n     *   socket.emit('agentRemove');\n     * });\n     * ```\n     *\n     * An agent may also be used for an individual request. By providing `{agent: false}` as an option to the `http.get()` or `http.request()` functions, a one-time use `Agent` with default options\n     * will be used\n     * for the client connection.\n     *\n     * `agent:false`:\n     *\n     * ```js\n     * http.get({\n     *   hostname: 'localhost',\n     *   port: 80,\n     *   path: '/',\n     *   agent: false,  // Create a new agent just for this one request\n     * }, (res) => {\n     *   // Do stuff with response\n     * });\n     * ```\n     *\n     * `options` in [`socket.connect()`](https://nodejs.org/docs/latest-v22.x/api/net.html#socketconnectoptions-connectlistener) are also supported.\n     *\n     * To configure any of them, a custom {@link Agent} instance must be created.\n     *\n     * ```js\n     * import http from 'node:http';\n     * const keepAliveAgent = new http.Agent({ keepAlive: true });\n     * options.agent = keepAliveAgent;\n     * http.request(options, onResponseCallback)\n     * ```\n     * @since v0.3.4\n     */\n    class Agent extends EventEmitter {\n        /**\n         * By default set to 256. For agents with `keepAlive` enabled, this\n         * sets the maximum number of sockets that will be left open in the free\n         * state.\n         * @since v0.11.7\n         */\n        maxFreeSockets: number;\n        /**\n         * By default set to `Infinity`. Determines how many concurrent sockets the agent\n         * can have open per origin. Origin is the returned value of `agent.getName()`.\n         * @since v0.3.6\n         */\n        maxSockets: number;\n        /**\n         * By default set to `Infinity`. Determines how many concurrent sockets the agent\n         * can have open. Unlike `maxSockets`, this parameter applies across all origins.\n         * @since v14.5.0, v12.19.0\n         */\n        maxTotalSockets: number;\n        /**\n         * An object which contains arrays of sockets currently awaiting use by\n         * the agent when `keepAlive` is enabled. Do not modify.\n         *\n         * Sockets in the `freeSockets` list will be automatically destroyed and\n         * removed from the array on `'timeout'`.\n         * @since v0.11.4\n         */\n        readonly freeSockets: NodeJS.ReadOnlyDict<Socket[]>;\n        /**\n         * An object which contains arrays of sockets currently in use by the\n         * agent. Do not modify.\n         * @since v0.3.6\n         */\n        readonly sockets: NodeJS.ReadOnlyDict<Socket[]>;\n        /**\n         * An object which contains queues of requests that have not yet been assigned to\n         * sockets. Do not modify.\n         * @since v0.5.9\n         */\n        readonly requests: NodeJS.ReadOnlyDict<IncomingMessage[]>;\n        constructor(opts?: AgentOptions);\n        /**\n         * Destroy any sockets that are currently in use by the agent.\n         *\n         * It is usually not necessary to do this. However, if using an\n         * agent with `keepAlive` enabled, then it is best to explicitly shut down\n         * the agent when it is no longer needed. Otherwise,\n         * sockets might stay open for quite a long time before the server\n         * terminates them.\n         * @since v0.11.4\n         */\n        destroy(): void;\n    }\n    const METHODS: string[];\n    const STATUS_CODES: {\n        [errorCode: number]: string | undefined;\n        [errorCode: string]: string | undefined;\n    };\n    /**\n     * Returns a new instance of {@link Server}.\n     *\n     * The `requestListener` is a function which is automatically\n     * added to the `'request'` event.\n     *\n     * ```js\n     * import http from 'node:http';\n     *\n     * // Create a local server to receive data from\n     * const server = http.createServer((req, res) => {\n     *   res.writeHead(200, { 'Content-Type': 'application/json' });\n     *   res.end(JSON.stringify({\n     *     data: 'Hello World!',\n     *   }));\n     * });\n     *\n     * server.listen(8000);\n     * ```\n     *\n     * ```js\n     * import http from 'node:http';\n     *\n     * // Create a local server to receive data from\n     * const server = http.createServer();\n     *\n     * // Listen to the request event\n     * server.on('request', (request, res) => {\n     *   res.writeHead(200, { 'Content-Type': 'application/json' });\n     *   res.end(JSON.stringify({\n     *     data: 'Hello World!',\n     *   }));\n     * });\n     *\n     * server.listen(8000);\n     * ```\n     * @since v0.1.13\n     */\n    function createServer<\n        Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,\n    >(requestListener?: RequestListener<Request, Response>): Server<Request, Response>;\n    function createServer<\n        Request extends typeof IncomingMessage = typeof IncomingMessage,\n        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,\n    >(\n        options: ServerOptions<Request, Response>,\n        requestListener?: RequestListener<Request, Response>,\n    ): Server<Request, Response>;\n    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,\n    // create interface RequestOptions would make the naming more clear to developers\n    interface RequestOptions extends ClientRequestArgs {}\n    /**\n     * `options` in `socket.connect()` are also supported.\n     *\n     * Node.js maintains several connections per server to make HTTP requests.\n     * This function allows one to transparently issue requests.\n     *\n     * `url` can be a string or a `URL` object. If `url` is a\n     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.\n     *\n     * If both `url` and `options` are specified, the objects are merged, with the `options` properties taking precedence.\n     *\n     * The optional `callback` parameter will be added as a one-time listener for\n     * the `'response'` event.\n     *\n     * `http.request()` returns an instance of the {@link ClientRequest} class. The `ClientRequest` instance is a writable stream. If one needs to\n     * upload a file with a POST request, then write to the `ClientRequest` object.\n     *\n     * ```js\n     * import http from 'node:http';\n     * import { Buffer } from 'node:buffer';\n     *\n     * const postData = JSON.stringify({\n     *   'msg': 'Hello World!',\n     * });\n     *\n     * const options = {\n     *   hostname: 'www.google.com',\n     *   port: 80,\n     *   path: '/upload',\n     *   method: 'POST',\n     *   headers: {\n     *     'Content-Type': 'application/json',\n     *     'Content-Length': Buffer.byteLength(postData),\n     *   },\n     * };\n     *\n     * const req = http.request(options, (res) => {\n     *   console.log(`STATUS: ${res.statusCode}`);\n     *   console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n     *   res.setEncoding('utf8');\n     *   res.on('data', (chunk) => {\n     *     console.log(`BODY: ${chunk}`);\n     *   });\n     *   res.on('end', () => {\n     *     console.log('No more data in response.');\n     *   });\n     * });\n     *\n     * req.on('error', (e) => {\n     *   console.error(`problem with request: ${e.message}`);\n     * });\n     *\n     * // Write data to request body\n     * req.write(postData);\n     * req.end();\n     * ```\n     *\n     * In the example `req.end()` was called. With `http.request()` one\n     * must always call `req.end()` to signify the end of the request -\n     * even if there is no data being written to the request body.\n     *\n     * If any error is encountered during the request (be that with DNS resolution,\n     * TCP level errors, or actual HTTP parse errors) an `'error'` event is emitted\n     * on the returned request object. As with all `'error'` events, if no listeners\n     * are registered the error will be thrown.\n     *\n     * There are a few special headers that should be noted.\n     *\n     * * Sending a 'Connection: keep-alive' will notify Node.js that the connection to\n     * the server should be persisted until the next request.\n     * * Sending a 'Content-Length' header will disable the default chunked encoding.\n     * * Sending an 'Expect' header will immediately send the request headers.\n     * Usually, when sending 'Expect: 100-continue', both a timeout and a listener\n     * for the `'continue'` event should be set. See RFC 2616 Section 8.2.3 for more\n     * information.\n     * * Sending an Authorization header will override using the `auth` option\n     * to compute basic authentication.\n     *\n     * Example using a `URL` as `options`:\n     *\n     * ```js\n     * const options = new URL('http://abc:xyz@example.com');\n     *\n     * const req = http.request(options, (res) => {\n     *   // ...\n     * });\n     * ```\n     *\n     * In a successful request, the following events will be emitted in the following\n     * order:\n     *\n     * * `'socket'`\n     * * `'response'`\n     *    * `'data'` any number of times, on the `res` object\n     *    (`'data'` will not be emitted at all if the response body is empty, for\n     *    instance, in most redirects)\n     *    * `'end'` on the `res` object\n     * * `'close'`\n     *\n     * In the case of a connection error, the following events will be emitted:\n     *\n     * * `'socket'`\n     * * `'error'`\n     * * `'close'`\n     *\n     * In the case of a premature connection close before the response is received,\n     * the following events will be emitted in the following order:\n     *\n     * * `'socket'`\n     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`\n     * * `'close'`\n     *\n     * In the case of a premature connection close after the response is received,\n     * the following events will be emitted in the following order:\n     *\n     * * `'socket'`\n     * * `'response'`\n     *    * `'data'` any number of times, on the `res` object\n     * * (connection closed here)\n     * * `'aborted'` on the `res` object\n     * * `'close'`\n     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`\n     * * `'close'` on the `res` object\n     *\n     * If `req.destroy()` is called before a socket is assigned, the following\n     * events will be emitted in the following order:\n     *\n     * * (`req.destroy()` called here)\n     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called\n     * * `'close'`\n     *\n     * If `req.destroy()` is called before the connection succeeds, the following\n     * events will be emitted in the following order:\n     *\n     * * `'socket'`\n     * * (`req.destroy()` called here)\n     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called\n     * * `'close'`\n     *\n     * If `req.destroy()` is called after the response is received, the following\n     * events will be emitted in the following order:\n     *\n     * * `'socket'`\n     * * `'response'`\n     *    * `'data'` any number of times, on the `res` object\n     * * (`req.destroy()` called here)\n     * * `'aborted'` on the `res` object\n     * * `'close'`\n     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called\n     * * `'close'` on the `res` object\n     *\n     * If `req.abort()` is called before a socket is assigned, the following\n     * events will be emitted in the following order:\n     *\n     * * (`req.abort()` called here)\n     * * `'abort'`\n     * * `'close'`\n     *\n     * If `req.abort()` is called before the connection succeeds, the following\n     * events will be emitted in the following order:\n     *\n     * * `'socket'`\n     * * (`req.abort()` called here)\n     * * `'abort'`\n     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`\n     * * `'close'`\n     *\n     * If `req.abort()` is called after the response is received, the following\n     * events will be emitted in the following order:\n     *\n     * * `'socket'`\n     * * `'response'`\n     *    * `'data'` any number of times, on the `res` object\n     * * (`req.abort()` called here)\n     * * `'abort'`\n     * * `'aborted'` on the `res` object\n     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`.\n     * * `'close'`\n     * * `'close'` on the `res` object\n     *\n     * Setting the `timeout` option or using the `setTimeout()` function will\n     * not abort the request or do anything besides add a `'timeout'` event.\n     *\n     * Passing an `AbortSignal` and then calling `abort()` on the corresponding `AbortController` will behave the same way as calling `.destroy()` on the\n     * request. Specifically, the `'error'` event will be emitted with an error with\n     * the message `'AbortError: The operation was aborted'`, the code `'ABORT_ERR'` and the `cause`, if one was provided.\n     * @since v0.3.6\n     */\n    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function request(\n        url: string | URL,\n        options: RequestOptions,\n        callback?: (res: IncomingMessage) => void,\n    ): ClientRequest;\n    /**\n     * Since most requests are GET requests without bodies, Node.js provides this\n     * convenience method. The only difference between this method and {@link request} is that it sets the method to GET by default and calls `req.end()` automatically. The callback must take care to\n     * consume the response\n     * data for reasons stated in {@link ClientRequest} section.\n     *\n     * The `callback` is invoked with a single argument that is an instance of {@link IncomingMessage}.\n     *\n     * JSON fetching example:\n     *\n     * ```js\n     * http.get('http://localhost:8000/', (res) => {\n     *   const { statusCode } = res;\n     *   const contentType = res.headers['content-type'];\n     *\n     *   let error;\n     *   // Any 2xx status code signals a successful response but\n     *   // here we're only checking for 200.\n     *   if (statusCode !== 200) {\n     *     error = new Error('Request Failed.\\n' +\n     *                       `Status Code: ${statusCode}`);\n     *   } else if (!/^application\\/json/.test(contentType)) {\n     *     error = new Error('Invalid content-type.\\n' +\n     *                       `Expected application/json but received ${contentType}`);\n     *   }\n     *   if (error) {\n     *     console.error(error.message);\n     *     // Consume response data to free up memory\n     *     res.resume();\n     *     return;\n     *   }\n     *\n     *   res.setEncoding('utf8');\n     *   let rawData = '';\n     *   res.on('data', (chunk) => { rawData += chunk; });\n     *   res.on('end', () => {\n     *     try {\n     *       const parsedData = JSON.parse(rawData);\n     *       console.log(parsedData);\n     *     } catch (e) {\n     *       console.error(e.message);\n     *     }\n     *   });\n     * }).on('error', (e) => {\n     *   console.error(`Got error: ${e.message}`);\n     * });\n     *\n     * // Create a local server to receive data from\n     * const server = http.createServer((req, res) => {\n     *   res.writeHead(200, { 'Content-Type': 'application/json' });\n     *   res.end(JSON.stringify({\n     *     data: 'Hello World!',\n     *   }));\n     * });\n     *\n     * server.listen(8000);\n     * ```\n     * @since v0.3.6\n     * @param options Accepts the same `options` as {@link request}, with the method set to GET by default.\n     */\n    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;\n    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;\n    /**\n     * Performs the low-level validations on the provided `name` that are done when `res.setHeader(name, value)` is called.\n     *\n     * Passing illegal value as `name` will result in a `TypeError` being thrown,\n     * identified by `code: 'ERR_INVALID_HTTP_TOKEN'`.\n     *\n     * It is not necessary to use this method before passing headers to an HTTP request\n     * or response. The HTTP module will automatically validate such headers.\n     *\n     * Example:\n     *\n     * ```js\n     * import { validateHeaderName } from 'node:http';\n     *\n     * try {\n     *   validateHeaderName('');\n     * } catch (err) {\n     *   console.error(err instanceof TypeError); // --> true\n     *   console.error(err.code); // --> 'ERR_INVALID_HTTP_TOKEN'\n     *   console.error(err.message); // --> 'Header name must be a valid HTTP token [\"\"]'\n     * }\n     * ```\n     * @since v14.3.0\n     * @param [label='Header name'] Label for error message.\n     */\n    function validateHeaderName(name: string): void;\n    /**\n     * Performs the low-level validations on the provided `value` that are done when `res.setHeader(name, value)` is called.\n     *\n     * Passing illegal value as `value` will result in a `TypeError` being thrown.\n     *\n     * * Undefined value error is identified by `code: 'ERR_HTTP_INVALID_HEADER_VALUE'`.\n     * * Invalid value character error is identified by `code: 'ERR_INVALID_CHAR'`.\n     *\n     * It is not necessary to use this method before passing headers to an HTTP request\n     * or response. The HTTP module will automatically validate such headers.\n     *\n     * Examples:\n     *\n     * ```js\n     * import { validateHeaderValue } from 'node:http';\n     *\n     * try {\n     *   validateHeaderValue('x-my-header', undefined);\n     * } catch (err) {\n     *   console.error(err instanceof TypeError); // --> true\n     *   console.error(err.code === 'ERR_HTTP_INVALID_HEADER_VALUE'); // --> true\n     *   console.error(err.message); // --> 'Invalid value \"undefined\" for header \"x-my-header\"'\n     * }\n     *\n     * try {\n     *   validateHeaderValue('x-my-header', 'oʊmɪɡə');\n     * } catch (err) {\n     *   console.error(err instanceof TypeError); // --> true\n     *   console.error(err.code === 'ERR_INVALID_CHAR'); // --> true\n     *   console.error(err.message); // --> 'Invalid character in header content [\"x-my-header\"]'\n     * }\n     * ```\n     * @since v14.3.0\n     * @param name Header name\n     * @param value Header value\n     */\n    function validateHeaderValue(name: string, value: string): void;\n    /**\n     * Set the maximum number of idle HTTP parsers.\n     * @since v18.8.0, v16.18.0\n     * @param [max=1000]\n     */\n    function setMaxIdleHTTPParsers(max: number): void;\n    /**\n     * Global instance of `Agent` which is used as the default for all HTTP client\n     * requests. Diverges from a default `Agent` configuration by having `keepAlive`\n     * enabled and a `timeout` of 5 seconds.\n     * @since v0.5.9\n     */\n    let globalAgent: Agent;\n    /**\n     * Read-only property specifying the maximum allowed size of HTTP headers in bytes.\n     * Defaults to 16KB. Configurable using the `--max-http-header-size` CLI option.\n     */\n    const maxHeaderSize: number;\n    /**\n     * A browser-compatible implementation of [WebSocket](https://nodejs.org/docs/latest/api/http.html#websocket).\n     * @since v22.5.0\n     */\n    const WebSocket: import(\"undici-types\").WebSocket;\n    /**\n     * @since v22.5.0\n     */\n    const CloseEvent: import(\"undici-types\").CloseEvent;\n    /**\n     * @since v22.5.0\n     */\n    const MessageEvent: import(\"undici-types\").MessageEvent;\n}\ndeclare module \"node:http\" {\n    export * from \"http\";\n}\n"
        }
    ]
}