{
    "sourceFile": "node_modules/@types/node/dgram.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:dgram` module provides an implementation of UDP datagram sockets.\n *\n * ```js\n * import dgram from 'node:dgram';\n *\n * const server = dgram.createSocket('udp4');\n *\n * server.on('error', (err) => {\n *   console.error(`server error:\\n${err.stack}`);\n *   server.close();\n * });\n *\n * server.on('message', (msg, rinfo) => {\n *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n * });\n *\n * server.on('listening', () => {\n *   const address = server.address();\n *   console.log(`server listening ${address.address}:${address.port}`);\n * });\n *\n * server.bind(41234);\n * // Prints: server listening 0.0.0.0:41234\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/dgram.js)\n */\ndeclare module \"dgram\" {\n    import { AddressInfo, BlockList } from \"node:net\";\n    import * as dns from \"node:dns\";\n    import { Abortable, EventEmitter } from \"node:events\";\n    interface RemoteInfo {\n        address: string;\n        family: \"IPv4\" | \"IPv6\";\n        port: number;\n        size: number;\n    }\n    interface BindOptions {\n        port?: number | undefined;\n        address?: string | undefined;\n        exclusive?: boolean | undefined;\n        fd?: number | undefined;\n    }\n    type SocketType = \"udp4\" | \"udp6\";\n    interface SocketOptions extends Abortable {\n        type: SocketType;\n        reuseAddr?: boolean | undefined;\n        reusePort?: boolean | undefined;\n        /**\n         * @default false\n         */\n        ipv6Only?: boolean | undefined;\n        recvBufferSize?: number | undefined;\n        sendBufferSize?: number | undefined;\n        lookup?:\n            | ((\n                hostname: string,\n                options: dns.LookupOneOptions,\n                callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,\n            ) => void)\n            | undefined;\n        receiveBlockList?: BlockList | undefined;\n        sendBlockList?: BlockList | undefined;\n    }\n    /**\n     * Creates a `dgram.Socket` object. Once the socket is created, calling `socket.bind()` will instruct the socket to begin listening for datagram\n     * messages. When `address` and `port` are not passed to `socket.bind()` the\n     * method will bind the socket to the \"all interfaces\" address on a random port\n     * (it does the right thing for both `udp4` and `udp6` sockets). The bound address\n     * and port can be retrieved using `socket.address().address` and `socket.address().port`.\n     *\n     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.close()` on the socket:\n     *\n     * ```js\n     * const controller = new AbortController();\n     * const { signal } = controller;\n     * const server = dgram.createSocket({ type: 'udp4', signal });\n     * server.on('message', (msg, rinfo) => {\n     *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n     * });\n     * // Later, when you want to close the server.\n     * controller.abort();\n     * ```\n     * @since v0.11.13\n     * @param options Available options are:\n     * @param callback Attached as a listener for `'message'` events. Optional.\n     */\n    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;\n    /**\n     * Encapsulates the datagram functionality.\n     *\n     * New instances of `dgram.Socket` are created using {@link createSocket}.\n     * The `new` keyword is not to be used to create `dgram.Socket` instances.\n     * @since v0.1.99\n     */\n    class Socket extends EventEmitter {\n        /**\n         * Tells the kernel to join a multicast group at the given `multicastAddress` and `multicastInterface` using the `IP_ADD_MEMBERSHIP` socket option. If the `multicastInterface` argument is not\n         * specified, the operating system will choose\n         * one interface and will add membership to it. To add membership to every\n         * available interface, call `addMembership` multiple times, once per interface.\n         *\n         * When called on an unbound socket, this method will implicitly bind to a random\n         * port, listening on all interfaces.\n         *\n         * When sharing a UDP socket across multiple `cluster` workers, the`socket.addMembership()` function must be called only once or an`EADDRINUSE` error will occur:\n         *\n         * ```js\n         * import cluster from 'node:cluster';\n         * import dgram from 'node:dgram';\n         *\n         * if (cluster.isPrimary) {\n         *   cluster.fork(); // Works ok.\n         *   cluster.fork(); // Fails with EADDRINUSE.\n         * } else {\n         *   const s = dgram.createSocket('udp4');\n         *   s.bind(1234, () => {\n         *     s.addMembership('224.0.0.114');\n         *   });\n         * }\n         * ```\n         * @since v0.6.9\n         */\n        addMembership(multicastAddress: string, multicastInterface?: string): void;\n        /**\n         * Returns an object containing the address information for a socket.\n         * For UDP sockets, this object will contain `address`, `family`, and `port` properties.\n         *\n         * This method throws `EBADF` if called on an unbound socket.\n         * @since v0.1.99\n         */\n        address(): AddressInfo;\n        /**\n         * For UDP sockets, causes the `dgram.Socket` to listen for datagram\n         * messages on a named `port` and optional `address`. If `port` is not\n         * specified or is `0`, the operating system will attempt to bind to a\n         * random port. If `address` is not specified, the operating system will\n         * attempt to listen on all addresses. Once binding is complete, a `'listening'` event is emitted and the optional `callback` function is\n         * called.\n         *\n         * Specifying both a `'listening'` event listener and passing a `callback` to the `socket.bind()` method is not harmful but not very\n         * useful.\n         *\n         * A bound datagram socket keeps the Node.js process running to receive\n         * datagram messages.\n         *\n         * If binding fails, an `'error'` event is generated. In rare case (e.g.\n         * attempting to bind with a closed socket), an `Error` may be thrown.\n         *\n         * Example of a UDP server listening on port 41234:\n         *\n         * ```js\n         * import dgram from 'node:dgram';\n         *\n         * const server = dgram.createSocket('udp4');\n         *\n         * server.on('error', (err) => {\n         *   console.error(`server error:\\n${err.stack}`);\n         *   server.close();\n         * });\n         *\n         * server.on('message', (msg, rinfo) => {\n         *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n         * });\n         *\n         * server.on('listening', () => {\n         *   const address = server.address();\n         *   console.log(`server listening ${address.address}:${address.port}`);\n         * });\n         *\n         * server.bind(41234);\n         * // Prints: server listening 0.0.0.0:41234\n         * ```\n         * @since v0.1.99\n         * @param callback with no parameters. Called when binding is complete.\n         */\n        bind(port?: number, address?: string, callback?: () => void): this;\n        bind(port?: number, callback?: () => void): this;\n        bind(callback?: () => void): this;\n        bind(options: BindOptions, callback?: () => void): this;\n        /**\n         * Close the underlying socket and stop listening for data on it. If a callback is\n         * provided, it is added as a listener for the `'close'` event.\n         * @since v0.1.99\n         * @param callback Called when the socket has been closed.\n         */\n        close(callback?: () => void): this;\n        /**\n         * Associates the `dgram.Socket` to a remote address and port. Every\n         * message sent by this handle is automatically sent to that destination. Also,\n         * the socket will only receive messages from that remote peer.\n         * Trying to call `connect()` on an already connected socket will result\n         * in an `ERR_SOCKET_DGRAM_IS_CONNECTED` exception. If `address` is not\n         * provided, `'127.0.0.1'` (for `udp4` sockets) or `'::1'` (for `udp6` sockets)\n         * will be used by default. Once the connection is complete, a `'connect'` event\n         * is emitted and the optional `callback` function is called. In case of failure,\n         * the `callback` is called or, failing this, an `'error'` event is emitted.\n         * @since v12.0.0\n         * @param callback Called when the connection is completed or on error.\n         */\n        connect(port: number, address?: string, callback?: () => void): void;\n        connect(port: number, callback: () => void): void;\n        /**\n         * A synchronous function that disassociates a connected `dgram.Socket` from\n         * its remote address. Trying to call `disconnect()` on an unbound or already\n         * disconnected socket will result in an `ERR_SOCKET_DGRAM_NOT_CONNECTED` exception.\n         * @since v12.0.0\n         */\n        disconnect(): void;\n        /**\n         * Instructs the kernel to leave a multicast group at `multicastAddress` using the `IP_DROP_MEMBERSHIP` socket option. This method is automatically called by the\n         * kernel when the socket is closed or the process terminates, so most apps will\n         * never have reason to call this.\n         *\n         * If `multicastInterface` is not specified, the operating system will attempt to\n         * drop membership on all valid interfaces.\n         * @since v0.6.9\n         */\n        dropMembership(multicastAddress: string, multicastInterface?: string): void;\n        /**\n         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.\n         * @since v8.7.0\n         * @return the `SO_RCVBUF` socket receive buffer size in bytes.\n         */\n        getRecvBufferSize(): number;\n        /**\n         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.\n         * @since v8.7.0\n         * @return the `SO_SNDBUF` socket send buffer size in bytes.\n         */\n        getSendBufferSize(): number;\n        /**\n         * @since v18.8.0, v16.19.0\n         * @return Number of bytes queued for sending.\n         */\n        getSendQueueSize(): number;\n        /**\n         * @since v18.8.0, v16.19.0\n         * @return Number of send requests currently in the queue awaiting to be processed.\n         */\n        getSendQueueCount(): number;\n        /**\n         * By default, binding a socket will cause it to block the Node.js process from\n         * exiting as long as the socket is open. The `socket.unref()` method can be used\n         * to exclude the socket from the reference counting that keeps the Node.js\n         * process active. The `socket.ref()` method adds the socket back to the reference\n         * counting and restores the default behavior.\n         *\n         * Calling `socket.ref()` multiples times will have no additional effect.\n         *\n         * The `socket.ref()` method returns a reference to the socket so calls can be\n         * chained.\n         * @since v0.9.1\n         */\n        ref(): this;\n        /**\n         * Returns an object containing the `address`, `family`, and `port` of the remote\n         * endpoint. This method throws an `ERR_SOCKET_DGRAM_NOT_CONNECTED` exception\n         * if the socket is not connected.\n         * @since v12.0.0\n         */\n        remoteAddress(): AddressInfo;\n        /**\n         * Broadcasts a datagram on the socket.\n         * For connectionless sockets, the destination `port` and `address` must be\n         * specified. Connected sockets, on the other hand, will use their associated\n         * remote endpoint, so the `port` and `address` arguments must not be set.\n         *\n         * The `msg` argument contains the message to be sent.\n         * Depending on its type, different behavior can apply. If `msg` is a `Buffer`,\n         * any `TypedArray` or a `DataView`,\n         * the `offset` and `length` specify the offset within the `Buffer` where the\n         * message begins and the number of bytes in the message, respectively.\n         * If `msg` is a `String`, then it is automatically converted to a `Buffer` with `'utf8'` encoding. With messages that\n         * contain multi-byte characters, `offset` and `length` will be calculated with\n         * respect to `byte length` and not the character position.\n         * If `msg` is an array, `offset` and `length` must not be specified.\n         *\n         * The `address` argument is a string. If the value of `address` is a host name,\n         * DNS will be used to resolve the address of the host. If `address` is not\n         * provided or otherwise nullish, `'127.0.0.1'` (for `udp4` sockets) or `'::1'` (for `udp6` sockets) will be used by default.\n         *\n         * If the socket has not been previously bound with a call to `bind`, the socket\n         * is assigned a random port number and is bound to the \"all interfaces\" address\n         * (`'0.0.0.0'` for `udp4` sockets, `'::0'` for `udp6` sockets.)\n         *\n         * An optional `callback` function may be specified to as a way of reporting\n         * DNS errors or for determining when it is safe to reuse the `buf` object.\n         * DNS lookups delay the time to send for at least one tick of the\n         * Node.js event loop.\n         *\n         * The only way to know for sure that the datagram has been sent is by using a `callback`. If an error occurs and a `callback` is given, the error will be\n         * passed as the first argument to the `callback`. If a `callback` is not given,\n         * the error is emitted as an `'error'` event on the `socket` object.\n         *\n         * Offset and length are optional but both _must_ be set if either are used.\n         * They are supported only when the first argument is a `Buffer`, a `TypedArray`,\n         * or a `DataView`.\n         *\n         * This method throws `ERR_SOCKET_BAD_PORT` if called on an unbound socket.\n         *\n         * Example of sending a UDP packet to a port on `localhost`;\n         *\n         * ```js\n         * import dgram from 'node:dgram';\n         * import { Buffer } from 'node:buffer';\n         *\n         * const message = Buffer.from('Some bytes');\n         * const client = dgram.createSocket('udp4');\n         * client.send(message, 41234, 'localhost', (err) => {\n         *   client.close();\n         * });\n         * ```\n         *\n         * Example of sending a UDP packet composed of multiple buffers to a port on`127.0.0.1`;\n         *\n         * ```js\n         * import dgram from 'node:dgram';\n         * import { Buffer } from 'node:buffer';\n         *\n         * const buf1 = Buffer.from('Some ');\n         * const buf2 = Buffer.from('bytes');\n         * const client = dgram.createSocket('udp4');\n         * client.send([buf1, buf2], 41234, (err) => {\n         *   client.close();\n         * });\n         * ```\n         *\n         * Sending multiple buffers might be faster or slower depending on the\n         * application and operating system. Run benchmarks to\n         * determine the optimal strategy on a case-by-case basis. Generally speaking,\n         * however, sending multiple buffers is faster.\n         *\n         * Example of sending a UDP packet using a socket connected to a port on `localhost`:\n         *\n         * ```js\n         * import dgram from 'node:dgram';\n         * import { Buffer } from 'node:buffer';\n         *\n         * const message = Buffer.from('Some bytes');\n         * const client = dgram.createSocket('udp4');\n         * client.connect(41234, 'localhost', (err) => {\n         *   client.send(message, (err) => {\n         *     client.close();\n         *   });\n         * });\n         * ```\n         * @since v0.1.99\n         * @param msg Message to be sent.\n         * @param offset Offset in the buffer where the message starts.\n         * @param length Number of bytes in the message.\n         * @param port Destination port.\n         * @param address Destination host name or IP address.\n         * @param callback Called when the message has been sent.\n         */\n        send(\n            msg: string | NodeJS.ArrayBufferView | readonly any[],\n            port?: number,\n            address?: string,\n            callback?: (error: Error | null, bytes: number) => void,\n        ): void;\n        send(\n            msg: string | NodeJS.ArrayBufferView | readonly any[],\n            port?: number,\n            callback?: (error: Error | null, bytes: number) => void,\n        ): void;\n        send(\n            msg: string | NodeJS.ArrayBufferView | readonly any[],\n            callback?: (error: Error | null, bytes: number) => void,\n        ): void;\n        send(\n            msg: string | NodeJS.ArrayBufferView,\n            offset: number,\n            length: number,\n            port?: number,\n            address?: string,\n            callback?: (error: Error | null, bytes: number) => void,\n        ): void;\n        send(\n            msg: string | NodeJS.ArrayBufferView,\n            offset: number,\n            length: number,\n            port?: number,\n            callback?: (error: Error | null, bytes: number) => void,\n        ): void;\n        send(\n            msg: string | NodeJS.ArrayBufferView,\n            offset: number,\n            length: number,\n            callback?: (error: Error | null, bytes: number) => void,\n        ): void;\n        /**\n         * Sets or clears the `SO_BROADCAST` socket option. When set to `true`, UDP\n         * packets may be sent to a local interface's broadcast address.\n         *\n         * This method throws `EBADF` if called on an unbound socket.\n         * @since v0.6.9\n         */\n        setBroadcast(flag: boolean): void;\n        /**\n         * _All references to scope in this section are referring to [IPv6 Zone Indices](https://en.wikipedia.org/wiki/IPv6_address#Scoped_literal_IPv6_addresses), which are defined by [RFC\n         * 4007](https://tools.ietf.org/html/rfc4007). In string form, an IP_\n         * _with a scope index is written as `'IP%scope'` where scope is an interface name_\n         * _or interface number._\n         *\n         * Sets the default outgoing multicast interface of the socket to a chosen\n         * interface or back to system interface selection. The `multicastInterface` must\n         * be a valid string representation of an IP from the socket's family.\n         *\n         * For IPv4 sockets, this should be the IP configured for the desired physical\n         * interface. All packets sent to multicast on the socket will be sent on the\n         * interface determined by the most recent successful use of this call.\n         *\n         * For IPv6 sockets, `multicastInterface` should include a scope to indicate the\n         * interface as in the examples that follow. In IPv6, individual `send` calls can\n         * also use explicit scope in addresses, so only packets sent to a multicast\n         * address without specifying an explicit scope are affected by the most recent\n         * successful use of this call.\n         *\n         * This method throws `EBADF` if called on an unbound socket.\n         *\n         * #### Example: IPv6 outgoing multicast interface\n         *\n         * On most systems, where scope format uses the interface name:\n         *\n         * ```js\n         * const socket = dgram.createSocket('udp6');\n         *\n         * socket.bind(1234, () => {\n         *   socket.setMulticastInterface('::%eth1');\n         * });\n         * ```\n         *\n         * On Windows, where scope format uses an interface number:\n         *\n         * ```js\n         * const socket = dgram.createSocket('udp6');\n         *\n         * socket.bind(1234, () => {\n         *   socket.setMulticastInterface('::%2');\n         * });\n         * ```\n         *\n         * #### Example: IPv4 outgoing multicast interface\n         *\n         * All systems use an IP of the host on the desired physical interface:\n         *\n         * ```js\n         * const socket = dgram.createSocket('udp4');\n         *\n         * socket.bind(1234, () => {\n         *   socket.setMulticastInterface('10.0.0.2');\n         * });\n         * ```\n         * @since v8.6.0\n         */\n        setMulticastInterface(multicastInterface: string): void;\n        /**\n         * Sets or clears the `IP_MULTICAST_LOOP` socket option. When set to `true`,\n         * multicast packets will also be received on the local interface.\n         *\n         * This method throws `EBADF` if called on an unbound socket.\n         * @since v0.3.8\n         */\n        setMulticastLoopback(flag: boolean): boolean;\n        /**\n         * Sets the `IP_MULTICAST_TTL` socket option. While TTL generally stands for\n         * \"Time to Live\", in this context it specifies the number of IP hops that a\n         * packet is allowed to travel through, specifically for multicast traffic. Each\n         * router or gateway that forwards a packet decrements the TTL. If the TTL is\n         * decremented to 0 by a router, it will not be forwarded.\n         *\n         * The `ttl` argument may be between 0 and 255\\. The default on most systems is `1`.\n         *\n         * This method throws `EBADF` if called on an unbound socket.\n         * @since v0.3.8\n         */\n        setMulticastTTL(ttl: number): number;\n        /**\n         * Sets the `SO_RCVBUF` socket option. Sets the maximum socket receive buffer\n         * in bytes.\n         *\n         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.\n         * @since v8.7.0\n         */\n        setRecvBufferSize(size: number): void;\n        /**\n         * Sets the `SO_SNDBUF` socket option. Sets the maximum socket send buffer\n         * in bytes.\n         *\n         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.\n         * @since v8.7.0\n         */\n        setSendBufferSize(size: number): void;\n        /**\n         * Sets the `IP_TTL` socket option. While TTL generally stands for \"Time to Live\",\n         * in this context it specifies the number of IP hops that a packet is allowed to\n         * travel through. Each router or gateway that forwards a packet decrements the\n         * TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.\n         * Changing TTL values is typically done for network probes or when multicasting.\n         *\n         * The `ttl` argument may be between 1 and 255\\. The default on most systems\n         * is 64.\n         *\n         * This method throws `EBADF` if called on an unbound socket.\n         * @since v0.1.101\n         */\n        setTTL(ttl: number): number;\n        /**\n         * By default, binding a socket will cause it to block the Node.js process from\n         * exiting as long as the socket is open. The `socket.unref()` method can be used\n         * to exclude the socket from the reference counting that keeps the Node.js\n         * process active, allowing the process to exit even if the socket is still\n         * listening.\n         *\n         * Calling `socket.unref()` multiple times will have no additional effect.\n         *\n         * The `socket.unref()` method returns a reference to the socket so calls can be\n         * chained.\n         * @since v0.9.1\n         */\n        unref(): this;\n        /**\n         * Tells the kernel to join a source-specific multicast channel at the given `sourceAddress` and `groupAddress`, using the `multicastInterface` with the `IP_ADD_SOURCE_MEMBERSHIP` socket\n         * option. If the `multicastInterface` argument\n         * is not specified, the operating system will choose one interface and will add\n         * membership to it. To add membership to every available interface, call `socket.addSourceSpecificMembership()` multiple times, once per interface.\n         *\n         * When called on an unbound socket, this method will implicitly bind to a random\n         * port, listening on all interfaces.\n         * @since v13.1.0, v12.16.0\n         */\n        addSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;\n        /**\n         * Instructs the kernel to leave a source-specific multicast channel at the given `sourceAddress` and `groupAddress` using the `IP_DROP_SOURCE_MEMBERSHIP` socket option. This method is\n         * automatically called by the kernel when the\n         * socket is closed or the process terminates, so most apps will never have\n         * reason to call this.\n         *\n         * If `multicastInterface` is not specified, the operating system will attempt to\n         * drop membership on all valid interfaces.\n         * @since v13.1.0, v12.16.0\n         */\n        dropSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. connect\n         * 3. error\n         * 4. listening\n         * 5. message\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connect\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(event: \"message\", msg: Buffer, rinfo: RemoteInfo): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connect\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connect\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"message\", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;\n        /**\n         * Calls `socket.close()` and returns a promise that fulfills when the socket has closed.\n         * @since v20.5.0\n         */\n        [Symbol.asyncDispose](): Promise<void>;\n    }\n}\ndeclare module \"node:dgram\" {\n    export * from \"dgram\";\n}\n"
        }
    ]
}