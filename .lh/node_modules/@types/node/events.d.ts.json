{
    "sourceFile": "node_modules/@types/node/events.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Much of the Node.js core API is built around an idiomatic asynchronous\n * event-driven architecture in which certain kinds of objects (called \"emitters\")\n * emit named events that cause `Function` objects (\"listeners\") to be called.\n *\n * For instance: a `net.Server` object emits an event each time a peer\n * connects to it; a `fs.ReadStream` emits an event when the file is opened;\n * a `stream` emits an event whenever data is available to be read.\n *\n * All objects that emit events are instances of the `EventEmitter` class. These\n * objects expose an `eventEmitter.on()` function that allows one or more\n * functions to be attached to named events emitted by the object. Typically,\n * event names are camel-cased strings but any valid JavaScript property key\n * can be used.\n *\n * When the `EventEmitter` object emits an event, all of the functions attached\n * to that specific event are called _synchronously_. Any values returned by the\n * called listeners are _ignored_ and discarded.\n *\n * The following example shows a simple `EventEmitter` instance with a single\n * listener. The `eventEmitter.on()` method is used to register listeners, while\n * the `eventEmitter.emit()` method is used to trigger the event.\n *\n * ```js\n * import { EventEmitter } from 'node:events';\n *\n * class MyEmitter extends EventEmitter {}\n *\n * const myEmitter = new MyEmitter();\n * myEmitter.on('event', () => {\n *   console.log('an event occurred!');\n * });\n * myEmitter.emit('event');\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/events.js)\n */\ndeclare module \"events\" {\n    import { AsyncResource, AsyncResourceOptions } from \"node:async_hooks\";\n    // NOTE: This class is in the docs but is **not actually exported** by Node.\n    // If https://github.com/nodejs/node/issues/39903 gets resolved and Node\n    // actually starts exporting the class, uncomment below.\n    // import { EventListener, EventListenerObject } from '__dom-events';\n    // /** The NodeEventTarget is a Node.js-specific extension to EventTarget that emulates a subset of the EventEmitter API. */\n    // interface NodeEventTarget extends EventTarget {\n    //     /**\n    //      * Node.js-specific extension to the `EventTarget` class that emulates the equivalent `EventEmitter` API.\n    //      * The only difference between `addListener()` and `addEventListener()` is that addListener() will return a reference to the EventTarget.\n    //      */\n    //     addListener(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;\n    //     /** Node.js-specific extension to the `EventTarget` class that returns an array of event `type` names for which event listeners are registered. */\n    //     eventNames(): string[];\n    //     /** Node.js-specific extension to the `EventTarget` class that returns the number of event listeners registered for the `type`. */\n    //     listenerCount(type: string): number;\n    //     /** Node.js-specific alias for `eventTarget.removeListener()`. */\n    //     off(type: string, listener: EventListener | EventListenerObject): this;\n    //     /** Node.js-specific alias for `eventTarget.addListener()`. */\n    //     on(type: string, listener: EventListener | EventListenerObject, options?: { once: boolean }): this;\n    //     /** Node.js-specific extension to the `EventTarget` class that adds a `once` listener for the given event `type`. This is equivalent to calling `on` with the `once` option set to `true`. */\n    //     once(type: string, listener: EventListener | EventListenerObject): this;\n    //     /**\n    //      * Node.js-specific extension to the `EventTarget` class.\n    //      * If `type` is specified, removes all registered listeners for `type`,\n    //      * otherwise removes all registered listeners.\n    //      */\n    //     removeAllListeners(type: string): this;\n    //     /**\n    //      * Node.js-specific extension to the `EventTarget` class that removes the listener for the given `type`.\n    //      * The only difference between `removeListener()` and `removeEventListener()` is that `removeListener()` will return a reference to the `EventTarget`.\n    //      */\n    //     removeListener(type: string, listener: EventListener | EventListenerObject): this;\n    // }\n    interface EventEmitterOptions {\n        /**\n         * Enables automatic capturing of promise rejection.\n         */\n        captureRejections?: boolean | undefined;\n    }\n    interface StaticEventEmitterOptions {\n        /**\n         * Can be used to cancel awaiting events.\n         */\n        signal?: AbortSignal | undefined;\n    }\n    interface StaticEventEmitterIteratorOptions extends StaticEventEmitterOptions {\n        /**\n         * Names of events that will end the iteration.\n         */\n        close?: string[] | undefined;\n        /**\n         * The high watermark. The emitter is paused every time the size of events being buffered is higher than it.\n         * Supported only on emitters implementing `pause()` and `resume()` methods.\n         * @default Number.MAX_SAFE_INTEGER\n         */\n        highWaterMark?: number | undefined;\n        /**\n         * The low watermark. The emitter is resumed every time the size of events being buffered is lower than it.\n         * Supported only on emitters implementing `pause()` and `resume()` methods.\n         * @default 1\n         */\n        lowWaterMark?: number | undefined;\n    }\n    interface EventEmitter<T extends EventMap<T> = DefaultEventMap> extends NodeJS.EventEmitter<T> {}\n    type EventMap<T> = Record<keyof T, any[]> | DefaultEventMap;\n    type DefaultEventMap = [never];\n    type AnyRest = [...args: any[]];\n    type Args<K, T> = T extends DefaultEventMap ? AnyRest : (\n        K extends keyof T ? T[K] : never\n    );\n    type Key<K, T> = T extends DefaultEventMap ? string | symbol : K | keyof T;\n    type Key2<K, T> = T extends DefaultEventMap ? string | symbol : K & keyof T;\n    type Listener<K, T, F> = T extends DefaultEventMap ? F : (\n        K extends keyof T ? (\n                T[K] extends unknown[] ? (...args: T[K]) => void : never\n            )\n            : never\n    );\n    type Listener1<K, T> = Listener<K, T, (...args: any[]) => void>;\n    type Listener2<K, T> = Listener<K, T, Function>;\n\n    /**\n     * The `EventEmitter` class is defined and exposed by the `node:events` module:\n     *\n     * ```js\n     * import { EventEmitter } from 'node:events';\n     * ```\n     *\n     * All `EventEmitter`s emit the event `'newListener'` when new listeners are\n     * added and `'removeListener'` when existing listeners are removed.\n     *\n     * It supports the following option:\n     * @since v0.1.26\n     */\n    class EventEmitter<T extends EventMap<T> = DefaultEventMap> {\n        constructor(options?: EventEmitterOptions);\n\n        [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;\n\n        /**\n         * Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\n         * event or that is rejected if the `EventEmitter` emits `'error'` while waiting.\n         * The `Promise` will resolve with an array of all the arguments emitted to the\n         * given event.\n         *\n         * This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\n         * semantics and does not listen to the `'error'` event.\n         *\n         * ```js\n         * import { once, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ee = new EventEmitter();\n         *\n         * process.nextTick(() => {\n         *   ee.emit('myevent', 42);\n         * });\n         *\n         * const [value] = await once(ee, 'myevent');\n         * console.log(value);\n         *\n         * const err = new Error('kaboom');\n         * process.nextTick(() => {\n         *   ee.emit('error', err);\n         * });\n         *\n         * try {\n         *   await once(ee, 'myevent');\n         * } catch (err) {\n         *   console.error('error happened', err);\n         * }\n         * ```\n         *\n         * The special handling of the `'error'` event is only used when `events.once()` is used to wait for another event. If `events.once()` is used to wait for the\n         * '`error'` event itself, then it is treated as any other kind of event without\n         * special handling:\n         *\n         * ```js\n         * import { EventEmitter, once } from 'node:events';\n         *\n         * const ee = new EventEmitter();\n         *\n         * once(ee, 'error')\n         *   .then(([err]) => console.log('ok', err.message))\n         *   .catch((err) => console.error('error', err.message));\n         *\n         * ee.emit('error', new Error('boom'));\n         *\n         * // Prints: ok boom\n         * ```\n         *\n         * An `AbortSignal` can be used to cancel waiting for the event:\n         *\n         * ```js\n         * import { EventEmitter, once } from 'node:events';\n         *\n         * const ee = new EventEmitter();\n         * const ac = new AbortController();\n         *\n         * async function foo(emitter, event, signal) {\n         *   try {\n         *     await once(emitter, event, { signal });\n         *     console.log('event emitted!');\n         *   } catch (error) {\n         *     if (error.name === 'AbortError') {\n         *       console.error('Waiting for the event was canceled!');\n         *     } else {\n         *       console.error('There was an error', error.message);\n         *     }\n         *   }\n         * }\n         *\n         * foo(ee, 'foo', ac.signal);\n         * ac.abort(); // Abort waiting for the event\n         * ee.emit('foo'); // Prints: Waiting for the event was canceled!\n         * ```\n         * @since v11.13.0, v10.16.0\n         */\n        static once(\n            emitter: NodeJS.EventEmitter,\n            eventName: string | symbol,\n            options?: StaticEventEmitterOptions,\n        ): Promise<any[]>;\n        static once(emitter: EventTarget, eventName: string, options?: StaticEventEmitterOptions): Promise<any[]>;\n        /**\n         * ```js\n         * import { on, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ee = new EventEmitter();\n         *\n         * // Emit later on\n         * process.nextTick(() => {\n         *   ee.emit('foo', 'bar');\n         *   ee.emit('foo', 42);\n         * });\n         *\n         * for await (const event of on(ee, 'foo')) {\n         *   // The execution of this inner block is synchronous and it\n         *   // processes one event at a time (even with await). Do not use\n         *   // if concurrent execution is required.\n         *   console.log(event); // prints ['bar'] [42]\n         * }\n         * // Unreachable here\n         * ```\n         *\n         * Returns an `AsyncIterator` that iterates `eventName` events. It will throw\n         * if the `EventEmitter` emits `'error'`. It removes all listeners when\n         * exiting the loop. The `value` returned by each iteration is an array\n         * composed of the emitted event arguments.\n         *\n         * An `AbortSignal` can be used to cancel waiting on events:\n         *\n         * ```js\n         * import { on, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ac = new AbortController();\n         *\n         * (async () => {\n         *   const ee = new EventEmitter();\n         *\n         *   // Emit later on\n         *   process.nextTick(() => {\n         *     ee.emit('foo', 'bar');\n         *     ee.emit('foo', 42);\n         *   });\n         *\n         *   for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n         *     // The execution of this inner block is synchronous and it\n         *     // processes one event at a time (even with await). Do not use\n         *     // if concurrent execution is required.\n         *     console.log(event); // prints ['bar'] [42]\n         *   }\n         *   // Unreachable here\n         * })();\n         *\n         * process.nextTick(() => ac.abort());\n         * ```\n         *\n         * Use the `close` option to specify an array of event names that will end the iteration:\n         *\n         * ```js\n         * import { on, EventEmitter } from 'node:events';\n         * import process from 'node:process';\n         *\n         * const ee = new EventEmitter();\n         *\n         * // Emit later on\n         * process.nextTick(() => {\n         *   ee.emit('foo', 'bar');\n         *   ee.emit('foo', 42);\n         *   ee.emit('close');\n         * });\n         *\n         * for await (const event of on(ee, 'foo', { close: ['close'] })) {\n         *   console.log(event); // prints ['bar'] [42]\n         * }\n         * // the loop will exit after 'close' is emitted\n         * console.log('done'); // prints 'done'\n         * ```\n         * @since v13.6.0, v12.16.0\n         * @return An `AsyncIterator` that iterates `eventName` events emitted by the `emitter`\n         */\n        static on(\n            emitter: NodeJS.EventEmitter,\n            eventName: string | symbol,\n            options?: StaticEventEmitterIteratorOptions,\n        ): NodeJS.AsyncIterator<any[]>;\n        static on(\n            emitter: EventTarget,\n            eventName: string,\n            options?: StaticEventEmitterIteratorOptions,\n        ): NodeJS.AsyncIterator<any[]>;\n        /**\n         * A class method that returns the number of listeners for the given `eventName` registered on the given `emitter`.\n         *\n         * ```js\n         * import { EventEmitter, listenerCount } from 'node:events';\n         *\n         * const myEmitter = new EventEmitter();\n         * myEmitter.on('event', () => {});\n         * myEmitter.on('event', () => {});\n         * console.log(listenerCount(myEmitter, 'event'));\n         * // Prints: 2\n         * ```\n         * @since v0.9.12\n         * @deprecated Since v3.2.0 - Use `listenerCount` instead.\n         * @param emitter The emitter to query\n         * @param eventName The event name\n         */\n        static listenerCount(emitter: NodeJS.EventEmitter, eventName: string | symbol): number;\n        /**\n         * Returns a copy of the array of listeners for the event named `eventName`.\n         *\n         * For `EventEmitter`s this behaves exactly the same as calling `.listeners` on\n         * the emitter.\n         *\n         * For `EventTarget`s this is the only way to get the event listeners for the\n         * event target. This is useful for debugging and diagnostic purposes.\n         *\n         * ```js\n         * import { getEventListeners, EventEmitter } from 'node:events';\n         *\n         * {\n         *   const ee = new EventEmitter();\n         *   const listener = () => console.log('Events are fun');\n         *   ee.on('foo', listener);\n         *   console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]\n         * }\n         * {\n         *   const et = new EventTarget();\n         *   const listener = () => console.log('Events are fun');\n         *   et.addEventListener('foo', listener);\n         *   console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]\n         * }\n         * ```\n         * @since v15.2.0, v14.17.0\n         */\n        static getEventListeners(emitter: EventTarget | NodeJS.EventEmitter, name: string | symbol): Function[];\n        /**\n         * Returns the currently set max amount of listeners.\n         *\n         * For `EventEmitter`s this behaves exactly the same as calling `.getMaxListeners` on\n         * the emitter.\n         *\n         * For `EventTarget`s this is the only way to get the max event listeners for the\n         * event target. If the number of event handlers on a single EventTarget exceeds\n         * the max set, the EventTarget will print a warning.\n         *\n         * ```js\n         * import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events';\n         *\n         * {\n         *   const ee = new EventEmitter();\n         *   console.log(getMaxListeners(ee)); // 10\n         *   setMaxListeners(11, ee);\n         *   console.log(getMaxListeners(ee)); // 11\n         * }\n         * {\n         *   const et = new EventTarget();\n         *   console.log(getMaxListeners(et)); // 10\n         *   setMaxListeners(11, et);\n         *   console.log(getMaxListeners(et)); // 11\n         * }\n         * ```\n         * @since v19.9.0\n         */\n        static getMaxListeners(emitter: EventTarget | NodeJS.EventEmitter): number;\n        /**\n         * ```js\n         * import { setMaxListeners, EventEmitter } from 'node:events';\n         *\n         * const target = new EventTarget();\n         * const emitter = new EventEmitter();\n         *\n         * setMaxListeners(5, target, emitter);\n         * ```\n         * @since v15.4.0\n         * @param n A non-negative number. The maximum number of listeners per `EventTarget` event.\n         * @param eventTargets Zero or more {EventTarget} or {EventEmitter} instances. If none are specified, `n` is set as the default max for all newly created {EventTarget} and {EventEmitter}\n         * objects.\n         */\n        static setMaxListeners(n?: number, ...eventTargets: Array<EventTarget | NodeJS.EventEmitter>): void;\n        /**\n         * Listens once to the `abort` event on the provided `signal`.\n         *\n         * Listening to the `abort` event on abort signals is unsafe and may\n         * lead to resource leaks since another third party with the signal can\n         * call `e.stopImmediatePropagation()`. Unfortunately Node.js cannot change\n         * this since it would violate the web standard. Additionally, the original\n         * API makes it easy to forget to remove listeners.\n         *\n         * This API allows safely using `AbortSignal`s in Node.js APIs by solving these\n         * two issues by listening to the event such that `stopImmediatePropagation` does\n         * not prevent the listener from running.\n         *\n         * Returns a disposable so that it may be unsubscribed from more easily.\n         *\n         * ```js\n         * import { addAbortListener } from 'node:events';\n         *\n         * function example(signal) {\n         *   let disposable;\n         *   try {\n         *     signal.addEventListener('abort', (e) => e.stopImmediatePropagation());\n         *     disposable = addAbortListener(signal, (e) => {\n         *       // Do something when signal is aborted.\n         *     });\n         *   } finally {\n         *     disposable?.[Symbol.dispose]();\n         *   }\n         * }\n         * ```\n         * @since v20.5.0\n         * @experimental\n         * @return Disposable that removes the `abort` listener.\n         */\n        static addAbortListener(signal: AbortSignal, resource: (event: Event) => void): Disposable;\n        /**\n         * This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n         *\n         * Installing a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\n         * regular `'error'` listener is installed.\n         * @since v13.6.0, v12.17.0\n         */\n        static readonly errorMonitor: unique symbol;\n        /**\n         * Value: `Symbol.for('nodejs.rejection')`\n         *\n         * See how to write a custom `rejection handler`.\n         * @since v13.4.0, v12.16.0\n         */\n        static readonly captureRejectionSymbol: unique symbol;\n        /**\n         * Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n         *\n         * Change the default `captureRejections` option on all new `EventEmitter` objects.\n         * @since v13.4.0, v12.16.0\n         */\n        static captureRejections: boolean;\n        /**\n         * By default, a maximum of `10` listeners can be registered for any single\n         * event. This limit can be changed for individual `EventEmitter` instances\n         * using the `emitter.setMaxListeners(n)` method. To change the default\n         * for _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\n         * can be used. If this value is not a positive number, a `RangeError` is thrown.\n         *\n         * Take caution when setting the `events.defaultMaxListeners` because the\n         * change affects _all_ `EventEmitter` instances, including those created before\n         * the change is made. However, calling `emitter.setMaxListeners(n)` still has\n         * precedence over `events.defaultMaxListeners`.\n         *\n         * This is not a hard limit. The `EventEmitter` instance will allow\n         * more listeners to be added but will output a trace warning to stderr indicating\n         * that a \"possible EventEmitter memory leak\" has been detected. For any single\n         * `EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\n         * temporarily avoid this warning:\n         *\n         * ```js\n         * import { EventEmitter } from 'node:events';\n         * const emitter = new EventEmitter();\n         * emitter.setMaxListeners(emitter.getMaxListeners() + 1);\n         * emitter.once('event', () => {\n         *   // do stuff\n         *   emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n         * });\n         * ```\n         *\n         * The `--trace-warnings` command-line flag can be used to display the\n         * stack trace for such warnings.\n         *\n         * The emitted warning can be inspected with `process.on('warning')` and will\n         * have the additional `emitter`, `type`, and `count` properties, referring to\n         * the event emitter instance, the event's name and the number of attached\n         * listeners, respectively.\n         * Its `name` property is set to `'MaxListenersExceededWarning'`.\n         * @since v0.11.2\n         */\n        static defaultMaxListeners: number;\n    }\n    import internal = require(\"node:events\");\n    namespace EventEmitter {\n        // Should just be `export { EventEmitter }`, but that doesn't work in TypeScript 3.4\n        export { internal as EventEmitter };\n        export interface Abortable {\n            /**\n             * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.\n             */\n            signal?: AbortSignal | undefined;\n        }\n\n        export interface EventEmitterReferencingAsyncResource extends AsyncResource {\n            readonly eventEmitter: EventEmitterAsyncResource;\n        }\n\n        export interface EventEmitterAsyncResourceOptions extends AsyncResourceOptions, EventEmitterOptions {\n            /**\n             * The type of async event, this is required when instantiating `EventEmitterAsyncResource`\n             * directly rather than as a child class.\n             * @default new.target.name if instantiated as a child class.\n             */\n            name?: string;\n        }\n\n        /**\n         * Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\n         * require manual async tracking. Specifically, all events emitted by instances\n         * of `events.EventEmitterAsyncResource` will run within its `async context`.\n         *\n         * ```js\n         * import { EventEmitterAsyncResource, EventEmitter } from 'node:events';\n         * import { notStrictEqual, strictEqual } from 'node:assert';\n         * import { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n         *\n         * // Async tracking tooling will identify this as 'Q'.\n         * const ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n         *\n         * // 'foo' listeners will run in the EventEmitters async context.\n         * ee1.on('foo', () => {\n         *   strictEqual(executionAsyncId(), ee1.asyncId);\n         *   strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n         * });\n         *\n         * const ee2 = new EventEmitter();\n         *\n         * // 'foo' listeners on ordinary EventEmitters that do not track async\n         * // context, however, run in the same async context as the emit().\n         * ee2.on('foo', () => {\n         *   notStrictEqual(executionAsyncId(), ee2.asyncId);\n         *   notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n         * });\n         *\n         * Promise.resolve().then(() => {\n         *   ee1.emit('foo');\n         *   ee2.emit('foo');\n         * });\n         * ```\n         *\n         * The `EventEmitterAsyncResource` class has the same methods and takes the\n         * same options as `EventEmitter` and `AsyncResource` themselves.\n         * @since v17.4.0, v16.14.0\n         */\n        export class EventEmitterAsyncResource extends EventEmitter {\n            /**\n             * @param options Only optional in child class.\n             */\n            constructor(options?: EventEmitterAsyncResourceOptions);\n            /**\n             * Call all `destroy` hooks. This should only ever be called once. An error will\n             * be thrown if it is called more than once. This **must** be manually called. If\n             * the resource is left to be collected by the GC then the `destroy` hooks will\n             * never be called.\n             */\n            emitDestroy(): void;\n            /**\n             * The unique `asyncId` assigned to the resource.\n             */\n            readonly asyncId: number;\n            /**\n             * The same triggerAsyncId that is passed to the AsyncResource constructor.\n             */\n            readonly triggerAsyncId: number;\n            /**\n             * The returned `AsyncResource` object has an additional `eventEmitter` property\n             * that provides a reference to this `EventEmitterAsyncResource`.\n             */\n            readonly asyncResource: EventEmitterReferencingAsyncResource;\n        }\n    }\n    global {\n        namespace NodeJS {\n            interface EventEmitter<T extends EventMap<T> = DefaultEventMap> {\n                [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;\n                /**\n                 * Alias for `emitter.on(eventName, listener)`.\n                 * @since v0.1.26\n                 */\n                addListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Adds the `listener` function to the end of the listeners array for the event\n                 * named `eventName`. No checks are made to see if the `listener` has already\n                 * been added. Multiple calls passing the same combination of `eventName` and\n                 * `listener` will result in the `listener` being added, and called, multiple times.\n                 *\n                 * ```js\n                 * server.on('connection', (stream) => {\n                 *   console.log('someone connected!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 *\n                 * By default, event listeners are invoked in the order they are added. The `emitter.prependListener()` method can be used as an alternative to add the\n                 * event listener to the beginning of the listeners array.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const myEE = new EventEmitter();\n                 * myEE.on('foo', () => console.log('a'));\n                 * myEE.prependListener('foo', () => console.log('b'));\n                 * myEE.emit('foo');\n                 * // Prints:\n                 * //   b\n                 * //   a\n                 * ```\n                 * @since v0.1.101\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                on<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Adds a **one-time** `listener` function for the event named `eventName`. The\n                 * next time `eventName` is triggered, this listener is removed and then invoked.\n                 *\n                 * ```js\n                 * server.once('connection', (stream) => {\n                 *   console.log('Ah, we have our first user!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 *\n                 * By default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\n                 * event listener to the beginning of the listeners array.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const myEE = new EventEmitter();\n                 * myEE.once('foo', () => console.log('a'));\n                 * myEE.prependOnceListener('foo', () => console.log('b'));\n                 * myEE.emit('foo');\n                 * // Prints:\n                 * //   b\n                 * //   a\n                 * ```\n                 * @since v0.3.0\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                once<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Removes the specified `listener` from the listener array for the event named `eventName`.\n                 *\n                 * ```js\n                 * const callback = (stream) => {\n                 *   console.log('someone connected!');\n                 * };\n                 * server.on('connection', callback);\n                 * // ...\n                 * server.removeListener('connection', callback);\n                 * ```\n                 *\n                 * `removeListener()` will remove, at most, one instance of a listener from the\n                 * listener array. If any single listener has been added multiple times to the\n                 * listener array for the specified `eventName`, then `removeListener()` must be\n                 * called multiple times to remove each instance.\n                 *\n                 * Once an event is emitted, all listeners attached to it at the\n                 * time of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\n                 * will not remove them from`emit()` in progress. Subsequent events behave as expected.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * class MyEmitter extends EventEmitter {}\n                 * const myEmitter = new MyEmitter();\n                 *\n                 * const callbackA = () => {\n                 *   console.log('A');\n                 *   myEmitter.removeListener('event', callbackB);\n                 * };\n                 *\n                 * const callbackB = () => {\n                 *   console.log('B');\n                 * };\n                 *\n                 * myEmitter.on('event', callbackA);\n                 *\n                 * myEmitter.on('event', callbackB);\n                 *\n                 * // callbackA removes listener callbackB but it will still be called.\n                 * // Internal listener array at time of emit [callbackA, callbackB]\n                 * myEmitter.emit('event');\n                 * // Prints:\n                 * //   A\n                 * //   B\n                 *\n                 * // callbackB is now removed.\n                 * // Internal listener array [callbackA]\n                 * myEmitter.emit('event');\n                 * // Prints:\n                 * //   A\n                 * ```\n                 *\n                 * Because listeners are managed using an internal array, calling this will\n                 * change the position indices of any listener registered _after_ the listener\n                 * being removed. This will not impact the order in which listeners are called,\n                 * but it means that any copies of the listener array as returned by\n                 * the `emitter.listeners()` method will need to be recreated.\n                 *\n                 * When a single function has been added as a handler multiple times for a single\n                 * event (as in the example below), `removeListener()` will remove the most\n                 * recently added instance. In the example the `once('ping')` listener is removed:\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const ee = new EventEmitter();\n                 *\n                 * function pong() {\n                 *   console.log('pong');\n                 * }\n                 *\n                 * ee.on('ping', pong);\n                 * ee.once('ping', pong);\n                 * ee.removeListener('ping', pong);\n                 *\n                 * ee.emit('ping');\n                 * ee.emit('ping');\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v0.1.26\n                 */\n                removeListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Alias for `emitter.removeListener()`.\n                 * @since v10.0.0\n                 */\n                off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Removes all listeners, or those of the specified `eventName`.\n                 *\n                 * It is bad practice to remove listeners added elsewhere in the code,\n                 * particularly when the `EventEmitter` instance was created by some other\n                 * component or module (e.g. sockets or file streams).\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v0.1.26\n                 */\n                removeAllListeners(eventName?: Key<unknown, T>): this;\n                /**\n                 * By default `EventEmitter`s will print a warning if more than `10` listeners are\n                 * added for a particular event. This is a useful default that helps finding\n                 * memory leaks. The `emitter.setMaxListeners()` method allows the limit to be\n                 * modified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v0.3.5\n                 */\n                setMaxListeners(n: number): this;\n                /**\n                 * Returns the current max listener value for the `EventEmitter` which is either\n                 * set by `emitter.setMaxListeners(n)` or defaults to {@link EventEmitter.defaultMaxListeners}.\n                 * @since v1.0.0\n                 */\n                getMaxListeners(): number;\n                /**\n                 * Returns a copy of the array of listeners for the event named `eventName`.\n                 *\n                 * ```js\n                 * server.on('connection', (stream) => {\n                 *   console.log('someone connected!');\n                 * });\n                 * console.log(util.inspect(server.listeners('connection')));\n                 * // Prints: [ [Function] ]\n                 * ```\n                 * @since v0.1.26\n                 */\n                listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;\n                /**\n                 * Returns a copy of the array of listeners for the event named `eventName`,\n                 * including any wrappers (such as those created by `.once()`).\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const emitter = new EventEmitter();\n                 * emitter.once('log', () => console.log('log once'));\n                 *\n                 * // Returns a new Array with a function `onceWrapper` which has a property\n                 * // `listener` which contains the original listener bound above\n                 * const listeners = emitter.rawListeners('log');\n                 * const logFnWrapper = listeners[0];\n                 *\n                 * // Logs \"log once\" to the console and does not unbind the `once` event\n                 * logFnWrapper.listener();\n                 *\n                 * // Logs \"log once\" to the console and removes the listener\n                 * logFnWrapper();\n                 *\n                 * emitter.on('log', () => console.log('log persistently'));\n                 * // Will return a new Array with a single function bound by `.on()` above\n                 * const newListeners = emitter.rawListeners('log');\n                 *\n                 * // Logs \"log persistently\" twice\n                 * newListeners[0]();\n                 * emitter.emit('log');\n                 * ```\n                 * @since v9.4.0\n                 */\n                rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;\n                /**\n                 * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\n                 * to each.\n                 *\n                 * Returns `true` if the event had listeners, `false` otherwise.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 * const myEmitter = new EventEmitter();\n                 *\n                 * // First listener\n                 * myEmitter.on('event', function firstListener() {\n                 *   console.log('Helloooo! first listener');\n                 * });\n                 * // Second listener\n                 * myEmitter.on('event', function secondListener(arg1, arg2) {\n                 *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n                 * });\n                 * // Third listener\n                 * myEmitter.on('event', function thirdListener(...args) {\n                 *   const parameters = args.join(', ');\n                 *   console.log(`event with parameters ${parameters} in third listener`);\n                 * });\n                 *\n                 * console.log(myEmitter.listeners('event'));\n                 *\n                 * myEmitter.emit('event', 1, 2, 3, 4, 5);\n                 *\n                 * // Prints:\n                 * // [\n                 * //   [Function: firstListener],\n                 * //   [Function: secondListener],\n                 * //   [Function: thirdListener]\n                 * // ]\n                 * // Helloooo! first listener\n                 * // event with parameters 1, 2 in second listener\n                 * // event with parameters 1, 2, 3, 4, 5 in third listener\n                 * ```\n                 * @since v0.1.26\n                 */\n                emit<K>(eventName: Key<K, T>, ...args: Args<K, T>): boolean;\n                /**\n                 * Returns the number of listeners listening for the event named `eventName`.\n                 * If `listener` is provided, it will return how many times the listener is found\n                 * in the list of the listeners of the event.\n                 * @since v3.2.0\n                 * @param eventName The name of the event being listened for\n                 * @param listener The event handler function\n                 */\n                listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;\n                /**\n                 * Adds the `listener` function to the _beginning_ of the listeners array for the\n                 * event named `eventName`. No checks are made to see if the `listener` has\n                 * already been added. Multiple calls passing the same combination of `eventName`\n                 * and `listener` will result in the `listener` being added, and called, multiple times.\n                 *\n                 * ```js\n                 * server.prependListener('connection', (stream) => {\n                 *   console.log('someone connected!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v6.0.0\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                prependListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\n                 * listener is removed, and then invoked.\n                 *\n                 * ```js\n                 * server.prependOnceListener('connection', (stream) => {\n                 *   console.log('Ah, we have our first user!');\n                 * });\n                 * ```\n                 *\n                 * Returns a reference to the `EventEmitter`, so that calls can be chained.\n                 * @since v6.0.0\n                 * @param eventName The name of the event.\n                 * @param listener The callback function\n                 */\n                prependOnceListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;\n                /**\n                 * Returns an array listing the events for which the emitter has registered\n                 * listeners. The values in the array are strings or `Symbol`s.\n                 *\n                 * ```js\n                 * import { EventEmitter } from 'node:events';\n                 *\n                 * const myEE = new EventEmitter();\n                 * myEE.on('foo', () => {});\n                 * myEE.on('bar', () => {});\n                 *\n                 * const sym = Symbol('symbol');\n                 * myEE.on(sym, () => {});\n                 *\n                 * console.log(myEE.eventNames());\n                 * // Prints: [ 'foo', 'bar', Symbol(symbol) ]\n                 * ```\n                 * @since v6.0.0\n                 */\n                eventNames(): Array<(string | symbol) & Key2<unknown, T>>;\n            }\n        }\n    }\n    export = EventEmitter;\n}\ndeclare module \"node:events\" {\n    import events = require(\"events\");\n    export = events;\n}\n"
        }
    ]
}