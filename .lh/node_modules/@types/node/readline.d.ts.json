{
    "sourceFile": "node_modules/@types/node/readline.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:readline` module provides an interface for reading data from a [Readable](https://nodejs.org/docs/latest-v22.x/api/stream.html#readable-streams) stream\n * (such as [`process.stdin`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstdin)) one line at a time.\n *\n * To use the promise-based APIs:\n *\n * ```js\n * import * as readline from 'node:readline/promises';\n * ```\n *\n * To use the callback and sync APIs:\n *\n * ```js\n * import * as readline from 'node:readline';\n * ```\n *\n * The following simple example illustrates the basic use of the `node:readline` module.\n *\n * ```js\n * import * as readline from 'node:readline/promises';\n * import { stdin as input, stdout as output } from 'node:process';\n *\n * const rl = readline.createInterface({ input, output });\n *\n * const answer = await rl.question('What do you think of Node.js? ');\n *\n * console.log(`Thank you for your valuable feedback: ${answer}`);\n *\n * rl.close();\n * ```\n *\n * Once this code is invoked, the Node.js application will not terminate until the `readline.Interface` is closed because the interface waits for data to be\n * received on the `input` stream.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/readline.js)\n */\ndeclare module \"readline\" {\n    import { Abortable, EventEmitter } from \"node:events\";\n    import * as promises from \"node:readline/promises\";\n    export { promises };\n    export interface Key {\n        sequence?: string | undefined;\n        name?: string | undefined;\n        ctrl?: boolean | undefined;\n        meta?: boolean | undefined;\n        shift?: boolean | undefined;\n    }\n    /**\n     * Instances of the `readline.Interface` class are constructed using the `readline.createInterface()` method. Every instance is associated with a\n     * single `input` [Readable](https://nodejs.org/docs/latest-v22.x/api/stream.html#readable-streams) stream and a single `output` [Writable](https://nodejs.org/docs/latest-v22.x/api/stream.html#writable-streams) stream.\n     * The `output` stream is used to print prompts for user input that arrives on,\n     * and is read from, the `input` stream.\n     * @since v0.1.104\n     */\n    export class Interface extends EventEmitter implements Disposable {\n        readonly terminal: boolean;\n        /**\n         * The current input data being processed by node.\n         *\n         * This can be used when collecting input from a TTY stream to retrieve the\n         * current value that has been processed thus far, prior to the `line` event\n         * being emitted. Once the `line` event has been emitted, this property will\n         * be an empty string.\n         *\n         * Be aware that modifying the value during the instance runtime may have\n         * unintended consequences if `rl.cursor` is not also controlled.\n         *\n         * **If not using a TTY stream for input, use the `'line'` event.**\n         *\n         * One possible use case would be as follows:\n         *\n         * ```js\n         * const values = ['lorem ipsum', 'dolor sit amet'];\n         * const rl = readline.createInterface(process.stdin);\n         * const showResults = debounce(() => {\n         *   console.log(\n         *     '\\n',\n         *     values.filter((val) => val.startsWith(rl.line)).join(' '),\n         *   );\n         * }, 300);\n         * process.stdin.on('keypress', (c, k) => {\n         *   showResults();\n         * });\n         * ```\n         * @since v0.1.98\n         */\n        readonly line: string;\n        /**\n         * The cursor position relative to `rl.line`.\n         *\n         * This will track where the current cursor lands in the input string, when\n         * reading input from a TTY stream. The position of cursor determines the\n         * portion of the input string that will be modified as input is processed,\n         * as well as the column where the terminal caret will be rendered.\n         * @since v0.1.98\n         */\n        readonly cursor: number;\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of the `readline.Interface` class are constructed using the\n         * > `readline.createInterface()` method.\n         *\n         * @see https://nodejs.org/dist/latest-v22.x/docs/api/readline.html#class-interfaceconstructor\n         */\n        protected constructor(\n            input: NodeJS.ReadableStream,\n            output?: NodeJS.WritableStream,\n            completer?: Completer | AsyncCompleter,\n            terminal?: boolean,\n        );\n        /**\n         * NOTE: According to the documentation:\n         *\n         * > Instances of the `readline.Interface` class are constructed using the\n         * > `readline.createInterface()` method.\n         *\n         * @see https://nodejs.org/dist/latest-v22.x/docs/api/readline.html#class-interfaceconstructor\n         */\n        protected constructor(options: ReadLineOptions);\n        /**\n         * The `rl.getPrompt()` method returns the current prompt used by `rl.prompt()`.\n         * @since v15.3.0, v14.17.0\n         * @return the current prompt string\n         */\n        getPrompt(): string;\n        /**\n         * The `rl.setPrompt()` method sets the prompt that will be written to `output` whenever `rl.prompt()` is called.\n         * @since v0.1.98\n         */\n        setPrompt(prompt: string): void;\n        /**\n         * The `rl.prompt()` method writes the `Interface` instances configured`prompt` to a new line in `output` in order to provide a user with a new\n         * location at which to provide input.\n         *\n         * When called, `rl.prompt()` will resume the `input` stream if it has been\n         * paused.\n         *\n         * If the `Interface` was created with `output` set to `null` or `undefined` the prompt is not written.\n         * @since v0.1.98\n         * @param preserveCursor If `true`, prevents the cursor placement from being reset to `0`.\n         */\n        prompt(preserveCursor?: boolean): void;\n        /**\n         * The `rl.question()` method displays the `query` by writing it to the `output`,\n         * waits for user input to be provided on `input`, then invokes the `callback` function passing the provided input as the first argument.\n         *\n         * When called, `rl.question()` will resume the `input` stream if it has been\n         * paused.\n         *\n         * If the `Interface` was created with `output` set to `null` or `undefined` the `query` is not written.\n         *\n         * The `callback` function passed to `rl.question()` does not follow the typical\n         * pattern of accepting an `Error` object or `null` as the first argument.\n         * The `callback` is called with the provided answer as the only argument.\n         *\n         * An error will be thrown if calling `rl.question()` after `rl.close()`.\n         *\n         * Example usage:\n         *\n         * ```js\n         * rl.question('What is your favorite food? ', (answer) => {\n         *   console.log(`Oh, so your favorite food is ${answer}`);\n         * });\n         * ```\n         *\n         * Using an `AbortController` to cancel a question.\n         *\n         * ```js\n         * const ac = new AbortController();\n         * const signal = ac.signal;\n         *\n         * rl.question('What is your favorite food? ', { signal }, (answer) => {\n         *   console.log(`Oh, so your favorite food is ${answer}`);\n         * });\n         *\n         * signal.addEventListener('abort', () => {\n         *   console.log('The food question timed out');\n         * }, { once: true });\n         *\n         * setTimeout(() => ac.abort(), 10000);\n         * ```\n         * @since v0.3.3\n         * @param query A statement or query to write to `output`, prepended to the prompt.\n         * @param callback A callback function that is invoked with the user's input in response to the `query`.\n         */\n        question(query: string, callback: (answer: string) => void): void;\n        question(query: string, options: Abortable, callback: (answer: string) => void): void;\n        /**\n         * The `rl.pause()` method pauses the `input` stream, allowing it to be resumed\n         * later if necessary.\n         *\n         * Calling `rl.pause()` does not immediately pause other events (including `'line'`) from being emitted by the `Interface` instance.\n         * @since v0.3.4\n         */\n        pause(): this;\n        /**\n         * The `rl.resume()` method resumes the `input` stream if it has been paused.\n         * @since v0.3.4\n         */\n        resume(): this;\n        /**\n         * The `rl.close()` method closes the `Interface` instance and\n         * relinquishes control over the `input` and `output` streams. When called,\n         * the `'close'` event will be emitted.\n         *\n         * Calling `rl.close()` does not immediately stop other events (including `'line'`)\n         * from being emitted by the `Interface` instance.\n         * @since v0.1.98\n         */\n        close(): void;\n        /**\n         * Alias for `rl.close()`.\n         * @since v22.15.0\n         */\n        [Symbol.dispose](): void;\n        /**\n         * The `rl.write()` method will write either `data` or a key sequence identified\n         * by `key` to the `output`. The `key` argument is supported only if `output` is\n         * a `TTY` text terminal. See `TTY keybindings` for a list of key\n         * combinations.\n         *\n         * If `key` is specified, `data` is ignored.\n         *\n         * When called, `rl.write()` will resume the `input` stream if it has been\n         * paused.\n         *\n         * If the `Interface` was created with `output` set to `null` or `undefined` the `data` and `key` are not written.\n         *\n         * ```js\n         * rl.write('Delete this!');\n         * // Simulate Ctrl+U to delete the line written previously\n         * rl.write(null, { ctrl: true, name: 'u' });\n         * ```\n         *\n         * The `rl.write()` method will write the data to the `readline` `Interface`'s `input` _as if it were provided by the user_.\n         * @since v0.1.98\n         */\n        write(data: string | Buffer, key?: Key): void;\n        write(data: undefined | null | string | Buffer, key: Key): void;\n        /**\n         * Returns the real position of the cursor in relation to the input\n         * prompt + string. Long input (wrapping) strings, as well as multiple\n         * line prompts are included in the calculations.\n         * @since v13.5.0, v12.16.0\n         */\n        getCursorPos(): CursorPos;\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. line\n         * 3. pause\n         * 4. resume\n         * 5. SIGCONT\n         * 6. SIGINT\n         * 7. SIGTSTP\n         * 8. history\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"line\", listener: (input: string) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: \"SIGCONT\", listener: () => void): this;\n        addListener(event: \"SIGINT\", listener: () => void): this;\n        addListener(event: \"SIGTSTP\", listener: () => void): this;\n        addListener(event: \"history\", listener: (history: string[]) => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"line\", input: string): boolean;\n        emit(event: \"pause\"): boolean;\n        emit(event: \"resume\"): boolean;\n        emit(event: \"SIGCONT\"): boolean;\n        emit(event: \"SIGINT\"): boolean;\n        emit(event: \"SIGTSTP\"): boolean;\n        emit(event: \"history\", history: string[]): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"line\", listener: (input: string) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: \"SIGCONT\", listener: () => void): this;\n        on(event: \"SIGINT\", listener: () => void): this;\n        on(event: \"SIGTSTP\", listener: () => void): this;\n        on(event: \"history\", listener: (history: string[]) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"line\", listener: (input: string) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: \"SIGCONT\", listener: () => void): this;\n        once(event: \"SIGINT\", listener: () => void): this;\n        once(event: \"SIGTSTP\", listener: () => void): this;\n        once(event: \"history\", listener: (history: string[]) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"line\", listener: (input: string) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: \"SIGCONT\", listener: () => void): this;\n        prependListener(event: \"SIGINT\", listener: () => void): this;\n        prependListener(event: \"SIGTSTP\", listener: () => void): this;\n        prependListener(event: \"history\", listener: (history: string[]) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"line\", listener: (input: string) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: \"SIGCONT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGINT\", listener: () => void): this;\n        prependOnceListener(event: \"SIGTSTP\", listener: () => void): this;\n        prependOnceListener(event: \"history\", listener: (history: string[]) => void): this;\n        [Symbol.asyncIterator](): NodeJS.AsyncIterator<string>;\n    }\n    export type ReadLine = Interface; // type forwarded for backwards compatibility\n    export type Completer = (line: string) => CompleterResult;\n    export type AsyncCompleter = (\n        line: string,\n        callback: (err?: null | Error, result?: CompleterResult) => void,\n    ) => void;\n    export type CompleterResult = [string[], string];\n    export interface ReadLineOptions {\n        /**\n         * The [`Readable`](https://nodejs.org/docs/latest-v22.x/api/stream.html#readable-streams) stream to listen to\n         */\n        input: NodeJS.ReadableStream;\n        /**\n         * The [`Writable`](https://nodejs.org/docs/latest-v22.x/api/stream.html#writable-streams) stream to write readline data to.\n         */\n        output?: NodeJS.WritableStream | undefined;\n        /**\n         * An optional function used for Tab autocompletion.\n         */\n        completer?: Completer | AsyncCompleter | undefined;\n        /**\n         * `true` if the `input` and `output` streams should be treated like a TTY,\n         * and have ANSI/VT100 escape codes written to it.\n         * Default: checking `isTTY` on the `output` stream upon instantiation.\n         */\n        terminal?: boolean | undefined;\n        /**\n         * Initial list of history lines.\n         * This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,\n         * otherwise the history caching mechanism is not initialized at all.\n         * @default []\n         */\n        history?: string[] | undefined;\n        /**\n         * Maximum number of history lines retained.\n         * To disable the history set this value to `0`.\n         * This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,\n         * otherwise the history caching mechanism is not initialized at all.\n         * @default 30\n         */\n        historySize?: number | undefined;\n        /**\n         * If `true`, when a new input line added to the history list duplicates an older one,\n         * this removes the older line from the list.\n         * @default false\n         */\n        removeHistoryDuplicates?: boolean | undefined;\n        /**\n         * The prompt string to use.\n         * @default \"> \"\n         */\n        prompt?: string | undefined;\n        /**\n         * If the delay between `\\r` and `\\n` exceeds `crlfDelay` milliseconds,\n         * both `\\r` and `\\n` will be treated as separate end-of-line input.\n         * `crlfDelay` will be coerced to a number no less than `100`.\n         * It can be set to `Infinity`, in which case\n         * `\\r` followed by `\\n` will always be considered a single newline\n         * (which may be reasonable for [reading files](https://nodejs.org/docs/latest-v22.x/api/readline.html#example-read-file-stream-line-by-line) with `\\r\\n` line delimiter).\n         * @default 100\n         */\n        crlfDelay?: number | undefined;\n        /**\n         * The duration `readline` will wait for a character\n         * (when reading an ambiguous key sequence in milliseconds\n         * one that can both form a complete key sequence using the input read so far\n         * and can take additional input to complete a longer key sequence).\n         * @default 500\n         */\n        escapeCodeTimeout?: number | undefined;\n        /**\n         * The number of spaces a tab is equal to (minimum 1).\n         * @default 8\n         */\n        tabSize?: number | undefined;\n        /**\n         * Allows closing the interface using an AbortSignal.\n         * Aborting the signal will internally call `close` on the interface.\n         */\n        signal?: AbortSignal | undefined;\n    }\n    /**\n     * The `readline.createInterface()` method creates a new `readline.Interface` instance.\n     *\n     * ```js\n     * import readline from 'node:readline';\n     * const rl = readline.createInterface({\n     *   input: process.stdin,\n     *   output: process.stdout,\n     * });\n     * ```\n     *\n     * Once the `readline.Interface` instance is created, the most common case is to\n     * listen for the `'line'` event:\n     *\n     * ```js\n     * rl.on('line', (line) => {\n     *   console.log(`Received: ${line}`);\n     * });\n     * ```\n     *\n     * If `terminal` is `true` for this instance then the `output` stream will get\n     * the best compatibility if it defines an `output.columns` property and emits\n     * a `'resize'` event on the `output` if or when the columns ever change\n     * (`process.stdout` does this automatically when it is a TTY).\n     *\n     * When creating a `readline.Interface` using `stdin` as input, the program\n     * will not terminate until it receives an [EOF character](https://en.wikipedia.org/wiki/End-of-file#EOF_character). To exit without\n     * waiting for user input, call `process.stdin.unref()`.\n     * @since v0.1.98\n     */\n    export function createInterface(\n        input: NodeJS.ReadableStream,\n        output?: NodeJS.WritableStream,\n        completer?: Completer | AsyncCompleter,\n        terminal?: boolean,\n    ): Interface;\n    export function createInterface(options: ReadLineOptions): Interface;\n    /**\n     * The `readline.emitKeypressEvents()` method causes the given `Readable` stream to begin emitting `'keypress'` events corresponding to received input.\n     *\n     * Optionally, `interface` specifies a `readline.Interface` instance for which\n     * autocompletion is disabled when copy-pasted input is detected.\n     *\n     * If the `stream` is a `TTY`, then it must be in raw mode.\n     *\n     * This is automatically called by any readline instance on its `input` if the `input` is a terminal. Closing the `readline` instance does not stop\n     * the `input` from emitting `'keypress'` events.\n     *\n     * ```js\n     * readline.emitKeypressEvents(process.stdin);\n     * if (process.stdin.isTTY)\n     *   process.stdin.setRawMode(true);\n     * ```\n     *\n     * ## Example: Tiny CLI\n     *\n     * The following example illustrates the use of `readline.Interface` class to\n     * implement a small command-line interface:\n     *\n     * ```js\n     * import readline from 'node:readline';\n     * const rl = readline.createInterface({\n     *   input: process.stdin,\n     *   output: process.stdout,\n     *   prompt: 'OHAI> ',\n     * });\n     *\n     * rl.prompt();\n     *\n     * rl.on('line', (line) => {\n     *   switch (line.trim()) {\n     *     case 'hello':\n     *       console.log('world!');\n     *       break;\n     *     default:\n     *       console.log(`Say what? I might have heard '${line.trim()}'`);\n     *       break;\n     *   }\n     *   rl.prompt();\n     * }).on('close', () => {\n     *   console.log('Have a great day!');\n     *   process.exit(0);\n     * });\n     * ```\n     *\n     * ## Example: Read file stream line-by-Line\n     *\n     * A common use case for `readline` is to consume an input file one line at a\n     * time. The easiest way to do so is leveraging the `fs.ReadStream` API as\n     * well as a `for await...of` loop:\n     *\n     * ```js\n     * import fs from 'node:fs';\n     * import readline from 'node:readline';\n     *\n     * async function processLineByLine() {\n     *   const fileStream = fs.createReadStream('input.txt');\n     *\n     *   const rl = readline.createInterface({\n     *     input: fileStream,\n     *     crlfDelay: Infinity,\n     *   });\n     *   // Note: we use the crlfDelay option to recognize all instances of CR LF\n     *   // ('\\r\\n') in input.txt as a single line break.\n     *\n     *   for await (const line of rl) {\n     *     // Each line in input.txt will be successively available here as `line`.\n     *     console.log(`Line from file: ${line}`);\n     *   }\n     * }\n     *\n     * processLineByLine();\n     * ```\n     *\n     * Alternatively, one could use the `'line'` event:\n     *\n     * ```js\n     * import fs from 'node:fs';\n     * import readline from 'node:readline';\n     *\n     * const rl = readline.createInterface({\n     *   input: fs.createReadStream('sample.txt'),\n     *   crlfDelay: Infinity,\n     * });\n     *\n     * rl.on('line', (line) => {\n     *   console.log(`Line from file: ${line}`);\n     * });\n     * ```\n     *\n     * Currently, `for await...of` loop can be a bit slower. If `async` / `await` flow and speed are both essential, a mixed approach can be applied:\n     *\n     * ```js\n     * import { once } from 'node:events';\n     * import { createReadStream } from 'node:fs';\n     * import { createInterface } from 'node:readline';\n     *\n     * (async function processLineByLine() {\n     *   try {\n     *     const rl = createInterface({\n     *       input: createReadStream('big-file.txt'),\n     *       crlfDelay: Infinity,\n     *     });\n     *\n     *     rl.on('line', (line) => {\n     *       // Process the line.\n     *     });\n     *\n     *     await once(rl, 'close');\n     *\n     *     console.log('File processed.');\n     *   } catch (err) {\n     *     console.error(err);\n     *   }\n     * })();\n     * ```\n     * @since v0.7.7\n     */\n    export function emitKeypressEvents(stream: NodeJS.ReadableStream, readlineInterface?: Interface): void;\n    export type Direction = -1 | 0 | 1;\n    export interface CursorPos {\n        rows: number;\n        cols: number;\n    }\n    /**\n     * The `readline.clearLine()` method clears current line of given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) stream\n     * in a specified direction identified by `dir`.\n     * @since v0.7.7\n     * @param callback Invoked once the operation completes.\n     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n     */\n    export function clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: () => void): boolean;\n    /**\n     * The `readline.clearScreenDown()` method clears the given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) stream from\n     * the current position of the cursor down.\n     * @since v0.7.7\n     * @param callback Invoked once the operation completes.\n     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n     */\n    export function clearScreenDown(stream: NodeJS.WritableStream, callback?: () => void): boolean;\n    /**\n     * The `readline.cursorTo()` method moves cursor to the specified position in a\n     * given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) `stream`.\n     * @since v0.7.7\n     * @param callback Invoked once the operation completes.\n     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n     */\n    export function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: () => void): boolean;\n    /**\n     * The `readline.moveCursor()` method moves the cursor _relative_ to its current\n     * position in a given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) `stream`.\n     * @since v0.7.7\n     * @param callback Invoked once the operation completes.\n     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n     */\n    export function moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: () => void): boolean;\n}\ndeclare module \"node:readline\" {\n    export * from \"readline\";\n}\n"
        }
    ]
}