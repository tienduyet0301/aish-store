{
    "sourceFile": "node_modules/@types/node/path.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955780,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "declare module \"path/posix\" {\n    import path = require(\"path\");\n    export = path;\n}\ndeclare module \"path/win32\" {\n    import path = require(\"path\");\n    export = path;\n}\n/**\n * The `node:path` module provides utilities for working with file and directory\n * paths. It can be accessed using:\n *\n * ```js\n * import path from 'node:path';\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/path.js)\n */\ndeclare module \"path\" {\n    namespace path {\n        /**\n         * A parsed path object generated by path.parse() or consumed by path.format().\n         */\n        interface ParsedPath {\n            /**\n             * The root of the path such as '/' or 'c:\\'\n             */\n            root: string;\n            /**\n             * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n             */\n            dir: string;\n            /**\n             * The file name including extension (if any) such as 'index.html'\n             */\n            base: string;\n            /**\n             * The file extension (if any) such as '.html'\n             */\n            ext: string;\n            /**\n             * The file name without extension (if any) such as 'index'\n             */\n            name: string;\n        }\n        interface FormatInputPathObject {\n            /**\n             * The root of the path such as '/' or 'c:\\'\n             */\n            root?: string | undefined;\n            /**\n             * The full directory path such as '/home/user/dir' or 'c:\\path\\dir'\n             */\n            dir?: string | undefined;\n            /**\n             * The file name including extension (if any) such as 'index.html'\n             */\n            base?: string | undefined;\n            /**\n             * The file extension (if any) such as '.html'\n             */\n            ext?: string | undefined;\n            /**\n             * The file name without extension (if any) such as 'index'\n             */\n            name?: string | undefined;\n        }\n        interface PlatformPath {\n            /**\n             * Normalize a string path, reducing '..' and '.' parts.\n             * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n             *\n             * @param path string path to normalize.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            normalize(path: string): string;\n            /**\n             * Join all arguments together and normalize the resulting path.\n             *\n             * @param paths paths to join.\n             * @throws {TypeError} if any of the path segments is not a string.\n             */\n            join(...paths: string[]): string;\n            /**\n             * The right-most parameter is considered {to}. Other parameters are considered an array of {from}.\n             *\n             * Starting from leftmost {from} parameter, resolves {to} to an absolute path.\n             *\n             * If {to} isn't already absolute, {from} arguments are prepended in right to left order,\n             * until an absolute path is found. If after using all {from} paths still no absolute path is found,\n             * the current working directory is used as well. The resulting path is normalized,\n             * and trailing slashes are removed unless the path gets resolved to the root directory.\n             *\n             * @param paths A sequence of paths or path segments.\n             * @throws {TypeError} if any of the arguments is not a string.\n             */\n            resolve(...paths: string[]): string;\n            /**\n             * The `path.matchesGlob()` method determines if `path` matches the `pattern`.\n             * @param path The path to glob-match against.\n             * @param pattern The glob to check the path against.\n             * @returns Whether or not the `path` matched the `pattern`.\n             * @throws {TypeError} if `path` or `pattern` are not strings.\n             * @since v22.5.0\n             */\n            matchesGlob(path: string, pattern: string): boolean;\n            /**\n             * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.\n             *\n             * If the given {path} is a zero-length string, `false` will be returned.\n             *\n             * @param path path to test.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            isAbsolute(path: string): boolean;\n            /**\n             * Solve the relative path from {from} to {to} based on the current working directory.\n             * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.\n             *\n             * @throws {TypeError} if either `from` or `to` is not a string.\n             */\n            relative(from: string, to: string): string;\n            /**\n             * Return the directory name of a path. Similar to the Unix dirname command.\n             *\n             * @param path the path to evaluate.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            dirname(path: string): string;\n            /**\n             * Return the last portion of a path. Similar to the Unix basename command.\n             * Often used to extract the file name from a fully qualified path.\n             *\n             * @param path the path to evaluate.\n             * @param suffix optionally, an extension to remove from the result.\n             * @throws {TypeError} if `path` is not a string or if `ext` is given and is not a string.\n             */\n            basename(path: string, suffix?: string): string;\n            /**\n             * Return the extension of the path, from the last '.' to end of string in the last portion of the path.\n             * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string.\n             *\n             * @param path the path to evaluate.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            extname(path: string): string;\n            /**\n             * The platform-specific file separator. '\\\\' or '/'.\n             */\n            readonly sep: \"\\\\\" | \"/\";\n            /**\n             * The platform-specific file delimiter. ';' or ':'.\n             */\n            readonly delimiter: \";\" | \":\";\n            /**\n             * Returns an object from a path string - the opposite of format().\n             *\n             * @param path path to evaluate.\n             * @throws {TypeError} if `path` is not a string.\n             */\n            parse(path: string): ParsedPath;\n            /**\n             * Returns a path string from an object - the opposite of parse().\n             *\n             * @param pathObject path to evaluate.\n             */\n            format(pathObject: FormatInputPathObject): string;\n            /**\n             * On Windows systems only, returns an equivalent namespace-prefixed path for the given path.\n             * If path is not a string, path will be returned without modifications.\n             * This method is meaningful only on Windows system.\n             * On POSIX systems, the method is non-operational and always returns path without modifications.\n             */\n            toNamespacedPath(path: string): string;\n            /**\n             * Posix specific pathing.\n             * Same as parent object on posix.\n             */\n            readonly posix: PlatformPath;\n            /**\n             * Windows specific pathing.\n             * Same as parent object on windows\n             */\n            readonly win32: PlatformPath;\n        }\n    }\n    const path: path.PlatformPath;\n    export = path;\n}\ndeclare module \"node:path\" {\n    import path = require(\"path\");\n    export = path;\n}\ndeclare module \"node:path/posix\" {\n    import path = require(\"path/posix\");\n    export = path;\n}\ndeclare module \"node:path/win32\" {\n    import path = require(\"path/win32\");\n    export = path;\n}\n"
        }
    ]
}