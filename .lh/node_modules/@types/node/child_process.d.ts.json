{
    "sourceFile": "node_modules/@types/node/child_process.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891954750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:child_process` module provides the ability to spawn subprocesses in\n * a manner that is similar, but not identical, to [`popen(3)`](http://man7.org/linux/man-pages/man3/popen.3.html). This capability\n * is primarily provided by the {@link spawn} function:\n *\n * ```js\n * import { spawn } from 'node:child_process';\n * const ls = spawn('ls', ['-lh', '/usr']);\n *\n * ls.stdout.on('data', (data) => {\n *   console.log(`stdout: ${data}`);\n * });\n *\n * ls.stderr.on('data', (data) => {\n *   console.error(`stderr: ${data}`);\n * });\n *\n * ls.on('close', (code) => {\n *   console.log(`child process exited with code ${code}`);\n * });\n * ```\n *\n * By default, pipes for `stdin`, `stdout`, and `stderr` are established between\n * the parent Node.js process and the spawned subprocess. These pipes have\n * limited (and platform-specific) capacity. If the subprocess writes to\n * stdout in excess of that limit without the output being captured, the\n * subprocess blocks waiting for the pipe buffer to accept more data. This is\n * identical to the behavior of pipes in the shell. Use the `{ stdio: 'ignore' }` option if the output will not be consumed.\n *\n * The command lookup is performed using the `options.env.PATH` environment\n * variable if `env` is in the `options` object. Otherwise, `process.env.PATH` is\n * used. If `options.env` is set without `PATH`, lookup on Unix is performed\n * on a default search path search of `/usr/bin:/bin` (see your operating system's\n * manual for execvpe/execvp), on Windows the current processes environment\n * variable `PATH` is used.\n *\n * On Windows, environment variables are case-insensitive. Node.js\n * lexicographically sorts the `env` keys and uses the first one that\n * case-insensitively matches. Only first (in lexicographic order) entry will be\n * passed to the subprocess. This might lead to issues on Windows when passing\n * objects to the `env` option that have multiple variants of the same key, such as `PATH` and `Path`.\n *\n * The {@link spawn} method spawns the child process asynchronously,\n * without blocking the Node.js event loop. The {@link spawnSync} function provides equivalent functionality in a synchronous manner that blocks\n * the event loop until the spawned process either exits or is terminated.\n *\n * For convenience, the `node:child_process` module provides a handful of\n * synchronous and asynchronous alternatives to {@link spawn} and {@link spawnSync}. Each of these alternatives are implemented on\n * top of {@link spawn} or {@link spawnSync}.\n *\n * * {@link exec}: spawns a shell and runs a command within that\n * shell, passing the `stdout` and `stderr` to a callback function when\n * complete.\n * * {@link execFile}: similar to {@link exec} except\n * that it spawns the command directly without first spawning a shell by\n * default.\n * * {@link fork}: spawns a new Node.js process and invokes a\n * specified module with an IPC communication channel established that allows\n * sending messages between parent and child.\n * * {@link execSync}: a synchronous version of {@link exec} that will block the Node.js event loop.\n * * {@link execFileSync}: a synchronous version of {@link execFile} that will block the Node.js event loop.\n *\n * For certain use cases, such as automating shell scripts, the `synchronous counterparts` may be more convenient. In many cases, however,\n * the synchronous methods can have significant impact on performance due to\n * stalling the event loop while spawned processes complete.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/child_process.js)\n */\ndeclare module \"child_process\" {\n    import { ObjectEncodingOptions } from \"node:fs\";\n    import { Abortable, EventEmitter } from \"node:events\";\n    import * as dgram from \"node:dgram\";\n    import * as net from \"node:net\";\n    import { Pipe, Readable, Stream, Writable } from \"node:stream\";\n    import { URL } from \"node:url\";\n    type Serializable = string | object | number | boolean | bigint;\n    type SendHandle = net.Socket | net.Server | dgram.Socket | undefined;\n    /**\n     * Instances of the `ChildProcess` represent spawned child processes.\n     *\n     * Instances of `ChildProcess` are not intended to be created directly. Rather,\n     * use the {@link spawn}, {@link exec},{@link execFile}, or {@link fork} methods to create\n     * instances of `ChildProcess`.\n     * @since v2.2.0\n     */\n    class ChildProcess extends EventEmitter {\n        /**\n         * A `Writable Stream` that represents the child process's `stdin`.\n         *\n         * If a child process waits to read all of its input, the child will not continue\n         * until this stream has been closed via `end()`.\n         *\n         * If the child was spawned with `stdio[0]` set to anything other than `'pipe'`,\n         * then this will be `null`.\n         *\n         * `subprocess.stdin` is an alias for `subprocess.stdio[0]`. Both properties will\n         * refer to the same value.\n         *\n         * The `subprocess.stdin` property can be `null` or `undefined` if the child process could not be successfully spawned.\n         * @since v0.1.90\n         */\n        stdin: Writable | null;\n        /**\n         * A `Readable Stream` that represents the child process's `stdout`.\n         *\n         * If the child was spawned with `stdio[1]` set to anything other than `'pipe'`,\n         * then this will be `null`.\n         *\n         * `subprocess.stdout` is an alias for `subprocess.stdio[1]`. Both properties will\n         * refer to the same value.\n         *\n         * ```js\n         * import { spawn } from 'node:child_process';\n         *\n         * const subprocess = spawn('ls');\n         *\n         * subprocess.stdout.on('data', (data) => {\n         *   console.log(`Received chunk ${data}`);\n         * });\n         * ```\n         *\n         * The `subprocess.stdout` property can be `null` or `undefined` if the child process could not be successfully spawned.\n         * @since v0.1.90\n         */\n        stdout: Readable | null;\n        /**\n         * A `Readable Stream` that represents the child process's `stderr`.\n         *\n         * If the child was spawned with `stdio[2]` set to anything other than `'pipe'`,\n         * then this will be `null`.\n         *\n         * `subprocess.stderr` is an alias for `subprocess.stdio[2]`. Both properties will\n         * refer to the same value.\n         *\n         * The `subprocess.stderr` property can be `null` or `undefined` if the child process could not be successfully spawned.\n         * @since v0.1.90\n         */\n        stderr: Readable | null;\n        /**\n         * The `subprocess.channel` property is a reference to the child's IPC channel. If\n         * no IPC channel exists, this property is `undefined`.\n         * @since v7.1.0\n         */\n        readonly channel?: Pipe | null | undefined;\n        /**\n         * A sparse array of pipes to the child process, corresponding with positions in\n         * the `stdio` option passed to {@link spawn} that have been set\n         * to the value `'pipe'`. `subprocess.stdio[0]`, `subprocess.stdio[1]`, and `subprocess.stdio[2]` are also available as `subprocess.stdin`, `subprocess.stdout`, and `subprocess.stderr`,\n         * respectively.\n         *\n         * In the following example, only the child's fd `1` (stdout) is configured as a\n         * pipe, so only the parent's `subprocess.stdio[1]` is a stream, all other values\n         * in the array are `null`.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         * import fs from 'node:fs';\n         * import child_process from 'node:child_process';\n         *\n         * const subprocess = child_process.spawn('ls', {\n         *   stdio: [\n         *     0, // Use parent's stdin for child.\n         *     'pipe', // Pipe child's stdout to parent.\n         *     fs.openSync('err.out', 'w'), // Direct child's stderr to a file.\n         *   ],\n         * });\n         *\n         * assert.strictEqual(subprocess.stdio[0], null);\n         * assert.strictEqual(subprocess.stdio[0], subprocess.stdin);\n         *\n         * assert(subprocess.stdout);\n         * assert.strictEqual(subprocess.stdio[1], subprocess.stdout);\n         *\n         * assert.strictEqual(subprocess.stdio[2], null);\n         * assert.strictEqual(subprocess.stdio[2], subprocess.stderr);\n         * ```\n         *\n         * The `subprocess.stdio` property can be `undefined` if the child process could\n         * not be successfully spawned.\n         * @since v0.7.10\n         */\n        readonly stdio: [\n            Writable | null,\n            // stdin\n            Readable | null,\n            // stdout\n            Readable | null,\n            // stderr\n            Readable | Writable | null | undefined,\n            // extra\n            Readable | Writable | null | undefined, // extra\n        ];\n        /**\n         * The `subprocess.killed` property indicates whether the child process\n         * successfully received a signal from `subprocess.kill()`. The `killed` property\n         * does not indicate that the child process has been terminated.\n         * @since v0.5.10\n         */\n        readonly killed: boolean;\n        /**\n         * Returns the process identifier (PID) of the child process. If the child process\n         * fails to spawn due to errors, then the value is `undefined` and `error` is\n         * emitted.\n         *\n         * ```js\n         * import { spawn } from 'node:child_process';\n         * const grep = spawn('grep', ['ssh']);\n         *\n         * console.log(`Spawned child pid: ${grep.pid}`);\n         * grep.stdin.end();\n         * ```\n         * @since v0.1.90\n         */\n        readonly pid?: number | undefined;\n        /**\n         * The `subprocess.connected` property indicates whether it is still possible to\n         * send and receive messages from a child process. When `subprocess.connected` is `false`, it is no longer possible to send or receive messages.\n         * @since v0.7.2\n         */\n        readonly connected: boolean;\n        /**\n         * The `subprocess.exitCode` property indicates the exit code of the child process.\n         * If the child process is still running, the field will be `null`.\n         */\n        readonly exitCode: number | null;\n        /**\n         * The `subprocess.signalCode` property indicates the signal received by\n         * the child process if any, else `null`.\n         */\n        readonly signalCode: NodeJS.Signals | null;\n        /**\n         * The `subprocess.spawnargs` property represents the full list of command-line\n         * arguments the child process was launched with.\n         */\n        readonly spawnargs: string[];\n        /**\n         * The `subprocess.spawnfile` property indicates the executable file name of\n         * the child process that is launched.\n         *\n         * For {@link fork}, its value will be equal to `process.execPath`.\n         * For {@link spawn}, its value will be the name of\n         * the executable file.\n         * For {@link exec},  its value will be the name of the shell\n         * in which the child process is launched.\n         */\n        readonly spawnfile: string;\n        /**\n         * The `subprocess.kill()` method sends a signal to the child process. If no\n         * argument is given, the process will be sent the `'SIGTERM'` signal. See [`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html) for a list of available signals. This function\n         * returns `true` if [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) succeeds, and `false` otherwise.\n         *\n         * ```js\n         * import { spawn } from 'node:child_process';\n         * const grep = spawn('grep', ['ssh']);\n         *\n         * grep.on('close', (code, signal) => {\n         *   console.log(\n         *     `child process terminated due to receipt of signal ${signal}`);\n         * });\n         *\n         * // Send SIGHUP to process.\n         * grep.kill('SIGHUP');\n         * ```\n         *\n         * The `ChildProcess` object may emit an `'error'` event if the signal\n         * cannot be delivered. Sending a signal to a child process that has already exited\n         * is not an error but may have unforeseen consequences. Specifically, if the\n         * process identifier (PID) has been reassigned to another process, the signal will\n         * be delivered to that process instead which can have unexpected results.\n         *\n         * While the function is called `kill`, the signal delivered to the child process\n         * may not actually terminate the process.\n         *\n         * See [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) for reference.\n         *\n         * On Windows, where POSIX signals do not exist, the `signal` argument will be\n         * ignored, and the process will be killed forcefully and abruptly (similar to `'SIGKILL'`).\n         * See `Signal Events` for more details.\n         *\n         * On Linux, child processes of child processes will not be terminated\n         * when attempting to kill their parent. This is likely to happen when running a\n         * new process in a shell or with the use of the `shell` option of `ChildProcess`:\n         *\n         * ```js\n         * 'use strict';\n         * import { spawn } from 'node:child_process';\n         *\n         * const subprocess = spawn(\n         *   'sh',\n         *   [\n         *     '-c',\n         *     `node -e \"setInterval(() => {\n         *       console.log(process.pid, 'is alive')\n         *     }, 500);\"`,\n         *   ], {\n         *     stdio: ['inherit', 'inherit', 'inherit'],\n         *   },\n         * );\n         *\n         * setTimeout(() => {\n         *   subprocess.kill(); // Does not terminate the Node.js process in the shell.\n         * }, 2000);\n         * ```\n         * @since v0.1.90\n         */\n        kill(signal?: NodeJS.Signals | number): boolean;\n        /**\n         * Calls {@link ChildProcess.kill} with `'SIGTERM'`.\n         * @since v20.5.0\n         */\n        [Symbol.dispose](): void;\n        /**\n         * When an IPC channel has been established between the parent and child (\n         * i.e. when using {@link fork}), the `subprocess.send()` method can\n         * be used to send messages to the child process. When the child process is a\n         * Node.js instance, these messages can be received via the `'message'` event.\n         *\n         * The message goes through serialization and parsing. The resulting\n         * message might not be the same as what is originally sent.\n         *\n         * For example, in the parent script:\n         *\n         * ```js\n         * import cp from 'node:child_process';\n         * const n = cp.fork(`${__dirname}/sub.js`);\n         *\n         * n.on('message', (m) => {\n         *   console.log('PARENT got message:', m);\n         * });\n         *\n         * // Causes the child to print: CHILD got message: { hello: 'world' }\n         * n.send({ hello: 'world' });\n         * ```\n         *\n         * And then the child script, `'sub.js'` might look like this:\n         *\n         * ```js\n         * process.on('message', (m) => {\n         *   console.log('CHILD got message:', m);\n         * });\n         *\n         * // Causes the parent to print: PARENT got message: { foo: 'bar', baz: null }\n         * process.send({ foo: 'bar', baz: NaN });\n         * ```\n         *\n         * Child Node.js processes will have a `process.send()` method of their own\n         * that allows the child to send messages back to the parent.\n         *\n         * There is a special case when sending a `{cmd: 'NODE_foo'}` message. Messages\n         * containing a `NODE_` prefix in the `cmd` property are reserved for use within\n         * Node.js core and will not be emitted in the child's `'message'` event. Rather, such messages are emitted using the `'internalMessage'` event and are consumed internally by Node.js.\n         * Applications should avoid using such messages or listening for `'internalMessage'` events as it is subject to change without notice.\n         *\n         * The optional `sendHandle` argument that may be passed to `subprocess.send()` is\n         * for passing a TCP server or socket object to the child process. The child will\n         * receive the object as the second argument passed to the callback function\n         * registered on the `'message'` event. Any data that is received and buffered in\n         * the socket will not be sent to the child. Sending IPC sockets is not supported on Windows.\n         *\n         * The optional `callback` is a function that is invoked after the message is\n         * sent but before the child may have received it. The function is called with a\n         * single argument: `null` on success, or an `Error` object on failure.\n         *\n         * If no `callback` function is provided and the message cannot be sent, an `'error'` event will be emitted by the `ChildProcess` object. This can\n         * happen, for instance, when the child process has already exited.\n         *\n         * `subprocess.send()` will return `false` if the channel has closed or when the\n         * backlog of unsent messages exceeds a threshold that makes it unwise to send\n         * more. Otherwise, the method returns `true`. The `callback` function can be\n         * used to implement flow control.\n         *\n         * #### Example: sending a server object\n         *\n         * The `sendHandle` argument can be used, for instance, to pass the handle of\n         * a TCP server object to the child process as illustrated in the example below:\n         *\n         * ```js\n         * import { createServer } from 'node:net';\n         * import { fork } from 'node:child_process';\n         * const subprocess = fork('subprocess.js');\n         *\n         * // Open up the server object and send the handle.\n         * const server = createServer();\n         * server.on('connection', (socket) => {\n         *   socket.end('handled by parent');\n         * });\n         * server.listen(1337, () => {\n         *   subprocess.send('server', server);\n         * });\n         * ```\n         *\n         * The child would then receive the server object as:\n         *\n         * ```js\n         * process.on('message', (m, server) => {\n         *   if (m === 'server') {\n         *     server.on('connection', (socket) => {\n         *       socket.end('handled by child');\n         *     });\n         *   }\n         * });\n         * ```\n         *\n         * Once the server is now shared between the parent and child, some connections\n         * can be handled by the parent and some by the child.\n         *\n         * While the example above uses a server created using the `node:net` module, `node:dgram` module servers use exactly the same workflow with the exceptions of\n         * listening on a `'message'` event instead of `'connection'` and using `server.bind()` instead of `server.listen()`. This is, however, only\n         * supported on Unix platforms.\n         *\n         * #### Example: sending a socket object\n         *\n         * Similarly, the `sendHandler` argument can be used to pass the handle of a\n         * socket to the child process. The example below spawns two children that each\n         * handle connections with \"normal\" or \"special\" priority:\n         *\n         * ```js\n         * import { createServer } from 'node:net';\n         * import { fork } from 'node:child_process';\n         * const normal = fork('subprocess.js', ['normal']);\n         * const special = fork('subprocess.js', ['special']);\n         *\n         * // Open up the server and send sockets to child. Use pauseOnConnect to prevent\n         * // the sockets from being read before they are sent to the child process.\n         * const server = createServer({ pauseOnConnect: true });\n         * server.on('connection', (socket) => {\n         *\n         *   // If this is special priority...\n         *   if (socket.remoteAddress === '74.125.127.100') {\n         *     special.send('socket', socket);\n         *     return;\n         *   }\n         *   // This is normal priority.\n         *   normal.send('socket', socket);\n         * });\n         * server.listen(1337);\n         * ```\n         *\n         * The `subprocess.js` would receive the socket handle as the second argument\n         * passed to the event callback function:\n         *\n         * ```js\n         * process.on('message', (m, socket) => {\n         *   if (m === 'socket') {\n         *     if (socket) {\n         *       // Check that the client socket exists.\n         *       // It is possible for the socket to be closed between the time it is\n         *       // sent and the time it is received in the child process.\n         *       socket.end(`Request handled with ${process.argv[2]} priority`);\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * Do not use `.maxConnections` on a socket that has been passed to a subprocess.\n         * The parent cannot track when the socket is destroyed.\n         *\n         * Any `'message'` handlers in the subprocess should verify that `socket` exists,\n         * as the connection may have been closed during the time it takes to send the\n         * connection to the child.\n         * @since v0.5.9\n         * @param sendHandle `undefined`, or a [`net.Socket`](https://nodejs.org/docs/latest-v22.x/api/net.html#class-netsocket), [`net.Server`](https://nodejs.org/docs/latest-v22.x/api/net.html#class-netserver), or [`dgram.Socket`](https://nodejs.org/docs/latest-v22.x/api/dgram.html#class-dgramsocket) object.\n         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles. `options` supports the following properties:\n         */\n        send(message: Serializable, callback?: (error: Error | null) => void): boolean;\n        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;\n        send(\n            message: Serializable,\n            sendHandle?: SendHandle,\n            options?: MessageOptions,\n            callback?: (error: Error | null) => void,\n        ): boolean;\n        /**\n         * Closes the IPC channel between parent and child, allowing the child to exit\n         * gracefully once there are no other connections keeping it alive. After calling\n         * this method the `subprocess.connected` and `process.connected` properties in\n         * both the parent and child (respectively) will be set to `false`, and it will be\n         * no longer possible to pass messages between the processes.\n         *\n         * The `'disconnect'` event will be emitted when there are no messages in the\n         * process of being received. This will most often be triggered immediately after\n         * calling `subprocess.disconnect()`.\n         *\n         * When the child process is a Node.js instance (e.g. spawned using {@link fork}), the `process.disconnect()` method can be invoked\n         * within the child process to close the IPC channel as well.\n         * @since v0.7.2\n         */\n        disconnect(): void;\n        /**\n         * By default, the parent will wait for the detached child to exit. To prevent the\n         * parent from waiting for a given `subprocess` to exit, use the `subprocess.unref()` method. Doing so will cause the parent's event loop to not\n         * include the child in its reference count, allowing the parent to exit\n         * independently of the child, unless there is an established IPC channel between\n         * the child and the parent.\n         *\n         * ```js\n         * import { spawn } from 'node:child_process';\n         *\n         * const subprocess = spawn(process.argv[0], ['child_program.js'], {\n         *   detached: true,\n         *   stdio: 'ignore',\n         * });\n         *\n         * subprocess.unref();\n         * ```\n         * @since v0.7.10\n         */\n        unref(): void;\n        /**\n         * Calling `subprocess.ref()` after making a call to `subprocess.unref()` will\n         * restore the removed reference count for the child process, forcing the parent\n         * to wait for the child to exit before exiting itself.\n         *\n         * ```js\n         * import { spawn } from 'node:child_process';\n         *\n         * const subprocess = spawn(process.argv[0], ['child_program.js'], {\n         *   detached: true,\n         *   stdio: 'ignore',\n         * });\n         *\n         * subprocess.unref();\n         * subprocess.ref();\n         * ```\n         * @since v0.7.10\n         */\n        ref(): void;\n        /**\n         * events.EventEmitter\n         * 1. close\n         * 2. disconnect\n         * 3. error\n         * 4. exit\n         * 5. message\n         * 6. spawn\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        addListener(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n        addListener(event: \"spawn\", listener: () => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", code: number | null, signal: NodeJS.Signals | null): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"exit\", code: number | null, signal: NodeJS.Signals | null): boolean;\n        emit(event: \"message\", message: Serializable, sendHandle: SendHandle): boolean;\n        emit(event: \"spawn\", listener: () => void): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        on(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n        on(event: \"spawn\", listener: () => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        once(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n        once(event: \"spawn\", listener: () => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;\n        prependListener(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n        prependListener(event: \"spawn\", listener: () => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(\n            event: \"close\",\n            listener: (code: number | null, signal: NodeJS.Signals | null) => void,\n        ): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(\n            event: \"exit\",\n            listener: (code: number | null, signal: NodeJS.Signals | null) => void,\n        ): this;\n        prependOnceListener(event: \"message\", listener: (message: Serializable, sendHandle: SendHandle) => void): this;\n        prependOnceListener(event: \"spawn\", listener: () => void): this;\n    }\n    // return this object when stdio option is undefined or not specified\n    interface ChildProcessWithoutNullStreams extends ChildProcess {\n        stdin: Writable;\n        stdout: Readable;\n        stderr: Readable;\n        readonly stdio: [\n            Writable,\n            Readable,\n            Readable,\n            // stderr\n            Readable | Writable | null | undefined,\n            // extra, no modification\n            Readable | Writable | null | undefined, // extra, no modification\n        ];\n    }\n    // return this object when stdio option is a tuple of 3\n    interface ChildProcessByStdio<I extends null | Writable, O extends null | Readable, E extends null | Readable>\n        extends ChildProcess\n    {\n        stdin: I;\n        stdout: O;\n        stderr: E;\n        readonly stdio: [\n            I,\n            O,\n            E,\n            Readable | Writable | null | undefined,\n            // extra, no modification\n            Readable | Writable | null | undefined, // extra, no modification\n        ];\n    }\n    interface MessageOptions {\n        keepOpen?: boolean | undefined;\n    }\n    type IOType = \"overlapped\" | \"pipe\" | \"ignore\" | \"inherit\";\n    type StdioOptions = IOType | Array<IOType | \"ipc\" | Stream | number | null | undefined>;\n    type SerializationType = \"json\" | \"advanced\";\n    interface MessagingOptions extends Abortable {\n        /**\n         * Specify the kind of serialization used for sending messages between processes.\n         * @default 'json'\n         */\n        serialization?: SerializationType | undefined;\n        /**\n         * The signal value to be used when the spawned process will be killed by the abort signal.\n         * @default 'SIGTERM'\n         */\n        killSignal?: NodeJS.Signals | number | undefined;\n        /**\n         * In milliseconds the maximum amount of time the process is allowed to run.\n         */\n        timeout?: number | undefined;\n    }\n    interface ProcessEnvOptions {\n        uid?: number | undefined;\n        gid?: number | undefined;\n        cwd?: string | URL | undefined;\n        env?: NodeJS.ProcessEnv | undefined;\n    }\n    interface CommonOptions extends ProcessEnvOptions {\n        /**\n         * @default false\n         */\n        windowsHide?: boolean | undefined;\n        /**\n         * @default 0\n         */\n        timeout?: number | undefined;\n    }\n    interface CommonSpawnOptions extends CommonOptions, MessagingOptions, Abortable {\n        argv0?: string | undefined;\n        /**\n         * Can be set to 'pipe', 'inherit', 'overlapped', or 'ignore', or an array of these strings.\n         * If passed as an array, the first element is used for `stdin`, the second for\n         * `stdout`, and the third for `stderr`. A fourth element can be used to\n         * specify the `stdio` behavior beyond the standard streams. See\n         * {@link ChildProcess.stdio} for more information.\n         *\n         * @default 'pipe'\n         */\n        stdio?: StdioOptions | undefined;\n        shell?: boolean | string | undefined;\n        windowsVerbatimArguments?: boolean | undefined;\n    }\n    interface SpawnOptions extends CommonSpawnOptions {\n        detached?: boolean | undefined;\n    }\n    interface SpawnOptionsWithoutStdio extends SpawnOptions {\n        stdio?: StdioPipeNamed | StdioPipe[] | undefined;\n    }\n    type StdioNull = \"inherit\" | \"ignore\" | Stream;\n    type StdioPipeNamed = \"pipe\" | \"overlapped\";\n    type StdioPipe = undefined | null | StdioPipeNamed;\n    interface SpawnOptionsWithStdioTuple<\n        Stdin extends StdioNull | StdioPipe,\n        Stdout extends StdioNull | StdioPipe,\n        Stderr extends StdioNull | StdioPipe,\n    > extends SpawnOptions {\n        stdio: [Stdin, Stdout, Stderr];\n    }\n    /**\n     * The `child_process.spawn()` method spawns a new process using the given `command`, with command-line arguments in `args`. If omitted, `args` defaults\n     * to an empty array.\n     *\n     * **If the `shell` option is enabled, do not pass unsanitized user input to this**\n     * **function. Any input containing shell metacharacters may be used to trigger**\n     * **arbitrary command execution.**\n     *\n     * A third argument may be used to specify additional options, with these defaults:\n     *\n     * ```js\n     * const defaults = {\n     *   cwd: undefined,\n     *   env: process.env,\n     * };\n     * ```\n     *\n     * Use `cwd` to specify the working directory from which the process is spawned.\n     * If not given, the default is to inherit the current working directory. If given,\n     * but the path does not exist, the child process emits an `ENOENT` error\n     * and exits immediately. `ENOENT` is also emitted when the command\n     * does not exist.\n     *\n     * Use `env` to specify environment variables that will be visible to the new\n     * process, the default is `process.env`.\n     *\n     * `undefined` values in `env` will be ignored.\n     *\n     * Example of running `ls -lh /usr`, capturing `stdout`, `stderr`, and the\n     * exit code:\n     *\n     * ```js\n     * import { spawn } from 'node:child_process';\n     * const ls = spawn('ls', ['-lh', '/usr']);\n     *\n     * ls.stdout.on('data', (data) => {\n     *   console.log(`stdout: ${data}`);\n     * });\n     *\n     * ls.stderr.on('data', (data) => {\n     *   console.error(`stderr: ${data}`);\n     * });\n     *\n     * ls.on('close', (code) => {\n     *   console.log(`child process exited with code ${code}`);\n     * });\n     * ```\n     *\n     * Example: A very elaborate way to run `ps ax | grep ssh`\n     *\n     * ```js\n     * import { spawn } from 'node:child_process';\n     * const ps = spawn('ps', ['ax']);\n     * const grep = spawn('grep', ['ssh']);\n     *\n     * ps.stdout.on('data', (data) => {\n     *   grep.stdin.write(data);\n     * });\n     *\n     * ps.stderr.on('data', (data) => {\n     *   console.error(`ps stderr: ${data}`);\n     * });\n     *\n     * ps.on('close', (code) => {\n     *   if (code !== 0) {\n     *     console.log(`ps process exited with code ${code}`);\n     *   }\n     *   grep.stdin.end();\n     * });\n     *\n     * grep.stdout.on('data', (data) => {\n     *   console.log(data.toString());\n     * });\n     *\n     * grep.stderr.on('data', (data) => {\n     *   console.error(`grep stderr: ${data}`);\n     * });\n     *\n     * grep.on('close', (code) => {\n     *   if (code !== 0) {\n     *     console.log(`grep process exited with code ${code}`);\n     *   }\n     * });\n     * ```\n     *\n     * Example of checking for failed `spawn`:\n     *\n     * ```js\n     * import { spawn } from 'node:child_process';\n     * const subprocess = spawn('bad_command');\n     *\n     * subprocess.on('error', (err) => {\n     *   console.error('Failed to start subprocess.');\n     * });\n     * ```\n     *\n     * Certain platforms (macOS, Linux) will use the value of `argv[0]` for the process\n     * title while others (Windows, SunOS) will use `command`.\n     *\n     * Node.js overwrites `argv[0]` with `process.execPath` on startup, so `process.argv[0]` in a Node.js child process will not match the `argv0` parameter passed to `spawn` from the parent. Retrieve\n     * it with the `process.argv0` property instead.\n     *\n     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except\n     * the error passed to the callback will be an `AbortError`:\n     *\n     * ```js\n     * import { spawn } from 'node:child_process';\n     * const controller = new AbortController();\n     * const { signal } = controller;\n     * const grep = spawn('grep', ['ssh'], { signal });\n     * grep.on('error', (err) => {\n     *   // This will be called with err being an AbortError if the controller aborts\n     * });\n     * controller.abort(); // Stops the child process\n     * ```\n     * @since v0.1.90\n     * @param command The command to run.\n     * @param args List of string arguments.\n     */\n    function spawn(command: string, options?: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<Writable, Readable, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<Writable, Readable, null>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<Writable, null, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<null, Readable, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<Writable, null, null>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<null, Readable, null>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<null, null, Readable>;\n    function spawn(\n        command: string,\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<null, null, null>;\n    function spawn(command: string, options: SpawnOptions): ChildProcess;\n    // overloads of spawn with 'args'\n    function spawn(\n        command: string,\n        args?: readonly string[],\n        options?: SpawnOptionsWithoutStdio,\n    ): ChildProcessWithoutNullStreams;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<Writable, Readable, Readable>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<Writable, Readable, null>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<Writable, null, Readable>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,\n    ): ChildProcessByStdio<null, Readable, Readable>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<Writable, null, null>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,\n    ): ChildProcessByStdio<null, Readable, null>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,\n    ): ChildProcessByStdio<null, null, Readable>;\n    function spawn(\n        command: string,\n        args: readonly string[],\n        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,\n    ): ChildProcessByStdio<null, null, null>;\n    function spawn(command: string, args: readonly string[], options: SpawnOptions): ChildProcess;\n    interface ExecOptions extends CommonOptions {\n        shell?: string | undefined;\n        signal?: AbortSignal | undefined;\n        maxBuffer?: number | undefined;\n        killSignal?: NodeJS.Signals | number | undefined;\n    }\n    interface ExecOptionsWithStringEncoding extends ExecOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecOptionsWithBufferEncoding extends ExecOptions {\n        encoding: BufferEncoding | null; // specify `null`.\n    }\n    interface ExecException extends Error {\n        cmd?: string | undefined;\n        killed?: boolean | undefined;\n        code?: number | undefined;\n        signal?: NodeJS.Signals | undefined;\n        stdout?: string;\n        stderr?: string;\n    }\n    /**\n     * Spawns a shell then executes the `command` within that shell, buffering any\n     * generated output. The `command` string passed to the exec function is processed\n     * directly by the shell and special characters (vary based on [shell](https://en.wikipedia.org/wiki/List_of_command-line_interpreters))\n     * need to be dealt with accordingly:\n     *\n     * ```js\n     * import { exec } from 'node:child_process';\n     *\n     * exec('\"/path/to/test file/test.sh\" arg1 arg2');\n     * // Double quotes are used so that the space in the path is not interpreted as\n     * // a delimiter of multiple arguments.\n     *\n     * exec('echo \"The \\\\$HOME variable is $HOME\"');\n     * // The $HOME variable is escaped in the first instance, but not in the second.\n     * ```\n     *\n     * **Never pass unsanitized user input to this function. Any input containing shell**\n     * **metacharacters may be used to trigger arbitrary command execution.**\n     *\n     * If a `callback` function is provided, it is called with the arguments `(error, stdout, stderr)`. On success, `error` will be `null`. On error, `error` will be an instance of `Error`. The\n     * `error.code` property will be\n     * the exit code of the process. By convention, any exit code other than `0` indicates an error. `error.signal` will be the signal that terminated the\n     * process.\n     *\n     * The `stdout` and `stderr` arguments passed to the callback will contain the\n     * stdout and stderr output of the child process. By default, Node.js will decode\n     * the output as UTF-8 and pass strings to the callback. The `encoding` option\n     * can be used to specify the character encoding used to decode the stdout and\n     * stderr output. If `encoding` is `'buffer'`, or an unrecognized character\n     * encoding, `Buffer` objects will be passed to the callback instead.\n     *\n     * ```js\n     * import { exec } from 'node:child_process';\n     * exec('cat *.js missing_file | wc -l', (error, stdout, stderr) => {\n     *   if (error) {\n     *     console.error(`exec error: ${error}`);\n     *     return;\n     *   }\n     *   console.log(`stdout: ${stdout}`);\n     *   console.error(`stderr: ${stderr}`);\n     * });\n     * ```\n     *\n     * If `timeout` is greater than `0`, the parent will send the signal\n     * identified by the `killSignal` property (the default is `'SIGTERM'`) if the\n     * child runs longer than `timeout` milliseconds.\n     *\n     * Unlike the [`exec(3)`](http://man7.org/linux/man-pages/man3/exec.3.html) POSIX system call, `child_process.exec()` does not replace\n     * the existing process and uses a shell to execute the command.\n     *\n     * If this method is invoked as its `util.promisify()` ed version, it returns\n     * a `Promise` for an `Object` with `stdout` and `stderr` properties. The returned `ChildProcess` instance is attached to the `Promise` as a `child` property. In\n     * case of an error (including any error resulting in an exit code other than 0), a\n     * rejected promise is returned, with the same `error` object given in the\n     * callback, but with two additional properties `stdout` and `stderr`.\n     *\n     * ```js\n     * import util from 'node:util';\n     * import child_process from 'node:child_process';\n     * const exec = util.promisify(child_process.exec);\n     *\n     * async function lsExample() {\n     *   const { stdout, stderr } = await exec('ls');\n     *   console.log('stdout:', stdout);\n     *   console.error('stderr:', stderr);\n     * }\n     * lsExample();\n     * ```\n     *\n     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except\n     * the error passed to the callback will be an `AbortError`:\n     *\n     * ```js\n     * import { exec } from 'node:child_process';\n     * const controller = new AbortController();\n     * const { signal } = controller;\n     * const child = exec('grep ssh', { signal }, (error) => {\n     *   console.error(error); // an AbortError\n     * });\n     * controller.abort();\n     * ```\n     * @since v0.1.90\n     * @param command The command to run, with space-separated arguments.\n     * @param callback called with the output when process terminates.\n     */\n    function exec(\n        command: string,\n        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function exec(\n        command: string,\n        options: {\n            encoding: \"buffer\" | null;\n        } & ExecOptions,\n        callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function exec(\n        command: string,\n        options: {\n            encoding: BufferEncoding;\n        } & ExecOptions,\n        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function exec(\n        command: string,\n        options: {\n            encoding: BufferEncoding;\n        } & ExecOptions,\n        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function exec(\n        command: string,\n        options: ExecOptions,\n        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function exec(\n        command: string,\n        options: (ObjectEncodingOptions & ExecOptions) | undefined | null,\n        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    interface PromiseWithChild<T> extends Promise<T> {\n        child: ChildProcess;\n    }\n    namespace exec {\n        function __promisify__(command: string): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            command: string,\n            options: {\n                encoding: \"buffer\" | null;\n            } & ExecOptions,\n        ): PromiseWithChild<{\n            stdout: Buffer;\n            stderr: Buffer;\n        }>;\n        function __promisify__(\n            command: string,\n            options: {\n                encoding: BufferEncoding;\n            } & ExecOptions,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            command: string,\n            options: ExecOptions,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            command: string,\n            options?: (ObjectEncodingOptions & ExecOptions) | null,\n        ): PromiseWithChild<{\n            stdout: string | Buffer;\n            stderr: string | Buffer;\n        }>;\n    }\n    interface ExecFileOptions extends CommonOptions, Abortable {\n        maxBuffer?: number | undefined;\n        killSignal?: NodeJS.Signals | number | undefined;\n        windowsVerbatimArguments?: boolean | undefined;\n        shell?: boolean | string | undefined;\n        signal?: AbortSignal | undefined;\n    }\n    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {\n        encoding: \"buffer\" | null;\n    }\n    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {\n        encoding: BufferEncoding;\n    }\n    type ExecFileException =\n        & Omit<ExecException, \"code\">\n        & Omit<NodeJS.ErrnoException, \"code\">\n        & { code?: string | number | undefined | null };\n    /**\n     * The `child_process.execFile()` function is similar to {@link exec} except that it does not spawn a shell by default. Rather, the specified\n     * executable `file` is spawned directly as a new process making it slightly more\n     * efficient than {@link exec}.\n     *\n     * The same options as {@link exec} are supported. Since a shell is\n     * not spawned, behaviors such as I/O redirection and file globbing are not\n     * supported.\n     *\n     * ```js\n     * import { execFile } from 'node:child_process';\n     * const child = execFile('node', ['--version'], (error, stdout, stderr) => {\n     *   if (error) {\n     *     throw error;\n     *   }\n     *   console.log(stdout);\n     * });\n     * ```\n     *\n     * The `stdout` and `stderr` arguments passed to the callback will contain the\n     * stdout and stderr output of the child process. By default, Node.js will decode\n     * the output as UTF-8 and pass strings to the callback. The `encoding` option\n     * can be used to specify the character encoding used to decode the stdout and\n     * stderr output. If `encoding` is `'buffer'`, or an unrecognized character\n     * encoding, `Buffer` objects will be passed to the callback instead.\n     *\n     * If this method is invoked as its `util.promisify()` ed version, it returns\n     * a `Promise` for an `Object` with `stdout` and `stderr` properties. The returned `ChildProcess` instance is attached to the `Promise` as a `child` property. In\n     * case of an error (including any error resulting in an exit code other than 0), a\n     * rejected promise is returned, with the same `error` object given in the\n     * callback, but with two additional properties `stdout` and `stderr`.\n     *\n     * ```js\n     * import util from 'node:util';\n     * import child_process from 'node:child_process';\n     * const execFile = util.promisify(child_process.execFile);\n     * async function getVersion() {\n     *   const { stdout } = await execFile('node', ['--version']);\n     *   console.log(stdout);\n     * }\n     * getVersion();\n     * ```\n     *\n     * **If the `shell` option is enabled, do not pass unsanitized user input to this**\n     * **function. Any input containing shell metacharacters may be used to trigger**\n     * **arbitrary command execution.**\n     *\n     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except\n     * the error passed to the callback will be an `AbortError`:\n     *\n     * ```js\n     * import { execFile } from 'node:child_process';\n     * const controller = new AbortController();\n     * const { signal } = controller;\n     * const child = execFile('node', ['--version'], { signal }, (error) => {\n     *   console.error(error); // an AbortError\n     * });\n     * controller.abort();\n     * ```\n     * @since v0.1.91\n     * @param file The name or path of the executable file to run.\n     * @param args List of string arguments.\n     * @param callback Called with the output when process terminates.\n     */\n    function execFile(file: string): ChildProcess;\n    function execFile(\n        file: string,\n        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,\n    ): ChildProcess;\n    function execFile(file: string, args?: readonly string[] | null): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,\n    ): ChildProcess;\n    // no `options` definitely means stdout/stderr are `string`.\n    function execFile(\n        file: string,\n        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    // `options` with `\"buffer\"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithBufferEncoding,\n        callback: (error: ExecFileException | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        options: ExecFileOptionsWithBufferEncoding,\n        callback: (error: ExecFileException | null, stdout: Buffer, stderr: Buffer) => void,\n    ): ChildProcess;\n    // `options` with well known `encoding` means stdout/stderr are definitely `string`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithStringEncoding,\n        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        options: ExecFileOptionsWithStringEncoding,\n        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    // `options` with an `encoding` whose type is `string` means stdout/stderr could either be `Buffer` or `string`.\n    // There is no guarantee the `encoding` is unknown as `string` is a superset of `BufferEncoding`.\n    function execFile(\n        file: string,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        options: ExecFileOptionsWithOtherEncoding,\n        callback: (error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void,\n    ): ChildProcess;\n    // `options` without an `encoding` means stdout/stderr are definitely `string`.\n    function execFile(\n        file: string,\n        options: ExecFileOptions,\n        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        options: ExecFileOptions,\n        callback: (error: ExecFileException | null, stdout: string, stderr: string) => void,\n    ): ChildProcess;\n    // fallback if nothing else matches. Worst case is always `string | Buffer`.\n    function execFile(\n        file: string,\n        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,\n        callback:\n            | ((error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void)\n            | undefined\n            | null,\n    ): ChildProcess;\n    function execFile(\n        file: string,\n        args: readonly string[] | undefined | null,\n        options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,\n        callback:\n            | ((error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void)\n            | undefined\n            | null,\n    ): ChildProcess;\n    namespace execFile {\n        function __promisify__(file: string): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            file: string,\n            args: readonly string[] | undefined | null,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            file: string,\n            options: ExecFileOptionsWithBufferEncoding,\n        ): PromiseWithChild<{\n            stdout: Buffer;\n            stderr: Buffer;\n        }>;\n        function __promisify__(\n            file: string,\n            args: readonly string[] | undefined | null,\n            options: ExecFileOptionsWithBufferEncoding,\n        ): PromiseWithChild<{\n            stdout: Buffer;\n            stderr: Buffer;\n        }>;\n        function __promisify__(\n            file: string,\n            options: ExecFileOptionsWithStringEncoding,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            file: string,\n            args: readonly string[] | undefined | null,\n            options: ExecFileOptionsWithStringEncoding,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            file: string,\n            options: ExecFileOptionsWithOtherEncoding,\n        ): PromiseWithChild<{\n            stdout: string | Buffer;\n            stderr: string | Buffer;\n        }>;\n        function __promisify__(\n            file: string,\n            args: readonly string[] | undefined | null,\n            options: ExecFileOptionsWithOtherEncoding,\n        ): PromiseWithChild<{\n            stdout: string | Buffer;\n            stderr: string | Buffer;\n        }>;\n        function __promisify__(\n            file: string,\n            options: ExecFileOptions,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            file: string,\n            args: readonly string[] | undefined | null,\n            options: ExecFileOptions,\n        ): PromiseWithChild<{\n            stdout: string;\n            stderr: string;\n        }>;\n        function __promisify__(\n            file: string,\n            options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,\n        ): PromiseWithChild<{\n            stdout: string | Buffer;\n            stderr: string | Buffer;\n        }>;\n        function __promisify__(\n            file: string,\n            args: readonly string[] | undefined | null,\n            options: (ObjectEncodingOptions & ExecFileOptions) | undefined | null,\n        ): PromiseWithChild<{\n            stdout: string | Buffer;\n            stderr: string | Buffer;\n        }>;\n    }\n    interface ForkOptions extends ProcessEnvOptions, MessagingOptions, Abortable {\n        execPath?: string | undefined;\n        execArgv?: string[] | undefined;\n        silent?: boolean | undefined;\n        /**\n         * Can be set to 'pipe', 'inherit', 'overlapped', or 'ignore', or an array of these strings.\n         * If passed as an array, the first element is used for `stdin`, the second for\n         * `stdout`, and the third for `stderr`. A fourth element can be used to\n         * specify the `stdio` behavior beyond the standard streams. See\n         * {@link ChildProcess.stdio} for more information.\n         *\n         * @default 'pipe'\n         */\n        stdio?: StdioOptions | undefined;\n        detached?: boolean | undefined;\n        windowsVerbatimArguments?: boolean | undefined;\n    }\n    /**\n     * The `child_process.fork()` method is a special case of {@link spawn} used specifically to spawn new Node.js processes.\n     * Like {@link spawn}, a `ChildProcess` object is returned. The\n     * returned `ChildProcess` will have an additional communication channel\n     * built-in that allows messages to be passed back and forth between the parent and\n     * child. See `subprocess.send()` for details.\n     *\n     * Keep in mind that spawned Node.js child processes are\n     * independent of the parent with exception of the IPC communication channel\n     * that is established between the two. Each process has its own memory, with\n     * their own V8 instances. Because of the additional resource allocations\n     * required, spawning a large number of child Node.js processes is not\n     * recommended.\n     *\n     * By default, `child_process.fork()` will spawn new Node.js instances using the `process.execPath` of the parent process. The `execPath` property in the `options` object allows for an alternative\n     * execution path to be used.\n     *\n     * Node.js processes launched with a custom `execPath` will communicate with the\n     * parent process using the file descriptor (fd) identified using the\n     * environment variable `NODE_CHANNEL_FD` on the child process.\n     *\n     * Unlike the [`fork(2)`](http://man7.org/linux/man-pages/man2/fork.2.html) POSIX system call, `child_process.fork()` does not clone the\n     * current process.\n     *\n     * The `shell` option available in {@link spawn} is not supported by `child_process.fork()` and will be ignored if set.\n     *\n     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except\n     * the error passed to the callback will be an `AbortError`:\n     *\n     * ```js\n     * if (process.argv[2] === 'child') {\n     *   setTimeout(() => {\n     *     console.log(`Hello from ${process.argv[2]}!`);\n     *   }, 1_000);\n     * } else {\n     *   import { fork } from 'node:child_process';\n     *   const controller = new AbortController();\n     *   const { signal } = controller;\n     *   const child = fork(__filename, ['child'], { signal });\n     *   child.on('error', (err) => {\n     *     // This will be called with err being an AbortError if the controller aborts\n     *   });\n     *   controller.abort(); // Stops the child process\n     * }\n     * ```\n     * @since v0.5.0\n     * @param modulePath The module to run in the child.\n     * @param args List of string arguments.\n     */\n    function fork(modulePath: string | URL, options?: ForkOptions): ChildProcess;\n    function fork(modulePath: string | URL, args?: readonly string[], options?: ForkOptions): ChildProcess;\n    interface SpawnSyncOptions extends CommonSpawnOptions {\n        input?: string | NodeJS.ArrayBufferView | undefined;\n        maxBuffer?: number | undefined;\n        encoding?: BufferEncoding | \"buffer\" | null | undefined;\n    }\n    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {\n        encoding?: \"buffer\" | null | undefined;\n    }\n    interface SpawnSyncReturns<T> {\n        pid: number;\n        output: Array<T | null>;\n        stdout: T;\n        stderr: T;\n        status: number | null;\n        signal: NodeJS.Signals | null;\n        error?: Error | undefined;\n    }\n    /**\n     * The `child_process.spawnSync()` method is generally identical to {@link spawn} with the exception that the function will not return\n     * until the child process has fully closed. When a timeout has been encountered\n     * and `killSignal` is sent, the method won't return until the process has\n     * completely exited. If the process intercepts and handles the `SIGTERM` signal\n     * and doesn't exit, the parent process will wait until the child process has\n     * exited.\n     *\n     * **If the `shell` option is enabled, do not pass unsanitized user input to this**\n     * **function. Any input containing shell metacharacters may be used to trigger**\n     * **arbitrary command execution.**\n     * @since v0.11.12\n     * @param command The command to run.\n     * @param args List of string arguments.\n     */\n    function spawnSync(command: string): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;\n    function spawnSync(command: string, options: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;\n    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<string | Buffer>;\n    function spawnSync(command: string, args: readonly string[]): SpawnSyncReturns<Buffer>;\n    function spawnSync(\n        command: string,\n        args: readonly string[],\n        options: SpawnSyncOptionsWithStringEncoding,\n    ): SpawnSyncReturns<string>;\n    function spawnSync(\n        command: string,\n        args: readonly string[],\n        options: SpawnSyncOptionsWithBufferEncoding,\n    ): SpawnSyncReturns<Buffer>;\n    function spawnSync(\n        command: string,\n        args?: readonly string[],\n        options?: SpawnSyncOptions,\n    ): SpawnSyncReturns<string | Buffer>;\n    interface CommonExecOptions extends CommonOptions {\n        input?: string | NodeJS.ArrayBufferView | undefined;\n        /**\n         * Can be set to 'pipe', 'inherit, or 'ignore', or an array of these strings.\n         * If passed as an array, the first element is used for `stdin`, the second for\n         * `stdout`, and the third for `stderr`. A fourth element can be used to\n         * specify the `stdio` behavior beyond the standard streams. See\n         * {@link ChildProcess.stdio} for more information.\n         *\n         * @default 'pipe'\n         */\n        stdio?: StdioOptions | undefined;\n        killSignal?: NodeJS.Signals | number | undefined;\n        maxBuffer?: number | undefined;\n        encoding?: BufferEncoding | \"buffer\" | null | undefined;\n    }\n    interface ExecSyncOptions extends CommonExecOptions {\n        shell?: string | undefined;\n    }\n    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {\n        encoding?: \"buffer\" | null | undefined;\n    }\n    /**\n     * The `child_process.execSync()` method is generally identical to {@link exec} with the exception that the method will not return\n     * until the child process has fully closed. When a timeout has been encountered\n     * and `killSignal` is sent, the method won't return until the process has\n     * completely exited. If the child process intercepts and handles the `SIGTERM` signal and doesn't exit, the parent process will wait until the child process\n     * has exited.\n     *\n     * If the process times out or has a non-zero exit code, this method will throw.\n     * The `Error` object will contain the entire result from {@link spawnSync}.\n     *\n     * **Never pass unsanitized user input to this function. Any input containing shell**\n     * **metacharacters may be used to trigger arbitrary command execution.**\n     * @since v0.11.12\n     * @param command The command to run.\n     * @return The stdout from the command.\n     */\n    function execSync(command: string): Buffer;\n    function execSync(command: string, options: ExecSyncOptionsWithStringEncoding): string;\n    function execSync(command: string, options: ExecSyncOptionsWithBufferEncoding): Buffer;\n    function execSync(command: string, options?: ExecSyncOptions): string | Buffer;\n    interface ExecFileSyncOptions extends CommonExecOptions {\n        shell?: boolean | string | undefined;\n    }\n    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {\n        encoding: BufferEncoding;\n    }\n    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {\n        encoding?: \"buffer\" | null; // specify `null`.\n    }\n    /**\n     * The `child_process.execFileSync()` method is generally identical to {@link execFile} with the exception that the method will not\n     * return until the child process has fully closed. When a timeout has been\n     * encountered and `killSignal` is sent, the method won't return until the process\n     * has completely exited.\n     *\n     * If the child process intercepts and handles the `SIGTERM` signal and\n     * does not exit, the parent process will still wait until the child process has\n     * exited.\n     *\n     * If the process times out or has a non-zero exit code, this method will throw an `Error` that will include the full result of the underlying {@link spawnSync}.\n     *\n     * **If the `shell` option is enabled, do not pass unsanitized user input to this**\n     * **function. Any input containing shell metacharacters may be used to trigger**\n     * **arbitrary command execution.**\n     * @since v0.11.12\n     * @param file The name or path of the executable file to run.\n     * @param args List of string arguments.\n     * @return The stdout from the command.\n     */\n    function execFileSync(file: string): Buffer;\n    function execFileSync(file: string, options: ExecFileSyncOptionsWithStringEncoding): string;\n    function execFileSync(file: string, options: ExecFileSyncOptionsWithBufferEncoding): Buffer;\n    function execFileSync(file: string, options?: ExecFileSyncOptions): string | Buffer;\n    function execFileSync(file: string, args: readonly string[]): Buffer;\n    function execFileSync(\n        file: string,\n        args: readonly string[],\n        options: ExecFileSyncOptionsWithStringEncoding,\n    ): string;\n    function execFileSync(\n        file: string,\n        args: readonly string[],\n        options: ExecFileSyncOptionsWithBufferEncoding,\n    ): Buffer;\n    function execFileSync(file: string, args?: readonly string[], options?: ExecFileSyncOptions): string | Buffer;\n}\ndeclare module \"node:child_process\" {\n    export * from \"child_process\";\n}\n"
        }
    ]
}