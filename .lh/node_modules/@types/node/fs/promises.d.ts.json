{
    "sourceFile": "node_modules/@types/node/fs/promises.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `fs/promises` API provides asynchronous file system methods that return\n * promises.\n *\n * The promise APIs use the underlying Node.js threadpool to perform file\n * system operations off the event loop thread. These operations are not\n * synchronized or threadsafe. Care must be taken when performing multiple\n * concurrent modifications on the same file or data corruption may occur.\n * @since v10.0.0\n */\ndeclare module \"fs/promises\" {\n    import { Abortable } from \"node:events\";\n    import { Stream } from \"node:stream\";\n    import { ReadableStream } from \"node:stream/web\";\n    import {\n        BigIntStats,\n        BigIntStatsFs,\n        BufferEncodingOption,\n        constants as fsConstants,\n        CopyOptions,\n        Dir,\n        Dirent,\n        GlobOptions,\n        GlobOptionsWithFileTypes,\n        GlobOptionsWithoutFileTypes,\n        MakeDirectoryOptions,\n        Mode,\n        ObjectEncodingOptions,\n        OpenDirOptions,\n        OpenMode,\n        PathLike,\n        ReadStream,\n        ReadVResult,\n        RmDirOptions,\n        RmOptions,\n        StatFsOptions,\n        StatOptions,\n        Stats,\n        StatsFs,\n        TimeLike,\n        WatchEventType,\n        WatchOptions,\n        WriteStream,\n        WriteVResult,\n    } from \"node:fs\";\n    import { Interface as ReadlineInterface } from \"node:readline\";\n    interface FileChangeInfo<T extends string | Buffer> {\n        eventType: WatchEventType;\n        filename: T | null;\n    }\n    interface FlagAndOpenMode {\n        mode?: Mode | undefined;\n        flag?: OpenMode | undefined;\n    }\n    interface FileReadResult<T extends NodeJS.ArrayBufferView> {\n        bytesRead: number;\n        buffer: T;\n    }\n    interface FileReadOptions<T extends NodeJS.ArrayBufferView = Buffer> {\n        /**\n         * @default `Buffer.alloc(0xffff)`\n         */\n        buffer?: T;\n        /**\n         * @default 0\n         */\n        offset?: number | null;\n        /**\n         * @default `buffer.byteLength`\n         */\n        length?: number | null;\n        position?: number | null;\n    }\n    interface CreateReadStreamOptions extends Abortable {\n        encoding?: BufferEncoding | null | undefined;\n        autoClose?: boolean | undefined;\n        emitClose?: boolean | undefined;\n        start?: number | undefined;\n        end?: number | undefined;\n        highWaterMark?: number | undefined;\n    }\n    interface CreateWriteStreamOptions {\n        encoding?: BufferEncoding | null | undefined;\n        autoClose?: boolean | undefined;\n        emitClose?: boolean | undefined;\n        start?: number | undefined;\n        highWaterMark?: number | undefined;\n        flush?: boolean | undefined;\n    }\n    // TODO: Add `EventEmitter` close\n    interface FileHandle {\n        /**\n         * The numeric file descriptor managed by the {FileHandle} object.\n         * @since v10.0.0\n         */\n        readonly fd: number;\n        /**\n         * Alias of `filehandle.writeFile()`.\n         *\n         * When operating on file handles, the mode cannot be changed from what it was set\n         * to with `fsPromises.open()`. Therefore, this is equivalent to `filehandle.writeFile()`.\n         * @since v10.0.0\n         * @return Fulfills with `undefined` upon success.\n         */\n        appendFile(\n            data: string | Uint8Array,\n            options?:\n                | (ObjectEncodingOptions & Abortable)\n                | BufferEncoding\n                | null,\n        ): Promise<void>;\n        /**\n         * Changes the ownership of the file. A wrapper for [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html).\n         * @since v10.0.0\n         * @param uid The file's new owner's user id.\n         * @param gid The file's new group's group id.\n         * @return Fulfills with `undefined` upon success.\n         */\n        chown(uid: number, gid: number): Promise<void>;\n        /**\n         * Modifies the permissions on the file. See [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html).\n         * @since v10.0.0\n         * @param mode the file mode bit mask.\n         * @return Fulfills with `undefined` upon success.\n         */\n        chmod(mode: Mode): Promise<void>;\n        /**\n         * Unlike the 16 KiB default `highWaterMark` for a `stream.Readable`, the stream\n         * returned by this method has a default `highWaterMark` of 64 KiB.\n         *\n         * `options` can include `start` and `end` values to read a range of bytes from\n         * the file instead of the entire file. Both `start` and `end` are inclusive and\n         * start counting at 0, allowed values are in the\n         * \\[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\\] range. If `start` is\n         * omitted or `undefined`, `filehandle.createReadStream()` reads sequentially from\n         * the current file position. The `encoding` can be any one of those accepted by `Buffer`.\n         *\n         * If the `FileHandle` points to a character device that only supports blocking\n         * reads (such as keyboard or sound card), read operations do not finish until data\n         * is available. This can prevent the process from exiting and the stream from\n         * closing naturally.\n         *\n         * By default, the stream will emit a `'close'` event after it has been\n         * destroyed.  Set the `emitClose` option to `false` to change this behavior.\n         *\n         * ```js\n         * import { open } from 'node:fs/promises';\n         *\n         * const fd = await open('/dev/input/event0');\n         * // Create a stream from some character device.\n         * const stream = fd.createReadStream();\n         * setTimeout(() => {\n         *   stream.close(); // This may not close the stream.\n         *   // Artificially marking end-of-stream, as if the underlying resource had\n         *   // indicated end-of-file by itself, allows the stream to close.\n         *   // This does not cancel pending read operations, and if there is such an\n         *   // operation, the process may still not be able to exit successfully\n         *   // until it finishes.\n         *   stream.push(null);\n         *   stream.read(0);\n         * }, 100);\n         * ```\n         *\n         * If `autoClose` is false, then the file descriptor won't be closed, even if\n         * there's an error. It is the application's responsibility to close it and make\n         * sure there's no file descriptor leak. If `autoClose` is set to true (default\n         * behavior), on `'error'` or `'end'` the file descriptor will be closed\n         * automatically.\n         *\n         * An example to read the last 10 bytes of a file which is 100 bytes long:\n         *\n         * ```js\n         * import { open } from 'node:fs/promises';\n         *\n         * const fd = await open('sample.txt');\n         * fd.createReadStream({ start: 90, end: 99 });\n         * ```\n         * @since v16.11.0\n         */\n        createReadStream(options?: CreateReadStreamOptions): ReadStream;\n        /**\n         * `options` may also include a `start` option to allow writing data at some\n         * position past the beginning of the file, allowed values are in the\n         * \\[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\\] range. Modifying a file rather than\n         * replacing it may require the `flags` `open` option to be set to `r+` rather than\n         * the default `r`. The `encoding` can be any one of those accepted by `Buffer`.\n         *\n         * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,\n         * then the file descriptor won't be closed, even if there's an error.\n         * It is the application's responsibility to close it and make sure there's no\n         * file descriptor leak.\n         *\n         * By default, the stream will emit a `'close'` event after it has been\n         * destroyed.  Set the `emitClose` option to `false` to change this behavior.\n         * @since v16.11.0\n         */\n        createWriteStream(options?: CreateWriteStreamOptions): WriteStream;\n        /**\n         * Forces all currently queued I/O operations associated with the file to the\n         * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details.\n         *\n         * Unlike `filehandle.sync` this method does not flush modified metadata.\n         * @since v10.0.0\n         * @return Fulfills with `undefined` upon success.\n         */\n        datasync(): Promise<void>;\n        /**\n         * Request that all data for the open file descriptor is flushed to the storage\n         * device. The specific implementation is operating system and device specific.\n         * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail.\n         * @since v10.0.0\n         * @return Fulfills with `undefined` upon success.\n         */\n        sync(): Promise<void>;\n        /**\n         * Reads data from the file and stores that in the given buffer.\n         *\n         * If the file is not modified concurrently, the end-of-file is reached when the\n         * number of bytes read is zero.\n         * @since v10.0.0\n         * @param buffer A buffer that will be filled with the file data read.\n         * @param offset The location in the buffer at which to start filling.\n         * @param length The number of bytes to read.\n         * @param position The location where to begin reading data from the file. If `null`, data will be read from the current file position, and the position will be updated. If `position` is an\n         * integer, the current file position will remain unchanged.\n         * @return Fulfills upon success with an object with two properties:\n         */\n        read<T extends NodeJS.ArrayBufferView>(\n            buffer: T,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<FileReadResult<T>>;\n        read<T extends NodeJS.ArrayBufferView = Buffer>(\n            buffer: T,\n            options?: FileReadOptions<T>,\n        ): Promise<FileReadResult<T>>;\n        read<T extends NodeJS.ArrayBufferView = Buffer>(options?: FileReadOptions<T>): Promise<FileReadResult<T>>;\n        /**\n         * Returns a byte-oriented `ReadableStream` that may be used to read the file's\n         * contents.\n         *\n         * An error will be thrown if this method is called more than once or is called\n         * after the `FileHandle` is closed or closing.\n         *\n         * ```js\n         * import {\n         *   open,\n         * } from 'node:fs/promises';\n         *\n         * const file = await open('./some/file/to/read');\n         *\n         * for await (const chunk of file.readableWebStream())\n         *   console.log(chunk);\n         *\n         * await file.close();\n         * ```\n         *\n         * While the `ReadableStream` will read the file to completion, it will not\n         * close the `FileHandle` automatically. User code must still call the`fileHandle.close()` method.\n         * @since v17.0.0\n         * @experimental\n         */\n        readableWebStream(): ReadableStream;\n        /**\n         * Asynchronously reads the entire contents of a file.\n         *\n         * If `options` is a string, then it specifies the `encoding`.\n         *\n         * The `FileHandle` has to support reading.\n         *\n         * If one or more `filehandle.read()` calls are made on a file handle and then a `filehandle.readFile()` call is made, the data will be read from the current\n         * position till the end of the file. It doesn't always read from the beginning\n         * of the file.\n         * @since v10.0.0\n         * @return Fulfills upon a successful read with the contents of the file. If no encoding is specified (using `options.encoding`), the data is returned as a {Buffer} object. Otherwise, the\n         * data will be a string.\n         */\n        readFile(\n            options?: {\n                encoding?: null | undefined;\n                flag?: OpenMode | undefined;\n            } | null,\n        ): Promise<Buffer>;\n        /**\n         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n         * The `FileHandle` must have been opened for reading.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        readFile(\n            options:\n                | {\n                    encoding: BufferEncoding;\n                    flag?: OpenMode | undefined;\n                }\n                | BufferEncoding,\n        ): Promise<string>;\n        /**\n         * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n         * The `FileHandle` must have been opened for reading.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        readFile(\n            options?:\n                | (ObjectEncodingOptions & {\n                    flag?: OpenMode | undefined;\n                })\n                | BufferEncoding\n                | null,\n        ): Promise<string | Buffer>;\n        /**\n         * Convenience method to create a `readline` interface and stream over the file.\n         * See `filehandle.createReadStream()` for the options.\n         *\n         * ```js\n         * import { open } from 'node:fs/promises';\n         *\n         * const file = await open('./some/file/to/read');\n         *\n         * for await (const line of file.readLines()) {\n         *   console.log(line);\n         * }\n         * ```\n         * @since v18.11.0\n         */\n        readLines(options?: CreateReadStreamOptions): ReadlineInterface;\n        /**\n         * @since v10.0.0\n         * @return Fulfills with an {fs.Stats} for the file.\n         */\n        stat(\n            opts?: StatOptions & {\n                bigint?: false | undefined;\n            },\n        ): Promise<Stats>;\n        stat(\n            opts: StatOptions & {\n                bigint: true;\n            },\n        ): Promise<BigIntStats>;\n        stat(opts?: StatOptions): Promise<Stats | BigIntStats>;\n        /**\n         * Truncates the file.\n         *\n         * If the file was larger than `len` bytes, only the first `len` bytes will be\n         * retained in the file.\n         *\n         * The following example retains only the first four bytes of the file:\n         *\n         * ```js\n         * import { open } from 'node:fs/promises';\n         *\n         * let filehandle = null;\n         * try {\n         *   filehandle = await open('temp.txt', 'r+');\n         *   await filehandle.truncate(4);\n         * } finally {\n         *   await filehandle?.close();\n         * }\n         * ```\n         *\n         * If the file previously was shorter than `len` bytes, it is extended, and the\n         * extended part is filled with null bytes (`'\\0'`):\n         *\n         * If `len` is negative then `0` will be used.\n         * @since v10.0.0\n         * @param [len=0]\n         * @return Fulfills with `undefined` upon success.\n         */\n        truncate(len?: number): Promise<void>;\n        /**\n         * Change the file system timestamps of the object referenced by the `FileHandle` then fulfills the promise with no arguments upon success.\n         * @since v10.0.0\n         */\n        utimes(atime: TimeLike, mtime: TimeLike): Promise<void>;\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists. `data` can be a string, a buffer, an\n         * [AsyncIterable](https://tc39.github.io/ecma262/#sec-asynciterable-interface), or an\n         * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) object.\n         * The promise is fulfilled with no arguments upon success.\n         *\n         * If `options` is a string, then it specifies the `encoding`.\n         *\n         * The `FileHandle` has to support writing.\n         *\n         * It is unsafe to use `filehandle.writeFile()` multiple times on the same file\n         * without waiting for the promise to be fulfilled (or rejected).\n         *\n         * If one or more `filehandle.write()` calls are made on a file handle and then a`filehandle.writeFile()` call is made, the data will be written from the\n         * current position till the end of the file. It doesn't always write from the\n         * beginning of the file.\n         * @since v10.0.0\n         */\n        writeFile(\n            data: string | Uint8Array,\n            options?:\n                | (ObjectEncodingOptions & Abortable)\n                | BufferEncoding\n                | null,\n        ): Promise<void>;\n        /**\n         * Write `buffer` to the file.\n         *\n         * The promise is fulfilled with an object containing two properties:\n         *\n         * It is unsafe to use `filehandle.write()` multiple times on the same file\n         * without waiting for the promise to be fulfilled (or rejected). For this\n         * scenario, use `filehandle.createWriteStream()`.\n         *\n         * On Linux, positional writes do not work when the file is opened in append mode.\n         * The kernel ignores the position argument and always appends the data to\n         * the end of the file.\n         * @since v10.0.0\n         * @param offset The start position from within `buffer` where the data to write begins.\n         * @param [length=buffer.byteLength - offset] The number of bytes from `buffer` to write.\n         * @param [position='null'] The offset from the beginning of the file where the data from `buffer` should be written. If `position` is not a `number`, the data will be written at the current\n         * position. See the POSIX pwrite(2) documentation for more detail.\n         */\n        write<TBuffer extends Uint8Array>(\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{\n            bytesWritten: number;\n            buffer: TBuffer;\n        }>;\n        write<TBuffer extends Uint8Array>(\n            buffer: TBuffer,\n            options?: { offset?: number; length?: number; position?: number },\n        ): Promise<{\n            bytesWritten: number;\n            buffer: TBuffer;\n        }>;\n        write(\n            data: string,\n            position?: number | null,\n            encoding?: BufferEncoding | null,\n        ): Promise<{\n            bytesWritten: number;\n            buffer: string;\n        }>;\n        /**\n         * Write an array of [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) s to the file.\n         *\n         * The promise is fulfilled with an object containing a two properties:\n         *\n         * It is unsafe to call `writev()` multiple times on the same file without waiting\n         * for the promise to be fulfilled (or rejected).\n         *\n         * On Linux, positional writes don't work when the file is opened in append mode.\n         * The kernel ignores the position argument and always appends the data to\n         * the end of the file.\n         * @since v12.9.0\n         * @param [position='null'] The offset from the beginning of the file where the data from `buffers` should be written. If `position` is not a `number`, the data will be written at the current\n         * position.\n         */\n        writev(buffers: readonly NodeJS.ArrayBufferView[], position?: number): Promise<WriteVResult>;\n        /**\n         * Read from a file and write to an array of [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView) s\n         * @since v13.13.0, v12.17.0\n         * @param [position='null'] The offset from the beginning of the file where the data should be read from. If `position` is not a `number`, the data will be read from the current position.\n         * @return Fulfills upon success an object containing two properties:\n         */\n        readv(buffers: readonly NodeJS.ArrayBufferView[], position?: number): Promise<ReadVResult>;\n        /**\n         * Closes the file handle after waiting for any pending operation on the handle to\n         * complete.\n         *\n         * ```js\n         * import { open } from 'node:fs/promises';\n         *\n         * let filehandle;\n         * try {\n         *   filehandle = await open('thefile.txt', 'r');\n         * } finally {\n         *   await filehandle?.close();\n         * }\n         * ```\n         * @since v10.0.0\n         * @return Fulfills with `undefined` upon success.\n         */\n        close(): Promise<void>;\n        /**\n         * An alias for {@link FileHandle.close()}.\n         * @since v20.4.0\n         */\n        [Symbol.asyncDispose](): Promise<void>;\n    }\n    const constants: typeof fsConstants;\n    /**\n     * Tests a user's permissions for the file or directory specified by `path`.\n     * The `mode` argument is an optional integer that specifies the accessibility\n     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`\n     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for\n     * possible values of `mode`.\n     *\n     * If the accessibility check is successful, the promise is fulfilled with no\n     * value. If any of the accessibility checks fail, the promise is rejected\n     * with an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object. The following example checks if the file`/etc/passwd` can be read and\n     * written by the current process.\n     *\n     * ```js\n     * import { access, constants } from 'node:fs/promises';\n     *\n     * try {\n     *   await access('/etc/passwd', constants.R_OK | constants.W_OK);\n     *   console.log('can access');\n     * } catch {\n     *   console.error('cannot access');\n     * }\n     * ```\n     *\n     * Using `fsPromises.access()` to check for the accessibility of a file before\n     * calling `fsPromises.open()` is not recommended. Doing so introduces a race\n     * condition, since other processes may change the file's state between the two\n     * calls. Instead, user code should open/read/write the file directly and handle\n     * the error raised if the file is not accessible.\n     * @since v10.0.0\n     * @param [mode=fs.constants.F_OK]\n     * @return Fulfills with `undefined` upon success.\n     */\n    function access(path: PathLike, mode?: number): Promise<void>;\n    /**\n     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it\n     * already exists.\n     *\n     * No guarantees are made about the atomicity of the copy operation. If an\n     * error occurs after the destination file has been opened for writing, an attempt\n     * will be made to remove the destination.\n     *\n     * ```js\n     * import { copyFile, constants } from 'node:fs/promises';\n     *\n     * try {\n     *   await copyFile('source.txt', 'destination.txt');\n     *   console.log('source.txt was copied to destination.txt');\n     * } catch {\n     *   console.error('The file could not be copied');\n     * }\n     *\n     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.\n     * try {\n     *   await copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL);\n     *   console.log('source.txt was copied to destination.txt');\n     * } catch {\n     *   console.error('The file could not be copied');\n     * }\n     * ```\n     * @since v10.0.0\n     * @param src source filename to copy\n     * @param dest destination filename of the copy operation\n     * @param [mode=0] Optional modifiers that specify the behavior of the copy operation. It is possible to create a mask consisting of the bitwise OR of two or more values (e.g.\n     * `fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`)\n     * @return Fulfills with `undefined` upon success.\n     */\n    function copyFile(src: PathLike, dest: PathLike, mode?: number): Promise<void>;\n    /**\n     * Opens a `FileHandle`.\n     *\n     * Refer to the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more detail.\n     *\n     * Some characters (`< > : \" / \\ | ? *`) are reserved under Windows as documented\n     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains\n     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).\n     * @since v10.0.0\n     * @param [flags='r'] See `support of file system `flags``.\n     * @param [mode=0o666] Sets the file mode (permission and sticky bits) if the file is created.\n     * @return Fulfills with a {FileHandle} object.\n     */\n    function open(path: PathLike, flags?: string | number, mode?: Mode): Promise<FileHandle>;\n    /**\n     * Renames `oldPath` to `newPath`.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    /**\n     * Truncates (shortens or extends the length) of the content at `path` to `len` bytes.\n     * @since v10.0.0\n     * @param [len=0]\n     * @return Fulfills with `undefined` upon success.\n     */\n    function truncate(path: PathLike, len?: number): Promise<void>;\n    /**\n     * Removes the directory identified by `path`.\n     *\n     * Using `fsPromises.rmdir()` on a file (not a directory) results in the\n     * promise being rejected with an `ENOENT` error on Windows and an `ENOTDIR` error on POSIX.\n     *\n     * To get a behavior similar to the `rm -rf` Unix command, use `fsPromises.rm()` with options `{ recursive: true, force: true }`.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function rmdir(path: PathLike, options?: RmDirOptions): Promise<void>;\n    /**\n     * Removes files and directories (modeled on the standard POSIX `rm` utility).\n     * @since v14.14.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function rm(path: PathLike, options?: RmOptions): Promise<void>;\n    /**\n     * Asynchronously creates a directory.\n     *\n     * The optional `options` argument can be an integer specifying `mode` (permission\n     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fsPromises.mkdir()` when `path` is a directory\n     * that exists results in a\n     * rejection only when `recursive` is false.\n     *\n     * ```js\n     * import { mkdir } from 'node:fs/promises';\n     *\n     * try {\n     *   const projectFolder = new URL('./test/project/', import.meta.url);\n     *   const createDir = await mkdir(projectFolder, { recursive: true });\n     *\n     *   console.log(`created ${createDir}`);\n     * } catch (err) {\n     *   console.error(err.message);\n     * }\n     * ```\n     * @since v10.0.0\n     * @return Upon success, fulfills with `undefined` if `recursive` is `false`, or the first directory path created if `recursive` is `true`.\n     */\n    function mkdir(\n        path: PathLike,\n        options: MakeDirectoryOptions & {\n            recursive: true;\n        },\n    ): Promise<string | undefined>;\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(\n        path: PathLike,\n        options?:\n            | Mode\n            | (MakeDirectoryOptions & {\n                recursive?: false | undefined;\n            })\n            | null,\n    ): Promise<void>;\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    function mkdir(path: PathLike, options?: Mode | MakeDirectoryOptions | null): Promise<string | undefined>;\n    /**\n     * Reads the contents of a directory.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the filenames. If the `encoding` is set to `'buffer'`, the filenames returned\n     * will be passed as `Buffer` objects.\n     *\n     * If `options.withFileTypes` is set to `true`, the returned array will contain `fs.Dirent` objects.\n     *\n     * ```js\n     * import { readdir } from 'node:fs/promises';\n     *\n     * try {\n     *   const files = await readdir(path);\n     *   for (const file of files)\n     *     console.log(file);\n     * } catch (err) {\n     *   console.error(err);\n     * }\n     * ```\n     * @since v10.0.0\n     * @return Fulfills with an array of the names of the files in the directory excluding `'.'` and `'..'`.\n     */\n    function readdir(\n        path: PathLike,\n        options?:\n            | (ObjectEncodingOptions & {\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            })\n            | BufferEncoding\n            | null,\n    ): Promise<string[]>;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options:\n            | {\n                encoding: \"buffer\";\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            }\n            | \"buffer\",\n    ): Promise<Buffer[]>;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readdir(\n        path: PathLike,\n        options?:\n            | (ObjectEncodingOptions & {\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            })\n            | BufferEncoding\n            | null,\n    ): Promise<string[] | Buffer[]>;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    function readdir(\n        path: PathLike,\n        options: ObjectEncodingOptions & {\n            withFileTypes: true;\n            recursive?: boolean | undefined;\n        },\n    ): Promise<Dirent[]>;\n    /**\n     * Reads the contents of the symbolic link referred to by `path`. See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more detail. The promise is\n     * fulfilled with the`linkString` upon success.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the link path returned. If the `encoding` is set to `'buffer'`, the link path\n     * returned will be passed as a `Buffer` object.\n     * @since v10.0.0\n     * @return Fulfills with the `linkString` upon success.\n     */\n    function readlink(path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function readlink(path: PathLike, options?: ObjectEncodingOptions | string | null): Promise<string | Buffer>;\n    /**\n     * Creates a symbolic link.\n     *\n     * The `type` argument is only used on Windows platforms and can be one of `'dir'`, `'file'`, or `'junction'`. If the `type` argument is not a string, Node.js will\n     * autodetect `target` type and use `'file'` or `'dir'`. If the `target` does not\n     * exist, `'file'` will be used. Windows junction points require the destination\n     * path to be absolute. When using `'junction'`, the `target` argument will\n     * automatically be normalized to absolute path. Junction points on NTFS volumes\n     * can only point to directories.\n     * @since v10.0.0\n     * @param [type='null']\n     * @return Fulfills with `undefined` upon success.\n     */\n    function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n    /**\n     * Equivalent to `fsPromises.stat()` unless `path` refers to a symbolic link,\n     * in which case the link itself is stat-ed, not the file that it refers to.\n     * Refer to the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) document for more detail.\n     * @since v10.0.0\n     * @return Fulfills with the {fs.Stats} object for the given symbolic link `path`.\n     */\n    function lstat(\n        path: PathLike,\n        opts?: StatOptions & {\n            bigint?: false | undefined;\n        },\n    ): Promise<Stats>;\n    function lstat(\n        path: PathLike,\n        opts: StatOptions & {\n            bigint: true;\n        },\n    ): Promise<BigIntStats>;\n    function lstat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;\n    /**\n     * @since v10.0.0\n     * @return Fulfills with the {fs.Stats} object for the given `path`.\n     */\n    function stat(\n        path: PathLike,\n        opts?: StatOptions & {\n            bigint?: false | undefined;\n        },\n    ): Promise<Stats>;\n    function stat(\n        path: PathLike,\n        opts: StatOptions & {\n            bigint: true;\n        },\n    ): Promise<BigIntStats>;\n    function stat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;\n    /**\n     * @since v19.6.0, v18.15.0\n     * @return Fulfills with the {fs.StatFs} object for the given `path`.\n     */\n    function statfs(\n        path: PathLike,\n        opts?: StatFsOptions & {\n            bigint?: false | undefined;\n        },\n    ): Promise<StatsFs>;\n    function statfs(\n        path: PathLike,\n        opts: StatFsOptions & {\n            bigint: true;\n        },\n    ): Promise<BigIntStatsFs>;\n    function statfs(path: PathLike, opts?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;\n    /**\n     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    /**\n     * If `path` refers to a symbolic link, then the link is removed without affecting\n     * the file or directory to which that link refers. If the `path` refers to a file\n     * path that is not a symbolic link, the file is deleted. See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more detail.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function unlink(path: PathLike): Promise<void>;\n    /**\n     * Changes the permissions of a file.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function chmod(path: PathLike, mode: Mode): Promise<void>;\n    /**\n     * Changes the permissions on a symbolic link.\n     *\n     * This method is only implemented on macOS.\n     * @deprecated Since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function lchmod(path: PathLike, mode: Mode): Promise<void>;\n    /**\n     * Changes the ownership on a symbolic link.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n    /**\n     * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`, with the difference that if the path refers to a\n     * symbolic link, then the link is not dereferenced: instead, the timestamps of\n     * the symbolic link itself are changed.\n     * @since v14.5.0, v12.19.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;\n    /**\n     * Changes the ownership of a file.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n    /**\n     * Change the file system timestamps of the object referenced by `path`.\n     *\n     * The `atime` and `mtime` arguments follow these rules:\n     *\n     * * Values can be either numbers representing Unix epoch time, `Date`s, or a\n     * numeric string like `'123456789.0'`.\n     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.\n     * @since v10.0.0\n     * @return Fulfills with `undefined` upon success.\n     */\n    function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;\n    /**\n     * Determines the actual location of `path` using the same semantics as the `fs.realpath.native()` function.\n     *\n     * Only paths that can be converted to UTF8 strings are supported.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the path. If the `encoding` is set to `'buffer'`, the path returned will be\n     * passed as a `Buffer` object.\n     *\n     * On Linux, when Node.js is linked against musl libc, the procfs file system must\n     * be mounted on `/proc` in order for this function to work. Glibc does not have\n     * this restriction.\n     * @since v10.0.0\n     * @return Fulfills with the resolved path upon success.\n     */\n    function realpath(path: PathLike, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function realpath(\n        path: PathLike,\n        options?: ObjectEncodingOptions | BufferEncoding | null,\n    ): Promise<string | Buffer>;\n    /**\n     * Creates a unique temporary directory. A unique directory name is generated by\n     * appending six random characters to the end of the provided `prefix`. Due to\n     * platform inconsistencies, avoid trailing `X` characters in `prefix`. Some\n     * platforms, notably the BSDs, can return more than six random characters, and\n     * replace trailing `X` characters in `prefix` with random characters.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use.\n     *\n     * ```js\n     * import { mkdtemp } from 'node:fs/promises';\n     * import { join } from 'node:path';\n     * import { tmpdir } from 'node:os';\n     *\n     * try {\n     *   await mkdtemp(join(tmpdir(), 'foo-'));\n     * } catch (err) {\n     *   console.error(err);\n     * }\n     * ```\n     *\n     * The `fsPromises.mkdtemp()` method will append the six randomly selected\n     * characters directly to the `prefix` string. For instance, given a directory `/tmp`, if the intention is to create a temporary directory _within_ `/tmp`, the `prefix` must end with a trailing\n     * platform-specific path separator\n     * (`import { sep } from 'node:path'`).\n     * @since v10.0.0\n     * @return Fulfills with a string containing the file system path of the newly created temporary directory.\n     */\n    function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string>;\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options: BufferEncodingOption): Promise<Buffer>;\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    function mkdtemp(prefix: string, options?: ObjectEncodingOptions | BufferEncoding | null): Promise<string | Buffer>;\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists. `data` can be a string, a buffer, an\n     * [AsyncIterable](https://tc39.github.io/ecma262/#sec-asynciterable-interface), or an\n     * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) object.\n     *\n     * The `encoding` option is ignored if `data` is a buffer.\n     *\n     * If `options` is a string, then it specifies the encoding.\n     *\n     * The `mode` option only affects the newly created file. See `fs.open()` for more details.\n     *\n     * Any specified `FileHandle` has to support writing.\n     *\n     * It is unsafe to use `fsPromises.writeFile()` multiple times on the same file\n     * without waiting for the promise to be settled.\n     *\n     * Similarly to `fsPromises.readFile` \\- `fsPromises.writeFile` is a convenience\n     * method that performs multiple `write` calls internally to write the buffer\n     * passed to it. For performance sensitive code consider using `fs.createWriteStream()` or `filehandle.createWriteStream()`.\n     *\n     * It is possible to use an `AbortSignal` to cancel an `fsPromises.writeFile()`.\n     * Cancelation is \"best effort\", and some amount of data is likely still\n     * to be written.\n     *\n     * ```js\n     * import { writeFile } from 'node:fs/promises';\n     * import { Buffer } from 'node:buffer';\n     *\n     * try {\n     *   const controller = new AbortController();\n     *   const { signal } = controller;\n     *   const data = new Uint8Array(Buffer.from('Hello Node.js'));\n     *   const promise = writeFile('message.txt', data, { signal });\n     *\n     *   // Abort the request before the promise settles.\n     *   controller.abort();\n     *\n     *   await promise;\n     * } catch (err) {\n     *   // When a request is aborted - err is an AbortError\n     *   console.error(err);\n     * }\n     * ```\n     *\n     * Aborting an ongoing request does not abort individual operating\n     * system requests but rather the internal buffering `fs.writeFile` performs.\n     * @since v10.0.0\n     * @param file filename or `FileHandle`\n     * @return Fulfills with `undefined` upon success.\n     */\n    function writeFile(\n        file: PathLike | FileHandle,\n        data:\n            | string\n            | NodeJS.ArrayBufferView\n            | Iterable<string | NodeJS.ArrayBufferView>\n            | AsyncIterable<string | NodeJS.ArrayBufferView>\n            | Stream,\n        options?:\n            | (ObjectEncodingOptions & {\n                mode?: Mode | undefined;\n                flag?: OpenMode | undefined;\n                /**\n                 * If all data is successfully written to the file, and `flush`\n                 * is `true`, `filehandle.sync()` is used to flush the data.\n                 * @default false\n                 */\n                flush?: boolean | undefined;\n            } & Abortable)\n            | BufferEncoding\n            | null,\n    ): Promise<void>;\n    /**\n     * Asynchronously append data to a file, creating the file if it does not yet\n     * exist. `data` can be a string or a `Buffer`.\n     *\n     * If `options` is a string, then it specifies the `encoding`.\n     *\n     * The `mode` option only affects the newly created file. See `fs.open()` for more details.\n     *\n     * The `path` may be specified as a `FileHandle` that has been opened\n     * for appending (using `fsPromises.open()`).\n     * @since v10.0.0\n     * @param path filename or {FileHandle}\n     * @return Fulfills with `undefined` upon success.\n     */\n    function appendFile(\n        path: PathLike | FileHandle,\n        data: string | Uint8Array,\n        options?: (ObjectEncodingOptions & FlagAndOpenMode & { flush?: boolean | undefined }) | BufferEncoding | null,\n    ): Promise<void>;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     *\n     * If no encoding is specified (using `options.encoding`), the data is returned\n     * as a `Buffer` object. Otherwise, the data will be a string.\n     *\n     * If `options` is a string, then it specifies the encoding.\n     *\n     * When the `path` is a directory, the behavior of `fsPromises.readFile()` is\n     * platform-specific. On macOS, Linux, and Windows, the promise will be rejected\n     * with an error. On FreeBSD, a representation of the directory's contents will be\n     * returned.\n     *\n     * An example of reading a `package.json` file located in the same directory of the\n     * running code:\n     *\n     * ```js\n     * import { readFile } from 'node:fs/promises';\n     * try {\n     *   const filePath = new URL('./package.json', import.meta.url);\n     *   const contents = await readFile(filePath, { encoding: 'utf8' });\n     *   console.log(contents);\n     * } catch (err) {\n     *   console.error(err.message);\n     * }\n     * ```\n     *\n     * It is possible to abort an ongoing `readFile` using an `AbortSignal`. If a\n     * request is aborted the promise returned is rejected with an `AbortError`:\n     *\n     * ```js\n     * import { readFile } from 'node:fs/promises';\n     *\n     * try {\n     *   const controller = new AbortController();\n     *   const { signal } = controller;\n     *   const promise = readFile(fileName, { signal });\n     *\n     *   // Abort the request before the promise settles.\n     *   controller.abort();\n     *\n     *   await promise;\n     * } catch (err) {\n     *   // When a request is aborted - err is an AbortError\n     *   console.error(err);\n     * }\n     * ```\n     *\n     * Aborting an ongoing request does not abort individual operating\n     * system requests but rather the internal buffering `fs.readFile` performs.\n     *\n     * Any specified `FileHandle` has to support reading.\n     * @since v10.0.0\n     * @param path filename or `FileHandle`\n     * @return Fulfills with the contents of the file.\n     */\n    function readFile(\n        path: PathLike | FileHandle,\n        options?:\n            | ({\n                encoding?: null | undefined;\n                flag?: OpenMode | undefined;\n            } & Abortable)\n            | null,\n    ): Promise<Buffer>;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(\n        path: PathLike | FileHandle,\n        options:\n            | ({\n                encoding: BufferEncoding;\n                flag?: OpenMode | undefined;\n            } & Abortable)\n            | BufferEncoding,\n    ): Promise<string>;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    function readFile(\n        path: PathLike | FileHandle,\n        options?:\n            | (\n                & ObjectEncodingOptions\n                & Abortable\n                & {\n                    flag?: OpenMode | undefined;\n                }\n            )\n            | BufferEncoding\n            | null,\n    ): Promise<string | Buffer>;\n    /**\n     * Asynchronously open a directory for iterative scanning. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for more detail.\n     *\n     * Creates an `fs.Dir`, which contains all further functions for reading from\n     * and cleaning up the directory.\n     *\n     * The `encoding` option sets the encoding for the `path` while opening the\n     * directory and subsequent read operations.\n     *\n     * Example using async iteration:\n     *\n     * ```js\n     * import { opendir } from 'node:fs/promises';\n     *\n     * try {\n     *   const dir = await opendir('./');\n     *   for await (const dirent of dir)\n     *     console.log(dirent.name);\n     * } catch (err) {\n     *   console.error(err);\n     * }\n     * ```\n     *\n     * When using the async iterator, the `fs.Dir` object will be automatically\n     * closed after the iterator exits.\n     * @since v12.12.0\n     * @return Fulfills with an {fs.Dir}.\n     */\n    function opendir(path: PathLike, options?: OpenDirOptions): Promise<Dir>;\n    /**\n     * Returns an async iterator that watches for changes on `filename`, where `filename`is either a file or a directory.\n     *\n     * ```js\n     * import { watch } from 'node:fs/promises';\n     *\n     * const ac = new AbortController();\n     * const { signal } = ac;\n     * setTimeout(() => ac.abort(), 10000);\n     *\n     * (async () => {\n     *   try {\n     *     const watcher = watch(__filename, { signal });\n     *     for await (const event of watcher)\n     *       console.log(event);\n     *   } catch (err) {\n     *     if (err.name === 'AbortError')\n     *       return;\n     *     throw err;\n     *   }\n     * })();\n     * ```\n     *\n     * On most platforms, `'rename'` is emitted whenever a filename appears or\n     * disappears in the directory.\n     *\n     * All the `caveats` for `fs.watch()` also apply to `fsPromises.watch()`.\n     * @since v15.9.0, v14.18.0\n     * @return of objects with the properties:\n     */\n    function watch(\n        filename: PathLike,\n        options:\n            | (WatchOptions & {\n                encoding: \"buffer\";\n            })\n            | \"buffer\",\n    ): AsyncIterable<FileChangeInfo<Buffer>>;\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(filename: PathLike, options?: WatchOptions | BufferEncoding): AsyncIterable<FileChangeInfo<string>>;\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: WatchOptions | string,\n    ): AsyncIterable<FileChangeInfo<string>> | AsyncIterable<FileChangeInfo<Buffer>>;\n    /**\n     * Asynchronously copies the entire directory structure from `src` to `dest`,\n     * including subdirectories and files.\n     *\n     * When copying a directory to another directory, globs are not supported and\n     * behavior is similar to `cp dir1/ dir2/`.\n     * @since v16.7.0\n     * @experimental\n     * @param src source path to copy.\n     * @param dest destination path to copy to.\n     * @return Fulfills with `undefined` upon success.\n     */\n    function cp(source: string | URL, destination: string | URL, opts?: CopyOptions): Promise<void>;\n    /**\n     * Retrieves the files matching the specified pattern.\n     */\n    function glob(pattern: string | string[]): NodeJS.AsyncIterator<string>;\n    function glob(\n        pattern: string | string[],\n        opt: GlobOptionsWithFileTypes,\n    ): NodeJS.AsyncIterator<Dirent>;\n    function glob(\n        pattern: string | string[],\n        opt: GlobOptionsWithoutFileTypes,\n    ): NodeJS.AsyncIterator<string>;\n    function glob(\n        pattern: string | string[],\n        opt: GlobOptions,\n    ): NodeJS.AsyncIterator<Dirent | string>;\n}\ndeclare module \"node:fs/promises\" {\n    export * from \"fs/promises\";\n}\n"
        }
    ]
}