{
    "sourceFile": "node_modules/@types/node/test.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:test` module facilitates the creation of JavaScript tests.\n * To access it:\n *\n * ```js\n * import test from 'node:test';\n * ```\n *\n * This module is only available under the `node:` scheme. The following will not\n * work:\n *\n * ```js\n * import test from 'node:test';\n * ```\n *\n * Tests created via the `test` module consist of a single function that is\n * processed in one of three ways:\n *\n * 1. A synchronous function that is considered failing if it throws an exception,\n * and is considered passing otherwise.\n * 2. A function that returns a `Promise` that is considered failing if the `Promise` rejects, and is considered passing if the `Promise` fulfills.\n * 3. A function that receives a callback function. If the callback receives any\n * truthy value as its first argument, the test is considered failing. If a\n * falsy value is passed as the first argument to the callback, the test is\n * considered passing. If the test function receives a callback function and\n * also returns a `Promise`, the test will fail.\n *\n * The following example illustrates how tests are written using the `test` module.\n *\n * ```js\n * test('synchronous passing test', (t) => {\n *   // This test passes because it does not throw an exception.\n *   assert.strictEqual(1, 1);\n * });\n *\n * test('synchronous failing test', (t) => {\n *   // This test fails because it throws an exception.\n *   assert.strictEqual(1, 2);\n * });\n *\n * test('asynchronous passing test', async (t) => {\n *   // This test passes because the Promise returned by the async\n *   // function is settled and not rejected.\n *   assert.strictEqual(1, 1);\n * });\n *\n * test('asynchronous failing test', async (t) => {\n *   // This test fails because the Promise returned by the async\n *   // function is rejected.\n *   assert.strictEqual(1, 2);\n * });\n *\n * test('failing test using Promises', (t) => {\n *   // Promises can be used directly as well.\n *   return new Promise((resolve, reject) => {\n *     setImmediate(() => {\n *       reject(new Error('this will cause the test to fail'));\n *     });\n *   });\n * });\n *\n * test('callback passing test', (t, done) => {\n *   // done() is the callback function. When the setImmediate() runs, it invokes\n *   // done() with no arguments.\n *   setImmediate(done);\n * });\n *\n * test('callback failing test', (t, done) => {\n *   // When the setImmediate() runs, done() is invoked with an Error object and\n *   // the test fails.\n *   setImmediate(() => {\n *     done(new Error('callback failure'));\n *   });\n * });\n * ```\n *\n * If any tests fail, the process exit code is set to `1`.\n * @since v18.0.0, v16.17.0\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/test.js)\n */\ndeclare module \"node:test\" {\n    import { Readable } from \"node:stream\";\n    /**\n     * **Note:** `shard` is used to horizontally parallelize test running across\n     * machines or processes, ideal for large-scale executions across varied\n     * environments. It's incompatible with `watch` mode, tailored for rapid\n     * code iteration by automatically rerunning tests on file changes.\n     *\n     * ```js\n     * import { tap } from 'node:test/reporters';\n     * import { run } from 'node:test';\n     * import process from 'node:process';\n     * import path from 'node:path';\n     *\n     * run({ files: [path.resolve('./tests/test.js')] })\n     *   .compose(tap)\n     *   .pipe(process.stdout);\n     * ```\n     * @since v18.9.0, v16.19.0\n     * @param options Configuration options for running tests.\n     */\n    function run(options?: RunOptions): TestsStream;\n    /**\n     * The `test()` function is the value imported from the `test` module. Each\n     * invocation of this function results in reporting the test to the `TestsStream`.\n     *\n     * The `TestContext` object passed to the `fn` argument can be used to perform\n     * actions related to the current test. Examples include skipping the test, adding\n     * additional diagnostic information, or creating subtests.\n     *\n     * `test()` returns a `Promise` that fulfills once the test completes.\n     * if `test()` is called within a suite, it fulfills immediately.\n     * The return value can usually be discarded for top level tests.\n     * However, the return value from subtests should be used to prevent the parent\n     * test from finishing first and cancelling the subtest\n     * as shown in the following example.\n     *\n     * ```js\n     * test('top level test', async (t) => {\n     *   // The setTimeout() in the following subtest would cause it to outlive its\n     *   // parent test if 'await' is removed on the next line. Once the parent test\n     *   // completes, it will cancel any outstanding subtests.\n     *   await t.test('longer running subtest', async (t) => {\n     *     return new Promise((resolve, reject) => {\n     *       setTimeout(resolve, 1000);\n     *     });\n     *   });\n     * });\n     * ```\n     *\n     * The `timeout` option can be used to fail the test if it takes longer than `timeout` milliseconds to complete. However, it is not a reliable mechanism for\n     * canceling tests because a running test might block the application thread and\n     * thus prevent the scheduled cancellation.\n     * @since v18.0.0, v16.17.0\n     * @param name The name of the test, which is displayed when reporting test results.\n     * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.\n     * @param options Configuration options for the test.\n     * @param fn The function under test. The first argument to this function is a {@link TestContext} object.\n     * If the test uses callbacks, the callback function is passed as the second argument.\n     * @return Fulfilled with `undefined` once the test completes, or immediately if the test runs within a suite.\n     */\n    function test(name?: string, fn?: TestFn): Promise<void>;\n    function test(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n    function test(options?: TestOptions, fn?: TestFn): Promise<void>;\n    function test(fn?: TestFn): Promise<void>;\n    namespace test {\n        export {\n            after,\n            afterEach,\n            assert,\n            before,\n            beforeEach,\n            describe,\n            it,\n            mock,\n            only,\n            run,\n            skip,\n            snapshot,\n            suite,\n            test,\n            todo,\n        };\n    }\n    /**\n     * The `suite()` function is imported from the `node:test` module.\n     * @param name The name of the suite, which is displayed when reporting test results.\n     * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.\n     * @param options Configuration options for the suite. This supports the same options as {@link test}.\n     * @param fn The suite function declaring nested tests and suites. The first argument to this function is a {@link SuiteContext} object.\n     * @return Immediately fulfilled with `undefined`.\n     * @since v20.13.0\n     */\n    function suite(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n    function suite(name?: string, fn?: SuiteFn): Promise<void>;\n    function suite(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n    function suite(fn?: SuiteFn): Promise<void>;\n    namespace suite {\n        /**\n         * Shorthand for skipping a suite. This is the same as calling {@link suite} with `options.skip` set to `true`.\n         * @since v20.13.0\n         */\n        function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function skip(name?: string, fn?: SuiteFn): Promise<void>;\n        function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function skip(fn?: SuiteFn): Promise<void>;\n        /**\n         * Shorthand for marking a suite as `TODO`. This is the same as calling {@link suite} with `options.todo` set to `true`.\n         * @since v20.13.0\n         */\n        function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function todo(name?: string, fn?: SuiteFn): Promise<void>;\n        function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function todo(fn?: SuiteFn): Promise<void>;\n        /**\n         * Shorthand for marking a suite as `only`. This is the same as calling {@link suite} with `options.only` set to `true`.\n         * @since v20.13.0\n         */\n        function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function only(name?: string, fn?: SuiteFn): Promise<void>;\n        function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function only(fn?: SuiteFn): Promise<void>;\n    }\n    /**\n     * Alias for {@link suite}.\n     *\n     * The `describe()` function is imported from the `node:test` module.\n     */\n    function describe(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n    function describe(name?: string, fn?: SuiteFn): Promise<void>;\n    function describe(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n    function describe(fn?: SuiteFn): Promise<void>;\n    namespace describe {\n        /**\n         * Shorthand for skipping a suite. This is the same as calling {@link describe} with `options.skip` set to `true`.\n         * @since v18.15.0\n         */\n        function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function skip(name?: string, fn?: SuiteFn): Promise<void>;\n        function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function skip(fn?: SuiteFn): Promise<void>;\n        /**\n         * Shorthand for marking a suite as `TODO`. This is the same as calling {@link describe} with `options.todo` set to `true`.\n         * @since v18.15.0\n         */\n        function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function todo(name?: string, fn?: SuiteFn): Promise<void>;\n        function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function todo(fn?: SuiteFn): Promise<void>;\n        /**\n         * Shorthand for marking a suite as `only`. This is the same as calling {@link describe} with `options.only` set to `true`.\n         * @since v18.15.0\n         */\n        function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function only(name?: string, fn?: SuiteFn): Promise<void>;\n        function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;\n        function only(fn?: SuiteFn): Promise<void>;\n    }\n    /**\n     * Alias for {@link test}.\n     *\n     * The `it()` function is imported from the `node:test` module.\n     * @since v18.6.0, v16.17.0\n     */\n    function it(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n    function it(name?: string, fn?: TestFn): Promise<void>;\n    function it(options?: TestOptions, fn?: TestFn): Promise<void>;\n    function it(fn?: TestFn): Promise<void>;\n    namespace it {\n        /**\n         * Shorthand for skipping a test. This is the same as calling {@link it} with `options.skip` set to `true`.\n         */\n        function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n        function skip(name?: string, fn?: TestFn): Promise<void>;\n        function skip(options?: TestOptions, fn?: TestFn): Promise<void>;\n        function skip(fn?: TestFn): Promise<void>;\n        /**\n         * Shorthand for marking a test as `TODO`. This is the same as calling {@link it} with `options.todo` set to `true`.\n         */\n        function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n        function todo(name?: string, fn?: TestFn): Promise<void>;\n        function todo(options?: TestOptions, fn?: TestFn): Promise<void>;\n        function todo(fn?: TestFn): Promise<void>;\n        /**\n         * Shorthand for marking a test as `only`. This is the same as calling {@link it} with `options.only` set to `true`.\n         * @since v18.15.0\n         */\n        function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n        function only(name?: string, fn?: TestFn): Promise<void>;\n        function only(options?: TestOptions, fn?: TestFn): Promise<void>;\n        function only(fn?: TestFn): Promise<void>;\n    }\n    /**\n     * Shorthand for skipping a test. This is the same as calling {@link test} with `options.skip` set to `true`.\n     * @since v20.2.0\n     */\n    function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n    function skip(name?: string, fn?: TestFn): Promise<void>;\n    function skip(options?: TestOptions, fn?: TestFn): Promise<void>;\n    function skip(fn?: TestFn): Promise<void>;\n    /**\n     * Shorthand for marking a test as `TODO`. This is the same as calling {@link test} with `options.todo` set to `true`.\n     * @since v20.2.0\n     */\n    function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n    function todo(name?: string, fn?: TestFn): Promise<void>;\n    function todo(options?: TestOptions, fn?: TestFn): Promise<void>;\n    function todo(fn?: TestFn): Promise<void>;\n    /**\n     * Shorthand for marking a test as `only`. This is the same as calling {@link test} with `options.only` set to `true`.\n     * @since v20.2.0\n     */\n    function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;\n    function only(name?: string, fn?: TestFn): Promise<void>;\n    function only(options?: TestOptions, fn?: TestFn): Promise<void>;\n    function only(fn?: TestFn): Promise<void>;\n    /**\n     * The type of a function passed to {@link test}. The first argument to this function is a {@link TestContext} object.\n     * If the test uses callbacks, the callback function is passed as the second argument.\n     */\n    type TestFn = (t: TestContext, done: (result?: any) => void) => void | Promise<void>;\n    /**\n     * The type of a suite test function. The argument to this function is a {@link SuiteContext} object.\n     */\n    type SuiteFn = (s: SuiteContext) => void | Promise<void>;\n    interface TestShard {\n        /**\n         * A positive integer between 1 and `total` that specifies the index of the shard to run.\n         */\n        index: number;\n        /**\n         * A positive integer that specifies the total number of shards to split the test files to.\n         */\n        total: number;\n    }\n    interface RunOptions {\n        /**\n         * If a number is provided, then that many test processes would run in parallel, where each process corresponds to one test file.\n         * If `true`, it would run `os.availableParallelism() - 1` test files in parallel. If `false`, it would only run one test file at a time.\n         * @default false\n         */\n        concurrency?: number | boolean | undefined;\n        /**\n         * An array containing the list of files to run. If omitted, files are run according to the\n         * [test runner execution model](https://nodejs.org/docs/latest-v22.x/api/test.html#test-runner-execution-model).\n         */\n        files?: readonly string[] | undefined;\n        /**\n         * Configures the test runner to exit the process once all known\n         * tests have finished executing even if the event loop would\n         * otherwise remain active.\n         * @default false\n         */\n        forceExit?: boolean | undefined;\n        /**\n         * An array containing the list of glob patterns to match test files.\n         * This option cannot be used together with `files`. If omitted, files are run according to the\n         * [test runner execution model](https://nodejs.org/docs/latest-v22.x/api/test.html#test-runner-execution-model).\n         * @since v22.6.0\n         */\n        globPatterns?: readonly string[] | undefined;\n        /**\n         * Sets inspector port of test child process.\n         * This can be a number, or a function that takes no arguments and returns a\n         * number. If a nullish value is provided, each process gets its own port,\n         * incremented from the primary's `process.debugPort`. This option is ignored\n         * if the `isolation` option is set to `'none'` as no child processes are\n         * spawned.\n         * @default undefined\n         */\n        inspectPort?: number | (() => number) | undefined;\n        /**\n         * Configures the type of test isolation. If set to\n         * `'process'`, each test file is run in a separate child process. If set to\n         * `'none'`, all test files run in the current process.\n         * @default 'process'\n         * @since v22.8.0\n         */\n        isolation?: \"process\" | \"none\" | undefined;\n        /**\n         * If truthy, the test context will only run tests that have the `only` option set\n         */\n        only?: boolean | undefined;\n        /**\n         * A function that accepts the `TestsStream` instance and can be used to setup listeners before any tests are run.\n         * @default undefined\n         */\n        setup?: ((reporter: TestsStream) => void | Promise<void>) | undefined;\n        /**\n         * An array of CLI flags to pass to the `node` executable when\n         * spawning the subprocesses. This option has no effect when `isolation` is `'none`'.\n         * @since v22.10.0\n         * @default []\n         */\n        execArgv?: readonly string[] | undefined;\n        /**\n         * An array of CLI flags to pass to each test file when spawning the\n         * subprocesses. This option has no effect when `isolation` is `'none'`.\n         * @since v22.10.0\n         * @default []\n         */\n        argv?: readonly string[] | undefined;\n        /**\n         * Allows aborting an in-progress test execution.\n         */\n        signal?: AbortSignal | undefined;\n        /**\n         * If provided, only run tests whose name matches the provided pattern.\n         * Strings are interpreted as JavaScript regular expressions.\n         * @default undefined\n         */\n        testNamePatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;\n        /**\n         * A String, RegExp or a RegExp Array, that can be used to exclude running tests whose\n         * name matches the provided pattern. Test name patterns are interpreted as JavaScript\n         * regular expressions. For each test that is executed, any corresponding test hooks,\n         * such as `beforeEach()`, are also run.\n         * @default undefined\n         * @since v22.1.0\n         */\n        testSkipPatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;\n        /**\n         * The number of milliseconds after which the test execution will fail.\n         * If unspecified, subtests inherit this value from their parent.\n         * @default Infinity\n         */\n        timeout?: number | undefined;\n        /**\n         * Whether to run in watch mode or not.\n         * @default false\n         */\n        watch?: boolean | undefined;\n        /**\n         * Running tests in a specific shard.\n         * @default undefined\n         */\n        shard?: TestShard | undefined;\n        /**\n         * enable [code coverage](https://nodejs.org/docs/latest-v22.x/api/test.html#collecting-code-coverage) collection.\n         * @since v22.10.0\n         * @default false\n         */\n        coverage?: boolean | undefined;\n        /**\n         * Excludes specific files from code coverage\n         * using a glob pattern, which can match both absolute and relative file paths.\n         * This property is only applicable when `coverage` was set to `true`.\n         * If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,\n         * files must meet **both** criteria to be included in the coverage report.\n         * @since v22.10.0\n         * @default undefined\n         */\n        coverageExcludeGlobs?: string | readonly string[] | undefined;\n        /**\n         * Includes specific files in code coverage\n         * using a glob pattern, which can match both absolute and relative file paths.\n         * This property is only applicable when `coverage` was set to `true`.\n         * If both `coverageExcludeGlobs` and `coverageIncludeGlobs` are provided,\n         * files must meet **both** criteria to be included in the coverage report.\n         * @since v22.10.0\n         * @default undefined\n         */\n        coverageIncludeGlobs?: string | readonly string[] | undefined;\n        /**\n         * Require a minimum percent of covered lines. If code\n         * coverage does not reach the threshold specified, the process will exit with code `1`.\n         * @since v22.10.0\n         * @default 0\n         */\n        lineCoverage?: number | undefined;\n        /**\n         * Require a minimum percent of covered branches. If code\n         * coverage does not reach the threshold specified, the process will exit with code `1`.\n         * @since v22.10.0\n         * @default 0\n         */\n        branchCoverage?: number | undefined;\n        /**\n         * Require a minimum percent of covered functions. If code\n         * coverage does not reach the threshold specified, the process will exit with code `1`.\n         * @since v22.10.0\n         * @default 0\n         */\n        functionCoverage?: number | undefined;\n    }\n    /**\n     * A successful call to `run()` will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.\n     *\n     * Some of the events are guaranteed to be emitted in the same order as the tests are defined, while others are emitted in the order that the tests execute.\n     * @since v18.9.0, v16.19.0\n     */\n    class TestsStream extends Readable implements NodeJS.ReadableStream {\n        addListener(event: \"test:coverage\", listener: (data: TestCoverage) => void): this;\n        addListener(event: \"test:complete\", listener: (data: TestComplete) => void): this;\n        addListener(event: \"test:dequeue\", listener: (data: TestDequeue) => void): this;\n        addListener(event: \"test:diagnostic\", listener: (data: DiagnosticData) => void): this;\n        addListener(event: \"test:enqueue\", listener: (data: TestEnqueue) => void): this;\n        addListener(event: \"test:fail\", listener: (data: TestFail) => void): this;\n        addListener(event: \"test:pass\", listener: (data: TestPass) => void): this;\n        addListener(event: \"test:plan\", listener: (data: TestPlan) => void): this;\n        addListener(event: \"test:start\", listener: (data: TestStart) => void): this;\n        addListener(event: \"test:stderr\", listener: (data: TestStderr) => void): this;\n        addListener(event: \"test:stdout\", listener: (data: TestStdout) => void): this;\n        addListener(event: \"test:summary\", listener: (data: TestSummary) => void): this;\n        addListener(event: \"test:watch:drained\", listener: () => void): this;\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        emit(event: \"test:coverage\", data: TestCoverage): boolean;\n        emit(event: \"test:complete\", data: TestComplete): boolean;\n        emit(event: \"test:dequeue\", data: TestDequeue): boolean;\n        emit(event: \"test:diagnostic\", data: DiagnosticData): boolean;\n        emit(event: \"test:enqueue\", data: TestEnqueue): boolean;\n        emit(event: \"test:fail\", data: TestFail): boolean;\n        emit(event: \"test:pass\", data: TestPass): boolean;\n        emit(event: \"test:plan\", data: TestPlan): boolean;\n        emit(event: \"test:start\", data: TestStart): boolean;\n        emit(event: \"test:stderr\", data: TestStderr): boolean;\n        emit(event: \"test:stdout\", data: TestStdout): boolean;\n        emit(event: \"test:summary\", data: TestSummary): boolean;\n        emit(event: \"test:watch:drained\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"test:coverage\", listener: (data: TestCoverage) => void): this;\n        on(event: \"test:complete\", listener: (data: TestComplete) => void): this;\n        on(event: \"test:dequeue\", listener: (data: TestDequeue) => void): this;\n        on(event: \"test:diagnostic\", listener: (data: DiagnosticData) => void): this;\n        on(event: \"test:enqueue\", listener: (data: TestEnqueue) => void): this;\n        on(event: \"test:fail\", listener: (data: TestFail) => void): this;\n        on(event: \"test:pass\", listener: (data: TestPass) => void): this;\n        on(event: \"test:plan\", listener: (data: TestPlan) => void): this;\n        on(event: \"test:start\", listener: (data: TestStart) => void): this;\n        on(event: \"test:stderr\", listener: (data: TestStderr) => void): this;\n        on(event: \"test:stdout\", listener: (data: TestStdout) => void): this;\n        on(event: \"test:summary\", listener: (data: TestSummary) => void): this;\n        on(event: \"test:watch:drained\", listener: () => void): this;\n        on(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"test:coverage\", listener: (data: TestCoverage) => void): this;\n        once(event: \"test:complete\", listener: (data: TestComplete) => void): this;\n        once(event: \"test:dequeue\", listener: (data: TestDequeue) => void): this;\n        once(event: \"test:diagnostic\", listener: (data: DiagnosticData) => void): this;\n        once(event: \"test:enqueue\", listener: (data: TestEnqueue) => void): this;\n        once(event: \"test:fail\", listener: (data: TestFail) => void): this;\n        once(event: \"test:pass\", listener: (data: TestPass) => void): this;\n        once(event: \"test:plan\", listener: (data: TestPlan) => void): this;\n        once(event: \"test:start\", listener: (data: TestStart) => void): this;\n        once(event: \"test:stderr\", listener: (data: TestStderr) => void): this;\n        once(event: \"test:stdout\", listener: (data: TestStdout) => void): this;\n        once(event: \"test:summary\", listener: (data: TestSummary) => void): this;\n        once(event: \"test:watch:drained\", listener: () => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"test:coverage\", listener: (data: TestCoverage) => void): this;\n        prependListener(event: \"test:complete\", listener: (data: TestComplete) => void): this;\n        prependListener(event: \"test:dequeue\", listener: (data: TestDequeue) => void): this;\n        prependListener(event: \"test:diagnostic\", listener: (data: DiagnosticData) => void): this;\n        prependListener(event: \"test:enqueue\", listener: (data: TestEnqueue) => void): this;\n        prependListener(event: \"test:fail\", listener: (data: TestFail) => void): this;\n        prependListener(event: \"test:pass\", listener: (data: TestPass) => void): this;\n        prependListener(event: \"test:plan\", listener: (data: TestPlan) => void): this;\n        prependListener(event: \"test:start\", listener: (data: TestStart) => void): this;\n        prependListener(event: \"test:stderr\", listener: (data: TestStderr) => void): this;\n        prependListener(event: \"test:stdout\", listener: (data: TestStdout) => void): this;\n        prependListener(event: \"test:summary\", listener: (data: TestSummary) => void): this;\n        prependListener(event: \"test:watch:drained\", listener: () => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"test:coverage\", listener: (data: TestCoverage) => void): this;\n        prependOnceListener(event: \"test:complete\", listener: (data: TestComplete) => void): this;\n        prependOnceListener(event: \"test:dequeue\", listener: (data: TestDequeue) => void): this;\n        prependOnceListener(event: \"test:diagnostic\", listener: (data: DiagnosticData) => void): this;\n        prependOnceListener(event: \"test:enqueue\", listener: (data: TestEnqueue) => void): this;\n        prependOnceListener(event: \"test:fail\", listener: (data: TestFail) => void): this;\n        prependOnceListener(event: \"test:pass\", listener: (data: TestPass) => void): this;\n        prependOnceListener(event: \"test:plan\", listener: (data: TestPlan) => void): this;\n        prependOnceListener(event: \"test:start\", listener: (data: TestStart) => void): this;\n        prependOnceListener(event: \"test:stderr\", listener: (data: TestStderr) => void): this;\n        prependOnceListener(event: \"test:stdout\", listener: (data: TestStdout) => void): this;\n        prependOnceListener(event: \"test:summary\", listener: (data: TestSummary) => void): this;\n        prependOnceListener(event: \"test:watch:drained\", listener: () => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n    }\n    /**\n     * An instance of `TestContext` is passed to each test function in order to\n     * interact with the test runner. However, the `TestContext` constructor is not\n     * exposed as part of the API.\n     * @since v18.0.0, v16.17.0\n     */\n    class TestContext {\n        /**\n         * An object containing assertion methods bound to the test context.\n         * The top-level functions from the `node:assert` module are exposed here for the purpose of creating test plans.\n         *\n         * **Note:** Some of the functions from `node:assert` contain type assertions. If these are called via the\n         * TestContext `assert` object, then the context parameter in the test's function signature **must be explicitly typed**\n         * (ie. the parameter must have a type annotation), otherwise an error will be raised by the TypeScript compiler:\n         * ```ts\n         * import { test, type TestContext } from 'node:test';\n         *\n         * // The test function's context parameter must have a type annotation.\n         * test('example', (t: TestContext) => {\n         *   t.assert.deepStrictEqual(actual, expected);\n         * });\n         *\n         * // Omitting the type annotation will result in a compilation error.\n         * test('example', t => {\n         *   t.assert.deepStrictEqual(actual, expected); // Error: 't' needs an explicit type annotation.\n         * });\n         * ```\n         * @since v22.2.0, v20.15.0\n         */\n        readonly assert: TestContextAssert;\n        /**\n         * This function is used to create a hook running before subtest of the current test.\n         * @param fn The hook function. The first argument to this function is a `TestContext` object.\n         * If the hook uses callbacks, the callback function is passed as the second argument.\n         * @param options Configuration options for the hook.\n         * @since v20.1.0, v18.17.0\n         */\n        before(fn?: TestContextHookFn, options?: HookOptions): void;\n        /**\n         * This function is used to create a hook running before each subtest of the current test.\n         * @param fn The hook function. The first argument to this function is a `TestContext` object.\n         * If the hook uses callbacks, the callback function is passed as the second argument.\n         * @param options Configuration options for the hook.\n         * @since v18.8.0\n         */\n        beforeEach(fn?: TestContextHookFn, options?: HookOptions): void;\n        /**\n         * This function is used to create a hook that runs after the current test finishes.\n         * @param fn The hook function. The first argument to this function is a `TestContext` object.\n         * If the hook uses callbacks, the callback function is passed as the second argument.\n         * @param options Configuration options for the hook.\n         * @since v18.13.0\n         */\n        after(fn?: TestContextHookFn, options?: HookOptions): void;\n        /**\n         * This function is used to create a hook running after each subtest of the current test.\n         * @param fn The hook function. The first argument to this function is a `TestContext` object.\n         * If the hook uses callbacks, the callback function is passed as the second argument.\n         * @param options Configuration options for the hook.\n         * @since v18.8.0\n         */\n        afterEach(fn?: TestContextHookFn, options?: HookOptions): void;\n        /**\n         * This function is used to write diagnostics to the output. Any diagnostic\n         * information is included at the end of the test's results. This function does\n         * not return a value.\n         *\n         * ```js\n         * test('top level test', (t) => {\n         *   t.diagnostic('A diagnostic message');\n         * });\n         * ```\n         * @since v18.0.0, v16.17.0\n         * @param message Message to be reported.\n         */\n        diagnostic(message: string): void;\n        /**\n         * The absolute path of the test file that created the current test. If a test file imports\n         * additional modules that generate tests, the imported tests will return the path of the root test file.\n         * @since v22.6.0\n         */\n        readonly filePath: string | undefined;\n        /**\n         * The name of the test and each of its ancestors, separated by `>`.\n         * @since v22.3.0\n         */\n        readonly fullName: string;\n        /**\n         * The name of the test.\n         * @since v18.8.0, v16.18.0\n         */\n        readonly name: string;\n        /**\n         * This function is used to set the number of assertions and subtests that are expected to run\n         * within the test. If the number of assertions and subtests that run does not match the\n         * expected count, the test will fail.\n         *\n         * > Note: To make sure assertions are tracked, `t.assert` must be used instead of `assert` directly.\n         *\n         * ```js\n         * test('top level test', (t) => {\n         *   t.plan(2);\n         *   t.assert.ok('some relevant assertion here');\n         *   t.test('subtest', () => {});\n         * });\n         * ```\n         *\n         * When working with asynchronous code, the `plan` function can be used to ensure that the\n         * correct number of assertions are run:\n         *\n         * ```js\n         * test('planning with streams', (t, done) => {\n         *   function* generate() {\n         *     yield 'a';\n         *     yield 'b';\n         *     yield 'c';\n         *   }\n         *   const expected = ['a', 'b', 'c'];\n         *   t.plan(expected.length);\n         *   const stream = Readable.from(generate());\n         *   stream.on('data', (chunk) => {\n         *     t.assert.strictEqual(chunk, expected.shift());\n         *   });\n         *\n         *   stream.on('end', () => {\n         *     done();\n         *   });\n         * });\n         * ```\n         *\n         * When using the `wait` option, you can control how long the test will wait for the expected assertions.\n         * For example, setting a maximum wait time ensures that the test will wait for asynchronous assertions\n         * to complete within the specified timeframe:\n         *\n         * ```js\n         * test('plan with wait: 2000 waits for async assertions', (t) => {\n         *   t.plan(1, { wait: 2000 }); // Waits for up to 2 seconds for the assertion to complete.\n         *\n         *   const asyncActivity = () => {\n         *     setTimeout(() => {\n         *          *       t.assert.ok(true, 'Async assertion completed within the wait time');\n         *     }, 1000); // Completes after 1 second, within the 2-second wait time.\n         *   };\n         *\n         *   asyncActivity(); // The test will pass because the assertion is completed in time.\n         * });\n         * ```\n         *\n         * Note: If a `wait` timeout is specified, it begins counting down only after the test function finishes executing.\n         * @since v22.2.0\n         */\n        plan(count: number, options?: TestContextPlanOptions): void;\n        /**\n         * If `shouldRunOnlyTests` is truthy, the test context will only run tests that\n         * have the `only` option set. Otherwise, all tests are run. If Node.js was not\n         * started with the `--test-only` command-line option, this function is a\n         * no-op.\n         *\n         * ```js\n         * test('top level test', (t) => {\n         *   // The test context can be set to run subtests with the 'only' option.\n         *   t.runOnly(true);\n         *   return Promise.all([\n         *     t.test('this subtest is now skipped'),\n         *     t.test('this subtest is run', { only: true }),\n         *   ]);\n         * });\n         * ```\n         * @since v18.0.0, v16.17.0\n         * @param shouldRunOnlyTests Whether or not to run `only` tests.\n         */\n        runOnly(shouldRunOnlyTests: boolean): void;\n        /**\n         * ```js\n         * test('top level test', async (t) => {\n         *   await fetch('some/uri', { signal: t.signal });\n         * });\n         * ```\n         * @since v18.7.0, v16.17.0\n         */\n        readonly signal: AbortSignal;\n        /**\n         * This function causes the test's output to indicate the test as skipped. If `message` is provided, it is included in the output. Calling `skip()` does\n         * not terminate execution of the test function. This function does not return a\n         * value.\n         *\n         * ```js\n         * test('top level test', (t) => {\n         *   // Make sure to return here as well if the test contains additional logic.\n         *   t.skip('this is skipped');\n         * });\n         * ```\n         * @since v18.0.0, v16.17.0\n         * @param message Optional skip message.\n         */\n        skip(message?: string): void;\n        /**\n         * This function adds a `TODO` directive to the test's output. If `message` is\n         * provided, it is included in the output. Calling `todo()` does not terminate\n         * execution of the test function. This function does not return a value.\n         *\n         * ```js\n         * test('top level test', (t) => {\n         *   // This test is marked as `TODO`\n         *   t.todo('this is a todo');\n         * });\n         * ```\n         * @since v18.0.0, v16.17.0\n         * @param message Optional `TODO` message.\n         */\n        todo(message?: string): void;\n        /**\n         * This function is used to create subtests under the current test. This function behaves in\n         * the same fashion as the top level {@link test} function.\n         * @since v18.0.0\n         * @param name The name of the test, which is displayed when reporting test results.\n         * Defaults to the `name` property of `fn`, or `'<anonymous>'` if `fn` does not have a name.\n         * @param options Configuration options for the test.\n         * @param fn The function under test. This first argument to this function is a {@link TestContext} object.\n         * If the test uses callbacks, the callback function is passed as the second argument.\n         * @returns A {@link Promise} resolved with `undefined` once the test completes.\n         */\n        test: typeof test;\n        /**\n         * This method polls a `condition` function until that function either returns\n         * successfully or the operation times out.\n         * @since v22.14.0\n         * @param condition An assertion function that is invoked\n         * periodically until it completes successfully or the defined polling timeout\n         * elapses. Successful completion is defined as not throwing or rejecting. This\n         * function does not accept any arguments, and is allowed to return any value.\n         * @param options An optional configuration object for the polling operation.\n         * @returns Fulfilled with the value returned by `condition`.\n         */\n        waitFor<T>(condition: () => T, options?: TestContextWaitForOptions): Promise<Awaited<T>>;\n        /**\n         * Each test provides its own MockTracker instance.\n         */\n        readonly mock: MockTracker;\n    }\n    interface TestContextAssert extends\n        Pick<\n            typeof import(\"assert\"),\n            | \"deepEqual\"\n            | \"deepStrictEqual\"\n            | \"doesNotMatch\"\n            | \"doesNotReject\"\n            | \"doesNotThrow\"\n            | \"equal\"\n            | \"fail\"\n            | \"ifError\"\n            | \"match\"\n            | \"notDeepEqual\"\n            | \"notDeepStrictEqual\"\n            | \"notEqual\"\n            | \"notStrictEqual\"\n            | \"ok\"\n            | \"partialDeepStrictEqual\"\n            | \"rejects\"\n            | \"strictEqual\"\n            | \"throws\"\n        >\n    {\n        /**\n         * This function serializes `value` and writes it to the file specified by `path`.\n         *\n         * ```js\n         * test('snapshot test with default serialization', (t) => {\n         *   t.assert.fileSnapshot({ value1: 1, value2: 2 }, './snapshots/snapshot.json');\n         * });\n         * ```\n         *\n         * This function differs from `context.assert.snapshot()` in the following ways:\n         *\n         * * The snapshot file path is explicitly provided by the user.\n         * * Each snapshot file is limited to a single snapshot value.\n         * * No additional escaping is performed by the test runner.\n         *\n         * These differences allow snapshot files to better support features such as syntax\n         * highlighting.\n         * @since v22.14.0\n         * @param value A value to serialize to a string. If Node.js was started with\n         * the [`--test-update-snapshots`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--test-update-snapshots)\n         * flag, the serialized value is written to\n         * `path`. Otherwise, the serialized value is compared to the contents of the\n         * existing snapshot file.\n         * @param path The file where the serialized `value` is written.\n         * @param options Optional configuration options.\n         */\n        fileSnapshot(value: any, path: string, options?: AssertSnapshotOptions): void;\n        /**\n         * This function implements assertions for snapshot testing.\n         * ```js\n         * test('snapshot test with default serialization', (t) => {\n         *   t.assert.snapshot({ value1: 1, value2: 2 });\n         * });\n         *\n         * test('snapshot test with custom serialization', (t) => {\n         *   t.assert.snapshot({ value3: 3, value4: 4 }, {\n         *     serializers: [(value) => JSON.stringify(value)]\n         *   });\n         * });\n         * ```\n         * @since v22.3.0\n         * @param value A value to serialize to a string. If Node.js was started with\n         * the [`--test-update-snapshots`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--test-update-snapshots)\n         * flag, the serialized value is written to\n         * the snapshot file. Otherwise, the serialized value is compared to the\n         * corresponding value in the existing snapshot file.\n         */\n        snapshot(value: any, options?: AssertSnapshotOptions): void;\n        /**\n         * A custom assertion function registered with `assert.register()`.\n         */\n        [name: string]: (...args: any[]) => void;\n    }\n    interface AssertSnapshotOptions {\n        /**\n         * An array of synchronous functions used to serialize `value` into a string.\n         * `value` is passed as the only argument to the first serializer function.\n         * The return value of each serializer is passed as input to the next serializer.\n         * Once all serializers have run, the resulting value is coerced to a string.\n         *\n         * If no serializers are provided, the test runner's default serializers are used.\n         */\n        serializers?: ReadonlyArray<(value: any) => any> | undefined;\n    }\n    interface TestContextPlanOptions {\n        /**\n         * The wait time for the plan:\n         * * If `true`, the plan waits indefinitely for all assertions and subtests to run.\n         * * If `false`, the plan performs an immediate check after the test function completes,\n         * without waiting for any pending assertions or subtests.\n         * Any assertions or subtests that complete after this check will not be counted towards the plan.\n         * * If a number, it specifies the maximum wait time in milliseconds\n         * before timing out while waiting for expected assertions and subtests to be matched.\n         * If the timeout is reached, the test will fail.\n         * @default false\n         */\n        wait?: boolean | number | undefined;\n    }\n    interface TestContextWaitForOptions {\n        /**\n         * The number of milliseconds to wait after an unsuccessful\n         * invocation of `condition` before trying again.\n         * @default 50\n         */\n        interval?: number | undefined;\n        /**\n         * The poll timeout in milliseconds. If `condition` has not\n         * succeeded by the time this elapses, an error occurs.\n         * @default 1000\n         */\n        timeout?: number | undefined;\n    }\n\n    /**\n     * An instance of `SuiteContext` is passed to each suite function in order to\n     * interact with the test runner. However, the `SuiteContext` constructor is not\n     * exposed as part of the API.\n     * @since v18.7.0, v16.17.0\n     */\n    class SuiteContext {\n        /**\n         * The absolute path of the test file that created the current suite. If a test file imports\n         * additional modules that generate suites, the imported suites will return the path of the root test file.\n         * @since v22.6.0\n         */\n        readonly filePath: string | undefined;\n        /**\n         * The name of the suite.\n         * @since v18.8.0, v16.18.0\n         */\n        readonly name: string;\n        /**\n         * Can be used to abort test subtasks when the test has been aborted.\n         * @since v18.7.0, v16.17.0\n         */\n        readonly signal: AbortSignal;\n    }\n    interface TestOptions {\n        /**\n         * If a number is provided, then that many tests would run in parallel.\n         * If truthy, it would run (number of cpu cores - 1) tests in parallel.\n         * For subtests, it will be `Infinity` tests in parallel.\n         * If falsy, it would only run one test at a time.\n         * If unspecified, subtests inherit this value from their parent.\n         * @default false\n         */\n        concurrency?: number | boolean | undefined;\n        /**\n         * If truthy, and the test context is configured to run `only` tests, then this test will be\n         * run. Otherwise, the test is skipped.\n         * @default false\n         */\n        only?: boolean | undefined;\n        /**\n         * Allows aborting an in-progress test.\n         * @since v18.8.0\n         */\n        signal?: AbortSignal | undefined;\n        /**\n         * If truthy, the test is skipped. If a string is provided, that string is displayed in the\n         * test results as the reason for skipping the test.\n         * @default false\n         */\n        skip?: boolean | string | undefined;\n        /**\n         * A number of milliseconds the test will fail after. If unspecified, subtests inherit this\n         * value from their parent.\n         * @default Infinity\n         * @since v18.7.0\n         */\n        timeout?: number | undefined;\n        /**\n         * If truthy, the test marked as `TODO`. If a string is provided, that string is displayed in\n         * the test results as the reason why the test is `TODO`.\n         * @default false\n         */\n        todo?: boolean | string | undefined;\n        /**\n         * The number of assertions and subtests expected to be run in the test.\n         * If the number of assertions run in the test does not match the number\n         * specified in the plan, the test will fail.\n         * @default undefined\n         * @since v22.2.0\n         */\n        plan?: number | undefined;\n    }\n    /**\n     * This function creates a hook that runs before executing a suite.\n     *\n     * ```js\n     * describe('tests', async () => {\n     *   before(() => console.log('about to run some test'));\n     *   it('is a subtest', () => {\n     *     assert.ok('some relevant assertion here');\n     *   });\n     * });\n     * ```\n     * @since v18.8.0, v16.18.0\n     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.\n     * @param options Configuration options for the hook.\n     */\n    function before(fn?: HookFn, options?: HookOptions): void;\n    /**\n     * This function creates a hook that runs after executing a suite.\n     *\n     * ```js\n     * describe('tests', async () => {\n     *   after(() => console.log('finished running tests'));\n     *   it('is a subtest', () => {\n     *     assert.ok('some relevant assertion here');\n     *   });\n     * });\n     * ```\n     * @since v18.8.0, v16.18.0\n     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.\n     * @param options Configuration options for the hook.\n     */\n    function after(fn?: HookFn, options?: HookOptions): void;\n    /**\n     * This function creates a hook that runs before each test in the current suite.\n     *\n     * ```js\n     * describe('tests', async () => {\n     *   beforeEach(() => console.log('about to run a test'));\n     *   it('is a subtest', () => {\n     *     assert.ok('some relevant assertion here');\n     *   });\n     * });\n     * ```\n     * @since v18.8.0, v16.18.0\n     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.\n     * @param options Configuration options for the hook.\n     */\n    function beforeEach(fn?: HookFn, options?: HookOptions): void;\n    /**\n     * This function creates a hook that runs after each test in the current suite.\n     * The `afterEach()` hook is run even if the test fails.\n     *\n     * ```js\n     * describe('tests', async () => {\n     *   afterEach(() => console.log('finished running a test'));\n     *   it('is a subtest', () => {\n     *     assert.ok('some relevant assertion here');\n     *   });\n     * });\n     * ```\n     * @since v18.8.0, v16.18.0\n     * @param fn The hook function. If the hook uses callbacks, the callback function is passed as the second argument.\n     * @param options Configuration options for the hook.\n     */\n    function afterEach(fn?: HookFn, options?: HookOptions): void;\n    /**\n     * The hook function. The first argument is the context in which the hook is called.\n     * If the hook uses callbacks, the callback function is passed as the second argument.\n     */\n    type HookFn = (c: TestContext | SuiteContext, done: (result?: any) => void) => any;\n    /**\n     * The hook function. The first argument is a `TestContext` object.\n     * If the hook uses callbacks, the callback function is passed as the second argument.\n     */\n    type TestContextHookFn = (t: TestContext, done: (result?: any) => void) => any;\n    /**\n     * Configuration options for hooks.\n     * @since v18.8.0\n     */\n    interface HookOptions {\n        /**\n         * Allows aborting an in-progress hook.\n         */\n        signal?: AbortSignal | undefined;\n        /**\n         * A number of milliseconds the hook will fail after. If unspecified, subtests inherit this\n         * value from their parent.\n         * @default Infinity\n         */\n        timeout?: number | undefined;\n    }\n    interface MockFunctionOptions {\n        /**\n         * The number of times that the mock will use the behavior of `implementation`.\n         * Once the mock function has been called `times` times,\n         * it will automatically restore the behavior of `original`.\n         * This value must be an integer greater than zero.\n         * @default Infinity\n         */\n        times?: number | undefined;\n    }\n    interface MockMethodOptions extends MockFunctionOptions {\n        /**\n         * If `true`, `object[methodName]` is treated as a getter.\n         * This option cannot be used with the `setter` option.\n         */\n        getter?: boolean | undefined;\n        /**\n         * If `true`, `object[methodName]` is treated as a setter.\n         * This option cannot be used with the `getter` option.\n         */\n        setter?: boolean | undefined;\n    }\n    type Mock<F extends Function> = F & {\n        mock: MockFunctionContext<F>;\n    };\n    type NoOpFunction = (...args: any[]) => undefined;\n    type FunctionPropertyNames<T> = {\n        [K in keyof T]: T[K] extends Function ? K : never;\n    }[keyof T];\n    interface MockModuleOptions {\n        /**\n         * If false, each call to `require()` or `import()` generates a new mock module.\n         * If true, subsequent calls will return the same module mock, and the mock module is inserted into the CommonJS cache.\n         * @default false\n         */\n        cache?: boolean | undefined;\n        /**\n         * The value to use as the mocked module's default export.\n         *\n         * If this value is not provided, ESM mocks do not include a default export.\n         * If the mock is a CommonJS or builtin module, this setting is used as the value of `module.exports`.\n         * If this value is not provided, CJS and builtin mocks use an empty object as the value of `module.exports`.\n         */\n        defaultExport?: any;\n        /**\n         * An object whose keys and values are used to create the named exports of the mock module.\n         *\n         * If the mock is a CommonJS or builtin module, these values are copied onto `module.exports`.\n         * Therefore, if a mock is created with both named exports and a non-object default export,\n         * the mock will throw an exception when used as a CJS or builtin module.\n         */\n        namedExports?: object | undefined;\n    }\n    /**\n     * The `MockTracker` class is used to manage mocking functionality. The test runner\n     * module provides a top level `mock` export which is a `MockTracker` instance.\n     * Each test also provides its own `MockTracker` instance via the test context's `mock` property.\n     * @since v19.1.0, v18.13.0\n     */\n    class MockTracker {\n        /**\n         * This function is used to create a mock function.\n         *\n         * The following example creates a mock function that increments a counter by one\n         * on each invocation. The `times` option is used to modify the mock behavior such\n         * that the first two invocations add two to the counter instead of one.\n         *\n         * ```js\n         * test('mocks a counting function', (t) => {\n         *   let cnt = 0;\n         *\n         *   function addOne() {\n         *     cnt++;\n         *     return cnt;\n         *   }\n         *\n         *   function addTwo() {\n         *     cnt += 2;\n         *     return cnt;\n         *   }\n         *\n         *   const fn = t.mock.fn(addOne, addTwo, { times: 2 });\n         *\n         *   assert.strictEqual(fn(), 2);\n         *   assert.strictEqual(fn(), 4);\n         *   assert.strictEqual(fn(), 5);\n         *   assert.strictEqual(fn(), 6);\n         * });\n         * ```\n         * @since v19.1.0, v18.13.0\n         * @param original An optional function to create a mock on.\n         * @param implementation An optional function used as the mock implementation for `original`. This is useful for creating mocks that exhibit one behavior for a specified number of calls and\n         * then restore the behavior of `original`.\n         * @param options Optional configuration options for the mock function.\n         * @return The mocked function. The mocked function contains a special `mock` property, which is an instance of {@link MockFunctionContext}, and can be used for inspecting and changing the\n         * behavior of the mocked function.\n         */\n        fn<F extends Function = NoOpFunction>(original?: F, options?: MockFunctionOptions): Mock<F>;\n        fn<F extends Function = NoOpFunction, Implementation extends Function = F>(\n            original?: F,\n            implementation?: Implementation,\n            options?: MockFunctionOptions,\n        ): Mock<F | Implementation>;\n        /**\n         * This function is used to create a mock on an existing object method. The\n         * following example demonstrates how a mock is created on an existing object\n         * method.\n         *\n         * ```js\n         * test('spies on an object method', (t) => {\n         *   const number = {\n         *     value: 5,\n         *     subtract(a) {\n         *       return this.value - a;\n         *     },\n         *   };\n         *\n         *   t.mock.method(number, 'subtract');\n         *   assert.strictEqual(number.subtract.mock.calls.length, 0);\n         *   assert.strictEqual(number.subtract(3), 2);\n         *   assert.strictEqual(number.subtract.mock.calls.length, 1);\n         *\n         *   const call = number.subtract.mock.calls[0];\n         *\n         *   assert.deepStrictEqual(call.arguments, [3]);\n         *   assert.strictEqual(call.result, 2);\n         *   assert.strictEqual(call.error, undefined);\n         *   assert.strictEqual(call.target, undefined);\n         *   assert.strictEqual(call.this, number);\n         * });\n         * ```\n         * @since v19.1.0, v18.13.0\n         * @param object The object whose method is being mocked.\n         * @param methodName The identifier of the method on `object` to mock. If `object[methodName]` is not a function, an error is thrown.\n         * @param implementation An optional function used as the mock implementation for `object[methodName]`.\n         * @param options Optional configuration options for the mock method.\n         * @return The mocked method. The mocked method contains a special `mock` property, which is an instance of {@link MockFunctionContext}, and can be used for inspecting and changing the\n         * behavior of the mocked method.\n         */\n        method<\n            MockedObject extends object,\n            MethodName extends FunctionPropertyNames<MockedObject>,\n        >(\n            object: MockedObject,\n            methodName: MethodName,\n            options?: MockFunctionOptions,\n        ): MockedObject[MethodName] extends Function ? Mock<MockedObject[MethodName]>\n            : never;\n        method<\n            MockedObject extends object,\n            MethodName extends FunctionPropertyNames<MockedObject>,\n            Implementation extends Function,\n        >(\n            object: MockedObject,\n            methodName: MethodName,\n            implementation: Implementation,\n            options?: MockFunctionOptions,\n        ): MockedObject[MethodName] extends Function ? Mock<MockedObject[MethodName] | Implementation>\n            : never;\n        method<MockedObject extends object>(\n            object: MockedObject,\n            methodName: keyof MockedObject,\n            options: MockMethodOptions,\n        ): Mock<Function>;\n        method<MockedObject extends object>(\n            object: MockedObject,\n            methodName: keyof MockedObject,\n            implementation: Function,\n            options: MockMethodOptions,\n        ): Mock<Function>;\n\n        /**\n         * This function is syntax sugar for `MockTracker.method` with `options.getter` set to `true`.\n         * @since v19.3.0, v18.13.0\n         */\n        getter<\n            MockedObject extends object,\n            MethodName extends keyof MockedObject,\n        >(\n            object: MockedObject,\n            methodName: MethodName,\n            options?: MockFunctionOptions,\n        ): Mock<() => MockedObject[MethodName]>;\n        getter<\n            MockedObject extends object,\n            MethodName extends keyof MockedObject,\n            Implementation extends Function,\n        >(\n            object: MockedObject,\n            methodName: MethodName,\n            implementation?: Implementation,\n            options?: MockFunctionOptions,\n        ): Mock<(() => MockedObject[MethodName]) | Implementation>;\n        /**\n         * This function is syntax sugar for `MockTracker.method` with `options.setter` set to `true`.\n         * @since v19.3.0, v18.13.0\n         */\n        setter<\n            MockedObject extends object,\n            MethodName extends keyof MockedObject,\n        >(\n            object: MockedObject,\n            methodName: MethodName,\n            options?: MockFunctionOptions,\n        ): Mock<(value: MockedObject[MethodName]) => void>;\n        setter<\n            MockedObject extends object,\n            MethodName extends keyof MockedObject,\n            Implementation extends Function,\n        >(\n            object: MockedObject,\n            methodName: MethodName,\n            implementation?: Implementation,\n            options?: MockFunctionOptions,\n        ): Mock<((value: MockedObject[MethodName]) => void) | Implementation>;\n\n        /**\n         * This function is used to mock the exports of ECMAScript modules, CommonJS modules, and Node.js builtin modules.\n         * Any references to the original module prior to mocking are not impacted.\n         *\n         * Only available through the [--experimental-test-module-mocks](https://nodejs.org/api/cli.html#--experimental-test-module-mocks) flag.\n         * @since v22.3.0\n         * @experimental\n         * @param specifier A string identifying the module to mock.\n         * @param options Optional configuration options for the mock module.\n         */\n        module(specifier: string, options?: MockModuleOptions): MockModuleContext;\n\n        /**\n         * This function restores the default behavior of all mocks that were previously\n         * created by this `MockTracker` and disassociates the mocks from the `MockTracker` instance. Once disassociated, the mocks can still be used, but the `MockTracker` instance can no longer be\n         * used to reset their behavior or\n         * otherwise interact with them.\n         *\n         * After each test completes, this function is called on the test context's `MockTracker`. If the global `MockTracker` is used extensively, calling this\n         * function manually is recommended.\n         * @since v19.1.0, v18.13.0\n         */\n        reset(): void;\n        /**\n         * This function restores the default behavior of all mocks that were previously\n         * created by this `MockTracker`. Unlike `mock.reset()`, `mock.restoreAll()` does\n         * not disassociate the mocks from the `MockTracker` instance.\n         * @since v19.1.0, v18.13.0\n         */\n        restoreAll(): void;\n\n        timers: MockTimers;\n    }\n    const mock: MockTracker;\n    interface MockFunctionCall<\n        F extends Function,\n        ReturnType = F extends (...args: any) => infer T ? T\n            : F extends abstract new(...args: any) => infer T ? T\n            : unknown,\n        Args = F extends (...args: infer Y) => any ? Y\n            : F extends abstract new(...args: infer Y) => any ? Y\n            : unknown[],\n    > {\n        /**\n         * An array of the arguments passed to the mock function.\n         */\n        arguments: Args;\n        /**\n         * If the mocked function threw then this property contains the thrown value.\n         */\n        error: unknown | undefined;\n        /**\n         * The value returned by the mocked function.\n         *\n         * If the mocked function threw, it will be `undefined`.\n         */\n        result: ReturnType | undefined;\n        /**\n         * An `Error` object whose stack can be used to determine the callsite of the mocked function invocation.\n         */\n        stack: Error;\n        /**\n         * If the mocked function is a constructor, this field contains the class being constructed.\n         * Otherwise this will be `undefined`.\n         */\n        target: F extends abstract new(...args: any) => any ? F : undefined;\n        /**\n         * The mocked function's `this` value.\n         */\n        this: unknown;\n    }\n    /**\n     * The `MockFunctionContext` class is used to inspect or manipulate the behavior of\n     * mocks created via the `MockTracker` APIs.\n     * @since v19.1.0, v18.13.0\n     */\n    class MockFunctionContext<F extends Function> {\n        /**\n         * A getter that returns a copy of the internal array used to track calls to the\n         * mock. Each entry in the array is an object with the following properties.\n         * @since v19.1.0, v18.13.0\n         */\n        readonly calls: Array<MockFunctionCall<F>>;\n        /**\n         * This function returns the number of times that this mock has been invoked. This\n         * function is more efficient than checking `ctx.calls.length` because `ctx.calls` is a getter that creates a copy of the internal call tracking array.\n         * @since v19.1.0, v18.13.0\n         * @return The number of times that this mock has been invoked.\n         */\n        callCount(): number;\n        /**\n         * This function is used to change the behavior of an existing mock.\n         *\n         * The following example creates a mock function using `t.mock.fn()`, calls the\n         * mock function, and then changes the mock implementation to a different function.\n         *\n         * ```js\n         * test('changes a mock behavior', (t) => {\n         *   let cnt = 0;\n         *\n         *   function addOne() {\n         *     cnt++;\n         *     return cnt;\n         *   }\n         *\n         *   function addTwo() {\n         *     cnt += 2;\n         *     return cnt;\n         *   }\n         *\n         *   const fn = t.mock.fn(addOne);\n         *\n         *   assert.strictEqual(fn(), 1);\n         *   fn.mock.mockImplementation(addTwo);\n         *   assert.strictEqual(fn(), 3);\n         *   assert.strictEqual(fn(), 5);\n         * });\n         * ```\n         * @since v19.1.0, v18.13.0\n         * @param implementation The function to be used as the mock's new implementation.\n         */\n        mockImplementation(implementation: F): void;\n        /**\n         * This function is used to change the behavior of an existing mock for a single\n         * invocation. Once invocation `onCall` has occurred, the mock will revert to\n         * whatever behavior it would have used had `mockImplementationOnce()` not been\n         * called.\n         *\n         * The following example creates a mock function using `t.mock.fn()`, calls the\n         * mock function, changes the mock implementation to a different function for the\n         * next invocation, and then resumes its previous behavior.\n         *\n         * ```js\n         * test('changes a mock behavior once', (t) => {\n         *   let cnt = 0;\n         *\n         *   function addOne() {\n         *     cnt++;\n         *     return cnt;\n         *   }\n         *\n         *   function addTwo() {\n         *     cnt += 2;\n         *     return cnt;\n         *   }\n         *\n         *   const fn = t.mock.fn(addOne);\n         *\n         *   assert.strictEqual(fn(), 1);\n         *   fn.mock.mockImplementationOnce(addTwo);\n         *   assert.strictEqual(fn(), 3);\n         *   assert.strictEqual(fn(), 4);\n         * });\n         * ```\n         * @since v19.1.0, v18.13.0\n         * @param implementation The function to be used as the mock's implementation for the invocation number specified by `onCall`.\n         * @param onCall The invocation number that will use `implementation`. If the specified invocation has already occurred then an exception is thrown.\n         */\n        mockImplementationOnce(implementation: F, onCall?: number): void;\n        /**\n         * Resets the call history of the mock function.\n         * @since v19.3.0, v18.13.0\n         */\n        resetCalls(): void;\n        /**\n         * Resets the implementation of the mock function to its original behavior. The\n         * mock can still be used after calling this function.\n         * @since v19.1.0, v18.13.0\n         */\n        restore(): void;\n    }\n    /**\n     * @since v22.3.0\n     * @experimental\n     */\n    class MockModuleContext {\n        /**\n         * Resets the implementation of the mock module.\n         * @since v22.3.0\n         */\n        restore(): void;\n    }\n\n    type Timer = \"setInterval\" | \"setTimeout\" | \"setImmediate\" | \"Date\";\n    interface MockTimersOptions {\n        apis: Timer[];\n        now?: number | Date | undefined;\n    }\n    /**\n     * Mocking timers is a technique commonly used in software testing to simulate and\n     * control the behavior of timers, such as `setInterval` and `setTimeout`,\n     * without actually waiting for the specified time intervals.\n     *\n     * The MockTimers API also allows for mocking of the `Date` constructor and\n     * `setImmediate`/`clearImmediate` functions.\n     *\n     * The `MockTracker` provides a top-level `timers` export\n     * which is a `MockTimers` instance.\n     * @since v20.4.0\n     * @experimental\n     */\n    class MockTimers {\n        /**\n         * Enables timer mocking for the specified timers.\n         *\n         * **Note:** When you enable mocking for a specific timer, its associated\n         * clear function will also be implicitly mocked.\n         *\n         * **Note:** Mocking `Date` will affect the behavior of the mocked timers\n         * as they use the same internal clock.\n         *\n         * Example usage without setting initial time:\n         *\n         * ```js\n         * import { mock } from 'node:test';\n         * mock.timers.enable({ apis: ['setInterval', 'Date'], now: 1234 });\n         * ```\n         *\n         * The above example enables mocking for the `Date` constructor, `setInterval` timer and\n         * implicitly mocks the `clearInterval` function. Only the `Date` constructor from `globalThis`,\n         * `setInterval` and `clearInterval` functions from `node:timers`, `node:timers/promises`, and `globalThis` will be mocked.\n         *\n         * Example usage with initial time set\n         *\n         * ```js\n         * import { mock } from 'node:test';\n         * mock.timers.enable({ apis: ['Date'], now: 1000 });\n         * ```\n         *\n         * Example usage with initial Date object as time set\n         *\n         * ```js\n         * import { mock } from 'node:test';\n         * mock.timers.enable({ apis: ['Date'], now: new Date() });\n         * ```\n         *\n         * Alternatively, if you call `mock.timers.enable()` without any parameters:\n         *\n         * All timers (`'setInterval'`, `'clearInterval'`, `'Date'`, `'setImmediate'`, `'clearImmediate'`, `'setTimeout'`, and `'clearTimeout'`)\n         * will be mocked.\n         *\n         * The `setInterval`, `clearInterval`, `setTimeout`, and `clearTimeout` functions from `node:timers`, `node:timers/promises`,\n         * and `globalThis` will be mocked.\n         * The `Date` constructor from `globalThis` will be mocked.\n         *\n         * If there is no initial epoch set, the initial date will be based on 0 in the Unix epoch. This is `January 1st, 1970, 00:00:00 UTC`. You can\n         * set an initial date by passing a now property to the `.enable()` method. This value will be used as the initial date for the mocked Date\n         * object. It can either be a positive integer, or another Date object.\n         * @since v20.4.0\n         */\n        enable(options?: MockTimersOptions): void;\n        /**\n         * You can use the `.setTime()` method to manually move the mocked date to another time. This method only accepts a positive integer.\n         * Note: This method will execute any mocked timers that are in the past from the new time.\n         * In the below example we are setting a new time for the mocked date.\n         * ```js\n         * import assert from 'node:assert';\n         * import { test } from 'node:test';\n         * test('sets the time of a date object', (context) => {\n         *   // Optionally choose what to mock\n         *   context.mock.timers.enable({ apis: ['Date'], now: 100 });\n         *   assert.strictEqual(Date.now(), 100);\n         *   // Advance in time will also advance the date\n         *   context.mock.timers.setTime(1000);\n         *   context.mock.timers.tick(200);\n         *   assert.strictEqual(Date.now(), 1200);\n         * });\n         * ```\n         */\n        setTime(time: number): void;\n        /**\n         * This function restores the default behavior of all mocks that were previously\n         * created by this `MockTimers` instance and disassociates the mocks\n         * from the `MockTracker` instance.\n         *\n         * **Note:** After each test completes, this function is called on\n         * the test context's `MockTracker`.\n         *\n         * ```js\n         * import { mock } from 'node:test';\n         * mock.timers.reset();\n         * ```\n         * @since v20.4.0\n         */\n        reset(): void;\n        /**\n         * Advances time for all mocked timers.\n         *\n         * **Note:** This diverges from how `setTimeout` in Node.js behaves and accepts\n         * only positive numbers. In Node.js, `setTimeout` with negative numbers is\n         * only supported for web compatibility reasons.\n         *\n         * The following example mocks a `setTimeout` function and\n         * by using `.tick` advances in\n         * time triggering all pending timers.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         * import { test } from 'node:test';\n         *\n         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) => {\n         *   const fn = context.mock.fn();\n         *\n         *   context.mock.timers.enable({ apis: ['setTimeout'] });\n         *\n         *   setTimeout(fn, 9999);\n         *\n         *   assert.strictEqual(fn.mock.callCount(), 0);\n         *\n         *   // Advance in time\n         *   context.mock.timers.tick(9999);\n         *\n         *   assert.strictEqual(fn.mock.callCount(), 1);\n         * });\n         * ```\n         *\n         * Alternativelly, the `.tick` function can be called many times\n         *\n         * ```js\n         * import assert from 'node:assert';\n         * import { test } from 'node:test';\n         *\n         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) => {\n         *   const fn = context.mock.fn();\n         *   context.mock.timers.enable({ apis: ['setTimeout'] });\n         *   const nineSecs = 9000;\n         *   setTimeout(fn, nineSecs);\n         *\n         *   const twoSeconds = 3000;\n         *   context.mock.timers.tick(twoSeconds);\n         *   context.mock.timers.tick(twoSeconds);\n         *   context.mock.timers.tick(twoSeconds);\n         *\n         *   assert.strictEqual(fn.mock.callCount(), 1);\n         * });\n         * ```\n         *\n         * Advancing time using `.tick` will also advance the time for any `Date` object\n         * created after the mock was enabled (if `Date` was also set to be mocked).\n         *\n         * ```js\n         * import assert from 'node:assert';\n         * import { test } from 'node:test';\n         *\n         * test('mocks setTimeout to be executed synchronously without having to actually wait for it', (context) => {\n         *   const fn = context.mock.fn();\n         *\n         *   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });\n         *   setTimeout(fn, 9999);\n         *\n         *   assert.strictEqual(fn.mock.callCount(), 0);\n         *   assert.strictEqual(Date.now(), 0);\n         *\n         *   // Advance in time\n         *   context.mock.timers.tick(9999);\n         *   assert.strictEqual(fn.mock.callCount(), 1);\n         *   assert.strictEqual(Date.now(), 9999);\n         * });\n         * ```\n         * @since v20.4.0\n         */\n        tick(milliseconds: number): void;\n        /**\n         * Triggers all pending mocked timers immediately. If the `Date` object is also\n         * mocked, it will also advance the `Date` object to the furthest timer's time.\n         *\n         * The example below triggers all pending timers immediately,\n         * causing them to execute without any delay.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         * import { test } from 'node:test';\n         *\n         * test('runAll functions following the given order', (context) => {\n         *   context.mock.timers.enable({ apis: ['setTimeout', 'Date'] });\n         *   const results = [];\n         *   setTimeout(() => results.push(1), 9999);\n         *\n         *   // Notice that if both timers have the same timeout,\n         *   // the order of execution is guaranteed\n         *   setTimeout(() => results.push(3), 8888);\n         *   setTimeout(() => results.push(2), 8888);\n         *\n         *   assert.deepStrictEqual(results, []);\n         *\n         *   context.mock.timers.runAll();\n         *   assert.deepStrictEqual(results, [3, 2, 1]);\n         *   // The Date object is also advanced to the furthest timer's time\n         *   assert.strictEqual(Date.now(), 9999);\n         * });\n         * ```\n         *\n         * **Note:** The `runAll()` function is specifically designed for\n         * triggering timers in the context of timer mocking.\n         * It does not have any effect on real-time system\n         * clocks or actual timers outside of the mocking environment.\n         * @since v20.4.0\n         */\n        runAll(): void;\n        /**\n         * Calls {@link MockTimers.reset()}.\n         */\n        [Symbol.dispose](): void;\n    }\n    /**\n     * An object whose methods are used to configure available assertions on the\n     * `TestContext` objects in the current process. The methods from `node:assert`\n     * and snapshot testing functions are available by default.\n     *\n     * It is possible to apply the same configuration to all files by placing common\n     * configuration code in a module\n     * preloaded with `--require` or `--import`.\n     * @since v22.14.0\n     */\n    namespace assert {\n        /**\n         * Defines a new assertion function with the provided name and function. If an\n         * assertion already exists with the same name, it is overwritten.\n         * @since v22.14.0\n         */\n        function register(name: string, fn: (this: TestContext, ...args: any[]) => void): void;\n    }\n    /**\n     * @since v22.3.0\n     */\n    namespace snapshot {\n        /**\n         * This function is used to customize the default serialization mechanism used by the test runner.\n         *\n         * By default, the test runner performs serialization by calling `JSON.stringify(value, null, 2)` on the provided value.\n         * `JSON.stringify()` does have limitations regarding circular structures and supported data types.\n         * If a more robust serialization mechanism is required, this function should be used to specify a list of custom serializers.\n         *\n         * Serializers are called in order, with the output of the previous serializer passed as input to the next.\n         * The final result must be a string value.\n         * @since v22.3.0\n         * @param serializers An array of synchronous functions used as the default serializers for snapshot tests.\n         */\n        function setDefaultSnapshotSerializers(serializers: ReadonlyArray<(value: any) => any>): void;\n        /**\n         * This function is used to set a custom resolver for the location of the snapshot file used for snapshot testing.\n         * By default, the snapshot filename is the same as the entry point filename with `.snapshot` appended.\n         * @since v22.3.0\n         * @param fn A function used to compute the location of the snapshot file.\n         * The function receives the path of the test file as its only argument. If the\n         * test is not associated with a file (for example in the REPL), the input is\n         * undefined. `fn()` must return a string specifying the location of the snapshot file.\n         */\n        function setResolveSnapshotPath(fn: (path: string | undefined) => string): void;\n    }\n    export {\n        after,\n        afterEach,\n        assert,\n        before,\n        beforeEach,\n        describe,\n        it,\n        Mock,\n        mock,\n        only,\n        run,\n        skip,\n        snapshot,\n        suite,\n        SuiteContext,\n        test,\n        test as default,\n        TestContext,\n        todo,\n    };\n}\n\ninterface TestError extends Error {\n    cause: Error;\n}\ninterface TestLocationInfo {\n    /**\n     * The column number where the test is defined, or\n     * `undefined` if the test was run through the REPL.\n     */\n    column?: number;\n    /**\n     * The path of the test file, `undefined` if test was run through the REPL.\n     */\n    file?: string;\n    /**\n     * The line number where the test is defined, or `undefined` if the test was run through the REPL.\n     */\n    line?: number;\n}\ninterface DiagnosticData extends TestLocationInfo {\n    /**\n     * The diagnostic message.\n     */\n    message: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n}\ninterface TestCoverage {\n    /**\n     * An object containing the coverage report.\n     */\n    summary: {\n        /**\n         * An array of coverage reports for individual files.\n         */\n        files: Array<{\n            /**\n             * The absolute path of the file.\n             */\n            path: string;\n            /**\n             * The total number of lines.\n             */\n            totalLineCount: number;\n            /**\n             * The total number of branches.\n             */\n            totalBranchCount: number;\n            /**\n             * The total number of functions.\n             */\n            totalFunctionCount: number;\n            /**\n             * The number of covered lines.\n             */\n            coveredLineCount: number;\n            /**\n             * The number of covered branches.\n             */\n            coveredBranchCount: number;\n            /**\n             * The number of covered functions.\n             */\n            coveredFunctionCount: number;\n            /**\n             * The percentage of lines covered.\n             */\n            coveredLinePercent: number;\n            /**\n             * The percentage of branches covered.\n             */\n            coveredBranchPercent: number;\n            /**\n             * The percentage of functions covered.\n             */\n            coveredFunctionPercent: number;\n            /**\n             * An array of functions representing function coverage.\n             */\n            functions: Array<{\n                /**\n                 * The name of the function.\n                 */\n                name: string;\n                /**\n                 * The line number where the function is defined.\n                 */\n                line: number;\n                /**\n                 * The number of times the function was called.\n                 */\n                count: number;\n            }>;\n            /**\n             * An array of branches representing branch coverage.\n             */\n            branches: Array<{\n                /**\n                 * The line number where the branch is defined.\n                 */\n                line: number;\n                /**\n                 * The number of times the branch was taken.\n                 */\n                count: number;\n            }>;\n            /**\n             * An array of lines representing line numbers and the number of times they were covered.\n             */\n            lines: Array<{\n                /**\n                 * The line number.\n                 */\n                line: number;\n                /**\n                 * The number of times the line was covered.\n                 */\n                count: number;\n            }>;\n        }>;\n        /**\n         * An object containing whether or not the coverage for\n         * each coverage type.\n         * @since v22.9.0\n         */\n        thresholds: {\n            /**\n             * The function coverage threshold.\n             */\n            function: number;\n            /**\n             * The branch coverage threshold.\n             */\n            branch: number;\n            /**\n             * The line coverage threshold.\n             */\n            line: number;\n        };\n        /**\n         * An object containing a summary of coverage for all files.\n         */\n        totals: {\n            /**\n             * The total number of lines.\n             */\n            totalLineCount: number;\n            /**\n             * The total number of branches.\n             */\n            totalBranchCount: number;\n            /**\n             * The total number of functions.\n             */\n            totalFunctionCount: number;\n            /**\n             * The number of covered lines.\n             */\n            coveredLineCount: number;\n            /**\n             * The number of covered branches.\n             */\n            coveredBranchCount: number;\n            /**\n             * The number of covered functions.\n             */\n            coveredFunctionCount: number;\n            /**\n             * The percentage of lines covered.\n             */\n            coveredLinePercent: number;\n            /**\n             * The percentage of branches covered.\n             */\n            coveredBranchPercent: number;\n            /**\n             * The percentage of functions covered.\n             */\n            coveredFunctionPercent: number;\n        };\n        /**\n         * The working directory when code coverage began. This\n         * is useful for displaying relative path names in case\n         * the tests changed the working directory of the Node.js process.\n         */\n        workingDirectory: string;\n    };\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n}\ninterface TestComplete extends TestLocationInfo {\n    /**\n     * Additional execution metadata.\n     */\n    details: {\n        /**\n         * Whether the test passed or not.\n         */\n        passed: boolean;\n        /**\n         * The duration of the test in milliseconds.\n         */\n        duration_ms: number;\n        /**\n         * An error wrapping the error thrown by the test if it did not pass.\n         */\n        error?: TestError;\n        /**\n         * The type of the test, used to denote whether this is a suite.\n         */\n        type?: \"suite\";\n    };\n    /**\n     * The test name.\n     */\n    name: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n    /**\n     * The ordinal number of the test.\n     */\n    testNumber: number;\n    /**\n     * Present if `context.todo` is called.\n     */\n    todo?: string | boolean;\n    /**\n     * Present if `context.skip` is called.\n     */\n    skip?: string | boolean;\n}\ninterface TestDequeue extends TestLocationInfo {\n    /**\n     * The test name.\n     */\n    name: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n    /**\n     * The test type. Either `'suite'` or `'test'`.\n     * @since v22.15.0\n     */\n    type: \"suite\" | \"test\";\n}\ninterface TestEnqueue extends TestLocationInfo {\n    /**\n     * The test name.\n     */\n    name: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n    /**\n     * The test type. Either `'suite'` or `'test'`.\n     * @since v22.15.0\n     */\n    type: \"suite\" | \"test\";\n}\ninterface TestFail extends TestLocationInfo {\n    /**\n     * Additional execution metadata.\n     */\n    details: {\n        /**\n         * The duration of the test in milliseconds.\n         */\n        duration_ms: number;\n        /**\n         * An error wrapping the error thrown by the test.\n         */\n        error: TestError;\n        /**\n         * The type of the test, used to denote whether this is a suite.\n         * @since v20.0.0, v19.9.0, v18.17.0\n         */\n        type?: \"suite\";\n    };\n    /**\n     * The test name.\n     */\n    name: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n    /**\n     * The ordinal number of the test.\n     */\n    testNumber: number;\n    /**\n     * Present if `context.todo` is called.\n     */\n    todo?: string | boolean;\n    /**\n     * Present if `context.skip` is called.\n     */\n    skip?: string | boolean;\n}\ninterface TestPass extends TestLocationInfo {\n    /**\n     * Additional execution metadata.\n     */\n    details: {\n        /**\n         * The duration of the test in milliseconds.\n         */\n        duration_ms: number;\n        /**\n         * The type of the test, used to denote whether this is a suite.\n         * @since 20.0.0, 19.9.0, 18.17.0\n         */\n        type?: \"suite\";\n    };\n    /**\n     * The test name.\n     */\n    name: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n    /**\n     * The ordinal number of the test.\n     */\n    testNumber: number;\n    /**\n     * Present if `context.todo` is called.\n     */\n    todo?: string | boolean;\n    /**\n     * Present if `context.skip` is called.\n     */\n    skip?: string | boolean;\n}\ninterface TestPlan extends TestLocationInfo {\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n    /**\n     * The number of subtests that have ran.\n     */\n    count: number;\n}\ninterface TestStart extends TestLocationInfo {\n    /**\n     * The test name.\n     */\n    name: string;\n    /**\n     * The nesting level of the test.\n     */\n    nesting: number;\n}\ninterface TestStderr {\n    /**\n     * The path of the test file.\n     */\n    file: string;\n    /**\n     * The message written to `stderr`.\n     */\n    message: string;\n}\ninterface TestStdout {\n    /**\n     * The path of the test file.\n     */\n    file: string;\n    /**\n     * The message written to `stdout`.\n     */\n    message: string;\n}\ninterface TestSummary {\n    /**\n     * An object containing the counts of various test results.\n     */\n    counts: {\n        /**\n         * The total number of cancelled tests.\n         */\n        cancelled: number;\n        /**\n         * The total number of passed tests.\n         */\n        passed: number;\n        /**\n         * The total number of skipped tests.\n         */\n        skipped: number;\n        /**\n         * The total number of suites run.\n         */\n        suites: number;\n        /**\n         * The total number of tests run, excluding suites.\n         */\n        tests: number;\n        /**\n         * The total number of TODO tests.\n         */\n        todo: number;\n        /**\n         * The total number of top level tests and suites.\n         */\n        topLevel: number;\n    };\n    /**\n     * The duration of the test run in milliseconds.\n     */\n    duration_ms: number;\n    /**\n     * The path of the test file that generated the\n     * summary. If the summary corresponds to multiple files, this value is\n     * `undefined`.\n     */\n    file: string | undefined;\n    /**\n     * Indicates whether or not the test run is considered\n     * successful or not. If any error condition occurs, such as a failing test or\n     * unmet coverage threshold, this value will be set to `false`.\n     */\n    success: boolean;\n}\n\n/**\n * The `node:test/reporters` module exposes the builtin-reporters for `node:test`.\n * To access it:\n *\n * ```js\n * import test from 'node:test/reporters';\n * ```\n *\n * This module is only available under the `node:` scheme. The following will not\n * work:\n *\n * ```js\n * import test from 'node:test/reporters';\n * ```\n * @since v19.9.0\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/test/reporters.js)\n */\ndeclare module \"node:test/reporters\" {\n    import { Transform, TransformOptions } from \"node:stream\";\n\n    type TestEvent =\n        | { type: \"test:coverage\"; data: TestCoverage }\n        | { type: \"test:complete\"; data: TestComplete }\n        | { type: \"test:dequeue\"; data: TestDequeue }\n        | { type: \"test:diagnostic\"; data: DiagnosticData }\n        | { type: \"test:enqueue\"; data: TestEnqueue }\n        | { type: \"test:fail\"; data: TestFail }\n        | { type: \"test:pass\"; data: TestPass }\n        | { type: \"test:plan\"; data: TestPlan }\n        | { type: \"test:start\"; data: TestStart }\n        | { type: \"test:stderr\"; data: TestStderr }\n        | { type: \"test:stdout\"; data: TestStdout }\n        | { type: \"test:summary\"; data: TestSummary }\n        | { type: \"test:watch:drained\"; data: undefined };\n    type TestEventGenerator = AsyncGenerator<TestEvent, void>;\n\n    interface ReporterConstructorWrapper<T extends new(...args: any[]) => Transform> {\n        new(...args: ConstructorParameters<T>): InstanceType<T>;\n        (...args: ConstructorParameters<T>): InstanceType<T>;\n    }\n\n    /**\n     * The `dot` reporter outputs the test results in a compact format,\n     * where each passing test is represented by a `.`,\n     * and each failing test is represented by a `X`.\n     * @since v20.0.0\n     */\n    function dot(source: TestEventGenerator): AsyncGenerator<\"\\n\" | \".\" | \"X\", void>;\n    /**\n     * The `tap` reporter outputs the test results in the [TAP](https://testanything.org/) format.\n     * @since v20.0.0\n     */\n    function tap(source: TestEventGenerator): AsyncGenerator<string, void>;\n    class SpecReporter extends Transform {\n        constructor();\n    }\n    /**\n     * The `spec` reporter outputs the test results in a human-readable format.\n     * @since v20.0.0\n     */\n    const spec: ReporterConstructorWrapper<typeof SpecReporter>;\n    /**\n     * The `junit` reporter outputs test results in a jUnit XML format.\n     * @since v21.0.0\n     */\n    function junit(source: TestEventGenerator): AsyncGenerator<string, void>;\n    class LcovReporter extends Transform {\n        constructor(opts?: Omit<TransformOptions, \"writableObjectMode\">);\n    }\n    /**\n     * The `lcov` reporter outputs test coverage when used with the\n     * [`--experimental-test-coverage`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--experimental-test-coverage) flag.\n     * @since v22.0.0\n     */\n    // TODO: change the export to a wrapper function once node@0db38f0 is merged (breaking change)\n    // const lcov: ReporterConstructorWrapper<typeof LcovReporter>;\n    const lcov: LcovReporter;\n\n    export { dot, junit, lcov, spec, tap, TestEvent };\n}\n"
        }
    ]
}