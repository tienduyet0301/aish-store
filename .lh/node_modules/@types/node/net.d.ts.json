{
    "sourceFile": "node_modules/@types/node/net.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * > Stability: 2 - Stable\n *\n * The `node:net` module provides an asynchronous network API for creating stream-based\n * TCP or `IPC` servers ({@link createServer}) and clients\n * ({@link createConnection}).\n *\n * It can be accessed using:\n *\n * ```js\n * import net from 'node:net';\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/net.js)\n */\ndeclare module \"net\" {\n    import * as stream from \"node:stream\";\n    import { Abortable, EventEmitter } from \"node:events\";\n    import * as dns from \"node:dns\";\n    type LookupFunction = (\n        hostname: string,\n        options: dns.LookupOptions,\n        callback: (err: NodeJS.ErrnoException | null, address: string | dns.LookupAddress[], family?: number) => void,\n    ) => void;\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n    interface SocketConstructorOpts {\n        fd?: number | undefined;\n        allowHalfOpen?: boolean | undefined;\n        onread?: OnReadOpts | undefined;\n        readable?: boolean | undefined;\n        writable?: boolean | undefined;\n        signal?: AbortSignal;\n    }\n    interface OnReadOpts {\n        buffer: Uint8Array | (() => Uint8Array);\n        /**\n         * This function is called for every chunk of incoming data.\n         * Two arguments are passed to it: the number of bytes written to `buffer` and a reference to `buffer`.\n         * Return `false` from this function to implicitly `pause()` the socket.\n         */\n        callback(bytesWritten: number, buffer: Uint8Array): boolean;\n    }\n    // TODO: remove empty ConnectOpts placeholder at next major @types/node version.\n    /** @deprecated */\n    interface ConnectOpts {}\n    interface TcpSocketConnectOpts {\n        port: number;\n        host?: string | undefined;\n        localAddress?: string | undefined;\n        localPort?: number | undefined;\n        hints?: number | undefined;\n        family?: number | undefined;\n        lookup?: LookupFunction | undefined;\n        noDelay?: boolean | undefined;\n        keepAlive?: boolean | undefined;\n        keepAliveInitialDelay?: number | undefined;\n        /**\n         * @since v18.13.0\n         */\n        autoSelectFamily?: boolean | undefined;\n        /**\n         * @since v18.13.0\n         */\n        autoSelectFamilyAttemptTimeout?: number | undefined;\n        blockList?: BlockList | undefined;\n    }\n    interface IpcSocketConnectOpts {\n        path: string;\n    }\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n    type SocketReadyState = \"opening\" | \"open\" | \"readOnly\" | \"writeOnly\" | \"closed\";\n    /**\n     * This class is an abstraction of a TCP socket or a streaming `IPC` endpoint\n     * (uses named pipes on Windows, and Unix domain sockets otherwise). It is also\n     * an `EventEmitter`.\n     *\n     * A `net.Socket` can be created by the user and used directly to interact with\n     * a server. For example, it is returned by {@link createConnection},\n     * so the user can use it to talk to the server.\n     *\n     * It can also be created by Node.js and passed to the user when a connection\n     * is received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use\n     * it to interact with the client.\n     * @since v0.3.4\n     */\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n        /**\n         * Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\n         * If the socket is still writable it implicitly calls `socket.end()`.\n         * @since v0.3.4\n         */\n        destroySoon(): void;\n        /**\n         * Sends data on the socket. The second parameter specifies the encoding in the\n         * case of a string. It defaults to UTF8 encoding.\n         *\n         * Returns `true` if the entire data was flushed successfully to the kernel\n         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.\n         *\n         * The optional `callback` parameter will be executed when the data is finally\n         * written out, which may not be immediately.\n         *\n         * See `Writable` stream `write()` method for more\n         * information.\n         * @since v0.1.90\n         * @param [encoding='utf8'] Only used when data is `string`.\n         */\n        write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;\n        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error) => void): boolean;\n        /**\n         * Initiate a connection on a given socket.\n         *\n         * Possible signatures:\n         *\n         * * `socket.connect(options[, connectListener])`\n         * * `socket.connect(path[, connectListener])` for `IPC` connections.\n         * * `socket.connect(port[, host][, connectListener])` for TCP connections.\n         * * Returns: `net.Socket` The socket itself.\n         *\n         * This function is asynchronous. When the connection is established, the `'connect'` event will be emitted. If there is a problem connecting,\n         * instead of a `'connect'` event, an `'error'` event will be emitted with\n         * the error passed to the `'error'` listener.\n         * The last parameter `connectListener`, if supplied, will be added as a listener\n         * for the `'connect'` event **once**.\n         *\n         * This function should only be used for reconnecting a socket after`'close'` has been emitted or otherwise it may lead to undefined\n         * behavior.\n         */\n        connect(options: SocketConnectOpts, connectionListener?: () => void): this;\n        connect(port: number, host: string, connectionListener?: () => void): this;\n        connect(port: number, connectionListener?: () => void): this;\n        connect(path: string, connectionListener?: () => void): this;\n        /**\n         * Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.\n         * @since v0.1.90\n         * @return The socket itself.\n         */\n        setEncoding(encoding?: BufferEncoding): this;\n        /**\n         * Pauses the reading of data. That is, `'data'` events will not be emitted.\n         * Useful to throttle back an upload.\n         * @return The socket itself.\n         */\n        pause(): this;\n        /**\n         * Close the TCP connection by sending an RST packet and destroy the stream.\n         * If this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\n         * Otherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\n         * If this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.\n         * @since v18.3.0, v16.17.0\n         */\n        resetAndDestroy(): this;\n        /**\n         * Resumes reading after a call to `socket.pause()`.\n         * @return The socket itself.\n         */\n        resume(): this;\n        /**\n         * Sets the socket to timeout after `timeout` milliseconds of inactivity on\n         * the socket. By default `net.Socket` do not have a timeout.\n         *\n         * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed. The user must manually call `socket.end()` or `socket.destroy()` to\n         * end the connection.\n         *\n         * ```js\n         * socket.setTimeout(3000);\n         * socket.on('timeout', () => {\n         *   console.log('socket timeout');\n         *   socket.end();\n         * });\n         * ```\n         *\n         * If `timeout` is 0, then the existing idle timeout is disabled.\n         *\n         * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.\n         * @since v0.1.90\n         * @return The socket itself.\n         */\n        setTimeout(timeout: number, callback?: () => void): this;\n        /**\n         * Enable/disable the use of Nagle's algorithm.\n         *\n         * When a TCP connection is created, it will have Nagle's algorithm enabled.\n         *\n         * Nagle's algorithm delays data before it is sent via the network. It attempts\n         * to optimize throughput at the expense of latency.\n         *\n         * Passing `true` for `noDelay` or not passing an argument will disable Nagle's\n         * algorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\n         * algorithm.\n         * @since v0.1.90\n         * @param [noDelay=true]\n         * @return The socket itself.\n         */\n        setNoDelay(noDelay?: boolean): this;\n        /**\n         * Enable/disable keep-alive functionality, and optionally set the initial\n         * delay before the first keepalive probe is sent on an idle socket.\n         *\n         * Set `initialDelay` (in milliseconds) to set the delay between the last\n         * data packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n         * (or previous) setting.\n         *\n         * Enabling the keep-alive functionality will set the following socket options:\n         *\n         * * `SO_KEEPALIVE=1`\n         * * `TCP_KEEPIDLE=initialDelay`\n         * * `TCP_KEEPCNT=10`\n         * * `TCP_KEEPINTVL=1`\n         * @since v0.1.92\n         * @param [enable=false]\n         * @param [initialDelay=0]\n         * @return The socket itself.\n         */\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        /**\n         * Returns the bound `address`, the address `family` name and `port` of the\n         * socket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`\n         * @since v0.1.90\n         */\n        address(): AddressInfo | {};\n        /**\n         * Calling `unref()` on a socket will allow the program to exit if this is the only\n         * active socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.\n         * @since v0.9.1\n         * @return The socket itself.\n         */\n        unref(): this;\n        /**\n         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\n         * If the socket is `ref`ed calling `ref` again will have no effect.\n         * @since v0.9.1\n         * @return The socket itself.\n         */\n        ref(): this;\n        /**\n         * This property is only present if the family autoselection algorithm is enabled in `socket.connect(options)`\n         * and it is an array of the addresses that have been attempted.\n         *\n         * Each address is a string in the form of `$IP:$PORT`.\n         * If the connection was successful, then the last address is the one that the socket is currently connected to.\n         * @since v19.4.0\n         */\n        readonly autoSelectFamilyAttemptedAddresses: string[];\n        /**\n         * This property shows the number of characters buffered for writing. The buffer\n         * may contain strings whose length after encoding is not yet known. So this number\n         * is only an approximation of the number of bytes in the buffer.\n         *\n         * `net.Socket` has the property that `socket.write()` always works. This is to\n         * help users get up and running quickly. The computer cannot always keep up\n         * with the amount of data that is written to a socket. The network connection\n         * simply might be too slow. Node.js will internally queue up the data written to a\n         * socket and send it out over the wire when it is possible.\n         *\n         * The consequence of this internal buffering is that memory may grow.\n         * Users who experience large or growing `bufferSize` should attempt to\n         * \"throttle\" the data flows in their program with `socket.pause()` and `socket.resume()`.\n         * @since v0.3.8\n         * @deprecated Since v14.6.0 - Use `writableLength` instead.\n         */\n        readonly bufferSize: number;\n        /**\n         * The amount of received bytes.\n         * @since v0.5.3\n         */\n        readonly bytesRead: number;\n        /**\n         * The amount of bytes sent.\n         * @since v0.5.3\n         */\n        readonly bytesWritten: number;\n        /**\n         * If `true`, `socket.connect(options[, connectListener])` was\n         * called and has not yet finished. It will stay `true` until the socket becomes\n         * connected, then it is set to `false` and the `'connect'` event is emitted. Note\n         * that the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.\n         * @since v6.1.0\n         */\n        readonly connecting: boolean;\n        /**\n         * This is `true` if the socket is not connected yet, either because `.connect()`has not yet been called or because it is still in the process of connecting\n         * (see `socket.connecting`).\n         * @since v11.2.0, v10.16.0\n         */\n        readonly pending: boolean;\n        /**\n         * See `writable.destroyed` for further details.\n         */\n        readonly destroyed: boolean;\n        /**\n         * The string representation of the local IP address the remote client is\n         * connecting on. For example, in a server listening on `'0.0.0.0'`, if a client\n         * connects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.\n         * @since v0.9.6\n         */\n        readonly localAddress?: string;\n        /**\n         * The numeric representation of the local port. For example, `80` or `21`.\n         * @since v0.9.6\n         */\n        readonly localPort?: number;\n        /**\n         * The string representation of the local IP family. `'IPv4'` or `'IPv6'`.\n         * @since v18.8.0, v16.18.0\n         */\n        readonly localFamily?: string;\n        /**\n         * This property represents the state of the connection as a string.\n         *\n         * * If the stream is connecting `socket.readyState` is `opening`.\n         * * If the stream is readable and writable, it is `open`.\n         * * If the stream is readable and not writable, it is `readOnly`.\n         * * If the stream is not readable and writable, it is `writeOnly`.\n         * @since v0.5.0\n         */\n        readonly readyState: SocketReadyState;\n        /**\n         * The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if\n         * the socket is destroyed (for example, if the client disconnected).\n         * @since v0.5.10\n         */\n        readonly remoteAddress?: string | undefined;\n        /**\n         * The string representation of the remote IP family. `'IPv4'` or `'IPv6'`. Value may be `undefined` if\n         * the socket is destroyed (for example, if the client disconnected).\n         * @since v0.11.14\n         */\n        readonly remoteFamily?: string | undefined;\n        /**\n         * The numeric representation of the remote port. For example, `80` or `21`. Value may be `undefined` if\n         * the socket is destroyed (for example, if the client disconnected).\n         * @since v0.5.10\n         */\n        readonly remotePort?: number | undefined;\n        /**\n         * The socket timeout in milliseconds as set by `socket.setTimeout()`.\n         * It is `undefined` if a timeout has not been set.\n         * @since v10.7.0\n         */\n        readonly timeout?: number | undefined;\n        /**\n         * Half-closes the socket. i.e., it sends a FIN packet. It is possible the\n         * server will still send some data.\n         *\n         * See `writable.end()` for further details.\n         * @since v0.1.90\n         * @param [encoding='utf8'] Only used when data is `string`.\n         * @param callback Optional callback for when the socket is finished.\n         * @return The socket itself.\n         */\n        end(callback?: () => void): this;\n        end(buffer: Uint8Array | string, callback?: () => void): this;\n        end(str: Uint8Array | string, encoding?: BufferEncoding, callback?: () => void): this;\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. connectionAttempt\n         *   4. connectionAttemptFailed\n         *   5. connectionAttemptTimeout\n         *   6. data\n         *   7. drain\n         *   8. end\n         *   9. error\n         *   10. lookup\n         *   11. ready\n         *   12. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: (hadError: boolean) => void): this;\n        addListener(event: \"connect\", listener: () => void): this;\n        addListener(event: \"connectionAttempt\", listener: (ip: string, port: number, family: number) => void): this;\n        addListener(\n            event: \"connectionAttemptFailed\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        addListener(\n            event: \"connectionAttemptTimeout\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        addListener(event: \"data\", listener: (data: Buffer) => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(\n            event: \"lookup\",\n            listener: (err: Error, address: string, family: string | number, host: string) => void,\n        ): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"timeout\", listener: () => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\", hadError: boolean): boolean;\n        emit(event: \"connect\"): boolean;\n        emit(event: \"connectionAttempt\", ip: string, port: number, family: number): boolean;\n        emit(event: \"connectionAttemptFailed\", ip: string, port: number, family: number): boolean;\n        emit(event: \"connectionAttemptTimeout\", ip: string, port: number, family: number): boolean;\n        emit(event: \"data\", data: Buffer): boolean;\n        emit(event: \"drain\"): boolean;\n        emit(event: \"end\"): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"lookup\", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: \"ready\"): boolean;\n        emit(event: \"timeout\"): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: (hadError: boolean) => void): this;\n        on(event: \"connect\", listener: () => void): this;\n        on(event: \"connectionAttempt\", listener: (ip: string, port: number, family: number) => void): this;\n        on(event: \"connectionAttemptFailed\", listener: (ip: string, port: number, family: number) => void): this;\n        on(event: \"connectionAttemptTimeout\", listener: (ip: string, port: number, family: number) => void): this;\n        on(event: \"data\", listener: (data: Buffer) => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(\n            event: \"lookup\",\n            listener: (err: Error, address: string, family: string | number, host: string) => void,\n        ): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"timeout\", listener: () => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: (hadError: boolean) => void): this;\n        once(event: \"connectionAttempt\", listener: (ip: string, port: number, family: number) => void): this;\n        once(event: \"connectionAttemptFailed\", listener: (ip: string, port: number, family: number) => void): this;\n        once(event: \"connectionAttemptTimeout\", listener: (ip: string, port: number, family: number) => void): this;\n        once(event: \"connect\", listener: () => void): this;\n        once(event: \"data\", listener: (data: Buffer) => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(\n            event: \"lookup\",\n            listener: (err: Error, address: string, family: string | number, host: string) => void,\n        ): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"timeout\", listener: () => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: (hadError: boolean) => void): this;\n        prependListener(event: \"connect\", listener: () => void): this;\n        prependListener(event: \"connectionAttempt\", listener: (ip: string, port: number, family: number) => void): this;\n        prependListener(\n            event: \"connectionAttemptFailed\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        prependListener(\n            event: \"connectionAttemptTimeout\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        prependListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(\n            event: \"lookup\",\n            listener: (err: Error, address: string, family: string | number, host: string) => void,\n        ): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"timeout\", listener: () => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: (hadError: boolean) => void): this;\n        prependOnceListener(event: \"connect\", listener: () => void): this;\n        prependOnceListener(\n            event: \"connectionAttempt\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        prependOnceListener(\n            event: \"connectionAttemptFailed\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        prependOnceListener(\n            event: \"connectionAttemptTimeout\",\n            listener: (ip: string, port: number, family: number) => void,\n        ): this;\n        prependOnceListener(event: \"data\", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(\n            event: \"lookup\",\n            listener: (err: Error, address: string, family: string | number, host: string) => void,\n        ): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"timeout\", listener: () => void): this;\n    }\n    interface ListenOptions extends Abortable {\n        backlog?: number | undefined;\n        exclusive?: boolean | undefined;\n        host?: string | undefined;\n        /**\n         * @default false\n         */\n        ipv6Only?: boolean | undefined;\n        reusePort?: boolean | undefined;\n        path?: string | undefined;\n        port?: number | undefined;\n        readableAll?: boolean | undefined;\n        writableAll?: boolean | undefined;\n    }\n    interface ServerOpts {\n        /**\n         * Indicates whether half-opened TCP connections are allowed.\n         * @default false\n         */\n        allowHalfOpen?: boolean | undefined;\n        /**\n         * Indicates whether the socket should be paused on incoming connections.\n         * @default false\n         */\n        pauseOnConnect?: boolean | undefined;\n        /**\n         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.\n         * @default false\n         * @since v16.5.0\n         */\n        noDelay?: boolean | undefined;\n        /**\n         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,\n         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.\n         * @default false\n         * @since v16.5.0\n         */\n        keepAlive?: boolean | undefined;\n        /**\n         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.\n         * @default 0\n         * @since v16.5.0\n         */\n        keepAliveInitialDelay?: number | undefined;\n        /**\n         * Optionally overrides all `net.Socket`s' `readableHighWaterMark` and `writableHighWaterMark`.\n         * @default See [stream.getDefaultHighWaterMark()](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamgetdefaulthighwatermarkobjectmode).\n         * @since v18.17.0, v20.1.0\n         */\n        highWaterMark?: number | undefined;\n        /**\n         * `blockList` can be used for disabling inbound\n         * access to specific IP addresses, IP ranges, or IP subnets. This does not\n         * work if the server is behind a reverse proxy, NAT, etc. because the address\n         * checked against the block list is the address of the proxy, or the one\n         * specified by the NAT.\n         * @since v22.13.0\n         */\n        blockList?: BlockList | undefined;\n    }\n    interface DropArgument {\n        localAddress?: string;\n        localPort?: number;\n        localFamily?: string;\n        remoteAddress?: string;\n        remotePort?: number;\n        remoteFamily?: string;\n    }\n    /**\n     * This class is used to create a TCP or `IPC` server.\n     * @since v0.1.90\n     */\n    class Server extends EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: ServerOpts, connectionListener?: (socket: Socket) => void);\n        /**\n         * Start a server listening for connections. A `net.Server` can be a TCP or\n         * an `IPC` server depending on what it listens to.\n         *\n         * Possible signatures:\n         *\n         * * `server.listen(handle[, backlog][, callback])`\n         * * `server.listen(options[, callback])`\n         * * `server.listen(path[, backlog][, callback])` for `IPC` servers\n         * * `server.listen([port[, host[, backlog]]][, callback])` for TCP servers\n         *\n         * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted. The last parameter `callback`will be added as a listener for the `'listening'`\n         * event.\n         *\n         * All `listen()` methods can take a `backlog` parameter to specify the maximum\n         * length of the queue of pending connections. The actual length will be determined\n         * by the OS through sysctl settings such as `tcp_max_syn_backlog` and `somaxconn` on Linux. The default value of this parameter is 511 (not 512).\n         *\n         * All {@link Socket} are set to `SO_REUSEADDR` (see [`socket(7)`](https://man7.org/linux/man-pages/man7/socket.7.html) for\n         * details).\n         *\n         * The `server.listen()` method can be called again if and only if there was an\n         * error during the first `server.listen()` call or `server.close()` has been\n         * called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN` error will be thrown.\n         *\n         * One of the most common errors raised when listening is `EADDRINUSE`.\n         * This happens when another server is already listening on the requested`port`/`path`/`handle`. One way to handle this would be to retry\n         * after a certain amount of time:\n         *\n         * ```js\n         * server.on('error', (e) => {\n         *   if (e.code === 'EADDRINUSE') {\n         *     console.error('Address in use, retrying...');\n         *     setTimeout(() => {\n         *       server.close();\n         *       server.listen(PORT, HOST);\n         *     }, 1000);\n         *   }\n         * });\n         * ```\n         */\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, hostname?: string, listeningListener?: () => void): this;\n        listen(port?: number, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, listeningListener?: () => void): this;\n        listen(path: string, backlog?: number, listeningListener?: () => void): this;\n        listen(path: string, listeningListener?: () => void): this;\n        listen(options: ListenOptions, listeningListener?: () => void): this;\n        listen(handle: any, backlog?: number, listeningListener?: () => void): this;\n        listen(handle: any, listeningListener?: () => void): this;\n        /**\n         * Stops the server from accepting new connections and keeps existing\n         * connections. This function is asynchronous, the server is finally closed\n         * when all connections are ended and the server emits a `'close'` event.\n         * The optional `callback` will be called once the `'close'` event occurs. Unlike\n         * that event, it will be called with an `Error` as its only argument if the server\n         * was not open when it was closed.\n         * @since v0.1.90\n         * @param callback Called when the server is closed.\n         */\n        close(callback?: (err?: Error) => void): this;\n        /**\n         * Returns the bound `address`, the address `family` name, and `port` of the server\n         * as reported by the operating system if listening on an IP socket\n         * (useful to find which port was assigned when getting an OS-assigned address):`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.\n         *\n         * For a server listening on a pipe or Unix domain socket, the name is returned\n         * as a string.\n         *\n         * ```js\n         * const server = net.createServer((socket) => {\n         *   socket.end('goodbye\\n');\n         * }).on('error', (err) => {\n         *   // Handle errors here.\n         *   throw err;\n         * });\n         *\n         * // Grab an arbitrary unused port.\n         * server.listen(() => {\n         *   console.log('opened server on', server.address());\n         * });\n         * ```\n         *\n         * `server.address()` returns `null` before the `'listening'` event has been\n         * emitted or after calling `server.close()`.\n         * @since v0.1.90\n         */\n        address(): AddressInfo | string | null;\n        /**\n         * Asynchronously get the number of concurrent connections on the server. Works\n         * when sockets were sent to forks.\n         *\n         * Callback should take two arguments `err` and `count`.\n         * @since v0.9.7\n         */\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        /**\n         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed server will _not_ let the program exit if it's the only server left (the default behavior).\n         * If the server is `ref`ed calling `ref()` again will have no effect.\n         * @since v0.9.1\n         */\n        ref(): this;\n        /**\n         * Calling `unref()` on a server will allow the program to exit if this is the only\n         * active server in the event system. If the server is already `unref`ed calling`unref()` again will have no effect.\n         * @since v0.9.1\n         */\n        unref(): this;\n        /**\n         * Set this property to reject connections when the server's connection count gets\n         * high.\n         *\n         * It is not recommended to use this option once a socket has been sent to a child\n         * with `child_process.fork()`.\n         * @since v0.2.0\n         */\n        maxConnections: number;\n        connections: number;\n        /**\n         * Indicates whether or not the server is listening for connections.\n         * @since v5.7.0\n         */\n        readonly listening: boolean;\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         *   5. drop\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"drop\", listener: (data?: DropArgument) => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connection\", socket: Socket): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(event: \"drop\", data?: DropArgument): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connection\", listener: (socket: Socket) => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"drop\", listener: (data?: DropArgument) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connection\", listener: (socket: Socket) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"drop\", listener: (data?: DropArgument) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"drop\", listener: (data?: DropArgument) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connection\", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"drop\", listener: (data?: DropArgument) => void): this;\n        /**\n         * Calls {@link Server.close()} and returns a promise that fulfills when the server has closed.\n         * @since v20.5.0\n         */\n        [Symbol.asyncDispose](): Promise<void>;\n    }\n    type IPVersion = \"ipv4\" | \"ipv6\";\n    /**\n     * The `BlockList` object can be used with some network APIs to specify rules for\n     * disabling inbound or outbound access to specific IP addresses, IP ranges, or\n     * IP subnets.\n     * @since v15.0.0, v14.18.0\n     */\n    class BlockList {\n        /**\n         * Adds a rule to block the given IP address.\n         * @since v15.0.0, v14.18.0\n         * @param address An IPv4 or IPv6 address.\n         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.\n         */\n        addAddress(address: string, type?: IPVersion): void;\n        addAddress(address: SocketAddress): void;\n        /**\n         * Adds a rule to block a range of IP addresses from `start` (inclusive) to`end` (inclusive).\n         * @since v15.0.0, v14.18.0\n         * @param start The starting IPv4 or IPv6 address in the range.\n         * @param end The ending IPv4 or IPv6 address in the range.\n         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.\n         */\n        addRange(start: string, end: string, type?: IPVersion): void;\n        addRange(start: SocketAddress, end: SocketAddress): void;\n        /**\n         * Adds a rule to block a range of IP addresses specified as a subnet mask.\n         * @since v15.0.0, v14.18.0\n         * @param net The network IPv4 or IPv6 address.\n         * @param prefix The number of CIDR prefix bits. For IPv4, this must be a value between `0` and `32`. For IPv6, this must be between `0` and `128`.\n         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.\n         */\n        addSubnet(net: SocketAddress, prefix: number): void;\n        addSubnet(net: string, prefix: number, type?: IPVersion): void;\n        /**\n         * Returns `true` if the given IP address matches any of the rules added to the`BlockList`.\n         *\n         * ```js\n         * const blockList = new net.BlockList();\n         * blockList.addAddress('123.123.123.123');\n         * blockList.addRange('10.0.0.1', '10.0.0.10');\n         * blockList.addSubnet('8592:757c:efae:4e45::', 64, 'ipv6');\n         *\n         * console.log(blockList.check('123.123.123.123'));  // Prints: true\n         * console.log(blockList.check('10.0.0.3'));  // Prints: true\n         * console.log(blockList.check('222.111.111.222'));  // Prints: false\n         *\n         * // IPv6 notation for IPv4 addresses works:\n         * console.log(blockList.check('::ffff:7b7b:7b7b', 'ipv6')); // Prints: true\n         * console.log(blockList.check('::ffff:123.123.123.123', 'ipv6')); // Prints: true\n         * ```\n         * @since v15.0.0, v14.18.0\n         * @param address The IP address to check\n         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.\n         */\n        check(address: SocketAddress): boolean;\n        check(address: string, type?: IPVersion): boolean;\n        /**\n         * The list of rules added to the blocklist.\n         * @since v15.0.0, v14.18.0\n         */\n        rules: readonly string[];\n        /**\n         * Returns `true` if the `value` is a `net.BlockList`.\n         * @since v22.13.0\n         * @param value Any JS value\n         */\n        static isBlockList(value: unknown): value is BlockList;\n    }\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number | undefined;\n    }\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number | undefined;\n    }\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n    /**\n     * Creates a new TCP or `IPC` server.\n     *\n     * If `allowHalfOpen` is set to `true`, when the other end of the socket\n     * signals the end of transmission, the server will only send back the end of\n     * transmission when `socket.end()` is explicitly called. For example, in the\n     * context of TCP, when a FIN packed is received, a FIN packed is sent\n     * back only when `socket.end()` is explicitly called. Until then the\n     * connection is half-closed (non-readable but still writable). See `'end'` event and [RFC 1122](https://tools.ietf.org/html/rfc1122) (section 4.2.2.13) for more information.\n     *\n     * If `pauseOnConnect` is set to `true`, then the socket associated with each\n     * incoming connection will be paused, and no data will be read from its handle.\n     * This allows connections to be passed between processes without any data being\n     * read by the original process. To begin reading data from a paused socket, call `socket.resume()`.\n     *\n     * The server can be a TCP server or an `IPC` server, depending on what it `listen()` to.\n     *\n     * Here is an example of a TCP echo server which listens for connections\n     * on port 8124:\n     *\n     * ```js\n     * import net from 'node:net';\n     * const server = net.createServer((c) => {\n     *   // 'connection' listener.\n     *   console.log('client connected');\n     *   c.on('end', () => {\n     *     console.log('client disconnected');\n     *   });\n     *   c.write('hello\\r\\n');\n     *   c.pipe(c);\n     * });\n     * server.on('error', (err) => {\n     *   throw err;\n     * });\n     * server.listen(8124, () => {\n     *   console.log('server bound');\n     * });\n     * ```\n     *\n     * Test this by using `telnet`:\n     *\n     * ```bash\n     * telnet localhost 8124\n     * ```\n     *\n     * To listen on the socket `/tmp/echo.sock`:\n     *\n     * ```js\n     * server.listen('/tmp/echo.sock', () => {\n     *   console.log('server bound');\n     * });\n     * ```\n     *\n     * Use `nc` to connect to a Unix domain socket server:\n     *\n     * ```bash\n     * nc -U /tmp/echo.sock\n     * ```\n     * @since v0.5.0\n     * @param connectionListener Automatically set as a listener for the {@link 'connection'} event.\n     */\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: ServerOpts, connectionListener?: (socket: Socket) => void): Server;\n    /**\n     * Aliases to {@link createConnection}.\n     *\n     * Possible signatures:\n     *\n     * * {@link connect}\n     * * {@link connect} for `IPC` connections.\n     * * {@link connect} for TCP connections.\n     */\n    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function connect(port: number, host?: string, connectionListener?: () => void): Socket;\n    function connect(path: string, connectionListener?: () => void): Socket;\n    /**\n     * A factory function, which creates a new {@link Socket},\n     * immediately initiates connection with `socket.connect()`,\n     * then returns the `net.Socket` that starts the connection.\n     *\n     * When the connection is established, a `'connect'` event will be emitted\n     * on the returned socket. The last parameter `connectListener`, if supplied,\n     * will be added as a listener for the `'connect'` event **once**.\n     *\n     * Possible signatures:\n     *\n     * * {@link createConnection}\n     * * {@link createConnection} for `IPC` connections.\n     * * {@link createConnection} for TCP connections.\n     *\n     * The {@link connect} function is an alias to this function.\n     */\n    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;\n    function createConnection(path: string, connectionListener?: () => void): Socket;\n    /**\n     * Gets the current default value of the `autoSelectFamily` option of `socket.connect(options)`.\n     * The initial default value is `true`, unless the command line option`--no-network-family-autoselection` is provided.\n     * @since v19.4.0\n     */\n    function getDefaultAutoSelectFamily(): boolean;\n    /**\n     * Sets the default value of the `autoSelectFamily` option of `socket.connect(options)`.\n     * @param value The new default value.\n     * The initial default value is `true`, unless the command line option\n     * `--no-network-family-autoselection` is provided.\n     * @since v19.4.0\n     */\n    function setDefaultAutoSelectFamily(value: boolean): void;\n    /**\n     * Gets the current default value of the `autoSelectFamilyAttemptTimeout` option of `socket.connect(options)`.\n     * The initial default value is `250` or the value specified via the command line option `--network-family-autoselection-attempt-timeout`.\n     * @returns The current default value of the `autoSelectFamilyAttemptTimeout` option.\n     * @since v19.8.0, v18.8.0\n     */\n    function getDefaultAutoSelectFamilyAttemptTimeout(): number;\n    /**\n     * Sets the default value of the `autoSelectFamilyAttemptTimeout` option of `socket.connect(options)`.\n     * @param value The new default value, which must be a positive number. If the number is less than `10`, the value `10` is used instead. The initial default value is `250` or the value specified via the command line\n     * option `--network-family-autoselection-attempt-timeout`.\n     * @since v19.8.0, v18.8.0\n     */\n    function setDefaultAutoSelectFamilyAttemptTimeout(value: number): void;\n    /**\n     * Returns `6` if `input` is an IPv6 address. Returns `4` if `input` is an IPv4\n     * address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no leading zeroes. Otherwise, returns`0`.\n     *\n     * ```js\n     * net.isIP('::1'); // returns 6\n     * net.isIP('127.0.0.1'); // returns 4\n     * net.isIP('127.000.000.001'); // returns 0\n     * net.isIP('127.0.0.1/24'); // returns 0\n     * net.isIP('fhqwhgads'); // returns 0\n     * ```\n     * @since v0.3.0\n     */\n    function isIP(input: string): number;\n    /**\n     * Returns `true` if `input` is an IPv4 address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no\n     * leading zeroes. Otherwise, returns `false`.\n     *\n     * ```js\n     * net.isIPv4('127.0.0.1'); // returns true\n     * net.isIPv4('127.000.000.001'); // returns false\n     * net.isIPv4('127.0.0.1/24'); // returns false\n     * net.isIPv4('fhqwhgads'); // returns false\n     * ```\n     * @since v0.3.0\n     */\n    function isIPv4(input: string): boolean;\n    /**\n     * Returns `true` if `input` is an IPv6 address. Otherwise, returns `false`.\n     *\n     * ```js\n     * net.isIPv6('::1'); // returns true\n     * net.isIPv6('fhqwhgads'); // returns false\n     * ```\n     * @since v0.3.0\n     */\n    function isIPv6(input: string): boolean;\n    interface SocketAddressInitOptions {\n        /**\n         * The network address as either an IPv4 or IPv6 string.\n         * @default 127.0.0.1\n         */\n        address?: string | undefined;\n        /**\n         * @default `'ipv4'`\n         */\n        family?: IPVersion | undefined;\n        /**\n         * An IPv6 flow-label used only if `family` is `'ipv6'`.\n         * @default 0\n         */\n        flowlabel?: number | undefined;\n        /**\n         * An IP port.\n         * @default 0\n         */\n        port?: number | undefined;\n    }\n    /**\n     * @since v15.14.0, v14.18.0\n     */\n    class SocketAddress {\n        constructor(options: SocketAddressInitOptions);\n        /**\n         * Either \\`'ipv4'\\` or \\`'ipv6'\\`.\n         * @since v15.14.0, v14.18.0\n         */\n        readonly address: string;\n        /**\n         * Either \\`'ipv4'\\` or \\`'ipv6'\\`.\n         * @since v15.14.0, v14.18.0\n         */\n        readonly family: IPVersion;\n        /**\n         * @since v15.14.0, v14.18.0\n         */\n        readonly port: number;\n        /**\n         * @since v15.14.0, v14.18.0\n         */\n        readonly flowlabel: number;\n        /**\n         * @since v22.13.0\n         * @param input An input string containing an IP address and optional port,\n         * e.g. `123.1.2.3:1234` or `[1::1]:1234`.\n         * @returns Returns a `SocketAddress` if parsing was successful.\n         * Otherwise returns `undefined`.\n         */\n        static parse(input: string): SocketAddress | undefined;\n    }\n}\ndeclare module \"node:net\" {\n    export * from \"net\";\n}\n"
        }
    ]
}