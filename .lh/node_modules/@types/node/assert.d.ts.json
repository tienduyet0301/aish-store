{
    "sourceFile": "node_modules/@types/node/assert.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891954689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:assert` module provides a set of assertion functions for verifying\n * invariants.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/assert.js)\n */\ndeclare module \"assert\" {\n    /**\n     * An alias of {@link ok}.\n     * @since v0.5.9\n     * @param value The input that is checked for being truthy.\n     */\n    function assert(value: unknown, message?: string | Error): asserts value;\n    namespace assert {\n        /**\n         * Indicates the failure of an assertion. All errors thrown by the `node:assert` module will be instances of the `AssertionError` class.\n         */\n        class AssertionError extends Error {\n            /**\n             * Set to the `actual` argument for methods such as {@link assert.strictEqual()}.\n             */\n            actual: unknown;\n            /**\n             * Set to the `expected` argument for methods such as {@link assert.strictEqual()}.\n             */\n            expected: unknown;\n            /**\n             * Set to the passed in operator value.\n             */\n            operator: string;\n            /**\n             * Indicates if the message was auto-generated (`true`) or not.\n             */\n            generatedMessage: boolean;\n            /**\n             * Value is always `ERR_ASSERTION` to show that the error is an assertion error.\n             */\n            code: \"ERR_ASSERTION\";\n            constructor(options?: {\n                /** If provided, the error message is set to this value. */\n                message?: string | undefined;\n                /** The `actual` property on the error instance. */\n                actual?: unknown | undefined;\n                /** The `expected` property on the error instance. */\n                expected?: unknown | undefined;\n                /** The `operator` property on the error instance. */\n                operator?: string | undefined;\n                /** If provided, the generated stack trace omits frames before this function. */\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n                stackStartFn?: Function | undefined;\n            });\n        }\n        /**\n         * This feature is deprecated and will be removed in a future version.\n         * Please consider using alternatives such as the `mock` helper function.\n         * @since v14.2.0, v12.19.0\n         * @deprecated Deprecated\n         */\n        class CallTracker {\n            /**\n             * The wrapper function is expected to be called exactly `exact` times. If the\n             * function has not been called exactly `exact` times when `tracker.verify()` is called, then `tracker.verify()` will throw an\n             * error.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * // Creates call tracker.\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             *\n             * // Returns a function that wraps func() that must be called exact times\n             * // before tracker.verify().\n             * const callsfunc = tracker.calls(func);\n             * ```\n             * @since v14.2.0, v12.19.0\n             * @param [fn='A no-op function']\n             * @param [exact=1]\n             * @return A function that wraps `fn`.\n             */\n            calls(exact?: number): () => void;\n            calls<Func extends (...args: any[]) => any>(fn?: Func, exact?: number): Func;\n            /**\n             * Example:\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             * const callsfunc = tracker.calls(func);\n             * callsfunc(1, 2, 3);\n             *\n             * assert.deepStrictEqual(tracker.getCalls(callsfunc),\n             *                        [{ thisArg: undefined, arguments: [1, 2, 3] }]);\n             * ```\n             * @since v18.8.0, v16.18.0\n             * @return An array with all the calls to a tracked function.\n             */\n            getCalls(fn: Function): CallTrackerCall[];\n            /**\n             * The arrays contains information about the expected and actual number of calls of\n             * the functions that have not been called the expected number of times.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * // Creates call tracker.\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             *\n             * // Returns a function that wraps func() that must be called exact times\n             * // before tracker.verify().\n             * const callsfunc = tracker.calls(func, 2);\n             *\n             * // Returns an array containing information on callsfunc()\n             * console.log(tracker.report());\n             * // [\n             * //  {\n             * //    message: 'Expected the func function to be executed 2 time(s) but was\n             * //    executed 0 time(s).',\n             * //    actual: 0,\n             * //    expected: 2,\n             * //    operator: 'func',\n             * //    stack: stack trace\n             * //  }\n             * // ]\n             * ```\n             * @since v14.2.0, v12.19.0\n             * @return An array of objects containing information about the wrapper functions returned by {@link tracker.calls()}.\n             */\n            report(): CallTrackerReportInformation[];\n            /**\n             * Reset calls of the call tracker. If a tracked function is passed as an argument, the calls will be reset for it.\n             * If no arguments are passed, all tracked functions will be reset.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             * const callsfunc = tracker.calls(func);\n             *\n             * callsfunc();\n             * // Tracker was called once\n             * assert.strictEqual(tracker.getCalls(callsfunc).length, 1);\n             *\n             * tracker.reset(callsfunc);\n             * assert.strictEqual(tracker.getCalls(callsfunc).length, 0);\n             * ```\n             * @since v18.8.0, v16.18.0\n             * @param fn a tracked function to reset.\n             */\n            reset(fn?: Function): void;\n            /**\n             * Iterates through the list of functions passed to {@link tracker.calls()} and will throw an error for functions that\n             * have not been called the expected number of times.\n             *\n             * ```js\n             * import assert from 'node:assert';\n             *\n             * // Creates call tracker.\n             * const tracker = new assert.CallTracker();\n             *\n             * function func() {}\n             *\n             * // Returns a function that wraps func() that must be called exact times\n             * // before tracker.verify().\n             * const callsfunc = tracker.calls(func, 2);\n             *\n             * callsfunc();\n             *\n             * // Will throw an error since callsfunc() was only called once.\n             * tracker.verify();\n             * ```\n             * @since v14.2.0, v12.19.0\n             */\n            verify(): void;\n        }\n        interface CallTrackerCall {\n            thisArg: object;\n            arguments: unknown[];\n        }\n        interface CallTrackerReportInformation {\n            message: string;\n            /** The actual number of times the function was called. */\n            actual: number;\n            /** The number of times the function was expected to be called. */\n            expected: number;\n            /** The name of the function that is wrapped. */\n            operator: string;\n            /** A stack trace of the function. */\n            stack: object;\n        }\n        type AssertPredicate = RegExp | (new() => object) | ((thrown: unknown) => boolean) | object | Error;\n        /**\n         * Throws an `AssertionError` with the provided error message or a default\n         * error message. If the `message` parameter is an instance of an `Error` then\n         * it will be thrown instead of the `AssertionError`.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.fail();\n         * // AssertionError [ERR_ASSERTION]: Failed\n         *\n         * assert.fail('boom');\n         * // AssertionError [ERR_ASSERTION]: boom\n         *\n         * assert.fail(new TypeError('need array'));\n         * // TypeError: need array\n         * ```\n         *\n         * Using `assert.fail()` with more than two arguments is possible but deprecated.\n         * See below for further details.\n         * @since v0.1.21\n         * @param [message='Failed']\n         */\n        function fail(message?: string | Error): never;\n        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */\n        function fail(\n            actual: unknown,\n            expected: unknown,\n            message?: string | Error,\n            operator?: string,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n            stackStartFn?: Function,\n        ): never;\n        /**\n         * Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.\n         *\n         * If `value` is not truthy, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is `undefined`, a default\n         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.\n         * If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.\n         *\n         * Be aware that in the `repl` the error message will be different to the one\n         * thrown in a file! See below for further details.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.ok(true);\n         * // OK\n         * assert.ok(1);\n         * // OK\n         *\n         * assert.ok();\n         * // AssertionError: No value argument passed to `assert.ok()`\n         *\n         * assert.ok(false, 'it\\'s false');\n         * // AssertionError: it's false\n         *\n         * // In the repl:\n         * assert.ok(typeof 123 === 'string');\n         * // AssertionError: false == true\n         *\n         * // In a file (e.g. test.js):\n         * assert.ok(typeof 123 === 'string');\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert.ok(typeof 123 === 'string')\n         *\n         * assert.ok(false);\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert.ok(false)\n         *\n         * assert.ok(0);\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert.ok(0)\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * // Using `assert()` works the same:\n         * assert(0);\n         * // AssertionError: The expression evaluated to a falsy value:\n         * //\n         * //   assert(0)\n         * ```\n         * @since v0.1.21\n         */\n        function ok(value: unknown, message?: string | Error): asserts value;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link strictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link strictEqual} instead.\n         *\n         * Tests shallow, coercive equality between the `actual` and `expected` parameters\n         * using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled\n         * and treated as being identical if both sides are `NaN`.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         *\n         * assert.equal(1, 1);\n         * // OK, 1 == 1\n         * assert.equal(1, '1');\n         * // OK, 1 == '1'\n         * assert.equal(NaN, NaN);\n         * // OK\n         *\n         * assert.equal(1, 2);\n         * // AssertionError: 1 == 2\n         * assert.equal({ a: { b: 1 } }, { a: { b: 1 } });\n         * // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }\n         * ```\n         *\n         * If the values are not equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default\n         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function equal(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link notStrictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link notStrictEqual} instead.\n         *\n         * Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is\n         * specially handled and treated as being identical if both sides are `NaN`.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         *\n         * assert.notEqual(1, 2);\n         * // OK\n         *\n         * assert.notEqual(1, 1);\n         * // AssertionError: 1 != 1\n         *\n         * assert.notEqual(1, '1');\n         * // AssertionError: 1 != '1'\n         * ```\n         *\n         * If the values are equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error\n         * message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function notEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link deepStrictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link deepStrictEqual} instead.\n         *\n         * Tests for deep equality between the `actual` and `expected` parameters. Consider\n         * using {@link deepStrictEqual} instead. {@link deepEqual} can have\n         * surprising results.\n         *\n         * _Deep equality_ means that the enumerable \"own\" properties of child objects\n         * are also recursively evaluated by the following rules.\n         * @since v0.1.21\n         */\n        function deepEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * **Strict assertion mode**\n         *\n         * An alias of {@link notDeepStrictEqual}.\n         *\n         * **Legacy assertion mode**\n         *\n         * > Stability: 3 - Legacy: Use {@link notDeepStrictEqual} instead.\n         *\n         * Tests for any deep inequality. Opposite of {@link deepEqual}.\n         *\n         * ```js\n         * import assert from 'node:assert';\n         *\n         * const obj1 = {\n         *   a: {\n         *     b: 1,\n         *   },\n         * };\n         * const obj2 = {\n         *   a: {\n         *     b: 2,\n         *   },\n         * };\n         * const obj3 = {\n         *   a: {\n         *     b: 1,\n         *   },\n         * };\n         * const obj4 = { __proto__: obj1 };\n         *\n         * assert.notDeepEqual(obj1, obj1);\n         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }\n         *\n         * assert.notDeepEqual(obj1, obj2);\n         * // OK\n         *\n         * assert.notDeepEqual(obj1, obj3);\n         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }\n         *\n         * assert.notDeepEqual(obj1, obj4);\n         * // OK\n         * ```\n         *\n         * If the values are deeply equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default\n         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function notDeepEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * Tests strict equality between the `actual` and `expected` parameters as\n         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.strictEqual(1, 2);\n         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:\n         * //\n         * // 1 !== 2\n         *\n         * assert.strictEqual(1, 1);\n         * // OK\n         *\n         * assert.strictEqual('Hello foobar', 'Hello World!');\n         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:\n         * // + actual - expected\n         * //\n         * // + 'Hello foobar'\n         * // - 'Hello World!'\n         * //          ^\n         *\n         * const apples = 1;\n         * const oranges = 2;\n         * assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);\n         * // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2\n         *\n         * assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));\n         * // TypeError: Inputs are not identical\n         * ```\n         *\n         * If the values are not strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a\n         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function strictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;\n        /**\n         * Tests strict inequality between the `actual` and `expected` parameters as\n         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.notStrictEqual(1, 2);\n         * // OK\n         *\n         * assert.notStrictEqual(1, 1);\n         * // AssertionError [ERR_ASSERTION]: Expected \"actual\" to be strictly unequal to:\n         * //\n         * // 1\n         *\n         * assert.notStrictEqual(1, '1');\n         * // OK\n         * ```\n         *\n         * If the values are strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a\n         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v0.1.21\n         */\n        function notStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * Tests for deep equality between the `actual` and `expected` parameters.\n         * \"Deep\" equality means that the enumerable \"own\" properties of child objects\n         * are recursively evaluated also by the following rules.\n         * @since v1.2.0\n         */\n        function deepStrictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;\n        /**\n         * Tests for deep strict inequality. Opposite of {@link deepStrictEqual}.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.notDeepStrictEqual({ a: 1 }, { a: '1' });\n         * // OK\n         * ```\n         *\n         * If the values are deeply and strictly equal, an `AssertionError` is thrown\n         * with a `message` property set equal to the value of the `message` parameter. If\n         * the `message` parameter is undefined, a default error message is assigned. If\n         * the `message` parameter is an instance of an `Error` then it will be thrown\n         * instead of the `AssertionError`.\n         * @since v1.2.0\n         */\n        function notDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * Expects the function `fn` to throw an error.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,\n         * a validation object where each property will be tested for strict deep equality,\n         * or an instance of error where each property will be tested for strict deep\n         * equality including the non-enumerable `message` and `name` properties. When\n         * using an object, it is also possible to use a regular expression, when\n         * validating against a string property. See below for examples.\n         *\n         * If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation\n         * fails.\n         *\n         * Custom validation object/error instance:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * const err = new TypeError('Wrong value');\n         * err.code = 404;\n         * err.foo = 'bar';\n         * err.info = {\n         *   nested: true,\n         *   baz: 'text',\n         * };\n         * err.reg = /abc/i;\n         *\n         * assert.throws(\n         *   () => {\n         *     throw err;\n         *   },\n         *   {\n         *     name: 'TypeError',\n         *     message: 'Wrong value',\n         *     info: {\n         *       nested: true,\n         *       baz: 'text',\n         *     },\n         *     // Only properties on the validation object will be tested for.\n         *     // Using nested objects requires all properties to be present. Otherwise\n         *     // the validation is going to fail.\n         *   },\n         * );\n         *\n         * // Using regular expressions to validate error properties:\n         * assert.throws(\n         *   () => {\n         *     throw err;\n         *   },\n         *   {\n         *     // The `name` and `message` properties are strings and using regular\n         *     // expressions on those will match against the string. If they fail, an\n         *     // error is thrown.\n         *     name: /^TypeError$/,\n         *     message: /Wrong/,\n         *     foo: 'bar',\n         *     info: {\n         *       nested: true,\n         *       // It is not possible to use regular expressions for nested properties!\n         *       baz: 'text',\n         *     },\n         *     // The `reg` property contains a regular expression and only if the\n         *     // validation object contains an identical regular expression, it is going\n         *     // to pass.\n         *     reg: /abc/i,\n         *   },\n         * );\n         *\n         * // Fails due to the different `message` and `name` properties:\n         * assert.throws(\n         *   () => {\n         *     const otherErr = new Error('Not found');\n         *     // Copy all enumerable properties from `err` to `otherErr`.\n         *     for (const [key, value] of Object.entries(err)) {\n         *       otherErr[key] = value;\n         *     }\n         *     throw otherErr;\n         *   },\n         *   // The error's `message` and `name` properties will also be checked when using\n         *   // an error as validation object.\n         *   err,\n         * );\n         * ```\n         *\n         * Validate instanceof using constructor:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.throws(\n         *   () => {\n         *     throw new Error('Wrong value');\n         *   },\n         *   Error,\n         * );\n         * ```\n         *\n         * Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):\n         *\n         * Using a regular expression runs `.toString` on the error object, and will\n         * therefore also include the error name.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.throws(\n         *   () => {\n         *     throw new Error('Wrong value');\n         *   },\n         *   /^Error: Wrong value$/,\n         * );\n         * ```\n         *\n         * Custom error validation:\n         *\n         * The function must return `true` to indicate all internal validations passed.\n         * It will otherwise fail with an `AssertionError`.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.throws(\n         *   () => {\n         *     throw new Error('Wrong value');\n         *   },\n         *   (err) => {\n         *     assert(err instanceof Error);\n         *     assert(/value/.test(err));\n         *     // Avoid returning anything from validation functions besides `true`.\n         *     // Otherwise, it's not clear what part of the validation failed. Instead,\n         *     // throw an error about the specific validation that failed (as done in this\n         *     // example) and add as much helpful debugging information to that error as\n         *     // possible.\n         *     return true;\n         *   },\n         *   'unexpected error',\n         * );\n         * ```\n         *\n         * `error` cannot be a string. If a string is provided as the second\n         * argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same\n         * message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using\n         * a string as the second argument gets considered:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * function throwingFirst() {\n         *   throw new Error('First');\n         * }\n         *\n         * function throwingSecond() {\n         *   throw new Error('Second');\n         * }\n         *\n         * function notThrowing() {}\n         *\n         * // The second argument is a string and the input function threw an Error.\n         * // The first case will not throw as it does not match for the error message\n         * // thrown by the input function!\n         * assert.throws(throwingFirst, 'Second');\n         * // In the next example the message has no benefit over the message from the\n         * // error and since it is not clear if the user intended to actually match\n         * // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.\n         * assert.throws(throwingSecond, 'Second');\n         * // TypeError [ERR_AMBIGUOUS_ARGUMENT]\n         *\n         * // The string is only used (as message) in case the function does not throw:\n         * assert.throws(notThrowing, 'Second');\n         * // AssertionError [ERR_ASSERTION]: Missing expected exception: Second\n         *\n         * // If it was intended to match for the error message do this instead:\n         * // It does not throw because the error messages match.\n         * assert.throws(throwingSecond, /Second$/);\n         *\n         * // If the error message does not match, an AssertionError is thrown.\n         * assert.throws(throwingFirst, /Second$/);\n         * // AssertionError [ERR_ASSERTION]\n         * ```\n         *\n         * Due to the confusing error-prone notation, avoid a string as the second\n         * argument.\n         * @since v0.1.21\n         */\n        function throws(block: () => unknown, message?: string | Error): void;\n        function throws(block: () => unknown, error: AssertPredicate, message?: string | Error): void;\n        /**\n         * Asserts that the function `fn` does not throw an error.\n         *\n         * Using `assert.doesNotThrow()` is actually not useful because there\n         * is no benefit in catching an error and then rethrowing it. Instead, consider\n         * adding a comment next to the specific code path that should not throw and keep\n         * error messages as expressive as possible.\n         *\n         * When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.\n         *\n         * If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a\n         * different type, or if the `error` parameter is undefined, the error is\n         * propagated back to the caller.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation\n         * function. See {@link throws} for more details.\n         *\n         * The following, for instance, will throw the `TypeError` because there is no\n         * matching error type in the assertion:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotThrow(\n         *   () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   SyntaxError,\n         * );\n         * ```\n         *\n         * However, the following will result in an `AssertionError` with the message\n         * 'Got unwanted exception...':\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotThrow(\n         *   () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   TypeError,\n         * );\n         * ```\n         *\n         * If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotThrow(\n         *   () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   /Wrong value/,\n         *   'Whoops',\n         * );\n         * // Throws: AssertionError: Got unwanted exception: Whoops\n         * ```\n         * @since v0.1.21\n         */\n        function doesNotThrow(block: () => unknown, message?: string | Error): void;\n        function doesNotThrow(block: () => unknown, error: AssertPredicate, message?: string | Error): void;\n        /**\n         * Throws `value` if `value` is not `undefined` or `null`. This is useful when\n         * testing the `error` argument in callbacks. The stack trace contains all frames\n         * from the error passed to `ifError()` including the potential new frames for `ifError()` itself.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.ifError(null);\n         * // OK\n         * assert.ifError(0);\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0\n         * assert.ifError('error');\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'\n         * assert.ifError(new Error());\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error\n         *\n         * // Create some random error frames.\n         * let err;\n         * (function errorFrame() {\n         *   err = new Error('test error');\n         * })();\n         *\n         * (function ifErrorFrame() {\n         *   assert.ifError(err);\n         * })();\n         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error\n         * //     at ifErrorFrame\n         * //     at errorFrame\n         * ```\n         * @since v0.1.97\n         */\n        function ifError(value: unknown): asserts value is null | undefined;\n        /**\n         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately\n         * calls the function and awaits the returned promise to complete. It will then\n         * check that the promise is rejected.\n         *\n         * If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the\n         * function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v22.x/api/errors.html#err_invalid_return_value)\n         * error. In both cases the error handler is skipped.\n         *\n         * Besides the async nature to await the completion behaves identically to {@link throws}.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,\n         * an object where each property will be tested for, or an instance of error where\n         * each property will be tested for including the non-enumerable `message` and `name` properties.\n         *\n         * If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * await assert.rejects(\n         *   async () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   {\n         *     name: 'TypeError',\n         *     message: 'Wrong value',\n         *   },\n         * );\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * await assert.rejects(\n         *   async () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   (err) => {\n         *     assert.strictEqual(err.name, 'TypeError');\n         *     assert.strictEqual(err.message, 'Wrong value');\n         *     return true;\n         *   },\n         * );\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.rejects(\n         *   Promise.reject(new Error('Wrong value')),\n         *   Error,\n         * ).then(() => {\n         *   // ...\n         * });\n         * ```\n         *\n         * `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to\n         * be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the\n         * example in {@link throws} carefully if using a string as the second argument gets considered.\n         * @since v10.0.0\n         */\n        function rejects(block: (() => Promise<unknown>) | Promise<unknown>, message?: string | Error): Promise<void>;\n        function rejects(\n            block: (() => Promise<unknown>) | Promise<unknown>,\n            error: AssertPredicate,\n            message?: string | Error,\n        ): Promise<void>;\n        /**\n         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately\n         * calls the function and awaits the returned promise to complete. It will then\n         * check that the promise is not rejected.\n         *\n         * If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If\n         * the function does not return a promise, `assert.doesNotReject()` will return a\n         * rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v22.x/api/errors.html#err_invalid_return_value) error. In both cases\n         * the error handler is skipped.\n         *\n         * Using `assert.doesNotReject()` is actually not useful because there is little\n         * benefit in catching a rejection and then rejecting it again. Instead, consider\n         * adding a comment next to the specific code path that should not reject and keep\n         * error messages as expressive as possible.\n         *\n         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),\n         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation\n         * function. See {@link throws} for more details.\n         *\n         * Besides the async nature to await the completion behaves identically to {@link doesNotThrow}.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * await assert.doesNotReject(\n         *   async () => {\n         *     throw new TypeError('Wrong value');\n         *   },\n         *   SyntaxError,\n         * );\n         * ```\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))\n         *   .then(() => {\n         *     // ...\n         *   });\n         * ```\n         * @since v10.0.0\n         */\n        function doesNotReject(\n            block: (() => Promise<unknown>) | Promise<unknown>,\n            message?: string | Error,\n        ): Promise<void>;\n        function doesNotReject(\n            block: (() => Promise<unknown>) | Promise<unknown>,\n            error: AssertPredicate,\n            message?: string | Error,\n        ): Promise<void>;\n        /**\n         * Expects the `string` input to match the regular expression.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.match('I will fail', /pass/);\n         * // AssertionError [ERR_ASSERTION]: The input did not match the regular ...\n         *\n         * assert.match(123, /pass/);\n         * // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string.\n         *\n         * assert.match('I will pass', /pass/);\n         * // OK\n         * ```\n         *\n         * If the values do not match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal\n         * to the value of the `message` parameter. If the `message` parameter is\n         * undefined, a default error message is assigned. If the `message` parameter is an\n         * instance of an [Error](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.\n         * @since v13.6.0, v12.16.0\n         */\n        function match(value: string, regExp: RegExp, message?: string | Error): void;\n        /**\n         * Expects the `string` input not to match the regular expression.\n         *\n         * ```js\n         * import assert from 'node:assert/strict';\n         *\n         * assert.doesNotMatch('I will fail', /fail/);\n         * // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...\n         *\n         * assert.doesNotMatch(123, /pass/);\n         * // AssertionError [ERR_ASSERTION]: The \"string\" argument must be of type string.\n         *\n         * assert.doesNotMatch('I will pass', /different/);\n         * // OK\n         * ```\n         *\n         * If the values do match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal\n         * to the value of the `message` parameter. If the `message` parameter is\n         * undefined, a default error message is assigned. If the `message` parameter is an\n         * instance of an [Error](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.\n         * @since v13.6.0, v12.16.0\n         */\n        function doesNotMatch(value: string, regExp: RegExp, message?: string | Error): void;\n        /**\n         * Tests for partial deep equality between the `actual` and `expected` parameters.\n         * \"Deep\" equality means that the enumerable \"own\" properties of child objects\n         * are recursively evaluated also by the following rules. \"Partial\" equality means\n         * that only properties that exist on the `expected` parameter are going to be\n         * compared.\n         *\n         * This method always passes the same test cases as `assert.deepStrictEqual()`,\n         * behaving as a super set of it.\n         * @since v22.13.0\n         */\n        function partialDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;\n        /**\n         * In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example,\n         * {@link deepEqual} will behave like {@link deepStrictEqual}.\n         *\n         * In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error\n         * messages for objects display the objects, often truncated.\n         *\n         * To use strict assertion mode:\n         *\n         * ```js\n         * import { strict as assert } from 'node:assert';\n         * import assert from 'node:assert/strict';\n         * ```\n         *\n         * Example error diff:\n         *\n         * ```js\n         * import { strict as assert } from 'node:assert';\n         *\n         * assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]);\n         * // AssertionError: Expected inputs to be strictly deep-equal:\n         * // + actual - expected ... Lines skipped\n         * //\n         * //   [\n         * //     [\n         * // ...\n         * //       2,\n         * // +     3\n         * // -     '3'\n         * //     ],\n         * // ...\n         * //     5\n         * //   ]\n         * ```\n         *\n         * To deactivate the colors, use the `NO_COLOR` or `NODE_DISABLE_COLORS` environment variables. This will also\n         * deactivate the colors in the REPL. For more on color support in terminal environments, read the tty\n         * `getColorDepth()` documentation.\n         *\n         * @since v15.0.0, v13.9.0, v12.16.2, v9.9.0\n         */\n        namespace strict {\n            type AssertionError = assert.AssertionError;\n            type AssertPredicate = assert.AssertPredicate;\n            type CallTrackerCall = assert.CallTrackerCall;\n            type CallTrackerReportInformation = assert.CallTrackerReportInformation;\n        }\n        const strict:\n            & Omit<\n                typeof assert,\n                | \"equal\"\n                | \"notEqual\"\n                | \"deepEqual\"\n                | \"notDeepEqual\"\n                | \"ok\"\n                | \"strictEqual\"\n                | \"deepStrictEqual\"\n                | \"ifError\"\n                | \"strict\"\n                | \"AssertionError\"\n            >\n            & {\n                (value: unknown, message?: string | Error): asserts value;\n                equal: typeof strictEqual;\n                notEqual: typeof notStrictEqual;\n                deepEqual: typeof deepStrictEqual;\n                notDeepEqual: typeof notDeepStrictEqual;\n                // Mapped types and assertion functions are incompatible?\n                // TS2775: Assertions require every name in the call target\n                // to be declared with an explicit type annotation.\n                ok: typeof ok;\n                strictEqual: typeof strictEqual;\n                deepStrictEqual: typeof deepStrictEqual;\n                ifError: typeof ifError;\n                strict: typeof strict;\n                AssertionError: typeof AssertionError;\n            };\n    }\n    export = assert;\n}\ndeclare module \"node:assert\" {\n    import assert = require(\"assert\");\n    export = assert;\n}\n"
        }
    ]
}