{
    "sourceFile": "node_modules/@types/node/tty.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:tty` module provides the `tty.ReadStream` and `tty.WriteStream` classes. In most cases, it will not be necessary or possible to use this module\n * directly. However, it can be accessed using:\n *\n * ```js\n * import tty from 'node:tty';\n * ```\n *\n * When Node.js detects that it is being run with a text terminal (\"TTY\")\n * attached, `process.stdin` will, by default, be initialized as an instance of `tty.ReadStream` and both `process.stdout` and `process.stderr` will, by\n * default, be instances of `tty.WriteStream`. The preferred method of determining\n * whether Node.js is being run within a TTY context is to check that the value of\n * the `process.stdout.isTTY` property is `true`:\n *\n * ```console\n * $ node -p -e \"Boolean(process.stdout.isTTY)\"\n * true\n * $ node -p -e \"Boolean(process.stdout.isTTY)\" | cat\n * false\n * ```\n *\n * In most cases, there should be little to no reason for an application to\n * manually create instances of the `tty.ReadStream` and `tty.WriteStream` classes.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/tty.js)\n */\ndeclare module \"tty\" {\n    import * as net from \"node:net\";\n    /**\n     * The `tty.isatty()` method returns `true` if the given `fd` is associated with\n     * a TTY and `false` if it is not, including whenever `fd` is not a non-negative\n     * integer.\n     * @since v0.5.8\n     * @param fd A numeric file descriptor\n     */\n    function isatty(fd: number): boolean;\n    /**\n     * Represents the readable side of a TTY. In normal circumstances `process.stdin` will be the only `tty.ReadStream` instance in a Node.js\n     * process and there should be no reason to create additional instances.\n     * @since v0.5.8\n     */\n    class ReadStream extends net.Socket {\n        constructor(fd: number, options?: net.SocketConstructorOpts);\n        /**\n         * A `boolean` that is `true` if the TTY is currently configured to operate as a\n         * raw device.\n         *\n         * This flag is always `false` when a process starts, even if the terminal is\n         * operating in raw mode. Its value will change with subsequent calls to `setRawMode`.\n         * @since v0.7.7\n         */\n        isRaw: boolean;\n        /**\n         * Allows configuration of `tty.ReadStream` so that it operates as a raw device.\n         *\n         * When in raw mode, input is always available character-by-character, not\n         * including modifiers. Additionally, all special processing of characters by the\n         * terminal is disabled, including echoing input\n         * characters. Ctrl+C will no longer cause a `SIGINT` when\n         * in this mode.\n         * @since v0.7.7\n         * @param mode If `true`, configures the `tty.ReadStream` to operate as a raw device. If `false`, configures the `tty.ReadStream` to operate in its default mode. The `readStream.isRaw`\n         * property will be set to the resulting mode.\n         * @return The read stream instance.\n         */\n        setRawMode(mode: boolean): this;\n        /**\n         * A `boolean` that is always `true` for `tty.ReadStream` instances.\n         * @since v0.5.8\n         */\n        isTTY: boolean;\n    }\n    /**\n     * -1 - to the left from cursor\n     *  0 - the entire line\n     *  1 - to the right from cursor\n     */\n    type Direction = -1 | 0 | 1;\n    /**\n     * Represents the writable side of a TTY. In normal circumstances, `process.stdout` and `process.stderr` will be the only`tty.WriteStream` instances created for a Node.js process and there\n     * should be no reason to create additional instances.\n     * @since v0.5.8\n     */\n    class WriteStream extends net.Socket {\n        constructor(fd: number);\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"resize\", listener: () => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"resize\"): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"resize\", listener: () => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"resize\", listener: () => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"resize\", listener: () => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"resize\", listener: () => void): this;\n        /**\n         * `writeStream.clearLine()` clears the current line of this `WriteStream` in a\n         * direction identified by `dir`.\n         * @since v0.7.7\n         * @param callback Invoked once the operation completes.\n         * @return `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n         */\n        clearLine(dir: Direction, callback?: () => void): boolean;\n        /**\n         * `writeStream.clearScreenDown()` clears this `WriteStream` from the current\n         * cursor down.\n         * @since v0.7.7\n         * @param callback Invoked once the operation completes.\n         * @return `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n         */\n        clearScreenDown(callback?: () => void): boolean;\n        /**\n         * `writeStream.cursorTo()` moves this `WriteStream`'s cursor to the specified\n         * position.\n         * @since v0.7.7\n         * @param callback Invoked once the operation completes.\n         * @return `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n         */\n        cursorTo(x: number, y?: number, callback?: () => void): boolean;\n        cursorTo(x: number, callback: () => void): boolean;\n        /**\n         * `writeStream.moveCursor()` moves this `WriteStream`'s cursor _relative_ to its\n         * current position.\n         * @since v0.7.7\n         * @param callback Invoked once the operation completes.\n         * @return `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.\n         */\n        moveCursor(dx: number, dy: number, callback?: () => void): boolean;\n        /**\n         * Returns:\n         *\n         * * `1` for 2,\n         * * `4` for 16,\n         * * `8` for 256,\n         * * `24` for 16,777,216 colors supported.\n         *\n         * Use this to determine what colors the terminal supports. Due to the nature of\n         * colors in terminals it is possible to either have false positives or false\n         * negatives. It depends on process information and the environment variables that\n         * may lie about what terminal is used.\n         * It is possible to pass in an `env` object to simulate the usage of a specific\n         * terminal. This can be useful to check how specific environment settings behave.\n         *\n         * To enforce a specific color support, use one of the below environment settings.\n         *\n         * * 2 colors: `FORCE_COLOR = 0` (Disables colors)\n         * * 16 colors: `FORCE_COLOR = 1`\n         * * 256 colors: `FORCE_COLOR = 2`\n         * * 16,777,216 colors: `FORCE_COLOR = 3`\n         *\n         * Disabling color support is also possible by using the `NO_COLOR` and `NODE_DISABLE_COLORS` environment variables.\n         * @since v9.9.0\n         * @param [env=process.env] An object containing the environment variables to check. This enables simulating the usage of a specific terminal.\n         */\n        getColorDepth(env?: object): number;\n        /**\n         * Returns `true` if the `writeStream` supports at least as many colors as provided\n         * in `count`. Minimum support is 2 (black and white).\n         *\n         * This has the same false positives and negatives as described in `writeStream.getColorDepth()`.\n         *\n         * ```js\n         * process.stdout.hasColors();\n         * // Returns true or false depending on if `stdout` supports at least 16 colors.\n         * process.stdout.hasColors(256);\n         * // Returns true or false depending on if `stdout` supports at least 256 colors.\n         * process.stdout.hasColors({ TMUX: '1' });\n         * // Returns true.\n         * process.stdout.hasColors(2 ** 24, { TMUX: '1' });\n         * // Returns false (the environment setting pretends to support 2 ** 8 colors).\n         * ```\n         * @since v11.13.0, v10.16.0\n         * @param [count=16] The number of colors that are requested (minimum 2).\n         * @param [env=process.env] An object containing the environment variables to check. This enables simulating the usage of a specific terminal.\n         */\n        hasColors(count?: number): boolean;\n        hasColors(env?: object): boolean;\n        hasColors(count: number, env?: object): boolean;\n        /**\n         * `writeStream.getWindowSize()` returns the size of the TTY\n         * corresponding to this `WriteStream`. The array is of the type `[numColumns, numRows]` where `numColumns` and `numRows` represent the number\n         * of columns and rows in the corresponding TTY.\n         * @since v0.7.7\n         */\n        getWindowSize(): [number, number];\n        /**\n         * A `number` specifying the number of columns the TTY currently has. This property\n         * is updated whenever the `'resize'` event is emitted.\n         * @since v0.7.7\n         */\n        columns: number;\n        /**\n         * A `number` specifying the number of rows the TTY currently has. This property\n         * is updated whenever the `'resize'` event is emitted.\n         * @since v0.7.7\n         */\n        rows: number;\n        /**\n         * A `boolean` that is always `true`.\n         * @since v0.5.8\n         */\n        isTTY: boolean;\n    }\n}\ndeclare module \"node:tty\" {\n    export * from \"tty\";\n}\n"
        }
    ]
}