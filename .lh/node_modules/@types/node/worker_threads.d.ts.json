{
    "sourceFile": "node_modules/@types/node/worker_threads.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:worker_threads` module enables the use of threads that execute\n * JavaScript in parallel. To access it:\n *\n * ```js\n * import worker from 'node:worker_threads';\n * ```\n *\n * Workers (threads) are useful for performing CPU-intensive JavaScript operations.\n * They do not help much with I/O-intensive work. The Node.js built-in\n * asynchronous I/O operations are more efficient than Workers can be.\n *\n * Unlike `child_process` or `cluster`, `worker_threads` can share memory. They do\n * so by transferring `ArrayBuffer` instances or sharing `SharedArrayBuffer` instances.\n *\n * ```js\n * import {\n *   Worker, isMainThread, parentPort, workerData,\n * } from 'node:worker_threads';\n * import { parse } from 'some-js-parsing-library';\n *\n * if (isMainThread) {\n *   module.exports = function parseJSAsync(script) {\n *     return new Promise((resolve, reject) => {\n *       const worker = new Worker(__filename, {\n *         workerData: script,\n *       });\n *       worker.on('message', resolve);\n *       worker.on('error', reject);\n *       worker.on('exit', (code) => {\n *         if (code !== 0)\n *           reject(new Error(`Worker stopped with exit code ${code}`));\n *       });\n *     });\n *   };\n * } else {\n *   const script = workerData;\n *   parentPort.postMessage(parse(script));\n * }\n * ```\n *\n * The above example spawns a Worker thread for each `parseJSAsync()` call. In\n * practice, use a pool of Workers for these kinds of tasks. Otherwise, the\n * overhead of creating Workers would likely exceed their benefit.\n *\n * When implementing a worker pool, use the `AsyncResource` API to inform\n * diagnostic tools (e.g. to provide asynchronous stack traces) about the\n * correlation between tasks and their outcomes. See `\"Using AsyncResource for a Worker thread pool\"` in the `async_hooks` documentation for an example implementation.\n *\n * Worker threads inherit non-process-specific options by default. Refer to `Worker constructor options` to know how to customize worker thread options,\n * specifically `argv` and `execArgv` options.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/worker_threads.js)\n */\ndeclare module \"worker_threads\" {\n    import { Blob } from \"node:buffer\";\n    import { Context } from \"node:vm\";\n    import { EventEmitter } from \"node:events\";\n    import { EventLoopUtilityFunction } from \"node:perf_hooks\";\n    import { FileHandle } from \"node:fs/promises\";\n    import { Readable, Writable } from \"node:stream\";\n    import { URL } from \"node:url\";\n    import { X509Certificate } from \"node:crypto\";\n    const isInternalThread: boolean;\n    const isMainThread: boolean;\n    const parentPort: null | MessagePort;\n    const resourceLimits: ResourceLimits;\n    const SHARE_ENV: unique symbol;\n    const threadId: number;\n    const workerData: any;\n    /**\n     * Instances of the `worker.MessageChannel` class represent an asynchronous,\n     * two-way communications channel.\n     * The `MessageChannel` has no methods of its own. `new MessageChannel()` yields an object with `port1` and `port2` properties, which refer to linked `MessagePort` instances.\n     *\n     * ```js\n     * import { MessageChannel } from 'node:worker_threads';\n     *\n     * const { port1, port2 } = new MessageChannel();\n     * port1.on('message', (message) => console.log('received', message));\n     * port2.postMessage({ foo: 'bar' });\n     * // Prints: received { foo: 'bar' } from the `port1.on('message')` listener\n     * ```\n     * @since v10.5.0\n     */\n    class MessageChannel {\n        readonly port1: MessagePort;\n        readonly port2: MessagePort;\n    }\n    interface WorkerPerformance {\n        eventLoopUtilization: EventLoopUtilityFunction;\n    }\n    type TransferListItem = ArrayBuffer | MessagePort | FileHandle | X509Certificate | Blob;\n    /**\n     * Instances of the `worker.MessagePort` class represent one end of an\n     * asynchronous, two-way communications channel. It can be used to transfer\n     * structured data, memory regions and other `MessagePort`s between different `Worker`s.\n     *\n     * This implementation matches [browser `MessagePort`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort) s.\n     * @since v10.5.0\n     */\n    class MessagePort extends EventEmitter {\n        /**\n         * Disables further sending of messages on either side of the connection.\n         * This method can be called when no further communication will happen over this `MessagePort`.\n         *\n         * The `'close' event` is emitted on both `MessagePort` instances that\n         * are part of the channel.\n         * @since v10.5.0\n         */\n        close(): void;\n        /**\n         * Sends a JavaScript value to the receiving side of this channel. `value` is transferred in a way which is compatible with\n         * the [HTML structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).\n         *\n         * In particular, the significant differences to `JSON` are:\n         *\n         * * `value` may contain circular references.\n         * * `value` may contain instances of builtin JS types such as `RegExp`s, `BigInt`s, `Map`s, `Set`s, etc.\n         * * `value` may contain typed arrays, both using `ArrayBuffer`s\n         * and `SharedArrayBuffer`s.\n         * * `value` may contain [`WebAssembly.Module`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module) instances.\n         * * `value` may not contain native (C++-backed) objects other than:\n         *\n         * ```js\n         * import { MessageChannel } from 'node:worker_threads';\n         * const { port1, port2 } = new MessageChannel();\n         *\n         * port1.on('message', (message) => console.log(message));\n         *\n         * const circularData = {};\n         * circularData.foo = circularData;\n         * // Prints: { foo: [Circular] }\n         * port2.postMessage(circularData);\n         * ```\n         *\n         * `transferList` may be a list of [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), `MessagePort`, and `FileHandle` objects.\n         * After transferring, they are not usable on the sending side of the channel\n         * anymore (even if they are not contained in `value`). Unlike with `child processes`, transferring handles such as network sockets is currently\n         * not supported.\n         *\n         * If `value` contains [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instances, those are accessible\n         * from either thread. They cannot be listed in `transferList`.\n         *\n         * `value` may still contain `ArrayBuffer` instances that are not in `transferList`; in that case, the underlying memory is copied rather than moved.\n         *\n         * ```js\n         * import { MessageChannel } from 'node:worker_threads';\n         * const { port1, port2 } = new MessageChannel();\n         *\n         * port1.on('message', (message) => console.log(message));\n         *\n         * const uint8Array = new Uint8Array([ 1, 2, 3, 4 ]);\n         * // This posts a copy of `uint8Array`:\n         * port2.postMessage(uint8Array);\n         * // This does not copy data, but renders `uint8Array` unusable:\n         * port2.postMessage(uint8Array, [ uint8Array.buffer ]);\n         *\n         * // The memory for the `sharedUint8Array` is accessible from both the\n         * // original and the copy received by `.on('message')`:\n         * const sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));\n         * port2.postMessage(sharedUint8Array);\n         *\n         * // This transfers a freshly created message port to the receiver.\n         * // This can be used, for example, to create communication channels between\n         * // multiple `Worker` threads that are children of the same parent thread.\n         * const otherChannel = new MessageChannel();\n         * port2.postMessage({ port: otherChannel.port1 }, [ otherChannel.port1 ]);\n         * ```\n         *\n         * The message object is cloned immediately, and can be modified after\n         * posting without having side effects.\n         *\n         * For more information on the serialization and deserialization mechanisms\n         * behind this API, see the `serialization API of the node:v8 module`.\n         * @since v10.5.0\n         */\n        postMessage(value: any, transferList?: readonly TransferListItem[]): void;\n        /**\n         * Opposite of `unref()`. Calling `ref()` on a previously `unref()`ed port does _not_ let the program exit if it's the only active handle left (the default\n         * behavior). If the port is `ref()`ed, calling `ref()` again has no effect.\n         *\n         * If listeners are attached or removed using `.on('message')`, the port\n         * is `ref()`ed and `unref()`ed automatically depending on whether\n         * listeners for the event exist.\n         * @since v10.5.0\n         */\n        ref(): void;\n        /**\n         * Calling `unref()` on a port allows the thread to exit if this is the only\n         * active handle in the event system. If the port is already `unref()`ed calling `unref()` again has no effect.\n         *\n         * If listeners are attached or removed using `.on('message')`, the port is `ref()`ed and `unref()`ed automatically depending on whether\n         * listeners for the event exist.\n         * @since v10.5.0\n         */\n        unref(): void;\n        /**\n         * Starts receiving messages on this `MessagePort`. When using this port\n         * as an event emitter, this is called automatically once `'message'` listeners are attached.\n         *\n         * This method exists for parity with the Web `MessagePort` API. In Node.js,\n         * it is only useful for ignoring messages when no event listener is present.\n         * Node.js also diverges in its handling of `.onmessage`. Setting it\n         * automatically calls `.start()`, but unsetting it lets messages queue up\n         * until a new handler is set or the port is discarded.\n         * @since v10.5.0\n         */\n        start(): void;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"message\", listener: (value: any) => void): this;\n        addListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"close\"): boolean;\n        emit(event: \"message\", value: any): boolean;\n        emit(event: \"messageerror\", error: Error): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"message\", listener: (value: any) => void): this;\n        on(event: \"messageerror\", listener: (error: Error) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"message\", listener: (value: any) => void): this;\n        once(event: \"messageerror\", listener: (error: Error) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"message\", listener: (value: any) => void): this;\n        prependListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"message\", listener: (value: any) => void): this;\n        prependOnceListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: \"close\", listener: () => void): this;\n        removeListener(event: \"message\", listener: (value: any) => void): this;\n        removeListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        off(event: \"close\", listener: () => void): this;\n        off(event: \"message\", listener: (value: any) => void): this;\n        off(event: \"messageerror\", listener: (error: Error) => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n        addEventListener: EventTarget[\"addEventListener\"];\n        dispatchEvent: EventTarget[\"dispatchEvent\"];\n        removeEventListener: EventTarget[\"removeEventListener\"];\n    }\n    interface WorkerOptions {\n        /**\n         * List of arguments which would be stringified and appended to\n         * `process.argv` in the worker. This is mostly similar to the `workerData`\n         * but the values will be available on the global `process.argv` as if they\n         * were passed as CLI options to the script.\n         */\n        argv?: any[] | undefined;\n        env?: NodeJS.Dict<string> | typeof SHARE_ENV | undefined;\n        eval?: boolean | undefined;\n        workerData?: any;\n        stdin?: boolean | undefined;\n        stdout?: boolean | undefined;\n        stderr?: boolean | undefined;\n        execArgv?: string[] | undefined;\n        resourceLimits?: ResourceLimits | undefined;\n        /**\n         * Additional data to send in the first worker message.\n         */\n        transferList?: TransferListItem[] | undefined;\n        /**\n         * @default true\n         */\n        trackUnmanagedFds?: boolean | undefined;\n        /**\n         * An optional `name` to be appended to the worker title\n         * for debugging/identification purposes, making the final title as\n         * `[worker ${id}] ${name}`.\n         */\n        name?: string | undefined;\n    }\n    interface ResourceLimits {\n        /**\n         * The maximum size of a heap space for recently created objects.\n         */\n        maxYoungGenerationSizeMb?: number | undefined;\n        /**\n         * The maximum size of the main heap in MB.\n         */\n        maxOldGenerationSizeMb?: number | undefined;\n        /**\n         * The size of a pre-allocated memory range used for generated code.\n         */\n        codeRangeSizeMb?: number | undefined;\n        /**\n         * The default maximum stack size for the thread. Small values may lead to unusable Worker instances.\n         * @default 4\n         */\n        stackSizeMb?: number | undefined;\n    }\n    /**\n     * The `Worker` class represents an independent JavaScript execution thread.\n     * Most Node.js APIs are available inside of it.\n     *\n     * Notable differences inside a Worker environment are:\n     *\n     * * The `process.stdin`, `process.stdout`, and `process.stderr` streams may be redirected by the parent thread.\n     * * The `import { isMainThread } from 'node:worker_threads'` variable is set to `false`.\n     * * The `import { parentPort } from 'node:worker_threads'` message port is available.\n     * * `process.exit()` does not stop the whole program, just the single thread,\n     * and `process.abort()` is not available.\n     * * `process.chdir()` and `process` methods that set group or user ids\n     * are not available.\n     * * `process.env` is a copy of the parent thread's environment variables,\n     * unless otherwise specified. Changes to one copy are not visible in other\n     * threads, and are not visible to native add-ons (unless `worker.SHARE_ENV` is passed as the `env` option to the `Worker` constructor). On Windows, unlike the main thread, a copy of the\n     * environment variables operates in a case-sensitive manner.\n     * * `process.title` cannot be modified.\n     * * Signals are not delivered through `process.on('...')`.\n     * * Execution may stop at any point as a result of `worker.terminate()` being invoked.\n     * * IPC channels from parent processes are not accessible.\n     * * The `trace_events` module is not supported.\n     * * Native add-ons can only be loaded from multiple threads if they fulfill `certain conditions`.\n     *\n     * Creating `Worker` instances inside of other `Worker`s is possible.\n     *\n     * Like [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) and the `node:cluster module`, two-way communication\n     * can be achieved through inter-thread message passing. Internally, a `Worker` has\n     * a built-in pair of `MessagePort` s that are already associated with each\n     * other when the `Worker` is created. While the `MessagePort` object on the parent\n     * side is not directly exposed, its functionalities are exposed through `worker.postMessage()` and the `worker.on('message')` event\n     * on the `Worker` object for the parent thread.\n     *\n     * To create custom messaging channels (which is encouraged over using the default\n     * global channel because it facilitates separation of concerns), users can create\n     * a `MessageChannel` object on either thread and pass one of the`MessagePort`s on that `MessageChannel` to the other thread through a\n     * pre-existing channel, such as the global one.\n     *\n     * See `port.postMessage()` for more information on how messages are passed,\n     * and what kind of JavaScript values can be successfully transported through\n     * the thread barrier.\n     *\n     * ```js\n     * import assert from 'node:assert';\n     * import {\n     *   Worker, MessageChannel, MessagePort, isMainThread, parentPort,\n     * } from 'node:worker_threads';\n     * if (isMainThread) {\n     *   const worker = new Worker(__filename);\n     *   const subChannel = new MessageChannel();\n     *   worker.postMessage({ hereIsYourPort: subChannel.port1 }, [subChannel.port1]);\n     *   subChannel.port2.on('message', (value) => {\n     *     console.log('received:', value);\n     *   });\n     * } else {\n     *   parentPort.once('message', (value) => {\n     *     assert(value.hereIsYourPort instanceof MessagePort);\n     *     value.hereIsYourPort.postMessage('the worker is sending this');\n     *     value.hereIsYourPort.close();\n     *   });\n     * }\n     * ```\n     * @since v10.5.0\n     */\n    class Worker extends EventEmitter {\n        /**\n         * If `stdin: true` was passed to the `Worker` constructor, this is a\n         * writable stream. The data written to this stream will be made available in\n         * the worker thread as `process.stdin`.\n         * @since v10.5.0\n         */\n        readonly stdin: Writable | null;\n        /**\n         * This is a readable stream which contains data written to `process.stdout` inside the worker thread. If `stdout: true` was not passed to the `Worker` constructor, then data is piped to the\n         * parent thread's `process.stdout` stream.\n         * @since v10.5.0\n         */\n        readonly stdout: Readable;\n        /**\n         * This is a readable stream which contains data written to `process.stderr` inside the worker thread. If `stderr: true` was not passed to the `Worker` constructor, then data is piped to the\n         * parent thread's `process.stderr` stream.\n         * @since v10.5.0\n         */\n        readonly stderr: Readable;\n        /**\n         * An integer identifier for the referenced thread. Inside the worker thread,\n         * it is available as `import { threadId } from 'node:worker_threads'`.\n         * This value is unique for each `Worker` instance inside a single process.\n         * @since v10.5.0\n         */\n        readonly threadId: number;\n        /**\n         * Provides the set of JS engine resource constraints for this Worker thread.\n         * If the `resourceLimits` option was passed to the `Worker` constructor,\n         * this matches its values.\n         *\n         * If the worker has stopped, the return value is an empty object.\n         * @since v13.2.0, v12.16.0\n         */\n        readonly resourceLimits?: ResourceLimits | undefined;\n        /**\n         * An object that can be used to query performance information from a worker\n         * instance. Similar to `perf_hooks.performance`.\n         * @since v15.1.0, v14.17.0, v12.22.0\n         */\n        readonly performance: WorkerPerformance;\n        /**\n         * @param filename  The path to the Worker’s main script or module.\n         *                  Must be either an absolute path or a relative path (i.e. relative to the current working directory) starting with ./ or ../,\n         *                  or a WHATWG URL object using file: protocol. If options.eval is true, this is a string containing JavaScript code rather than a path.\n         */\n        constructor(filename: string | URL, options?: WorkerOptions);\n        /**\n         * Send a message to the worker that is received via `require('node:worker_threads').parentPort.on('message')`.\n         * See `port.postMessage()` for more details.\n         * @since v10.5.0\n         */\n        postMessage(value: any, transferList?: readonly TransferListItem[]): void;\n        /**\n         * Sends a value to another worker, identified by its thread ID.\n         * @param threadId The target thread ID. If the thread ID is invalid, a `ERR_WORKER_MESSAGING_FAILED` error will be thrown.\n         * If the target thread ID is the current thread ID, a `ERR_WORKER_MESSAGING_SAME_THREAD` error will be thrown.\n         * @param value The value to send.\n         * @param transferList If one or more `MessagePort`-like objects are passed in value, a `transferList` is required for those items\n         * or `ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST` is thrown. See `port.postMessage()` for more information.\n         * @param timeout Time to wait for the message to be delivered in milliseconds. By default it's `undefined`, which means wait forever.\n         * If the operation times out, a `ERR_WORKER_MESSAGING_TIMEOUT` error is thrown.\n         * @since v22.5.0\n         */\n        postMessageToThread(threadId: number, value: any, timeout?: number): Promise<void>;\n        postMessageToThread(\n            threadId: number,\n            value: any,\n            transferList: readonly TransferListItem[],\n            timeout?: number,\n        ): Promise<void>;\n        /**\n         * Opposite of `unref()`, calling `ref()` on a previously `unref()`ed worker does _not_ let the program exit if it's the only active handle left (the default\n         * behavior). If the worker is `ref()`ed, calling `ref()` again has\n         * no effect.\n         * @since v10.5.0\n         */\n        ref(): void;\n        /**\n         * Calling `unref()` on a worker allows the thread to exit if this is the only\n         * active handle in the event system. If the worker is already `unref()`ed calling `unref()` again has no effect.\n         * @since v10.5.0\n         */\n        unref(): void;\n        /**\n         * Stop all JavaScript execution in the worker thread as soon as possible.\n         * Returns a Promise for the exit code that is fulfilled when the `'exit' event` is emitted.\n         * @since v10.5.0\n         */\n        terminate(): Promise<number>;\n        /**\n         * Returns a readable stream for a V8 snapshot of the current state of the Worker.\n         * See `v8.getHeapSnapshot()` for more details.\n         *\n         * If the Worker thread is no longer running, which may occur before the `'exit' event` is emitted, the returned `Promise` is rejected\n         * immediately with an `ERR_WORKER_NOT_RUNNING` error.\n         * @since v13.9.0, v12.17.0\n         * @return A promise for a Readable Stream containing a V8 heap snapshot\n         */\n        getHeapSnapshot(): Promise<Readable>;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        addListener(event: \"message\", listener: (value: any) => void): this;\n        addListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        addListener(event: \"online\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"exit\", exitCode: number): boolean;\n        emit(event: \"message\", value: any): boolean;\n        emit(event: \"messageerror\", error: Error): boolean;\n        emit(event: \"online\"): boolean;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"exit\", listener: (exitCode: number) => void): this;\n        on(event: \"message\", listener: (value: any) => void): this;\n        on(event: \"messageerror\", listener: (error: Error) => void): this;\n        on(event: \"online\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"exit\", listener: (exitCode: number) => void): this;\n        once(event: \"message\", listener: (value: any) => void): this;\n        once(event: \"messageerror\", listener: (error: Error) => void): this;\n        once(event: \"online\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        prependListener(event: \"message\", listener: (value: any) => void): this;\n        prependListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        prependListener(event: \"online\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        prependOnceListener(event: \"message\", listener: (value: any) => void): this;\n        prependOnceListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"online\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        removeListener(event: \"error\", listener: (err: Error) => void): this;\n        removeListener(event: \"exit\", listener: (exitCode: number) => void): this;\n        removeListener(event: \"message\", listener: (value: any) => void): this;\n        removeListener(event: \"messageerror\", listener: (error: Error) => void): this;\n        removeListener(event: \"online\", listener: () => void): this;\n        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        off(event: \"error\", listener: (err: Error) => void): this;\n        off(event: \"exit\", listener: (exitCode: number) => void): this;\n        off(event: \"message\", listener: (value: any) => void): this;\n        off(event: \"messageerror\", listener: (error: Error) => void): this;\n        off(event: \"online\", listener: () => void): this;\n        off(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n    interface BroadcastChannel extends NodeJS.RefCounted {}\n    /**\n     * Instances of `BroadcastChannel` allow asynchronous one-to-many communication\n     * with all other `BroadcastChannel` instances bound to the same channel name.\n     *\n     * ```js\n     * 'use strict';\n     *\n     * import {\n     *   isMainThread,\n     *   BroadcastChannel,\n     *   Worker,\n     * } from 'node:worker_threads';\n     *\n     * const bc = new BroadcastChannel('hello');\n     *\n     * if (isMainThread) {\n     *   let c = 0;\n     *   bc.onmessage = (event) => {\n     *     console.log(event.data);\n     *     if (++c === 10) bc.close();\n     *   };\n     *   for (let n = 0; n < 10; n++)\n     *     new Worker(__filename);\n     * } else {\n     *   bc.postMessage('hello from every worker');\n     *   bc.close();\n     * }\n     * ```\n     * @since v15.4.0\n     */\n    class BroadcastChannel {\n        readonly name: string;\n        /**\n         * Invoked with a single \\`MessageEvent\\` argument when a message is received.\n         * @since v15.4.0\n         */\n        onmessage: (message: unknown) => void;\n        /**\n         * Invoked with a received message cannot be deserialized.\n         * @since v15.4.0\n         */\n        onmessageerror: (message: unknown) => void;\n        constructor(name: string);\n        /**\n         * Closes the `BroadcastChannel` connection.\n         * @since v15.4.0\n         */\n        close(): void;\n        /**\n         * @since v15.4.0\n         * @param message Any cloneable JavaScript value.\n         */\n        postMessage(message: unknown): void;\n    }\n    /**\n     * Mark an object as not transferable. If `object` occurs in the transfer list of\n     * a `port.postMessage()` call, it is ignored.\n     *\n     * In particular, this makes sense for objects that can be cloned, rather than\n     * transferred, and which are used by other objects on the sending side.\n     * For example, Node.js marks the `ArrayBuffer`s it uses for its `Buffer pool` with this.\n     *\n     * This operation cannot be undone.\n     *\n     * ```js\n     * import { MessageChannel, markAsUntransferable } from 'node:worker_threads';\n     *\n     * const pooledBuffer = new ArrayBuffer(8);\n     * const typedArray1 = new Uint8Array(pooledBuffer);\n     * const typedArray2 = new Float64Array(pooledBuffer);\n     *\n     * markAsUntransferable(pooledBuffer);\n     *\n     * const { port1 } = new MessageChannel();\n     * port1.postMessage(typedArray1, [ typedArray1.buffer ]);\n     *\n     * // The following line prints the contents of typedArray1 -- it still owns\n     * // its memory and has been cloned, not transferred. Without\n     * // `markAsUntransferable()`, this would print an empty Uint8Array.\n     * // typedArray2 is intact as well.\n     * console.log(typedArray1);\n     * console.log(typedArray2);\n     * ```\n     *\n     * There is no equivalent to this API in browsers.\n     * @since v14.5.0, v12.19.0\n     */\n    function markAsUntransferable(object: object): void;\n    /**\n     * Check if an object is marked as not transferable with\n     * {@link markAsUntransferable}.\n     * @since v21.0.0\n     */\n    function isMarkedAsUntransferable(object: object): boolean;\n    /**\n     * Mark an object as not cloneable. If `object` is used as `message` in\n     * a `port.postMessage()` call, an error is thrown. This is a no-op if `object` is a\n     * primitive value.\n     *\n     * This has no effect on `ArrayBuffer`, or any `Buffer` like objects.\n     *\n     * This operation cannot be undone.\n     *\n     * ```js\n     * const { markAsUncloneable } = require('node:worker_threads');\n     *\n     * const anyObject = { foo: 'bar' };\n     * markAsUncloneable(anyObject);\n     * const { port1 } = new MessageChannel();\n     * try {\n     *   // This will throw an error, because anyObject is not cloneable.\n     *   port1.postMessage(anyObject)\n     * } catch (error) {\n     *   // error.name === 'DataCloneError'\n     * }\n     * ```\n     *\n     * There is no equivalent to this API in browsers.\n     * @since v22.10.0\n     */\n    function markAsUncloneable(object: object): void;\n    /**\n     * Transfer a `MessagePort` to a different `vm` Context. The original `port` object is rendered unusable, and the returned `MessagePort` instance\n     * takes its place.\n     *\n     * The returned `MessagePort` is an object in the target context and\n     * inherits from its global `Object` class. Objects passed to the [`port.onmessage()`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage) listener are also created in the\n     * target context\n     * and inherit from its global `Object` class.\n     *\n     * However, the created `MessagePort` no longer inherits from [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget), and only\n     * [`port.onmessage()`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage) can be used to receive\n     * events using it.\n     * @since v11.13.0\n     * @param port The message port to transfer.\n     * @param contextifiedSandbox A `contextified` object as returned by the `vm.createContext()` method.\n     */\n    function moveMessagePortToContext(port: MessagePort, contextifiedSandbox: Context): MessagePort;\n    /**\n     * Receive a single message from a given `MessagePort`. If no message is available,`undefined` is returned, otherwise an object with a single `message` property\n     * that contains the message payload, corresponding to the oldest message in the `MessagePort`'s queue.\n     *\n     * ```js\n     * import { MessageChannel, receiveMessageOnPort } from 'node:worker_threads';\n     * const { port1, port2 } = new MessageChannel();\n     * port1.postMessage({ hello: 'world' });\n     *\n     * console.log(receiveMessageOnPort(port2));\n     * // Prints: { message: { hello: 'world' } }\n     * console.log(receiveMessageOnPort(port2));\n     * // Prints: undefined\n     * ```\n     *\n     * When this function is used, no `'message'` event is emitted and the `onmessage` listener is not invoked.\n     * @since v12.3.0\n     */\n    function receiveMessageOnPort(port: MessagePort):\n        | {\n            message: any;\n        }\n        | undefined;\n    type Serializable = string | object | number | boolean | bigint;\n    /**\n     * Within a worker thread, `worker.getEnvironmentData()` returns a clone\n     * of data passed to the spawning thread's `worker.setEnvironmentData()`.\n     * Every new `Worker` receives its own copy of the environment data\n     * automatically.\n     *\n     * ```js\n     * import {\n     *   Worker,\n     *   isMainThread,\n     *   setEnvironmentData,\n     *   getEnvironmentData,\n     * } from 'node:worker_threads';\n     *\n     * if (isMainThread) {\n     *   setEnvironmentData('Hello', 'World!');\n     *   const worker = new Worker(__filename);\n     * } else {\n     *   console.log(getEnvironmentData('Hello'));  // Prints 'World!'.\n     * }\n     * ```\n     * @since v15.12.0, v14.18.0\n     * @param key Any arbitrary, cloneable JavaScript value that can be used as a {Map} key.\n     */\n    function getEnvironmentData(key: Serializable): Serializable;\n    /**\n     * The `worker.setEnvironmentData()` API sets the content of `worker.getEnvironmentData()` in the current thread and all new `Worker` instances spawned from the current context.\n     * @since v15.12.0, v14.18.0\n     * @param key Any arbitrary, cloneable JavaScript value that can be used as a {Map} key.\n     * @param value Any arbitrary, cloneable JavaScript value that will be cloned and passed automatically to all new `Worker` instances. If `value` is passed as `undefined`, any previously set value\n     * for the `key` will be deleted.\n     */\n    function setEnvironmentData(key: Serializable, value: Serializable): void;\n\n    import {\n        BroadcastChannel as _BroadcastChannel,\n        MessageChannel as _MessageChannel,\n        MessagePort as _MessagePort,\n    } from \"worker_threads\";\n    global {\n        /**\n         * `BroadcastChannel` class is a global reference for `import { BroadcastChannel } from 'worker_threads'`\n         * https://nodejs.org/api/globals.html#broadcastchannel\n         * @since v18.0.0\n         */\n        var BroadcastChannel: typeof globalThis extends {\n            onmessage: any;\n            BroadcastChannel: infer T;\n        } ? T\n            : typeof _BroadcastChannel;\n        /**\n         * `MessageChannel` class is a global reference for `import { MessageChannel } from 'worker_threads'`\n         * https://nodejs.org/api/globals.html#messagechannel\n         * @since v15.0.0\n         */\n        var MessageChannel: typeof globalThis extends {\n            onmessage: any;\n            MessageChannel: infer T;\n        } ? T\n            : typeof _MessageChannel;\n        /**\n         * `MessagePort` class is a global reference for `import { MessagePort } from 'worker_threads'`\n         * https://nodejs.org/api/globals.html#messageport\n         * @since v15.0.0\n         */\n        var MessagePort: typeof globalThis extends {\n            onmessage: any;\n            MessagePort: infer T;\n        } ? T\n            : typeof _MessagePort;\n    }\n}\ndeclare module \"node:worker_threads\" {\n    export * from \"worker_threads\";\n}\n"
        }
    ]
}