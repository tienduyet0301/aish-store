{
    "sourceFile": "node_modules/@types/node/https.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a\n * separate module.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/https.js)\n */\ndeclare module \"https\" {\n    import { Duplex } from \"node:stream\";\n    import * as tls from \"node:tls\";\n    import * as http from \"node:http\";\n    import { URL } from \"node:url\";\n    type ServerOptions<\n        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,\n        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,\n    > = tls.SecureContextOptions & tls.TlsOptions & http.ServerOptions<Request, Response>;\n    type RequestOptions =\n        & http.RequestOptions\n        & tls.SecureContextOptions\n        & {\n            checkServerIdentity?:\n                | ((hostname: string, cert: tls.DetailedPeerCertificate) => Error | undefined)\n                | undefined;\n            rejectUnauthorized?: boolean | undefined; // Defaults to true\n            servername?: string | undefined; // SNI TLS Extension\n        };\n    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {\n        maxCachedSessions?: number | undefined;\n    }\n    /**\n     * An `Agent` object for HTTPS similar to `http.Agent`. See {@link request} for more information.\n     * @since v0.4.5\n     */\n    class Agent extends http.Agent {\n        constructor(options?: AgentOptions);\n        options: AgentOptions;\n    }\n    interface Server<\n        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,\n        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,\n    > extends http.Server<Request, Response> {}\n    /**\n     * See `http.Server` for more information.\n     * @since v0.3.4\n     */\n    class Server<\n        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,\n        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,\n    > extends tls.Server {\n        constructor(requestListener?: http.RequestListener<Request, Response>);\n        constructor(\n            options: ServerOptions<Request, Response>,\n            requestListener?: http.RequestListener<Request, Response>,\n        );\n        /**\n         * Closes all connections connected to this server.\n         * @since v18.2.0\n         */\n        closeAllConnections(): void;\n        /**\n         * Closes all connections connected to this server which are not sending a request or waiting for a response.\n         * @since v18.2.0\n         */\n        closeIdleConnections(): void;\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;\n        addListener(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,\n        ): this;\n        addListener(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        addListener(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,\n        ): this;\n        addListener(event: \"secureConnection\", listener: (tlsSocket: tls.TLSSocket) => void): this;\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"connection\", listener: (socket: Duplex) => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"listening\", listener: () => void): this;\n        addListener(event: \"checkContinue\", listener: http.RequestListener<Request, Response>): this;\n        addListener(event: \"checkExpectation\", listener: http.RequestListener<Request, Response>): this;\n        addListener(event: \"clientError\", listener: (err: Error, socket: Duplex) => void): this;\n        addListener(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,\n        ): this;\n        addListener(event: \"request\", listener: http.RequestListener<Request, Response>): this;\n        addListener(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,\n        ): this;\n        emit(event: string, ...args: any[]): boolean;\n        emit(event: \"keylog\", line: Buffer, tlsSocket: tls.TLSSocket): boolean;\n        emit(\n            event: \"newSession\",\n            sessionId: Buffer,\n            sessionData: Buffer,\n            callback: (err: Error, resp: Buffer) => void,\n        ): boolean;\n        emit(\n            event: \"OCSPRequest\",\n            certificate: Buffer,\n            issuer: Buffer,\n            callback: (err: Error | null, resp: Buffer) => void,\n        ): boolean;\n        emit(event: \"resumeSession\", sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;\n        emit(event: \"secureConnection\", tlsSocket: tls.TLSSocket): boolean;\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: tls.TLSSocket): boolean;\n        emit(event: \"close\"): boolean;\n        emit(event: \"connection\", socket: Duplex): boolean;\n        emit(event: \"error\", err: Error): boolean;\n        emit(event: \"listening\"): boolean;\n        emit(\n            event: \"checkContinue\",\n            req: InstanceType<Request>,\n            res: InstanceType<Response>,\n        ): boolean;\n        emit(\n            event: \"checkExpectation\",\n            req: InstanceType<Request>,\n            res: InstanceType<Response>,\n        ): boolean;\n        emit(event: \"clientError\", err: Error, socket: Duplex): boolean;\n        emit(event: \"connect\", req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;\n        emit(\n            event: \"request\",\n            req: InstanceType<Request>,\n            res: InstanceType<Response>,\n        ): boolean;\n        emit(event: \"upgrade\", req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"keylog\", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;\n        on(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,\n        ): this;\n        on(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        on(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,\n        ): this;\n        on(event: \"secureConnection\", listener: (tlsSocket: tls.TLSSocket) => void): this;\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"connection\", listener: (socket: Duplex) => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"listening\", listener: () => void): this;\n        on(event: \"checkContinue\", listener: http.RequestListener<Request, Response>): this;\n        on(event: \"checkExpectation\", listener: http.RequestListener<Request, Response>): this;\n        on(event: \"clientError\", listener: (err: Error, socket: Duplex) => void): this;\n        on(event: \"connect\", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;\n        on(event: \"request\", listener: http.RequestListener<Request, Response>): this;\n        on(event: \"upgrade\", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"keylog\", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;\n        once(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,\n        ): this;\n        once(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        once(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,\n        ): this;\n        once(event: \"secureConnection\", listener: (tlsSocket: tls.TLSSocket) => void): this;\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"connection\", listener: (socket: Duplex) => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"listening\", listener: () => void): this;\n        once(event: \"checkContinue\", listener: http.RequestListener<Request, Response>): this;\n        once(event: \"checkExpectation\", listener: http.RequestListener<Request, Response>): this;\n        once(event: \"clientError\", listener: (err: Error, socket: Duplex) => void): this;\n        once(event: \"connect\", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;\n        once(event: \"request\", listener: http.RequestListener<Request, Response>): this;\n        once(event: \"upgrade\", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;\n        prependListener(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,\n        ): this;\n        prependListener(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        prependListener(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,\n        ): this;\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: tls.TLSSocket) => void): this;\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"connection\", listener: (socket: Duplex) => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"listening\", listener: () => void): this;\n        prependListener(event: \"checkContinue\", listener: http.RequestListener<Request, Response>): this;\n        prependListener(event: \"checkExpectation\", listener: http.RequestListener<Request, Response>): this;\n        prependListener(event: \"clientError\", listener: (err: Error, socket: Duplex) => void): this;\n        prependListener(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,\n        ): this;\n        prependListener(event: \"request\", listener: http.RequestListener<Request, Response>): this;\n        prependListener(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,\n        ): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;\n        prependOnceListener(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,\n        ): this;\n        prependOnceListener(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        prependOnceListener(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,\n        ): this;\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"connection\", listener: (socket: Duplex) => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"listening\", listener: () => void): this;\n        prependOnceListener(event: \"checkContinue\", listener: http.RequestListener<Request, Response>): this;\n        prependOnceListener(event: \"checkExpectation\", listener: http.RequestListener<Request, Response>): this;\n        prependOnceListener(event: \"clientError\", listener: (err: Error, socket: Duplex) => void): this;\n        prependOnceListener(\n            event: \"connect\",\n            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,\n        ): this;\n        prependOnceListener(event: \"request\", listener: http.RequestListener<Request, Response>): this;\n        prependOnceListener(\n            event: \"upgrade\",\n            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,\n        ): this;\n    }\n    /**\n     * ```js\n     * // curl -k https://localhost:8000/\n     * import https from 'node:https';\n     * import fs from 'node:fs';\n     *\n     * const options = {\n     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),\n     * };\n     *\n     * https.createServer(options, (req, res) => {\n     *   res.writeHead(200);\n     *   res.end('hello world\\n');\n     * }).listen(8000);\n     * ```\n     *\n     * Or\n     *\n     * ```js\n     * import https from 'node:https';\n     * import fs from 'node:fs';\n     *\n     * const options = {\n     *   pfx: fs.readFileSync('test/fixtures/test_cert.pfx'),\n     *   passphrase: 'sample',\n     * };\n     *\n     * https.createServer(options, (req, res) => {\n     *   res.writeHead(200);\n     *   res.end('hello world\\n');\n     * }).listen(8000);\n     * ```\n     * @since v0.3.4\n     * @param options Accepts `options` from `createServer`, `createSecureContext` and `createServer`.\n     * @param requestListener A listener to be added to the `'request'` event.\n     */\n    function createServer<\n        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,\n        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,\n    >(requestListener?: http.RequestListener<Request, Response>): Server<Request, Response>;\n    function createServer<\n        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,\n        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,\n    >(\n        options: ServerOptions<Request, Response>,\n        requestListener?: http.RequestListener<Request, Response>,\n    ): Server<Request, Response>;\n    /**\n     * Makes a request to a secure web server.\n     *\n     * The following additional `options` from `tls.connect()` are also accepted: `ca`, `cert`, `ciphers`, `clientCertEngine`, `crl`, `dhparam`, `ecdhCurve`, `honorCipherOrder`, `key`, `passphrase`,\n     * `pfx`, `rejectUnauthorized`, `secureOptions`, `secureProtocol`, `servername`, `sessionIdContext`, `highWaterMark`.\n     *\n     * `options` can be an object, a string, or a `URL` object. If `options` is a\n     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.\n     *\n     * `https.request()` returns an instance of the `http.ClientRequest` class. The `ClientRequest` instance is a writable stream. If one needs to\n     * upload a file with a POST request, then write to the `ClientRequest` object.\n     *\n     * ```js\n     * import https from 'node:https';\n     *\n     * const options = {\n     *   hostname: 'encrypted.google.com',\n     *   port: 443,\n     *   path: '/',\n     *   method: 'GET',\n     * };\n     *\n     * const req = https.request(options, (res) => {\n     *   console.log('statusCode:', res.statusCode);\n     *   console.log('headers:', res.headers);\n     *\n     *   res.on('data', (d) => {\n     *     process.stdout.write(d);\n     *   });\n     * });\n     *\n     * req.on('error', (e) => {\n     *   console.error(e);\n     * });\n     * req.end();\n     * ```\n     *\n     * Example using options from `tls.connect()`:\n     *\n     * ```js\n     * const options = {\n     *   hostname: 'encrypted.google.com',\n     *   port: 443,\n     *   path: '/',\n     *   method: 'GET',\n     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),\n     * };\n     * options.agent = new https.Agent(options);\n     *\n     * const req = https.request(options, (res) => {\n     *   // ...\n     * });\n     * ```\n     *\n     * Alternatively, opt out of connection pooling by not using an `Agent`.\n     *\n     * ```js\n     * const options = {\n     *   hostname: 'encrypted.google.com',\n     *   port: 443,\n     *   path: '/',\n     *   method: 'GET',\n     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),\n     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),\n     *   agent: false,\n     * };\n     *\n     * const req = https.request(options, (res) => {\n     *   // ...\n     * });\n     * ```\n     *\n     * Example using a `URL` as `options`:\n     *\n     * ```js\n     * const options = new URL('https://abc:xyz@example.com');\n     *\n     * const req = https.request(options, (res) => {\n     *   // ...\n     * });\n     * ```\n     *\n     * Example pinning on certificate fingerprint, or the public key (similar to`pin-sha256`):\n     *\n     * ```js\n     * import tls from 'node:tls';\n     * import https from 'node:https';\n     * import crypto from 'node:crypto';\n     *\n     * function sha256(s) {\n     *   return crypto.createHash('sha256').update(s).digest('base64');\n     * }\n     * const options = {\n     *   hostname: 'github.com',\n     *   port: 443,\n     *   path: '/',\n     *   method: 'GET',\n     *   checkServerIdentity: function(host, cert) {\n     *     // Make sure the certificate is issued to the host we are connected to\n     *     const err = tls.checkServerIdentity(host, cert);\n     *     if (err) {\n     *       return err;\n     *     }\n     *\n     *     // Pin the public key, similar to HPKP pin-sha256 pinning\n     *     const pubkey256 = 'pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=';\n     *     if (sha256(cert.pubkey) !== pubkey256) {\n     *       const msg = 'Certificate verification error: ' +\n     *         `The public key of '${cert.subject.CN}' ` +\n     *         'does not match our pinned fingerprint';\n     *       return new Error(msg);\n     *     }\n     *\n     *     // Pin the exact certificate, rather than the pub key\n     *     const cert256 = '25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:' +\n     *       'D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16';\n     *     if (cert.fingerprint256 !== cert256) {\n     *       const msg = 'Certificate verification error: ' +\n     *         `The certificate of '${cert.subject.CN}' ` +\n     *         'does not match our pinned fingerprint';\n     *       return new Error(msg);\n     *     }\n     *\n     *     // This loop is informational only.\n     *     // Print the certificate and public key fingerprints of all certs in the\n     *     // chain. Its common to pin the public key of the issuer on the public\n     *     // internet, while pinning the public key of the service in sensitive\n     *     // environments.\n     *     do {\n     *       console.log('Subject Common Name:', cert.subject.CN);\n     *       console.log('  Certificate SHA256 fingerprint:', cert.fingerprint256);\n     *\n     *       hash = crypto.createHash('sha256');\n     *       console.log('  Public key ping-sha256:', sha256(cert.pubkey));\n     *\n     *       lastprint256 = cert.fingerprint256;\n     *       cert = cert.issuerCertificate;\n     *     } while (cert.fingerprint256 !== lastprint256);\n     *\n     *   },\n     * };\n     *\n     * options.agent = new https.Agent(options);\n     * const req = https.request(options, (res) => {\n     *   console.log('All OK. Server matched our pinned cert or public key');\n     *   console.log('statusCode:', res.statusCode);\n     *   // Print the HPKP values\n     *   console.log('headers:', res.headers['public-key-pins']);\n     *\n     *   res.on('data', (d) => {});\n     * });\n     *\n     * req.on('error', (e) => {\n     *   console.error(e.message);\n     * });\n     * req.end();\n     * ```\n     *\n     * Outputs for example:\n     *\n     * ```text\n     * Subject Common Name: github.com\n     *   Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16\n     *   Public key ping-sha256: pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=\n     * Subject Common Name: DigiCert SHA2 Extended Validation Server CA\n     *   Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A\n     *   Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=\n     * Subject Common Name: DigiCert High Assurance EV Root CA\n     *   Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF\n     *   Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=\n     * All OK. Server matched our pinned cert or public key\n     * statusCode: 200\n     * headers: max-age=0; pin-sha256=\"WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=\"; pin-sha256=\"RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=\";\n     * pin-sha256=\"k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws=\"; pin-sha256=\"K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q=\"; pin-sha256=\"IQBnNBEiFuhj+8x6X8XLgh01V9Ic5/V3IRQLNFFc7v4=\";\n     * pin-sha256=\"iie1VXtL7HzAMF+/PVPR9xzT80kQxdZeJ+zduCB3uj0=\"; pin-sha256=\"LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A=\"; includeSubDomains\n     * ```\n     * @since v0.3.6\n     * @param options Accepts all `options` from `request`, with some differences in default values:\n     */\n    function request(\n        options: RequestOptions | string | URL,\n        callback?: (res: http.IncomingMessage) => void,\n    ): http.ClientRequest;\n    function request(\n        url: string | URL,\n        options: RequestOptions,\n        callback?: (res: http.IncomingMessage) => void,\n    ): http.ClientRequest;\n    /**\n     * Like `http.get()` but for HTTPS.\n     *\n     * `options` can be an object, a string, or a `URL` object. If `options` is a\n     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.\n     *\n     * ```js\n     * import https from 'node:https';\n     *\n     * https.get('https://encrypted.google.com/', (res) => {\n     *   console.log('statusCode:', res.statusCode);\n     *   console.log('headers:', res.headers);\n     *\n     *   res.on('data', (d) => {\n     *     process.stdout.write(d);\n     *   });\n     *\n     * }).on('error', (e) => {\n     *   console.error(e);\n     * });\n     * ```\n     * @since v0.3.6\n     * @param options Accepts the same `options` as {@link request}, with the `method` always set to `GET`.\n     */\n    function get(\n        options: RequestOptions | string | URL,\n        callback?: (res: http.IncomingMessage) => void,\n    ): http.ClientRequest;\n    function get(\n        url: string | URL,\n        options: RequestOptions,\n        callback?: (res: http.IncomingMessage) => void,\n    ): http.ClientRequest;\n    let globalAgent: Agent;\n}\ndeclare module \"node:https\" {\n    export * from \"https\";\n}\n"
        }
    ]
}