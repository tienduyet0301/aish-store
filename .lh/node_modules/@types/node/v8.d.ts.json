{
    "sourceFile": "node_modules/@types/node/v8.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:v8` module exposes APIs that are specific to the version of [V8](https://developers.google.com/v8/) built into the Node.js binary. It can be accessed using:\n *\n * ```js\n * import v8 from 'node:v8';\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/v8.js)\n */\ndeclare module \"v8\" {\n    import { Readable } from \"node:stream\";\n    interface HeapSpaceInfo {\n        space_name: string;\n        space_size: number;\n        space_used_size: number;\n        space_available_size: number;\n        physical_space_size: number;\n    }\n    // ** Signifies if the --zap_code_space option is enabled or not.  1 == enabled, 0 == disabled. */\n    type DoesZapCodeSpaceFlag = 0 | 1;\n    interface HeapInfo {\n        total_heap_size: number;\n        total_heap_size_executable: number;\n        total_physical_size: number;\n        total_available_size: number;\n        used_heap_size: number;\n        heap_size_limit: number;\n        malloced_memory: number;\n        peak_malloced_memory: number;\n        does_zap_garbage: DoesZapCodeSpaceFlag;\n        number_of_native_contexts: number;\n        number_of_detached_contexts: number;\n        total_global_handles_size: number;\n        used_global_handles_size: number;\n        external_memory: number;\n    }\n    interface HeapCodeStatistics {\n        code_and_metadata_size: number;\n        bytecode_and_metadata_size: number;\n        external_script_source_size: number;\n    }\n    interface HeapSnapshotOptions {\n        /**\n         * If true, expose internals in the heap snapshot.\n         * @default false\n         */\n        exposeInternals?: boolean;\n        /**\n         * If true, expose numeric values in artificial fields.\n         * @default false\n         */\n        exposeNumericValues?: boolean;\n    }\n    /**\n     * Returns an integer representing a version tag derived from the V8 version,\n     * command-line flags, and detected CPU features. This is useful for determining\n     * whether a `vm.Script` `cachedData` buffer is compatible with this instance\n     * of V8.\n     *\n     * ```js\n     * console.log(v8.cachedDataVersionTag()); // 3947234607\n     * // The value returned by v8.cachedDataVersionTag() is derived from the V8\n     * // version, command-line flags, and detected CPU features. Test that the value\n     * // does indeed update when flags are toggled.\n     * v8.setFlagsFromString('--allow_natives_syntax');\n     * console.log(v8.cachedDataVersionTag()); // 183726201\n     * ```\n     * @since v8.0.0\n     */\n    function cachedDataVersionTag(): number;\n    /**\n     * Returns an object with the following properties:\n     *\n     * `does_zap_garbage` is a 0/1 boolean, which signifies whether the `--zap_code_space` option is enabled or not. This makes V8 overwrite heap\n     * garbage with a bit pattern. The RSS footprint (resident set size) gets bigger\n     * because it continuously touches all heap pages and that makes them less likely\n     * to get swapped out by the operating system.\n     *\n     * `number_of_native_contexts` The value of native\\_context is the number of the\n     * top-level contexts currently active. Increase of this number over time indicates\n     * a memory leak.\n     *\n     * `number_of_detached_contexts` The value of detached\\_context is the number\n     * of contexts that were detached and not yet garbage collected. This number\n     * being non-zero indicates a potential memory leak.\n     *\n     * `total_global_handles_size` The value of total\\_global\\_handles\\_size is the\n     * total memory size of V8 global handles.\n     *\n     * `used_global_handles_size` The value of used\\_global\\_handles\\_size is the\n     * used memory size of V8 global handles.\n     *\n     * `external_memory` The value of external\\_memory is the memory size of array\n     * buffers and external strings.\n     *\n     * ```js\n     * {\n     *   total_heap_size: 7326976,\n     *   total_heap_size_executable: 4194304,\n     *   total_physical_size: 7326976,\n     *   total_available_size: 1152656,\n     *   used_heap_size: 3476208,\n     *   heap_size_limit: 1535115264,\n     *   malloced_memory: 16384,\n     *   peak_malloced_memory: 1127496,\n     *   does_zap_garbage: 0,\n     *   number_of_native_contexts: 1,\n     *   number_of_detached_contexts: 0,\n     *   total_global_handles_size: 8192,\n     *   used_global_handles_size: 3296,\n     *   external_memory: 318824\n     * }\n     * ```\n     * @since v1.0.0\n     */\n    function getHeapStatistics(): HeapInfo;\n    /**\n     * It returns an object with a structure similar to the\n     * [`cppgc::HeapStatistics`](https://v8docs.nodesource.com/node-22.4/d7/d51/heap-statistics_8h_source.html)\n     * object. See the [V8 documentation](https://v8docs.nodesource.com/node-22.4/df/d2f/structcppgc_1_1_heap_statistics.html)\n     * for more information about the properties of the object.\n     *\n     * ```js\n     * // Detailed\n     * ({\n     *   committed_size_bytes: 131072,\n     *   resident_size_bytes: 131072,\n     *   used_size_bytes: 152,\n     *   space_statistics: [\n     *     {\n     *       name: 'NormalPageSpace0',\n     *       committed_size_bytes: 0,\n     *       resident_size_bytes: 0,\n     *       used_size_bytes: 0,\n     *       page_stats: [{}],\n     *       free_list_stats: {},\n     *     },\n     *     {\n     *       name: 'NormalPageSpace1',\n     *       committed_size_bytes: 131072,\n     *       resident_size_bytes: 131072,\n     *       used_size_bytes: 152,\n     *       page_stats: [{}],\n     *       free_list_stats: {},\n     *     },\n     *     {\n     *       name: 'NormalPageSpace2',\n     *       committed_size_bytes: 0,\n     *       resident_size_bytes: 0,\n     *       used_size_bytes: 0,\n     *       page_stats: [{}],\n     *       free_list_stats: {},\n     *     },\n     *     {\n     *       name: 'NormalPageSpace3',\n     *       committed_size_bytes: 0,\n     *       resident_size_bytes: 0,\n     *       used_size_bytes: 0,\n     *       page_stats: [{}],\n     *       free_list_stats: {},\n     *     },\n     *     {\n     *       name: 'LargePageSpace',\n     *       committed_size_bytes: 0,\n     *       resident_size_bytes: 0,\n     *       used_size_bytes: 0,\n     *       page_stats: [{}],\n     *       free_list_stats: {},\n     *     },\n     *   ],\n     *   type_names: [],\n     *   detail_level: 'detailed',\n     * });\n     * ```\n     *\n     * ```js\n     * // Brief\n     * ({\n     *   committed_size_bytes: 131072,\n     *   resident_size_bytes: 131072,\n     *   used_size_bytes: 128864,\n     *   space_statistics: [],\n     *   type_names: [],\n     *   detail_level: 'brief',\n     * });\n     * ```\n     * @since v22.15.0\n     * @param detailLevel **Default:** `'detailed'`. Specifies the level of detail in the returned statistics.\n     * Accepted values are:\n     * * `'brief'`:  Brief statistics contain only the top-level\n     * allocated and used\n     * memory statistics for the entire heap.\n     * * `'detailed'`: Detailed statistics also contain a break\n     * down per space and page, as well as freelist statistics\n     * and object type histograms.\n     */\n    function getCppHeapStatistics(detailLevel?: \"brief\" | \"detailed\"): object;\n    /**\n     * Returns statistics about the V8 heap spaces, i.e. the segments which make up\n     * the V8 heap. Neither the ordering of heap spaces, nor the availability of a\n     * heap space can be guaranteed as the statistics are provided via the\n     * V8 [`GetHeapSpaceStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate.html#ac673576f24fdc7a33378f8f57e1d13a4) function and may change from one V8 version to the\n     * next.\n     *\n     * The value returned is an array of objects containing the following properties:\n     *\n     * ```json\n     * [\n     *   {\n     *     \"space_name\": \"new_space\",\n     *     \"space_size\": 2063872,\n     *     \"space_used_size\": 951112,\n     *     \"space_available_size\": 80824,\n     *     \"physical_space_size\": 2063872\n     *   },\n     *   {\n     *     \"space_name\": \"old_space\",\n     *     \"space_size\": 3090560,\n     *     \"space_used_size\": 2493792,\n     *     \"space_available_size\": 0,\n     *     \"physical_space_size\": 3090560\n     *   },\n     *   {\n     *     \"space_name\": \"code_space\",\n     *     \"space_size\": 1260160,\n     *     \"space_used_size\": 644256,\n     *     \"space_available_size\": 960,\n     *     \"physical_space_size\": 1260160\n     *   },\n     *   {\n     *     \"space_name\": \"map_space\",\n     *     \"space_size\": 1094160,\n     *     \"space_used_size\": 201608,\n     *     \"space_available_size\": 0,\n     *     \"physical_space_size\": 1094160\n     *   },\n     *   {\n     *     \"space_name\": \"large_object_space\",\n     *     \"space_size\": 0,\n     *     \"space_used_size\": 0,\n     *     \"space_available_size\": 1490980608,\n     *     \"physical_space_size\": 0\n     *   }\n     * ]\n     * ```\n     * @since v6.0.0\n     */\n    function getHeapSpaceStatistics(): HeapSpaceInfo[];\n    /**\n     * The `v8.setFlagsFromString()` method can be used to programmatically set\n     * V8 command-line flags. This method should be used with care. Changing settings\n     * after the VM has started may result in unpredictable behavior, including\n     * crashes and data loss; or it may simply do nothing.\n     *\n     * The V8 options available for a version of Node.js may be determined by running `node --v8-options`.\n     *\n     * Usage:\n     *\n     * ```js\n     * // Print GC events to stdout for one minute.\n     * import v8 from 'node:v8';\n     * v8.setFlagsFromString('--trace_gc');\n     * setTimeout(() => { v8.setFlagsFromString('--notrace_gc'); }, 60e3);\n     * ```\n     * @since v1.0.0\n     */\n    function setFlagsFromString(flags: string): void;\n    /**\n     * This is similar to the [`queryObjects()` console API](https://developer.chrome.com/docs/devtools/console/utilities#queryObjects-function)\n     * provided by the Chromium DevTools console. It can be used to search for objects that have the matching constructor on its prototype chain\n     * in the heap after a full garbage collection, which can be useful for memory leak regression tests. To avoid surprising results, users should\n     * avoid using this API on constructors whose implementation they don't control, or on constructors that can be invoked by other parties in the\n     * application.\n     *\n     * To avoid accidental leaks, this API does not return raw references to the objects found. By default, it returns the count of the objects\n     * found. If `options.format` is `'summary'`, it returns an array containing brief string representations for each object. The visibility provided\n     * in this API is similar to what the heap snapshot provides, while users can save the cost of serialization and parsing and directly filter the\n     * target objects during the search.\n     *\n     * Only objects created in the current execution context are included in the results.\n     *\n     * ```js\n     * import { queryObjects } from 'node:v8';\n     * class A { foo = 'bar'; }\n     * console.log(queryObjects(A)); // 0\n     * const a = new A();\n     * console.log(queryObjects(A)); // 1\n     * // [ \"A { foo: 'bar' }\" ]\n     * console.log(queryObjects(A, { format: 'summary' }));\n     *\n     * class B extends A { bar = 'qux'; }\n     * const b = new B();\n     * console.log(queryObjects(B)); // 1\n     * // [ \"B { foo: 'bar', bar: 'qux' }\" ]\n     * console.log(queryObjects(B, { format: 'summary' }));\n     *\n     * // Note that, when there are child classes inheriting from a constructor,\n     * // the constructor also shows up in the prototype chain of the child\n     * // classes's prototoype, so the child classes's prototoype would also be\n     * // included in the result.\n     * console.log(queryObjects(A));  // 3\n     * // [ \"B { foo: 'bar', bar: 'qux' }\", 'A {}', \"A { foo: 'bar' }\" ]\n     * console.log(queryObjects(A, { format: 'summary' }));\n     * ```\n     * @param ctor The constructor that can be used to search on the prototype chain in order to filter target objects in the heap.\n     * @since v20.13.0\n     * @experimental\n     */\n    function queryObjects(ctor: Function): number | string[];\n    function queryObjects(ctor: Function, options: { format: \"count\" }): number;\n    function queryObjects(ctor: Function, options: { format: \"summary\" }): string[];\n    /**\n     * Generates a snapshot of the current V8 heap and returns a Readable\n     * Stream that may be used to read the JSON serialized representation.\n     * This JSON stream format is intended to be used with tools such as\n     * Chrome DevTools. The JSON schema is undocumented and specific to the\n     * V8 engine. Therefore, the schema may change from one version of V8 to the next.\n     *\n     * Creating a heap snapshot requires memory about twice the size of the heap at\n     * the time the snapshot is created. This results in the risk of OOM killers\n     * terminating the process.\n     *\n     * Generating a snapshot is a synchronous operation which blocks the event loop\n     * for a duration depending on the heap size.\n     *\n     * ```js\n     * // Print heap snapshot to the console\n     * import v8 from 'node:v8';\n     * const stream = v8.getHeapSnapshot();\n     * stream.pipe(process.stdout);\n     * ```\n     * @since v11.13.0\n     * @return A Readable containing the V8 heap snapshot.\n     */\n    function getHeapSnapshot(options?: HeapSnapshotOptions): Readable;\n    /**\n     * Generates a snapshot of the current V8 heap and writes it to a JSON\n     * file. This file is intended to be used with tools such as Chrome\n     * DevTools. The JSON schema is undocumented and specific to the V8\n     * engine, and may change from one version of V8 to the next.\n     *\n     * A heap snapshot is specific to a single V8 isolate. When using `worker threads`, a heap snapshot generated from the main thread will\n     * not contain any information about the workers, and vice versa.\n     *\n     * Creating a heap snapshot requires memory about twice the size of the heap at\n     * the time the snapshot is created. This results in the risk of OOM killers\n     * terminating the process.\n     *\n     * Generating a snapshot is a synchronous operation which blocks the event loop\n     * for a duration depending on the heap size.\n     *\n     * ```js\n     * import { writeHeapSnapshot } from 'node:v8';\n     * import {\n     *   Worker,\n     *   isMainThread,\n     *   parentPort,\n     * } from 'node:worker_threads';\n     *\n     * if (isMainThread) {\n     *   const worker = new Worker(__filename);\n     *\n     *   worker.once('message', (filename) => {\n     *     console.log(`worker heapdump: ${filename}`);\n     *     // Now get a heapdump for the main thread.\n     *     console.log(`main thread heapdump: ${writeHeapSnapshot()}`);\n     *   });\n     *\n     *   // Tell the worker to create a heapdump.\n     *   worker.postMessage('heapdump');\n     * } else {\n     *   parentPort.once('message', (message) => {\n     *     if (message === 'heapdump') {\n     *       // Generate a heapdump for the worker\n     *       // and return the filename to the parent.\n     *       parentPort.postMessage(writeHeapSnapshot());\n     *     }\n     *   });\n     * }\n     * ```\n     * @since v11.13.0\n     * @param filename The file path where the V8 heap snapshot is to be saved. If not specified, a file name with the pattern `'Heap-${yyyymmdd}-${hhmmss}-${pid}-${thread_id}.heapsnapshot'` will be\n     * generated, where `{pid}` will be the PID of the Node.js process, `{thread_id}` will be `0` when `writeHeapSnapshot()` is called from the main Node.js thread or the id of a\n     * worker thread.\n     * @return The filename where the snapshot was saved.\n     */\n    function writeHeapSnapshot(filename?: string, options?: HeapSnapshotOptions): string;\n    /**\n     * Get statistics about code and its metadata in the heap, see\n     * V8 [`GetHeapCodeAndMetadataStatistics`](https://v8docs.nodesource.com/node-13.2/d5/dda/classv8_1_1_isolate.html#a6079122af17612ef54ef3348ce170866) API. Returns an object with the\n     * following properties:\n     *\n     * ```js\n     * {\n     *   code_and_metadata_size: 212208,\n     *   bytecode_and_metadata_size: 161368,\n     *   external_script_source_size: 1410794,\n     *   cpu_profiler_metadata_size: 0,\n     * }\n     * ```\n     * @since v12.8.0\n     */\n    function getHeapCodeStatistics(): HeapCodeStatistics;\n    /**\n     * @since v8.0.0\n     */\n    class Serializer {\n        /**\n         * Writes out a header, which includes the serialization format version.\n         */\n        writeHeader(): void;\n        /**\n         * Serializes a JavaScript value and adds the serialized representation to the\n         * internal buffer.\n         *\n         * This throws an error if `value` cannot be serialized.\n         */\n        writeValue(val: any): boolean;\n        /**\n         * Returns the stored internal buffer. This serializer should not be used once\n         * the buffer is released. Calling this method results in undefined behavior\n         * if a previous write has failed.\n         */\n        releaseBuffer(): Buffer;\n        /**\n         * Marks an `ArrayBuffer` as having its contents transferred out of band.\n         * Pass the corresponding `ArrayBuffer` in the deserializing context to `deserializer.transferArrayBuffer()`.\n         * @param id A 32-bit unsigned integer.\n         * @param arrayBuffer An `ArrayBuffer` instance.\n         */\n        transferArrayBuffer(id: number, arrayBuffer: ArrayBuffer): void;\n        /**\n         * Write a raw 32-bit unsigned integer.\n         * For use inside of a custom `serializer._writeHostObject()`.\n         */\n        writeUint32(value: number): void;\n        /**\n         * Write a raw 64-bit unsigned integer, split into high and low 32-bit parts.\n         * For use inside of a custom `serializer._writeHostObject()`.\n         */\n        writeUint64(hi: number, lo: number): void;\n        /**\n         * Write a JS `number` value.\n         * For use inside of a custom `serializer._writeHostObject()`.\n         */\n        writeDouble(value: number): void;\n        /**\n         * Write raw bytes into the serializer's internal buffer. The deserializer\n         * will require a way to compute the length of the buffer.\n         * For use inside of a custom `serializer._writeHostObject()`.\n         */\n        writeRawBytes(buffer: NodeJS.TypedArray): void;\n    }\n    /**\n     * A subclass of `Serializer` that serializes `TypedArray`(in particular `Buffer`) and `DataView` objects as host objects, and only\n     * stores the part of their underlying `ArrayBuffer`s that they are referring to.\n     * @since v8.0.0\n     */\n    class DefaultSerializer extends Serializer {}\n    /**\n     * @since v8.0.0\n     */\n    class Deserializer {\n        constructor(data: NodeJS.TypedArray);\n        /**\n         * Reads and validates a header (including the format version).\n         * May, for example, reject an invalid or unsupported wire format. In that case,\n         * an `Error` is thrown.\n         */\n        readHeader(): boolean;\n        /**\n         * Deserializes a JavaScript value from the buffer and returns it.\n         */\n        readValue(): any;\n        /**\n         * Marks an `ArrayBuffer` as having its contents transferred out of band.\n         * Pass the corresponding `ArrayBuffer` in the serializing context to `serializer.transferArrayBuffer()` (or return the `id` from `serializer._getSharedArrayBufferId()` in the case of\n         * `SharedArrayBuffer`s).\n         * @param id A 32-bit unsigned integer.\n         * @param arrayBuffer An `ArrayBuffer` instance.\n         */\n        transferArrayBuffer(id: number, arrayBuffer: ArrayBuffer): void;\n        /**\n         * Reads the underlying wire format version. Likely mostly to be useful to\n         * legacy code reading old wire format versions. May not be called before `.readHeader()`.\n         */\n        getWireFormatVersion(): number;\n        /**\n         * Read a raw 32-bit unsigned integer and return it.\n         * For use inside of a custom `deserializer._readHostObject()`.\n         */\n        readUint32(): number;\n        /**\n         * Read a raw 64-bit unsigned integer and return it as an array `[hi, lo]` with two 32-bit unsigned integer entries.\n         * For use inside of a custom `deserializer._readHostObject()`.\n         */\n        readUint64(): [number, number];\n        /**\n         * Read a JS `number` value.\n         * For use inside of a custom `deserializer._readHostObject()`.\n         */\n        readDouble(): number;\n        /**\n         * Read raw bytes from the deserializer's internal buffer. The `length` parameter\n         * must correspond to the length of the buffer that was passed to `serializer.writeRawBytes()`.\n         * For use inside of a custom `deserializer._readHostObject()`.\n         */\n        readRawBytes(length: number): Buffer;\n    }\n    /**\n     * A subclass of `Deserializer` corresponding to the format written by `DefaultSerializer`.\n     * @since v8.0.0\n     */\n    class DefaultDeserializer extends Deserializer {}\n    /**\n     * Uses a `DefaultSerializer` to serialize `value` into a buffer.\n     *\n     * `ERR_BUFFER_TOO_LARGE` will be thrown when trying to\n     * serialize a huge object which requires buffer\n     * larger than `buffer.constants.MAX_LENGTH`.\n     * @since v8.0.0\n     */\n    function serialize(value: any): Buffer;\n    /**\n     * Uses a `DefaultDeserializer` with default options to read a JS value\n     * from a buffer.\n     * @since v8.0.0\n     * @param buffer A buffer returned by {@link serialize}.\n     */\n    function deserialize(buffer: NodeJS.ArrayBufferView): any;\n    /**\n     * The `v8.takeCoverage()` method allows the user to write the coverage started by `NODE_V8_COVERAGE` to disk on demand. This method can be invoked multiple\n     * times during the lifetime of the process. Each time the execution counter will\n     * be reset and a new coverage report will be written to the directory specified\n     * by `NODE_V8_COVERAGE`.\n     *\n     * When the process is about to exit, one last coverage will still be written to\n     * disk unless {@link stopCoverage} is invoked before the process exits.\n     * @since v15.1.0, v14.18.0, v12.22.0\n     */\n    function takeCoverage(): void;\n    /**\n     * The `v8.stopCoverage()` method allows the user to stop the coverage collection\n     * started by `NODE_V8_COVERAGE`, so that V8 can release the execution count\n     * records and optimize code. This can be used in conjunction with {@link takeCoverage} if the user wants to collect the coverage on demand.\n     * @since v15.1.0, v14.18.0, v12.22.0\n     */\n    function stopCoverage(): void;\n    /**\n     * The API is a no-op if `--heapsnapshot-near-heap-limit` is already set from the command line or the API is called more than once.\n     * `limit` must be a positive integer. See [`--heapsnapshot-near-heap-limit`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--heapsnapshot-near-heap-limitmax_count) for more information.\n     * @experimental\n     * @since v18.10.0, v16.18.0\n     */\n    function setHeapSnapshotNearHeapLimit(limit: number): void;\n    /**\n     * This API collects GC data in current thread.\n     * @since v19.6.0, v18.15.0\n     */\n    class GCProfiler {\n        /**\n         * Start collecting GC data.\n         * @since v19.6.0, v18.15.0\n         */\n        start(): void;\n        /**\n         * Stop collecting GC data and return an object. The content of object\n         * is as follows.\n         *\n         * ```json\n         * {\n         *   \"version\": 1,\n         *   \"startTime\": 1674059033862,\n         *   \"statistics\": [\n         *     {\n         *       \"gcType\": \"Scavenge\",\n         *       \"beforeGC\": {\n         *         \"heapStatistics\": {\n         *           \"totalHeapSize\": 5005312,\n         *           \"totalHeapSizeExecutable\": 524288,\n         *           \"totalPhysicalSize\": 5226496,\n         *           \"totalAvailableSize\": 4341325216,\n         *           \"totalGlobalHandlesSize\": 8192,\n         *           \"usedGlobalHandlesSize\": 2112,\n         *           \"usedHeapSize\": 4883840,\n         *           \"heapSizeLimit\": 4345298944,\n         *           \"mallocedMemory\": 254128,\n         *           \"externalMemory\": 225138,\n         *           \"peakMallocedMemory\": 181760\n         *         },\n         *         \"heapSpaceStatistics\": [\n         *           {\n         *             \"spaceName\": \"read_only_space\",\n         *             \"spaceSize\": 0,\n         *             \"spaceUsedSize\": 0,\n         *             \"spaceAvailableSize\": 0,\n         *             \"physicalSpaceSize\": 0\n         *           }\n         *         ]\n         *       },\n         *       \"cost\": 1574.14,\n         *       \"afterGC\": {\n         *         \"heapStatistics\": {\n         *           \"totalHeapSize\": 6053888,\n         *           \"totalHeapSizeExecutable\": 524288,\n         *           \"totalPhysicalSize\": 5500928,\n         *           \"totalAvailableSize\": 4341101384,\n         *           \"totalGlobalHandlesSize\": 8192,\n         *           \"usedGlobalHandlesSize\": 2112,\n         *           \"usedHeapSize\": 4059096,\n         *           \"heapSizeLimit\": 4345298944,\n         *           \"mallocedMemory\": 254128,\n         *           \"externalMemory\": 225138,\n         *           \"peakMallocedMemory\": 181760\n         *         },\n         *         \"heapSpaceStatistics\": [\n         *           {\n         *             \"spaceName\": \"read_only_space\",\n         *             \"spaceSize\": 0,\n         *             \"spaceUsedSize\": 0,\n         *             \"spaceAvailableSize\": 0,\n         *             \"physicalSpaceSize\": 0\n         *           }\n         *         ]\n         *       }\n         *     }\n         *   ],\n         *   \"endTime\": 1674059036865\n         * }\n         * ```\n         *\n         * Here's an example.\n         *\n         * ```js\n         * import { GCProfiler } from 'node:v8';\n         * const profiler = new GCProfiler();\n         * profiler.start();\n         * setTimeout(() => {\n         *   console.log(profiler.stop());\n         * }, 1000);\n         * ```\n         * @since v19.6.0, v18.15.0\n         */\n        stop(): GCProfilerResult;\n    }\n    interface GCProfilerResult {\n        version: number;\n        startTime: number;\n        endTime: number;\n        statistics: Array<{\n            gcType: string;\n            cost: number;\n            beforeGC: {\n                heapStatistics: HeapStatistics;\n                heapSpaceStatistics: HeapSpaceStatistics[];\n            };\n            afterGC: {\n                heapStatistics: HeapStatistics;\n                heapSpaceStatistics: HeapSpaceStatistics[];\n            };\n        }>;\n    }\n    interface HeapStatistics {\n        totalHeapSize: number;\n        totalHeapSizeExecutable: number;\n        totalPhysicalSize: number;\n        totalAvailableSize: number;\n        totalGlobalHandlesSize: number;\n        usedGlobalHandlesSize: number;\n        usedHeapSize: number;\n        heapSizeLimit: number;\n        mallocedMemory: number;\n        externalMemory: number;\n        peakMallocedMemory: number;\n    }\n    interface HeapSpaceStatistics {\n        spaceName: string;\n        spaceSize: number;\n        spaceUsedSize: number;\n        spaceAvailableSize: number;\n        physicalSpaceSize: number;\n    }\n    /**\n     * Called when a promise is constructed. This does not mean that corresponding before/after events will occur, only that the possibility exists. This will\n     * happen if a promise is created without ever getting a continuation.\n     * @since v17.1.0, v16.14.0\n     * @param promise The promise being created.\n     * @param parent The promise continued from, if applicable.\n     */\n    interface Init {\n        (promise: Promise<unknown>, parent: Promise<unknown>): void;\n    }\n    /**\n     * Called before a promise continuation executes. This can be in the form of `then()`, `catch()`, or `finally()` handlers or an await resuming.\n     *\n     * The before callback will be called 0 to N times. The before callback will typically be called 0 times if no continuation was ever made for the promise.\n     * The before callback may be called many times in the case where many continuations have been made from the same promise.\n     * @since v17.1.0, v16.14.0\n     */\n    interface Before {\n        (promise: Promise<unknown>): void;\n    }\n    /**\n     * Called immediately after a promise continuation executes. This may be after a `then()`, `catch()`, or `finally()` handler or before an await after another await.\n     * @since v17.1.0, v16.14.0\n     */\n    interface After {\n        (promise: Promise<unknown>): void;\n    }\n    /**\n     * Called when the promise receives a resolution or rejection value. This may occur synchronously in the case of {@link Promise.resolve()} or\n     * {@link Promise.reject()}.\n     * @since v17.1.0, v16.14.0\n     */\n    interface Settled {\n        (promise: Promise<unknown>): void;\n    }\n    /**\n     * Key events in the lifetime of a promise have been categorized into four areas: creation of a promise, before/after a continuation handler is called or\n     * around an await, and when the promise resolves or rejects.\n     *\n     * Because promises are asynchronous resources whose lifecycle is tracked via the promise hooks mechanism, the `init()`, `before()`, `after()`, and\n     * `settled()` callbacks must not be async functions as they create more promises which would produce an infinite loop.\n     * @since v17.1.0, v16.14.0\n     */\n    interface HookCallbacks {\n        init?: Init;\n        before?: Before;\n        after?: After;\n        settled?: Settled;\n    }\n    interface PromiseHooks {\n        /**\n         * The `init` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop.\n         * @since v17.1.0, v16.14.0\n         * @param init The {@link Init | `init` callback} to call when a promise is created.\n         * @return Call to stop the hook.\n         */\n        onInit: (init: Init) => Function;\n        /**\n         * The `settled` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop.\n         * @since v17.1.0, v16.14.0\n         * @param settled The {@link Settled | `settled` callback} to call when a promise is created.\n         * @return Call to stop the hook.\n         */\n        onSettled: (settled: Settled) => Function;\n        /**\n         * The `before` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop.\n         * @since v17.1.0, v16.14.0\n         * @param before The {@link Before | `before` callback} to call before a promise continuation executes.\n         * @return Call to stop the hook.\n         */\n        onBefore: (before: Before) => Function;\n        /**\n         * The `after` hook must be a plain function. Providing an async function will throw as it would produce an infinite microtask loop.\n         * @since v17.1.0, v16.14.0\n         * @param after The {@link After | `after` callback} to call after a promise continuation executes.\n         * @return Call to stop the hook.\n         */\n        onAfter: (after: After) => Function;\n        /**\n         * Registers functions to be called for different lifetime events of each promise.\n         * The callbacks `init()`/`before()`/`after()`/`settled()` are called for the respective events during a promise's lifetime.\n         * All callbacks are optional. For example, if only promise creation needs to be tracked, then only the init callback needs to be passed.\n         * The hook callbacks must be plain functions. Providing async functions will throw as it would produce an infinite microtask loop.\n         * @since v17.1.0, v16.14.0\n         * @param callbacks The {@link HookCallbacks | Hook Callbacks} to register\n         * @return Used for disabling hooks\n         */\n        createHook: (callbacks: HookCallbacks) => Function;\n    }\n    /**\n     * The `promiseHooks` interface can be used to track promise lifecycle events.\n     * @since v17.1.0, v16.14.0\n     */\n    const promiseHooks: PromiseHooks;\n    type StartupSnapshotCallbackFn = (args: any) => any;\n    interface StartupSnapshot {\n        /**\n         * Add a callback that will be called when the Node.js instance is about to get serialized into a snapshot and exit.\n         * This can be used to release resources that should not or cannot be serialized or to convert user data into a form more suitable for serialization.\n         * @since v18.6.0, v16.17.0\n         */\n        addSerializeCallback(callback: StartupSnapshotCallbackFn, data?: any): void;\n        /**\n         * Add a callback that will be called when the Node.js instance is deserialized from a snapshot.\n         * The `callback` and the `data` (if provided) will be serialized into the snapshot, they can be used to re-initialize the state of the application or\n         * to re-acquire resources that the application needs when the application is restarted from the snapshot.\n         * @since v18.6.0, v16.17.0\n         */\n        addDeserializeCallback(callback: StartupSnapshotCallbackFn, data?: any): void;\n        /**\n         * This sets the entry point of the Node.js application when it is deserialized from a snapshot. This can be called only once in the snapshot building script.\n         * If called, the deserialized application no longer needs an additional entry point script to start up and will simply invoke the callback along with the deserialized\n         * data (if provided), otherwise an entry point script still needs to be provided to the deserialized application.\n         * @since v18.6.0, v16.17.0\n         */\n        setDeserializeMainFunction(callback: StartupSnapshotCallbackFn, data?: any): void;\n        /**\n         * Returns true if the Node.js instance is run to build a snapshot.\n         * @since v18.6.0, v16.17.0\n         */\n        isBuildingSnapshot(): boolean;\n    }\n    /**\n     * The `v8.startupSnapshot` interface can be used to add serialization and deserialization hooks for custom startup snapshots.\n     *\n     * ```bash\n     * $ node --snapshot-blob snapshot.blob --build-snapshot entry.js\n     * # This launches a process with the snapshot\n     * $ node --snapshot-blob snapshot.blob\n     * ```\n     *\n     * In the example above, `entry.js` can use methods from the `v8.startupSnapshot` interface to specify how to save information for custom objects\n     * in the snapshot during serialization and how the information can be used to synchronize these objects during deserialization of the snapshot.\n     * For example, if the `entry.js` contains the following script:\n     *\n     * ```js\n     * 'use strict';\n     *\n     * import fs from 'node:fs';\n     * import zlib from 'node:zlib';\n     * import path from 'node:path';\n     * import assert from 'node:assert';\n     *\n     * import v8 from 'node:v8';\n     *\n     * class BookShelf {\n     *   storage = new Map();\n     *\n     *   // Reading a series of files from directory and store them into storage.\n     *   constructor(directory, books) {\n     *     for (const book of books) {\n     *       this.storage.set(book, fs.readFileSync(path.join(directory, book)));\n     *     }\n     *   }\n     *\n     *   static compressAll(shelf) {\n     *     for (const [ book, content ] of shelf.storage) {\n     *       shelf.storage.set(book, zlib.gzipSync(content));\n     *     }\n     *   }\n     *\n     *   static decompressAll(shelf) {\n     *     for (const [ book, content ] of shelf.storage) {\n     *       shelf.storage.set(book, zlib.gunzipSync(content));\n     *     }\n     *   }\n     * }\n     *\n     * // __dirname here is where the snapshot script is placed\n     * // during snapshot building time.\n     * const shelf = new BookShelf(__dirname, [\n     *   'book1.en_US.txt',\n     *   'book1.es_ES.txt',\n     *   'book2.zh_CN.txt',\n     * ]);\n     *\n     * assert(v8.startupSnapshot.isBuildingSnapshot());\n     * // On snapshot serialization, compress the books to reduce size.\n     * v8.startupSnapshot.addSerializeCallback(BookShelf.compressAll, shelf);\n     * // On snapshot deserialization, decompress the books.\n     * v8.startupSnapshot.addDeserializeCallback(BookShelf.decompressAll, shelf);\n     * v8.startupSnapshot.setDeserializeMainFunction((shelf) => {\n     *   // process.env and process.argv are refreshed during snapshot\n     *   // deserialization.\n     *   const lang = process.env.BOOK_LANG || 'en_US';\n     *   const book = process.argv[1];\n     *   const name = `${book}.${lang}.txt`;\n     *   console.log(shelf.storage.get(name));\n     * }, shelf);\n     * ```\n     *\n     * The resulted binary will get print the data deserialized from the snapshot during start up, using the refreshed `process.env` and `process.argv` of the launched process:\n     *\n     * ```bash\n     * $ BOOK_LANG=es_ES node --snapshot-blob snapshot.blob book1\n     * # Prints content of book1.es_ES.txt deserialized from the snapshot.\n     * ```\n     *\n     * Currently the application deserialized from a user-land snapshot cannot be snapshotted again, so these APIs are only available to applications that are not deserialized from a user-land snapshot.\n     *\n     * @experimental\n     * @since v18.6.0, v16.17.0\n     */\n    const startupSnapshot: StartupSnapshot;\n}\ndeclare module \"node:v8\" {\n    export * from \"v8\";\n}\n"
        }
    ]
}