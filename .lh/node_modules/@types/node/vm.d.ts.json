{
    "sourceFile": "node_modules/@types/node/vm.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:vm` module enables compiling and running code within V8 Virtual\n * Machine contexts.\n *\n * **The `node:vm` module is not a security**\n * **mechanism. Do not use it to run untrusted code.**\n *\n * JavaScript code can be compiled and run immediately or\n * compiled, saved, and run later.\n *\n * A common use case is to run the code in a different V8 Context. This means\n * invoked code has a different global object than the invoking code.\n *\n * One can provide the context by `contextifying` an\n * object. The invoked code treats any property in the context like a\n * global variable. Any changes to global variables caused by the invoked\n * code are reflected in the context object.\n *\n * ```js\n * import vm from 'node:vm';\n *\n * const x = 1;\n *\n * const context = { x: 2 };\n * vm.createContext(context); // Contextify the object.\n *\n * const code = 'x += 40; var y = 17;';\n * // `x` and `y` are global variables in the context.\n * // Initially, x has the value 2 because that is the value of context.x.\n * vm.runInContext(code, context);\n *\n * console.log(context.x); // 42\n * console.log(context.y); // 17\n *\n * console.log(x); // 1; y is not defined.\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/vm.js)\n */\ndeclare module \"vm\" {\n    import { ImportAttributes } from \"node:module\";\n    interface Context extends NodeJS.Dict<any> {}\n    interface BaseOptions {\n        /**\n         * Specifies the filename used in stack traces produced by this script.\n         * @default ''\n         */\n        filename?: string | undefined;\n        /**\n         * Specifies the line number offset that is displayed in stack traces produced by this script.\n         * @default 0\n         */\n        lineOffset?: number | undefined;\n        /**\n         * Specifies the column number offset that is displayed in stack traces produced by this script.\n         * @default 0\n         */\n        columnOffset?: number | undefined;\n    }\n    interface ScriptOptions extends BaseOptions {\n        /**\n         * V8's code cache data for the supplied source.\n         */\n        cachedData?: Buffer | NodeJS.ArrayBufferView | undefined;\n        /** @deprecated in favor of `script.createCachedData()` */\n        produceCachedData?: boolean | undefined;\n        /**\n         * Used to specify how the modules should be loaded during the evaluation of this script when `import()` is called. This option is\n         * part of the experimental modules API. We do not recommend using it in a production environment. For detailed information, see\n         * [Support of dynamic `import()` in compilation APIs](https://nodejs.org/docs/latest-v22.x/api/vm.html#support-of-dynamic-import-in-compilation-apis).\n         */\n        importModuleDynamically?:\n            | ((specifier: string, script: Script, importAttributes: ImportAttributes) => Module | Promise<Module>)\n            | typeof constants.USE_MAIN_CONTEXT_DEFAULT_LOADER\n            | undefined;\n    }\n    interface RunningScriptOptions extends BaseOptions {\n        /**\n         * When `true`, if an `Error` occurs while compiling the `code`, the line of code causing the error is attached to the stack trace.\n         * @default true\n         */\n        displayErrors?: boolean | undefined;\n        /**\n         * Specifies the number of milliseconds to execute code before terminating execution.\n         * If execution is terminated, an `Error` will be thrown. This value must be a strictly positive integer.\n         */\n        timeout?: number | undefined;\n        /**\n         * If `true`, the execution will be terminated when `SIGINT` (Ctrl+C) is received.\n         * Existing handlers for the event that have been attached via `process.on('SIGINT')` will be disabled during script execution, but will continue to work after that.\n         * If execution is terminated, an `Error` will be thrown.\n         * @default false\n         */\n        breakOnSigint?: boolean | undefined;\n    }\n    interface RunningScriptInNewContextOptions extends RunningScriptOptions {\n        /**\n         * Human-readable name of the newly created context.\n         */\n        contextName?: CreateContextOptions[\"name\"];\n        /**\n         * Origin corresponding to the newly created context for display purposes. The origin should be formatted like a URL,\n         * but with only the scheme, host, and port (if necessary), like the value of the `url.origin` property of a `URL` object.\n         * Most notably, this string should omit the trailing slash, as that denotes a path.\n         */\n        contextOrigin?: CreateContextOptions[\"origin\"];\n        contextCodeGeneration?: CreateContextOptions[\"codeGeneration\"];\n        /**\n         * If set to `afterEvaluate`, microtasks will be run immediately after the script has run.\n         */\n        microtaskMode?: CreateContextOptions[\"microtaskMode\"];\n    }\n    interface RunningCodeOptions extends RunningScriptOptions {\n        cachedData?: ScriptOptions[\"cachedData\"];\n        importModuleDynamically?: ScriptOptions[\"importModuleDynamically\"];\n    }\n    interface RunningCodeInNewContextOptions extends RunningScriptInNewContextOptions {\n        cachedData?: ScriptOptions[\"cachedData\"];\n        importModuleDynamically?: ScriptOptions[\"importModuleDynamically\"];\n    }\n    interface CompileFunctionOptions extends BaseOptions {\n        /**\n         * Provides an optional data with V8's code cache data for the supplied source.\n         */\n        cachedData?: Buffer | undefined;\n        /**\n         * Specifies whether to produce new cache data.\n         * @default false\n         */\n        produceCachedData?: boolean | undefined;\n        /**\n         * The sandbox/context in which the said function should be compiled in.\n         */\n        parsingContext?: Context | undefined;\n        /**\n         * An array containing a collection of context extensions (objects wrapping the current scope) to be applied while compiling\n         */\n        contextExtensions?: Object[] | undefined;\n    }\n    interface CreateContextOptions {\n        /**\n         * Human-readable name of the newly created context.\n         * @default 'VM Context i' Where i is an ascending numerical index of the created context.\n         */\n        name?: string | undefined;\n        /**\n         * Corresponds to the newly created context for display purposes.\n         * The origin should be formatted like a `URL`, but with only the scheme, host, and port (if necessary),\n         * like the value of the `url.origin` property of a URL object.\n         * Most notably, this string should omit the trailing slash, as that denotes a path.\n         * @default ''\n         */\n        origin?: string | undefined;\n        codeGeneration?:\n            | {\n                /**\n                 * If set to false any calls to eval or function constructors (Function, GeneratorFunction, etc)\n                 * will throw an EvalError.\n                 * @default true\n                 */\n                strings?: boolean | undefined;\n                /**\n                 * If set to false any attempt to compile a WebAssembly module will throw a WebAssembly.CompileError.\n                 * @default true\n                 */\n                wasm?: boolean | undefined;\n            }\n            | undefined;\n        /**\n         * If set to `afterEvaluate`, microtasks will be run immediately after the script has run.\n         */\n        microtaskMode?: \"afterEvaluate\" | undefined;\n    }\n    type MeasureMemoryMode = \"summary\" | \"detailed\";\n    interface MeasureMemoryOptions {\n        /**\n         * @default 'summary'\n         */\n        mode?: MeasureMemoryMode | undefined;\n        /**\n         * @default 'default'\n         */\n        execution?: \"default\" | \"eager\" | undefined;\n    }\n    interface MemoryMeasurement {\n        total: {\n            jsMemoryEstimate: number;\n            jsMemoryRange: [number, number];\n        };\n    }\n    /**\n     * Instances of the `vm.Script` class contain precompiled scripts that can be\n     * executed in specific contexts.\n     * @since v0.3.1\n     */\n    class Script {\n        constructor(code: string, options?: ScriptOptions | string);\n        /**\n         * Runs the compiled code contained by the `vm.Script` object within the given `contextifiedObject` and returns the result. Running code does not have access\n         * to local scope.\n         *\n         * The following example compiles code that increments a global variable, sets\n         * the value of another global variable, then execute the code multiple times.\n         * The globals are contained in the `context` object.\n         *\n         * ```js\n         * import vm from 'node:vm';\n         *\n         * const context = {\n         *   animal: 'cat',\n         *   count: 2,\n         * };\n         *\n         * const script = new vm.Script('count += 1; name = \"kitty\";');\n         *\n         * vm.createContext(context);\n         * for (let i = 0; i < 10; ++i) {\n         *   script.runInContext(context);\n         * }\n         *\n         * console.log(context);\n         * // Prints: { animal: 'cat', count: 12, name: 'kitty' }\n         * ```\n         *\n         * Using the `timeout` or `breakOnSigint` options will result in new event loops\n         * and corresponding threads being started, which have a non-zero performance\n         * overhead.\n         * @since v0.3.1\n         * @param contextifiedObject A `contextified` object as returned by the `vm.createContext()` method.\n         * @return the result of the very last statement executed in the script.\n         */\n        runInContext(contextifiedObject: Context, options?: RunningScriptOptions): any;\n        /**\n         * This method is a shortcut to `script.runInContext(vm.createContext(options), options)`.\n         * It does several things at once:\n         *\n         * 1. Creates a new context.\n         * 2. If `contextObject` is an object, contextifies it with the new context.\n         *    If  `contextObject` is undefined, creates a new object and contextifies it.\n         *    If `contextObject` is `vm.constants.DONT_CONTEXTIFY`, don't contextify anything.\n         * 3. Runs the compiled code contained by the `vm.Script` object within the created context. The code\n         *    does not have access to the scope in which this method is called.\n         * 4. Returns the result.\n         *\n         * The following example compiles code that sets a global variable, then executes\n         * the code multiple times in different contexts. The globals are set on and\n         * contained within each individual `context`.\n         *\n         * ```js\n         * const vm = require('node:vm');\n         *\n         * const script = new vm.Script('globalVar = \"set\"');\n         *\n         * const contexts = [{}, {}, {}];\n         * contexts.forEach((context) => {\n         *   script.runInNewContext(context);\n         * });\n         *\n         * console.log(contexts);\n         * // Prints: [{ globalVar: 'set' }, { globalVar: 'set' }, { globalVar: 'set' }]\n         *\n         * // This would throw if the context is created from a contextified object.\n         * // vm.constants.DONT_CONTEXTIFY allows creating contexts with ordinary\n         * // global objects that can be frozen.\n         * const freezeScript = new vm.Script('Object.freeze(globalThis); globalThis;');\n         * const frozenContext = freezeScript.runInNewContext(vm.constants.DONT_CONTEXTIFY);\n         * ```\n         * @since v0.3.1\n         * @param contextObject Either `vm.constants.DONT_CONTEXTIFY` or an object that will be contextified.\n         * If `undefined`, an empty contextified object will be created for backwards compatibility.\n         * @return the result of the very last statement executed in the script.\n         */\n        runInNewContext(\n            contextObject?: Context | typeof constants.DONT_CONTEXTIFY,\n            options?: RunningScriptInNewContextOptions,\n        ): any;\n        /**\n         * Runs the compiled code contained by the `vm.Script` within the context of the\n         * current `global` object. Running code does not have access to local scope, but _does_ have access to the current `global` object.\n         *\n         * The following example compiles code that increments a `global` variable then\n         * executes that code multiple times:\n         *\n         * ```js\n         * import vm from 'node:vm';\n         *\n         * global.globalVar = 0;\n         *\n         * const script = new vm.Script('globalVar += 1', { filename: 'myfile.vm' });\n         *\n         * for (let i = 0; i < 1000; ++i) {\n         *   script.runInThisContext();\n         * }\n         *\n         * console.log(globalVar);\n         *\n         * // 1000\n         * ```\n         * @since v0.3.1\n         * @return the result of the very last statement executed in the script.\n         */\n        runInThisContext(options?: RunningScriptOptions): any;\n        /**\n         * Creates a code cache that can be used with the `Script` constructor's `cachedData` option. Returns a `Buffer`. This method may be called at any\n         * time and any number of times.\n         *\n         * The code cache of the `Script` doesn't contain any JavaScript observable\n         * states. The code cache is safe to be saved along side the script source and\n         * used to construct new `Script` instances multiple times.\n         *\n         * Functions in the `Script` source can be marked as lazily compiled and they are\n         * not compiled at construction of the `Script`. These functions are going to be\n         * compiled when they are invoked the first time. The code cache serializes the\n         * metadata that V8 currently knows about the `Script` that it can use to speed up\n         * future compilations.\n         *\n         * ```js\n         * const script = new vm.Script(`\n         * function add(a, b) {\n         *   return a + b;\n         * }\n         *\n         * const x = add(1, 2);\n         * `);\n         *\n         * const cacheWithoutAdd = script.createCachedData();\n         * // In `cacheWithoutAdd` the function `add()` is marked for full compilation\n         * // upon invocation.\n         *\n         * script.runInThisContext();\n         *\n         * const cacheWithAdd = script.createCachedData();\n         * // `cacheWithAdd` contains fully compiled function `add()`.\n         * ```\n         * @since v10.6.0\n         */\n        createCachedData(): Buffer;\n        /** @deprecated in favor of `script.createCachedData()` */\n        cachedDataProduced?: boolean | undefined;\n        /**\n         * When `cachedData` is supplied to create the `vm.Script`, this value will be set\n         * to either `true` or `false` depending on acceptance of the data by V8.\n         * Otherwise the value is `undefined`.\n         * @since v5.7.0\n         */\n        cachedDataRejected?: boolean | undefined;\n        cachedData?: Buffer | undefined;\n        /**\n         * When the script is compiled from a source that contains a source map magic\n         * comment, this property will be set to the URL of the source map.\n         *\n         * ```js\n         * import vm from 'node:vm';\n         *\n         * const script = new vm.Script(`\n         * function myFunc() {}\n         * //# sourceMappingURL=sourcemap.json\n         * `);\n         *\n         * console.log(script.sourceMapURL);\n         * // Prints: sourcemap.json\n         * ```\n         * @since v19.1.0, v18.13.0\n         */\n        sourceMapURL?: string | undefined;\n    }\n    /**\n     * If the given `contextObject` is an object, the `vm.createContext()` method will\n     * [prepare that object](https://nodejs.org/docs/latest-v22.x/api/vm.html#what-does-it-mean-to-contextify-an-object)\n     * and return a reference to it so that it can be used in calls to {@link runInContext} or\n     * [`script.runInContext()`](https://nodejs.org/docs/latest-v22.x/api/vm.html#scriptrunincontextcontextifiedobject-options).\n     * Inside such scripts, the global object will be wrapped by the `contextObject`, retaining all of its\n     * existing properties but also having the built-in objects and functions any standard\n     * [global object](https://es5.github.io/#x15.1) has. Outside of scripts run by the vm module, global\n     * variables will remain unchanged.\n     *\n     * ```js\n     * const vm = require('node:vm');\n     *\n     * global.globalVar = 3;\n     *\n     * const context = { globalVar: 1 };\n     * vm.createContext(context);\n     *\n     * vm.runInContext('globalVar *= 2;', context);\n     *\n     * console.log(context);\n     * // Prints: { globalVar: 2 }\n     *\n     * console.log(global.globalVar);\n     * // Prints: 3\n     * ```\n     *\n     * If `contextObject` is omitted (or passed explicitly as `undefined`), a new,\n     * empty contextified object will be returned.\n     *\n     * When the global object in the newly created context is contextified, it has some quirks\n     * compared to ordinary global objects. For example, it cannot be frozen. To create a context\n     * without the contextifying quirks, pass `vm.constants.DONT_CONTEXTIFY` as the `contextObject`\n     * argument. See the documentation of `vm.constants.DONT_CONTEXTIFY` for details.\n     *\n     * The `vm.createContext()` method is primarily useful for creating a single\n     * context that can be used to run multiple scripts. For instance, if emulating a\n     * web browser, the method can be used to create a single context representing a\n     * window's global object, then run all `<script>` tags together within that\n     * context.\n     *\n     * The provided `name` and `origin` of the context are made visible through the\n     * Inspector API.\n     * @since v0.3.1\n     * @param contextObject Either `vm.constants.DONT_CONTEXTIFY` or an object that will be contextified.\n     * If `undefined`, an empty contextified object will be created for backwards compatibility.\n     * @return contextified object.\n     */\n    function createContext(\n        contextObject?: Context | typeof constants.DONT_CONTEXTIFY,\n        options?: CreateContextOptions,\n    ): Context;\n    /**\n     * Returns `true` if the given `object` object has been contextified using {@link createContext},\n     * or if it's the global object of a context created using `vm.constants.DONT_CONTEXTIFY`.\n     * @since v0.11.7\n     */\n    function isContext(sandbox: Context): boolean;\n    /**\n     * The `vm.runInContext()` method compiles `code`, runs it within the context of\n     * the `contextifiedObject`, then returns the result. Running code does not have\n     * access to the local scope. The `contextifiedObject` object _must_ have been\n     * previously `contextified` using the {@link createContext} method.\n     *\n     * If `options` is a string, then it specifies the filename.\n     *\n     * The following example compiles and executes different scripts using a single `contextified` object:\n     *\n     * ```js\n     * import vm from 'node:vm';\n     *\n     * const contextObject = { globalVar: 1 };\n     * vm.createContext(contextObject);\n     *\n     * for (let i = 0; i < 10; ++i) {\n     *   vm.runInContext('globalVar *= 2;', contextObject);\n     * }\n     * console.log(contextObject);\n     * // Prints: { globalVar: 1024 }\n     * ```\n     * @since v0.3.1\n     * @param code The JavaScript code to compile and run.\n     * @param contextifiedObject The `contextified` object that will be used as the `global` when the `code` is compiled and run.\n     * @return the result of the very last statement executed in the script.\n     */\n    function runInContext(code: string, contextifiedObject: Context, options?: RunningCodeOptions | string): any;\n    /**\n     * This method is a shortcut to\n     * `(new vm.Script(code, options)).runInContext(vm.createContext(options), options)`.\n     * If `options` is a string, then it specifies the filename.\n     *\n     * It does several things at once:\n     *\n     * 1. Creates a new context.\n     * 2. If `contextObject` is an object, contextifies it with the new context.\n     *    If  `contextObject` is undefined, creates a new object and contextifies it.\n     *    If `contextObject` is `vm.constants.DONT_CONTEXTIFY`, don't contextify anything.\n     * 3. Compiles the code as a`vm.Script`\n     * 4. Runs the compield code within the created context. The code does not have access to the scope in\n     *    which this method is called.\n     * 5. Returns the result.\n     *\n     * The following example compiles and executes code that increments a global\n     * variable and sets a new one. These globals are contained in the `contextObject`.\n     *\n     * ```js\n     * const vm = require('node:vm');\n     *\n     * const contextObject = {\n     *   animal: 'cat',\n     *   count: 2,\n     * };\n     *\n     * vm.runInNewContext('count += 1; name = \"kitty\"', contextObject);\n     * console.log(contextObject);\n     * // Prints: { animal: 'cat', count: 3, name: 'kitty' }\n     *\n     * // This would throw if the context is created from a contextified object.\n     * // vm.constants.DONT_CONTEXTIFY allows creating contexts with ordinary global objects that\n     * // can be frozen.\n     * const frozenContext = vm.runInNewContext('Object.freeze(globalThis); globalThis;', vm.constants.DONT_CONTEXTIFY);\n     * ```\n     * @since v0.3.1\n     * @param code The JavaScript code to compile and run.\n     * @param contextObject Either `vm.constants.DONT_CONTEXTIFY` or an object that will be contextified.\n     * If `undefined`, an empty contextified object will be created for backwards compatibility.\n     * @return the result of the very last statement executed in the script.\n     */\n    function runInNewContext(\n        code: string,\n        contextObject?: Context | typeof constants.DONT_CONTEXTIFY,\n        options?: RunningCodeInNewContextOptions | string,\n    ): any;\n    /**\n     * `vm.runInThisContext()` compiles `code`, runs it within the context of the\n     * current `global` and returns the result. Running code does not have access to\n     * local scope, but does have access to the current `global` object.\n     *\n     * If `options` is a string, then it specifies the filename.\n     *\n     * The following example illustrates using both `vm.runInThisContext()` and\n     * the JavaScript [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) function to run the same code:\n     *\n     * ```js\n     * import vm from 'node:vm';\n     * let localVar = 'initial value';\n     *\n     * const vmResult = vm.runInThisContext('localVar = \"vm\";');\n     * console.log(`vmResult: '${vmResult}', localVar: '${localVar}'`);\n     * // Prints: vmResult: 'vm', localVar: 'initial value'\n     *\n     * const evalResult = eval('localVar = \"eval\";');\n     * console.log(`evalResult: '${evalResult}', localVar: '${localVar}'`);\n     * // Prints: evalResult: 'eval', localVar: 'eval'\n     * ```\n     *\n     * Because `vm.runInThisContext()` does not have access to the local scope, `localVar` is unchanged. In contrast,\n     * [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) _does_ have access to the\n     * local scope, so the value `localVar` is changed. In this way `vm.runInThisContext()` is much like an [indirect `eval()` call](https://es5.github.io/#x10.4.2), e.g.`(0,eval)('code')`.\n     *\n     * ## Example: Running an HTTP server within a VM\n     *\n     * When using either `script.runInThisContext()` or {@link runInThisContext}, the code is executed within the current V8 global\n     * context. The code passed to this VM context will have its own isolated scope.\n     *\n     * In order to run a simple web server using the `node:http` module the code passed\n     * to the context must either import `node:http` on its own, or have a\n     * reference to the `node:http` module passed to it. For instance:\n     *\n     * ```js\n     * 'use strict';\n     * import vm from 'node:vm';\n     *\n     * const code = `\n     * ((require) => {\n     * const http = require('node:http');\n     *\n     *   http.createServer((request, response) => {\n     *     response.writeHead(200, { 'Content-Type': 'text/plain' });\n     *     response.end('Hello World\\\\n');\n     *   }).listen(8124);\n     *\n     *   console.log('Server running at http://127.0.0.1:8124/');\n     * })`;\n     *\n     * vm.runInThisContext(code)(require);\n     * ```\n     *\n     * The `require()` in the above case shares the state with the context it is\n     * passed from. This may introduce risks when untrusted code is executed, e.g.\n     * altering objects in the context in unwanted ways.\n     * @since v0.3.1\n     * @param code The JavaScript code to compile and run.\n     * @return the result of the very last statement executed in the script.\n     */\n    function runInThisContext(code: string, options?: RunningCodeOptions | string): any;\n    /**\n     * Compiles the given code into the provided context (if no context is\n     * supplied, the current context is used), and returns it wrapped inside a\n     * function with the given `params`.\n     * @since v10.10.0\n     * @param code The body of the function to compile.\n     * @param params An array of strings containing all parameters for the function.\n     */\n    function compileFunction(\n        code: string,\n        params?: readonly string[],\n        options?: CompileFunctionOptions,\n    ): Function & {\n        cachedData?: Script[\"cachedData\"] | undefined;\n        cachedDataProduced?: Script[\"cachedDataProduced\"] | undefined;\n        cachedDataRejected?: Script[\"cachedDataRejected\"] | undefined;\n    };\n    /**\n     * Measure the memory known to V8 and used by all contexts known to the\n     * current V8 isolate, or the main context.\n     *\n     * The format of the object that the returned Promise may resolve with is\n     * specific to the V8 engine and may change from one version of V8 to the next.\n     *\n     * The returned result is different from the statistics returned by `v8.getHeapSpaceStatistics()` in that `vm.measureMemory()` measure the\n     * memory reachable by each V8 specific contexts in the current instance of\n     * the V8 engine, while the result of `v8.getHeapSpaceStatistics()` measure\n     * the memory occupied by each heap space in the current V8 instance.\n     *\n     * ```js\n     * import vm from 'node:vm';\n     * // Measure the memory used by the main context.\n     * vm.measureMemory({ mode: 'summary' })\n     *   // This is the same as vm.measureMemory()\n     *   .then((result) => {\n     *     // The current format is:\n     *     // {\n     *     //   total: {\n     *     //      jsMemoryEstimate: 2418479, jsMemoryRange: [ 2418479, 2745799 ]\n     *     //    }\n     *     // }\n     *     console.log(result);\n     *   });\n     *\n     * const context = vm.createContext({ a: 1 });\n     * vm.measureMemory({ mode: 'detailed', execution: 'eager' })\n     *   .then((result) => {\n     *     // Reference the context here so that it won't be GC'ed\n     *     // until the measurement is complete.\n     *     console.log(context.a);\n     *     // {\n     *     //   total: {\n     *     //     jsMemoryEstimate: 2574732,\n     *     //     jsMemoryRange: [ 2574732, 2904372 ]\n     *     //   },\n     *     //   current: {\n     *     //     jsMemoryEstimate: 2438996,\n     *     //     jsMemoryRange: [ 2438996, 2768636 ]\n     *     //   },\n     *     //   other: [\n     *     //     {\n     *     //       jsMemoryEstimate: 135736,\n     *     //       jsMemoryRange: [ 135736, 465376 ]\n     *     //     }\n     *     //   ]\n     *     // }\n     *     console.log(result);\n     *   });\n     * ```\n     * @since v13.10.0\n     * @experimental\n     */\n    function measureMemory(options?: MeasureMemoryOptions): Promise<MemoryMeasurement>;\n    interface ModuleEvaluateOptions {\n        timeout?: RunningScriptOptions[\"timeout\"] | undefined;\n        breakOnSigint?: RunningScriptOptions[\"breakOnSigint\"] | undefined;\n    }\n    type ModuleLinker = (\n        specifier: string,\n        referencingModule: Module,\n        extra: {\n            attributes: ImportAttributes;\n        },\n    ) => Module | Promise<Module>;\n    type ModuleStatus = \"unlinked\" | \"linking\" | \"linked\" | \"evaluating\" | \"evaluated\" | \"errored\";\n    /**\n     * This feature is only available with the `--experimental-vm-modules` command\n     * flag enabled.\n     *\n     * The `vm.Module` class provides a low-level interface for using\n     * ECMAScript modules in VM contexts. It is the counterpart of the `vm.Script` class that closely mirrors [Module Record](https://262.ecma-international.org/14.0/#sec-abstract-module-records) s as\n     * defined in the ECMAScript\n     * specification.\n     *\n     * Unlike `vm.Script` however, every `vm.Module` object is bound to a context from\n     * its creation. Operations on `vm.Module` objects are intrinsically asynchronous,\n     * in contrast with the synchronous nature of `vm.Script` objects. The use of\n     * 'async' functions can help with manipulating `vm.Module` objects.\n     *\n     * Using a `vm.Module` object requires three distinct steps: creation/parsing,\n     * linking, and evaluation. These three steps are illustrated in the following\n     * example.\n     *\n     * This implementation lies at a lower level than the `ECMAScript Module\n     * loader`. There is also no way to interact with the Loader yet, though\n     * support is planned.\n     *\n     * ```js\n     * import vm from 'node:vm';\n     *\n     * const contextifiedObject = vm.createContext({\n     *   secret: 42,\n     *   print: console.log,\n     * });\n     *\n     * // Step 1\n     * //\n     * // Create a Module by constructing a new `vm.SourceTextModule` object. This\n     * // parses the provided source text, throwing a `SyntaxError` if anything goes\n     * // wrong. By default, a Module is created in the top context. But here, we\n     * // specify `contextifiedObject` as the context this Module belongs to.\n     * //\n     * // Here, we attempt to obtain the default export from the module \"foo\", and\n     * // put it into local binding \"secret\".\n     *\n     * const bar = new vm.SourceTextModule(`\n     *   import s from 'foo';\n     *   s;\n     *   print(s);\n     * `, { context: contextifiedObject });\n     *\n     * // Step 2\n     * //\n     * // \"Link\" the imported dependencies of this Module to it.\n     * //\n     * // The provided linking callback (the \"linker\") accepts two arguments: the\n     * // parent module (`bar` in this case) and the string that is the specifier of\n     * // the imported module. The callback is expected to return a Module that\n     * // corresponds to the provided specifier, with certain requirements documented\n     * // in `module.link()`.\n     * //\n     * // If linking has not started for the returned Module, the same linker\n     * // callback will be called on the returned Module.\n     * //\n     * // Even top-level Modules without dependencies must be explicitly linked. The\n     * // callback provided would never be called, however.\n     * //\n     * // The link() method returns a Promise that will be resolved when all the\n     * // Promises returned by the linker resolve.\n     * //\n     * // Note: This is a contrived example in that the linker function creates a new\n     * // \"foo\" module every time it is called. In a full-fledged module system, a\n     * // cache would probably be used to avoid duplicated modules.\n     *\n     * async function linker(specifier, referencingModule) {\n     *   if (specifier === 'foo') {\n     *     return new vm.SourceTextModule(`\n     *       // The \"secret\" variable refers to the global variable we added to\n     *       // \"contextifiedObject\" when creating the context.\n     *       export default secret;\n     *     `, { context: referencingModule.context });\n     *\n     *     // Using `contextifiedObject` instead of `referencingModule.context`\n     *     // here would work as well.\n     *   }\n     *   throw new Error(`Unable to resolve dependency: ${specifier}`);\n     * }\n     * await bar.link(linker);\n     *\n     * // Step 3\n     * //\n     * // Evaluate the Module. The evaluate() method returns a promise which will\n     * // resolve after the module has finished evaluating.\n     *\n     * // Prints 42.\n     * await bar.evaluate();\n     * ```\n     * @since v13.0.0, v12.16.0\n     * @experimental\n     */\n    class Module {\n        /**\n         * The specifiers of all dependencies of this module. The returned array is frozen\n         * to disallow any changes to it.\n         *\n         * Corresponds to the `[[RequestedModules]]` field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s in\n         * the ECMAScript specification.\n         */\n        dependencySpecifiers: readonly string[];\n        /**\n         * If the `module.status` is `'errored'`, this property contains the exception\n         * thrown by the module during evaluation. If the status is anything else,\n         * accessing this property will result in a thrown exception.\n         *\n         * The value `undefined` cannot be used for cases where there is not a thrown\n         * exception due to possible ambiguity with `throw undefined;`.\n         *\n         * Corresponds to the `[[EvaluationError]]` field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s\n         * in the ECMAScript specification.\n         */\n        error: any;\n        /**\n         * The identifier of the current module, as set in the constructor.\n         */\n        identifier: string;\n        context: Context;\n        /**\n         * The namespace object of the module. This is only available after linking\n         * (`module.link()`) has completed.\n         *\n         * Corresponds to the [GetModuleNamespace](https://tc39.es/ecma262/#sec-getmodulenamespace) abstract operation in the ECMAScript\n         * specification.\n         */\n        namespace: Object;\n        /**\n         * The current status of the module. Will be one of:\n         *\n         * * `'unlinked'`: `module.link()` has not yet been called.\n         * * `'linking'`: `module.link()` has been called, but not all Promises returned\n         * by the linker function have been resolved yet.\n         * * `'linked'`: The module has been linked successfully, and all of its\n         * dependencies are linked, but `module.evaluate()` has not yet been called.\n         * * `'evaluating'`: The module is being evaluated through a `module.evaluate()` on\n         * itself or a parent module.\n         * * `'evaluated'`: The module has been successfully evaluated.\n         * * `'errored'`: The module has been evaluated, but an exception was thrown.\n         *\n         * Other than `'errored'`, this status string corresponds to the specification's [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)'s `[[Status]]` field. `'errored'`\n         * corresponds to `'evaluated'` in the specification, but with `[[EvaluationError]]` set to a\n         * value that is not `undefined`.\n         */\n        status: ModuleStatus;\n        /**\n         * Evaluate the module.\n         *\n         * This must be called after the module has been linked; otherwise it will reject.\n         * It could be called also when the module has already been evaluated, in which\n         * case it will either do nothing if the initial evaluation ended in success\n         * (`module.status` is `'evaluated'`) or it will re-throw the exception that the\n         * initial evaluation resulted in (`module.status` is `'errored'`).\n         *\n         * This method cannot be called while the module is being evaluated\n         * (`module.status` is `'evaluating'`).\n         *\n         * Corresponds to the [Evaluate() concrete method](https://tc39.es/ecma262/#sec-moduleevaluation) field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s in the\n         * ECMAScript specification.\n         * @return Fulfills with `undefined` upon success.\n         */\n        evaluate(options?: ModuleEvaluateOptions): Promise<void>;\n        /**\n         * Link module dependencies. This method must be called before evaluation, and\n         * can only be called once per module.\n         *\n         * The function is expected to return a `Module` object or a `Promise` that\n         * eventually resolves to a `Module` object. The returned `Module` must satisfy the\n         * following two invariants:\n         *\n         * * It must belong to the same context as the parent `Module`.\n         * * Its `status` must not be `'errored'`.\n         *\n         * If the returned `Module`'s `status` is `'unlinked'`, this method will be\n         * recursively called on the returned `Module` with the same provided `linker` function.\n         *\n         * `link()` returns a `Promise` that will either get resolved when all linking\n         * instances resolve to a valid `Module`, or rejected if the linker function either\n         * throws an exception or returns an invalid `Module`.\n         *\n         * The linker function roughly corresponds to the implementation-defined [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) abstract operation in the\n         * ECMAScript\n         * specification, with a few key differences:\n         *\n         * * The linker function is allowed to be asynchronous while [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) is synchronous.\n         *\n         * The actual [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) implementation used during module\n         * linking is one that returns the modules linked during linking. Since at\n         * that point all modules would have been fully linked already, the [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) implementation is fully synchronous per\n         * specification.\n         *\n         * Corresponds to the [Link() concrete method](https://tc39.es/ecma262/#sec-moduledeclarationlinking) field of [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records) s in\n         * the ECMAScript specification.\n         */\n        link(linker: ModuleLinker): Promise<void>;\n    }\n    interface SourceTextModuleOptions {\n        /**\n         * String used in stack traces.\n         * @default 'vm:module(i)' where i is a context-specific ascending index.\n         */\n        identifier?: string | undefined;\n        cachedData?: ScriptOptions[\"cachedData\"] | undefined;\n        context?: Context | undefined;\n        lineOffset?: BaseOptions[\"lineOffset\"] | undefined;\n        columnOffset?: BaseOptions[\"columnOffset\"] | undefined;\n        /**\n         * Called during evaluation of this module to initialize the `import.meta`.\n         */\n        initializeImportMeta?: ((meta: ImportMeta, module: SourceTextModule) => void) | undefined;\n        importModuleDynamically?: ScriptOptions[\"importModuleDynamically\"] | undefined;\n    }\n    /**\n     * This feature is only available with the `--experimental-vm-modules` command\n     * flag enabled.\n     *\n     * The `vm.SourceTextModule` class provides the [Source Text Module Record](https://tc39.es/ecma262/#sec-source-text-module-records) as\n     * defined in the ECMAScript specification.\n     * @since v9.6.0\n     * @experimental\n     */\n    class SourceTextModule extends Module {\n        /**\n         * Creates a new `SourceTextModule` instance.\n         * @param code JavaScript Module code to parse\n         */\n        constructor(code: string, options?: SourceTextModuleOptions);\n    }\n    interface SyntheticModuleOptions {\n        /**\n         * String used in stack traces.\n         * @default 'vm:module(i)' where i is a context-specific ascending index.\n         */\n        identifier?: string | undefined;\n        /**\n         * The contextified object as returned by the `vm.createContext()` method, to compile and evaluate this module in.\n         */\n        context?: Context | undefined;\n    }\n    /**\n     * This feature is only available with the `--experimental-vm-modules` command\n     * flag enabled.\n     *\n     * The `vm.SyntheticModule` class provides the [Synthetic Module Record](https://heycam.github.io/webidl/#synthetic-module-records) as\n     * defined in the WebIDL specification. The purpose of synthetic modules is to\n     * provide a generic interface for exposing non-JavaScript sources to ECMAScript\n     * module graphs.\n     *\n     * ```js\n     * import vm from 'node:vm';\n     *\n     * const source = '{ \"a\": 1 }';\n     * const module = new vm.SyntheticModule(['default'], function() {\n     *   const obj = JSON.parse(source);\n     *   this.setExport('default', obj);\n     * });\n     *\n     * // Use `module` in linking...\n     * ```\n     * @since v13.0.0, v12.16.0\n     * @experimental\n     */\n    class SyntheticModule extends Module {\n        /**\n         * Creates a new `SyntheticModule` instance.\n         * @param exportNames Array of names that will be exported from the module.\n         * @param evaluateCallback Called when the module is evaluated.\n         */\n        constructor(\n            exportNames: string[],\n            evaluateCallback: (this: SyntheticModule) => void,\n            options?: SyntheticModuleOptions,\n        );\n        /**\n         * This method is used after the module is linked to set the values of exports. If\n         * it is called before the module is linked, an `ERR_VM_MODULE_STATUS` error\n         * will be thrown.\n         *\n         * ```js\n         * import vm from 'node:vm';\n         *\n         * const m = new vm.SyntheticModule(['x'], () => {\n         *   m.setExport('x', 1);\n         * });\n         *\n         * await m.link(() => {});\n         * await m.evaluate();\n         *\n         * assert.strictEqual(m.namespace.x, 1);\n         * ```\n         * @since v13.0.0, v12.16.0\n         * @param name Name of the export to set.\n         * @param value The value to set the export to.\n         */\n        setExport(name: string, value: any): void;\n    }\n    /**\n     * Returns an object containing commonly used constants for VM operations.\n     * @since v21.7.0, v20.12.0\n     */\n    namespace constants {\n        /**\n         * A constant that can be used as the `importModuleDynamically` option to `vm.Script`\n         * and `vm.compileFunction()` so that Node.js uses the default ESM loader from the main\n         * context to load the requested module.\n         *\n         * For detailed information, see [Support of dynamic `import()` in compilation APIs](https://nodejs.org/docs/latest-v22.x/api/vm.html#support-of-dynamic-import-in-compilation-apis).\n         * @since v21.7.0, v20.12.0\n         */\n        const USE_MAIN_CONTEXT_DEFAULT_LOADER: number;\n        /**\n         * This constant, when used as the `contextObject` argument in vm APIs, instructs Node.js to create\n         * a context without wrapping its global object with another object in a Node.js-specific manner.\n         * As a result, the `globalThis` value inside the new context would behave more closely to an ordinary\n         * one.\n         *\n         * When `vm.constants.DONT_CONTEXTIFY` is used as the `contextObject` argument to {@link createContext},\n         * the returned object is a proxy-like object to the global object in the newly created context with\n         * fewer Node.js-specific quirks. It is reference equal to the `globalThis` value in the new context,\n         * can be modified from outside the context, and can be used to access built-ins in the new context directly.\n         * @since v22.8.0\n         */\n        const DONT_CONTEXTIFY: number;\n    }\n}\ndeclare module \"node:vm\" {\n    export * from \"vm\";\n}\n"
        }
    ]
}