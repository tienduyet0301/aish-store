{
    "sourceFile": "node_modules/@types/node/async_hooks.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891954707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * We strongly discourage the use of the `async_hooks` API.\n * Other APIs that can cover most of its use cases include:\n *\n * * [`AsyncLocalStorage`](https://nodejs.org/docs/latest-v22.x/api/async_context.html#class-asynclocalstorage) tracks async context\n * * [`process.getActiveResourcesInfo()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processgetactiveresourcesinfo) tracks active resources\n *\n * The `node:async_hooks` module provides an API to track asynchronous resources.\n * It can be accessed using:\n *\n * ```js\n * import async_hooks from 'node:async_hooks';\n * ```\n * @experimental\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/async_hooks.js)\n */\ndeclare module \"async_hooks\" {\n    /**\n     * ```js\n     * import { executionAsyncId } from 'node:async_hooks';\n     * import fs from 'node:fs';\n     *\n     * console.log(executionAsyncId());  // 1 - bootstrap\n     * const path = '.';\n     * fs.open(path, 'r', (err, fd) => {\n     *   console.log(executionAsyncId());  // 6 - open()\n     * });\n     * ```\n     *\n     * The ID returned from `executionAsyncId()` is related to execution timing, not\n     * causality (which is covered by `triggerAsyncId()`):\n     *\n     * ```js\n     * const server = net.createServer((conn) => {\n     *   // Returns the ID of the server, not of the new connection, because the\n     *   // callback runs in the execution scope of the server's MakeCallback().\n     *   async_hooks.executionAsyncId();\n     *\n     * }).listen(port, () => {\n     *   // Returns the ID of a TickObject (process.nextTick()) because all\n     *   // callbacks passed to .listen() are wrapped in a nextTick().\n     *   async_hooks.executionAsyncId();\n     * });\n     * ```\n     *\n     * Promise contexts may not get precise `executionAsyncIds` by default.\n     * See the section on [promise execution tracking](https://nodejs.org/docs/latest-v22.x/api/async_hooks.html#promise-execution-tracking).\n     * @since v8.1.0\n     * @return The `asyncId` of the current execution context. Useful to track when something calls.\n     */\n    function executionAsyncId(): number;\n    /**\n     * Resource objects returned by `executionAsyncResource()` are most often internal\n     * Node.js handle objects with undocumented APIs. Using any functions or properties\n     * on the object is likely to crash your application and should be avoided.\n     *\n     * Using `executionAsyncResource()` in the top-level execution context will\n     * return an empty object as there is no handle or request object to use,\n     * but having an object representing the top-level can be helpful.\n     *\n     * ```js\n     * import { open } from 'node:fs';\n     * import { executionAsyncId, executionAsyncResource } from 'node:async_hooks';\n     *\n     * console.log(executionAsyncId(), executionAsyncResource());  // 1 {}\n     * open(new URL(import.meta.url), 'r', (err, fd) => {\n     *   console.log(executionAsyncId(), executionAsyncResource());  // 7 FSReqWrap\n     * });\n     * ```\n     *\n     * This can be used to implement continuation local storage without the\n     * use of a tracking `Map` to store the metadata:\n     *\n     * ```js\n     * import { createServer } from 'node:http';\n     * import {\n     *   executionAsyncId,\n     *   executionAsyncResource,\n     *   createHook,\n     * } from 'node:async_hooks';\n     * const sym = Symbol('state'); // Private symbol to avoid pollution\n     *\n     * createHook({\n     *   init(asyncId, type, triggerAsyncId, resource) {\n     *     const cr = executionAsyncResource();\n     *     if (cr) {\n     *       resource[sym] = cr[sym];\n     *     }\n     *   },\n     * }).enable();\n     *\n     * const server = createServer((req, res) => {\n     *   executionAsyncResource()[sym] = { state: req.url };\n     *   setTimeout(function() {\n     *     res.end(JSON.stringify(executionAsyncResource()[sym]));\n     *   }, 100);\n     * }).listen(3000);\n     * ```\n     * @since v13.9.0, v12.17.0\n     * @return The resource representing the current execution. Useful to store data within the resource.\n     */\n    function executionAsyncResource(): object;\n    /**\n     * ```js\n     * const server = net.createServer((conn) => {\n     *   // The resource that caused (or triggered) this callback to be called\n     *   // was that of the new connection. Thus the return value of triggerAsyncId()\n     *   // is the asyncId of \"conn\".\n     *   async_hooks.triggerAsyncId();\n     *\n     * }).listen(port, () => {\n     *   // Even though all callbacks passed to .listen() are wrapped in a nextTick()\n     *   // the callback itself exists because the call to the server's .listen()\n     *   // was made. So the return value would be the ID of the server.\n     *   async_hooks.triggerAsyncId();\n     * });\n     * ```\n     *\n     * Promise contexts may not get valid `triggerAsyncId`s by default. See\n     * the section on [promise execution tracking](https://nodejs.org/docs/latest-v22.x/api/async_hooks.html#promise-execution-tracking).\n     * @return The ID of the resource responsible for calling the callback that is currently being executed.\n     */\n    function triggerAsyncId(): number;\n    interface HookCallbacks {\n        /**\n         * Called when a class is constructed that has the possibility to emit an asynchronous event.\n         * @param asyncId A unique ID for the async resource\n         * @param type The type of the async resource\n         * @param triggerAsyncId The unique ID of the async resource in whose execution context this async resource was created\n         * @param resource Reference to the resource representing the async operation, needs to be released during destroy\n         */\n        init?(asyncId: number, type: string, triggerAsyncId: number, resource: object): void;\n        /**\n         * When an asynchronous operation is initiated or completes a callback is called to notify the user.\n         * The before callback is called just before said callback is executed.\n         * @param asyncId the unique identifier assigned to the resource about to execute the callback.\n         */\n        before?(asyncId: number): void;\n        /**\n         * Called immediately after the callback specified in `before` is completed.\n         *\n         * If an uncaught exception occurs during execution of the callback, then `after` will run after the `'uncaughtException'` event is emitted or a `domain`'s handler runs.\n         * @param asyncId the unique identifier assigned to the resource which has executed the callback.\n         */\n        after?(asyncId: number): void;\n        /**\n         * Called when a promise has resolve() called. This may not be in the same execution id\n         * as the promise itself.\n         * @param asyncId the unique id for the promise that was resolve()d.\n         */\n        promiseResolve?(asyncId: number): void;\n        /**\n         * Called after the resource corresponding to asyncId is destroyed\n         * @param asyncId a unique ID for the async resource\n         */\n        destroy?(asyncId: number): void;\n    }\n    interface AsyncHook {\n        /**\n         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.\n         */\n        enable(): this;\n        /**\n         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.\n         */\n        disable(): this;\n    }\n    /**\n     * Registers functions to be called for different lifetime events of each async\n     * operation.\n     *\n     * The callbacks `init()`/`before()`/`after()`/`destroy()` are called for the\n     * respective asynchronous event during a resource's lifetime.\n     *\n     * All callbacks are optional. For example, if only resource cleanup needs to\n     * be tracked, then only the `destroy` callback needs to be passed. The\n     * specifics of all functions that can be passed to `callbacks` is in the `Hook Callbacks` section.\n     *\n     * ```js\n     * import { createHook } from 'node:async_hooks';\n     *\n     * const asyncHook = createHook({\n     *   init(asyncId, type, triggerAsyncId, resource) { },\n     *   destroy(asyncId) { },\n     * });\n     * ```\n     *\n     * The callbacks will be inherited via the prototype chain:\n     *\n     * ```js\n     * class MyAsyncCallbacks {\n     *   init(asyncId, type, triggerAsyncId, resource) { }\n     *   destroy(asyncId) {}\n     * }\n     *\n     * class MyAddedCallbacks extends MyAsyncCallbacks {\n     *   before(asyncId) { }\n     *   after(asyncId) { }\n     * }\n     *\n     * const asyncHook = async_hooks.createHook(new MyAddedCallbacks());\n     * ```\n     *\n     * Because promises are asynchronous resources whose lifecycle is tracked\n     * via the async hooks mechanism, the `init()`, `before()`, `after()`, and`destroy()` callbacks _must not_ be async functions that return promises.\n     * @since v8.1.0\n     * @param callbacks The `Hook Callbacks` to register\n     * @return Instance used for disabling and enabling hooks\n     */\n    function createHook(callbacks: HookCallbacks): AsyncHook;\n    interface AsyncResourceOptions {\n        /**\n         * The ID of the execution context that created this async event.\n         * @default executionAsyncId()\n         */\n        triggerAsyncId?: number | undefined;\n        /**\n         * Disables automatic `emitDestroy` when the object is garbage collected.\n         * This usually does not need to be set (even if `emitDestroy` is called\n         * manually), unless the resource's `asyncId` is retrieved and the\n         * sensitive API's `emitDestroy` is called with it.\n         * @default false\n         */\n        requireManualDestroy?: boolean | undefined;\n    }\n    /**\n     * The class `AsyncResource` is designed to be extended by the embedder's async\n     * resources. Using this, users can easily trigger the lifetime events of their\n     * own resources.\n     *\n     * The `init` hook will trigger when an `AsyncResource` is instantiated.\n     *\n     * The following is an overview of the `AsyncResource` API.\n     *\n     * ```js\n     * import { AsyncResource, executionAsyncId } from 'node:async_hooks';\n     *\n     * // AsyncResource() is meant to be extended. Instantiating a\n     * // new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n     * // async_hook.executionAsyncId() is used.\n     * const asyncResource = new AsyncResource(\n     *   type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false },\n     * );\n     *\n     * // Run a function in the execution context of the resource. This will\n     * // * establish the context of the resource\n     * // * trigger the AsyncHooks before callbacks\n     * // * call the provided function `fn` with the supplied arguments\n     * // * trigger the AsyncHooks after callbacks\n     * // * restore the original execution context\n     * asyncResource.runInAsyncScope(fn, thisArg, ...args);\n     *\n     * // Call AsyncHooks destroy callbacks.\n     * asyncResource.emitDestroy();\n     *\n     * // Return the unique ID assigned to the AsyncResource instance.\n     * asyncResource.asyncId();\n     *\n     * // Return the trigger ID for the AsyncResource instance.\n     * asyncResource.triggerAsyncId();\n     * ```\n     */\n    class AsyncResource {\n        /**\n         * AsyncResource() is meant to be extended. Instantiating a\n         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then\n         * async_hook.executionAsyncId() is used.\n         * @param type The type of async event.\n         * @param triggerAsyncId The ID of the execution context that created\n         *   this async event (default: `executionAsyncId()`), or an\n         *   AsyncResourceOptions object (since v9.3.0)\n         */\n        constructor(type: string, triggerAsyncId?: number | AsyncResourceOptions);\n        /**\n         * Binds the given function to the current execution context.\n         * @since v14.8.0, v12.19.0\n         * @param fn The function to bind to the current execution context.\n         * @param type An optional name to associate with the underlying `AsyncResource`.\n         */\n        static bind<Func extends (this: ThisArg, ...args: any[]) => any, ThisArg>(\n            fn: Func,\n            type?: string,\n            thisArg?: ThisArg,\n        ): Func;\n        /**\n         * Binds the given function to execute to this `AsyncResource`'s scope.\n         * @since v14.8.0, v12.19.0\n         * @param fn The function to bind to the current `AsyncResource`.\n         */\n        bind<Func extends (...args: any[]) => any>(fn: Func): Func;\n        /**\n         * Call the provided function with the provided arguments in the execution context\n         * of the async resource. This will establish the context, trigger the AsyncHooks\n         * before callbacks, call the function, trigger the AsyncHooks after callbacks, and\n         * then restore the original execution context.\n         * @since v9.6.0\n         * @param fn The function to call in the execution context of this async resource.\n         * @param thisArg The receiver to be used for the function call.\n         * @param args Optional arguments to pass to the function.\n         */\n        runInAsyncScope<This, Result>(\n            fn: (this: This, ...args: any[]) => Result,\n            thisArg?: This,\n            ...args: any[]\n        ): Result;\n        /**\n         * Call all `destroy` hooks. This should only ever be called once. An error will\n         * be thrown if it is called more than once. This **must** be manually called. If\n         * the resource is left to be collected by the GC then the `destroy` hooks will\n         * never be called.\n         * @return A reference to `asyncResource`.\n         */\n        emitDestroy(): this;\n        /**\n         * @return The unique `asyncId` assigned to the resource.\n         */\n        asyncId(): number;\n        /**\n         * @return The same `triggerAsyncId` that is passed to the `AsyncResource` constructor.\n         */\n        triggerAsyncId(): number;\n    }\n    /**\n     * This class creates stores that stay coherent through asynchronous operations.\n     *\n     * While you can create your own implementation on top of the `node:async_hooks` module, `AsyncLocalStorage` should be preferred as it is a performant and memory\n     * safe implementation that involves significant optimizations that are non-obvious\n     * to implement.\n     *\n     * The following example uses `AsyncLocalStorage` to build a simple logger\n     * that assigns IDs to incoming HTTP requests and includes them in messages\n     * logged within each request.\n     *\n     * ```js\n     * import http from 'node:http';\n     * import { AsyncLocalStorage } from 'node:async_hooks';\n     *\n     * const asyncLocalStorage = new AsyncLocalStorage();\n     *\n     * function logWithId(msg) {\n     *   const id = asyncLocalStorage.getStore();\n     *   console.log(`${id !== undefined ? id : '-'}:`, msg);\n     * }\n     *\n     * let idSeq = 0;\n     * http.createServer((req, res) => {\n     *   asyncLocalStorage.run(idSeq++, () => {\n     *     logWithId('start');\n     *     // Imagine any chain of async operations here\n     *     setImmediate(() => {\n     *       logWithId('finish');\n     *       res.end();\n     *     });\n     *   });\n     * }).listen(8080);\n     *\n     * http.get('http://localhost:8080');\n     * http.get('http://localhost:8080');\n     * // Prints:\n     * //   0: start\n     * //   1: start\n     * //   0: finish\n     * //   1: finish\n     * ```\n     *\n     * Each instance of `AsyncLocalStorage` maintains an independent storage context.\n     * Multiple instances can safely exist simultaneously without risk of interfering\n     * with each other's data.\n     * @since v13.10.0, v12.17.0\n     */\n    class AsyncLocalStorage<T> {\n        /**\n         * Binds the given function to the current execution context.\n         * @since v19.8.0\n         * @param fn The function to bind to the current execution context.\n         * @return A new function that calls `fn` within the captured execution context.\n         */\n        static bind<Func extends (...args: any[]) => any>(fn: Func): Func;\n        /**\n         * Captures the current execution context and returns a function that accepts a\n         * function as an argument. Whenever the returned function is called, it\n         * calls the function passed to it within the captured context.\n         *\n         * ```js\n         * const asyncLocalStorage = new AsyncLocalStorage();\n         * const runInAsyncScope = asyncLocalStorage.run(123, () => AsyncLocalStorage.snapshot());\n         * const result = asyncLocalStorage.run(321, () => runInAsyncScope(() => asyncLocalStorage.getStore()));\n         * console.log(result);  // returns 123\n         * ```\n         *\n         * AsyncLocalStorage.snapshot() can replace the use of AsyncResource for simple\n         * async context tracking purposes, for example:\n         *\n         * ```js\n         * class Foo {\n         *   #runInAsyncScope = AsyncLocalStorage.snapshot();\n         *\n         *   get() { return this.#runInAsyncScope(() => asyncLocalStorage.getStore()); }\n         * }\n         *\n         * const foo = asyncLocalStorage.run(123, () => new Foo());\n         * console.log(asyncLocalStorage.run(321, () => foo.get())); // returns 123\n         * ```\n         * @since v19.8.0\n         * @return A new function with the signature `(fn: (...args) : R, ...args) : R`.\n         */\n        static snapshot(): <R, TArgs extends any[]>(fn: (...args: TArgs) => R, ...args: TArgs) => R;\n        /**\n         * Disables the instance of `AsyncLocalStorage`. All subsequent calls\n         * to `asyncLocalStorage.getStore()` will return `undefined` until `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()` is called again.\n         *\n         * When calling `asyncLocalStorage.disable()`, all current contexts linked to the\n         * instance will be exited.\n         *\n         * Calling `asyncLocalStorage.disable()` is required before the `asyncLocalStorage` can be garbage collected. This does not apply to stores\n         * provided by the `asyncLocalStorage`, as those objects are garbage collected\n         * along with the corresponding async resources.\n         *\n         * Use this method when the `asyncLocalStorage` is not in use anymore\n         * in the current process.\n         * @since v13.10.0, v12.17.0\n         * @experimental\n         */\n        disable(): void;\n        /**\n         * Returns the current store.\n         * If called outside of an asynchronous context initialized by\n         * calling `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()`, it\n         * returns `undefined`.\n         * @since v13.10.0, v12.17.0\n         */\n        getStore(): T | undefined;\n        /**\n         * Runs a function synchronously within a context and returns its\n         * return value. The store is not accessible outside of the callback function.\n         * The store is accessible to any asynchronous operations created within the\n         * callback.\n         *\n         * The optional `args` are passed to the callback function.\n         *\n         * If the callback function throws an error, the error is thrown by `run()` too.\n         * The stacktrace is not impacted by this call and the context is exited.\n         *\n         * Example:\n         *\n         * ```js\n         * const store = { id: 2 };\n         * try {\n         *   asyncLocalStorage.run(store, () => {\n         *     asyncLocalStorage.getStore(); // Returns the store object\n         *     setTimeout(() => {\n         *       asyncLocalStorage.getStore(); // Returns the store object\n         *     }, 200);\n         *     throw new Error();\n         *   });\n         * } catch (e) {\n         *   asyncLocalStorage.getStore(); // Returns undefined\n         *   // The error will be caught here\n         * }\n         * ```\n         * @since v13.10.0, v12.17.0\n         */\n        run<R>(store: T, callback: () => R): R;\n        run<R, TArgs extends any[]>(store: T, callback: (...args: TArgs) => R, ...args: TArgs): R;\n        /**\n         * Runs a function synchronously outside of a context and returns its\n         * return value. The store is not accessible within the callback function or\n         * the asynchronous operations created within the callback. Any `getStore()` call done within the callback function will always return `undefined`.\n         *\n         * The optional `args` are passed to the callback function.\n         *\n         * If the callback function throws an error, the error is thrown by `exit()` too.\n         * The stacktrace is not impacted by this call and the context is re-entered.\n         *\n         * Example:\n         *\n         * ```js\n         * // Within a call to run\n         * try {\n         *   asyncLocalStorage.getStore(); // Returns the store object or value\n         *   asyncLocalStorage.exit(() => {\n         *     asyncLocalStorage.getStore(); // Returns undefined\n         *     throw new Error();\n         *   });\n         * } catch (e) {\n         *   asyncLocalStorage.getStore(); // Returns the same object or value\n         *   // The error will be caught here\n         * }\n         * ```\n         * @since v13.10.0, v12.17.0\n         * @experimental\n         */\n        exit<R, TArgs extends any[]>(callback: (...args: TArgs) => R, ...args: TArgs): R;\n        /**\n         * Transitions into the context for the remainder of the current\n         * synchronous execution and then persists the store through any following\n         * asynchronous calls.\n         *\n         * Example:\n         *\n         * ```js\n         * const store = { id: 1 };\n         * // Replaces previous store with the given store object\n         * asyncLocalStorage.enterWith(store);\n         * asyncLocalStorage.getStore(); // Returns the store object\n         * someAsyncOperation(() => {\n         *   asyncLocalStorage.getStore(); // Returns the same object\n         * });\n         * ```\n         *\n         * This transition will continue for the _entire_ synchronous execution.\n         * This means that if, for example, the context is entered within an event\n         * handler subsequent event handlers will also run within that context unless\n         * specifically bound to another context with an `AsyncResource`. That is why `run()` should be preferred over `enterWith()` unless there are strong reasons\n         * to use the latter method.\n         *\n         * ```js\n         * const store = { id: 1 };\n         *\n         * emitter.on('my-event', () => {\n         *   asyncLocalStorage.enterWith(store);\n         * });\n         * emitter.on('my-event', () => {\n         *   asyncLocalStorage.getStore(); // Returns the same object\n         * });\n         *\n         * asyncLocalStorage.getStore(); // Returns undefined\n         * emitter.emit('my-event');\n         * asyncLocalStorage.getStore(); // Returns the same object\n         * ```\n         * @since v13.11.0, v12.17.0\n         * @experimental\n         */\n        enterWith(store: T): void;\n    }\n}\ndeclare module \"node:async_hooks\" {\n    export * from \"async_hooks\";\n}\n"
        }
    ]
}