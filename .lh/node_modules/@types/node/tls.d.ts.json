{
    "sourceFile": "node_modules/@types/node/tls.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956218,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:tls` module provides an implementation of the Transport Layer Security\n * (TLS) and Secure Socket Layer (SSL) protocols that is built on top of OpenSSL.\n * The module can be accessed using:\n *\n * ```js\n * import tls from 'node:tls';\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/tls.js)\n */\ndeclare module \"tls\" {\n    import { X509Certificate } from \"node:crypto\";\n    import * as net from \"node:net\";\n    import * as stream from \"stream\";\n    const CLIENT_RENEG_LIMIT: number;\n    const CLIENT_RENEG_WINDOW: number;\n    interface Certificate {\n        /**\n         * Country code.\n         */\n        C: string;\n        /**\n         * Street.\n         */\n        ST: string;\n        /**\n         * Locality.\n         */\n        L: string;\n        /**\n         * Organization.\n         */\n        O: string;\n        /**\n         * Organizational unit.\n         */\n        OU: string;\n        /**\n         * Common name.\n         */\n        CN: string;\n    }\n    interface PeerCertificate {\n        /**\n         * `true` if a Certificate Authority (CA), `false` otherwise.\n         * @since v18.13.0\n         */\n        ca: boolean;\n        /**\n         * The DER encoded X.509 certificate data.\n         */\n        raw: Buffer;\n        /**\n         * The certificate subject.\n         */\n        subject: Certificate;\n        /**\n         * The certificate issuer, described in the same terms as the `subject`.\n         */\n        issuer: Certificate;\n        /**\n         * The date-time the certificate is valid from.\n         */\n        valid_from: string;\n        /**\n         * The date-time the certificate is valid to.\n         */\n        valid_to: string;\n        /**\n         * The certificate serial number, as a hex string.\n         */\n        serialNumber: string;\n        /**\n         * The SHA-1 digest of the DER encoded certificate.\n         * It is returned as a `:` separated hexadecimal string.\n         */\n        fingerprint: string;\n        /**\n         * The SHA-256 digest of the DER encoded certificate.\n         * It is returned as a `:` separated hexadecimal string.\n         */\n        fingerprint256: string;\n        /**\n         * The SHA-512 digest of the DER encoded certificate.\n         * It is returned as a `:` separated hexadecimal string.\n         */\n        fingerprint512: string;\n        /**\n         * The extended key usage, a set of OIDs.\n         */\n        ext_key_usage?: string[];\n        /**\n         * A string containing concatenated names for the subject,\n         * an alternative to the `subject` names.\n         */\n        subjectaltname?: string;\n        /**\n         * An array describing the AuthorityInfoAccess, used with OCSP.\n         */\n        infoAccess?: NodeJS.Dict<string[]>;\n        /**\n         * For RSA keys: The RSA bit size.\n         *\n         * For EC keys: The key size in bits.\n         */\n        bits?: number;\n        /**\n         * The RSA exponent, as a string in hexadecimal number notation.\n         */\n        exponent?: string;\n        /**\n         * The RSA modulus, as a hexadecimal string.\n         */\n        modulus?: string;\n        /**\n         * The public key.\n         */\n        pubkey?: Buffer;\n        /**\n         * The ASN.1 name of the OID of the elliptic curve.\n         * Well-known curves are identified by an OID.\n         * While it is unusual, it is possible that the curve\n         * is identified by its mathematical properties,\n         * in which case it will not have an OID.\n         */\n        asn1Curve?: string;\n        /**\n         * The NIST name for the elliptic curve, if it has one\n         * (not all well-known curves have been assigned names by NIST).\n         */\n        nistCurve?: string;\n    }\n    interface DetailedPeerCertificate extends PeerCertificate {\n        /**\n         * The issuer certificate object.\n         * For self-signed certificates, this may be a circular reference.\n         */\n        issuerCertificate: DetailedPeerCertificate;\n    }\n    interface CipherNameAndProtocol {\n        /**\n         * The cipher name.\n         */\n        name: string;\n        /**\n         * SSL/TLS protocol version.\n         */\n        version: string;\n        /**\n         * IETF name for the cipher suite.\n         */\n        standardName: string;\n    }\n    interface EphemeralKeyInfo {\n        /**\n         * The supported types are 'DH' and 'ECDH'.\n         */\n        type: string;\n        /**\n         * The name property is available only when type is 'ECDH'.\n         */\n        name?: string | undefined;\n        /**\n         * The size of parameter of an ephemeral key exchange.\n         */\n        size: number;\n    }\n    interface KeyObject {\n        /**\n         * Private keys in PEM format.\n         */\n        pem: string | Buffer;\n        /**\n         * Optional passphrase.\n         */\n        passphrase?: string | undefined;\n    }\n    interface PxfObject {\n        /**\n         * PFX or PKCS12 encoded private key and certificate chain.\n         */\n        buf: string | Buffer;\n        /**\n         * Optional passphrase.\n         */\n        passphrase?: string | undefined;\n    }\n    interface TLSSocketOptions extends SecureContextOptions, CommonConnectionOptions {\n        /**\n         * If true the TLS socket will be instantiated in server-mode.\n         * Defaults to false.\n         */\n        isServer?: boolean | undefined;\n        /**\n         * An optional net.Server instance.\n         */\n        server?: net.Server | undefined;\n        /**\n         * An optional Buffer instance containing a TLS session.\n         */\n        session?: Buffer | undefined;\n        /**\n         * If true, specifies that the OCSP status request extension will be\n         * added to the client hello and an 'OCSPResponse' event will be\n         * emitted on the socket before establishing a secure communication\n         */\n        requestOCSP?: boolean | undefined;\n    }\n    /**\n     * Performs transparent encryption of written data and all required TLS\n     * negotiation.\n     *\n     * Instances of `tls.TLSSocket` implement the duplex `Stream` interface.\n     *\n     * Methods that return TLS connection metadata (e.g.{@link TLSSocket.getPeerCertificate}) will only return data while the\n     * connection is open.\n     * @since v0.11.4\n     */\n    class TLSSocket extends net.Socket {\n        /**\n         * Construct a new tls.TLSSocket object from an existing TCP socket.\n         */\n        constructor(socket: net.Socket | stream.Duplex, options?: TLSSocketOptions);\n        /**\n         * This property is `true` if the peer certificate was signed by one of the CAs\n         * specified when creating the `tls.TLSSocket` instance, otherwise `false`.\n         * @since v0.11.4\n         */\n        authorized: boolean;\n        /**\n         * Returns the reason why the peer's certificate was not been verified. This\n         * property is set only when `tlsSocket.authorized === false`.\n         * @since v0.11.4\n         */\n        authorizationError: Error;\n        /**\n         * Always returns `true`. This may be used to distinguish TLS sockets from regular`net.Socket` instances.\n         * @since v0.11.4\n         */\n        encrypted: true;\n        /**\n         * String containing the selected ALPN protocol.\n         * Before a handshake has completed, this value is always null.\n         * When a handshake is completed but not ALPN protocol was selected, tlsSocket.alpnProtocol equals false.\n         */\n        alpnProtocol: string | false | null;\n        /**\n         * Returns an object representing the local certificate. The returned object has\n         * some properties corresponding to the fields of the certificate.\n         *\n         * See {@link TLSSocket.getPeerCertificate} for an example of the certificate\n         * structure.\n         *\n         * If there is no local certificate, an empty object will be returned. If the\n         * socket has been destroyed, `null` will be returned.\n         * @since v11.2.0\n         */\n        getCertificate(): PeerCertificate | object | null;\n        /**\n         * Returns an object containing information on the negotiated cipher suite.\n         *\n         * For example, a TLSv1.2 protocol with AES256-SHA cipher:\n         *\n         * ```json\n         * {\n         *     \"name\": \"AES256-SHA\",\n         *     \"standardName\": \"TLS_RSA_WITH_AES_256_CBC_SHA\",\n         *     \"version\": \"SSLv3\"\n         * }\n         * ```\n         *\n         * See [SSL\\_CIPHER\\_get\\_name](https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html) for more information.\n         * @since v0.11.4\n         */\n        getCipher(): CipherNameAndProtocol;\n        /**\n         * Returns an object representing the type, name, and size of parameter of\n         * an ephemeral key exchange in `perfect forward secrecy` on a client\n         * connection. It returns an empty object when the key exchange is not\n         * ephemeral. As this is only supported on a client socket; `null` is returned\n         * if called on a server socket. The supported types are `'DH'` and `'ECDH'`. The `name` property is available only when type is `'ECDH'`.\n         *\n         * For example: `{ type: 'ECDH', name: 'prime256v1', size: 256 }`.\n         * @since v5.0.0\n         */\n        getEphemeralKeyInfo(): EphemeralKeyInfo | object | null;\n        /**\n         * As the `Finished` messages are message digests of the complete handshake\n         * (with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can\n         * be used for external authentication procedures when the authentication\n         * provided by SSL/TLS is not desired or is not enough.\n         *\n         * Corresponds to the `SSL_get_finished` routine in OpenSSL and may be used\n         * to implement the `tls-unique` channel binding from [RFC 5929](https://tools.ietf.org/html/rfc5929).\n         * @since v9.9.0\n         * @return The latest `Finished` message that has been sent to the socket as part of a SSL/TLS handshake, or `undefined` if no `Finished` message has been sent yet.\n         */\n        getFinished(): Buffer | undefined;\n        /**\n         * Returns an object representing the peer's certificate. If the peer does not\n         * provide a certificate, an empty object will be returned. If the socket has been\n         * destroyed, `null` will be returned.\n         *\n         * If the full certificate chain was requested, each certificate will include an`issuerCertificate` property containing an object representing its issuer's\n         * certificate.\n         * @since v0.11.4\n         * @param detailed Include the full certificate chain if `true`, otherwise include just the peer's certificate.\n         * @return A certificate object.\n         */\n        getPeerCertificate(detailed: true): DetailedPeerCertificate;\n        getPeerCertificate(detailed?: false): PeerCertificate;\n        getPeerCertificate(detailed?: boolean): PeerCertificate | DetailedPeerCertificate;\n        /**\n         * As the `Finished` messages are message digests of the complete handshake\n         * (with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can\n         * be used for external authentication procedures when the authentication\n         * provided by SSL/TLS is not desired or is not enough.\n         *\n         * Corresponds to the `SSL_get_peer_finished` routine in OpenSSL and may be used\n         * to implement the `tls-unique` channel binding from [RFC 5929](https://tools.ietf.org/html/rfc5929).\n         * @since v9.9.0\n         * @return The latest `Finished` message that is expected or has actually been received from the socket as part of a SSL/TLS handshake, or `undefined` if there is no `Finished` message so\n         * far.\n         */\n        getPeerFinished(): Buffer | undefined;\n        /**\n         * Returns a string containing the negotiated SSL/TLS protocol version of the\n         * current connection. The value `'unknown'` will be returned for connected\n         * sockets that have not completed the handshaking process. The value `null` will\n         * be returned for server sockets or disconnected client sockets.\n         *\n         * Protocol versions are:\n         *\n         * * `'SSLv3'`\n         * * `'TLSv1'`\n         * * `'TLSv1.1'`\n         * * `'TLSv1.2'`\n         * * `'TLSv1.3'`\n         *\n         * See the OpenSSL [`SSL_get_version`](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version.html) documentation for more information.\n         * @since v5.7.0\n         */\n        getProtocol(): string | null;\n        /**\n         * Returns the TLS session data or `undefined` if no session was\n         * negotiated. On the client, the data can be provided to the `session` option of {@link connect} to resume the connection. On the server, it may be useful\n         * for debugging.\n         *\n         * See `Session Resumption` for more information.\n         *\n         * Note: `getSession()` works only for TLSv1.2 and below. For TLSv1.3, applications\n         * must use the `'session'` event (it also works for TLSv1.2 and below).\n         * @since v0.11.4\n         */\n        getSession(): Buffer | undefined;\n        /**\n         * See [SSL\\_get\\_shared\\_sigalgs](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs.html) for more information.\n         * @since v12.11.0\n         * @return List of signature algorithms shared between the server and the client in the order of decreasing preference.\n         */\n        getSharedSigalgs(): string[];\n        /**\n         * For a client, returns the TLS session ticket if one is available, or`undefined`. For a server, always returns `undefined`.\n         *\n         * It may be useful for debugging.\n         *\n         * See `Session Resumption` for more information.\n         * @since v0.11.4\n         */\n        getTLSTicket(): Buffer | undefined;\n        /**\n         * See `Session Resumption` for more information.\n         * @since v0.5.6\n         * @return `true` if the session was reused, `false` otherwise.\n         */\n        isSessionReused(): boolean;\n        /**\n         * The `tlsSocket.renegotiate()` method initiates a TLS renegotiation process.\n         * Upon completion, the `callback` function will be passed a single argument\n         * that is either an `Error` (if the request failed) or `null`.\n         *\n         * This method can be used to request a peer's certificate after the secure\n         * connection has been established.\n         *\n         * When running as the server, the socket will be destroyed with an error after `handshakeTimeout` timeout.\n         *\n         * For TLSv1.3, renegotiation cannot be initiated, it is not supported by the\n         * protocol.\n         * @since v0.11.8\n         * @param callback If `renegotiate()` returned `true`, callback is attached once to the `'secure'` event. If `renegotiate()` returned `false`, `callback` will be called in the next tick with\n         * an error, unless the `tlsSocket` has been destroyed, in which case `callback` will not be called at all.\n         * @return `true` if renegotiation was initiated, `false` otherwise.\n         */\n        renegotiate(\n            options: {\n                rejectUnauthorized?: boolean | undefined;\n                requestCert?: boolean | undefined;\n            },\n            callback: (err: Error | null) => void,\n        ): undefined | boolean;\n        /**\n         * The `tlsSocket.setKeyCert()` method sets the private key and certificate to use for the socket.\n         * This is mainly useful if you wish to select a server certificate from a TLS server's `ALPNCallback`.\n         * @since v22.5.0, v20.17.0\n         * @param context An object containing at least `key` and `cert` properties from the {@link createSecureContext()} `options`,\n         * or a TLS context object created with {@link createSecureContext()} itself.\n         */\n        setKeyCert(context: SecureContextOptions | SecureContext): void;\n        /**\n         * The `tlsSocket.setMaxSendFragment()` method sets the maximum TLS fragment size.\n         * Returns `true` if setting the limit succeeded; `false` otherwise.\n         *\n         * Smaller fragment sizes decrease the buffering latency on the client: larger\n         * fragments are buffered by the TLS layer until the entire fragment is received\n         * and its integrity is verified; large fragments can span multiple roundtrips\n         * and their processing can be delayed due to packet loss or reordering. However,\n         * smaller fragments add extra TLS framing bytes and CPU overhead, which may\n         * decrease overall server throughput.\n         * @since v0.11.11\n         * @param [size=16384] The maximum TLS fragment size. The maximum value is `16384`.\n         */\n        setMaxSendFragment(size: number): boolean;\n        /**\n         * Disables TLS renegotiation for this `TLSSocket` instance. Once called, attempts\n         * to renegotiate will trigger an `'error'` event on the `TLSSocket`.\n         * @since v8.4.0\n         */\n        disableRenegotiation(): void;\n        /**\n         * When enabled, TLS packet trace information is written to `stderr`. This can be\n         * used to debug TLS connection problems.\n         *\n         * The format of the output is identical to the output of`openssl s_client -trace` or `openssl s_server -trace`. While it is produced by\n         * OpenSSL's `SSL_trace()` function, the format is undocumented, can change\n         * without notice, and should not be relied on.\n         * @since v12.2.0\n         */\n        enableTrace(): void;\n        /**\n         * Returns the peer certificate as an `X509Certificate` object.\n         *\n         * If there is no peer certificate, or the socket has been destroyed,`undefined` will be returned.\n         * @since v15.9.0\n         */\n        getPeerX509Certificate(): X509Certificate | undefined;\n        /**\n         * Returns the local certificate as an `X509Certificate` object.\n         *\n         * If there is no local certificate, or the socket has been destroyed,`undefined` will be returned.\n         * @since v15.9.0\n         */\n        getX509Certificate(): X509Certificate | undefined;\n        /**\n         * Keying material is used for validations to prevent different kind of attacks in\n         * network protocols, for example in the specifications of IEEE 802.1X.\n         *\n         * Example\n         *\n         * ```js\n         * const keyingMaterial = tlsSocket.exportKeyingMaterial(\n         *   128,\n         *   'client finished');\n         *\n         * /*\n         *  Example return value of keyingMaterial:\n         *  <Buffer 76 26 af 99 c5 56 8e 42 09 91 ef 9f 93 cb ad 6c 7b 65 f8 53 f1 d8 d9\n         *     12 5a 33 b8 b5 25 df 7b 37 9f e0 e2 4f b8 67 83 a3 2f cd 5d 41 42 4c 91\n         *     74 ef 2c ... 78 more bytes>\n         *\n         * ```\n         *\n         * See the OpenSSL [`SSL_export_keying_material`](https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material.html) documentation for more\n         * information.\n         * @since v13.10.0, v12.17.0\n         * @param length number of bytes to retrieve from keying material\n         * @param label an application specific label, typically this will be a value from the [IANA Exporter Label\n         * Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels).\n         * @param context Optionally provide a context.\n         * @return requested bytes of the keying material\n         */\n        exportKeyingMaterial(length: number, label: string, context: Buffer): Buffer;\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        addListener(event: \"secureConnect\", listener: () => void): this;\n        addListener(event: \"session\", listener: (session: Buffer) => void): this;\n        addListener(event: \"keylog\", listener: (line: Buffer) => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"OCSPResponse\", response: Buffer): boolean;\n        emit(event: \"secureConnect\"): boolean;\n        emit(event: \"session\", session: Buffer): boolean;\n        emit(event: \"keylog\", line: Buffer): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        on(event: \"secureConnect\", listener: () => void): this;\n        on(event: \"session\", listener: (session: Buffer) => void): this;\n        on(event: \"keylog\", listener: (line: Buffer) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        once(event: \"secureConnect\", listener: () => void): this;\n        once(event: \"session\", listener: (session: Buffer) => void): this;\n        once(event: \"keylog\", listener: (line: Buffer) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependListener(event: \"secureConnect\", listener: () => void): this;\n        prependListener(event: \"session\", listener: (session: Buffer) => void): this;\n        prependListener(event: \"keylog\", listener: (line: Buffer) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"OCSPResponse\", listener: (response: Buffer) => void): this;\n        prependOnceListener(event: \"secureConnect\", listener: () => void): this;\n        prependOnceListener(event: \"session\", listener: (session: Buffer) => void): this;\n        prependOnceListener(event: \"keylog\", listener: (line: Buffer) => void): this;\n    }\n    interface CommonConnectionOptions {\n        /**\n         * An optional TLS context object from tls.createSecureContext()\n         */\n        secureContext?: SecureContext | undefined;\n        /**\n         * When enabled, TLS packet trace information is written to `stderr`. This can be\n         * used to debug TLS connection problems.\n         * @default false\n         */\n        enableTrace?: boolean | undefined;\n        /**\n         * If true the server will request a certificate from clients that\n         * connect and attempt to verify that certificate. Defaults to\n         * false.\n         */\n        requestCert?: boolean | undefined;\n        /**\n         * An array of strings or a Buffer naming possible ALPN protocols.\n         * (Protocols should be ordered by their priority.)\n         */\n        ALPNProtocols?: string[] | Uint8Array[] | Uint8Array | undefined;\n        /**\n         * SNICallback(servername, cb) <Function> A function that will be\n         * called if the client supports SNI TLS extension. Two arguments\n         * will be passed when called: servername and cb. SNICallback should\n         * invoke cb(null, ctx), where ctx is a SecureContext instance.\n         * (tls.createSecureContext(...) can be used to get a proper\n         * SecureContext.) If SNICallback wasn't provided the default callback\n         * with high-level API will be used (see below).\n         */\n        SNICallback?: ((servername: string, cb: (err: Error | null, ctx?: SecureContext) => void) => void) | undefined;\n        /**\n         * If true the server will reject any connection which is not\n         * authorized with the list of supplied CAs. This option only has an\n         * effect if requestCert is true.\n         * @default true\n         */\n        rejectUnauthorized?: boolean | undefined;\n    }\n    interface TlsOptions extends SecureContextOptions, CommonConnectionOptions, net.ServerOpts {\n        /**\n         * Abort the connection if the SSL/TLS handshake does not finish in the\n         * specified number of milliseconds. A 'tlsClientError' is emitted on\n         * the tls.Server object whenever a handshake times out. Default:\n         * 120000 (120 seconds).\n         */\n        handshakeTimeout?: number | undefined;\n        /**\n         * The number of seconds after which a TLS session created by the\n         * server will no longer be resumable. See Session Resumption for more\n         * information. Default: 300.\n         */\n        sessionTimeout?: number | undefined;\n        /**\n         * 48-bytes of cryptographically strong pseudo-random data.\n         */\n        ticketKeys?: Buffer | undefined;\n        /**\n         * @param socket\n         * @param identity identity parameter sent from the client.\n         * @return pre-shared key that must either be\n         * a buffer or `null` to stop the negotiation process. Returned PSK must be\n         * compatible with the selected cipher's digest.\n         *\n         * When negotiating TLS-PSK (pre-shared keys), this function is called\n         * with the identity provided by the client.\n         * If the return value is `null` the negotiation process will stop and an\n         * \"unknown_psk_identity\" alert message will be sent to the other party.\n         * If the server wishes to hide the fact that the PSK identity was not known,\n         * the callback must provide some random data as `psk` to make the connection\n         * fail with \"decrypt_error\" before negotiation is finished.\n         * PSK ciphers are disabled by default, and using TLS-PSK thus\n         * requires explicitly specifying a cipher suite with the `ciphers` option.\n         * More information can be found in the RFC 4279.\n         */\n        pskCallback?(socket: TLSSocket, identity: string): DataView | NodeJS.TypedArray | null;\n        /**\n         * hint to send to a client to help\n         * with selecting the identity during TLS-PSK negotiation. Will be ignored\n         * in TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be\n         * emitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.\n         */\n        pskIdentityHint?: string | undefined;\n    }\n    interface PSKCallbackNegotation {\n        psk: DataView | NodeJS.TypedArray;\n        identity: string;\n    }\n    interface ConnectionOptions extends SecureContextOptions, CommonConnectionOptions {\n        host?: string | undefined;\n        port?: number | undefined;\n        path?: string | undefined; // Creates unix socket connection to path. If this option is specified, `host` and `port` are ignored.\n        socket?: stream.Duplex | undefined; // Establish secure connection on a given socket rather than creating a new socket\n        checkServerIdentity?: typeof checkServerIdentity | undefined;\n        servername?: string | undefined; // SNI TLS Extension\n        session?: Buffer | undefined;\n        minDHSize?: number | undefined;\n        lookup?: net.LookupFunction | undefined;\n        timeout?: number | undefined;\n        /**\n         * When negotiating TLS-PSK (pre-shared keys), this function is called\n         * with optional identity `hint` provided by the server or `null`\n         * in case of TLS 1.3 where `hint` was removed.\n         * It will be necessary to provide a custom `tls.checkServerIdentity()`\n         * for the connection as the default one will try to check hostname/IP\n         * of the server against the certificate but that's not applicable for PSK\n         * because there won't be a certificate present.\n         * More information can be found in the RFC 4279.\n         *\n         * @param hint message sent from the server to help client\n         * decide which identity to use during negotiation.\n         * Always `null` if TLS 1.3 is used.\n         * @returns Return `null` to stop the negotiation process. `psk` must be\n         * compatible with the selected cipher's digest.\n         * `identity` must use UTF-8 encoding.\n         */\n        pskCallback?(hint: string | null): PSKCallbackNegotation | null;\n    }\n    /**\n     * Accepts encrypted connections using TLS or SSL.\n     * @since v0.3.2\n     */\n    class Server extends net.Server {\n        constructor(secureConnectionListener?: (socket: TLSSocket) => void);\n        constructor(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void);\n        /**\n         * The `server.addContext()` method adds a secure context that will be used if\n         * the client request's SNI name matches the supplied `hostname` (or wildcard).\n         *\n         * When there are multiple matching contexts, the most recently added one is\n         * used.\n         * @since v0.5.3\n         * @param hostname A SNI host name or wildcard (e.g. `'*'`)\n         * @param context An object containing any of the possible properties from the {@link createSecureContext} `options` arguments (e.g. `key`, `cert`, `ca`, etc), or a TLS context object created\n         * with {@link createSecureContext} itself.\n         */\n        addContext(hostname: string, context: SecureContextOptions): void;\n        /**\n         * Returns the session ticket keys.\n         *\n         * See `Session Resumption` for more information.\n         * @since v3.0.0\n         * @return A 48-byte buffer containing the session ticket keys.\n         */\n        getTicketKeys(): Buffer;\n        /**\n         * The `server.setSecureContext()` method replaces the secure context of an\n         * existing server. Existing connections to the server are not interrupted.\n         * @since v11.0.0\n         * @param options An object containing any of the possible properties from the {@link createSecureContext} `options` arguments (e.g. `key`, `cert`, `ca`, etc).\n         */\n        setSecureContext(options: SecureContextOptions): void;\n        /**\n         * Sets the session ticket keys.\n         *\n         * Changes to the ticket keys are effective only for future server connections.\n         * Existing or currently pending server connections will use the previous keys.\n         *\n         * See `Session Resumption` for more information.\n         * @since v3.0.0\n         * @param keys A 48-byte buffer containing the session ticket keys.\n         */\n        setTicketKeys(keys: Buffer): void;\n        /**\n         * events.EventEmitter\n         * 1. tlsClientError\n         * 2. newSession\n         * 3. OCSPRequest\n         * 4. resumeSession\n         * 5. secureConnection\n         * 6. keylog\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        addListener(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void,\n        ): this;\n        addListener(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        addListener(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void,\n        ): this;\n        addListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        addListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"tlsClientError\", err: Error, tlsSocket: TLSSocket): boolean;\n        emit(event: \"newSession\", sessionId: Buffer, sessionData: Buffer, callback: () => void): boolean;\n        emit(\n            event: \"OCSPRequest\",\n            certificate: Buffer,\n            issuer: Buffer,\n            callback: (err: Error | null, resp: Buffer) => void,\n        ): boolean;\n        emit(\n            event: \"resumeSession\",\n            sessionId: Buffer,\n            callback: (err: Error | null, sessionData: Buffer | null) => void,\n        ): boolean;\n        emit(event: \"secureConnection\", tlsSocket: TLSSocket): boolean;\n        emit(event: \"keylog\", line: Buffer, tlsSocket: TLSSocket): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        on(event: \"newSession\", listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void): this;\n        on(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        on(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void,\n        ): this;\n        on(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        on(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        once(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void,\n        ): this;\n        once(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        once(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void,\n        ): this;\n        once(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        once(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependListener(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void,\n        ): this;\n        prependListener(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        prependListener(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void,\n        ): this;\n        prependListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        prependListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"tlsClientError\", listener: (err: Error, tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(\n            event: \"newSession\",\n            listener: (sessionId: Buffer, sessionData: Buffer, callback: () => void) => void,\n        ): this;\n        prependOnceListener(\n            event: \"OCSPRequest\",\n            listener: (\n                certificate: Buffer,\n                issuer: Buffer,\n                callback: (err: Error | null, resp: Buffer) => void,\n            ) => void,\n        ): this;\n        prependOnceListener(\n            event: \"resumeSession\",\n            listener: (sessionId: Buffer, callback: (err: Error | null, sessionData: Buffer | null) => void) => void,\n        ): this;\n        prependOnceListener(event: \"secureConnection\", listener: (tlsSocket: TLSSocket) => void): this;\n        prependOnceListener(event: \"keylog\", listener: (line: Buffer, tlsSocket: TLSSocket) => void): this;\n    }\n    /**\n     * @deprecated since v0.11.3 Use `tls.TLSSocket` instead.\n     */\n    interface SecurePair {\n        encrypted: TLSSocket;\n        cleartext: TLSSocket;\n    }\n    type SecureVersion = \"TLSv1.3\" | \"TLSv1.2\" | \"TLSv1.1\" | \"TLSv1\";\n    interface SecureContextOptions {\n        /**\n         * If set, this will be called when a client opens a connection using the ALPN extension.\n         * One argument will be passed to the callback: an object containing `servername` and `protocols` fields,\n         * respectively containing the server name from the SNI extension (if any) and an array of\n         * ALPN protocol name strings. The callback must return either one of the strings listed in `protocols`,\n         * which will be returned to the client as the selected ALPN protocol, or `undefined`,\n         * to reject the connection with a fatal alert. If a string is returned that does not match one of\n         * the client's ALPN protocols, an error will be thrown.\n         * This option cannot be used with the `ALPNProtocols` option, and setting both options will throw an error.\n         */\n        ALPNCallback?: ((arg: { servername: string; protocols: string[] }) => string | undefined) | undefined;\n        /**\n         * Treat intermediate (non-self-signed)\n         * certificates in the trust CA certificate list as trusted.\n         * @since v22.9.0, v20.18.0\n         */\n        allowPartialTrustChain?: boolean | undefined;\n        /**\n         * Optionally override the trusted CA certificates. Default is to trust\n         * the well-known CAs curated by Mozilla. Mozilla's CAs are completely\n         * replaced when CAs are explicitly specified using this option.\n         */\n        ca?: string | Buffer | Array<string | Buffer> | undefined;\n        /**\n         *  Cert chains in PEM format. One cert chain should be provided per\n         *  private key. Each cert chain should consist of the PEM formatted\n         *  certificate for a provided private key, followed by the PEM\n         *  formatted intermediate certificates (if any), in order, and not\n         *  including the root CA (the root CA must be pre-known to the peer,\n         *  see ca). When providing multiple cert chains, they do not have to\n         *  be in the same order as their private keys in key. If the\n         *  intermediate certificates are not provided, the peer will not be\n         *  able to validate the certificate, and the handshake will fail.\n         */\n        cert?: string | Buffer | Array<string | Buffer> | undefined;\n        /**\n         *  Colon-separated list of supported signature algorithms. The list\n         *  can contain digest algorithms (SHA256, MD5 etc.), public key\n         *  algorithms (RSA-PSS, ECDSA etc.), combination of both (e.g\n         *  'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).\n         */\n        sigalgs?: string | undefined;\n        /**\n         * Cipher suite specification, replacing the default. For more\n         * information, see modifying the default cipher suite. Permitted\n         * ciphers can be obtained via tls.getCiphers(). Cipher names must be\n         * uppercased in order for OpenSSL to accept them.\n         */\n        ciphers?: string | undefined;\n        /**\n         * Name of an OpenSSL engine which can provide the client certificate.\n         * @deprecated\n         */\n        clientCertEngine?: string | undefined;\n        /**\n         * PEM formatted CRLs (Certificate Revocation Lists).\n         */\n        crl?: string | Buffer | Array<string | Buffer> | undefined;\n        /**\n         * `'auto'` or custom Diffie-Hellman parameters, required for non-ECDHE perfect forward secrecy.\n         * If omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available.\n         * ECDHE-based perfect forward secrecy will still be available.\n         */\n        dhparam?: string | Buffer | undefined;\n        /**\n         * A string describing a named curve or a colon separated list of curve\n         * NIDs or names, for example P-521:P-384:P-256, to use for ECDH key\n         * agreement. Set to auto to select the curve automatically. Use\n         * crypto.getCurves() to obtain a list of available curve names. On\n         * recent releases, openssl ecparam -list_curves will also display the\n         * name and description of each available elliptic curve. Default:\n         * tls.DEFAULT_ECDH_CURVE.\n         */\n        ecdhCurve?: string | undefined;\n        /**\n         * Attempt to use the server's cipher suite preferences instead of the\n         * client's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be\n         * set in secureOptions\n         */\n        honorCipherOrder?: boolean | undefined;\n        /**\n         * Private keys in PEM format. PEM allows the option of private keys\n         * being encrypted. Encrypted keys will be decrypted with\n         * options.passphrase. Multiple keys using different algorithms can be\n         * provided either as an array of unencrypted key strings or buffers,\n         * or an array of objects in the form {pem: <string|buffer>[,\n         * passphrase: <string>]}. The object form can only occur in an array.\n         * object.passphrase is optional. Encrypted keys will be decrypted with\n         * object.passphrase if provided, or options.passphrase if it is not.\n         */\n        key?: string | Buffer | Array<string | Buffer | KeyObject> | undefined;\n        /**\n         * Name of an OpenSSL engine to get private key from. Should be used\n         * together with privateKeyIdentifier.\n         * @deprecated\n         */\n        privateKeyEngine?: string | undefined;\n        /**\n         * Identifier of a private key managed by an OpenSSL engine. Should be\n         * used together with privateKeyEngine. Should not be set together with\n         * key, because both options define a private key in different ways.\n         * @deprecated\n         */\n        privateKeyIdentifier?: string | undefined;\n        /**\n         * Optionally set the maximum TLS version to allow. One\n         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n         * `secureProtocol` option, use one or the other.\n         * **Default:** `'TLSv1.3'`, unless changed using CLI options. Using\n         * `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to\n         * `'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.\n         */\n        maxVersion?: SecureVersion | undefined;\n        /**\n         * Optionally set the minimum TLS version to allow. One\n         * of `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n         * `secureProtocol` option, use one or the other.  It is not recommended to use\n         * less than TLSv1.2, but it may be required for interoperability.\n         * **Default:** `'TLSv1.2'`, unless changed using CLI options. Using\n         * `--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to\n         * `'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to\n         * 'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.\n         */\n        minVersion?: SecureVersion | undefined;\n        /**\n         * Shared passphrase used for a single private key and/or a PFX.\n         */\n        passphrase?: string | undefined;\n        /**\n         * PFX or PKCS12 encoded private key and certificate chain. pfx is an\n         * alternative to providing key and cert individually. PFX is usually\n         * encrypted, if it is, passphrase will be used to decrypt it. Multiple\n         * PFX can be provided either as an array of unencrypted PFX buffers,\n         * or an array of objects in the form {buf: <string|buffer>[,\n         * passphrase: <string>]}. The object form can only occur in an array.\n         * object.passphrase is optional. Encrypted PFX will be decrypted with\n         * object.passphrase if provided, or options.passphrase if it is not.\n         */\n        pfx?: string | Buffer | Array<string | Buffer | PxfObject> | undefined;\n        /**\n         * Optionally affect the OpenSSL protocol behavior, which is not\n         * usually necessary. This should be used carefully if at all! Value is\n         * a numeric bitmask of the SSL_OP_* options from OpenSSL Options\n         */\n        secureOptions?: number | undefined; // Value is a numeric bitmask of the `SSL_OP_*` options\n        /**\n         * Legacy mechanism to select the TLS protocol version to use, it does\n         * not support independent control of the minimum and maximum version,\n         * and does not support limiting the protocol to TLSv1.3. Use\n         * minVersion and maxVersion instead. The possible values are listed as\n         * SSL_METHODS, use the function names as strings. For example, use\n         * 'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\n         * any TLS protocol version up to TLSv1.3. It is not recommended to use\n         * TLS versions less than 1.2, but it may be required for\n         * interoperability. Default: none, see minVersion.\n         */\n        secureProtocol?: string | undefined;\n        /**\n         * Opaque identifier used by servers to ensure session state is not\n         * shared between applications. Unused by clients.\n         */\n        sessionIdContext?: string | undefined;\n        /**\n         * 48-bytes of cryptographically strong pseudo-random data.\n         * See Session Resumption for more information.\n         */\n        ticketKeys?: Buffer | undefined;\n        /**\n         * The number of seconds after which a TLS session created by the\n         * server will no longer be resumable. See Session Resumption for more\n         * information. Default: 300.\n         */\n        sessionTimeout?: number | undefined;\n    }\n    interface SecureContext {\n        context: any;\n    }\n    /**\n     * Verifies the certificate `cert` is issued to `hostname`.\n     *\n     * Returns [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, populating it with `reason`, `host`, and `cert` on\n     * failure. On success, returns [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type).\n     *\n     * This function is intended to be used in combination with the`checkServerIdentity` option that can be passed to {@link connect} and as\n     * such operates on a `certificate object`. For other purposes, consider using `x509.checkHost()` instead.\n     *\n     * This function can be overwritten by providing an alternative function as the `options.checkServerIdentity` option that is passed to `tls.connect()`. The\n     * overwriting function can call `tls.checkServerIdentity()` of course, to augment\n     * the checks done with additional verification.\n     *\n     * This function is only called if the certificate passed all other checks, such as\n     * being issued by trusted CA (`options.ca`).\n     *\n     * Earlier versions of Node.js incorrectly accepted certificates for a given`hostname` if a matching `uniformResourceIdentifier` subject alternative name\n     * was present (see [CVE-2021-44531](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531)). Applications that wish to accept`uniformResourceIdentifier` subject alternative names can use\n     * a custom `options.checkServerIdentity` function that implements the desired behavior.\n     * @since v0.8.4\n     * @param hostname The host name or IP address to verify the certificate against.\n     * @param cert A `certificate object` representing the peer's certificate.\n     */\n    function checkServerIdentity(hostname: string, cert: PeerCertificate): Error | undefined;\n    /**\n     * Creates a new {@link Server}. The `secureConnectionListener`, if provided, is\n     * automatically set as a listener for the `'secureConnection'` event.\n     *\n     * The `ticketKeys` options is automatically shared between `node:cluster` module\n     * workers.\n     *\n     * The following illustrates a simple echo server:\n     *\n     * ```js\n     * import tls from 'node:tls';\n     * import fs from 'node:fs';\n     *\n     * const options = {\n     *   key: fs.readFileSync('server-key.pem'),\n     *   cert: fs.readFileSync('server-cert.pem'),\n     *\n     *   // This is necessary only if using client certificate authentication.\n     *   requestCert: true,\n     *\n     *   // This is necessary only if the client uses a self-signed certificate.\n     *   ca: [ fs.readFileSync('client-cert.pem') ],\n     * };\n     *\n     * const server = tls.createServer(options, (socket) => {\n     *   console.log('server connected',\n     *               socket.authorized ? 'authorized' : 'unauthorized');\n     *   socket.write('welcome!\\n');\n     *   socket.setEncoding('utf8');\n     *   socket.pipe(socket);\n     * });\n     * server.listen(8000, () => {\n     *   console.log('server bound');\n     * });\n     * ```\n     *\n     * The server can be tested by connecting to it using the example client from {@link connect}.\n     * @since v0.3.2\n     */\n    function createServer(secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    function createServer(options: TlsOptions, secureConnectionListener?: (socket: TLSSocket) => void): Server;\n    /**\n     * The `callback` function, if specified, will be added as a listener for the `'secureConnect'` event.\n     *\n     * `tls.connect()` returns a {@link TLSSocket} object.\n     *\n     * Unlike the `https` API, `tls.connect()` does not enable the\n     * SNI (Server Name Indication) extension by default, which may cause some\n     * servers to return an incorrect certificate or reject the connection\n     * altogether. To enable SNI, set the `servername` option in addition\n     * to `host`.\n     *\n     * The following illustrates a client for the echo server example from {@link createServer}:\n     *\n     * ```js\n     * // Assumes an echo server that is listening on port 8000.\n     * import tls from 'node:tls';\n     * import fs from 'node:fs';\n     *\n     * const options = {\n     *   // Necessary only if the server requires client certificate authentication.\n     *   key: fs.readFileSync('client-key.pem'),\n     *   cert: fs.readFileSync('client-cert.pem'),\n     *\n     *   // Necessary only if the server uses a self-signed certificate.\n     *   ca: [ fs.readFileSync('server-cert.pem') ],\n     *\n     *   // Necessary only if the server's cert isn't for \"localhost\".\n     *   checkServerIdentity: () => { return null; },\n     * };\n     *\n     * const socket = tls.connect(8000, options, () => {\n     *   console.log('client connected',\n     *               socket.authorized ? 'authorized' : 'unauthorized');\n     *   process.stdin.pipe(socket);\n     *   process.stdin.resume();\n     * });\n     * socket.setEncoding('utf8');\n     * socket.on('data', (data) => {\n     *   console.log(data);\n     * });\n     * socket.on('end', () => {\n     *   console.log('server ends connection');\n     * });\n     * ```\n     * @since v0.11.3\n     */\n    function connect(options: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    function connect(\n        port: number,\n        host?: string,\n        options?: ConnectionOptions,\n        secureConnectListener?: () => void,\n    ): TLSSocket;\n    function connect(port: number, options?: ConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n    /**\n     * Creates a new secure pair object with two streams, one of which reads and writes\n     * the encrypted data and the other of which reads and writes the cleartext data.\n     * Generally, the encrypted stream is piped to/from an incoming encrypted data\n     * stream and the cleartext one is used as a replacement for the initial encrypted\n     * stream.\n     *\n     * `tls.createSecurePair()` returns a `tls.SecurePair` object with `cleartext` and `encrypted` stream properties.\n     *\n     * Using `cleartext` has the same API as {@link TLSSocket}.\n     *\n     * The `tls.createSecurePair()` method is now deprecated in favor of`tls.TLSSocket()`. For example, the code:\n     *\n     * ```js\n     * pair = tls.createSecurePair(// ... );\n     * pair.encrypted.pipe(socket);\n     * socket.pipe(pair.encrypted);\n     * ```\n     *\n     * can be replaced by:\n     *\n     * ```js\n     * secureSocket = tls.TLSSocket(socket, options);\n     * ```\n     *\n     * where `secureSocket` has the same API as `pair.cleartext`.\n     * @since v0.3.2\n     * @deprecated Since v0.11.3 - Use {@link TLSSocket} instead.\n     * @param context A secure context object as returned by `tls.createSecureContext()`\n     * @param isServer `true` to specify that this TLS connection should be opened as a server.\n     * @param requestCert `true` to specify whether a server should request a certificate from a connecting client. Only applies when `isServer` is `true`.\n     * @param rejectUnauthorized If not `false` a server automatically reject clients with invalid certificates. Only applies when `isServer` is `true`.\n     */\n    function createSecurePair(\n        context?: SecureContext,\n        isServer?: boolean,\n        requestCert?: boolean,\n        rejectUnauthorized?: boolean,\n    ): SecurePair;\n    /**\n     * `{@link createServer}` sets the default value of the `honorCipherOrder` option\n     * to `true`, other APIs that create secure contexts leave it unset.\n     *\n     * `{@link createServer}` uses a 128 bit truncated SHA1 hash value generated\n     * from `process.argv` as the default value of the `sessionIdContext` option, other\n     * APIs that create secure contexts have no default value.\n     *\n     * The `tls.createSecureContext()` method creates a `SecureContext` object. It is\n     * usable as an argument to several `tls` APIs, such as `server.addContext()`,\n     * but has no public methods. The {@link Server} constructor and the {@link createServer} method do not support the `secureContext` option.\n     *\n     * A key is _required_ for ciphers that use certificates. Either `key` or `pfx` can be used to provide it.\n     *\n     * If the `ca` option is not given, then Node.js will default to using [Mozilla's publicly trusted list of\n     * CAs](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt).\n     *\n     * Custom DHE parameters are discouraged in favor of the new `dhparam: 'auto' `option. When set to `'auto'`, well-known DHE parameters of sufficient strength\n     * will be selected automatically. Otherwise, if necessary, `openssl dhparam` can\n     * be used to create custom parameters. The key length must be greater than or\n     * equal to 1024 bits or else an error will be thrown. Although 1024 bits is\n     * permissible, use 2048 bits or larger for stronger security.\n     * @since v0.11.13\n     */\n    function createSecureContext(options?: SecureContextOptions): SecureContext;\n    /**\n     * Returns an array containing the CA certificates from various sources, depending on `type`:\n     *\n     * * `\"default\"`: return the CA certificates that will be used by the Node.js TLS clients by default.\n     *   * When `--use-bundled-ca` is enabled (default), or `--use-openssl-ca` is not enabled,\n     *     this would include CA certificates from the bundled Mozilla CA store.\n     *   * When `--use-system-ca` is enabled, this would also include certificates from the system's\n     *     trusted store.\n     *   * When `NODE_EXTRA_CA_CERTS` is used, this would also include certificates loaded from the specified\n     *     file.\n     * * `\"system\"`: return the CA certificates that are loaded from the system's trusted store, according\n     *   to rules set by `--use-system-ca`. This can be used to get the certificates from the system\n     *   when `--use-system-ca` is not enabled.\n     * * `\"bundled\"`: return the CA certificates from the bundled Mozilla CA store. This would be the same\n     *   as `tls.rootCertificates`.\n     * * `\"extra\"`: return the CA certificates loaded from `NODE_EXTRA_CA_CERTS`. It's an empty array if\n     *   `NODE_EXTRA_CA_CERTS` is not set.\n     * @since v22.15.0\n     * @param type The type of CA certificates that will be returned. Valid values\n     * are `\"default\"`, `\"system\"`, `\"bundled\"` and `\"extra\"`.\n     * **Default:** `\"default\"`.\n     * @returns An array of PEM-encoded certificates. The array may contain duplicates\n     * if the same certificate is repeatedly stored in multiple sources.\n     */\n    function getCACertificates(type?: \"default\" | \"system\" | \"bundled\" | \"extra\"): string[];\n    /**\n     * Returns an array with the names of the supported TLS ciphers. The names are\n     * lower-case for historical reasons, but must be uppercased to be used in\n     * the `ciphers` option of `{@link createSecureContext}`.\n     *\n     * Not all supported ciphers are enabled by default. See\n     * [Modifying the default TLS cipher suite](https://nodejs.org/docs/latest-v22.x/api/tls.html#modifying-the-default-tls-cipher-suite).\n     *\n     * Cipher names that start with `'tls_'` are for TLSv1.3, all the others are for\n     * TLSv1.2 and below.\n     *\n     * ```js\n     * console.log(tls.getCiphers()); // ['aes128-gcm-sha256', 'aes128-sha', ...]\n     * ```\n     * @since v0.10.2\n     */\n    function getCiphers(): string[];\n    /**\n     * The default curve name to use for ECDH key agreement in a tls server.\n     * The default value is `'auto'`. See `{@link createSecureContext()}` for further\n     * information.\n     * @since v0.11.13\n     */\n    let DEFAULT_ECDH_CURVE: string;\n    /**\n     * The default value of the `maxVersion` option of `{@link createSecureContext()}`.\n     * It can be assigned any of the supported TLS protocol versions,\n     * `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. **Default:** `'TLSv1.3'`, unless\n     * changed using CLI options. Using `--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using\n     * `--tls-max-v1.3` sets the default to `'TLSv1.3'`. If multiple of the options\n     * are provided, the highest maximum is used.\n     * @since v11.4.0\n     */\n    let DEFAULT_MAX_VERSION: SecureVersion;\n    /**\n     * The default value of the `minVersion` option of `{@link createSecureContext()}`.\n     * It can be assigned any of the supported TLS protocol versions,\n     * `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. **Default:** `'TLSv1.2'`, unless\n     * changed using CLI options. Using `--tls-min-v1.0` sets the default to\n     * `'TLSv1'`. Using `--tls-min-v1.1` sets the default to `'TLSv1.1'`. Using\n     * `--tls-min-v1.3` sets the default to `'TLSv1.3'`. If multiple of the options\n     * are provided, the lowest minimum is used.\n     * @since v11.4.0\n     */\n    let DEFAULT_MIN_VERSION: SecureVersion;\n    /**\n     * The default value of the `ciphers` option of `{@link createSecureContext()}`.\n     * It can be assigned any of the supported OpenSSL ciphers.\n     * Defaults to the content of `crypto.constants.defaultCoreCipherList`, unless\n     * changed using CLI options using `--tls-default-ciphers`.\n     * @since v19.8.0\n     */\n    let DEFAULT_CIPHERS: string;\n    /**\n     * An immutable array of strings representing the root certificates (in PEM format)\n     * from the bundled Mozilla CA store as supplied by the current Node.js version.\n     *\n     * The bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store\n     * that is fixed at release time. It is identical on all supported platforms.\n     * @since v12.3.0\n     */\n    const rootCertificates: readonly string[];\n}\ndeclare module \"node:tls\" {\n    export * from \"tls\";\n}\n"
        }
    ]
}