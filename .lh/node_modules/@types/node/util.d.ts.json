{
    "sourceFile": "node_modules/@types/node/util.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:util` module supports the needs of Node.js internal APIs. Many of the\n * utilities are useful for application and module developers as well. To access\n * it:\n *\n * ```js\n * import util from 'node:util';\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/util.js)\n */\ndeclare module \"util\" {\n    import * as types from \"node:util/types\";\n    export interface InspectOptions {\n        /**\n         * If `true`, object's non-enumerable symbols and properties are included in the formatted result.\n         * `WeakMap` and `WeakSet` entries are also included as well as user defined prototype properties (excluding method properties).\n         * @default false\n         */\n        showHidden?: boolean | undefined;\n        /**\n         * Specifies the number of times to recurse while formatting object.\n         * This is useful for inspecting large objects.\n         * To recurse up to the maximum call stack size pass `Infinity` or `null`.\n         * @default 2\n         */\n        depth?: number | null | undefined;\n        /**\n         * If `true`, the output is styled with ANSI color codes. Colors are customizable.\n         */\n        colors?: boolean | undefined;\n        /**\n         * If `false`, `[util.inspect.custom](depth, opts, inspect)` functions are not invoked.\n         * @default true\n         */\n        customInspect?: boolean | undefined;\n        /**\n         * If `true`, `Proxy` inspection includes the target and handler objects.\n         * @default false\n         */\n        showProxy?: boolean | undefined;\n        /**\n         * Specifies the maximum number of `Array`, `TypedArray`, `WeakMap`, and `WeakSet` elements\n         * to include when formatting. Set to `null` or `Infinity` to show all elements.\n         * Set to `0` or negative to show no elements.\n         * @default 100\n         */\n        maxArrayLength?: number | null | undefined;\n        /**\n         * Specifies the maximum number of characters to\n         * include when formatting. Set to `null` or `Infinity` to show all elements.\n         * Set to `0` or negative to show no characters.\n         * @default 10000\n         */\n        maxStringLength?: number | null | undefined;\n        /**\n         * The length at which input values are split across multiple lines.\n         * Set to `Infinity` to format the input as a single line\n         * (in combination with `compact` set to `true` or any number >= `1`).\n         * @default 80\n         */\n        breakLength?: number | undefined;\n        /**\n         * Setting this to `false` causes each object key\n         * to be displayed on a new line. It will also add new lines to text that is\n         * longer than `breakLength`. If set to a number, the most `n` inner elements\n         * are united on a single line as long as all properties fit into\n         * `breakLength`. Short array elements are also grouped together. Note that no\n         * text will be reduced below 16 characters, no matter the `breakLength` size.\n         * For more information, see the example below.\n         * @default true\n         */\n        compact?: boolean | number | undefined;\n        /**\n         * If set to `true` or a function, all properties of an object, and `Set` and `Map`\n         * entries are sorted in the resulting string.\n         * If set to `true` the default sort is used.\n         * If set to a function, it is used as a compare function.\n         */\n        sorted?: boolean | ((a: string, b: string) => number) | undefined;\n        /**\n         * If set to `true`, getters are going to be\n         * inspected as well. If set to `'get'` only getters without setter are going\n         * to be inspected. If set to `'set'` only getters having a corresponding\n         * setter are going to be inspected. This might cause side effects depending on\n         * the getter function.\n         * @default false\n         */\n        getters?: \"get\" | \"set\" | boolean | undefined;\n        /**\n         * If set to `true`, an underscore is used to separate every three digits in all bigints and numbers.\n         * @default false\n         */\n        numericSeparator?: boolean | undefined;\n    }\n    export type Style =\n        | \"special\"\n        | \"number\"\n        | \"bigint\"\n        | \"boolean\"\n        | \"undefined\"\n        | \"null\"\n        | \"string\"\n        | \"symbol\"\n        | \"date\"\n        | \"regexp\"\n        | \"module\";\n    export type CustomInspectFunction = (depth: number, options: InspectOptionsStylized) => any; // TODO: , inspect: inspect\n    export interface InspectOptionsStylized extends InspectOptions {\n        stylize(text: string, styleType: Style): string;\n    }\n    export interface CallSiteObject {\n        /**\n         * Returns the name of the function associated with this call site.\n         */\n        functionName: string;\n        /**\n         * Returns the name of the resource that contains the script for the\n         * function for this call site.\n         */\n        scriptName: string;\n        /**\n         * Returns the unique id of the script, as in Chrome DevTools protocol\n         * [`Runtime.ScriptId`](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#type-ScriptId).\n         * @since v22.14.0\n         */\n        scriptId: string;\n        /**\n         * Returns the number, 1-based, of the line for the associate function call.\n         */\n        lineNumber: number;\n        /**\n         * Returns the 1-based column offset on the line for the associated function call.\n         */\n        columnNumber: number;\n    }\n    export type DiffEntry = [operation: -1 | 0 | 1, value: string];\n    /**\n     * `util.diff()` compares two string or array values and returns an array of difference entries.\n     * It uses the Myers diff algorithm to compute minimal differences, which is the same algorithm\n     * used internally by assertion error messages.\n     *\n     * If the values are equal, an empty array is returned.\n     *\n     * ```js\n     * const { diff } = require('node:util');\n     *\n     * // Comparing strings\n     * const actualString = '12345678';\n     * const expectedString = '12!!5!7!';\n     * console.log(diff(actualString, expectedString));\n     * // [\n     * //   [0, '1'],\n     * //   [0, '2'],\n     * //   [1, '3'],\n     * //   [1, '4'],\n     * //   [-1, '!'],\n     * //   [-1, '!'],\n     * //   [0, '5'],\n     * //   [1, '6'],\n     * //   [-1, '!'],\n     * //   [0, '7'],\n     * //   [1, '8'],\n     * //   [-1, '!'],\n     * // ]\n     * // Comparing arrays\n     * const actualArray = ['1', '2', '3'];\n     * const expectedArray = ['1', '3', '4'];\n     * console.log(diff(actualArray, expectedArray));\n     * // [\n     * //   [0, '1'],\n     * //   [1, '2'],\n     * //   [0, '3'],\n     * //   [-1, '4'],\n     * // ]\n     * // Equal values return empty array\n     * console.log(diff('same', 'same'));\n     * // []\n     * ```\n     * @since v22.15.0\n     * @experimental\n     * @param actual The first value to compare\n     * @param expected The second value to compare\n     * @returns An array of difference entries. Each entry is an array with two elements:\n     * * Index 0: `number` Operation code: `-1` for delete, `0` for no-op/unchanged, `1` for insert\n     * * Index 1: `string` The value associated with the operation\n     */\n    export function diff(actual: string | readonly string[], expected: string | readonly string[]): DiffEntry[];\n    /**\n     * The `util.format()` method returns a formatted string using the first argument\n     * as a `printf`-like format string which can contain zero or more format\n     * specifiers. Each specifier is replaced with the converted value from the\n     * corresponding argument. Supported specifiers are:\n     *\n     * If a specifier does not have a corresponding argument, it is not replaced:\n     *\n     * ```js\n     * util.format('%s:%s', 'foo');\n     * // Returns: 'foo:%s'\n     * ```\n     *\n     * Values that are not part of the format string are formatted using `util.inspect()` if their type is not `string`.\n     *\n     * If there are more arguments passed to the `util.format()` method than the\n     * number of specifiers, the extra arguments are concatenated to the returned\n     * string, separated by spaces:\n     *\n     * ```js\n     * util.format('%s:%s', 'foo', 'bar', 'baz');\n     * // Returns: 'foo:bar baz'\n     * ```\n     *\n     * If the first argument does not contain a valid format specifier, `util.format()` returns a string that is the concatenation of all arguments separated by spaces:\n     *\n     * ```js\n     * util.format(1, 2, 3);\n     * // Returns: '1 2 3'\n     * ```\n     *\n     * If only one argument is passed to `util.format()`, it is returned as it is\n     * without any formatting:\n     *\n     * ```js\n     * util.format('%% %s');\n     * // Returns: '%% %s'\n     * ```\n     *\n     * `util.format()` is a synchronous method that is intended as a debugging tool.\n     * Some input values can have a significant performance overhead that can block the\n     * event loop. Use this function with care and never in a hot code path.\n     * @since v0.5.3\n     * @param format A `printf`-like format string.\n     */\n    export function format(format?: any, ...param: any[]): string;\n    /**\n     * This function is identical to {@link format}, except in that it takes\n     * an `inspectOptions` argument which specifies options that are passed along to {@link inspect}.\n     *\n     * ```js\n     * util.formatWithOptions({ colors: true }, 'See object %O', { foo: 42 });\n     * // Returns 'See object { foo: 42 }', where `42` is colored as a number\n     * // when printed to a terminal.\n     * ```\n     * @since v10.0.0\n     */\n    export function formatWithOptions(inspectOptions: InspectOptions, format?: any, ...param: any[]): string;\n    interface GetCallSitesOptions {\n        /**\n         * Reconstruct the original location in the stacktrace from the source-map.\n         * Enabled by default with the flag `--enable-source-maps`.\n         */\n        sourceMap?: boolean | undefined;\n    }\n    /**\n     * Returns an array of call site objects containing the stack of\n     * the caller function.\n     *\n     * ```js\n     * import { getCallSites } from 'node:util';\n     *\n     * function exampleFunction() {\n     *   const callSites = getCallSites();\n     *\n     *   console.log('Call Sites:');\n     *   callSites.forEach((callSite, index) => {\n     *     console.log(`CallSite ${index + 1}:`);\n     *     console.log(`Function Name: ${callSite.functionName}`);\n     *     console.log(`Script Name: ${callSite.scriptName}`);\n     *     console.log(`Line Number: ${callSite.lineNumber}`);\n     *     console.log(`Column Number: ${callSite.column}`);\n     *   });\n     *   // CallSite 1:\n     *   // Function Name: exampleFunction\n     *   // Script Name: /home/example.js\n     *   // Line Number: 5\n     *   // Column Number: 26\n     *\n     *   // CallSite 2:\n     *   // Function Name: anotherFunction\n     *   // Script Name: /home/example.js\n     *   // Line Number: 22\n     *   // Column Number: 3\n     *\n     *   // ...\n     * }\n     *\n     * // A function to simulate another stack layer\n     * function anotherFunction() {\n     *   exampleFunction();\n     * }\n     *\n     * anotherFunction();\n     * ```\n     *\n     * It is possible to reconstruct the original locations by setting the option `sourceMap` to `true`.\n     * If the source map is not available, the original location will be the same as the current location.\n     * When the `--enable-source-maps` flag is enabled, for example when using `--experimental-transform-types`,\n     * `sourceMap` will be true by default.\n     *\n     * ```ts\n     * import { getCallSites } from 'node:util';\n     *\n     * interface Foo {\n     *   foo: string;\n     * }\n     *\n     * const callSites = getCallSites({ sourceMap: true });\n     *\n     * // With sourceMap:\n     * // Function Name: ''\n     * // Script Name: example.js\n     * // Line Number: 7\n     * // Column Number: 26\n     *\n     * // Without sourceMap:\n     * // Function Name: ''\n     * // Script Name: example.js\n     * // Line Number: 2\n     * // Column Number: 26\n     * ```\n     * @param frameCount Number of frames to capture as call site objects.\n     * **Default:** `10`. Allowable range is between 1 and 200.\n     * @return An array of call site objects\n     * @since v22.9.0\n     */\n    export function getCallSites(frameCount?: number, options?: GetCallSitesOptions): CallSiteObject[];\n    export function getCallSites(options: GetCallSitesOptions): CallSiteObject[];\n    /**\n     * Returns the string name for a numeric error code that comes from a Node.js API.\n     * The mapping between error codes and error names is platform-dependent.\n     * See `Common System Errors` for the names of common errors.\n     *\n     * ```js\n     * fs.access('file/that/does/not/exist', (err) => {\n     *   const name = util.getSystemErrorName(err.errno);\n     *   console.error(name);  // ENOENT\n     * });\n     * ```\n     * @since v9.7.0\n     */\n    export function getSystemErrorName(err: number): string;\n    /**\n     * Returns a Map of all system error codes available from the Node.js API.\n     * The mapping between error codes and error names is platform-dependent.\n     * See `Common System Errors` for the names of common errors.\n     *\n     * ```js\n     * fs.access('file/that/does/not/exist', (err) => {\n     *   const errorMap = util.getSystemErrorMap();\n     *   const name = errorMap.get(err.errno);\n     *   console.error(name);  // ENOENT\n     * });\n     * ```\n     * @since v16.0.0, v14.17.0\n     */\n    export function getSystemErrorMap(): Map<number, [string, string]>;\n    /**\n     * Returns the string message for a numeric error code that comes from a Node.js\n     * API.\n     * The mapping between error codes and string messages is platform-dependent.\n     *\n     * ```js\n     * fs.access('file/that/does/not/exist', (err) => {\n     *   const message = util.getSystemErrorMessage(err.errno);\n     *   console.error(message);  // no such file or directory\n     * });\n     * ```\n     * @since v22.12.0\n     */\n    export function getSystemErrorMessage(err: number): string;\n    /**\n     * The `util.log()` method prints the given `string` to `stdout` with an included\n     * timestamp.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.log('Timestamped message.');\n     * ```\n     * @since v0.3.0\n     * @deprecated Since v6.0.0 - Use a third party module instead.\n     */\n    export function log(string: string): void;\n    /**\n     * Returns the `string` after replacing any surrogate code points\n     * (or equivalently, any unpaired surrogate code units) with the\n     * Unicode \"replacement character\" U+FFFD.\n     * @since v16.8.0, v14.18.0\n     */\n    export function toUSVString(string: string): string;\n    /**\n     * Creates and returns an `AbortController` instance whose `AbortSignal` is marked\n     * as transferable and can be used with `structuredClone()` or `postMessage()`.\n     * @since v18.11.0\n     * @returns A transferable AbortController\n     */\n    export function transferableAbortController(): AbortController;\n    /**\n     * Marks the given `AbortSignal` as transferable so that it can be used with`structuredClone()` and `postMessage()`.\n     *\n     * ```js\n     * const signal = transferableAbortSignal(AbortSignal.timeout(100));\n     * const channel = new MessageChannel();\n     * channel.port2.postMessage(signal, [signal]);\n     * ```\n     * @since v18.11.0\n     * @param signal The AbortSignal\n     * @returns The same AbortSignal\n     */\n    export function transferableAbortSignal(signal: AbortSignal): AbortSignal;\n    /**\n     * Listens to abort event on the provided `signal` and returns a promise that resolves when the `signal` is aborted.\n     * If `resource` is provided, it weakly references the operation's associated object,\n     * so if `resource` is garbage collected before the `signal` aborts,\n     * then returned promise shall remain pending.\n     * This prevents memory leaks in long-running or non-cancelable operations.\n     *\n     * ```js\n     * import { aborted } from 'node:util';\n     *\n     * // Obtain an object with an abortable signal, like a custom resource or operation.\n     * const dependent = obtainSomethingAbortable();\n     *\n     * // Pass `dependent` as the resource, indicating the promise should only resolve\n     * // if `dependent` is still in memory when the signal is aborted.\n     * aborted(dependent.signal, dependent).then(() => {\n     *   // This code runs when `dependent` is aborted.\n     *   console.log('Dependent resource was aborted.');\n     * });\n     *\n     * // Simulate an event that triggers the abort.\n     * dependent.on('event', () => {\n     *   dependent.abort(); // This will cause the `aborted` promise to resolve.\n     * });\n     * ```\n     * @since v19.7.0\n     * @experimental\n     * @param resource Any non-null object tied to the abortable operation and held weakly.\n     * If `resource` is garbage collected before the `signal` aborts, the promise remains pending,\n     * allowing Node.js to stop tracking it.\n     * This helps prevent memory leaks in long-running or non-cancelable operations.\n     */\n    export function aborted(signal: AbortSignal, resource: any): Promise<void>;\n    /**\n     * The `util.inspect()` method returns a string representation of `object` that is\n     * intended for debugging. The output of `util.inspect` may change at any time\n     * and should not be depended upon programmatically. Additional `options` may be\n     * passed that alter the result.\n     * `util.inspect()` will use the constructor's name and/or `@@toStringTag` to make\n     * an identifiable tag for an inspected value.\n     *\n     * ```js\n     * class Foo {\n     *   get [Symbol.toStringTag]() {\n     *     return 'bar';\n     *   }\n     * }\n     *\n     * class Bar {}\n     *\n     * const baz = Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } });\n     *\n     * util.inspect(new Foo()); // 'Foo [bar] {}'\n     * util.inspect(new Bar()); // 'Bar {}'\n     * util.inspect(baz);       // '[foo] {}'\n     * ```\n     *\n     * Circular references point to their anchor by using a reference index:\n     *\n     * ```js\n     * import { inspect } from 'node:util';\n     *\n     * const obj = {};\n     * obj.a = [obj];\n     * obj.b = {};\n     * obj.b.inner = obj.b;\n     * obj.b.obj = obj;\n     *\n     * console.log(inspect(obj));\n     * // <ref *1> {\n     * //   a: [ [Circular *1] ],\n     * //   b: <ref *2> { inner: [Circular *2], obj: [Circular *1] }\n     * // }\n     * ```\n     *\n     * The following example inspects all properties of the `util` object:\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * console.log(util.inspect(util, { showHidden: true, depth: null }));\n     * ```\n     *\n     * The following example highlights the effect of the `compact` option:\n     *\n     * ```js\n     * import { inspect } from 'node:util';\n     *\n     * const o = {\n     *   a: [1, 2, [[\n     *     'Lorem ipsum dolor sit amet,\\nconsectetur adipiscing elit, sed do ' +\n     *       'eiusmod \\ntempor incididunt ut labore et dolore magna aliqua.',\n     *     'test',\n     *     'foo']], 4],\n     *   b: new Map([['za', 1], ['zb', 'test']]),\n     * };\n     * console.log(inspect(o, { compact: true, depth: 5, breakLength: 80 }));\n     *\n     * // { a:\n     * //   [ 1,\n     * //     2,\n     * //     [ [ 'Lorem ipsum dolor sit amet,\\nconsectetur [...]', // A long line\n     * //           'test',\n     * //           'foo' ] ],\n     * //     4 ],\n     * //   b: Map(2) { 'za' => 1, 'zb' => 'test' } }\n     *\n     * // Setting `compact` to false or an integer creates more reader friendly output.\n     * console.log(inspect(o, { compact: false, depth: 5, breakLength: 80 }));\n     *\n     * // {\n     * //   a: [\n     * //     1,\n     * //     2,\n     * //     [\n     * //       [\n     * //         'Lorem ipsum dolor sit amet,\\n' +\n     * //           'consectetur adipiscing elit, sed do eiusmod \\n' +\n     * //           'tempor incididunt ut labore et dolore magna aliqua.',\n     * //         'test',\n     * //         'foo'\n     * //       ]\n     * //     ],\n     * //     4\n     * //   ],\n     * //   b: Map(2) {\n     * //     'za' => 1,\n     * //     'zb' => 'test'\n     * //   }\n     * // }\n     *\n     * // Setting `breakLength` to e.g. 150 will print the \"Lorem ipsum\" text in a\n     * // single line.\n     * ```\n     *\n     * The `showHidden` option allows `WeakMap` and `WeakSet` entries to be\n     * inspected. If there are more entries than `maxArrayLength`, there is no\n     * guarantee which entries are displayed. That means retrieving the same\n     * `WeakSet` entries twice may result in different output. Furthermore, entries\n     * with no remaining strong references may be garbage collected at any time.\n     *\n     * ```js\n     * import { inspect } from 'node:util';\n     *\n     * const obj = { a: 1 };\n     * const obj2 = { b: 2 };\n     * const weakSet = new WeakSet([obj, obj2]);\n     *\n     * console.log(inspect(weakSet, { showHidden: true }));\n     * // WeakSet { { a: 1 }, { b: 2 } }\n     * ```\n     *\n     * The `sorted` option ensures that an object's property insertion order does not\n     * impact the result of `util.inspect()`.\n     *\n     * ```js\n     * import { inspect } from 'node:util';\n     * import assert from 'node:assert';\n     *\n     * const o1 = {\n     *   b: [2, 3, 1],\n     *   a: '`a` comes before `b`',\n     *   c: new Set([2, 3, 1]),\n     * };\n     * console.log(inspect(o1, { sorted: true }));\n     * // { a: '`a` comes before `b`', b: [ 2, 3, 1 ], c: Set(3) { 1, 2, 3 } }\n     * console.log(inspect(o1, { sorted: (a, b) => b.localeCompare(a) }));\n     * // { c: Set(3) { 3, 2, 1 }, b: [ 2, 3, 1 ], a: '`a` comes before `b`' }\n     *\n     * const o2 = {\n     *   c: new Set([2, 1, 3]),\n     *   a: '`a` comes before `b`',\n     *   b: [2, 3, 1],\n     * };\n     * assert.strict.equal(\n     *   inspect(o1, { sorted: true }),\n     *   inspect(o2, { sorted: true }),\n     * );\n     * ```\n     *\n     * The `numericSeparator` option adds an underscore every three digits to all\n     * numbers.\n     *\n     * ```js\n     * import { inspect } from 'node:util';\n     *\n     * const thousand = 1000;\n     * const million = 1000000;\n     * const bigNumber = 123456789n;\n     * const bigDecimal = 1234.12345;\n     *\n     * console.log(inspect(thousand, { numericSeparator: true }));\n     * // 1_000\n     * console.log(inspect(million, { numericSeparator: true }));\n     * // 1_000_000\n     * console.log(inspect(bigNumber, { numericSeparator: true }));\n     * // 123_456_789n\n     * console.log(inspect(bigDecimal, { numericSeparator: true }));\n     * // 1_234.123_45\n     * ```\n     *\n     * `util.inspect()` is a synchronous method intended for debugging. Its maximum\n     * output length is approximately 128 MiB. Inputs that result in longer output will\n     * be truncated.\n     * @since v0.3.0\n     * @param object Any JavaScript primitive or `Object`.\n     * @return The representation of `object`.\n     */\n    export function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;\n    export function inspect(object: any, options?: InspectOptions): string;\n    export namespace inspect {\n        let colors: NodeJS.Dict<[number, number]>;\n        let styles: {\n            [K in Style]: string;\n        };\n        let defaultOptions: InspectOptions;\n        /**\n         * Allows changing inspect settings from the repl.\n         */\n        let replDefaults: InspectOptions;\n        /**\n         * That can be used to declare custom inspect functions.\n         */\n        const custom: unique symbol;\n    }\n    /**\n     * Alias for [`Array.isArray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).\n     *\n     * Returns `true` if the given `object` is an `Array`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isArray([]);\n     * // Returns: true\n     * util.isArray(new Array());\n     * // Returns: true\n     * util.isArray({});\n     * // Returns: false\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Use `isArray` instead.\n     */\n    export function isArray(object: unknown): object is unknown[];\n    /**\n     * Returns `true` if the given `object` is a `RegExp`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isRegExp(/some regexp/);\n     * // Returns: true\n     * util.isRegExp(new RegExp('another regexp'));\n     * // Returns: true\n     * util.isRegExp({});\n     * // Returns: false\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Deprecated\n     */\n    export function isRegExp(object: unknown): object is RegExp;\n    /**\n     * Returns `true` if the given `object` is a `Date`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isDate(new Date());\n     * // Returns: true\n     * util.isDate(Date());\n     * // false (without 'new' returns a String)\n     * util.isDate({});\n     * // Returns: false\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Use {@link types.isDate} instead.\n     */\n    export function isDate(object: unknown): object is Date;\n    /**\n     * Returns `true` if the given `object` is an `Error`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isError(new Error());\n     * // Returns: true\n     * util.isError(new TypeError());\n     * // Returns: true\n     * util.isError({ name: 'Error', message: 'an error occurred' });\n     * // Returns: false\n     * ```\n     *\n     * This method relies on `Object.prototype.toString()` behavior. It is\n     * possible to obtain an incorrect result when the `object` argument manipulates `@@toStringTag`.\n     *\n     * ```js\n     * import util from 'node:util';\n     * const obj = { name: 'Error', message: 'an error occurred' };\n     *\n     * util.isError(obj);\n     * // Returns: false\n     * obj[Symbol.toStringTag] = 'Error';\n     * util.isError(obj);\n     * // Returns: true\n     * ```\n     * @since v0.6.0\n     * @deprecated Since v4.0.0 - Use {@link types.isNativeError} instead.\n     */\n    export function isError(object: unknown): object is Error;\n    /**\n     * Usage of `util.inherits()` is discouraged. Please use the ES6 `class` and\n     * `extends` keywords to get language level inheritance support. Also note\n     * that the two styles are [semantically incompatible](https://github.com/nodejs/node/issues/4179).\n     *\n     * Inherit the prototype methods from one\n     * [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) into another. The\n     * prototype of `constructor` will be set to a new object created from\n     * `superConstructor`.\n     *\n     * This mainly adds some input validation on top of\n     * `Object.setPrototypeOf(constructor.prototype, superConstructor.prototype)`.\n     * As an additional convenience, `superConstructor` will be accessible\n     * through the `constructor.super_` property.\n     *\n     * ```js\n     * const util = require('node:util');\n     * const EventEmitter = require('node:events');\n     *\n     * function MyStream() {\n     *   EventEmitter.call(this);\n     * }\n     *\n     * util.inherits(MyStream, EventEmitter);\n     *\n     * MyStream.prototype.write = function(data) {\n     *   this.emit('data', data);\n     * };\n     *\n     * const stream = new MyStream();\n     *\n     * console.log(stream instanceof EventEmitter); // true\n     * console.log(MyStream.super_ === EventEmitter); // true\n     *\n     * stream.on('data', (data) => {\n     *   console.log(`Received data: \"${data}\"`);\n     * });\n     * stream.write('It works!'); // Received data: \"It works!\"\n     * ```\n     *\n     * ES6 example using `class` and `extends`:\n     *\n     * ```js\n     * import EventEmitter from 'node:events';\n     *\n     * class MyStream extends EventEmitter {\n     *   write(data) {\n     *     this.emit('data', data);\n     *   }\n     * }\n     *\n     * const stream = new MyStream();\n     *\n     * stream.on('data', (data) => {\n     *   console.log(`Received data: \"${data}\"`);\n     * });\n     * stream.write('With ES6');\n     * ```\n     * @since v0.3.0\n     * @legacy Use ES2015 class syntax and `extends` keyword instead.\n     */\n    export function inherits(constructor: unknown, superConstructor: unknown): void;\n    export type DebugLoggerFunction = (msg: string, ...param: unknown[]) => void;\n    export interface DebugLogger extends DebugLoggerFunction {\n        /**\n         * The `util.debuglog().enabled` getter is used to create a test that can be used\n         * in conditionals based on the existence of the `NODE_DEBUG` environment variable.\n         * If the `section` name appears within the value of that environment variable,\n         * then the returned value will be `true`. If not, then the returned value will be\n         * `false`.\n         *\n         * ```js\n         * import { debuglog } from 'node:util';\n         * const enabled = debuglog('foo').enabled;\n         * if (enabled) {\n         *   console.log('hello from foo [%d]', 123);\n         * }\n         * ```\n         *\n         * If this program is run with `NODE_DEBUG=foo` in the environment, then it will\n         * output something like:\n         *\n         * ```console\n         * hello from foo [123]\n         * ```\n         */\n        enabled: boolean;\n    }\n    /**\n     * The `util.debuglog()` method is used to create a function that conditionally\n     * writes debug messages to `stderr` based on the existence of the `NODE_DEBUG`\n     * environment variable. If the `section` name appears within the value of that\n     * environment variable, then the returned function operates similar to\n     * `console.error()`. If not, then the returned function is a no-op.\n     *\n     * ```js\n     * import { debuglog } from 'node:util';\n     * const log = debuglog('foo');\n     *\n     * log('hello from foo [%d]', 123);\n     * ```\n     *\n     * If this program is run with `NODE_DEBUG=foo` in the environment, then\n     * it will output something like:\n     *\n     * ```console\n     * FOO 3245: hello from foo [123]\n     * ```\n     *\n     * where `3245` is the process id. If it is not run with that\n     * environment variable set, then it will not print anything.\n     *\n     * The `section` supports wildcard also:\n     *\n     * ```js\n     * import { debuglog } from 'node:util';\n     * const log = debuglog('foo');\n     *\n     * log('hi there, it\\'s foo-bar [%d]', 2333);\n     * ```\n     *\n     * if it is run with `NODE_DEBUG=foo*` in the environment, then it will output\n     * something like:\n     *\n     * ```console\n     * FOO-BAR 3257: hi there, it's foo-bar [2333]\n     * ```\n     *\n     * Multiple comma-separated `section` names may be specified in the `NODE_DEBUG`\n     * environment variable: `NODE_DEBUG=fs,net,tls`.\n     *\n     * The optional `callback` argument can be used to replace the logging function\n     * with a different function that doesn't have any initialization or\n     * unnecessary wrapping.\n     *\n     * ```js\n     * import { debuglog } from 'node:util';\n     * let log = debuglog('internals', (debug) => {\n     *   // Replace with a logging function that optimizes out\n     *   // testing if the section is enabled\n     *   log = debug;\n     * });\n     * ```\n     * @since v0.11.3\n     * @param section A string identifying the portion of the application for which the `debuglog` function is being created.\n     * @param callback A callback invoked the first time the logging function is called with a function argument that is a more optimized logging function.\n     * @return The logging function\n     */\n    export function debuglog(section: string, callback?: (fn: DebugLoggerFunction) => void): DebugLogger;\n    export { debuglog as debug };\n    /**\n     * Returns `true` if the given `object` is a `Boolean`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isBoolean(1);\n     * // Returns: false\n     * util.isBoolean(0);\n     * // Returns: false\n     * util.isBoolean(false);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'boolean'` instead.\n     */\n    export function isBoolean(object: unknown): object is boolean;\n    /**\n     * Returns `true` if the given `object` is a `Buffer`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isBuffer({ length: 0 });\n     * // Returns: false\n     * util.isBuffer([]);\n     * // Returns: false\n     * util.isBuffer(Buffer.from('hello world'));\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `isBuffer` instead.\n     */\n    export function isBuffer(object: unknown): object is Buffer;\n    /**\n     * Returns `true` if the given `object` is a `Function`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * function Foo() {}\n     * const Bar = () => {};\n     *\n     * util.isFunction({});\n     * // Returns: false\n     * util.isFunction(Foo);\n     * // Returns: true\n     * util.isFunction(Bar);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'function'` instead.\n     */\n    export function isFunction(object: unknown): boolean;\n    /**\n     * Returns `true` if the given `object` is strictly `null`. Otherwise, returns`false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isNull(0);\n     * // Returns: false\n     * util.isNull(undefined);\n     * // Returns: false\n     * util.isNull(null);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value === null` instead.\n     */\n    export function isNull(object: unknown): object is null;\n    /**\n     * Returns `true` if the given `object` is `null` or `undefined`. Otherwise,\n     * returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isNullOrUndefined(0);\n     * // Returns: false\n     * util.isNullOrUndefined(undefined);\n     * // Returns: true\n     * util.isNullOrUndefined(null);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value === undefined || value === null` instead.\n     */\n    export function isNullOrUndefined(object: unknown): object is null | undefined;\n    /**\n     * Returns `true` if the given `object` is a `Number`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isNumber(false);\n     * // Returns: false\n     * util.isNumber(Infinity);\n     * // Returns: true\n     * util.isNumber(0);\n     * // Returns: true\n     * util.isNumber(NaN);\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'number'` instead.\n     */\n    export function isNumber(object: unknown): object is number;\n    /**\n     * Returns `true` if the given `object` is strictly an `Object`**and** not a`Function` (even though functions are objects in JavaScript).\n     * Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isObject(5);\n     * // Returns: false\n     * util.isObject(null);\n     * // Returns: false\n     * util.isObject({});\n     * // Returns: true\n     * util.isObject(() => {});\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value !== null && typeof value === 'object'` instead.\n     */\n    export function isObject(object: unknown): boolean;\n    /**\n     * Returns `true` if the given `object` is a primitive type. Otherwise, returns`false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isPrimitive(5);\n     * // Returns: true\n     * util.isPrimitive('foo');\n     * // Returns: true\n     * util.isPrimitive(false);\n     * // Returns: true\n     * util.isPrimitive(null);\n     * // Returns: true\n     * util.isPrimitive(undefined);\n     * // Returns: true\n     * util.isPrimitive({});\n     * // Returns: false\n     * util.isPrimitive(() => {});\n     * // Returns: false\n     * util.isPrimitive(/^$/);\n     * // Returns: false\n     * util.isPrimitive(new Date());\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `(typeof value !== 'object' && typeof value !== 'function') || value === null` instead.\n     */\n    export function isPrimitive(object: unknown): boolean;\n    /**\n     * Returns `true` if the given `object` is a `string`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isString('');\n     * // Returns: true\n     * util.isString('foo');\n     * // Returns: true\n     * util.isString(String('foo'));\n     * // Returns: true\n     * util.isString(5);\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'string'` instead.\n     */\n    export function isString(object: unknown): object is string;\n    /**\n     * Returns `true` if the given `object` is a `Symbol`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * util.isSymbol(5);\n     * // Returns: false\n     * util.isSymbol('foo');\n     * // Returns: false\n     * util.isSymbol(Symbol('foo'));\n     * // Returns: true\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `typeof value === 'symbol'` instead.\n     */\n    export function isSymbol(object: unknown): object is symbol;\n    /**\n     * Returns `true` if the given `object` is `undefined`. Otherwise, returns `false`.\n     *\n     * ```js\n     * import util from 'node:util';\n     *\n     * const foo = undefined;\n     * util.isUndefined(5);\n     * // Returns: false\n     * util.isUndefined(foo);\n     * // Returns: true\n     * util.isUndefined(null);\n     * // Returns: false\n     * ```\n     * @since v0.11.5\n     * @deprecated Since v4.0.0 - Use `value === undefined` instead.\n     */\n    export function isUndefined(object: unknown): object is undefined;\n    /**\n     * The `util.deprecate()` method wraps `fn` (which may be a function or class) in\n     * such a way that it is marked as deprecated.\n     *\n     * ```js\n     * import { deprecate } from 'node:util';\n     *\n     * export const obsoleteFunction = deprecate(() => {\n     *   // Do something here.\n     * }, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');\n     * ```\n     *\n     * When called, `util.deprecate()` will return a function that will emit a\n     * `DeprecationWarning` using the `'warning'` event. The warning will\n     * be emitted and printed to `stderr` the first time the returned function is\n     * called. After the warning is emitted, the wrapped function is called without\n     * emitting a warning.\n     *\n     * If the same optional `code` is supplied in multiple calls to `util.deprecate()`,\n     * the warning will be emitted only once for that `code`.\n     *\n     * ```js\n     * import { deprecate } from 'node:util';\n     *\n     * const fn1 = deprecate(\n     *   () => 'a value',\n     *   'deprecation message',\n     *   'DEP0001',\n     * );\n     * const fn2 = deprecate(\n     *   () => 'a  different value',\n     *   'other dep message',\n     *   'DEP0001',\n     * );\n     * fn1(); // Emits a deprecation warning with code DEP0001\n     * fn2(); // Does not emit a deprecation warning because it has the same code\n     * ```\n     *\n     * If either the `--no-deprecation` or `--no-warnings` command-line flags are\n     * used, or if the `process.noDeprecation` property is set to `true` _prior_ to\n     * the first deprecation warning, the `util.deprecate()` method does nothing.\n     *\n     * If the `--trace-deprecation` or `--trace-warnings` command-line flags are set,\n     * or the `process.traceDeprecation` property is set to `true`, a warning and a\n     * stack trace are printed to `stderr` the first time the deprecated function is\n     * called.\n     *\n     * If the `--throw-deprecation` command-line flag is set, or the\n     * `process.throwDeprecation` property is set to `true`, then an exception will be\n     * thrown when the deprecated function is called.\n     *\n     * The `--throw-deprecation` command-line flag and `process.throwDeprecation`\n     * property take precedence over `--trace-deprecation` and\n     * `process.traceDeprecation`.\n     * @since v0.8.0\n     * @param fn The function that is being deprecated.\n     * @param msg A warning message to display when the deprecated function is invoked.\n     * @param code A deprecation code. See the `list of deprecated APIs` for a list of codes.\n     * @return The deprecated function wrapped to emit a warning.\n     */\n    export function deprecate<T extends Function>(fn: T, msg: string, code?: string): T;\n    /**\n     * Returns `true` if there is deep strict equality between `val1` and `val2`.\n     * Otherwise, returns `false`.\n     *\n     * See `assert.deepStrictEqual()` for more information about deep strict\n     * equality.\n     * @since v9.0.0\n     */\n    export function isDeepStrictEqual(val1: unknown, val2: unknown): boolean;\n    /**\n     * Returns `str` with any ANSI escape codes removed.\n     *\n     * ```js\n     * console.log(util.stripVTControlCharacters('\\u001B[4mvalue\\u001B[0m'));\n     * // Prints \"value\"\n     * ```\n     * @since v16.11.0\n     */\n    export function stripVTControlCharacters(str: string): string;\n    /**\n     * Takes an `async` function (or a function that returns a `Promise`) and returns a\n     * function following the error-first callback style, i.e. taking\n     * an `(err, value) => ...` callback as the last argument. In the callback, the\n     * first argument will be the rejection reason (or `null` if the `Promise`\n     * resolved), and the second argument will be the resolved value.\n     *\n     * ```js\n     * import { callbackify } from 'node:util';\n     *\n     * async function fn() {\n     *   return 'hello world';\n     * }\n     * const callbackFunction = callbackify(fn);\n     *\n     * callbackFunction((err, ret) => {\n     *   if (err) throw err;\n     *   console.log(ret);\n     * });\n     * ```\n     *\n     * Will print:\n     *\n     * ```text\n     * hello world\n     * ```\n     *\n     * The callback is executed asynchronously, and will have a limited stack trace.\n     * If the callback throws, the process will emit an `'uncaughtException'`\n     * event, and if not handled will exit.\n     *\n     * Since `null` has a special meaning as the first argument to a callback, if a\n     * wrapped function rejects a `Promise` with a falsy value as a reason, the value\n     * is wrapped in an `Error` with the original value stored in a field named\n     * `reason`.\n     *\n     * ```js\n     * function fn() {\n     *   return Promise.reject(null);\n     * }\n     * const callbackFunction = util.callbackify(fn);\n     *\n     * callbackFunction((err, ret) => {\n     *   // When the Promise was rejected with `null` it is wrapped with an Error and\n     *   // the original value is stored in `reason`.\n     *   err && Object.hasOwn(err, 'reason') && err.reason === null;  // true\n     * });\n     * ```\n     * @since v8.2.0\n     * @param fn An `async` function\n     * @return a callback style function\n     */\n    export function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<TResult>(\n        fn: () => Promise<TResult>,\n    ): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    export function callbackify<T1>(\n        fn: (arg1: T1) => Promise<void>,\n    ): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, TResult>(\n        fn: (arg1: T1) => Promise<TResult>,\n    ): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;\n    export function callbackify<T1, T2>(\n        fn: (arg1: T1, arg2: T2) => Promise<void>,\n    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, TResult>(\n        fn: (arg1: T1, arg2: T2) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    export function callbackify<T1, T2, T3>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>,\n    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;\n    export function callbackify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,\n    ) => void;\n    export function callbackify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;\n    export function callbackify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,\n    ) => void;\n    export function callbackify<T1, T2, T3, T4, T5, T6>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        arg6: T6,\n        callback: (err: NodeJS.ErrnoException) => void,\n    ) => void;\n    export function callbackify<T1, T2, T3, T4, T5, T6, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>,\n    ): (\n        arg1: T1,\n        arg2: T2,\n        arg3: T3,\n        arg4: T4,\n        arg5: T5,\n        arg6: T6,\n        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,\n    ) => void;\n    export interface CustomPromisifyLegacy<TCustom extends Function> extends Function {\n        __promisify__: TCustom;\n    }\n    export interface CustomPromisifySymbol<TCustom extends Function> extends Function {\n        [promisify.custom]: TCustom;\n    }\n    export type CustomPromisify<TCustom extends Function> =\n        | CustomPromisifySymbol<TCustom>\n        | CustomPromisifyLegacy<TCustom>;\n    /**\n     * Takes a function following the common error-first callback style, i.e. taking\n     * an `(err, value) => ...` callback as the last argument, and returns a version\n     * that returns promises.\n     *\n     * ```js\n     * import { promisify } from 'node:util';\n     * import { stat } from 'node:fs';\n     *\n     * const promisifiedStat = promisify(stat);\n     * promisifiedStat('.').then((stats) => {\n     *   // Do something with `stats`\n     * }).catch((error) => {\n     *   // Handle the error.\n     * });\n     * ```\n     *\n     * Or, equivalently using `async function`s:\n     *\n     * ```js\n     * import { promisify } from 'node:util';\n     * import { stat } from 'node:fs';\n     *\n     * const promisifiedStat = promisify(stat);\n     *\n     * async function callStat() {\n     *   const stats = await promisifiedStat('.');\n     *   console.log(`This directory is owned by ${stats.uid}`);\n     * }\n     *\n     * callStat();\n     * ```\n     *\n     * If there is an `original[util.promisify.custom]` property present, `promisify`\n     * will return its value, see [Custom promisified functions](https://nodejs.org/docs/latest-v22.x/api/util.html#custom-promisified-functions).\n     *\n     * `promisify()` assumes that `original` is a function taking a callback as its\n     * final argument in all cases. If `original` is not a function, `promisify()`\n     * will throw an error. If `original` is a function but its last argument is not\n     * an error-first callback, it will still be passed an error-first\n     * callback as its last argument.\n     *\n     * Using `promisify()` on class methods or other methods that use `this` may not\n     * work as expected unless handled specially:\n     *\n     * ```js\n     * import { promisify } from 'node:util';\n     *\n     * class Foo {\n     *   constructor() {\n     *     this.a = 42;\n     *   }\n     *\n     *   bar(callback) {\n     *     callback(null, this.a);\n     *   }\n     * }\n     *\n     * const foo = new Foo();\n     *\n     * const naiveBar = promisify(foo.bar);\n     * // TypeError: Cannot read properties of undefined (reading 'a')\n     * // naiveBar().then(a => console.log(a));\n     *\n     * naiveBar.call(foo).then((a) => console.log(a)); // '42'\n     *\n     * const bindBar = naiveBar.bind(foo);\n     * bindBar().then((a) => console.log(a)); // '42'\n     * ```\n     * @since v8.0.0\n     */\n    export function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;\n    export function promisify<TResult>(\n        fn: (callback: (err: any, result: TResult) => void) => void,\n    ): () => Promise<TResult>;\n    export function promisify(fn: (callback: (err?: any) => void) => void): () => Promise<void>;\n    export function promisify<T1, TResult>(\n        fn: (arg1: T1, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1) => Promise<TResult>;\n    export function promisify<T1>(fn: (arg1: T1, callback: (err?: any) => void) => void): (arg1: T1) => Promise<void>;\n    export function promisify<T1, T2, TResult>(\n        fn: (arg1: T1, arg2: T2, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2) => Promise<TResult>;\n    export function promisify<T1, T2>(\n        fn: (arg1: T1, arg2: T2, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2) => Promise<void>;\n    export function promisify<T1, T2, T3, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;\n    export function promisify<T1, T2, T3>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;\n    export function promisify<T1, T2, T3, T4, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;\n    export function promisify<T1, T2, T3, T4>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;\n    export function promisify<T1, T2, T3, T4, T5, TResult>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: any, result: TResult) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;\n    export function promisify<T1, T2, T3, T4, T5>(\n        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: any) => void) => void,\n    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;\n    export function promisify(fn: Function): Function;\n    export namespace promisify {\n        /**\n         * That can be used to declare custom promisified variants of functions.\n         */\n        const custom: unique symbol;\n    }\n    /**\n     * Stability: 1.1 - Active development\n     * Given an example `.env` file:\n     *\n     * ```js\n     * import { parseEnv } from 'node:util';\n     *\n     * parseEnv('HELLO=world\\nHELLO=oh my\\n');\n     * // Returns: { HELLO: 'oh my' }\n     * ```\n     * @param content The raw contents of a `.env` file.\n     * @since v20.12.0\n     */\n    export function parseEnv(content: string): object;\n    // https://nodejs.org/docs/latest/api/util.html#foreground-colors\n    type ForegroundColors =\n        | \"black\"\n        | \"blackBright\"\n        | \"blue\"\n        | \"blueBright\"\n        | \"cyan\"\n        | \"cyanBright\"\n        | \"gray\"\n        | \"green\"\n        | \"greenBright\"\n        | \"grey\"\n        | \"magenta\"\n        | \"magentaBright\"\n        | \"red\"\n        | \"redBright\"\n        | \"white\"\n        | \"whiteBright\"\n        | \"yellow\"\n        | \"yellowBright\";\n    // https://nodejs.org/docs/latest/api/util.html#background-colors\n    type BackgroundColors =\n        | \"bgBlack\"\n        | \"bgBlackBright\"\n        | \"bgBlue\"\n        | \"bgBlueBright\"\n        | \"bgCyan\"\n        | \"bgCyanBright\"\n        | \"bgGray\"\n        | \"bgGreen\"\n        | \"bgGreenBright\"\n        | \"bgGrey\"\n        | \"bgMagenta\"\n        | \"bgMagentaBright\"\n        | \"bgRed\"\n        | \"bgRedBright\"\n        | \"bgWhite\"\n        | \"bgWhiteBright\"\n        | \"bgYellow\"\n        | \"bgYellowBright\";\n    // https://nodejs.org/docs/latest/api/util.html#modifiers\n    type Modifiers =\n        | \"blink\"\n        | \"bold\"\n        | \"dim\"\n        | \"doubleunderline\"\n        | \"framed\"\n        | \"hidden\"\n        | \"inverse\"\n        | \"italic\"\n        | \"overlined\"\n        | \"reset\"\n        | \"strikethrough\"\n        | \"underline\";\n    /**\n     * This function returns a formatted text considering the `format` passed\n     * for printing in a terminal. It is aware of the terminal's capabilities\n     * and acts according to the configuration set via `NO_COLORS`,\n     * `NODE_DISABLE_COLORS` and `FORCE_COLOR` environment variables.\n     *\n     * ```js\n     * import { styleText } from 'node:util';\n     * import { stderr } from 'node:process';\n     *\n     * const successMessage = styleText('green', 'Success!');\n     * console.log(successMessage);\n     *\n     * const errorMessage = styleText(\n     *   'red',\n     *   'Error! Error!',\n     *   // Validate if process.stderr has TTY\n     *   { stream: stderr },\n     * );\n     * console.error(errorMessage);\n     * ```\n     *\n     * `util.inspect.colors` also provides text formats such as `italic`, and\n     * `underline` and you can combine both:\n     *\n     * ```js\n     * console.log(\n     *   util.styleText(['underline', 'italic'], 'My italic underlined message'),\n     * );\n     * ```\n     *\n     * When passing an array of formats, the order of the format applied\n     * is left to right so the following style might overwrite the previous one.\n     *\n     * ```js\n     * console.log(\n     *   util.styleText(['red', 'green'], 'text'), // green\n     * );\n     * ```\n     *\n     * The full list of formats can be found in [modifiers](https://nodejs.org/docs/latest-v22.x/api/util.html#modifiers).\n     * @param format A text format or an Array of text formats defined in `util.inspect.colors`.\n     * @param text The text to to be formatted.\n     * @since v20.12.0\n     */\n    export function styleText(\n        format:\n            | ForegroundColors\n            | BackgroundColors\n            | Modifiers\n            | Array<ForegroundColors | BackgroundColors | Modifiers>,\n        text: string,\n    ): string;\n    /**\n     * An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextDecoder` API.\n     *\n     * ```js\n     * const decoder = new TextDecoder();\n     * const u8arr = new Uint8Array([72, 101, 108, 108, 111]);\n     * console.log(decoder.decode(u8arr)); // Hello\n     * ```\n     * @since v8.3.0\n     */\n    export class TextDecoder {\n        /**\n         * The encoding supported by the `TextDecoder` instance.\n         */\n        readonly encoding: string;\n        /**\n         * The value will be `true` if decoding errors result in a `TypeError` being\n         * thrown.\n         */\n        readonly fatal: boolean;\n        /**\n         * The value will be `true` if the decoding result will include the byte order\n         * mark.\n         */\n        readonly ignoreBOM: boolean;\n        constructor(\n            encoding?: string,\n            options?: {\n                fatal?: boolean | undefined;\n                ignoreBOM?: boolean | undefined;\n            },\n        );\n        /**\n         * Decodes the `input` and returns a string. If `options.stream` is `true`, any\n         * incomplete byte sequences occurring at the end of the `input` are buffered\n         * internally and emitted after the next call to `textDecoder.decode()`.\n         *\n         * If `textDecoder.fatal` is `true`, decoding errors that occur will result in a `TypeError` being thrown.\n         * @param input An `ArrayBuffer`, `DataView`, or `TypedArray` instance containing the encoded data.\n         */\n        decode(\n            input?: NodeJS.ArrayBufferView | ArrayBuffer | null,\n            options?: {\n                stream?: boolean | undefined;\n            },\n        ): string;\n    }\n    export interface EncodeIntoResult {\n        /**\n         * The read Unicode code units of input.\n         */\n        read: number;\n        /**\n         * The written UTF-8 bytes of output.\n         */\n        written: number;\n    }\n    export { types };\n\n    //// TextEncoder/Decoder\n    /**\n     * An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextEncoder` API. All\n     * instances of `TextEncoder` only support UTF-8 encoding.\n     *\n     * ```js\n     * const encoder = new TextEncoder();\n     * const uint8array = encoder.encode('this is some data');\n     * ```\n     *\n     * The `TextEncoder` class is also available on the global object.\n     * @since v8.3.0\n     */\n    export class TextEncoder {\n        /**\n         * The encoding supported by the `TextEncoder` instance. Always set to `'utf-8'`.\n         */\n        readonly encoding: string;\n        /**\n         * UTF-8 encodes the `input` string and returns a `Uint8Array` containing the\n         * encoded bytes.\n         * @param [input='an empty string'] The text to encode.\n         */\n        encode(input?: string): Uint8Array;\n        /**\n         * UTF-8 encodes the `src` string to the `dest` Uint8Array and returns an object\n         * containing the read Unicode code units and written UTF-8 bytes.\n         *\n         * ```js\n         * const encoder = new TextEncoder();\n         * const src = 'this is some data';\n         * const dest = new Uint8Array(10);\n         * const { read, written } = encoder.encodeInto(src, dest);\n         * ```\n         * @param src The text to encode.\n         * @param dest The array to hold the encode result.\n         */\n        encodeInto(src: string, dest: Uint8Array): EncodeIntoResult;\n    }\n    import { TextDecoder as _TextDecoder, TextEncoder as _TextEncoder } from \"util\";\n    global {\n        /**\n         * `TextDecoder` class is a global reference for `import { TextDecoder } from 'node:util'`\n         * https://nodejs.org/api/globals.html#textdecoder\n         * @since v11.0.0\n         */\n        var TextDecoder: typeof globalThis extends {\n            onmessage: any;\n            TextDecoder: infer TextDecoder;\n        } ? TextDecoder\n            : typeof _TextDecoder;\n        /**\n         * `TextEncoder` class is a global reference for `import { TextEncoder } from 'node:util'`\n         * https://nodejs.org/api/globals.html#textencoder\n         * @since v11.0.0\n         */\n        var TextEncoder: typeof globalThis extends {\n            onmessage: any;\n            TextEncoder: infer TextEncoder;\n        } ? TextEncoder\n            : typeof _TextEncoder;\n    }\n\n    //// parseArgs\n    /**\n     * Provides a higher level API for command-line argument parsing than interacting\n     * with `process.argv` directly. Takes a specification for the expected arguments\n     * and returns a structured object with the parsed options and positionals.\n     *\n     * ```js\n     * import { parseArgs } from 'node:util';\n     * const args = ['-f', '--bar', 'b'];\n     * const options = {\n     *   foo: {\n     *     type: 'boolean',\n     *     short: 'f',\n     *   },\n     *   bar: {\n     *     type: 'string',\n     *   },\n     * };\n     * const {\n     *   values,\n     *   positionals,\n     * } = parseArgs({ args, options });\n     * console.log(values, positionals);\n     * // Prints: [Object: null prototype] { foo: true, bar: 'b' } []\n     * ```\n     * @since v18.3.0, v16.17.0\n     * @param config Used to provide arguments for parsing and to configure the parser. `config` supports the following properties:\n     * @return The parsed command line arguments:\n     */\n    export function parseArgs<T extends ParseArgsConfig>(config?: T): ParsedResults<T>;\n\n    /**\n     * Type of argument used in {@link parseArgs}.\n     */\n    export type ParseArgsOptionsType = \"boolean\" | \"string\";\n\n    export interface ParseArgsOptionDescriptor {\n        /**\n         * Type of argument.\n         */\n        type: ParseArgsOptionsType;\n        /**\n         * Whether this option can be provided multiple times.\n         * If `true`, all values will be collected in an array.\n         * If `false`, values for the option are last-wins.\n         * @default false.\n         */\n        multiple?: boolean | undefined;\n        /**\n         * A single character alias for the option.\n         */\n        short?: string | undefined;\n        /**\n         * The default value to\n         * be used if (and only if) the option does not appear in the arguments to be\n         * parsed. It must be of the same type as the `type` property. When `multiple`\n         * is `true`, it must be an array.\n         * @since v18.11.0\n         */\n        default?: string | boolean | string[] | boolean[] | undefined;\n    }\n    export interface ParseArgsOptionsConfig {\n        [longOption: string]: ParseArgsOptionDescriptor;\n    }\n    export interface ParseArgsConfig {\n        /**\n         * Array of argument strings.\n         */\n        args?: string[] | undefined;\n        /**\n         * Used to describe arguments known to the parser.\n         */\n        options?: ParseArgsOptionsConfig | undefined;\n        /**\n         * Should an error be thrown when unknown arguments are encountered,\n         * or when arguments are passed that do not match the `type` configured in `options`.\n         * @default true\n         */\n        strict?: boolean | undefined;\n        /**\n         * Whether this command accepts positional arguments.\n         */\n        allowPositionals?: boolean | undefined;\n        /**\n         * If `true`, allows explicitly setting boolean options to `false` by prefixing the option name with `--no-`.\n         * @default false\n         * @since v22.4.0\n         */\n        allowNegative?: boolean | undefined;\n        /**\n         * Return the parsed tokens. This is useful for extending the built-in behavior,\n         * from adding additional checks through to reprocessing the tokens in different ways.\n         * @default false\n         */\n        tokens?: boolean | undefined;\n    }\n    /*\n    IfDefaultsTrue and IfDefaultsFalse are helpers to handle default values for missing boolean properties.\n    TypeScript does not have exact types for objects: https://github.com/microsoft/TypeScript/issues/12936\n    This means it is impossible to distinguish between \"field X is definitely not present\" and \"field X may or may not be present\".\n    But we expect users to generally provide their config inline or `as const`, which means TS will always know whether a given field is present.\n    So this helper treats \"not definitely present\" (i.e., not `extends boolean`) as being \"definitely not present\", i.e. it should have its default value.\n    This is technically incorrect but is a much nicer UX for the common case.\n    The IfDefaultsTrue version is for things which default to true; the IfDefaultsFalse version is for things which default to false.\n    */\n    type IfDefaultsTrue<T, IfTrue, IfFalse> = T extends true ? IfTrue\n        : T extends false ? IfFalse\n        : IfTrue;\n\n    // we put the `extends false` condition first here because `undefined` compares like `any` when `strictNullChecks: false`\n    type IfDefaultsFalse<T, IfTrue, IfFalse> = T extends false ? IfFalse\n        : T extends true ? IfTrue\n        : IfFalse;\n\n    type ExtractOptionValue<T extends ParseArgsConfig, O extends ParseArgsOptionDescriptor> = IfDefaultsTrue<\n        T[\"strict\"],\n        O[\"type\"] extends \"string\" ? string : O[\"type\"] extends \"boolean\" ? boolean : string | boolean,\n        string | boolean\n    >;\n\n    type ApplyOptionalModifiers<O extends ParseArgsOptionsConfig, V extends Record<keyof O, unknown>> = (\n        & { -readonly [LongOption in keyof O]?: V[LongOption] }\n        & { [LongOption in keyof O as O[LongOption][\"default\"] extends {} ? LongOption : never]: V[LongOption] }\n    ) extends infer P ? { [K in keyof P]: P[K] } : never; // resolve intersection to object\n\n    type ParsedValues<T extends ParseArgsConfig> =\n        & IfDefaultsTrue<T[\"strict\"], unknown, { [longOption: string]: undefined | string | boolean }>\n        & (T[\"options\"] extends ParseArgsOptionsConfig ? ApplyOptionalModifiers<\n                T[\"options\"],\n                {\n                    [LongOption in keyof T[\"options\"]]: IfDefaultsFalse<\n                        T[\"options\"][LongOption][\"multiple\"],\n                        Array<ExtractOptionValue<T, T[\"options\"][LongOption]>>,\n                        ExtractOptionValue<T, T[\"options\"][LongOption]>\n                    >;\n                }\n            >\n            : {});\n\n    type ParsedPositionals<T extends ParseArgsConfig> = IfDefaultsTrue<\n        T[\"strict\"],\n        IfDefaultsFalse<T[\"allowPositionals\"], string[], []>,\n        IfDefaultsTrue<T[\"allowPositionals\"], string[], []>\n    >;\n\n    type PreciseTokenForOptions<\n        K extends string,\n        O extends ParseArgsOptionDescriptor,\n    > = O[\"type\"] extends \"string\" ? {\n            kind: \"option\";\n            index: number;\n            name: K;\n            rawName: string;\n            value: string;\n            inlineValue: boolean;\n        }\n        : O[\"type\"] extends \"boolean\" ? {\n                kind: \"option\";\n                index: number;\n                name: K;\n                rawName: string;\n                value: undefined;\n                inlineValue: undefined;\n            }\n        : OptionToken & { name: K };\n\n    type TokenForOptions<\n        T extends ParseArgsConfig,\n        K extends keyof T[\"options\"] = keyof T[\"options\"],\n    > = K extends unknown\n        ? T[\"options\"] extends ParseArgsOptionsConfig ? PreciseTokenForOptions<K & string, T[\"options\"][K]>\n        : OptionToken\n        : never;\n\n    type ParsedOptionToken<T extends ParseArgsConfig> = IfDefaultsTrue<T[\"strict\"], TokenForOptions<T>, OptionToken>;\n\n    type ParsedPositionalToken<T extends ParseArgsConfig> = IfDefaultsTrue<\n        T[\"strict\"],\n        IfDefaultsFalse<T[\"allowPositionals\"], { kind: \"positional\"; index: number; value: string }, never>,\n        IfDefaultsTrue<T[\"allowPositionals\"], { kind: \"positional\"; index: number; value: string }, never>\n    >;\n\n    type ParsedTokens<T extends ParseArgsConfig> = Array<\n        ParsedOptionToken<T> | ParsedPositionalToken<T> | { kind: \"option-terminator\"; index: number }\n    >;\n\n    type PreciseParsedResults<T extends ParseArgsConfig> = IfDefaultsFalse<\n        T[\"tokens\"],\n        {\n            values: ParsedValues<T>;\n            positionals: ParsedPositionals<T>;\n            tokens: ParsedTokens<T>;\n        },\n        {\n            values: ParsedValues<T>;\n            positionals: ParsedPositionals<T>;\n        }\n    >;\n\n    type OptionToken =\n        | { kind: \"option\"; index: number; name: string; rawName: string; value: string; inlineValue: boolean }\n        | {\n            kind: \"option\";\n            index: number;\n            name: string;\n            rawName: string;\n            value: undefined;\n            inlineValue: undefined;\n        };\n\n    type Token =\n        | OptionToken\n        | { kind: \"positional\"; index: number; value: string }\n        | { kind: \"option-terminator\"; index: number };\n\n    // If ParseArgsConfig extends T, then the user passed config constructed elsewhere.\n    // So we can't rely on the `\"not definitely present\" implies \"definitely not present\"` assumption mentioned above.\n    type ParsedResults<T extends ParseArgsConfig> = ParseArgsConfig extends T ? {\n            values: {\n                [longOption: string]: undefined | string | boolean | Array<string | boolean>;\n            };\n            positionals: string[];\n            tokens?: Token[];\n        }\n        : PreciseParsedResults<T>;\n\n    /**\n     * An implementation of [the MIMEType class](https://bmeck.github.io/node-proposal-mime-api/).\n     *\n     * In accordance with browser conventions, all properties of `MIMEType` objects\n     * are implemented as getters and setters on the class prototype, rather than as\n     * data properties on the object itself.\n     *\n     * A MIME string is a structured string containing multiple meaningful\n     * components. When parsed, a `MIMEType` object is returned containing\n     * properties for each of these components.\n     * @since v19.1.0, v18.13.0\n     */\n    export class MIMEType {\n        /**\n         * Creates a new MIMEType object by parsing the input.\n         *\n         * A `TypeError` will be thrown if the `input` is not a valid MIME.\n         * Note that an effort will be made to coerce the given values into strings.\n         * @param input The input MIME to parse.\n         */\n        constructor(input: string | { toString: () => string });\n\n        /**\n         * Gets and sets the type portion of the MIME.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const myMIME = new MIMEType('text/javascript');\n         * console.log(myMIME.type);\n         * // Prints: text\n         * myMIME.type = 'application';\n         * console.log(myMIME.type);\n         * // Prints: application\n         * console.log(String(myMIME));\n         * // Prints: application/javascript\n         * ```\n         */\n        type: string;\n        /**\n         * Gets and sets the subtype portion of the MIME.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const myMIME = new MIMEType('text/ecmascript');\n         * console.log(myMIME.subtype);\n         * // Prints: ecmascript\n         * myMIME.subtype = 'javascript';\n         * console.log(myMIME.subtype);\n         * // Prints: javascript\n         * console.log(String(myMIME));\n         * // Prints: text/javascript\n         * ```\n         */\n        subtype: string;\n        /**\n         * Gets the essence of the MIME. This property is read only.\n         * Use `mime.type` or `mime.subtype` to alter the MIME.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const myMIME = new MIMEType('text/javascript;key=value');\n         * console.log(myMIME.essence);\n         * // Prints: text/javascript\n         * myMIME.type = 'application';\n         * console.log(myMIME.essence);\n         * // Prints: application/javascript\n         * console.log(String(myMIME));\n         * // Prints: application/javascript;key=value\n         * ```\n         */\n        readonly essence: string;\n        /**\n         * Gets the `MIMEParams` object representing the\n         * parameters of the MIME. This property is read-only. See `MIMEParams` documentation for details.\n         */\n        readonly params: MIMEParams;\n        /**\n         * The `toString()` method on the `MIMEType` object returns the serialized MIME.\n         *\n         * Because of the need for standard compliance, this method does not allow users\n         * to customize the serialization process of the MIME.\n         */\n        toString(): string;\n    }\n    /**\n     * The `MIMEParams` API provides read and write access to the parameters of a `MIMEType`.\n     * @since v19.1.0, v18.13.0\n     */\n    export class MIMEParams {\n        /**\n         * Remove all name-value pairs whose name is `name`.\n         */\n        delete(name: string): void;\n        /**\n         * Returns an iterator over each of the name-value pairs in the parameters.\n         * Each item of the iterator is a JavaScript `Array`. The first item of the array\n         * is the `name`, the second item of the array is the `value`.\n         */\n        entries(): NodeJS.Iterator<[name: string, value: string]>;\n        /**\n         * Returns the value of the first name-value pair whose name is `name`. If there\n         * are no such pairs, `null` is returned.\n         * @return or `null` if there is no name-value pair with the given `name`.\n         */\n        get(name: string): string | null;\n        /**\n         * Returns `true` if there is at least one name-value pair whose name is `name`.\n         */\n        has(name: string): boolean;\n        /**\n         * Returns an iterator over the names of each name-value pair.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const { params } = new MIMEType('text/plain;foo=0;bar=1');\n         * for (const name of params.keys()) {\n         *   console.log(name);\n         * }\n         * // Prints:\n         * //   foo\n         * //   bar\n         * ```\n         */\n        keys(): NodeJS.Iterator<string>;\n        /**\n         * Sets the value in the `MIMEParams` object associated with `name` to `value`. If there are any pre-existing name-value pairs whose names are `name`,\n         * set the first such pair's value to `value`.\n         *\n         * ```js\n         * import { MIMEType } from 'node:util';\n         *\n         * const { params } = new MIMEType('text/plain;foo=0;bar=1');\n         * params.set('foo', 'def');\n         * params.set('baz', 'xyz');\n         * console.log(params.toString());\n         * // Prints: foo=def;bar=1;baz=xyz\n         * ```\n         */\n        set(name: string, value: string): void;\n        /**\n         * Returns an iterator over the values of each name-value pair.\n         */\n        values(): NodeJS.Iterator<string>;\n        /**\n         * Returns an iterator over each of the name-value pairs in the parameters.\n         */\n        [Symbol.iterator](): NodeJS.Iterator<[name: string, value: string]>;\n    }\n}\ndeclare module \"util/types\" {\n    import { KeyObject, webcrypto } from \"node:crypto\";\n    /**\n     * Returns `true` if the value is a built-in [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) or\n     * [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instance.\n     *\n     * See also `util.types.isArrayBuffer()` and `util.types.isSharedArrayBuffer()`.\n     *\n     * ```js\n     * util.types.isAnyArrayBuffer(new ArrayBuffer());  // Returns true\n     * util.types.isAnyArrayBuffer(new SharedArrayBuffer());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isAnyArrayBuffer(object: unknown): object is ArrayBufferLike;\n    /**\n     * Returns `true` if the value is an `arguments` object.\n     *\n     * ```js\n     * function foo() {\n     *   util.types.isArgumentsObject(arguments);  // Returns true\n     * }\n     * ```\n     * @since v10.0.0\n     */\n    function isArgumentsObject(object: unknown): object is IArguments;\n    /**\n     * Returns `true` if the value is a built-in [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) instance.\n     * This does _not_ include [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instances. Usually, it is\n     * desirable to test for both; See `util.types.isAnyArrayBuffer()` for that.\n     *\n     * ```js\n     * util.types.isArrayBuffer(new ArrayBuffer());  // Returns true\n     * util.types.isArrayBuffer(new SharedArrayBuffer());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isArrayBuffer(object: unknown): object is ArrayBuffer;\n    /**\n     * Returns `true` if the value is an instance of one of the [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) views, such as typed\n     * array objects or [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView). Equivalent to\n     * [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).\n     *\n     * ```js\n     * util.types.isArrayBufferView(new Int8Array());  // true\n     * util.types.isArrayBufferView(Buffer.from('hello world')); // true\n     * util.types.isArrayBufferView(new DataView(new ArrayBuffer(16)));  // true\n     * util.types.isArrayBufferView(new ArrayBuffer());  // false\n     * ```\n     * @since v10.0.0\n     */\n    function isArrayBufferView(object: unknown): object is NodeJS.ArrayBufferView;\n    /**\n     * Returns `true` if the value is an [async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).\n     * This only reports back what the JavaScript engine is seeing;\n     * in particular, the return value may not match the original source code if\n     * a transpilation tool was used.\n     *\n     * ```js\n     * util.types.isAsyncFunction(function foo() {});  // Returns false\n     * util.types.isAsyncFunction(async function foo() {});  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isAsyncFunction(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a `BigInt64Array` instance.\n     *\n     * ```js\n     * util.types.isBigInt64Array(new BigInt64Array());   // Returns true\n     * util.types.isBigInt64Array(new BigUint64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isBigInt64Array(value: unknown): value is BigInt64Array;\n    /**\n     * Returns `true` if the value is a BigInt object, e.g. created\n     * by `Object(BigInt(123))`.\n     *\n     * ```js\n     * util.types.isBigIntObject(Object(BigInt(123)));   // Returns true\n     * util.types.isBigIntObject(BigInt(123));   // Returns false\n     * util.types.isBigIntObject(123);  // Returns false\n     * ```\n     * @since v10.4.0\n     */\n    function isBigIntObject(object: unknown): object is BigInt;\n    /**\n     * Returns `true` if the value is a `BigUint64Array` instance.\n     *\n     * ```js\n     * util.types.isBigUint64Array(new BigInt64Array());   // Returns false\n     * util.types.isBigUint64Array(new BigUint64Array());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isBigUint64Array(value: unknown): value is BigUint64Array;\n    /**\n     * Returns `true` if the value is a boolean object, e.g. created\n     * by `new Boolean()`.\n     *\n     * ```js\n     * util.types.isBooleanObject(false);  // Returns false\n     * util.types.isBooleanObject(true);   // Returns false\n     * util.types.isBooleanObject(new Boolean(false)); // Returns true\n     * util.types.isBooleanObject(new Boolean(true));  // Returns true\n     * util.types.isBooleanObject(Boolean(false)); // Returns false\n     * util.types.isBooleanObject(Boolean(true));  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isBooleanObject(object: unknown): object is Boolean;\n    /**\n     * Returns `true` if the value is any boxed primitive object, e.g. created\n     * by `new Boolean()`, `new String()` or `Object(Symbol())`.\n     *\n     * For example:\n     *\n     * ```js\n     * util.types.isBoxedPrimitive(false); // Returns false\n     * util.types.isBoxedPrimitive(new Boolean(false)); // Returns true\n     * util.types.isBoxedPrimitive(Symbol('foo')); // Returns false\n     * util.types.isBoxedPrimitive(Object(Symbol('foo'))); // Returns true\n     * util.types.isBoxedPrimitive(Object(BigInt(5))); // Returns true\n     * ```\n     * @since v10.11.0\n     */\n    function isBoxedPrimitive(object: unknown): object is String | Number | BigInt | Boolean | Symbol;\n    /**\n     * Returns `true` if the value is a built-in [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) instance.\n     *\n     * ```js\n     * const ab = new ArrayBuffer(20);\n     * util.types.isDataView(new DataView(ab));  // Returns true\n     * util.types.isDataView(new Float64Array());  // Returns false\n     * ```\n     *\n     * See also [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).\n     * @since v10.0.0\n     */\n    function isDataView(object: unknown): object is DataView;\n    /**\n     * Returns `true` if the value is a built-in [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.\n     *\n     * ```js\n     * util.types.isDate(new Date());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isDate(object: unknown): object is Date;\n    /**\n     * Returns `true` if the value is a native `External` value.\n     *\n     * A native `External` value is a special type of object that contains a\n     * raw C++ pointer (`void*`) for access from native code, and has no other\n     * properties. Such objects are created either by Node.js internals or native\n     * addons. In JavaScript, they are\n     * [frozen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) objects with a\n     * `null` prototype.\n     *\n     * ```c\n     * #include <js_native_api.h>\n     * #include <stdlib.h>\n     * napi_value result;\n     * static napi_value MyNapi(napi_env env, napi_callback_info info) {\n     *   int* raw = (int*) malloc(1024);\n     *   napi_status status = napi_create_external(env, (void*) raw, NULL, NULL, &result);\n     *   if (status != napi_ok) {\n     *     napi_throw_error(env, NULL, \"napi_create_external failed\");\n     *     return NULL;\n     *   }\n     *   return result;\n     * }\n     * ...\n     * DECLARE_NAPI_PROPERTY(\"myNapi\", MyNapi)\n     * ...\n     * ```\n     *\n     * ```js\n     * import native from 'napi_addon.node';\n     * import { types } from 'node:util';\n     *\n     * const data = native.myNapi();\n     * types.isExternal(data); // returns true\n     * types.isExternal(0); // returns false\n     * types.isExternal(new String('foo')); // returns false\n     * ```\n     *\n     * For further information on `napi_create_external`, refer to\n     * [`napi_create_external()`](https://nodejs.org/docs/latest-v22.x/api/n-api.html#napi_create_external).\n     * @since v10.0.0\n     */\n    function isExternal(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a built-in [`Float32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array) instance.\n     *\n     * ```js\n     * util.types.isFloat32Array(new ArrayBuffer());  // Returns false\n     * util.types.isFloat32Array(new Float32Array());  // Returns true\n     * util.types.isFloat32Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isFloat32Array(object: unknown): object is Float32Array;\n    /**\n     * Returns `true` if the value is a built-in [`Float64Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array) instance.\n     *\n     * ```js\n     * util.types.isFloat64Array(new ArrayBuffer());  // Returns false\n     * util.types.isFloat64Array(new Uint8Array());  // Returns false\n     * util.types.isFloat64Array(new Float64Array());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isFloat64Array(object: unknown): object is Float64Array;\n    /**\n     * Returns `true` if the value is a generator function.\n     * This only reports back what the JavaScript engine is seeing;\n     * in particular, the return value may not match the original source code if\n     * a transpilation tool was used.\n     *\n     * ```js\n     * util.types.isGeneratorFunction(function foo() {});  // Returns false\n     * util.types.isGeneratorFunction(function* foo() {});  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isGeneratorFunction(object: unknown): object is GeneratorFunction;\n    /**\n     * Returns `true` if the value is a generator object as returned from a\n     * built-in generator function.\n     * This only reports back what the JavaScript engine is seeing;\n     * in particular, the return value may not match the original source code if\n     * a transpilation tool was used.\n     *\n     * ```js\n     * function* foo() {}\n     * const generator = foo();\n     * util.types.isGeneratorObject(generator);  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isGeneratorObject(object: unknown): object is Generator;\n    /**\n     * Returns `true` if the value is a built-in [`Int8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) instance.\n     *\n     * ```js\n     * util.types.isInt8Array(new ArrayBuffer());  // Returns false\n     * util.types.isInt8Array(new Int8Array());  // Returns true\n     * util.types.isInt8Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isInt8Array(object: unknown): object is Int8Array;\n    /**\n     * Returns `true` if the value is a built-in [`Int16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array) instance.\n     *\n     * ```js\n     * util.types.isInt16Array(new ArrayBuffer());  // Returns false\n     * util.types.isInt16Array(new Int16Array());  // Returns true\n     * util.types.isInt16Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isInt16Array(object: unknown): object is Int16Array;\n    /**\n     * Returns `true` if the value is a built-in [`Int32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array) instance.\n     *\n     * ```js\n     * util.types.isInt32Array(new ArrayBuffer());  // Returns false\n     * util.types.isInt32Array(new Int32Array());  // Returns true\n     * util.types.isInt32Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isInt32Array(object: unknown): object is Int32Array;\n    /**\n     * Returns `true` if the value is a built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance.\n     *\n     * ```js\n     * util.types.isMap(new Map());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isMap<T>(\n        object: T | {},\n    ): object is T extends ReadonlyMap<any, any> ? (unknown extends T ? never : ReadonlyMap<any, any>)\n        : Map<unknown, unknown>;\n    /**\n     * Returns `true` if the value is an iterator returned for a built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance.\n     *\n     * ```js\n     * const map = new Map();\n     * util.types.isMapIterator(map.keys());  // Returns true\n     * util.types.isMapIterator(map.values());  // Returns true\n     * util.types.isMapIterator(map.entries());  // Returns true\n     * util.types.isMapIterator(map[Symbol.iterator]());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isMapIterator(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is an instance of a [Module Namespace Object](https://tc39.github.io/ecma262/#sec-module-namespace-exotic-objects).\n     *\n     * ```js\n     * import * as ns from './a.js';\n     *\n     * util.types.isModuleNamespaceObject(ns);  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isModuleNamespaceObject(value: unknown): boolean;\n    /**\n     * Returns `true` if the value was returned by the constructor of a\n     * [built-in `Error` type](https://tc39.es/ecma262/#sec-error-objects).\n     *\n     * ```js\n     * console.log(util.types.isNativeError(new Error()));  // true\n     * console.log(util.types.isNativeError(new TypeError()));  // true\n     * console.log(util.types.isNativeError(new RangeError()));  // true\n     * ```\n     *\n     * Subclasses of the native error types are also native errors:\n     *\n     * ```js\n     * class MyError extends Error {}\n     * console.log(util.types.isNativeError(new MyError()));  // true\n     * ```\n     *\n     * A value being `instanceof` a native error class is not equivalent to `isNativeError()`\n     * returning `true` for that value. `isNativeError()` returns `true` for errors\n     * which come from a different [realm](https://tc39.es/ecma262/#realm) while `instanceof Error` returns `false`\n     * for these errors:\n     *\n     * ```js\n     * import { createContext, runInContext } from 'node:vm';\n     * import { types } from 'node:util';\n     *\n     * const context = createContext({});\n     * const myError = runInContext('new Error()', context);\n     * console.log(types.isNativeError(myError)); // true\n     * console.log(myError instanceof Error); // false\n     * ```\n     *\n     * Conversely, `isNativeError()` returns `false` for all objects which were not\n     * returned by the constructor of a native error. That includes values\n     * which are `instanceof` native errors:\n     *\n     * ```js\n     * const myError = { __proto__: Error.prototype };\n     * console.log(util.types.isNativeError(myError)); // false\n     * console.log(myError instanceof Error); // true\n     * ```\n     * @since v10.0.0\n     */\n    function isNativeError(object: unknown): object is Error;\n    /**\n     * Returns `true` if the value is a number object, e.g. created\n     * by `new Number()`.\n     *\n     * ```js\n     * util.types.isNumberObject(0);  // Returns false\n     * util.types.isNumberObject(new Number(0));   // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isNumberObject(object: unknown): object is Number;\n    /**\n     * Returns `true` if the value is a built-in [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n     *\n     * ```js\n     * util.types.isPromise(Promise.resolve(42));  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isPromise(object: unknown): object is Promise<unknown>;\n    /**\n     * Returns `true` if the value is a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) instance.\n     *\n     * ```js\n     * const target = {};\n     * const proxy = new Proxy(target, {});\n     * util.types.isProxy(target);  // Returns false\n     * util.types.isProxy(proxy);  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isProxy(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a regular expression object.\n     *\n     * ```js\n     * util.types.isRegExp(/abc/);  // Returns true\n     * util.types.isRegExp(new RegExp('abc'));  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isRegExp(object: unknown): object is RegExp;\n    /**\n     * Returns `true` if the value is a built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.\n     *\n     * ```js\n     * util.types.isSet(new Set());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSet<T>(\n        object: T | {},\n    ): object is T extends ReadonlySet<any> ? (unknown extends T ? never : ReadonlySet<any>) : Set<unknown>;\n    /**\n     * Returns `true` if the value is an iterator returned for a built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.\n     *\n     * ```js\n     * const set = new Set();\n     * util.types.isSetIterator(set.keys());  // Returns true\n     * util.types.isSetIterator(set.values());  // Returns true\n     * util.types.isSetIterator(set.entries());  // Returns true\n     * util.types.isSetIterator(set[Symbol.iterator]());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSetIterator(object: unknown): boolean;\n    /**\n     * Returns `true` if the value is a built-in [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instance.\n     * This does _not_ include [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) instances. Usually, it is\n     * desirable to test for both; See `util.types.isAnyArrayBuffer()` for that.\n     *\n     * ```js\n     * util.types.isSharedArrayBuffer(new ArrayBuffer());  // Returns false\n     * util.types.isSharedArrayBuffer(new SharedArrayBuffer());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSharedArrayBuffer(object: unknown): object is SharedArrayBuffer;\n    /**\n     * Returns `true` if the value is a string object, e.g. created\n     * by `new String()`.\n     *\n     * ```js\n     * util.types.isStringObject('foo');  // Returns false\n     * util.types.isStringObject(new String('foo'));   // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isStringObject(object: unknown): object is String;\n    /**\n     * Returns `true` if the value is a symbol object, created\n     * by calling `Object()` on a `Symbol` primitive.\n     *\n     * ```js\n     * const symbol = Symbol('foo');\n     * util.types.isSymbolObject(symbol);  // Returns false\n     * util.types.isSymbolObject(Object(symbol));   // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isSymbolObject(object: unknown): object is Symbol;\n    /**\n     * Returns `true` if the value is a built-in [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) instance.\n     *\n     * ```js\n     * util.types.isTypedArray(new ArrayBuffer());  // Returns false\n     * util.types.isTypedArray(new Uint8Array());  // Returns true\n     * util.types.isTypedArray(new Float64Array());  // Returns true\n     * ```\n     *\n     * See also [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).\n     * @since v10.0.0\n     */\n    function isTypedArray(object: unknown): object is NodeJS.TypedArray;\n    /**\n     * Returns `true` if the value is a built-in [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instance.\n     *\n     * ```js\n     * util.types.isUint8Array(new ArrayBuffer());  // Returns false\n     * util.types.isUint8Array(new Uint8Array());  // Returns true\n     * util.types.isUint8Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint8Array(object: unknown): object is Uint8Array;\n    /**\n     * Returns `true` if the value is a built-in [`Uint8ClampedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) instance.\n     *\n     * ```js\n     * util.types.isUint8ClampedArray(new ArrayBuffer());  // Returns false\n     * util.types.isUint8ClampedArray(new Uint8ClampedArray());  // Returns true\n     * util.types.isUint8ClampedArray(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint8ClampedArray(object: unknown): object is Uint8ClampedArray;\n    /**\n     * Returns `true` if the value is a built-in [`Uint16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array) instance.\n     *\n     * ```js\n     * util.types.isUint16Array(new ArrayBuffer());  // Returns false\n     * util.types.isUint16Array(new Uint16Array());  // Returns true\n     * util.types.isUint16Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint16Array(object: unknown): object is Uint16Array;\n    /**\n     * Returns `true` if the value is a built-in [`Uint32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array) instance.\n     *\n     * ```js\n     * util.types.isUint32Array(new ArrayBuffer());  // Returns false\n     * util.types.isUint32Array(new Uint32Array());  // Returns true\n     * util.types.isUint32Array(new Float64Array());  // Returns false\n     * ```\n     * @since v10.0.0\n     */\n    function isUint32Array(object: unknown): object is Uint32Array;\n    /**\n     * Returns `true` if the value is a built-in [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) instance.\n     *\n     * ```js\n     * util.types.isWeakMap(new WeakMap());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isWeakMap(object: unknown): object is WeakMap<object, unknown>;\n    /**\n     * Returns `true` if the value is a built-in [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) instance.\n     *\n     * ```js\n     * util.types.isWeakSet(new WeakSet());  // Returns true\n     * ```\n     * @since v10.0.0\n     */\n    function isWeakSet(object: unknown): object is WeakSet<object>;\n    /**\n     * Returns `true` if `value` is a `KeyObject`, `false` otherwise.\n     * @since v16.2.0\n     */\n    function isKeyObject(object: unknown): object is KeyObject;\n    /**\n     * Returns `true` if `value` is a `CryptoKey`, `false` otherwise.\n     * @since v16.2.0\n     */\n    function isCryptoKey(object: unknown): object is webcrypto.CryptoKey;\n}\ndeclare module \"node:util\" {\n    export * from \"util\";\n}\ndeclare module \"node:util/types\" {\n    export * from \"util/types\";\n}\n"
        }
    ]
}