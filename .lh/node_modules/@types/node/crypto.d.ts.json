{
    "sourceFile": "node_modules/@types/node/crypto.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:crypto` module provides cryptographic functionality that includes a\n * set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify\n * functions.\n *\n * ```js\n * const { createHmac } = await import('node:crypto');\n *\n * const secret = 'abcdefg';\n * const hash = createHmac('sha256', secret)\n *                .update('I love cupcakes')\n *                .digest('hex');\n * console.log(hash);\n * // Prints:\n * //   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e\n * ```\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/crypto.js)\n */\ndeclare module \"crypto\" {\n    import * as stream from \"node:stream\";\n    import { PeerCertificate } from \"node:tls\";\n    /**\n     * SPKAC is a Certificate Signing Request mechanism originally implemented by\n     * Netscape and was specified formally as part of HTML5's `keygen` element.\n     *\n     * `<keygen>` is deprecated since [HTML 5.2](https://www.w3.org/TR/html52/changes.html#features-removed) and new projects\n     * should not use this element anymore.\n     *\n     * The `node:crypto` module provides the `Certificate` class for working with SPKAC\n     * data. The most common usage is handling output generated by the HTML5 `<keygen>` element. Node.js uses [OpenSSL's SPKAC\n     * implementation](https://www.openssl.org/docs/man3.0/man1/openssl-spkac.html) internally.\n     * @since v0.11.8\n     */\n    class Certificate {\n        /**\n         * ```js\n         * const { Certificate } = await import('node:crypto');\n         * const spkac = getSpkacSomehow();\n         * const challenge = Certificate.exportChallenge(spkac);\n         * console.log(challenge.toString('utf8'));\n         * // Prints: the challenge as a UTF8 string\n         * ```\n         * @since v9.0.0\n         * @param encoding The `encoding` of the `spkac` string.\n         * @return The challenge component of the `spkac` data structure, which includes a public key and a challenge.\n         */\n        static exportChallenge(spkac: BinaryLike): Buffer;\n        /**\n         * ```js\n         * const { Certificate } = await import('node:crypto');\n         * const spkac = getSpkacSomehow();\n         * const publicKey = Certificate.exportPublicKey(spkac);\n         * console.log(publicKey);\n         * // Prints: the public key as <Buffer ...>\n         * ```\n         * @since v9.0.0\n         * @param encoding The `encoding` of the `spkac` string.\n         * @return The public key component of the `spkac` data structure, which includes a public key and a challenge.\n         */\n        static exportPublicKey(spkac: BinaryLike, encoding?: string): Buffer;\n        /**\n         * ```js\n         * import { Buffer } from 'node:buffer';\n         * const { Certificate } = await import('node:crypto');\n         *\n         * const spkac = getSpkacSomehow();\n         * console.log(Certificate.verifySpkac(Buffer.from(spkac)));\n         * // Prints: true or false\n         * ```\n         * @since v9.0.0\n         * @param encoding The `encoding` of the `spkac` string.\n         * @return `true` if the given `spkac` data structure is valid, `false` otherwise.\n         */\n        static verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;\n        /**\n         * @deprecated\n         * @param spkac\n         * @returns The challenge component of the `spkac` data structure,\n         * which includes a public key and a challenge.\n         */\n        exportChallenge(spkac: BinaryLike): Buffer;\n        /**\n         * @deprecated\n         * @param spkac\n         * @param encoding The encoding of the spkac string.\n         * @returns The public key component of the `spkac` data structure,\n         * which includes a public key and a challenge.\n         */\n        exportPublicKey(spkac: BinaryLike, encoding?: string): Buffer;\n        /**\n         * @deprecated\n         * @param spkac\n         * @returns `true` if the given `spkac` data structure is valid,\n         * `false` otherwise.\n         */\n        verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;\n    }\n    namespace constants {\n        // https://nodejs.org/dist/latest-v22.x/docs/api/crypto.html#crypto-constants\n        const OPENSSL_VERSION_NUMBER: number;\n        /** Applies multiple bug workarounds within OpenSSL. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html for detail. */\n        const SSL_OP_ALL: number;\n        /** Instructs OpenSSL to allow a non-[EC]DHE-based key exchange mode for TLS v1.3 */\n        const SSL_OP_ALLOW_NO_DHE_KEX: number;\n        /** Allows legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */\n        const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;\n        /** Attempts to use the server's preferences instead of the client's when selecting a cipher. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */\n        const SSL_OP_CIPHER_SERVER_PREFERENCE: number;\n        /** Instructs OpenSSL to use Cisco's version identifier of DTLS_BAD_VER. */\n        const SSL_OP_CISCO_ANYCONNECT: number;\n        /** Instructs OpenSSL to turn on cookie exchange. */\n        const SSL_OP_COOKIE_EXCHANGE: number;\n        /** Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft. */\n        const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;\n        /** Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d. */\n        const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;\n        /** Allows initial connection to servers that do not support RI. */\n        const SSL_OP_LEGACY_SERVER_CONNECT: number;\n        /** Instructs OpenSSL to disable support for SSL/TLS compression. */\n        const SSL_OP_NO_COMPRESSION: number;\n        /** Instructs OpenSSL to disable encrypt-then-MAC. */\n        const SSL_OP_NO_ENCRYPT_THEN_MAC: number;\n        const SSL_OP_NO_QUERY_MTU: number;\n        /** Instructs OpenSSL to disable renegotiation. */\n        const SSL_OP_NO_RENEGOTIATION: number;\n        /** Instructs OpenSSL to always start a new session when performing renegotiation. */\n        const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;\n        /** Instructs OpenSSL to turn off SSL v2 */\n        const SSL_OP_NO_SSLv2: number;\n        /** Instructs OpenSSL to turn off SSL v3 */\n        const SSL_OP_NO_SSLv3: number;\n        /** Instructs OpenSSL to disable use of RFC4507bis tickets. */\n        const SSL_OP_NO_TICKET: number;\n        /** Instructs OpenSSL to turn off TLS v1 */\n        const SSL_OP_NO_TLSv1: number;\n        /** Instructs OpenSSL to turn off TLS v1.1 */\n        const SSL_OP_NO_TLSv1_1: number;\n        /** Instructs OpenSSL to turn off TLS v1.2 */\n        const SSL_OP_NO_TLSv1_2: number;\n        /** Instructs OpenSSL to turn off TLS v1.3 */\n        const SSL_OP_NO_TLSv1_3: number;\n        /** Instructs OpenSSL server to prioritize ChaCha20-Poly1305 when the client does. This option has no effect if `SSL_OP_CIPHER_SERVER_PREFERENCE` is not enabled. */\n        const SSL_OP_PRIORITIZE_CHACHA: number;\n        /** Instructs OpenSSL to disable version rollback attack detection. */\n        const SSL_OP_TLS_ROLLBACK_BUG: number;\n        const ENGINE_METHOD_RSA: number;\n        const ENGINE_METHOD_DSA: number;\n        const ENGINE_METHOD_DH: number;\n        const ENGINE_METHOD_RAND: number;\n        const ENGINE_METHOD_EC: number;\n        const ENGINE_METHOD_CIPHERS: number;\n        const ENGINE_METHOD_DIGESTS: number;\n        const ENGINE_METHOD_PKEY_METHS: number;\n        const ENGINE_METHOD_PKEY_ASN1_METHS: number;\n        const ENGINE_METHOD_ALL: number;\n        const ENGINE_METHOD_NONE: number;\n        const DH_CHECK_P_NOT_SAFE_PRIME: number;\n        const DH_CHECK_P_NOT_PRIME: number;\n        const DH_UNABLE_TO_CHECK_GENERATOR: number;\n        const DH_NOT_SUITABLE_GENERATOR: number;\n        const RSA_PKCS1_PADDING: number;\n        const RSA_SSLV23_PADDING: number;\n        const RSA_NO_PADDING: number;\n        const RSA_PKCS1_OAEP_PADDING: number;\n        const RSA_X931_PADDING: number;\n        const RSA_PKCS1_PSS_PADDING: number;\n        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the digest size when signing or verifying. */\n        const RSA_PSS_SALTLEN_DIGEST: number;\n        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the maximum permissible value when signing data. */\n        const RSA_PSS_SALTLEN_MAX_SIGN: number;\n        /** Causes the salt length for RSA_PKCS1_PSS_PADDING to be determined automatically when verifying a signature. */\n        const RSA_PSS_SALTLEN_AUTO: number;\n        const POINT_CONVERSION_COMPRESSED: number;\n        const POINT_CONVERSION_UNCOMPRESSED: number;\n        const POINT_CONVERSION_HYBRID: number;\n        /** Specifies the built-in default cipher list used by Node.js (colon-separated values). */\n        const defaultCoreCipherList: string;\n        /** Specifies the active default cipher list used by the current Node.js process  (colon-separated values). */\n        const defaultCipherList: string;\n    }\n    interface HashOptions extends stream.TransformOptions {\n        /**\n         * For XOF hash functions such as `shake256`, the\n         * outputLength option can be used to specify the desired output length in bytes.\n         */\n        outputLength?: number | undefined;\n    }\n    /** @deprecated since v10.0.0 */\n    const fips: boolean;\n    /**\n     * Creates and returns a `Hash` object that can be used to generate hash digests\n     * using the given `algorithm`. Optional `options` argument controls stream\n     * behavior. For XOF hash functions such as `'shake256'`, the `outputLength` option\n     * can be used to specify the desired output length in bytes.\n     *\n     * The `algorithm` is dependent on the available algorithms supported by the\n     * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.\n     * On recent releases of OpenSSL, `openssl list -digest-algorithms` will\n     * display the available digest algorithms.\n     *\n     * Example: generating the sha256 sum of a file\n     *\n     * ```js\n     * import {\n     *   createReadStream,\n     * } from 'node:fs';\n     * import { argv } from 'node:process';\n     * const {\n     *   createHash,\n     * } = await import('node:crypto');\n     *\n     * const filename = argv[2];\n     *\n     * const hash = createHash('sha256');\n     *\n     * const input = createReadStream(filename);\n     * input.on('readable', () => {\n     *   // Only one element is going to be produced by the\n     *   // hash stream.\n     *   const data = input.read();\n     *   if (data)\n     *     hash.update(data);\n     *   else {\n     *     console.log(`${hash.digest('hex')} ${filename}`);\n     *   }\n     * });\n     * ```\n     * @since v0.1.92\n     * @param options `stream.transform` options\n     */\n    function createHash(algorithm: string, options?: HashOptions): Hash;\n    /**\n     * Creates and returns an `Hmac` object that uses the given `algorithm` and `key`.\n     * Optional `options` argument controls stream behavior.\n     *\n     * The `algorithm` is dependent on the available algorithms supported by the\n     * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.\n     * On recent releases of OpenSSL, `openssl list -digest-algorithms` will\n     * display the available digest algorithms.\n     *\n     * The `key` is the HMAC key used to generate the cryptographic HMAC hash. If it is\n     * a `KeyObject`, its type must be `secret`. If it is a string, please consider `caveats when using strings as inputs to cryptographic APIs`. If it was\n     * obtained from a cryptographically secure source of entropy, such as {@link randomBytes} or {@link generateKey}, its length should not\n     * exceed the block size of `algorithm` (e.g., 512 bits for SHA-256).\n     *\n     * Example: generating the sha256 HMAC of a file\n     *\n     * ```js\n     * import {\n     *   createReadStream,\n     * } from 'node:fs';\n     * import { argv } from 'node:process';\n     * const {\n     *   createHmac,\n     * } = await import('node:crypto');\n     *\n     * const filename = argv[2];\n     *\n     * const hmac = createHmac('sha256', 'a secret');\n     *\n     * const input = createReadStream(filename);\n     * input.on('readable', () => {\n     *   // Only one element is going to be produced by the\n     *   // hash stream.\n     *   const data = input.read();\n     *   if (data)\n     *     hmac.update(data);\n     *   else {\n     *     console.log(`${hmac.digest('hex')} ${filename}`);\n     *   }\n     * });\n     * ```\n     * @since v0.1.94\n     * @param options `stream.transform` options\n     */\n    function createHmac(algorithm: string, key: BinaryLike | KeyObject, options?: stream.TransformOptions): Hmac;\n    // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings\n    type BinaryToTextEncoding = \"base64\" | \"base64url\" | \"hex\" | \"binary\";\n    type CharacterEncoding = \"utf8\" | \"utf-8\" | \"utf16le\" | \"utf-16le\" | \"latin1\";\n    type LegacyCharacterEncoding = \"ascii\" | \"binary\" | \"ucs2\" | \"ucs-2\";\n    type Encoding = BinaryToTextEncoding | CharacterEncoding | LegacyCharacterEncoding;\n    type ECDHKeyFormat = \"compressed\" | \"uncompressed\" | \"hybrid\";\n    /**\n     * The `Hash` class is a utility for creating hash digests of data. It can be\n     * used in one of two ways:\n     *\n     * * As a `stream` that is both readable and writable, where data is written\n     * to produce a computed hash digest on the readable side, or\n     * * Using the `hash.update()` and `hash.digest()` methods to produce the\n     * computed hash.\n     *\n     * The {@link createHash} method is used to create `Hash` instances. `Hash`objects are not to be created directly using the `new` keyword.\n     *\n     * Example: Using `Hash` objects as streams:\n     *\n     * ```js\n     * const {\n     *   createHash,\n     * } = await import('node:crypto');\n     *\n     * const hash = createHash('sha256');\n     *\n     * hash.on('readable', () => {\n     *   // Only one element is going to be produced by the\n     *   // hash stream.\n     *   const data = hash.read();\n     *   if (data) {\n     *     console.log(data.toString('hex'));\n     *     // Prints:\n     *     //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50\n     *   }\n     * });\n     *\n     * hash.write('some data to hash');\n     * hash.end();\n     * ```\n     *\n     * Example: Using `Hash` and piped streams:\n     *\n     * ```js\n     * import { createReadStream } from 'node:fs';\n     * import { stdout } from 'node:process';\n     * const { createHash } = await import('node:crypto');\n     *\n     * const hash = createHash('sha256');\n     *\n     * const input = createReadStream('test.js');\n     * input.pipe(hash).setEncoding('hex').pipe(stdout);\n     * ```\n     *\n     * Example: Using the `hash.update()` and `hash.digest()` methods:\n     *\n     * ```js\n     * const {\n     *   createHash,\n     * } = await import('node:crypto');\n     *\n     * const hash = createHash('sha256');\n     *\n     * hash.update('some data to hash');\n     * console.log(hash.digest('hex'));\n     * // Prints:\n     * //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50\n     * ```\n     * @since v0.1.92\n     */\n    class Hash extends stream.Transform {\n        private constructor();\n        /**\n         * Creates a new `Hash` object that contains a deep copy of the internal state\n         * of the current `Hash` object.\n         *\n         * The optional `options` argument controls stream behavior. For XOF hash\n         * functions such as `'shake256'`, the `outputLength` option can be used to\n         * specify the desired output length in bytes.\n         *\n         * An error is thrown when an attempt is made to copy the `Hash` object after\n         * its `hash.digest()` method has been called.\n         *\n         * ```js\n         * // Calculate a rolling hash.\n         * const {\n         *   createHash,\n         * } = await import('node:crypto');\n         *\n         * const hash = createHash('sha256');\n         *\n         * hash.update('one');\n         * console.log(hash.copy().digest('hex'));\n         *\n         * hash.update('two');\n         * console.log(hash.copy().digest('hex'));\n         *\n         * hash.update('three');\n         * console.log(hash.copy().digest('hex'));\n         *\n         * // Etc.\n         * ```\n         * @since v13.1.0\n         * @param options `stream.transform` options\n         */\n        copy(options?: HashOptions): Hash;\n        /**\n         * Updates the hash content with the given `data`, the encoding of which\n         * is given in `inputEncoding`.\n         * If `encoding` is not provided, and the `data` is a string, an\n         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n         *\n         * This can be called many times with new data as it is streamed.\n         * @since v0.1.92\n         * @param inputEncoding The `encoding` of the `data` string.\n         */\n        update(data: BinaryLike): Hash;\n        update(data: string, inputEncoding: Encoding): Hash;\n        /**\n         * Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).\n         * If `encoding` is provided a string will be returned; otherwise\n         * a `Buffer` is returned.\n         *\n         * The `Hash` object can not be used again after `hash.digest()` method has been\n         * called. Multiple calls will cause an error to be thrown.\n         * @since v0.1.92\n         * @param encoding The `encoding` of the return value.\n         */\n        digest(): Buffer;\n        digest(encoding: BinaryToTextEncoding): string;\n    }\n    /**\n     * The `Hmac` class is a utility for creating cryptographic HMAC digests. It can\n     * be used in one of two ways:\n     *\n     * * As a `stream` that is both readable and writable, where data is written\n     * to produce a computed HMAC digest on the readable side, or\n     * * Using the `hmac.update()` and `hmac.digest()` methods to produce the\n     * computed HMAC digest.\n     *\n     * The {@link createHmac} method is used to create `Hmac` instances. `Hmac`objects are not to be created directly using the `new` keyword.\n     *\n     * Example: Using `Hmac` objects as streams:\n     *\n     * ```js\n     * const {\n     *   createHmac,\n     * } = await import('node:crypto');\n     *\n     * const hmac = createHmac('sha256', 'a secret');\n     *\n     * hmac.on('readable', () => {\n     *   // Only one element is going to be produced by the\n     *   // hash stream.\n     *   const data = hmac.read();\n     *   if (data) {\n     *     console.log(data.toString('hex'));\n     *     // Prints:\n     *     //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e\n     *   }\n     * });\n     *\n     * hmac.write('some data to hash');\n     * hmac.end();\n     * ```\n     *\n     * Example: Using `Hmac` and piped streams:\n     *\n     * ```js\n     * import { createReadStream } from 'node:fs';\n     * import { stdout } from 'node:process';\n     * const {\n     *   createHmac,\n     * } = await import('node:crypto');\n     *\n     * const hmac = createHmac('sha256', 'a secret');\n     *\n     * const input = createReadStream('test.js');\n     * input.pipe(hmac).pipe(stdout);\n     * ```\n     *\n     * Example: Using the `hmac.update()` and `hmac.digest()` methods:\n     *\n     * ```js\n     * const {\n     *   createHmac,\n     * } = await import('node:crypto');\n     *\n     * const hmac = createHmac('sha256', 'a secret');\n     *\n     * hmac.update('some data to hash');\n     * console.log(hmac.digest('hex'));\n     * // Prints:\n     * //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e\n     * ```\n     * @since v0.1.94\n     * @deprecated Since v20.13.0 Calling `Hmac` class directly with `Hmac()` or `new Hmac()` is deprecated due to being internals, not intended for public use. Please use the {@link createHmac} method to create Hmac instances.\n     */\n    class Hmac extends stream.Transform {\n        private constructor();\n        /**\n         * Updates the `Hmac` content with the given `data`, the encoding of which\n         * is given in `inputEncoding`.\n         * If `encoding` is not provided, and the `data` is a string, an\n         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n         *\n         * This can be called many times with new data as it is streamed.\n         * @since v0.1.94\n         * @param inputEncoding The `encoding` of the `data` string.\n         */\n        update(data: BinaryLike): Hmac;\n        update(data: string, inputEncoding: Encoding): Hmac;\n        /**\n         * Calculates the HMAC digest of all of the data passed using `hmac.update()`.\n         * If `encoding` is\n         * provided a string is returned; otherwise a `Buffer` is returned;\n         *\n         * The `Hmac` object can not be used again after `hmac.digest()` has been\n         * called. Multiple calls to `hmac.digest()` will result in an error being thrown.\n         * @since v0.1.94\n         * @param encoding The `encoding` of the return value.\n         */\n        digest(): Buffer;\n        digest(encoding: BinaryToTextEncoding): string;\n    }\n    type KeyObjectType = \"secret\" | \"public\" | \"private\";\n    interface KeyExportOptions<T extends KeyFormat> {\n        type: \"pkcs1\" | \"spki\" | \"pkcs8\" | \"sec1\";\n        format: T;\n        cipher?: string | undefined;\n        passphrase?: string | Buffer | undefined;\n    }\n    interface JwkKeyExportOptions {\n        format: \"jwk\";\n    }\n    interface JsonWebKey {\n        crv?: string | undefined;\n        d?: string | undefined;\n        dp?: string | undefined;\n        dq?: string | undefined;\n        e?: string | undefined;\n        k?: string | undefined;\n        kty?: string | undefined;\n        n?: string | undefined;\n        p?: string | undefined;\n        q?: string | undefined;\n        qi?: string | undefined;\n        x?: string | undefined;\n        y?: string | undefined;\n        [key: string]: unknown;\n    }\n    interface AsymmetricKeyDetails {\n        /**\n         * Key size in bits (RSA, DSA).\n         */\n        modulusLength?: number | undefined;\n        /**\n         * Public exponent (RSA).\n         */\n        publicExponent?: bigint | undefined;\n        /**\n         * Name of the message digest (RSA-PSS).\n         */\n        hashAlgorithm?: string | undefined;\n        /**\n         * Name of the message digest used by MGF1 (RSA-PSS).\n         */\n        mgf1HashAlgorithm?: string | undefined;\n        /**\n         * Minimal salt length in bytes (RSA-PSS).\n         */\n        saltLength?: number | undefined;\n        /**\n         * Size of q in bits (DSA).\n         */\n        divisorLength?: number | undefined;\n        /**\n         * Name of the curve (EC).\n         */\n        namedCurve?: string | undefined;\n    }\n    /**\n     * Node.js uses a `KeyObject` class to represent a symmetric or asymmetric key,\n     * and each kind of key exposes different functions. The {@link createSecretKey}, {@link createPublicKey} and {@link createPrivateKey} methods are used to create `KeyObject`instances. `KeyObject`\n     * objects are not to be created directly using the `new`keyword.\n     *\n     * Most applications should consider using the new `KeyObject` API instead of\n     * passing keys as strings or `Buffer`s due to improved security features.\n     *\n     * `KeyObject` instances can be passed to other threads via `postMessage()`.\n     * The receiver obtains a cloned `KeyObject`, and the `KeyObject` does not need to\n     * be listed in the `transferList` argument.\n     * @since v11.6.0\n     */\n    class KeyObject {\n        private constructor();\n        /**\n         * Example: Converting a `CryptoKey` instance to a `KeyObject`:\n         *\n         * ```js\n         * const { KeyObject } = await import('node:crypto');\n         * const { subtle } = globalThis.crypto;\n         *\n         * const key = await subtle.generateKey({\n         *   name: 'HMAC',\n         *   hash: 'SHA-256',\n         *   length: 256,\n         * }, true, ['sign', 'verify']);\n         *\n         * const keyObject = KeyObject.from(key);\n         * console.log(keyObject.symmetricKeySize);\n         * // Prints: 32 (symmetric key size in bytes)\n         * ```\n         * @since v15.0.0\n         */\n        static from(key: webcrypto.CryptoKey): KeyObject;\n        /**\n         * For asymmetric keys, this property represents the type of the key. Supported key\n         * types are:\n         *\n         * * `'rsa'` (OID 1.2.840.113549.1.1.1)\n         * * `'rsa-pss'` (OID 1.2.840.113549.1.1.10)\n         * * `'dsa'` (OID 1.2.840.10040.4.1)\n         * * `'ec'` (OID 1.2.840.10045.2.1)\n         * * `'x25519'` (OID 1.3.101.110)\n         * * `'x448'` (OID 1.3.101.111)\n         * * `'ed25519'` (OID 1.3.101.112)\n         * * `'ed448'` (OID 1.3.101.113)\n         * * `'dh'` (OID 1.2.840.113549.1.3.1)\n         *\n         * This property is `undefined` for unrecognized `KeyObject` types and symmetric\n         * keys.\n         * @since v11.6.0\n         */\n        asymmetricKeyType?: KeyType | undefined;\n        /**\n         * This property exists only on asymmetric keys. Depending on the type of the key,\n         * this object contains information about the key. None of the information obtained\n         * through this property can be used to uniquely identify a key or to compromise\n         * the security of the key.\n         *\n         * For RSA-PSS keys, if the key material contains a `RSASSA-PSS-params` sequence,\n         * the `hashAlgorithm`, `mgf1HashAlgorithm`, and `saltLength` properties will be\n         * set.\n         *\n         * Other key details might be exposed via this API using additional attributes.\n         * @since v15.7.0\n         */\n        asymmetricKeyDetails?: AsymmetricKeyDetails | undefined;\n        /**\n         * For symmetric keys, the following encoding options can be used:\n         *\n         * For public keys, the following encoding options can be used:\n         *\n         * For private keys, the following encoding options can be used:\n         *\n         * The result type depends on the selected encoding format, when PEM the\n         * result is a string, when DER it will be a buffer containing the data\n         * encoded as DER, when [JWK](https://tools.ietf.org/html/rfc7517) it will be an object.\n         *\n         * When [JWK](https://tools.ietf.org/html/rfc7517) encoding format was selected, all other encoding options are\n         * ignored.\n         *\n         * PKCS#1, SEC1, and PKCS#8 type keys can be encrypted by using a combination of\n         * the `cipher` and `format` options. The PKCS#8 `type` can be used with any`format` to encrypt any key algorithm (RSA, EC, or DH) by specifying a`cipher`. PKCS#1 and SEC1 can only be\n         * encrypted by specifying a `cipher`when the PEM `format` is used. For maximum compatibility, use PKCS#8 for\n         * encrypted private keys. Since PKCS#8 defines its own\n         * encryption mechanism, PEM-level encryption is not supported when encrypting\n         * a PKCS#8 key. See [RFC 5208](https://www.rfc-editor.org/rfc/rfc5208.txt) for PKCS#8 encryption and [RFC 1421](https://www.rfc-editor.org/rfc/rfc1421.txt) for\n         * PKCS#1 and SEC1 encryption.\n         * @since v11.6.0\n         */\n        export(options: KeyExportOptions<\"pem\">): string | Buffer;\n        export(options?: KeyExportOptions<\"der\">): Buffer;\n        export(options?: JwkKeyExportOptions): JsonWebKey;\n        /**\n         * Returns `true` or `false` depending on whether the keys have exactly the same\n         * type, value, and parameters. This method is not [constant time](https://en.wikipedia.org/wiki/Timing_attack).\n         * @since v17.7.0, v16.15.0\n         * @param otherKeyObject A `KeyObject` with which to compare `keyObject`.\n         */\n        equals(otherKeyObject: KeyObject): boolean;\n        /**\n         * For secret keys, this property represents the size of the key in bytes. This\n         * property is `undefined` for asymmetric keys.\n         * @since v11.6.0\n         */\n        symmetricKeySize?: number | undefined;\n        /**\n         * Converts a `KeyObject` instance to a `CryptoKey`.\n         * @since 22.10.0\n         */\n        toCryptoKey(\n            algorithm:\n                | webcrypto.AlgorithmIdentifier\n                | webcrypto.RsaHashedImportParams\n                | webcrypto.EcKeyImportParams\n                | webcrypto.HmacImportParams,\n            extractable: boolean,\n            keyUsages: readonly webcrypto.KeyUsage[],\n        ): webcrypto.CryptoKey;\n        /**\n         * Depending on the type of this `KeyObject`, this property is either`'secret'` for secret (symmetric) keys, `'public'` for public (asymmetric) keys\n         * or `'private'` for private (asymmetric) keys.\n         * @since v11.6.0\n         */\n        type: KeyObjectType;\n    }\n    type CipherCCMTypes = \"aes-128-ccm\" | \"aes-192-ccm\" | \"aes-256-ccm\";\n    type CipherGCMTypes = \"aes-128-gcm\" | \"aes-192-gcm\" | \"aes-256-gcm\";\n    type CipherOCBTypes = \"aes-128-ocb\" | \"aes-192-ocb\" | \"aes-256-ocb\";\n    type CipherChaCha20Poly1305Types = \"chacha20-poly1305\";\n    type BinaryLike = string | NodeJS.ArrayBufferView;\n    type CipherKey = BinaryLike | KeyObject;\n    interface CipherCCMOptions extends stream.TransformOptions {\n        authTagLength: number;\n    }\n    interface CipherGCMOptions extends stream.TransformOptions {\n        authTagLength?: number | undefined;\n    }\n    interface CipherOCBOptions extends stream.TransformOptions {\n        authTagLength: number;\n    }\n    interface CipherChaCha20Poly1305Options extends stream.TransformOptions {\n        /** @default 16 */\n        authTagLength?: number | undefined;\n    }\n    /**\n     * Creates and returns a `Cipher` object, with the given `algorithm`, `key` and\n     * initialization vector (`iv`).\n     *\n     * The `options` argument controls stream behavior and is optional except when a\n     * cipher in CCM or OCB mode (e.g. `'aes-128-ccm'`) is used. In that case, the`authTagLength` option is required and specifies the length of the\n     * authentication tag in bytes, see `CCM mode`. In GCM mode, the `authTagLength`option is not required but can be used to set the length of the authentication\n     * tag that will be returned by `getAuthTag()` and defaults to 16 bytes.\n     * For `chacha20-poly1305`, the `authTagLength` option defaults to 16 bytes.\n     *\n     * The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On\n     * recent OpenSSL releases, `openssl list -cipher-algorithms` will\n     * display the available cipher algorithms.\n     *\n     * The `key` is the raw key used by the `algorithm` and `iv` is an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector). Both arguments must be `'utf8'` encoded\n     * strings,`Buffers`, `TypedArray`, or `DataView`s. The `key` may optionally be\n     * a `KeyObject` of type `secret`. If the cipher does not need\n     * an initialization vector, `iv` may be `null`.\n     *\n     * When passing strings for `key` or `iv`, please consider `caveats when using strings as inputs to cryptographic APIs`.\n     *\n     * Initialization vectors should be unpredictable and unique; ideally, they will be\n     * cryptographically random. They do not have to be secret: IVs are typically just\n     * added to ciphertext messages unencrypted. It may sound contradictory that\n     * something has to be unpredictable and unique, but does not have to be secret;\n     * remember that an attacker must not be able to predict ahead of time what a\n     * given IV will be.\n     * @since v0.1.94\n     * @param options `stream.transform` options\n     */\n    function createCipheriv(\n        algorithm: CipherCCMTypes,\n        key: CipherKey,\n        iv: BinaryLike,\n        options: CipherCCMOptions,\n    ): CipherCCM;\n    function createCipheriv(\n        algorithm: CipherOCBTypes,\n        key: CipherKey,\n        iv: BinaryLike,\n        options: CipherOCBOptions,\n    ): CipherOCB;\n    function createCipheriv(\n        algorithm: CipherGCMTypes,\n        key: CipherKey,\n        iv: BinaryLike,\n        options?: CipherGCMOptions,\n    ): CipherGCM;\n    function createCipheriv(\n        algorithm: CipherChaCha20Poly1305Types,\n        key: CipherKey,\n        iv: BinaryLike,\n        options?: CipherChaCha20Poly1305Options,\n    ): CipherChaCha20Poly1305;\n    function createCipheriv(\n        algorithm: string,\n        key: CipherKey,\n        iv: BinaryLike | null,\n        options?: stream.TransformOptions,\n    ): Cipher;\n    /**\n     * Instances of the `Cipher` class are used to encrypt data. The class can be\n     * used in one of two ways:\n     *\n     * * As a `stream` that is both readable and writable, where plain unencrypted\n     * data is written to produce encrypted data on the readable side, or\n     * * Using the `cipher.update()` and `cipher.final()` methods to produce\n     * the encrypted data.\n     *\n     * The {@link createCipheriv} method is\n     * used to create `Cipher` instances. `Cipher` objects are not to be created\n     * directly using the `new` keyword.\n     *\n     * Example: Using `Cipher` objects as streams:\n     *\n     * ```js\n     * const {\n     *   scrypt,\n     *   randomFill,\n     *   createCipheriv,\n     * } = await import('node:crypto');\n     *\n     * const algorithm = 'aes-192-cbc';\n     * const password = 'Password used to generate key';\n     *\n     * // First, we'll generate the key. The key length is dependent on the algorithm.\n     * // In this case for aes192, it is 24 bytes (192 bits).\n     * scrypt(password, 'salt', 24, (err, key) => {\n     *   if (err) throw err;\n     *   // Then, we'll generate a random initialization vector\n     *   randomFill(new Uint8Array(16), (err, iv) => {\n     *     if (err) throw err;\n     *\n     *     // Once we have the key and iv, we can create and use the cipher...\n     *     const cipher = createCipheriv(algorithm, key, iv);\n     *\n     *     let encrypted = '';\n     *     cipher.setEncoding('hex');\n     *\n     *     cipher.on('data', (chunk) => encrypted += chunk);\n     *     cipher.on('end', () => console.log(encrypted));\n     *\n     *     cipher.write('some clear text data');\n     *     cipher.end();\n     *   });\n     * });\n     * ```\n     *\n     * Example: Using `Cipher` and piped streams:\n     *\n     * ```js\n     * import {\n     *   createReadStream,\n     *   createWriteStream,\n     * } from 'node:fs';\n     *\n     * import {\n     *   pipeline,\n     * } from 'node:stream';\n     *\n     * const {\n     *   scrypt,\n     *   randomFill,\n     *   createCipheriv,\n     * } = await import('node:crypto');\n     *\n     * const algorithm = 'aes-192-cbc';\n     * const password = 'Password used to generate key';\n     *\n     * // First, we'll generate the key. The key length is dependent on the algorithm.\n     * // In this case for aes192, it is 24 bytes (192 bits).\n     * scrypt(password, 'salt', 24, (err, key) => {\n     *   if (err) throw err;\n     *   // Then, we'll generate a random initialization vector\n     *   randomFill(new Uint8Array(16), (err, iv) => {\n     *     if (err) throw err;\n     *\n     *     const cipher = createCipheriv(algorithm, key, iv);\n     *\n     *     const input = createReadStream('test.js');\n     *     const output = createWriteStream('test.enc');\n     *\n     *     pipeline(input, cipher, output, (err) => {\n     *       if (err) throw err;\n     *     });\n     *   });\n     * });\n     * ```\n     *\n     * Example: Using the `cipher.update()` and `cipher.final()` methods:\n     *\n     * ```js\n     * const {\n     *   scrypt,\n     *   randomFill,\n     *   createCipheriv,\n     * } = await import('node:crypto');\n     *\n     * const algorithm = 'aes-192-cbc';\n     * const password = 'Password used to generate key';\n     *\n     * // First, we'll generate the key. The key length is dependent on the algorithm.\n     * // In this case for aes192, it is 24 bytes (192 bits).\n     * scrypt(password, 'salt', 24, (err, key) => {\n     *   if (err) throw err;\n     *   // Then, we'll generate a random initialization vector\n     *   randomFill(new Uint8Array(16), (err, iv) => {\n     *     if (err) throw err;\n     *\n     *     const cipher = createCipheriv(algorithm, key, iv);\n     *\n     *     let encrypted = cipher.update('some clear text data', 'utf8', 'hex');\n     *     encrypted += cipher.final('hex');\n     *     console.log(encrypted);\n     *   });\n     * });\n     * ```\n     * @since v0.1.94\n     */\n    class Cipher extends stream.Transform {\n        private constructor();\n        /**\n         * Updates the cipher with `data`. If the `inputEncoding` argument is given,\n         * the `data`argument is a string using the specified encoding. If the `inputEncoding`argument is not given, `data` must be a `Buffer`, `TypedArray`, or `DataView`. If `data` is a `Buffer`,\n         * `TypedArray`, or `DataView`, then `inputEncoding` is ignored.\n         *\n         * The `outputEncoding` specifies the output format of the enciphered\n         * data. If the `outputEncoding`is specified, a string using the specified encoding is returned. If no`outputEncoding` is provided, a `Buffer` is returned.\n         *\n         * The `cipher.update()` method can be called multiple times with new data until `cipher.final()` is called. Calling `cipher.update()` after `cipher.final()` will result in an error being\n         * thrown.\n         * @since v0.1.94\n         * @param inputEncoding The `encoding` of the data.\n         * @param outputEncoding The `encoding` of the return value.\n         */\n        update(data: BinaryLike): Buffer;\n        update(data: string, inputEncoding: Encoding): Buffer;\n        update(data: NodeJS.ArrayBufferView, inputEncoding: undefined, outputEncoding: Encoding): string;\n        update(data: string, inputEncoding: Encoding | undefined, outputEncoding: Encoding): string;\n        /**\n         * Once the `cipher.final()` method has been called, the `Cipher` object can no\n         * longer be used to encrypt data. Attempts to call `cipher.final()` more than\n         * once will result in an error being thrown.\n         * @since v0.1.94\n         * @param outputEncoding The `encoding` of the return value.\n         * @return Any remaining enciphered contents. If `outputEncoding` is specified, a string is returned. If an `outputEncoding` is not provided, a {@link Buffer} is returned.\n         */\n        final(): Buffer;\n        final(outputEncoding: BufferEncoding): string;\n        /**\n         * When using block encryption algorithms, the `Cipher` class will automatically\n         * add padding to the input data to the appropriate block size. To disable the\n         * default padding call `cipher.setAutoPadding(false)`.\n         *\n         * When `autoPadding` is `false`, the length of the entire input data must be a\n         * multiple of the cipher's block size or `cipher.final()` will throw an error.\n         * Disabling automatic padding is useful for non-standard padding, for instance\n         * using `0x0` instead of PKCS padding.\n         *\n         * The `cipher.setAutoPadding()` method must be called before `cipher.final()`.\n         * @since v0.7.1\n         * @param [autoPadding=true]\n         * @return for method chaining.\n         */\n        setAutoPadding(autoPadding?: boolean): this;\n    }\n    interface CipherCCM extends Cipher {\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options: {\n                plaintextLength: number;\n            },\n        ): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherGCM extends Cipher {\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options?: {\n                plaintextLength: number;\n            },\n        ): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherOCB extends Cipher {\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options?: {\n                plaintextLength: number;\n            },\n        ): this;\n        getAuthTag(): Buffer;\n    }\n    interface CipherChaCha20Poly1305 extends Cipher {\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options: {\n                plaintextLength: number;\n            },\n        ): this;\n        getAuthTag(): Buffer;\n    }\n    /**\n     * Creates and returns a `Decipher` object that uses the given `algorithm`, `key` and initialization vector (`iv`).\n     *\n     * The `options` argument controls stream behavior and is optional except when a\n     * cipher in CCM or OCB mode (e.g. `'aes-128-ccm'`) is used. In that case, the `authTagLength` option is required and specifies the length of the\n     * authentication tag in bytes, see `CCM mode`. In GCM mode, the `authTagLength` option is not required but can be used to restrict accepted authentication tags\n     * to those with the specified length.\n     * For `chacha20-poly1305`, the `authTagLength` option defaults to 16 bytes.\n     *\n     * The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On\n     * recent OpenSSL releases, `openssl list -cipher-algorithms` will\n     * display the available cipher algorithms.\n     *\n     * The `key` is the raw key used by the `algorithm` and `iv` is an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector). Both arguments must be `'utf8'` encoded\n     * strings,`Buffers`, `TypedArray`, or `DataView`s. The `key` may optionally be\n     * a `KeyObject` of type `secret`. If the cipher does not need\n     * an initialization vector, `iv` may be `null`.\n     *\n     * When passing strings for `key` or `iv`, please consider `caveats when using strings as inputs to cryptographic APIs`.\n     *\n     * Initialization vectors should be unpredictable and unique; ideally, they will be\n     * cryptographically random. They do not have to be secret: IVs are typically just\n     * added to ciphertext messages unencrypted. It may sound contradictory that\n     * something has to be unpredictable and unique, but does not have to be secret;\n     * remember that an attacker must not be able to predict ahead of time what a given\n     * IV will be.\n     * @since v0.1.94\n     * @param options `stream.transform` options\n     */\n    function createDecipheriv(\n        algorithm: CipherCCMTypes,\n        key: CipherKey,\n        iv: BinaryLike,\n        options: CipherCCMOptions,\n    ): DecipherCCM;\n    function createDecipheriv(\n        algorithm: CipherOCBTypes,\n        key: CipherKey,\n        iv: BinaryLike,\n        options: CipherOCBOptions,\n    ): DecipherOCB;\n    function createDecipheriv(\n        algorithm: CipherGCMTypes,\n        key: CipherKey,\n        iv: BinaryLike,\n        options?: CipherGCMOptions,\n    ): DecipherGCM;\n    function createDecipheriv(\n        algorithm: CipherChaCha20Poly1305Types,\n        key: CipherKey,\n        iv: BinaryLike,\n        options?: CipherChaCha20Poly1305Options,\n    ): DecipherChaCha20Poly1305;\n    function createDecipheriv(\n        algorithm: string,\n        key: CipherKey,\n        iv: BinaryLike | null,\n        options?: stream.TransformOptions,\n    ): Decipher;\n    /**\n     * Instances of the `Decipher` class are used to decrypt data. The class can be\n     * used in one of two ways:\n     *\n     * * As a `stream` that is both readable and writable, where plain encrypted\n     * data is written to produce unencrypted data on the readable side, or\n     * * Using the `decipher.update()` and `decipher.final()` methods to\n     * produce the unencrypted data.\n     *\n     * The {@link createDecipheriv} method is\n     * used to create `Decipher` instances. `Decipher` objects are not to be created\n     * directly using the `new` keyword.\n     *\n     * Example: Using `Decipher` objects as streams:\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const {\n     *   scryptSync,\n     *   createDecipheriv,\n     * } = await import('node:crypto');\n     *\n     * const algorithm = 'aes-192-cbc';\n     * const password = 'Password used to generate key';\n     * // Key length is dependent on the algorithm. In this case for aes192, it is\n     * // 24 bytes (192 bits).\n     * // Use the async `crypto.scrypt()` instead.\n     * const key = scryptSync(password, 'salt', 24);\n     * // The IV is usually passed along with the ciphertext.\n     * const iv = Buffer.alloc(16, 0); // Initialization vector.\n     *\n     * const decipher = createDecipheriv(algorithm, key, iv);\n     *\n     * let decrypted = '';\n     * decipher.on('readable', () => {\n     *   let chunk;\n     *   while (null !== (chunk = decipher.read())) {\n     *     decrypted += chunk.toString('utf8');\n     *   }\n     * });\n     * decipher.on('end', () => {\n     *   console.log(decrypted);\n     *   // Prints: some clear text data\n     * });\n     *\n     * // Encrypted with same algorithm, key and iv.\n     * const encrypted =\n     *   'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';\n     * decipher.write(encrypted, 'hex');\n     * decipher.end();\n     * ```\n     *\n     * Example: Using `Decipher` and piped streams:\n     *\n     * ```js\n     * import {\n     *   createReadStream,\n     *   createWriteStream,\n     * } from 'node:fs';\n     * import { Buffer } from 'node:buffer';\n     * const {\n     *   scryptSync,\n     *   createDecipheriv,\n     * } = await import('node:crypto');\n     *\n     * const algorithm = 'aes-192-cbc';\n     * const password = 'Password used to generate key';\n     * // Use the async `crypto.scrypt()` instead.\n     * const key = scryptSync(password, 'salt', 24);\n     * // The IV is usually passed along with the ciphertext.\n     * const iv = Buffer.alloc(16, 0); // Initialization vector.\n     *\n     * const decipher = createDecipheriv(algorithm, key, iv);\n     *\n     * const input = createReadStream('test.enc');\n     * const output = createWriteStream('test.js');\n     *\n     * input.pipe(decipher).pipe(output);\n     * ```\n     *\n     * Example: Using the `decipher.update()` and `decipher.final()` methods:\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const {\n     *   scryptSync,\n     *   createDecipheriv,\n     * } = await import('node:crypto');\n     *\n     * const algorithm = 'aes-192-cbc';\n     * const password = 'Password used to generate key';\n     * // Use the async `crypto.scrypt()` instead.\n     * const key = scryptSync(password, 'salt', 24);\n     * // The IV is usually passed along with the ciphertext.\n     * const iv = Buffer.alloc(16, 0); // Initialization vector.\n     *\n     * const decipher = createDecipheriv(algorithm, key, iv);\n     *\n     * // Encrypted using same algorithm, key and iv.\n     * const encrypted =\n     *   'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';\n     * let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n     * decrypted += decipher.final('utf8');\n     * console.log(decrypted);\n     * // Prints: some clear text data\n     * ```\n     * @since v0.1.94\n     */\n    class Decipher extends stream.Transform {\n        private constructor();\n        /**\n         * Updates the decipher with `data`. If the `inputEncoding` argument is given,\n         * the `data` argument is a string using the specified encoding. If the `inputEncoding` argument is not given, `data` must be a `Buffer`. If `data` is a `Buffer` then `inputEncoding` is\n         * ignored.\n         *\n         * The `outputEncoding` specifies the output format of the enciphered\n         * data. If the `outputEncoding` is specified, a string using the specified encoding is returned. If no `outputEncoding` is provided, a `Buffer` is returned.\n         *\n         * The `decipher.update()` method can be called multiple times with new data until `decipher.final()` is called. Calling `decipher.update()` after `decipher.final()` will result in an error\n         * being thrown.\n         * @since v0.1.94\n         * @param inputEncoding The `encoding` of the `data` string.\n         * @param outputEncoding The `encoding` of the return value.\n         */\n        update(data: NodeJS.ArrayBufferView): Buffer;\n        update(data: string, inputEncoding: Encoding): Buffer;\n        update(data: NodeJS.ArrayBufferView, inputEncoding: undefined, outputEncoding: Encoding): string;\n        update(data: string, inputEncoding: Encoding | undefined, outputEncoding: Encoding): string;\n        /**\n         * Once the `decipher.final()` method has been called, the `Decipher` object can\n         * no longer be used to decrypt data. Attempts to call `decipher.final()` more\n         * than once will result in an error being thrown.\n         * @since v0.1.94\n         * @param outputEncoding The `encoding` of the return value.\n         * @return Any remaining deciphered contents. If `outputEncoding` is specified, a string is returned. If an `outputEncoding` is not provided, a {@link Buffer} is returned.\n         */\n        final(): Buffer;\n        final(outputEncoding: BufferEncoding): string;\n        /**\n         * When data has been encrypted without standard block padding, calling `decipher.setAutoPadding(false)` will disable automatic padding to prevent `decipher.final()` from checking for and\n         * removing padding.\n         *\n         * Turning auto padding off will only work if the input data's length is a\n         * multiple of the ciphers block size.\n         *\n         * The `decipher.setAutoPadding()` method must be called before `decipher.final()`.\n         * @since v0.7.1\n         * @param [autoPadding=true]\n         * @return for method chaining.\n         */\n        setAutoPadding(auto_padding?: boolean): this;\n    }\n    interface DecipherCCM extends Decipher {\n        setAuthTag(buffer: NodeJS.ArrayBufferView): this;\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options: {\n                plaintextLength: number;\n            },\n        ): this;\n    }\n    interface DecipherGCM extends Decipher {\n        setAuthTag(buffer: NodeJS.ArrayBufferView): this;\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options?: {\n                plaintextLength: number;\n            },\n        ): this;\n    }\n    interface DecipherOCB extends Decipher {\n        setAuthTag(buffer: NodeJS.ArrayBufferView): this;\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options?: {\n                plaintextLength: number;\n            },\n        ): this;\n    }\n    interface DecipherChaCha20Poly1305 extends Decipher {\n        setAuthTag(buffer: NodeJS.ArrayBufferView): this;\n        setAAD(\n            buffer: NodeJS.ArrayBufferView,\n            options: {\n                plaintextLength: number;\n            },\n        ): this;\n    }\n    interface PrivateKeyInput {\n        key: string | Buffer;\n        format?: KeyFormat | undefined;\n        type?: \"pkcs1\" | \"pkcs8\" | \"sec1\" | undefined;\n        passphrase?: string | Buffer | undefined;\n        encoding?: string | undefined;\n    }\n    interface PublicKeyInput {\n        key: string | Buffer;\n        format?: KeyFormat | undefined;\n        type?: \"pkcs1\" | \"spki\" | undefined;\n        encoding?: string | undefined;\n    }\n    /**\n     * Asynchronously generates a new random secret key of the given `length`. The `type` will determine which validations will be performed on the `length`.\n     *\n     * ```js\n     * const {\n     *   generateKey,\n     * } = await import('node:crypto');\n     *\n     * generateKey('hmac', { length: 512 }, (err, key) => {\n     *   if (err) throw err;\n     *   console.log(key.export().toString('hex'));  // 46e..........620\n     * });\n     * ```\n     *\n     * The size of a generated HMAC key should not exceed the block size of the\n     * underlying hash function. See {@link createHmac} for more information.\n     * @since v15.0.0\n     * @param type The intended use of the generated secret key. Currently accepted values are `'hmac'` and `'aes'`.\n     */\n    function generateKey(\n        type: \"hmac\" | \"aes\",\n        options: {\n            length: number;\n        },\n        callback: (err: Error | null, key: KeyObject) => void,\n    ): void;\n    /**\n     * Synchronously generates a new random secret key of the given `length`. The `type` will determine which validations will be performed on the `length`.\n     *\n     * ```js\n     * const {\n     *   generateKeySync,\n     * } = await import('node:crypto');\n     *\n     * const key = generateKeySync('hmac', { length: 512 });\n     * console.log(key.export().toString('hex'));  // e89..........41e\n     * ```\n     *\n     * The size of a generated HMAC key should not exceed the block size of the\n     * underlying hash function. See {@link createHmac} for more information.\n     * @since v15.0.0\n     * @param type The intended use of the generated secret key. Currently accepted values are `'hmac'` and `'aes'`.\n     */\n    function generateKeySync(\n        type: \"hmac\" | \"aes\",\n        options: {\n            length: number;\n        },\n    ): KeyObject;\n    interface JsonWebKeyInput {\n        key: JsonWebKey;\n        format: \"jwk\";\n    }\n    /**\n     * Creates and returns a new key object containing a private key. If `key` is a\n     * string or `Buffer`, `format` is assumed to be `'pem'`; otherwise, `key` must be an object with the properties described above.\n     *\n     * If the private key is encrypted, a `passphrase` must be specified. The length\n     * of the passphrase is limited to 1024 bytes.\n     * @since v11.6.0\n     */\n    function createPrivateKey(key: PrivateKeyInput | string | Buffer | JsonWebKeyInput): KeyObject;\n    /**\n     * Creates and returns a new key object containing a public key. If `key` is a\n     * string or `Buffer`, `format` is assumed to be `'pem'`; if `key` is a `KeyObject` with type `'private'`, the public key is derived from the given private key;\n     * otherwise, `key` must be an object with the properties described above.\n     *\n     * If the format is `'pem'`, the `'key'` may also be an X.509 certificate.\n     *\n     * Because public keys can be derived from private keys, a private key may be\n     * passed instead of a public key. In that case, this function behaves as if {@link createPrivateKey} had been called, except that the type of the\n     * returned `KeyObject` will be `'public'` and that the private key cannot be\n     * extracted from the returned `KeyObject`. Similarly, if a `KeyObject` with type `'private'` is given, a new `KeyObject` with type `'public'` will be returned\n     * and it will be impossible to extract the private key from the returned object.\n     * @since v11.6.0\n     */\n    function createPublicKey(key: PublicKeyInput | string | Buffer | KeyObject | JsonWebKeyInput): KeyObject;\n    /**\n     * Creates and returns a new key object containing a secret key for symmetric\n     * encryption or `Hmac`.\n     * @since v11.6.0\n     * @param encoding The string encoding when `key` is a string.\n     */\n    function createSecretKey(key: NodeJS.ArrayBufferView): KeyObject;\n    function createSecretKey(key: string, encoding: BufferEncoding): KeyObject;\n    /**\n     * Creates and returns a `Sign` object that uses the given `algorithm`. Use {@link getHashes} to obtain the names of the available digest algorithms.\n     * Optional `options` argument controls the `stream.Writable` behavior.\n     *\n     * In some cases, a `Sign` instance can be created using the name of a signature\n     * algorithm, such as `'RSA-SHA256'`, instead of a digest algorithm. This will use\n     * the corresponding digest algorithm. This does not work for all signature\n     * algorithms, such as `'ecdsa-with-SHA256'`, so it is best to always use digest\n     * algorithm names.\n     * @since v0.1.92\n     * @param options `stream.Writable` options\n     */\n    function createSign(algorithm: string, options?: stream.WritableOptions): Sign;\n    type DSAEncoding = \"der\" | \"ieee-p1363\";\n    interface SigningOptions {\n        /**\n         * @see crypto.constants.RSA_PKCS1_PADDING\n         */\n        padding?: number | undefined;\n        saltLength?: number | undefined;\n        dsaEncoding?: DSAEncoding | undefined;\n    }\n    interface SignPrivateKeyInput extends PrivateKeyInput, SigningOptions {}\n    interface SignKeyObjectInput extends SigningOptions {\n        key: KeyObject;\n    }\n    interface SignJsonWebKeyInput extends JsonWebKeyInput, SigningOptions {}\n    interface VerifyPublicKeyInput extends PublicKeyInput, SigningOptions {}\n    interface VerifyKeyObjectInput extends SigningOptions {\n        key: KeyObject;\n    }\n    interface VerifyJsonWebKeyInput extends JsonWebKeyInput, SigningOptions {}\n    type KeyLike = string | Buffer | KeyObject;\n    /**\n     * The `Sign` class is a utility for generating signatures. It can be used in one\n     * of two ways:\n     *\n     * * As a writable `stream`, where data to be signed is written and the `sign.sign()` method is used to generate and return the signature, or\n     * * Using the `sign.update()` and `sign.sign()` methods to produce the\n     * signature.\n     *\n     * The {@link createSign} method is used to create `Sign` instances. The\n     * argument is the string name of the hash function to use. `Sign` objects are not\n     * to be created directly using the `new` keyword.\n     *\n     * Example: Using `Sign` and `Verify` objects as streams:\n     *\n     * ```js\n     * const {\n     *   generateKeyPairSync,\n     *   createSign,\n     *   createVerify,\n     * } = await import('node:crypto');\n     *\n     * const { privateKey, publicKey } = generateKeyPairSync('ec', {\n     *   namedCurve: 'sect239k1',\n     * });\n     *\n     * const sign = createSign('SHA256');\n     * sign.write('some data to sign');\n     * sign.end();\n     * const signature = sign.sign(privateKey, 'hex');\n     *\n     * const verify = createVerify('SHA256');\n     * verify.write('some data to sign');\n     * verify.end();\n     * console.log(verify.verify(publicKey, signature, 'hex'));\n     * // Prints: true\n     * ```\n     *\n     * Example: Using the `sign.update()` and `verify.update()` methods:\n     *\n     * ```js\n     * const {\n     *   generateKeyPairSync,\n     *   createSign,\n     *   createVerify,\n     * } = await import('node:crypto');\n     *\n     * const { privateKey, publicKey } = generateKeyPairSync('rsa', {\n     *   modulusLength: 2048,\n     * });\n     *\n     * const sign = createSign('SHA256');\n     * sign.update('some data to sign');\n     * sign.end();\n     * const signature = sign.sign(privateKey);\n     *\n     * const verify = createVerify('SHA256');\n     * verify.update('some data to sign');\n     * verify.end();\n     * console.log(verify.verify(publicKey, signature));\n     * // Prints: true\n     * ```\n     * @since v0.1.92\n     */\n    class Sign extends stream.Writable {\n        private constructor();\n        /**\n         * Updates the `Sign` content with the given `data`, the encoding of which\n         * is given in `inputEncoding`.\n         * If `encoding` is not provided, and the `data` is a string, an\n         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.\n         *\n         * This can be called many times with new data as it is streamed.\n         * @since v0.1.92\n         * @param inputEncoding The `encoding` of the `data` string.\n         */\n        update(data: BinaryLike): this;\n        update(data: string, inputEncoding: Encoding): this;\n        /**\n         * Calculates the signature on all the data passed through using either `sign.update()` or `sign.write()`.\n         *\n         * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an\n         * object, the following additional properties can be passed:\n         *\n         * If `outputEncoding` is provided a string is returned; otherwise a `Buffer` is returned.\n         *\n         * The `Sign` object can not be again used after `sign.sign()` method has been\n         * called. Multiple calls to `sign.sign()` will result in an error being thrown.\n         * @since v0.1.92\n         */\n        sign(privateKey: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput): Buffer;\n        sign(\n            privateKey: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,\n            outputFormat: BinaryToTextEncoding,\n        ): string;\n    }\n    /**\n     * Creates and returns a `Verify` object that uses the given algorithm.\n     * Use {@link getHashes} to obtain an array of names of the available\n     * signing algorithms. Optional `options` argument controls the `stream.Writable` behavior.\n     *\n     * In some cases, a `Verify` instance can be created using the name of a signature\n     * algorithm, such as `'RSA-SHA256'`, instead of a digest algorithm. This will use\n     * the corresponding digest algorithm. This does not work for all signature\n     * algorithms, such as `'ecdsa-with-SHA256'`, so it is best to always use digest\n     * algorithm names.\n     * @since v0.1.92\n     * @param options `stream.Writable` options\n     */\n    function createVerify(algorithm: string, options?: stream.WritableOptions): Verify;\n    /**\n     * The `Verify` class is a utility for verifying signatures. It can be used in one\n     * of two ways:\n     *\n     * * As a writable `stream` where written data is used to validate against the\n     * supplied signature, or\n     * * Using the `verify.update()` and `verify.verify()` methods to verify\n     * the signature.\n     *\n     * The {@link createVerify} method is used to create `Verify` instances. `Verify` objects are not to be created directly using the `new` keyword.\n     *\n     * See `Sign` for examples.\n     * @since v0.1.92\n     */\n    class Verify extends stream.Writable {\n        private constructor();\n        /**\n         * Updates the `Verify` content with the given `data`, the encoding of which\n         * is given in `inputEncoding`.\n         * If `inputEncoding` is not provided, and the `data` is a string, an\n         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or `DataView`, then `inputEncoding` is ignored.\n         *\n         * This can be called many times with new data as it is streamed.\n         * @since v0.1.92\n         * @param inputEncoding The `encoding` of the `data` string.\n         */\n        update(data: BinaryLike): Verify;\n        update(data: string, inputEncoding: Encoding): Verify;\n        /**\n         * Verifies the provided data using the given `object` and `signature`.\n         *\n         * If `object` is not a `KeyObject`, this function behaves as if `object` had been passed to {@link createPublicKey}. If it is an\n         * object, the following additional properties can be passed:\n         *\n         * The `signature` argument is the previously calculated signature for the data, in\n         * the `signatureEncoding`.\n         * If a `signatureEncoding` is specified, the `signature` is expected to be a\n         * string; otherwise `signature` is expected to be a `Buffer`, `TypedArray`, or `DataView`.\n         *\n         * The `verify` object can not be used again after `verify.verify()` has been\n         * called. Multiple calls to `verify.verify()` will result in an error being\n         * thrown.\n         *\n         * Because public keys can be derived from private keys, a private key may\n         * be passed instead of a public key.\n         * @since v0.1.92\n         */\n        verify(\n            object: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,\n            signature: NodeJS.ArrayBufferView,\n        ): boolean;\n        verify(\n            object: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,\n            signature: string,\n            signature_format?: BinaryToTextEncoding,\n        ): boolean;\n    }\n    /**\n     * Creates a `DiffieHellman` key exchange object using the supplied `prime` and an\n     * optional specific `generator`.\n     *\n     * The `generator` argument can be a number, string, or `Buffer`. If `generator` is not specified, the value `2` is used.\n     *\n     * If `primeEncoding` is specified, `prime` is expected to be a string; otherwise\n     * a `Buffer`, `TypedArray`, or `DataView` is expected.\n     *\n     * If `generatorEncoding` is specified, `generator` is expected to be a string;\n     * otherwise a number, `Buffer`, `TypedArray`, or `DataView` is expected.\n     * @since v0.11.12\n     * @param primeEncoding The `encoding` of the `prime` string.\n     * @param [generator=2]\n     * @param generatorEncoding The `encoding` of the `generator` string.\n     */\n    function createDiffieHellman(primeLength: number, generator?: number): DiffieHellman;\n    function createDiffieHellman(\n        prime: ArrayBuffer | NodeJS.ArrayBufferView,\n        generator?: number | ArrayBuffer | NodeJS.ArrayBufferView,\n    ): DiffieHellman;\n    function createDiffieHellman(\n        prime: ArrayBuffer | NodeJS.ArrayBufferView,\n        generator: string,\n        generatorEncoding: BinaryToTextEncoding,\n    ): DiffieHellman;\n    function createDiffieHellman(\n        prime: string,\n        primeEncoding: BinaryToTextEncoding,\n        generator?: number | ArrayBuffer | NodeJS.ArrayBufferView,\n    ): DiffieHellman;\n    function createDiffieHellman(\n        prime: string,\n        primeEncoding: BinaryToTextEncoding,\n        generator: string,\n        generatorEncoding: BinaryToTextEncoding,\n    ): DiffieHellman;\n    /**\n     * The `DiffieHellman` class is a utility for creating Diffie-Hellman key\n     * exchanges.\n     *\n     * Instances of the `DiffieHellman` class can be created using the {@link createDiffieHellman} function.\n     *\n     * ```js\n     * import assert from 'node:assert';\n     *\n     * const {\n     *   createDiffieHellman,\n     * } = await import('node:crypto');\n     *\n     * // Generate Alice's keys...\n     * const alice = createDiffieHellman(2048);\n     * const aliceKey = alice.generateKeys();\n     *\n     * // Generate Bob's keys...\n     * const bob = createDiffieHellman(alice.getPrime(), alice.getGenerator());\n     * const bobKey = bob.generateKeys();\n     *\n     * // Exchange and generate the secret...\n     * const aliceSecret = alice.computeSecret(bobKey);\n     * const bobSecret = bob.computeSecret(aliceKey);\n     *\n     * // OK\n     * assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n     * ```\n     * @since v0.5.0\n     */\n    class DiffieHellman {\n        private constructor();\n        /**\n         * Generates private and public Diffie-Hellman key values unless they have been\n         * generated or computed already, and returns\n         * the public key in the specified `encoding`. This key should be\n         * transferred to the other party.\n         * If `encoding` is provided a string is returned; otherwise a `Buffer` is returned.\n         *\n         * This function is a thin wrapper around [`DH_generate_key()`](https://www.openssl.org/docs/man3.0/man3/DH_generate_key.html). In particular,\n         * once a private key has been generated or set, calling this function only updates\n         * the public key but does not generate a new private key.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the return value.\n         */\n        generateKeys(): Buffer;\n        generateKeys(encoding: BinaryToTextEncoding): string;\n        /**\n         * Computes the shared secret using `otherPublicKey` as the other\n         * party's public key and returns the computed shared secret. The supplied\n         * key is interpreted using the specified `inputEncoding`, and secret is\n         * encoded using specified `outputEncoding`.\n         * If the `inputEncoding` is not\n         * provided, `otherPublicKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.\n         *\n         * If `outputEncoding` is given a string is returned; otherwise, a `Buffer` is returned.\n         * @since v0.5.0\n         * @param inputEncoding The `encoding` of an `otherPublicKey` string.\n         * @param outputEncoding The `encoding` of the return value.\n         */\n        computeSecret(otherPublicKey: NodeJS.ArrayBufferView, inputEncoding?: null, outputEncoding?: null): Buffer;\n        computeSecret(otherPublicKey: string, inputEncoding: BinaryToTextEncoding, outputEncoding?: null): Buffer;\n        computeSecret(\n            otherPublicKey: NodeJS.ArrayBufferView,\n            inputEncoding: null,\n            outputEncoding: BinaryToTextEncoding,\n        ): string;\n        computeSecret(\n            otherPublicKey: string,\n            inputEncoding: BinaryToTextEncoding,\n            outputEncoding: BinaryToTextEncoding,\n        ): string;\n        /**\n         * Returns the Diffie-Hellman prime in the specified `encoding`.\n         * If `encoding` is provided a string is\n         * returned; otherwise a `Buffer` is returned.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the return value.\n         */\n        getPrime(): Buffer;\n        getPrime(encoding: BinaryToTextEncoding): string;\n        /**\n         * Returns the Diffie-Hellman generator in the specified `encoding`.\n         * If `encoding` is provided a string is\n         * returned; otherwise a `Buffer` is returned.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the return value.\n         */\n        getGenerator(): Buffer;\n        getGenerator(encoding: BinaryToTextEncoding): string;\n        /**\n         * Returns the Diffie-Hellman public key in the specified `encoding`.\n         * If `encoding` is provided a\n         * string is returned; otherwise a `Buffer` is returned.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the return value.\n         */\n        getPublicKey(): Buffer;\n        getPublicKey(encoding: BinaryToTextEncoding): string;\n        /**\n         * Returns the Diffie-Hellman private key in the specified `encoding`.\n         * If `encoding` is provided a\n         * string is returned; otherwise a `Buffer` is returned.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the return value.\n         */\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: BinaryToTextEncoding): string;\n        /**\n         * Sets the Diffie-Hellman public key. If the `encoding` argument is provided, `publicKey` is expected\n         * to be a string. If no `encoding` is provided, `publicKey` is expected\n         * to be a `Buffer`, `TypedArray`, or `DataView`.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the `publicKey` string.\n         */\n        setPublicKey(publicKey: NodeJS.ArrayBufferView): void;\n        setPublicKey(publicKey: string, encoding: BufferEncoding): void;\n        /**\n         * Sets the Diffie-Hellman private key. If the `encoding` argument is provided,`privateKey` is expected\n         * to be a string. If no `encoding` is provided, `privateKey` is expected\n         * to be a `Buffer`, `TypedArray`, or `DataView`.\n         *\n         * This function does not automatically compute the associated public key. Either `diffieHellman.setPublicKey()` or `diffieHellman.generateKeys()` can be\n         * used to manually provide the public key or to automatically derive it.\n         * @since v0.5.0\n         * @param encoding The `encoding` of the `privateKey` string.\n         */\n        setPrivateKey(privateKey: NodeJS.ArrayBufferView): void;\n        setPrivateKey(privateKey: string, encoding: BufferEncoding): void;\n        /**\n         * A bit field containing any warnings and/or errors resulting from a check\n         * performed during initialization of the `DiffieHellman` object.\n         *\n         * The following values are valid for this property (as defined in `node:constants` module):\n         *\n         * * `DH_CHECK_P_NOT_SAFE_PRIME`\n         * * `DH_CHECK_P_NOT_PRIME`\n         * * `DH_UNABLE_TO_CHECK_GENERATOR`\n         * * `DH_NOT_SUITABLE_GENERATOR`\n         * @since v0.11.12\n         */\n        verifyError: number;\n    }\n    /**\n     * The `DiffieHellmanGroup` class takes a well-known modp group as its argument.\n     * It works the same as `DiffieHellman`, except that it does not allow changing its keys after creation.\n     * In other words, it does not implement `setPublicKey()` or `setPrivateKey()` methods.\n     *\n     * ```js\n     * const { createDiffieHellmanGroup } = await import('node:crypto');\n     * const dh = createDiffieHellmanGroup('modp1');\n     * ```\n     * The name (e.g. `'modp1'`) is taken from [RFC 2412](https://www.rfc-editor.org/rfc/rfc2412.txt) (modp1 and 2) and [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt):\n     * ```bash\n     * $ perl -ne 'print \"$1\\n\" if /\"(modp\\d+)\"/' src/node_crypto_groups.h\n     * modp1  #  768 bits\n     * modp2  # 1024 bits\n     * modp5  # 1536 bits\n     * modp14 # 2048 bits\n     * modp15 # etc.\n     * modp16\n     * modp17\n     * modp18\n     * ```\n     * @since v0.7.5\n     */\n    const DiffieHellmanGroup: DiffieHellmanGroupConstructor;\n    interface DiffieHellmanGroupConstructor {\n        new(name: string): DiffieHellmanGroup;\n        (name: string): DiffieHellmanGroup;\n        readonly prototype: DiffieHellmanGroup;\n    }\n    type DiffieHellmanGroup = Omit<DiffieHellman, \"setPublicKey\" | \"setPrivateKey\">;\n    /**\n     * Creates a predefined `DiffieHellmanGroup` key exchange object. The\n     * supported groups are listed in the documentation for `DiffieHellmanGroup`.\n     *\n     * The returned object mimics the interface of objects created by {@link createDiffieHellman}, but will not allow changing\n     * the keys (with `diffieHellman.setPublicKey()`, for example). The\n     * advantage of using this method is that the parties do not have to\n     * generate nor exchange a group modulus beforehand, saving both processor\n     * and communication time.\n     *\n     * Example (obtaining a shared secret):\n     *\n     * ```js\n     * const {\n     *   getDiffieHellman,\n     * } = await import('node:crypto');\n     * const alice = getDiffieHellman('modp14');\n     * const bob = getDiffieHellman('modp14');\n     *\n     * alice.generateKeys();\n     * bob.generateKeys();\n     *\n     * const aliceSecret = alice.computeSecret(bob.getPublicKey(), null, 'hex');\n     * const bobSecret = bob.computeSecret(alice.getPublicKey(), null, 'hex');\n     *\n     * // aliceSecret and bobSecret should be the same\n     * console.log(aliceSecret === bobSecret);\n     * ```\n     * @since v0.7.5\n     */\n    function getDiffieHellman(groupName: string): DiffieHellmanGroup;\n    /**\n     * An alias for {@link getDiffieHellman}\n     * @since v0.9.3\n     */\n    function createDiffieHellmanGroup(name: string): DiffieHellmanGroup;\n    /**\n     * Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)\n     * implementation. A selected HMAC digest algorithm specified by `digest` is\n     * applied to derive a key of the requested byte length (`keylen`) from the `password`, `salt` and `iterations`.\n     *\n     * The supplied `callback` function is called with two arguments: `err` and `derivedKey`. If an error occurs while deriving the key, `err` will be set;\n     * otherwise `err` will be `null`. By default, the successfully generated `derivedKey` will be passed to the callback as a `Buffer`. An error will be\n     * thrown if any of the input arguments specify invalid values or types.\n     *\n     * The `iterations` argument must be a number set as high as possible. The\n     * higher the number of iterations, the more secure the derived key will be,\n     * but will take a longer amount of time to complete.\n     *\n     * The `salt` should be as unique as possible. It is recommended that a salt is\n     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.\n     *\n     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.\n     *\n     * ```js\n     * const {\n     *   pbkdf2,\n     * } = await import('node:crypto');\n     *\n     * pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, derivedKey) => {\n     *   if (err) throw err;\n     *   console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'\n     * });\n     * ```\n     *\n     * An array of supported digest functions can be retrieved using {@link getHashes}.\n     *\n     * This API uses libuv's threadpool, which can have surprising and\n     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.\n     * @since v0.5.5\n     */\n    function pbkdf2(\n        password: BinaryLike,\n        salt: BinaryLike,\n        iterations: number,\n        keylen: number,\n        digest: string,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    /**\n     * Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2)\n     * implementation. A selected HMAC digest algorithm specified by `digest` is\n     * applied to derive a key of the requested byte length (`keylen`) from the `password`, `salt` and `iterations`.\n     *\n     * If an error occurs an `Error` will be thrown, otherwise the derived key will be\n     * returned as a `Buffer`.\n     *\n     * The `iterations` argument must be a number set as high as possible. The\n     * higher the number of iterations, the more secure the derived key will be,\n     * but will take a longer amount of time to complete.\n     *\n     * The `salt` should be as unique as possible. It is recommended that a salt is\n     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.\n     *\n     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.\n     *\n     * ```js\n     * const {\n     *   pbkdf2Sync,\n     * } = await import('node:crypto');\n     *\n     * const key = pbkdf2Sync('secret', 'salt', 100000, 64, 'sha512');\n     * console.log(key.toString('hex'));  // '3745e48...08d59ae'\n     * ```\n     *\n     * An array of supported digest functions can be retrieved using {@link getHashes}.\n     * @since v0.9.3\n     */\n    function pbkdf2Sync(\n        password: BinaryLike,\n        salt: BinaryLike,\n        iterations: number,\n        keylen: number,\n        digest: string,\n    ): Buffer;\n    /**\n     * Generates cryptographically strong pseudorandom data. The `size` argument\n     * is a number indicating the number of bytes to generate.\n     *\n     * If a `callback` function is provided, the bytes are generated asynchronously\n     * and the `callback` function is invoked with two arguments: `err` and `buf`.\n     * If an error occurs, `err` will be an `Error` object; otherwise it is `null`. The `buf` argument is a `Buffer` containing the generated bytes.\n     *\n     * ```js\n     * // Asynchronous\n     * const {\n     *   randomBytes,\n     * } = await import('node:crypto');\n     *\n     * randomBytes(256, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);\n     * });\n     * ```\n     *\n     * If the `callback` function is not provided, the random bytes are generated\n     * synchronously and returned as a `Buffer`. An error will be thrown if\n     * there is a problem generating the bytes.\n     *\n     * ```js\n     * // Synchronous\n     * const {\n     *   randomBytes,\n     * } = await import('node:crypto');\n     *\n     * const buf = randomBytes(256);\n     * console.log(\n     *   `${buf.length} bytes of random data: ${buf.toString('hex')}`);\n     * ```\n     *\n     * The `crypto.randomBytes()` method will not complete until there is\n     * sufficient entropy available.\n     * This should normally never take longer than a few milliseconds. The only time\n     * when generating the random bytes may conceivably block for a longer period of\n     * time is right after boot, when the whole system is still low on entropy.\n     *\n     * This API uses libuv's threadpool, which can have surprising and\n     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.\n     *\n     * The asynchronous version of `crypto.randomBytes()` is carried out in a single\n     * threadpool request. To minimize threadpool task length variation, partition\n     * large `randomBytes` requests when doing so as part of fulfilling a client\n     * request.\n     * @since v0.5.8\n     * @param size The number of bytes to generate. The `size` must not be larger than `2**31 - 1`.\n     * @return if the `callback` function is not provided.\n     */\n    function randomBytes(size: number): Buffer;\n    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n    function pseudoRandomBytes(size: number): Buffer;\n    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;\n    /**\n     * Return a random integer `n` such that `min <= n < max`.  This\n     * implementation avoids [modulo bias](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Modulo_bias).\n     *\n     * The range (`max - min`) must be less than 2**48. `min` and `max` must\n     * be [safe integers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger).\n     *\n     * If the `callback` function is not provided, the random integer is\n     * generated synchronously.\n     *\n     * ```js\n     * // Asynchronous\n     * const {\n     *   randomInt,\n     * } = await import('node:crypto');\n     *\n     * randomInt(3, (err, n) => {\n     *   if (err) throw err;\n     *   console.log(`Random number chosen from (0, 1, 2): ${n}`);\n     * });\n     * ```\n     *\n     * ```js\n     * // Synchronous\n     * const {\n     *   randomInt,\n     * } = await import('node:crypto');\n     *\n     * const n = randomInt(3);\n     * console.log(`Random number chosen from (0, 1, 2): ${n}`);\n     * ```\n     *\n     * ```js\n     * // With `min` argument\n     * const {\n     *   randomInt,\n     * } = await import('node:crypto');\n     *\n     * const n = randomInt(1, 7);\n     * console.log(`The dice rolled: ${n}`);\n     * ```\n     * @since v14.10.0, v12.19.0\n     * @param [min=0] Start of random range (inclusive).\n     * @param max End of random range (exclusive).\n     * @param callback `function(err, n) {}`.\n     */\n    function randomInt(max: number): number;\n    function randomInt(min: number, max: number): number;\n    function randomInt(max: number, callback: (err: Error | null, value: number) => void): void;\n    function randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;\n    /**\n     * Synchronous version of {@link randomFill}.\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const { randomFillSync } = await import('node:crypto');\n     *\n     * const buf = Buffer.alloc(10);\n     * console.log(randomFillSync(buf).toString('hex'));\n     *\n     * randomFillSync(buf, 5);\n     * console.log(buf.toString('hex'));\n     *\n     * // The above is equivalent to the following:\n     * randomFillSync(buf, 5, 5);\n     * console.log(buf.toString('hex'));\n     * ```\n     *\n     * Any `ArrayBuffer`, `TypedArray` or `DataView` instance may be passed as`buffer`.\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const { randomFillSync } = await import('node:crypto');\n     *\n     * const a = new Uint32Array(10);\n     * console.log(Buffer.from(randomFillSync(a).buffer,\n     *                         a.byteOffset, a.byteLength).toString('hex'));\n     *\n     * const b = new DataView(new ArrayBuffer(10));\n     * console.log(Buffer.from(randomFillSync(b).buffer,\n     *                         b.byteOffset, b.byteLength).toString('hex'));\n     *\n     * const c = new ArrayBuffer(10);\n     * console.log(Buffer.from(randomFillSync(c)).toString('hex'));\n     * ```\n     * @since v7.10.0, v6.13.0\n     * @param buffer Must be supplied. The size of the provided `buffer` must not be larger than `2**31 - 1`.\n     * @param [offset=0]\n     * @param [size=buffer.length - offset]\n     * @return The object passed as `buffer` argument.\n     */\n    function randomFillSync<T extends NodeJS.ArrayBufferView>(buffer: T, offset?: number, size?: number): T;\n    /**\n     * This function is similar to {@link randomBytes} but requires the first\n     * argument to be a `Buffer` that will be filled. It also\n     * requires that a callback is passed in.\n     *\n     * If the `callback` function is not provided, an error will be thrown.\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const { randomFill } = await import('node:crypto');\n     *\n     * const buf = Buffer.alloc(10);\n     * randomFill(buf, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(buf.toString('hex'));\n     * });\n     *\n     * randomFill(buf, 5, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(buf.toString('hex'));\n     * });\n     *\n     * // The above is equivalent to the following:\n     * randomFill(buf, 5, 5, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(buf.toString('hex'));\n     * });\n     * ```\n     *\n     * Any `ArrayBuffer`, `TypedArray`, or `DataView` instance may be passed as `buffer`.\n     *\n     * While this includes instances of `Float32Array` and `Float64Array`, this\n     * function should not be used to generate random floating-point numbers. The\n     * result may contain `+Infinity`, `-Infinity`, and `NaN`, and even if the array\n     * contains finite numbers only, they are not drawn from a uniform random\n     * distribution and have no meaningful lower or upper bounds.\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const { randomFill } = await import('node:crypto');\n     *\n     * const a = new Uint32Array(10);\n     * randomFill(a, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)\n     *     .toString('hex'));\n     * });\n     *\n     * const b = new DataView(new ArrayBuffer(10));\n     * randomFill(b, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)\n     *     .toString('hex'));\n     * });\n     *\n     * const c = new ArrayBuffer(10);\n     * randomFill(c, (err, buf) => {\n     *   if (err) throw err;\n     *   console.log(Buffer.from(buf).toString('hex'));\n     * });\n     * ```\n     *\n     * This API uses libuv's threadpool, which can have surprising and\n     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.\n     *\n     * The asynchronous version of `crypto.randomFill()` is carried out in a single\n     * threadpool request. To minimize threadpool task length variation, partition\n     * large `randomFill` requests when doing so as part of fulfilling a client\n     * request.\n     * @since v7.10.0, v6.13.0\n     * @param buffer Must be supplied. The size of the provided `buffer` must not be larger than `2**31 - 1`.\n     * @param [offset=0]\n     * @param [size=buffer.length - offset]\n     * @param callback `function(err, buf) {}`.\n     */\n    function randomFill<T extends NodeJS.ArrayBufferView>(\n        buffer: T,\n        callback: (err: Error | null, buf: T) => void,\n    ): void;\n    function randomFill<T extends NodeJS.ArrayBufferView>(\n        buffer: T,\n        offset: number,\n        callback: (err: Error | null, buf: T) => void,\n    ): void;\n    function randomFill<T extends NodeJS.ArrayBufferView>(\n        buffer: T,\n        offset: number,\n        size: number,\n        callback: (err: Error | null, buf: T) => void,\n    ): void;\n    interface ScryptOptions {\n        cost?: number | undefined;\n        blockSize?: number | undefined;\n        parallelization?: number | undefined;\n        N?: number | undefined;\n        r?: number | undefined;\n        p?: number | undefined;\n        maxmem?: number | undefined;\n    }\n    /**\n     * Provides an asynchronous [scrypt](https://en.wikipedia.org/wiki/Scrypt) implementation. Scrypt is a password-based\n     * key derivation function that is designed to be expensive computationally and\n     * memory-wise in order to make brute-force attacks unrewarding.\n     *\n     * The `salt` should be as unique as possible. It is recommended that a salt is\n     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.\n     *\n     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.\n     *\n     * The `callback` function is called with two arguments: `err` and `derivedKey`. `err` is an exception object when key derivation fails, otherwise `err` is `null`. `derivedKey` is passed to the\n     * callback as a `Buffer`.\n     *\n     * An exception is thrown when any of the input arguments specify invalid values\n     * or types.\n     *\n     * ```js\n     * const {\n     *   scrypt,\n     * } = await import('node:crypto');\n     *\n     * // Using the factory defaults.\n     * scrypt('password', 'salt', 64, (err, derivedKey) => {\n     *   if (err) throw err;\n     *   console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'\n     * });\n     * // Using a custom N parameter. Must be a power of two.\n     * scrypt('password', 'salt', 64, { N: 1024 }, (err, derivedKey) => {\n     *   if (err) throw err;\n     *   console.log(derivedKey.toString('hex'));  // '3745e48...aa39b34'\n     * });\n     * ```\n     * @since v10.5.0\n     */\n    function scrypt(\n        password: BinaryLike,\n        salt: BinaryLike,\n        keylen: number,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    function scrypt(\n        password: BinaryLike,\n        salt: BinaryLike,\n        keylen: number,\n        options: ScryptOptions,\n        callback: (err: Error | null, derivedKey: Buffer) => void,\n    ): void;\n    /**\n     * Provides a synchronous [scrypt](https://en.wikipedia.org/wiki/Scrypt) implementation. Scrypt is a password-based\n     * key derivation function that is designed to be expensive computationally and\n     * memory-wise in order to make brute-force attacks unrewarding.\n     *\n     * The `salt` should be as unique as possible. It is recommended that a salt is\n     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.\n     *\n     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.\n     *\n     * An exception is thrown when key derivation fails, otherwise the derived key is\n     * returned as a `Buffer`.\n     *\n     * An exception is thrown when any of the input arguments specify invalid values\n     * or types.\n     *\n     * ```js\n     * const {\n     *   scryptSync,\n     * } = await import('node:crypto');\n     * // Using the factory defaults.\n     *\n     * const key1 = scryptSync('password', 'salt', 64);\n     * console.log(key1.toString('hex'));  // '3745e48...08d59ae'\n     * // Using a custom N parameter. Must be a power of two.\n     * const key2 = scryptSync('password', 'salt', 64, { N: 1024 });\n     * console.log(key2.toString('hex'));  // '3745e48...aa39b34'\n     * ```\n     * @since v10.5.0\n     */\n    function scryptSync(password: BinaryLike, salt: BinaryLike, keylen: number, options?: ScryptOptions): Buffer;\n    interface RsaPublicKey {\n        key: KeyLike;\n        padding?: number | undefined;\n    }\n    interface RsaPrivateKey {\n        key: KeyLike;\n        passphrase?: string | undefined;\n        /**\n         * @default 'sha1'\n         */\n        oaepHash?: string | undefined;\n        oaepLabel?: NodeJS.TypedArray | undefined;\n        padding?: number | undefined;\n    }\n    /**\n     * Encrypts the content of `buffer` with `key` and returns a new `Buffer` with encrypted content. The returned data can be decrypted using\n     * the corresponding private key, for example using {@link privateDecrypt}.\n     *\n     * If `key` is not a `KeyObject`, this function behaves as if `key` had been passed to {@link createPublicKey}. If it is an\n     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_OAEP_PADDING`.\n     *\n     * Because RSA public keys can be derived from private keys, a private key may\n     * be passed instead of a public key.\n     * @since v0.11.14\n     */\n    function publicEncrypt(\n        key: RsaPublicKey | RsaPrivateKey | KeyLike,\n        buffer: NodeJS.ArrayBufferView | string,\n    ): Buffer;\n    /**\n     * Decrypts `buffer` with `key`.`buffer` was previously encrypted using\n     * the corresponding private key, for example using {@link privateEncrypt}.\n     *\n     * If `key` is not a `KeyObject`, this function behaves as if `key` had been passed to {@link createPublicKey}. If it is an\n     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_PADDING`.\n     *\n     * Because RSA public keys can be derived from private keys, a private key may\n     * be passed instead of a public key.\n     * @since v1.1.0\n     */\n    function publicDecrypt(\n        key: RsaPublicKey | RsaPrivateKey | KeyLike,\n        buffer: NodeJS.ArrayBufferView | string,\n    ): Buffer;\n    /**\n     * Decrypts `buffer` with `privateKey`. `buffer` was previously encrypted using\n     * the corresponding public key, for example using {@link publicEncrypt}.\n     *\n     * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an\n     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_OAEP_PADDING`.\n     * @since v0.11.14\n     */\n    function privateDecrypt(privateKey: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView | string): Buffer;\n    /**\n     * Encrypts `buffer` with `privateKey`. The returned data can be decrypted using\n     * the corresponding public key, for example using {@link publicDecrypt}.\n     *\n     * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an\n     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_PADDING`.\n     * @since v1.1.0\n     */\n    function privateEncrypt(privateKey: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView | string): Buffer;\n    /**\n     * ```js\n     * const {\n     *   getCiphers,\n     * } = await import('node:crypto');\n     *\n     * console.log(getCiphers()); // ['aes-128-cbc', 'aes-128-ccm', ...]\n     * ```\n     * @since v0.9.3\n     * @return An array with the names of the supported cipher algorithms.\n     */\n    function getCiphers(): string[];\n    /**\n     * ```js\n     * const {\n     *   getCurves,\n     * } = await import('node:crypto');\n     *\n     * console.log(getCurves()); // ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]\n     * ```\n     * @since v2.3.0\n     * @return An array with the names of the supported elliptic curves.\n     */\n    function getCurves(): string[];\n    /**\n     * @since v10.0.0\n     * @return `1` if and only if a FIPS compliant crypto provider is currently in use, `0` otherwise. A future semver-major release may change the return type of this API to a {boolean}.\n     */\n    function getFips(): 1 | 0;\n    /**\n     * Enables the FIPS compliant crypto provider in a FIPS-enabled Node.js build.\n     * Throws an error if FIPS mode is not available.\n     * @since v10.0.0\n     * @param bool `true` to enable FIPS mode.\n     */\n    function setFips(bool: boolean): void;\n    /**\n     * ```js\n     * const {\n     *   getHashes,\n     * } = await import('node:crypto');\n     *\n     * console.log(getHashes()); // ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]\n     * ```\n     * @since v0.9.3\n     * @return An array of the names of the supported hash algorithms, such as `'RSA-SHA256'`. Hash algorithms are also called \"digest\" algorithms.\n     */\n    function getHashes(): string[];\n    /**\n     * The `ECDH` class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH)\n     * key exchanges.\n     *\n     * Instances of the `ECDH` class can be created using the {@link createECDH} function.\n     *\n     * ```js\n     * import assert from 'node:assert';\n     *\n     * const {\n     *   createECDH,\n     * } = await import('node:crypto');\n     *\n     * // Generate Alice's keys...\n     * const alice = createECDH('secp521r1');\n     * const aliceKey = alice.generateKeys();\n     *\n     * // Generate Bob's keys...\n     * const bob = createECDH('secp521r1');\n     * const bobKey = bob.generateKeys();\n     *\n     * // Exchange and generate the secret...\n     * const aliceSecret = alice.computeSecret(bobKey);\n     * const bobSecret = bob.computeSecret(aliceKey);\n     *\n     * assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));\n     * // OK\n     * ```\n     * @since v0.11.14\n     */\n    class ECDH {\n        private constructor();\n        /**\n         * Converts the EC Diffie-Hellman public key specified by `key` and `curve` to the\n         * format specified by `format`. The `format` argument specifies point encoding\n         * and can be `'compressed'`, `'uncompressed'` or `'hybrid'`. The supplied key is\n         * interpreted using the specified `inputEncoding`, and the returned key is encoded\n         * using the specified `outputEncoding`.\n         *\n         * Use {@link getCurves} to obtain a list of available curve names.\n         * On recent OpenSSL releases, `openssl ecparam -list_curves` will also display\n         * the name and description of each available elliptic curve.\n         *\n         * If `format` is not specified the point will be returned in `'uncompressed'` format.\n         *\n         * If the `inputEncoding` is not provided, `key` is expected to be a `Buffer`, `TypedArray`, or `DataView`.\n         *\n         * Example (uncompressing a key):\n         *\n         * ```js\n         * const {\n         *   createECDH,\n         *   ECDH,\n         * } = await import('node:crypto');\n         *\n         * const ecdh = createECDH('secp256k1');\n         * ecdh.generateKeys();\n         *\n         * const compressedKey = ecdh.getPublicKey('hex', 'compressed');\n         *\n         * const uncompressedKey = ECDH.convertKey(compressedKey,\n         *                                         'secp256k1',\n         *                                         'hex',\n         *                                         'hex',\n         *                                         'uncompressed');\n         *\n         * // The converted key and the uncompressed public key should be the same\n         * console.log(uncompressedKey === ecdh.getPublicKey('hex'));\n         * ```\n         * @since v10.0.0\n         * @param inputEncoding The `encoding` of the `key` string.\n         * @param outputEncoding The `encoding` of the return value.\n         * @param [format='uncompressed']\n         */\n        static convertKey(\n            key: BinaryLike,\n            curve: string,\n            inputEncoding?: BinaryToTextEncoding,\n            outputEncoding?: \"latin1\" | \"hex\" | \"base64\" | \"base64url\",\n            format?: \"uncompressed\" | \"compressed\" | \"hybrid\",\n        ): Buffer | string;\n        /**\n         * Generates private and public EC Diffie-Hellman key values, and returns\n         * the public key in the specified `format` and `encoding`. This key should be\n         * transferred to the other party.\n         *\n         * The `format` argument specifies point encoding and can be `'compressed'` or `'uncompressed'`. If `format` is not specified, the point will be returned in`'uncompressed'` format.\n         *\n         * If `encoding` is provided a string is returned; otherwise a `Buffer` is returned.\n         * @since v0.11.14\n         * @param encoding The `encoding` of the return value.\n         * @param [format='uncompressed']\n         */\n        generateKeys(): Buffer;\n        generateKeys(encoding: BinaryToTextEncoding, format?: ECDHKeyFormat): string;\n        /**\n         * Computes the shared secret using `otherPublicKey` as the other\n         * party's public key and returns the computed shared secret. The supplied\n         * key is interpreted using specified `inputEncoding`, and the returned secret\n         * is encoded using the specified `outputEncoding`.\n         * If the `inputEncoding` is not\n         * provided, `otherPublicKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.\n         *\n         * If `outputEncoding` is given a string will be returned; otherwise a `Buffer` is returned.\n         *\n         * `ecdh.computeSecret` will throw an`ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY` error when `otherPublicKey` lies outside of the elliptic curve. Since `otherPublicKey` is\n         * usually supplied from a remote user over an insecure network,\n         * be sure to handle this exception accordingly.\n         * @since v0.11.14\n         * @param inputEncoding The `encoding` of the `otherPublicKey` string.\n         * @param outputEncoding The `encoding` of the return value.\n         */\n        computeSecret(otherPublicKey: NodeJS.ArrayBufferView): Buffer;\n        computeSecret(otherPublicKey: string, inputEncoding: BinaryToTextEncoding): Buffer;\n        computeSecret(otherPublicKey: NodeJS.ArrayBufferView, outputEncoding: BinaryToTextEncoding): string;\n        computeSecret(\n            otherPublicKey: string,\n            inputEncoding: BinaryToTextEncoding,\n            outputEncoding: BinaryToTextEncoding,\n        ): string;\n        /**\n         * If `encoding` is specified, a string is returned; otherwise a `Buffer` is\n         * returned.\n         * @since v0.11.14\n         * @param encoding The `encoding` of the return value.\n         * @return The EC Diffie-Hellman in the specified `encoding`.\n         */\n        getPrivateKey(): Buffer;\n        getPrivateKey(encoding: BinaryToTextEncoding): string;\n        /**\n         * The `format` argument specifies point encoding and can be `'compressed'` or `'uncompressed'`. If `format` is not specified the point will be returned in`'uncompressed'` format.\n         *\n         * If `encoding` is specified, a string is returned; otherwise a `Buffer` is\n         * returned.\n         * @since v0.11.14\n         * @param encoding The `encoding` of the return value.\n         * @param [format='uncompressed']\n         * @return The EC Diffie-Hellman public key in the specified `encoding` and `format`.\n         */\n        getPublicKey(encoding?: null, format?: ECDHKeyFormat): Buffer;\n        getPublicKey(encoding: BinaryToTextEncoding, format?: ECDHKeyFormat): string;\n        /**\n         * Sets the EC Diffie-Hellman private key.\n         * If `encoding` is provided, `privateKey` is expected\n         * to be a string; otherwise `privateKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.\n         *\n         * If `privateKey` is not valid for the curve specified when the `ECDH` object was\n         * created, an error is thrown. Upon setting the private key, the associated\n         * public point (key) is also generated and set in the `ECDH` object.\n         * @since v0.11.14\n         * @param encoding The `encoding` of the `privateKey` string.\n         */\n        setPrivateKey(privateKey: NodeJS.ArrayBufferView): void;\n        setPrivateKey(privateKey: string, encoding: BinaryToTextEncoding): void;\n    }\n    /**\n     * Creates an Elliptic Curve Diffie-Hellman (`ECDH`) key exchange object using a\n     * predefined curve specified by the `curveName` string. Use {@link getCurves} to obtain a list of available curve names. On recent\n     * OpenSSL releases, `openssl ecparam -list_curves` will also display the name\n     * and description of each available elliptic curve.\n     * @since v0.11.14\n     */\n    function createECDH(curveName: string): ECDH;\n    /**\n     * This function compares the underlying bytes that represent the given `ArrayBuffer`, `TypedArray`, or `DataView` instances using a constant-time\n     * algorithm.\n     *\n     * This function does not leak timing information that\n     * would allow an attacker to guess one of the values. This is suitable for\n     * comparing HMAC digests or secret values like authentication cookies or [capability urls](https://www.w3.org/TR/capability-urls/).\n     *\n     * `a` and `b` must both be `Buffer`s, `TypedArray`s, or `DataView`s, and they\n     * must have the same byte length. An error is thrown if `a` and `b` have\n     * different byte lengths.\n     *\n     * If at least one of `a` and `b` is a `TypedArray` with more than one byte per\n     * entry, such as `Uint16Array`, the result will be computed using the platform\n     * byte order.\n     *\n     * **When both of the inputs are `Float32Array`s or `Float64Array`s, this function might return unexpected results due to IEEE 754**\n     * **encoding of floating-point numbers. In particular, neither `x === y` nor `Object.is(x, y)` implies that the byte representations of two floating-point**\n     * **numbers `x` and `y` are equal.**\n     *\n     * Use of `crypto.timingSafeEqual` does not guarantee that the _surrounding_ code\n     * is timing-safe. Care should be taken to ensure that the surrounding code does\n     * not introduce timing vulnerabilities.\n     * @since v6.6.0\n     */\n    function timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;\n    type KeyType = \"rsa\" | \"rsa-pss\" | \"dsa\" | \"ec\" | \"ed25519\" | \"ed448\" | \"x25519\" | \"x448\";\n    type KeyFormat = \"pem\" | \"der\" | \"jwk\";\n    interface BasePrivateKeyEncodingOptions<T extends KeyFormat> {\n        format: T;\n        cipher?: string | undefined;\n        passphrase?: string | undefined;\n    }\n    interface KeyPairKeyObjectResult {\n        publicKey: KeyObject;\n        privateKey: KeyObject;\n    }\n    interface ED25519KeyPairKeyObjectOptions {}\n    interface ED448KeyPairKeyObjectOptions {}\n    interface X25519KeyPairKeyObjectOptions {}\n    interface X448KeyPairKeyObjectOptions {}\n    interface ECKeyPairKeyObjectOptions {\n        /**\n         * Name of the curve to use\n         */\n        namedCurve: string;\n        /**\n         * Must be `'named'` or `'explicit'`. Default: `'named'`.\n         */\n        paramEncoding?: \"explicit\" | \"named\" | undefined;\n    }\n    interface RSAKeyPairKeyObjectOptions {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Public exponent\n         * @default 0x10001\n         */\n        publicExponent?: number | undefined;\n    }\n    interface RSAPSSKeyPairKeyObjectOptions {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Public exponent\n         * @default 0x10001\n         */\n        publicExponent?: number | undefined;\n        /**\n         * Name of the message digest\n         */\n        hashAlgorithm?: string;\n        /**\n         * Name of the message digest used by MGF1\n         */\n        mgf1HashAlgorithm?: string;\n        /**\n         * Minimal salt length in bytes\n         */\n        saltLength?: string;\n    }\n    interface DSAKeyPairKeyObjectOptions {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Size of q in bits\n         */\n        divisorLength: number;\n    }\n    interface RSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Public exponent\n         * @default 0x10001\n         */\n        publicExponent?: number | undefined;\n        publicKeyEncoding: {\n            type: \"pkcs1\" | \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs1\" | \"pkcs8\";\n        };\n    }\n    interface RSAPSSKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Public exponent\n         * @default 0x10001\n         */\n        publicExponent?: number | undefined;\n        /**\n         * Name of the message digest\n         */\n        hashAlgorithm?: string;\n        /**\n         * Name of the message digest used by MGF1\n         */\n        mgf1HashAlgorithm?: string;\n        /**\n         * Minimal salt length in bytes\n         */\n        saltLength?: string;\n        publicKeyEncoding: {\n            type: \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs8\";\n        };\n    }\n    interface DSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        /**\n         * Key size in bits\n         */\n        modulusLength: number;\n        /**\n         * Size of q in bits\n         */\n        divisorLength: number;\n        publicKeyEncoding: {\n            type: \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs8\";\n        };\n    }\n    interface ECKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> extends ECKeyPairKeyObjectOptions {\n        publicKeyEncoding: {\n            type: \"pkcs1\" | \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"sec1\" | \"pkcs8\";\n        };\n    }\n    interface ED25519KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        publicKeyEncoding: {\n            type: \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs8\";\n        };\n    }\n    interface ED448KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        publicKeyEncoding: {\n            type: \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs8\";\n        };\n    }\n    interface X25519KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        publicKeyEncoding: {\n            type: \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs8\";\n        };\n    }\n    interface X448KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {\n        publicKeyEncoding: {\n            type: \"spki\";\n            format: PubF;\n        };\n        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {\n            type: \"pkcs8\";\n        };\n    }\n    interface KeyPairSyncResult<T1 extends string | Buffer, T2 extends string | Buffer> {\n        publicKey: T1;\n        privateKey: T2;\n    }\n    /**\n     * Generates a new asymmetric key pair of the given `type`. RSA, RSA-PSS, DSA, EC,\n     * Ed25519, Ed448, X25519, X448, and DH are currently supported.\n     *\n     * If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function\n     * behaves as if `keyObject.export()` had been called on its result. Otherwise,\n     * the respective part of the key is returned as a `KeyObject`.\n     *\n     * When encoding public keys, it is recommended to use `'spki'`. When encoding\n     * private keys, it is recommended to use `'pkcs8'` with a strong passphrase,\n     * and to keep the passphrase confidential.\n     *\n     * ```js\n     * const {\n     *   generateKeyPairSync,\n     * } = await import('node:crypto');\n     *\n     * const {\n     *   publicKey,\n     *   privateKey,\n     * } = generateKeyPairSync('rsa', {\n     *   modulusLength: 4096,\n     *   publicKeyEncoding: {\n     *     type: 'spki',\n     *     format: 'pem',\n     *   },\n     *   privateKeyEncoding: {\n     *     type: 'pkcs8',\n     *     format: 'pem',\n     *     cipher: 'aes-256-cbc',\n     *     passphrase: 'top secret',\n     *   },\n     * });\n     * ```\n     *\n     * The return value `{ publicKey, privateKey }` represents the generated key pair.\n     * When PEM encoding was selected, the respective key will be a string, otherwise\n     * it will be a buffer containing the data encoded as DER.\n     * @since v10.12.0\n     * @param type Must be `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, or `'dh'`.\n     */\n    function generateKeyPairSync(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"rsa\", options: RSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"rsa-pss\", options: RSAPSSKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"dsa\", options: DSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"ec\", options: ECKeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"ed25519\", options?: ED25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"ed448\", options?: ED448KeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"x25519\", options?: X25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    function generateKeyPairSync(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"pem\", \"pem\">,\n    ): KeyPairSyncResult<string, string>;\n    function generateKeyPairSync(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"pem\", \"der\">,\n    ): KeyPairSyncResult<string, Buffer>;\n    function generateKeyPairSync(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"der\", \"pem\">,\n    ): KeyPairSyncResult<Buffer, string>;\n    function generateKeyPairSync(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"der\", \"der\">,\n    ): KeyPairSyncResult<Buffer, Buffer>;\n    function generateKeyPairSync(type: \"x448\", options?: X448KeyPairKeyObjectOptions): KeyPairKeyObjectResult;\n    /**\n     * Generates a new asymmetric key pair of the given `type`. RSA, RSA-PSS, DSA, EC,\n     * Ed25519, Ed448, X25519, X448, and DH are currently supported.\n     *\n     * If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function\n     * behaves as if `keyObject.export()` had been called on its result. Otherwise,\n     * the respective part of the key is returned as a `KeyObject`.\n     *\n     * It is recommended to encode public keys as `'spki'` and private keys as `'pkcs8'` with encryption for long-term storage:\n     *\n     * ```js\n     * const {\n     *   generateKeyPair,\n     * } = await import('node:crypto');\n     *\n     * generateKeyPair('rsa', {\n     *   modulusLength: 4096,\n     *   publicKeyEncoding: {\n     *     type: 'spki',\n     *     format: 'pem',\n     *   },\n     *   privateKeyEncoding: {\n     *     type: 'pkcs8',\n     *     format: 'pem',\n     *     cipher: 'aes-256-cbc',\n     *     passphrase: 'top secret',\n     *   },\n     * }, (err, publicKey, privateKey) => {\n     *   // Handle errors and use the generated key pair.\n     * });\n     * ```\n     *\n     * On completion, `callback` will be called with `err` set to `undefined` and `publicKey` / `privateKey` representing the generated key pair.\n     *\n     * If this method is invoked as its `util.promisify()` ed version, it returns\n     * a `Promise` for an `Object` with `publicKey` and `privateKey` properties.\n     * @since v10.12.0\n     * @param type Must be `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, or `'dh'`.\n     */\n    function generateKeyPair(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa\",\n        options: RSAKeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa\",\n        options: RSAKeyPairKeyObjectOptions,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"rsa-pss\",\n        options: RSAPSSKeyPairKeyObjectOptions,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"dsa\",\n        options: DSAKeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"dsa\",\n        options: DSAKeyPairKeyObjectOptions,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ec\",\n        options: ECKeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ec\",\n        options: ECKeyPairKeyObjectOptions,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed25519\",\n        options: ED25519KeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed25519\",\n        options: ED25519KeyPairKeyObjectOptions | undefined,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed448\",\n        options: ED448KeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"ed448\",\n        options: ED448KeyPairKeyObjectOptions | undefined,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x25519\",\n        options: X25519KeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x25519\",\n        options: X25519KeyPairKeyObjectOptions | undefined,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"pem\", \"pem\">,\n        callback: (err: Error | null, publicKey: string, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"pem\", \"der\">,\n        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"der\", \"pem\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x448\",\n        options: X448KeyPairOptions<\"der\", \"der\">,\n        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,\n    ): void;\n    function generateKeyPair(\n        type: \"x448\",\n        options: X448KeyPairKeyObjectOptions | undefined,\n        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,\n    ): void;\n    namespace generateKeyPair {\n        function __promisify__(\n            type: \"rsa\",\n            options: RSAKeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"rsa\",\n            options: RSAKeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"rsa\",\n            options: RSAKeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"rsa\",\n            options: RSAKeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(type: \"rsa\", options: RSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"rsa-pss\",\n            options: RSAPSSKeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"rsa-pss\",\n            options: RSAPSSKeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"rsa-pss\",\n            options: RSAPSSKeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"rsa-pss\",\n            options: RSAPSSKeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"rsa-pss\",\n            options: RSAPSSKeyPairKeyObjectOptions,\n        ): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"dsa\",\n            options: DSAKeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"dsa\",\n            options: DSAKeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"dsa\",\n            options: DSAKeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"dsa\",\n            options: DSAKeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(type: \"dsa\", options: DSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"ec\",\n            options: ECKeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"ec\",\n            options: ECKeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"ec\",\n            options: ECKeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"ec\",\n            options: ECKeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(type: \"ec\", options: ECKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"ed25519\",\n            options: ED25519KeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"ed25519\",\n            options: ED25519KeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"ed25519\",\n            options: ED25519KeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"ed25519\",\n            options: ED25519KeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"ed25519\",\n            options?: ED25519KeyPairKeyObjectOptions,\n        ): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"ed448\",\n            options: ED448KeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"ed448\",\n            options: ED448KeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"ed448\",\n            options: ED448KeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"ed448\",\n            options: ED448KeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(type: \"ed448\", options?: ED448KeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"x25519\",\n            options: X25519KeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"x25519\",\n            options: X25519KeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"x25519\",\n            options: X25519KeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"x25519\",\n            options: X25519KeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"x25519\",\n            options?: X25519KeyPairKeyObjectOptions,\n        ): Promise<KeyPairKeyObjectResult>;\n        function __promisify__(\n            type: \"x448\",\n            options: X448KeyPairOptions<\"pem\", \"pem\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"x448\",\n            options: X448KeyPairOptions<\"pem\", \"der\">,\n        ): Promise<{\n            publicKey: string;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(\n            type: \"x448\",\n            options: X448KeyPairOptions<\"der\", \"pem\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: string;\n        }>;\n        function __promisify__(\n            type: \"x448\",\n            options: X448KeyPairOptions<\"der\", \"der\">,\n        ): Promise<{\n            publicKey: Buffer;\n            privateKey: Buffer;\n        }>;\n        function __promisify__(type: \"x448\", options?: X448KeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;\n    }\n    /**\n     * Calculates and returns the signature for `data` using the given private key and\n     * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is\n     * dependent upon the key type (especially Ed25519 and Ed448).\n     *\n     * If `key` is not a `KeyObject`, this function behaves as if `key` had been\n     * passed to {@link createPrivateKey}. If it is an object, the following\n     * additional properties can be passed:\n     *\n     * If the `callback` function is provided this function uses libuv's threadpool.\n     * @since v12.0.0\n     */\n    function sign(\n        algorithm: string | null | undefined,\n        data: NodeJS.ArrayBufferView,\n        key: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,\n    ): Buffer;\n    function sign(\n        algorithm: string | null | undefined,\n        data: NodeJS.ArrayBufferView,\n        key: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,\n        callback: (error: Error | null, data: Buffer) => void,\n    ): void;\n    /**\n     * Verifies the given signature for `data` using the given key and algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is dependent upon the\n     * key type (especially Ed25519 and Ed448).\n     *\n     * If `key` is not a `KeyObject`, this function behaves as if `key` had been\n     * passed to {@link createPublicKey}. If it is an object, the following\n     * additional properties can be passed:\n     *\n     * The `signature` argument is the previously calculated signature for the `data`.\n     *\n     * Because public keys can be derived from private keys, a private key or a public\n     * key may be passed for `key`.\n     *\n     * If the `callback` function is provided this function uses libuv's threadpool.\n     * @since v12.0.0\n     */\n    function verify(\n        algorithm: string | null | undefined,\n        data: NodeJS.ArrayBufferView,\n        key: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,\n        signature: NodeJS.ArrayBufferView,\n    ): boolean;\n    function verify(\n        algorithm: string | null | undefined,\n        data: NodeJS.ArrayBufferView,\n        key: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,\n        signature: NodeJS.ArrayBufferView,\n        callback: (error: Error | null, result: boolean) => void,\n    ): void;\n    /**\n     * Computes the Diffie-Hellman secret based on a `privateKey` and a `publicKey`.\n     * Both keys must have the same `asymmetricKeyType`, which must be one of `'dh'` (for Diffie-Hellman), `'ec'` (for ECDH), `'x448'`, or `'x25519'` (for ECDH-ES).\n     * @since v13.9.0, v12.17.0\n     */\n    function diffieHellman(options: { privateKey: KeyObject; publicKey: KeyObject }): Buffer;\n    /**\n     * A utility for creating one-shot hash digests of data. It can be faster than the object-based `crypto.createHash()` when hashing a smaller amount of data\n     * (<= 5MB) that's readily available. If the data can be big or if it is streamed, it's still recommended to use `crypto.createHash()` instead. The `algorithm`\n     * is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc. On recent releases\n     * of OpenSSL, `openssl list -digest-algorithms` will display the available digest algorithms.\n     *\n     * Example:\n     *\n     * ```js\n     * import crypto from 'node:crypto';\n     * import { Buffer } from 'node:buffer';\n     *\n     * // Hashing a string and return the result as a hex-encoded string.\n     * const string = 'Node.js';\n     * // 10b3493287f831e81a438811a1ffba01f8cec4b7\n     * console.log(crypto.hash('sha1', string));\n     *\n     * // Encode a base64-encoded string into a Buffer, hash it and return\n     * // the result as a buffer.\n     * const base64 = 'Tm9kZS5qcw==';\n     * // <Buffer 10 b3 49 32 87 f8 31 e8 1a 43 88 11 a1 ff ba 01 f8 ce c4 b7>\n     * console.log(crypto.hash('sha1', Buffer.from(base64, 'base64'), 'buffer'));\n     * ```\n     * @since v21.7.0, v20.12.0\n     * @param data When `data` is a string, it will be encoded as UTF-8 before being hashed. If a different input encoding is desired for a string input, user\n     *             could encode the string into a `TypedArray` using either `TextEncoder` or `Buffer.from()` and passing the encoded `TypedArray` into this API instead.\n     * @param [outputEncoding='hex'] [Encoding](https://nodejs.org/docs/latest-v22.x/api/buffer.html#buffers-and-character-encodings) used to encode the returned digest.\n     */\n    function hash(algorithm: string, data: BinaryLike, outputEncoding?: BinaryToTextEncoding): string;\n    function hash(algorithm: string, data: BinaryLike, outputEncoding: \"buffer\"): Buffer;\n    function hash(\n        algorithm: string,\n        data: BinaryLike,\n        outputEncoding?: BinaryToTextEncoding | \"buffer\",\n    ): string | Buffer;\n    type CipherMode = \"cbc\" | \"ccm\" | \"cfb\" | \"ctr\" | \"ecb\" | \"gcm\" | \"ocb\" | \"ofb\" | \"stream\" | \"wrap\" | \"xts\";\n    interface CipherInfoOptions {\n        /**\n         * A test key length.\n         */\n        keyLength?: number | undefined;\n        /**\n         * A test IV length.\n         */\n        ivLength?: number | undefined;\n    }\n    interface CipherInfo {\n        /**\n         * The name of the cipher.\n         */\n        name: string;\n        /**\n         * The nid of the cipher.\n         */\n        nid: number;\n        /**\n         * The block size of the cipher in bytes.\n         * This property is omitted when mode is 'stream'.\n         */\n        blockSize?: number | undefined;\n        /**\n         * The expected or default initialization vector length in bytes.\n         * This property is omitted if the cipher does not use an initialization vector.\n         */\n        ivLength?: number | undefined;\n        /**\n         * The expected or default key length in bytes.\n         */\n        keyLength: number;\n        /**\n         * The cipher mode.\n         */\n        mode: CipherMode;\n    }\n    /**\n     * Returns information about a given cipher.\n     *\n     * Some ciphers accept variable length keys and initialization vectors. By default,\n     * the `crypto.getCipherInfo()` method will return the default values for these\n     * ciphers. To test if a given key length or iv length is acceptable for given\n     * cipher, use the `keyLength` and `ivLength` options. If the given values are\n     * unacceptable, `undefined` will be returned.\n     * @since v15.0.0\n     * @param nameOrNid The name or nid of the cipher to query.\n     */\n    function getCipherInfo(nameOrNid: string | number, options?: CipherInfoOptions): CipherInfo | undefined;\n    /**\n     * HKDF is a simple key derivation function defined in RFC 5869\\. The given `ikm`, `salt` and `info` are used with the `digest` to derive a key of `keylen` bytes.\n     *\n     * The supplied `callback` function is called with two arguments: `err` and `derivedKey`. If an errors occurs while deriving the key, `err` will be set;\n     * otherwise `err` will be `null`. The successfully generated `derivedKey` will\n     * be passed to the callback as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). An error will be thrown if any\n     * of the input arguments specify invalid values or types.\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const {\n     *   hkdf,\n     * } = await import('node:crypto');\n     *\n     * hkdf('sha512', 'key', 'salt', 'info', 64, (err, derivedKey) => {\n     *   if (err) throw err;\n     *   console.log(Buffer.from(derivedKey).toString('hex'));  // '24156e2...5391653'\n     * });\n     * ```\n     * @since v15.0.0\n     * @param digest The digest algorithm to use.\n     * @param ikm The input keying material. Must be provided but can be zero-length.\n     * @param salt The salt value. Must be provided but can be zero-length.\n     * @param info Additional info value. Must be provided but can be zero-length, and cannot be more than 1024 bytes.\n     * @param keylen The length of the key to generate. Must be greater than 0. The maximum allowable value is `255` times the number of bytes produced by the selected digest function (e.g. `sha512`\n     * generates 64-byte hashes, making the maximum HKDF output 16320 bytes).\n     */\n    function hkdf(\n        digest: string,\n        irm: BinaryLike | KeyObject,\n        salt: BinaryLike,\n        info: BinaryLike,\n        keylen: number,\n        callback: (err: Error | null, derivedKey: ArrayBuffer) => void,\n    ): void;\n    /**\n     * Provides a synchronous HKDF key derivation function as defined in RFC 5869\\. The\n     * given `ikm`, `salt` and `info` are used with the `digest` to derive a key of `keylen` bytes.\n     *\n     * The successfully generated `derivedKey` will be returned as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n     *\n     * An error will be thrown if any of the input arguments specify invalid values or\n     * types, or if the derived key cannot be generated.\n     *\n     * ```js\n     * import { Buffer } from 'node:buffer';\n     * const {\n     *   hkdfSync,\n     * } = await import('node:crypto');\n     *\n     * const derivedKey = hkdfSync('sha512', 'key', 'salt', 'info', 64);\n     * console.log(Buffer.from(derivedKey).toString('hex'));  // '24156e2...5391653'\n     * ```\n     * @since v15.0.0\n     * @param digest The digest algorithm to use.\n     * @param ikm The input keying material. Must be provided but can be zero-length.\n     * @param salt The salt value. Must be provided but can be zero-length.\n     * @param info Additional info value. Must be provided but can be zero-length, and cannot be more than 1024 bytes.\n     * @param keylen The length of the key to generate. Must be greater than 0. The maximum allowable value is `255` times the number of bytes produced by the selected digest function (e.g. `sha512`\n     * generates 64-byte hashes, making the maximum HKDF output 16320 bytes).\n     */\n    function hkdfSync(\n        digest: string,\n        ikm: BinaryLike | KeyObject,\n        salt: BinaryLike,\n        info: BinaryLike,\n        keylen: number,\n    ): ArrayBuffer;\n    interface SecureHeapUsage {\n        /**\n         * The total allocated secure heap size as specified using the `--secure-heap=n` command-line flag.\n         */\n        total: number;\n        /**\n         * The minimum allocation from the secure heap as specified using the `--secure-heap-min` command-line flag.\n         */\n        min: number;\n        /**\n         * The total number of bytes currently allocated from the secure heap.\n         */\n        used: number;\n        /**\n         * The calculated ratio of `used` to `total` allocated bytes.\n         */\n        utilization: number;\n    }\n    /**\n     * @since v15.6.0\n     */\n    function secureHeapUsed(): SecureHeapUsage;\n    interface RandomUUIDOptions {\n        /**\n         * By default, to improve performance,\n         * Node.js will pre-emptively generate and persistently cache enough\n         * random data to generate up to 128 random UUIDs. To generate a UUID\n         * without using the cache, set `disableEntropyCache` to `true`.\n         *\n         * @default `false`\n         */\n        disableEntropyCache?: boolean | undefined;\n    }\n    type UUID = `${string}-${string}-${string}-${string}-${string}`;\n    /**\n     * Generates a random [RFC 4122](https://www.rfc-editor.org/rfc/rfc4122.txt) version 4 UUID. The UUID is generated using a\n     * cryptographic pseudorandom number generator.\n     * @since v15.6.0, v14.17.0\n     */\n    function randomUUID(options?: RandomUUIDOptions): UUID;\n    interface X509CheckOptions {\n        /**\n         * @default 'always'\n         */\n        subject?: \"always\" | \"default\" | \"never\";\n        /**\n         * @default true\n         */\n        wildcards?: boolean;\n        /**\n         * @default true\n         */\n        partialWildcards?: boolean;\n        /**\n         * @default false\n         */\n        multiLabelWildcards?: boolean;\n        /**\n         * @default false\n         */\n        singleLabelSubdomains?: boolean;\n    }\n    /**\n     * Encapsulates an X509 certificate and provides read-only access to\n     * its information.\n     *\n     * ```js\n     * const { X509Certificate } = await import('node:crypto');\n     *\n     * const x509 = new X509Certificate('{... pem encoded cert ...}');\n     *\n     * console.log(x509.subject);\n     * ```\n     * @since v15.6.0\n     */\n    class X509Certificate {\n        /**\n         * Will be \\`true\\` if this is a Certificate Authority (CA) certificate.\n         * @since v15.6.0\n         */\n        readonly ca: boolean;\n        /**\n         * The SHA-1 fingerprint of this certificate.\n         *\n         * Because SHA-1 is cryptographically broken and because the security of SHA-1 is\n         * significantly worse than that of algorithms that are commonly used to sign\n         * certificates, consider using `x509.fingerprint256` instead.\n         * @since v15.6.0\n         */\n        readonly fingerprint: string;\n        /**\n         * The SHA-256 fingerprint of this certificate.\n         * @since v15.6.0\n         */\n        readonly fingerprint256: string;\n        /**\n         * The SHA-512 fingerprint of this certificate.\n         *\n         * Because computing the SHA-256 fingerprint is usually faster and because it is\n         * only half the size of the SHA-512 fingerprint, `x509.fingerprint256` may be\n         * a better choice. While SHA-512 presumably provides a higher level of security in\n         * general, the security of SHA-256 matches that of most algorithms that are\n         * commonly used to sign certificates.\n         * @since v17.2.0, v16.14.0\n         */\n        readonly fingerprint512: string;\n        /**\n         * The complete subject of this certificate.\n         * @since v15.6.0\n         */\n        readonly subject: string;\n        /**\n         * The subject alternative name specified for this certificate.\n         *\n         * This is a comma-separated list of subject alternative names. Each entry begins\n         * with a string identifying the kind of the subject alternative name followed by\n         * a colon and the value associated with the entry.\n         *\n         * Earlier versions of Node.js incorrectly assumed that it is safe to split this\n         * property at the two-character sequence `', '` (see [CVE-2021-44532](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44532)). However,\n         * both malicious and legitimate certificates can contain subject alternative names\n         * that include this sequence when represented as a string.\n         *\n         * After the prefix denoting the type of the entry, the remainder of each entry\n         * might be enclosed in quotes to indicate that the value is a JSON string literal.\n         * For backward compatibility, Node.js only uses JSON string literals within this\n         * property when necessary to avoid ambiguity. Third-party code should be prepared\n         * to handle both possible entry formats.\n         * @since v15.6.0\n         */\n        readonly subjectAltName: string | undefined;\n        /**\n         * A textual representation of the certificate's authority information access\n         * extension.\n         *\n         * This is a line feed separated list of access descriptions. Each line begins with\n         * the access method and the kind of the access location, followed by a colon and\n         * the value associated with the access location.\n         *\n         * After the prefix denoting the access method and the kind of the access location,\n         * the remainder of each line might be enclosed in quotes to indicate that the\n         * value is a JSON string literal. For backward compatibility, Node.js only uses\n         * JSON string literals within this property when necessary to avoid ambiguity.\n         * Third-party code should be prepared to handle both possible entry formats.\n         * @since v15.6.0\n         */\n        readonly infoAccess: string | undefined;\n        /**\n         * An array detailing the key usages for this certificate.\n         * @since v15.6.0\n         */\n        readonly keyUsage: string[];\n        /**\n         * The issuer identification included in this certificate.\n         * @since v15.6.0\n         */\n        readonly issuer: string;\n        /**\n         * The issuer certificate or `undefined` if the issuer certificate is not\n         * available.\n         * @since v15.9.0\n         */\n        readonly issuerCertificate?: X509Certificate | undefined;\n        /**\n         * The public key `KeyObject` for this certificate.\n         * @since v15.6.0\n         */\n        readonly publicKey: KeyObject;\n        /**\n         * A `Buffer` containing the DER encoding of this certificate.\n         * @since v15.6.0\n         */\n        readonly raw: Buffer;\n        /**\n         * The serial number of this certificate.\n         *\n         * Serial numbers are assigned by certificate authorities and do not uniquely\n         * identify certificates. Consider using `x509.fingerprint256` as a unique\n         * identifier instead.\n         * @since v15.6.0\n         */\n        readonly serialNumber: string;\n        /**\n         * The date/time from which this certificate is considered valid.\n         * @since v15.6.0\n         */\n        readonly validFrom: string;\n        /**\n         * The date/time from which this certificate is valid, encapsulated in a `Date` object.\n         * @since v22.10.0\n         */\n        readonly validFromDate: Date;\n        /**\n         * The date/time until which this certificate is considered valid.\n         * @since v15.6.0\n         */\n        readonly validTo: string;\n        /**\n         * The date/time until which this certificate is valid, encapsulated in a `Date` object.\n         * @since v22.10.0\n         */\n        readonly validToDate: Date;\n        constructor(buffer: BinaryLike);\n        /**\n         * Checks whether the certificate matches the given email address.\n         *\n         * If the `'subject'` option is undefined or set to `'default'`, the certificate\n         * subject is only considered if the subject alternative name extension either does\n         * not exist or does not contain any email addresses.\n         *\n         * If the `'subject'` option is set to `'always'` and if the subject alternative\n         * name extension either does not exist or does not contain a matching email\n         * address, the certificate subject is considered.\n         *\n         * If the `'subject'` option is set to `'never'`, the certificate subject is never\n         * considered, even if the certificate contains no subject alternative names.\n         * @since v15.6.0\n         * @return Returns `email` if the certificate matches, `undefined` if it does not.\n         */\n        checkEmail(email: string, options?: Pick<X509CheckOptions, \"subject\">): string | undefined;\n        /**\n         * Checks whether the certificate matches the given host name.\n         *\n         * If the certificate matches the given host name, the matching subject name is\n         * returned. The returned name might be an exact match (e.g., `foo.example.com`)\n         * or it might contain wildcards (e.g., `*.example.com`). Because host name\n         * comparisons are case-insensitive, the returned subject name might also differ\n         * from the given `name` in capitalization.\n         *\n         * If the `'subject'` option is undefined or set to `'default'`, the certificate\n         * subject is only considered if the subject alternative name extension either does\n         * not exist or does not contain any DNS names. This behavior is consistent with [RFC 2818](https://www.rfc-editor.org/rfc/rfc2818.txt) (\"HTTP Over TLS\").\n         *\n         * If the `'subject'` option is set to `'always'` and if the subject alternative\n         * name extension either does not exist or does not contain a matching DNS name,\n         * the certificate subject is considered.\n         *\n         * If the `'subject'` option is set to `'never'`, the certificate subject is never\n         * considered, even if the certificate contains no subject alternative names.\n         * @since v15.6.0\n         * @return Returns a subject name that matches `name`, or `undefined` if no subject name matches `name`.\n         */\n        checkHost(name: string, options?: X509CheckOptions): string | undefined;\n        /**\n         * Checks whether the certificate matches the given IP address (IPv4 or IPv6).\n         *\n         * Only [RFC 5280](https://www.rfc-editor.org/rfc/rfc5280.txt) `iPAddress` subject alternative names are considered, and they\n         * must match the given `ip` address exactly. Other subject alternative names as\n         * well as the subject field of the certificate are ignored.\n         * @since v15.6.0\n         * @return Returns `ip` if the certificate matches, `undefined` if it does not.\n         */\n        checkIP(ip: string): string | undefined;\n        /**\n         * Checks whether this certificate was issued by the given `otherCert`.\n         * @since v15.6.0\n         */\n        checkIssued(otherCert: X509Certificate): boolean;\n        /**\n         * Checks whether the public key for this certificate is consistent with\n         * the given private key.\n         * @since v15.6.0\n         * @param privateKey A private key.\n         */\n        checkPrivateKey(privateKey: KeyObject): boolean;\n        /**\n         * There is no standard JSON encoding for X509 certificates. The`toJSON()` method returns a string containing the PEM encoded\n         * certificate.\n         * @since v15.6.0\n         */\n        toJSON(): string;\n        /**\n         * Returns information about this certificate using the legacy `certificate object` encoding.\n         * @since v15.6.0\n         */\n        toLegacyObject(): PeerCertificate;\n        /**\n         * Returns the PEM-encoded certificate.\n         * @since v15.6.0\n         */\n        toString(): string;\n        /**\n         * Verifies that this certificate was signed by the given public key.\n         * Does not perform any other validation checks on the certificate.\n         * @since v15.6.0\n         * @param publicKey A public key.\n         */\n        verify(publicKey: KeyObject): boolean;\n    }\n    type LargeNumberLike = NodeJS.ArrayBufferView | SharedArrayBuffer | ArrayBuffer | bigint;\n    interface GeneratePrimeOptions {\n        add?: LargeNumberLike | undefined;\n        rem?: LargeNumberLike | undefined;\n        /**\n         * @default false\n         */\n        safe?: boolean | undefined;\n        bigint?: boolean | undefined;\n    }\n    interface GeneratePrimeOptionsBigInt extends GeneratePrimeOptions {\n        bigint: true;\n    }\n    interface GeneratePrimeOptionsArrayBuffer extends GeneratePrimeOptions {\n        bigint?: false | undefined;\n    }\n    /**\n     * Generates a pseudorandom prime of `size` bits.\n     *\n     * If `options.safe` is `true`, the prime will be a safe prime -- that is, `(prime - 1) / 2` will also be a prime.\n     *\n     * The `options.add` and `options.rem` parameters can be used to enforce additional\n     * requirements, e.g., for Diffie-Hellman:\n     *\n     * * If `options.add` and `options.rem` are both set, the prime will satisfy the\n     * condition that `prime % add = rem`.\n     * * If only `options.add` is set and `options.safe` is not `true`, the prime will\n     * satisfy the condition that `prime % add = 1`.\n     * * If only `options.add` is set and `options.safe` is set to `true`, the prime\n     * will instead satisfy the condition that `prime % add = 3`. This is necessary\n     * because `prime % add = 1` for `options.add > 2` would contradict the condition\n     * enforced by `options.safe`.\n     * * `options.rem` is ignored if `options.add` is not given.\n     *\n     * Both `options.add` and `options.rem` must be encoded as big-endian sequences\n     * if given as an `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, or `DataView`.\n     *\n     * By default, the prime is encoded as a big-endian sequence of octets\n     * in an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). If the `bigint` option is `true`, then a\n     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) is provided.\n     * @since v15.8.0\n     * @param size The size (in bits) of the prime to generate.\n     */\n    function generatePrime(size: number, callback: (err: Error | null, prime: ArrayBuffer) => void): void;\n    function generatePrime(\n        size: number,\n        options: GeneratePrimeOptionsBigInt,\n        callback: (err: Error | null, prime: bigint) => void,\n    ): void;\n    function generatePrime(\n        size: number,\n        options: GeneratePrimeOptionsArrayBuffer,\n        callback: (err: Error | null, prime: ArrayBuffer) => void,\n    ): void;\n    function generatePrime(\n        size: number,\n        options: GeneratePrimeOptions,\n        callback: (err: Error | null, prime: ArrayBuffer | bigint) => void,\n    ): void;\n    /**\n     * Generates a pseudorandom prime of `size` bits.\n     *\n     * If `options.safe` is `true`, the prime will be a safe prime -- that is, `(prime - 1) / 2` will also be a prime.\n     *\n     * The `options.add` and `options.rem` parameters can be used to enforce additional\n     * requirements, e.g., for Diffie-Hellman:\n     *\n     * * If `options.add` and `options.rem` are both set, the prime will satisfy the\n     * condition that `prime % add = rem`.\n     * * If only `options.add` is set and `options.safe` is not `true`, the prime will\n     * satisfy the condition that `prime % add = 1`.\n     * * If only `options.add` is set and `options.safe` is set to `true`, the prime\n     * will instead satisfy the condition that `prime % add = 3`. This is necessary\n     * because `prime % add = 1` for `options.add > 2` would contradict the condition\n     * enforced by `options.safe`.\n     * * `options.rem` is ignored if `options.add` is not given.\n     *\n     * Both `options.add` and `options.rem` must be encoded as big-endian sequences\n     * if given as an `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, or `DataView`.\n     *\n     * By default, the prime is encoded as a big-endian sequence of octets\n     * in an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). If the `bigint` option is `true`, then a\n     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) is provided.\n     * @since v15.8.0\n     * @param size The size (in bits) of the prime to generate.\n     */\n    function generatePrimeSync(size: number): ArrayBuffer;\n    function generatePrimeSync(size: number, options: GeneratePrimeOptionsBigInt): bigint;\n    function generatePrimeSync(size: number, options: GeneratePrimeOptionsArrayBuffer): ArrayBuffer;\n    function generatePrimeSync(size: number, options: GeneratePrimeOptions): ArrayBuffer | bigint;\n    interface CheckPrimeOptions {\n        /**\n         * The number of Miller-Rabin probabilistic primality iterations to perform.\n         * When the value is 0 (zero), a number of checks is used that yields a false positive rate of at most `2**-64` for random input.\n         * Care must be used when selecting a number of checks.\n         * Refer to the OpenSSL documentation for the BN_is_prime_ex function nchecks options for more details.\n         *\n         * @default 0\n         */\n        checks?: number | undefined;\n    }\n    /**\n     * Checks the primality of the `candidate`.\n     * @since v15.8.0\n     * @param candidate A possible prime encoded as a sequence of big endian octets of arbitrary length.\n     */\n    function checkPrime(value: LargeNumberLike, callback: (err: Error | null, result: boolean) => void): void;\n    function checkPrime(\n        value: LargeNumberLike,\n        options: CheckPrimeOptions,\n        callback: (err: Error | null, result: boolean) => void,\n    ): void;\n    /**\n     * Checks the primality of the `candidate`.\n     * @since v15.8.0\n     * @param candidate A possible prime encoded as a sequence of big endian octets of arbitrary length.\n     * @return `true` if the candidate is a prime with an error probability less than `0.25 ** options.checks`.\n     */\n    function checkPrimeSync(candidate: LargeNumberLike, options?: CheckPrimeOptions): boolean;\n    /**\n     * Load and set the `engine` for some or all OpenSSL functions (selected by flags).\n     *\n     * `engine` could be either an id or a path to the engine's shared library.\n     *\n     * The optional `flags` argument uses `ENGINE_METHOD_ALL` by default. The `flags` is a bit field taking one of or a mix of the following flags (defined in `crypto.constants`):\n     *\n     * * `crypto.constants.ENGINE_METHOD_RSA`\n     * * `crypto.constants.ENGINE_METHOD_DSA`\n     * * `crypto.constants.ENGINE_METHOD_DH`\n     * * `crypto.constants.ENGINE_METHOD_RAND`\n     * * `crypto.constants.ENGINE_METHOD_EC`\n     * * `crypto.constants.ENGINE_METHOD_CIPHERS`\n     * * `crypto.constants.ENGINE_METHOD_DIGESTS`\n     * * `crypto.constants.ENGINE_METHOD_PKEY_METHS`\n     * * `crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS`\n     * * `crypto.constants.ENGINE_METHOD_ALL`\n     * * `crypto.constants.ENGINE_METHOD_NONE`\n     * @since v0.11.11\n     * @param flags\n     */\n    function setEngine(engine: string, flags?: number): void;\n    /**\n     * A convenient alias for {@link webcrypto.getRandomValues}. This\n     * implementation is not compliant with the Web Crypto spec, to write\n     * web-compatible code use {@link webcrypto.getRandomValues} instead.\n     * @since v17.4.0\n     * @return Returns `typedArray`.\n     */\n    function getRandomValues<T extends webcrypto.BufferSource>(typedArray: T): T;\n    /**\n     * A convenient alias for `crypto.webcrypto.subtle`.\n     * @since v17.4.0\n     */\n    const subtle: webcrypto.SubtleCrypto;\n    /**\n     * An implementation of the Web Crypto API standard.\n     *\n     * See the {@link https://nodejs.org/docs/latest/api/webcrypto.html Web Crypto API documentation} for details.\n     * @since v15.0.0\n     */\n    const webcrypto: webcrypto.Crypto;\n    namespace webcrypto {\n        type BufferSource = ArrayBufferView | ArrayBuffer;\n        type KeyFormat = \"jwk\" | \"pkcs8\" | \"raw\" | \"spki\";\n        type KeyType = \"private\" | \"public\" | \"secret\";\n        type KeyUsage =\n            | \"decrypt\"\n            | \"deriveBits\"\n            | \"deriveKey\"\n            | \"encrypt\"\n            | \"sign\"\n            | \"unwrapKey\"\n            | \"verify\"\n            | \"wrapKey\";\n        type AlgorithmIdentifier = Algorithm | string;\n        type HashAlgorithmIdentifier = AlgorithmIdentifier;\n        type NamedCurve = string;\n        type BigInteger = Uint8Array;\n        interface AesCbcParams extends Algorithm {\n            iv: BufferSource;\n        }\n        interface AesCtrParams extends Algorithm {\n            counter: BufferSource;\n            length: number;\n        }\n        interface AesDerivedKeyParams extends Algorithm {\n            length: number;\n        }\n        interface AesGcmParams extends Algorithm {\n            additionalData?: BufferSource;\n            iv: BufferSource;\n            tagLength?: number;\n        }\n        interface AesKeyAlgorithm extends KeyAlgorithm {\n            length: number;\n        }\n        interface AesKeyGenParams extends Algorithm {\n            length: number;\n        }\n        interface Algorithm {\n            name: string;\n        }\n        interface EcKeyAlgorithm extends KeyAlgorithm {\n            namedCurve: NamedCurve;\n        }\n        interface EcKeyGenParams extends Algorithm {\n            namedCurve: NamedCurve;\n        }\n        interface EcKeyImportParams extends Algorithm {\n            namedCurve: NamedCurve;\n        }\n        interface EcdhKeyDeriveParams extends Algorithm {\n            public: CryptoKey;\n        }\n        interface EcdsaParams extends Algorithm {\n            hash: HashAlgorithmIdentifier;\n        }\n        interface Ed448Params extends Algorithm {\n            context?: BufferSource;\n        }\n        interface HkdfParams extends Algorithm {\n            hash: HashAlgorithmIdentifier;\n            info: BufferSource;\n            salt: BufferSource;\n        }\n        interface HmacImportParams extends Algorithm {\n            hash: HashAlgorithmIdentifier;\n            length?: number;\n        }\n        interface HmacKeyAlgorithm extends KeyAlgorithm {\n            hash: KeyAlgorithm;\n            length: number;\n        }\n        interface HmacKeyGenParams extends Algorithm {\n            hash: HashAlgorithmIdentifier;\n            length?: number;\n        }\n        interface JsonWebKey {\n            alg?: string;\n            crv?: string;\n            d?: string;\n            dp?: string;\n            dq?: string;\n            e?: string;\n            ext?: boolean;\n            k?: string;\n            key_ops?: string[];\n            kty?: string;\n            n?: string;\n            oth?: RsaOtherPrimesInfo[];\n            p?: string;\n            q?: string;\n            qi?: string;\n            use?: string;\n            x?: string;\n            y?: string;\n        }\n        interface KeyAlgorithm {\n            name: string;\n        }\n        interface Pbkdf2Params extends Algorithm {\n            hash: HashAlgorithmIdentifier;\n            iterations: number;\n            salt: BufferSource;\n        }\n        interface RsaHashedImportParams extends Algorithm {\n            hash: HashAlgorithmIdentifier;\n        }\n        interface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {\n            hash: KeyAlgorithm;\n        }\n        interface RsaHashedKeyGenParams extends RsaKeyGenParams {\n            hash: HashAlgorithmIdentifier;\n        }\n        interface RsaKeyAlgorithm extends KeyAlgorithm {\n            modulusLength: number;\n            publicExponent: BigInteger;\n        }\n        interface RsaKeyGenParams extends Algorithm {\n            modulusLength: number;\n            publicExponent: BigInteger;\n        }\n        interface RsaOaepParams extends Algorithm {\n            label?: BufferSource;\n        }\n        interface RsaOtherPrimesInfo {\n            d?: string;\n            r?: string;\n            t?: string;\n        }\n        interface RsaPssParams extends Algorithm {\n            saltLength: number;\n        }\n        /**\n         * Importing the `webcrypto` object (`import { webcrypto } from 'node:crypto'`) gives an instance of the `Crypto` class.\n         * `Crypto` is a singleton that provides access to the remainder of the crypto API.\n         * @since v15.0.0\n         */\n        interface Crypto {\n            /**\n             * Provides access to the `SubtleCrypto` API.\n             * @since v15.0.0\n             */\n            readonly subtle: SubtleCrypto;\n            /**\n             * Generates cryptographically strong random values.\n             * The given `typedArray` is filled with random values, and a reference to `typedArray` is returned.\n             *\n             * The given `typedArray` must be an integer-based instance of {@link NodeJS.TypedArray}, i.e. `Float32Array` and `Float64Array` are not accepted.\n             *\n             * An error will be thrown if the given `typedArray` is larger than 65,536 bytes.\n             * @since v15.0.0\n             */\n            getRandomValues<T extends Exclude<NodeJS.TypedArray, Float32Array | Float64Array>>(typedArray: T): T;\n            /**\n             * Generates a random {@link https://www.rfc-editor.org/rfc/rfc4122.txt RFC 4122} version 4 UUID.\n             * The UUID is generated using a cryptographic pseudorandom number generator.\n             * @since v16.7.0\n             */\n            randomUUID(): UUID;\n            CryptoKey: CryptoKeyConstructor;\n        }\n        // This constructor throws ILLEGAL_CONSTRUCTOR so it should not be newable.\n        interface CryptoKeyConstructor {\n            /** Illegal constructor */\n            (_: { readonly _: unique symbol }): never; // Allows instanceof to work but not be callable by the user.\n            readonly length: 0;\n            readonly name: \"CryptoKey\";\n            readonly prototype: CryptoKey;\n        }\n        /**\n         * @since v15.0.0\n         */\n        interface CryptoKey {\n            /**\n             * An object detailing the algorithm for which the key can be used along with additional algorithm-specific parameters.\n             * @since v15.0.0\n             */\n            readonly algorithm: KeyAlgorithm;\n            /**\n             * When `true`, the {@link CryptoKey} can be extracted using either `subtleCrypto.exportKey()` or `subtleCrypto.wrapKey()`.\n             * @since v15.0.0\n             */\n            readonly extractable: boolean;\n            /**\n             * A string identifying whether the key is a symmetric (`'secret'`) or asymmetric (`'private'` or `'public'`) key.\n             * @since v15.0.0\n             */\n            readonly type: KeyType;\n            /**\n             * An array of strings identifying the operations for which the key may be used.\n             *\n             * The possible usages are:\n             * - `'encrypt'` - The key may be used to encrypt data.\n             * - `'decrypt'` - The key may be used to decrypt data.\n             * - `'sign'` - The key may be used to generate digital signatures.\n             * - `'verify'` - The key may be used to verify digital signatures.\n             * - `'deriveKey'` - The key may be used to derive a new key.\n             * - `'deriveBits'` - The key may be used to derive bits.\n             * - `'wrapKey'` - The key may be used to wrap another key.\n             * - `'unwrapKey'` - The key may be used to unwrap another key.\n             *\n             * Valid key usages depend on the key algorithm (identified by `cryptokey.algorithm.name`).\n             * @since v15.0.0\n             */\n            readonly usages: KeyUsage[];\n        }\n        /**\n         * The `CryptoKeyPair` is a simple dictionary object with `publicKey` and `privateKey` properties, representing an asymmetric key pair.\n         * @since v15.0.0\n         */\n        interface CryptoKeyPair {\n            /**\n             * A {@link CryptoKey} whose type will be `'private'`.\n             * @since v15.0.0\n             */\n            privateKey: CryptoKey;\n            /**\n             * A {@link CryptoKey} whose type will be `'public'`.\n             * @since v15.0.0\n             */\n            publicKey: CryptoKey;\n        }\n        /**\n         * @since v15.0.0\n         */\n        interface SubtleCrypto {\n            /**\n             * Using the method and parameters specified in `algorithm` and the keying material provided by `key`,\n             * `subtle.decrypt()` attempts to decipher the provided `data`. If successful,\n             * the returned promise will be resolved with an `<ArrayBuffer>` containing the plaintext result.\n             *\n             * The algorithms currently supported include:\n             *\n             * - `'RSA-OAEP'`\n             * - `'AES-CTR'`\n             * - `'AES-CBC'`\n             * - `'AES-GCM'`\n             * @since v15.0.0\n             */\n            decrypt(\n                algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,\n                key: CryptoKey,\n                data: BufferSource,\n            ): Promise<ArrayBuffer>;\n            /**\n             * Using the method and parameters specified in `algorithm` and the keying material provided by `baseKey`,\n             * `subtle.deriveBits()` attempts to generate `length` bits.\n             * The Node.js implementation requires that when `length` is a number it must be multiple of `8`.\n             * When `length` is `null` the maximum number of bits for a given algorithm is generated. This is allowed\n             * for the `'ECDH'`, `'X25519'`, and `'X448'` algorithms.\n             * If successful, the returned promise will be resolved with an `<ArrayBuffer>` containing the generated data.\n             *\n             * The algorithms currently supported include:\n             *\n             * - `'ECDH'`\n             * - `'X25519'`\n             * - `'X448'`\n             * - `'HKDF'`\n             * - `'PBKDF2'`\n             * @since v15.0.0\n             */\n            deriveBits(\n                algorithm: EcdhKeyDeriveParams,\n                baseKey: CryptoKey,\n                length?: number | null,\n            ): Promise<ArrayBuffer>;\n            deriveBits(\n                algorithm: EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params,\n                baseKey: CryptoKey,\n                length: number,\n            ): Promise<ArrayBuffer>;\n            /**\n             * Using the method and parameters specified in `algorithm`, and the keying material provided by `baseKey`,\n             * `subtle.deriveKey()` attempts to generate a new <CryptoKey>` based on the method and parameters in `derivedKeyAlgorithm`.\n             *\n             * Calling `subtle.deriveKey()` is equivalent to calling `subtle.deriveBits()` to generate raw keying material,\n             * then passing the result into the `subtle.importKey()` method using the `deriveKeyAlgorithm`, `extractable`, and `keyUsages` parameters as input.\n             *\n             * The algorithms currently supported include:\n             *\n             * - `'ECDH'`\n             * - `'X25519'`\n             * - `'X448'`\n             * - `'HKDF'`\n             * - `'PBKDF2'`\n             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.\n             * @since v15.0.0\n             */\n            deriveKey(\n                algorithm: EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params,\n                baseKey: CryptoKey,\n                derivedKeyAlgorithm: AlgorithmIdentifier | HmacImportParams | AesDerivedKeyParams,\n                extractable: boolean,\n                keyUsages: readonly KeyUsage[],\n            ): Promise<CryptoKey>;\n            /**\n             * Using the method identified by `algorithm`, `subtle.digest()` attempts to generate a digest of `data`.\n             * If successful, the returned promise is resolved with an `<ArrayBuffer>` containing the computed digest.\n             *\n             * If `algorithm` is provided as a `<string>`, it must be one of:\n             *\n             * - `'SHA-1'`\n             * - `'SHA-256'`\n             * - `'SHA-384'`\n             * - `'SHA-512'`\n             *\n             * If `algorithm` is provided as an `<Object>`, it must have a `name` property whose value is one of the above.\n             * @since v15.0.0\n             */\n            digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>;\n            /**\n             * Using the method and parameters specified by `algorithm` and the keying material provided by `key`,\n             * `subtle.encrypt()` attempts to encipher `data`. If successful,\n             * the returned promise is resolved with an `<ArrayBuffer>` containing the encrypted result.\n             *\n             * The algorithms currently supported include:\n             *\n             * - `'RSA-OAEP'`\n             * - `'AES-CTR'`\n             * - `'AES-CBC'`\n             * - `'AES-GCM'`\n             * @since v15.0.0\n             */\n            encrypt(\n                algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,\n                key: CryptoKey,\n                data: BufferSource,\n            ): Promise<ArrayBuffer>;\n            /**\n             * Exports the given key into the specified format, if supported.\n             *\n             * If the `<CryptoKey>` is not extractable, the returned promise will reject.\n             *\n             * When `format` is either `'pkcs8'` or `'spki'` and the export is successful,\n             * the returned promise will be resolved with an `<ArrayBuffer>` containing the exported key data.\n             *\n             * When `format` is `'jwk'` and the export is successful, the returned promise will be resolved with a\n             * JavaScript object conforming to the {@link https://tools.ietf.org/html/rfc7517 JSON Web Key} specification.\n             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.\n             * @returns `<Promise>` containing `<ArrayBuffer>`.\n             * @since v15.0.0\n             */\n            exportKey(format: \"jwk\", key: CryptoKey): Promise<JsonWebKey>;\n            exportKey(format: Exclude<KeyFormat, \"jwk\">, key: CryptoKey): Promise<ArrayBuffer>;\n            /**\n             * Using the method and parameters provided in `algorithm`,\n             * `subtle.generateKey()` attempts to generate new keying material.\n             * Depending the method used, the method may generate either a single `<CryptoKey>` or a `<CryptoKeyPair>`.\n             *\n             * The `<CryptoKeyPair>` (public and private key) generating algorithms supported include:\n             *\n             * - `'RSASSA-PKCS1-v1_5'`\n             * - `'RSA-PSS'`\n             * - `'RSA-OAEP'`\n             * - `'ECDSA'`\n             * - `'Ed25519'`\n             * - `'Ed448'`\n             * - `'ECDH'`\n             * - `'X25519'`\n             * - `'X448'`\n             * The `<CryptoKey>` (secret key) generating algorithms supported include:\n             *\n             * - `'HMAC'`\n             * - `'AES-CTR'`\n             * - `'AES-CBC'`\n             * - `'AES-GCM'`\n             * - `'AES-KW'`\n             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.\n             * @since v15.0.0\n             */\n            generateKey(\n                algorithm: RsaHashedKeyGenParams | EcKeyGenParams,\n                extractable: boolean,\n                keyUsages: readonly KeyUsage[],\n            ): Promise<CryptoKeyPair>;\n            generateKey(\n                algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params,\n                extractable: boolean,\n                keyUsages: readonly KeyUsage[],\n            ): Promise<CryptoKey>;\n            generateKey(\n                algorithm: AlgorithmIdentifier,\n                extractable: boolean,\n                keyUsages: KeyUsage[],\n            ): Promise<CryptoKeyPair | CryptoKey>;\n            /**\n             * The `subtle.importKey()` method attempts to interpret the provided `keyData` as the given `format`\n             * to create a `<CryptoKey>` instance using the provided `algorithm`, `extractable`, and `keyUsages` arguments.\n             * If the import is successful, the returned promise will be resolved with the created `<CryptoKey>`.\n             *\n             * If importing a `'PBKDF2'` key, `extractable` must be `false`.\n             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.\n             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.\n             * @since v15.0.0\n             */\n            importKey(\n                format: \"jwk\",\n                keyData: JsonWebKey,\n                algorithm:\n                    | AlgorithmIdentifier\n                    | RsaHashedImportParams\n                    | EcKeyImportParams\n                    | HmacImportParams\n                    | AesKeyAlgorithm,\n                extractable: boolean,\n                keyUsages: readonly KeyUsage[],\n            ): Promise<CryptoKey>;\n            importKey(\n                format: Exclude<KeyFormat, \"jwk\">,\n                keyData: BufferSource,\n                algorithm:\n                    | AlgorithmIdentifier\n                    | RsaHashedImportParams\n                    | EcKeyImportParams\n                    | HmacImportParams\n                    | AesKeyAlgorithm,\n                extractable: boolean,\n                keyUsages: KeyUsage[],\n            ): Promise<CryptoKey>;\n            /**\n             * Using the method and parameters given by `algorithm` and the keying material provided by `key`,\n             * `subtle.sign()` attempts to generate a cryptographic signature of `data`. If successful,\n             * the returned promise is resolved with an `<ArrayBuffer>` containing the generated signature.\n             *\n             * The algorithms currently supported include:\n             *\n             * - `'RSASSA-PKCS1-v1_5'`\n             * - `'RSA-PSS'`\n             * - `'ECDSA'`\n             * - `'Ed25519'`\n             * - `'Ed448'`\n             * - `'HMAC'`\n             * @since v15.0.0\n             */\n            sign(\n                algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams | Ed448Params,\n                key: CryptoKey,\n                data: BufferSource,\n            ): Promise<ArrayBuffer>;\n            /**\n             * In cryptography, \"wrapping a key\" refers to exporting and then encrypting the keying material.\n             * The `subtle.unwrapKey()` method attempts to decrypt a wrapped key and create a `<CryptoKey>` instance.\n             * It is equivalent to calling `subtle.decrypt()` first on the encrypted key data (using the `wrappedKey`, `unwrapAlgo`, and `unwrappingKey` arguments as input)\n             * then passing the results in to the `subtle.importKey()` method using the `unwrappedKeyAlgo`, `extractable`, and `keyUsages` arguments as inputs.\n             * If successful, the returned promise is resolved with a `<CryptoKey>` object.\n             *\n             * The wrapping algorithms currently supported include:\n             *\n             * - `'RSA-OAEP'`\n             * - `'AES-CTR'`\n             * - `'AES-CBC'`\n             * - `'AES-GCM'`\n             * - `'AES-KW'`\n             *\n             * The unwrapped key algorithms supported include:\n             *\n             * - `'RSASSA-PKCS1-v1_5'`\n             * - `'RSA-PSS'`\n             * - `'RSA-OAEP'`\n             * - `'ECDSA'`\n             * - `'Ed25519'`\n             * - `'Ed448'`\n             * - `'ECDH'`\n             * - `'X25519'`\n             * - `'X448'`\n             * - `'HMAC'`\n             * - `'AES-CTR'`\n             * - `'AES-CBC'`\n             * - `'AES-GCM'`\n             * - `'AES-KW'`\n             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.\n             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.\n             * @since v15.0.0\n             */\n            unwrapKey(\n                format: KeyFormat,\n                wrappedKey: BufferSource,\n                unwrappingKey: CryptoKey,\n                unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,\n                unwrappedKeyAlgorithm:\n                    | AlgorithmIdentifier\n                    | RsaHashedImportParams\n                    | EcKeyImportParams\n                    | HmacImportParams\n                    | AesKeyAlgorithm,\n                extractable: boolean,\n                keyUsages: KeyUsage[],\n            ): Promise<CryptoKey>;\n            /**\n             * Using the method and parameters given in `algorithm` and the keying material provided by `key`,\n             * `subtle.verify()` attempts to verify that `signature` is a valid cryptographic signature of `data`.\n             * The returned promise is resolved with either `true` or `false`.\n             *\n             * The algorithms currently supported include:\n             *\n             * - `'RSASSA-PKCS1-v1_5'`\n             * - `'RSA-PSS'`\n             * - `'ECDSA'`\n             * - `'Ed25519'`\n             * - `'Ed448'`\n             * - `'HMAC'`\n             * @since v15.0.0\n             */\n            verify(\n                algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams | Ed448Params,\n                key: CryptoKey,\n                signature: BufferSource,\n                data: BufferSource,\n            ): Promise<boolean>;\n            /**\n             * In cryptography, \"wrapping a key\" refers to exporting and then encrypting the keying material.\n             * The `subtle.wrapKey()` method exports the keying material into the format identified by `format`,\n             * then encrypts it using the method and parameters specified by `wrapAlgo` and the keying material provided by `wrappingKey`.\n             * It is the equivalent to calling `subtle.exportKey()` using `format` and `key` as the arguments,\n             * then passing the result to the `subtle.encrypt()` method using `wrappingKey` and `wrapAlgo` as inputs.\n             * If successful, the returned promise will be resolved with an `<ArrayBuffer>` containing the encrypted key data.\n             *\n             * The wrapping algorithms currently supported include:\n             *\n             * - `'RSA-OAEP'`\n             * - `'AES-CTR'`\n             * - `'AES-CBC'`\n             * - `'AES-GCM'`\n             * - `'AES-KW'`\n             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.\n             * @since v15.0.0\n             */\n            wrapKey(\n                format: KeyFormat,\n                key: CryptoKey,\n                wrappingKey: CryptoKey,\n                wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,\n            ): Promise<ArrayBuffer>;\n        }\n    }\n\n    global {\n        var crypto: typeof globalThis extends {\n            crypto: infer T;\n            onmessage: any;\n        } ? T\n            : webcrypto.Crypto;\n    }\n}\ndeclare module \"node:crypto\" {\n    export * from \"crypto\";\n}\n"
        }
    ]
}