{
    "sourceFile": "node_modules/@types/node/cluster.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891954820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * Clusters of Node.js processes can be used to run multiple instances of Node.js\n * that can distribute workloads among their application threads. When process isolation\n * is not needed, use the [`worker_threads`](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html)\n * module instead, which allows running multiple application threads within a single Node.js instance.\n *\n * The cluster module allows easy creation of child processes that all share\n * server ports.\n *\n * ```js\n * import cluster from 'node:cluster';\n * import http from 'node:http';\n * import { availableParallelism } from 'node:os';\n * import process from 'node:process';\n *\n * const numCPUs = availableParallelism();\n *\n * if (cluster.isPrimary) {\n *   console.log(`Primary ${process.pid} is running`);\n *\n *   // Fork workers.\n *   for (let i = 0; i < numCPUs; i++) {\n *     cluster.fork();\n *   }\n *\n *   cluster.on('exit', (worker, code, signal) => {\n *     console.log(`worker ${worker.process.pid} died`);\n *   });\n * } else {\n *   // Workers can share any TCP connection\n *   // In this case it is an HTTP server\n *   http.createServer((req, res) => {\n *     res.writeHead(200);\n *     res.end('hello world\\n');\n *   }).listen(8000);\n *\n *   console.log(`Worker ${process.pid} started`);\n * }\n * ```\n *\n * Running Node.js will now share port 8000 between the workers:\n *\n * ```console\n * $ node server.js\n * Primary 3596 is running\n * Worker 4324 started\n * Worker 4520 started\n * Worker 6056 started\n * Worker 5644 started\n * ```\n *\n * On Windows, it is not yet possible to set up a named pipe server in a worker.\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/cluster.js)\n */\ndeclare module \"cluster\" {\n    import * as child from \"node:child_process\";\n    import EventEmitter = require(\"node:events\");\n    import * as net from \"node:net\";\n    type SerializationType = \"json\" | \"advanced\";\n    export interface ClusterSettings {\n        /**\n         * List of string arguments passed to the Node.js executable.\n         * @default process.execArgv\n         */\n        execArgv?: string[] | undefined;\n        /**\n         * File path to worker file.\n         * @default process.argv[1]\n         */\n        exec?: string | undefined;\n        /**\n         * String arguments passed to worker.\n         * @default process.argv.slice(2)\n         */\n        args?: string[] | undefined;\n        /**\n         * Whether or not to send output to parent's stdio.\n         * @default false\n         */\n        silent?: boolean | undefined;\n        /**\n         * Configures the stdio of forked processes. Because the cluster module relies on IPC to function, this configuration must\n         * contain an `'ipc'` entry. When this option is provided, it overrides `silent`. See [`child_prcess.spawn()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processspawncommand-args-options)'s\n         * [`stdio`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#optionsstdio).\n         */\n        stdio?: any[] | undefined;\n        /**\n         * Sets the user identity of the process. (See [`setuid(2)`](https://man7.org/linux/man-pages/man2/setuid.2.html).)\n         */\n        uid?: number | undefined;\n        /**\n         * Sets the group identity of the process. (See [`setgid(2)`](https://man7.org/linux/man-pages/man2/setgid.2.html).)\n         */\n        gid?: number | undefined;\n        /**\n         * Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number.\n         * By default each worker gets its own port, incremented from the primary's `process.debugPort`.\n         */\n        inspectPort?: number | (() => number) | undefined;\n        /**\n         * Specify the kind of serialization used for sending messages between processes. Possible values are `'json'` and `'advanced'`.\n         * See [Advanced serialization for `child_process`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#advanced-serialization) for more details.\n         * @default false\n         */\n        serialization?: SerializationType | undefined;\n        /**\n         * Current working directory of the worker process.\n         * @default undefined (inherits from parent process)\n         */\n        cwd?: string | undefined;\n        /**\n         * Hide the forked processes console window that would normally be created on Windows systems.\n         * @default false\n         */\n        windowsHide?: boolean | undefined;\n    }\n    export interface Address {\n        address: string;\n        port: number;\n        /**\n         * The `addressType` is one of:\n         *\n         * * `4` (TCPv4)\n         * * `6` (TCPv6)\n         * * `-1` (Unix domain socket)\n         * * `'udp4'` or `'udp6'` (UDPv4 or UDPv6)\n         */\n        addressType: 4 | 6 | -1 | \"udp4\" | \"udp6\";\n    }\n    /**\n     * A `Worker` object contains all public information and method about a worker.\n     * In the primary it can be obtained using `cluster.workers`. In a worker\n     * it can be obtained using `cluster.worker`.\n     * @since v0.7.0\n     */\n    export class Worker extends EventEmitter {\n        /**\n         * Each new worker is given its own unique id, this id is stored in the `id`.\n         *\n         * While a worker is alive, this is the key that indexes it in `cluster.workers`.\n         * @since v0.8.0\n         */\n        id: number;\n        /**\n         * All workers are created using [`child_process.fork()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options), the returned object\n         * from this function is stored as `.process`. In a worker, the global `process` is stored.\n         *\n         * See: [Child Process module](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options).\n         *\n         * Workers will call `process.exit(0)` if the `'disconnect'` event occurs\n         * on `process` and `.exitedAfterDisconnect` is not `true`. This protects against\n         * accidental disconnection.\n         * @since v0.7.0\n         */\n        process: child.ChildProcess;\n        /**\n         * Send a message to a worker or primary, optionally with a handle.\n         *\n         * In the primary, this sends a message to a specific worker. It is identical to [`ChildProcess.send()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#subprocesssendmessage-sendhandle-options-callback).\n         *\n         * In a worker, this sends a message to the primary. It is identical to `process.send()`.\n         *\n         * This example will echo back all messages from the primary:\n         *\n         * ```js\n         * if (cluster.isPrimary) {\n         *   const worker = cluster.fork();\n         *   worker.send('hi there');\n         *\n         * } else if (cluster.isWorker) {\n         *   process.on('message', (msg) => {\n         *     process.send(msg);\n         *   });\n         * }\n         * ```\n         * @since v0.7.0\n         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles.\n         */\n        send(message: child.Serializable, callback?: (error: Error | null) => void): boolean;\n        send(\n            message: child.Serializable,\n            sendHandle: child.SendHandle,\n            callback?: (error: Error | null) => void,\n        ): boolean;\n        send(\n            message: child.Serializable,\n            sendHandle: child.SendHandle,\n            options?: child.MessageOptions,\n            callback?: (error: Error | null) => void,\n        ): boolean;\n        /**\n         * This function will kill the worker. In the primary worker, it does this by\n         * disconnecting the `worker.process`, and once disconnected, killing with `signal`. In the worker, it does it by killing the process with `signal`.\n         *\n         * The `kill()` function kills the worker process without waiting for a graceful\n         * disconnect, it has the same behavior as `worker.process.kill()`.\n         *\n         * This method is aliased as `worker.destroy()` for backwards compatibility.\n         *\n         * In a worker, `process.kill()` exists, but it is not this function;\n         * it is [`kill()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processkillpid-signal).\n         * @since v0.9.12\n         * @param [signal='SIGTERM'] Name of the kill signal to send to the worker process.\n         */\n        kill(signal?: string): void;\n        destroy(signal?: string): void;\n        /**\n         * In a worker, this function will close all servers, wait for the `'close'` event\n         * on those servers, and then disconnect the IPC channel.\n         *\n         * In the primary, an internal message is sent to the worker causing it to call `.disconnect()` on itself.\n         *\n         * Causes `.exitedAfterDisconnect` to be set.\n         *\n         * After a server is closed, it will no longer accept new connections,\n         * but connections may be accepted by any other listening worker. Existing\n         * connections will be allowed to close as usual. When no more connections exist,\n         * see `server.close()`, the IPC channel to the worker will close allowing it\n         * to die gracefully.\n         *\n         * The above applies _only_ to server connections, client connections are not\n         * automatically closed by workers, and disconnect does not wait for them to close\n         * before exiting.\n         *\n         * In a worker, `process.disconnect` exists, but it is not this function;\n         * it is `disconnect()`.\n         *\n         * Because long living server connections may block workers from disconnecting, it\n         * may be useful to send a message, so application specific actions may be taken to\n         * close them. It also may be useful to implement a timeout, killing a worker if\n         * the `'disconnect'` event has not been emitted after some time.\n         *\n         * ```js\n         * import net from 'node:net';\n         *\n         * if (cluster.isPrimary) {\n         *   const worker = cluster.fork();\n         *   let timeout;\n         *\n         *   worker.on('listening', (address) => {\n         *     worker.send('shutdown');\n         *     worker.disconnect();\n         *     timeout = setTimeout(() => {\n         *       worker.kill();\n         *     }, 2000);\n         *   });\n         *\n         *   worker.on('disconnect', () => {\n         *     clearTimeout(timeout);\n         *   });\n         *\n         * } else if (cluster.isWorker) {\n         *   const server = net.createServer((socket) => {\n         *     // Connections never end\n         *   });\n         *\n         *   server.listen(8000);\n         *\n         *   process.on('message', (msg) => {\n         *     if (msg === 'shutdown') {\n         *       // Initiate graceful close of any connections to server\n         *     }\n         *   });\n         * }\n         * ```\n         * @since v0.7.7\n         * @return A reference to `worker`.\n         */\n        disconnect(): void;\n        /**\n         * This function returns `true` if the worker is connected to its primary via its\n         * IPC channel, `false` otherwise. A worker is connected to its primary after it\n         * has been created. It is disconnected after the `'disconnect'` event is emitted.\n         * @since v0.11.14\n         */\n        isConnected(): boolean;\n        /**\n         * This function returns `true` if the worker's process has terminated (either\n         * because of exiting or being signaled). Otherwise, it returns `false`.\n         *\n         * ```js\n         * import cluster from 'node:cluster';\n         * import http from 'node:http';\n         * import { availableParallelism } from 'node:os';\n         * import process from 'node:process';\n         *\n         * const numCPUs = availableParallelism();\n         *\n         * if (cluster.isPrimary) {\n         *   console.log(`Primary ${process.pid} is running`);\n         *\n         *   // Fork workers.\n         *   for (let i = 0; i < numCPUs; i++) {\n         *     cluster.fork();\n         *   }\n         *\n         *   cluster.on('fork', (worker) => {\n         *     console.log('worker is dead:', worker.isDead());\n         *   });\n         *\n         *   cluster.on('exit', (worker, code, signal) => {\n         *     console.log('worker is dead:', worker.isDead());\n         *   });\n         * } else {\n         *   // Workers can share any TCP connection. In this case, it is an HTTP server.\n         *   http.createServer((req, res) => {\n         *     res.writeHead(200);\n         *     res.end(`Current process\\n ${process.pid}`);\n         *     process.kill(process.pid);\n         *   }).listen(8000);\n         * }\n         * ```\n         * @since v0.11.14\n         */\n        isDead(): boolean;\n        /**\n         * This property is `true` if the worker exited due to `.disconnect()`.\n         * If the worker exited any other way, it is `false`. If the\n         * worker has not exited, it is `undefined`.\n         *\n         * The boolean `worker.exitedAfterDisconnect` allows distinguishing between\n         * voluntary and accidental exit, the primary may choose not to respawn a worker\n         * based on this value.\n         *\n         * ```js\n         * cluster.on('exit', (worker, code, signal) => {\n         *   if (worker.exitedAfterDisconnect === true) {\n         *     console.log('Oh, it was just voluntary – no need to worry');\n         *   }\n         * });\n         *\n         * // kill worker\n         * worker.kill();\n         * ```\n         * @since v6.0.0\n         */\n        exitedAfterDisconnect: boolean;\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. error\n         *   3. exit\n         *   4. listening\n         *   5. message\n         *   6. online\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        addListener(event: \"listening\", listener: (address: Address) => void): this;\n        addListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: () => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\"): boolean;\n        emit(event: \"error\", error: Error): boolean;\n        emit(event: \"exit\", code: number, signal: string): boolean;\n        emit(event: \"listening\", address: Address): boolean;\n        emit(event: \"message\", message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\"): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        on(event: \"listening\", listener: (address: Address) => void): this;\n        on(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: () => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        once(event: \"listening\", listener: (address: Address) => void): this;\n        once(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: () => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(event: \"online\", listener: () => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"exit\", listener: (code: number, signal: string) => void): this;\n        prependOnceListener(event: \"listening\", listener: (address: Address) => void): this;\n        prependOnceListener(event: \"message\", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(event: \"online\", listener: () => void): this;\n    }\n    export interface Cluster extends EventEmitter {\n        disconnect(callback?: () => void): void;\n        /**\n         * Spawn a new worker process.\n         *\n         * This can only be called from the primary process.\n         * @param env Key/value pairs to add to worker process environment.\n         * @since v0.6.0\n         */\n        fork(env?: any): Worker;\n        /** @deprecated since v16.0.0 - use isPrimary. */\n        readonly isMaster: boolean;\n        /**\n         * True if the process is a primary. This is determined by the `process.env.NODE_UNIQUE_ID`. If `process.env.NODE_UNIQUE_ID`\n         * is undefined, then `isPrimary` is `true`.\n         * @since v16.0.0\n         */\n        readonly isPrimary: boolean;\n        /**\n         * True if the process is not a primary (it is the negation of `cluster.isPrimary`).\n         * @since v0.6.0\n         */\n        readonly isWorker: boolean;\n        /**\n         * The scheduling policy, either `cluster.SCHED_RR` for round-robin or `cluster.SCHED_NONE` to leave it to the operating system. This is a\n         * global setting and effectively frozen once either the first worker is spawned, or [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)\n         * is called, whichever comes first.\n         *\n         * `SCHED_RR` is the default on all operating systems except Windows. Windows will change to `SCHED_RR` once libuv is able to effectively distribute\n         * IOCP handles without incurring a large performance hit.\n         *\n         * `cluster.schedulingPolicy` can also be set through the `NODE_CLUSTER_SCHED_POLICY` environment variable. Valid values are `'rr'` and `'none'`.\n         * @since v0.11.2\n         */\n        schedulingPolicy: number;\n        /**\n         * After calling [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)\n         * (or [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)) this settings object will contain\n         * the settings, including the default values.\n         *\n         * This object is not intended to be changed or set manually.\n         * @since v0.7.1\n         */\n        readonly settings: ClusterSettings;\n        /** @deprecated since v16.0.0 - use [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings) instead. */\n        setupMaster(settings?: ClusterSettings): void;\n        /**\n         * `setupPrimary` is used to change the default 'fork' behavior. Once called, the settings will be present in `cluster.settings`.\n         *\n         * Any settings changes only affect future calls to [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)\n         * and have no effect on workers that are already running.\n         *\n         * The only attribute of a worker that cannot be set via `.setupPrimary()` is the `env` passed to\n         * [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv).\n         *\n         * The defaults above apply to the first call only; the defaults for later calls are the current values at the time of\n         * `cluster.setupPrimary()` is called.\n         *\n         * ```js\n         * import cluster from 'node:cluster';\n         *\n         * cluster.setupPrimary({\n         *   exec: 'worker.js',\n         *   args: ['--use', 'https'],\n         *   silent: true,\n         * });\n         * cluster.fork(); // https worker\n         * cluster.setupPrimary({\n         *   exec: 'worker.js',\n         *   args: ['--use', 'http'],\n         * });\n         * cluster.fork(); // http worker\n         * ```\n         *\n         * This can only be called from the primary process.\n         * @since v16.0.0\n         */\n        setupPrimary(settings?: ClusterSettings): void;\n        /**\n         * A reference to the current worker object. Not available in the primary process.\n         *\n         * ```js\n         * import cluster from 'node:cluster';\n         *\n         * if (cluster.isPrimary) {\n         *   console.log('I am primary');\n         *   cluster.fork();\n         *   cluster.fork();\n         * } else if (cluster.isWorker) {\n         *   console.log(`I am worker #${cluster.worker.id}`);\n         * }\n         * ```\n         * @since v0.7.0\n         */\n        readonly worker?: Worker | undefined;\n        /**\n         * A hash that stores the active worker objects, keyed by `id` field. This makes it easy to loop through all the workers. It is only available in the primary process.\n         *\n         * A worker is removed from `cluster.workers` after the worker has disconnected _and_ exited. The order between these two events cannot be determined in advance. However, it\n         * is guaranteed that the removal from the `cluster.workers` list happens before the last `'disconnect'` or `'exit'` event is emitted.\n         *\n         * ```js\n         * import cluster from 'node:cluster';\n         *\n         * for (const worker of Object.values(cluster.workers)) {\n         *   worker.send('big announcement to all workers');\n         * }\n         * ```\n         * @since v0.7.0\n         */\n        readonly workers?: NodeJS.Dict<Worker> | undefined;\n        readonly SCHED_NONE: number;\n        readonly SCHED_RR: number;\n        /**\n         * events.EventEmitter\n         *   1. disconnect\n         *   2. exit\n         *   3. fork\n         *   4. listening\n         *   5. message\n         *   6. online\n         *   7. setup\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        addListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        addListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        addListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        addListener(\n            event: \"message\",\n            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,\n        ): this; // the handle is a net.Socket or net.Server object, or undefined.\n        addListener(event: \"online\", listener: (worker: Worker) => void): this;\n        addListener(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: \"disconnect\", worker: Worker): boolean;\n        emit(event: \"exit\", worker: Worker, code: number, signal: string): boolean;\n        emit(event: \"fork\", worker: Worker): boolean;\n        emit(event: \"listening\", worker: Worker, address: Address): boolean;\n        emit(event: \"message\", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;\n        emit(event: \"online\", worker: Worker): boolean;\n        emit(event: \"setup\", settings: ClusterSettings): boolean;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        on(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        on(event: \"fork\", listener: (worker: Worker) => void): this;\n        on(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        on(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        on(event: \"online\", listener: (worker: Worker) => void): this;\n        on(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        once(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        once(event: \"fork\", listener: (worker: Worker) => void): this;\n        once(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        once(event: \"message\", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.\n        once(event: \"online\", listener: (worker: Worker) => void): this;\n        once(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        // the handle is a net.Socket or net.Server object, or undefined.\n        prependListener(\n            event: \"message\",\n            listener: (worker: Worker, message: any, handle?: net.Socket | net.Server) => void,\n        ): this;\n        prependListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependListener(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"disconnect\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"exit\", listener: (worker: Worker, code: number, signal: string) => void): this;\n        prependOnceListener(event: \"fork\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"listening\", listener: (worker: Worker, address: Address) => void): this;\n        // the handle is a net.Socket or net.Server object, or undefined.\n        prependOnceListener(\n            event: \"message\",\n            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,\n        ): this;\n        prependOnceListener(event: \"online\", listener: (worker: Worker) => void): this;\n        prependOnceListener(event: \"setup\", listener: (settings: ClusterSettings) => void): this;\n    }\n    const cluster: Cluster;\n    export default cluster;\n}\ndeclare module \"node:cluster\" {\n    export * from \"cluster\";\n    export { default as default } from \"cluster\";\n}\n"
        }
    ]
}