{
    "sourceFile": "node_modules/@types/node/diagnostics_channel.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:diagnostics_channel` module provides an API to create named channels\n * to report arbitrary message data for diagnostics purposes.\n *\n * It can be accessed using:\n *\n * ```js\n * import diagnostics_channel from 'node:diagnostics_channel';\n * ```\n *\n * It is intended that a module writer wanting to report diagnostics messages\n * will create one or many top-level channels to report messages through.\n * Channels may also be acquired at runtime but it is not encouraged\n * due to the additional overhead of doing so. Channels may be exported for\n * convenience, but as long as the name is known it can be acquired anywhere.\n *\n * If you intend for your module to produce diagnostics data for others to\n * consume it is recommended that you include documentation of what named\n * channels are used along with the shape of the message data. Channel names\n * should generally include the module name to avoid collisions with data from\n * other modules.\n * @since v15.1.0, v14.17.0\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/diagnostics_channel.js)\n */\ndeclare module \"diagnostics_channel\" {\n    import { AsyncLocalStorage } from \"node:async_hooks\";\n    /**\n     * Check if there are active subscribers to the named channel. This is helpful if\n     * the message you want to send might be expensive to prepare.\n     *\n     * This API is optional but helpful when trying to publish messages from very\n     * performance-sensitive code.\n     *\n     * ```js\n     * import diagnostics_channel from 'node:diagnostics_channel';\n     *\n     * if (diagnostics_channel.hasSubscribers('my-channel')) {\n     *   // There are subscribers, prepare and publish message\n     * }\n     * ```\n     * @since v15.1.0, v14.17.0\n     * @param name The channel name\n     * @return If there are active subscribers\n     */\n    function hasSubscribers(name: string | symbol): boolean;\n    /**\n     * This is the primary entry-point for anyone wanting to publish to a named\n     * channel. It produces a channel object which is optimized to reduce overhead at\n     * publish time as much as possible.\n     *\n     * ```js\n     * import diagnostics_channel from 'node:diagnostics_channel';\n     *\n     * const channel = diagnostics_channel.channel('my-channel');\n     * ```\n     * @since v15.1.0, v14.17.0\n     * @param name The channel name\n     * @return The named channel object\n     */\n    function channel(name: string | symbol): Channel;\n    type ChannelListener = (message: unknown, name: string | symbol) => void;\n    /**\n     * Register a message handler to subscribe to this channel. This message handler\n     * will be run synchronously whenever a message is published to the channel. Any\n     * errors thrown in the message handler will trigger an `'uncaughtException'`.\n     *\n     * ```js\n     * import diagnostics_channel from 'node:diagnostics_channel';\n     *\n     * diagnostics_channel.subscribe('my-channel', (message, name) => {\n     *   // Received data\n     * });\n     * ```\n     * @since v18.7.0, v16.17.0\n     * @param name The channel name\n     * @param onMessage The handler to receive channel messages\n     */\n    function subscribe(name: string | symbol, onMessage: ChannelListener): void;\n    /**\n     * Remove a message handler previously registered to this channel with {@link subscribe}.\n     *\n     * ```js\n     * import diagnostics_channel from 'node:diagnostics_channel';\n     *\n     * function onMessage(message, name) {\n     *   // Received data\n     * }\n     *\n     * diagnostics_channel.subscribe('my-channel', onMessage);\n     *\n     * diagnostics_channel.unsubscribe('my-channel', onMessage);\n     * ```\n     * @since v18.7.0, v16.17.0\n     * @param name The channel name\n     * @param onMessage The previous subscribed handler to remove\n     * @return `true` if the handler was found, `false` otherwise.\n     */\n    function unsubscribe(name: string | symbol, onMessage: ChannelListener): boolean;\n    /**\n     * Creates a `TracingChannel` wrapper for the given `TracingChannel Channels`. If a name is given, the corresponding tracing\n     * channels will be created in the form of `tracing:${name}:${eventType}` where `eventType` corresponds to the types of `TracingChannel Channels`.\n     *\n     * ```js\n     * import diagnostics_channel from 'node:diagnostics_channel';\n     *\n     * const channelsByName = diagnostics_channel.tracingChannel('my-channel');\n     *\n     * // or...\n     *\n     * const channelsByCollection = diagnostics_channel.tracingChannel({\n     *   start: diagnostics_channel.channel('tracing:my-channel:start'),\n     *   end: diagnostics_channel.channel('tracing:my-channel:end'),\n     *   asyncStart: diagnostics_channel.channel('tracing:my-channel:asyncStart'),\n     *   asyncEnd: diagnostics_channel.channel('tracing:my-channel:asyncEnd'),\n     *   error: diagnostics_channel.channel('tracing:my-channel:error'),\n     * });\n     * ```\n     * @since v19.9.0\n     * @experimental\n     * @param nameOrChannels Channel name or object containing all the `TracingChannel Channels`\n     * @return Collection of channels to trace with\n     */\n    function tracingChannel<\n        StoreType = unknown,\n        ContextType extends object = StoreType extends object ? StoreType : object,\n    >(\n        nameOrChannels: string | TracingChannelCollection<StoreType, ContextType>,\n    ): TracingChannel<StoreType, ContextType>;\n    /**\n     * The class `Channel` represents an individual named channel within the data\n     * pipeline. It is used to track subscribers and to publish messages when there\n     * are subscribers present. It exists as a separate object to avoid channel\n     * lookups at publish time, enabling very fast publish speeds and allowing\n     * for heavy use while incurring very minimal cost. Channels are created with {@link channel}, constructing a channel directly\n     * with `new Channel(name)` is not supported.\n     * @since v15.1.0, v14.17.0\n     */\n    class Channel<StoreType = unknown, ContextType = StoreType> {\n        readonly name: string | symbol;\n        /**\n         * Check if there are active subscribers to this channel. This is helpful if\n         * the message you want to send might be expensive to prepare.\n         *\n         * This API is optional but helpful when trying to publish messages from very\n         * performance-sensitive code.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * if (channel.hasSubscribers) {\n         *   // There are subscribers, prepare and publish message\n         * }\n         * ```\n         * @since v15.1.0, v14.17.0\n         */\n        readonly hasSubscribers: boolean;\n        private constructor(name: string | symbol);\n        /**\n         * Publish a message to any subscribers to the channel. This will trigger\n         * message handlers synchronously so they will execute within the same context.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * channel.publish({\n         *   some: 'message',\n         * });\n         * ```\n         * @since v15.1.0, v14.17.0\n         * @param message The message to send to the channel subscribers\n         */\n        publish(message: unknown): void;\n        /**\n         * Register a message handler to subscribe to this channel. This message handler\n         * will be run synchronously whenever a message is published to the channel. Any\n         * errors thrown in the message handler will trigger an `'uncaughtException'`.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * channel.subscribe((message, name) => {\n         *   // Received data\n         * });\n         * ```\n         * @since v15.1.0, v14.17.0\n         * @deprecated Since v18.7.0,v16.17.0 - Use {@link subscribe(name, onMessage)}\n         * @param onMessage The handler to receive channel messages\n         */\n        subscribe(onMessage: ChannelListener): void;\n        /**\n         * Remove a message handler previously registered to this channel with `channel.subscribe(onMessage)`.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * function onMessage(message, name) {\n         *   // Received data\n         * }\n         *\n         * channel.subscribe(onMessage);\n         *\n         * channel.unsubscribe(onMessage);\n         * ```\n         * @since v15.1.0, v14.17.0\n         * @deprecated Since v18.7.0,v16.17.0 - Use {@link unsubscribe(name, onMessage)}\n         * @param onMessage The previous subscribed handler to remove\n         * @return `true` if the handler was found, `false` otherwise.\n         */\n        unsubscribe(onMessage: ChannelListener): void;\n        /**\n         * When `channel.runStores(context, ...)` is called, the given context data\n         * will be applied to any store bound to the channel. If the store has already been\n         * bound the previous `transform` function will be replaced with the new one.\n         * The `transform` function may be omitted to set the given context data as the\n         * context directly.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         * import { AsyncLocalStorage } from 'node:async_hooks';\n         *\n         * const store = new AsyncLocalStorage();\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * channel.bindStore(store, (data) => {\n         *   return { data };\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param store The store to which to bind the context data\n         * @param transform Transform context data before setting the store context\n         */\n        bindStore(store: AsyncLocalStorage<StoreType>, transform?: (context: ContextType) => StoreType): void;\n        /**\n         * Remove a message handler previously registered to this channel with `channel.bindStore(store)`.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         * import { AsyncLocalStorage } from 'node:async_hooks';\n         *\n         * const store = new AsyncLocalStorage();\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * channel.bindStore(store);\n         * channel.unbindStore(store);\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param store The store to unbind from the channel.\n         * @return `true` if the store was found, `false` otherwise.\n         */\n        unbindStore(store: any): void;\n        /**\n         * Applies the given data to any AsyncLocalStorage instances bound to the channel\n         * for the duration of the given function, then publishes to the channel within\n         * the scope of that data is applied to the stores.\n         *\n         * If a transform function was given to `channel.bindStore(store)` it will be\n         * applied to transform the message data before it becomes the context value for\n         * the store. The prior storage context is accessible from within the transform\n         * function in cases where context linking is required.\n         *\n         * The context applied to the store should be accessible in any async code which\n         * continues from execution which began during the given function, however\n         * there are some situations in which `context loss` may occur.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         * import { AsyncLocalStorage } from 'node:async_hooks';\n         *\n         * const store = new AsyncLocalStorage();\n         *\n         * const channel = diagnostics_channel.channel('my-channel');\n         *\n         * channel.bindStore(store, (message) => {\n         *   const parent = store.getStore();\n         *   return new Span(message, parent);\n         * });\n         * channel.runStores({ some: 'message' }, () => {\n         *   store.getStore(); // Span({ some: 'message' })\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param context Message to send to subscribers and bind to stores\n         * @param fn Handler to run within the entered storage context\n         * @param thisArg The receiver to be used for the function call.\n         * @param args Optional arguments to pass to the function.\n         */\n        runStores(): void;\n    }\n    interface TracingChannelSubscribers<ContextType extends object> {\n        start: (message: ContextType) => void;\n        end: (\n            message: ContextType & {\n                error?: unknown;\n                result?: unknown;\n            },\n        ) => void;\n        asyncStart: (\n            message: ContextType & {\n                error?: unknown;\n                result?: unknown;\n            },\n        ) => void;\n        asyncEnd: (\n            message: ContextType & {\n                error?: unknown;\n                result?: unknown;\n            },\n        ) => void;\n        error: (\n            message: ContextType & {\n                error: unknown;\n            },\n        ) => void;\n    }\n    interface TracingChannelCollection<StoreType = unknown, ContextType = StoreType> {\n        start: Channel<StoreType, ContextType>;\n        end: Channel<StoreType, ContextType>;\n        asyncStart: Channel<StoreType, ContextType>;\n        asyncEnd: Channel<StoreType, ContextType>;\n        error: Channel<StoreType, ContextType>;\n    }\n    /**\n     * The class `TracingChannel` is a collection of `TracingChannel Channels` which\n     * together express a single traceable action. It is used to formalize and\n     * simplify the process of producing events for tracing application flow. {@link tracingChannel} is used to construct a `TracingChannel`. As with `Channel` it is recommended to create and reuse a\n     * single `TracingChannel` at the top-level of the file rather than creating them\n     * dynamically.\n     * @since v19.9.0\n     * @experimental\n     */\n    class TracingChannel<StoreType = unknown, ContextType extends object = {}> implements TracingChannelCollection {\n        start: Channel<StoreType, ContextType>;\n        end: Channel<StoreType, ContextType>;\n        asyncStart: Channel<StoreType, ContextType>;\n        asyncEnd: Channel<StoreType, ContextType>;\n        error: Channel<StoreType, ContextType>;\n        /**\n         * Helper to subscribe a collection of functions to the corresponding channels.\n         * This is the same as calling `channel.subscribe(onMessage)` on each channel\n         * individually.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channels = diagnostics_channel.tracingChannel('my-channel');\n         *\n         * channels.subscribe({\n         *   start(message) {\n         *     // Handle start message\n         *   },\n         *   end(message) {\n         *     // Handle end message\n         *   },\n         *   asyncStart(message) {\n         *     // Handle asyncStart message\n         *   },\n         *   asyncEnd(message) {\n         *     // Handle asyncEnd message\n         *   },\n         *   error(message) {\n         *     // Handle error message\n         *   },\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param subscribers Set of `TracingChannel Channels` subscribers\n         */\n        subscribe(subscribers: TracingChannelSubscribers<ContextType>): void;\n        /**\n         * Helper to unsubscribe a collection of functions from the corresponding channels.\n         * This is the same as calling `channel.unsubscribe(onMessage)` on each channel\n         * individually.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channels = diagnostics_channel.tracingChannel('my-channel');\n         *\n         * channels.unsubscribe({\n         *   start(message) {\n         *     // Handle start message\n         *   },\n         *   end(message) {\n         *     // Handle end message\n         *   },\n         *   asyncStart(message) {\n         *     // Handle asyncStart message\n         *   },\n         *   asyncEnd(message) {\n         *     // Handle asyncEnd message\n         *   },\n         *   error(message) {\n         *     // Handle error message\n         *   },\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param subscribers Set of `TracingChannel Channels` subscribers\n         * @return `true` if all handlers were successfully unsubscribed, and `false` otherwise.\n         */\n        unsubscribe(subscribers: TracingChannelSubscribers<ContextType>): void;\n        /**\n         * Trace a synchronous function call. This will always produce a `start event` and `end event` around the execution and may produce an `error event` if the given function throws an error.\n         * This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all\n         * events should have any bound stores set to match this trace context.\n         *\n         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions\n         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channels = diagnostics_channel.tracingChannel('my-channel');\n         *\n         * channels.traceSync(() => {\n         *   // Do something\n         * }, {\n         *   some: 'thing',\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param fn Function to wrap a trace around\n         * @param context Shared object to correlate events through\n         * @param thisArg The receiver to be used for the function call\n         * @param args Optional arguments to pass to the function\n         * @return The return value of the given function\n         */\n        traceSync<ThisArg = any, Args extends any[] = any[]>(\n            fn: (this: ThisArg, ...args: Args) => any,\n            context?: ContextType,\n            thisArg?: ThisArg,\n            ...args: Args\n        ): void;\n        /**\n         * Trace a promise-returning function call. This will always produce a `start event` and `end event` around the synchronous portion of the\n         * function execution, and will produce an `asyncStart event` and `asyncEnd event` when a promise continuation is reached. It may also\n         * produce an `error event` if the given function throws an error or the\n         * returned promise rejects. This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all\n         * events should have any bound stores set to match this trace context.\n         *\n         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions\n         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channels = diagnostics_channel.tracingChannel('my-channel');\n         *\n         * channels.tracePromise(async () => {\n         *   // Do something\n         * }, {\n         *   some: 'thing',\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param fn Promise-returning function to wrap a trace around\n         * @param context Shared object to correlate trace events through\n         * @param thisArg The receiver to be used for the function call\n         * @param args Optional arguments to pass to the function\n         * @return Chained from promise returned by the given function\n         */\n        tracePromise<ThisArg = any, Args extends any[] = any[]>(\n            fn: (this: ThisArg, ...args: Args) => Promise<any>,\n            context?: ContextType,\n            thisArg?: ThisArg,\n            ...args: Args\n        ): void;\n        /**\n         * Trace a callback-receiving function call. This will always produce a `start event` and `end event` around the synchronous portion of the\n         * function execution, and will produce a `asyncStart event` and `asyncEnd event` around the callback execution. It may also produce an `error event` if the given function throws an error or\n         * the returned\n         * promise rejects. This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all\n         * events should have any bound stores set to match this trace context.\n         *\n         * The `position` will be -1 by default to indicate the final argument should\n         * be used as the callback.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         *\n         * const channels = diagnostics_channel.tracingChannel('my-channel');\n         *\n         * channels.traceCallback((arg1, callback) => {\n         *   // Do something\n         *   callback(null, 'result');\n         * }, 1, {\n         *   some: 'thing',\n         * }, thisArg, arg1, callback);\n         * ```\n         *\n         * The callback will also be run with `channel.runStores(context, ...)` which\n         * enables context loss recovery in some cases.\n         *\n         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions\n         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.\n         *\n         * ```js\n         * import diagnostics_channel from 'node:diagnostics_channel';\n         * import { AsyncLocalStorage } from 'node:async_hooks';\n         *\n         * const channels = diagnostics_channel.tracingChannel('my-channel');\n         * const myStore = new AsyncLocalStorage();\n         *\n         * // The start channel sets the initial store data to something\n         * // and stores that store data value on the trace context object\n         * channels.start.bindStore(myStore, (data) => {\n         *   const span = new Span(data);\n         *   data.span = span;\n         *   return span;\n         * });\n         *\n         * // Then asyncStart can restore from that data it stored previously\n         * channels.asyncStart.bindStore(myStore, (data) => {\n         *   return data.span;\n         * });\n         * ```\n         * @since v19.9.0\n         * @experimental\n         * @param fn callback using function to wrap a trace around\n         * @param position Zero-indexed argument position of expected callback\n         * @param context Shared object to correlate trace events through\n         * @param thisArg The receiver to be used for the function call\n         * @param args Optional arguments to pass to the function\n         * @return The return value of the given function\n         */\n        traceCallback<Fn extends (this: any, ...args: any[]) => any>(\n            fn: Fn,\n            position?: number,\n            context?: ContextType,\n            thisArg?: any,\n            ...args: Parameters<Fn>\n        ): void;\n    }\n}\ndeclare module \"node:diagnostics_channel\" {\n    export * from \"diagnostics_channel\";\n}\n"
        }
    ]
}