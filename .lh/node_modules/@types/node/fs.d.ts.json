{
    "sourceFile": "node_modules/@types/node/fs.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891955430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `node:fs` module enables interacting with the file system in a\n * way modeled on standard POSIX functions.\n *\n * To use the promise-based APIs:\n *\n * ```js\n * import * as fs from 'node:fs/promises';\n * ```\n *\n * To use the callback and sync APIs:\n *\n * ```js\n * import * as fs from 'node:fs';\n * ```\n *\n * All file system operations have synchronous, callback, and promise-based\n * forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/fs.js)\n */\ndeclare module \"fs\" {\n    import * as stream from \"node:stream\";\n    import { Abortable, EventEmitter } from \"node:events\";\n    import { URL } from \"node:url\";\n    import * as promises from \"node:fs/promises\";\n    export { promises };\n    /**\n     * Valid types for path values in \"fs\".\n     */\n    export type PathLike = string | Buffer | URL;\n    export type PathOrFileDescriptor = PathLike | number;\n    export type TimeLike = string | number | Date;\n    export type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;\n    export type BufferEncodingOption =\n        | \"buffer\"\n        | {\n            encoding: \"buffer\";\n        };\n    export interface ObjectEncodingOptions {\n        encoding?: BufferEncoding | null | undefined;\n    }\n    export type EncodingOption = ObjectEncodingOptions | BufferEncoding | undefined | null;\n    export type OpenMode = number | string;\n    export type Mode = number | string;\n    export interface StatsBase<T> {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        dev: T;\n        ino: T;\n        mode: T;\n        nlink: T;\n        uid: T;\n        gid: T;\n        rdev: T;\n        size: T;\n        blksize: T;\n        blocks: T;\n        atimeMs: T;\n        mtimeMs: T;\n        ctimeMs: T;\n        birthtimeMs: T;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n    export interface Stats extends StatsBase<number> {}\n    /**\n     * A `fs.Stats` object provides information about a file.\n     *\n     * Objects returned from {@link stat}, {@link lstat}, {@link fstat}, and\n     * their synchronous counterparts are of this type.\n     * If `bigint` in the `options` passed to those methods is true, the numeric values\n     * will be `bigint` instead of `number`, and the object will contain additional\n     * nanosecond-precision properties suffixed with `Ns`. `Stat` objects are not to be created directly using the `new` keyword.\n     *\n     * ```console\n     * Stats {\n     *   dev: 2114,\n     *   ino: 48064969,\n     *   mode: 33188,\n     *   nlink: 1,\n     *   uid: 85,\n     *   gid: 100,\n     *   rdev: 0,\n     *   size: 527,\n     *   blksize: 4096,\n     *   blocks: 8,\n     *   atimeMs: 1318289051000.1,\n     *   mtimeMs: 1318289051000.1,\n     *   ctimeMs: 1318289051000.1,\n     *   birthtimeMs: 1318289051000.1,\n     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,\n     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,\n     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,\n     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }\n     * ```\n     *\n     * `bigint` version:\n     *\n     * ```console\n     * BigIntStats {\n     *   dev: 2114n,\n     *   ino: 48064969n,\n     *   mode: 33188n,\n     *   nlink: 1n,\n     *   uid: 85n,\n     *   gid: 100n,\n     *   rdev: 0n,\n     *   size: 527n,\n     *   blksize: 4096n,\n     *   blocks: 8n,\n     *   atimeMs: 1318289051000n,\n     *   mtimeMs: 1318289051000n,\n     *   ctimeMs: 1318289051000n,\n     *   birthtimeMs: 1318289051000n,\n     *   atimeNs: 1318289051000000000n,\n     *   mtimeNs: 1318289051000000000n,\n     *   ctimeNs: 1318289051000000000n,\n     *   birthtimeNs: 1318289051000000000n,\n     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,\n     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,\n     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,\n     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }\n     * ```\n     * @since v0.1.21\n     */\n    export class Stats {\n        private constructor();\n    }\n    export interface StatsFsBase<T> {\n        /** Type of file system. */\n        type: T;\n        /**  Optimal transfer block size. */\n        bsize: T;\n        /**  Total data blocks in file system. */\n        blocks: T;\n        /** Free blocks in file system. */\n        bfree: T;\n        /** Available blocks for unprivileged users */\n        bavail: T;\n        /** Total file nodes in file system. */\n        files: T;\n        /** Free file nodes in file system. */\n        ffree: T;\n    }\n    export interface StatsFs extends StatsFsBase<number> {}\n    /**\n     * Provides information about a mounted file system.\n     *\n     * Objects returned from {@link statfs} and its synchronous counterpart are of\n     * this type. If `bigint` in the `options` passed to those methods is `true`, the\n     * numeric values will be `bigint` instead of `number`.\n     *\n     * ```console\n     * StatFs {\n     *   type: 1397114950,\n     *   bsize: 4096,\n     *   blocks: 121938943,\n     *   bfree: 61058895,\n     *   bavail: 61058895,\n     *   files: 999,\n     *   ffree: 1000000\n     * }\n     * ```\n     *\n     * `bigint` version:\n     *\n     * ```console\n     * StatFs {\n     *   type: 1397114950n,\n     *   bsize: 4096n,\n     *   blocks: 121938943n,\n     *   bfree: 61058895n,\n     *   bavail: 61058895n,\n     *   files: 999n,\n     *   ffree: 1000000n\n     * }\n     * ```\n     * @since v19.6.0, v18.15.0\n     */\n    export class StatsFs {}\n    export interface BigIntStatsFs extends StatsFsBase<bigint> {}\n    export interface StatFsOptions {\n        bigint?: boolean | undefined;\n    }\n    /**\n     * A representation of a directory entry, which can be a file or a subdirectory\n     * within the directory, as returned by reading from an `fs.Dir`. The\n     * directory entry is a combination of the file name and file type pairs.\n     *\n     * Additionally, when {@link readdir} or {@link readdirSync} is called with\n     * the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.\n     * @since v10.10.0\n     */\n    export class Dirent {\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a regular file.\n         * @since v10.10.0\n         */\n        isFile(): boolean;\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a file system\n         * directory.\n         * @since v10.10.0\n         */\n        isDirectory(): boolean;\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a block device.\n         * @since v10.10.0\n         */\n        isBlockDevice(): boolean;\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a character device.\n         * @since v10.10.0\n         */\n        isCharacterDevice(): boolean;\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a symbolic link.\n         * @since v10.10.0\n         */\n        isSymbolicLink(): boolean;\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a first-in-first-out\n         * (FIFO) pipe.\n         * @since v10.10.0\n         */\n        isFIFO(): boolean;\n        /**\n         * Returns `true` if the `fs.Dirent` object describes a socket.\n         * @since v10.10.0\n         */\n        isSocket(): boolean;\n        /**\n         * The file name that this `fs.Dirent` object refers to. The type of this\n         * value is determined by the `options.encoding` passed to {@link readdir} or {@link readdirSync}.\n         * @since v10.10.0\n         */\n        name: string;\n        /**\n         * The base path that this `fs.Dirent` object refers to.\n         * @since v20.12.0\n         */\n        parentPath: string;\n        /**\n         * Alias for `dirent.parentPath`.\n         * @since v20.1.0\n         * @deprecated Since v20.12.0\n         */\n        path: string;\n    }\n    /**\n     * A class representing a directory stream.\n     *\n     * Created by {@link opendir}, {@link opendirSync}, or `fsPromises.opendir()`.\n     *\n     * ```js\n     * import { opendir } from 'node:fs/promises';\n     *\n     * try {\n     *   const dir = await opendir('./');\n     *   for await (const dirent of dir)\n     *     console.log(dirent.name);\n     * } catch (err) {\n     *   console.error(err);\n     * }\n     * ```\n     *\n     * When using the async iterator, the `fs.Dir` object will be automatically\n     * closed after the iterator exits.\n     * @since v12.12.0\n     */\n    export class Dir implements AsyncIterable<Dirent> {\n        /**\n         * The read-only path of this directory as was provided to {@link opendir},{@link opendirSync}, or `fsPromises.opendir()`.\n         * @since v12.12.0\n         */\n        readonly path: string;\n        /**\n         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.\n         */\n        [Symbol.asyncIterator](): NodeJS.AsyncIterator<Dirent>;\n        /**\n         * Asynchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         *\n         * A promise is returned that will be fulfilled after the resource has been\n         * closed.\n         * @since v12.12.0\n         */\n        close(): Promise<void>;\n        close(cb: NoParamCallback): void;\n        /**\n         * Synchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         * @since v12.12.0\n         */\n        closeSync(): void;\n        /**\n         * Asynchronously read the next directory entry via [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) as an `fs.Dirent`.\n         *\n         * A promise is returned that will be fulfilled with an `fs.Dirent`, or `null` if there are no more directory entries to read.\n         *\n         * Directory entries returned by this function are in no particular order as\n         * provided by the operating system's underlying directory mechanisms.\n         * Entries added or removed while iterating over the directory might not be\n         * included in the iteration results.\n         * @since v12.12.0\n         * @return containing {fs.Dirent|null}\n         */\n        read(): Promise<Dirent | null>;\n        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;\n        /**\n         * Synchronously read the next directory entry as an `fs.Dirent`. See the\n         * POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more detail.\n         *\n         * If there are no more directory entries to read, `null` will be returned.\n         *\n         * Directory entries returned by this function are in no particular order as\n         * provided by the operating system's underlying directory mechanisms.\n         * Entries added or removed while iterating over the directory might not be\n         * included in the iteration results.\n         * @since v12.12.0\n         */\n        readSync(): Dirent | null;\n    }\n    /**\n     * Class: fs.StatWatcher\n     * @since v14.3.0, v12.20.0\n     * Extends `EventEmitter`\n     * A successful call to {@link watchFile} method will return a new fs.StatWatcher object.\n     */\n    export interface StatWatcher extends EventEmitter {\n        /**\n         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.StatWatcher` is active. Calling `watcher.ref()` multiple times will have\n         * no effect.\n         *\n         * By default, all `fs.StatWatcher` objects are \"ref'ed\", making it normally\n         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been\n         * called previously.\n         * @since v14.3.0, v12.20.0\n         */\n        ref(): this;\n        /**\n         * When called, the active `fs.StatWatcher` object will not require the Node.js\n         * event loop to remain active. If there is no other activity keeping the\n         * event loop running, the process may exit before the `fs.StatWatcher` object's\n         * callback is invoked. Calling `watcher.unref()` multiple times will have\n         * no effect.\n         * @since v14.3.0, v12.20.0\n         */\n        unref(): this;\n    }\n    export interface FSWatcher extends EventEmitter {\n        /**\n         * Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.\n         * @since v0.5.8\n         */\n        close(): void;\n        /**\n         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have\n         * no effect.\n         *\n         * By default, all `fs.FSWatcher` objects are \"ref'ed\", making it normally\n         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been\n         * called previously.\n         * @since v14.3.0, v12.20.0\n         */\n        ref(): this;\n        /**\n         * When called, the active `fs.FSWatcher` object will not require the Node.js\n         * event loop to remain active. If there is no other activity keeping the\n         * event loop running, the process may exit before the `fs.FSWatcher` object's\n         * callback is invoked. Calling `watcher.unref()` multiple times will have\n         * no effect.\n         * @since v14.3.0, v12.20.0\n         */\n        unref(): this;\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. close\n         *   3. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n    }\n    /**\n     * Instances of `fs.ReadStream` are created and returned using the {@link createReadStream} function.\n     * @since v0.1.93\n     */\n    export class ReadStream extends stream.Readable {\n        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;\n        /**\n         * The number of bytes that have been read so far.\n         * @since v6.4.0\n         */\n        bytesRead: number;\n        /**\n         * The path to the file the stream is reading from as specified in the first\n         * argument to `fs.createReadStream()`. If `path` is passed as a string, then`readStream.path` will be a string. If `path` is passed as a `Buffer`, then`readStream.path` will be a\n         * `Buffer`. If `fd` is specified, then`readStream.path` will be `undefined`.\n         * @since v0.1.93\n         */\n        path: string | Buffer;\n        /**\n         * This property is `true` if the underlying file has not been opened yet,\n         * i.e. before the `'ready'` event is emitted.\n         * @since v11.2.0, v10.16.0\n         */\n        pending: boolean;\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;\n        on<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;\n        once<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;\n        prependListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;\n        prependOnceListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;\n    }\n\n    /**\n     * The Keys are events of the ReadStream and the values are the functions that are called when the event is emitted.\n     */\n    type ReadStreamEvents = {\n        close: () => void;\n        data: (chunk: Buffer | string) => void;\n        end: () => void;\n        error: (err: Error) => void;\n        open: (fd: number) => void;\n        pause: () => void;\n        readable: () => void;\n        ready: () => void;\n        resume: () => void;\n    } & CustomEvents;\n\n    /**\n     * string & {} allows to allow any kind of strings for the event\n     * but still allows to have auto completion for the normal events.\n     */\n    type CustomEvents = { [Key in string & {} | symbol]: (...args: any[]) => void };\n\n    /**\n     * The Keys are events of the WriteStream and the values are the functions that are called when the event is emitted.\n     */\n    type WriteStreamEvents = {\n        close: () => void;\n        drain: () => void;\n        error: (err: Error) => void;\n        finish: () => void;\n        open: (fd: number) => void;\n        pipe: (src: stream.Readable) => void;\n        ready: () => void;\n        unpipe: (src: stream.Readable) => void;\n    } & CustomEvents;\n    /**\n     * * Extends `stream.Writable`\n     *\n     * Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.\n     * @since v0.1.93\n     */\n    export class WriteStream extends stream.Writable {\n        /**\n         * Closes `writeStream`. Optionally accepts a\n         * callback that will be executed once the `writeStream`is closed.\n         * @since v0.9.4\n         */\n        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;\n        /**\n         * The number of bytes written so far. Does not include data that is still queued\n         * for writing.\n         * @since v0.4.7\n         */\n        bytesWritten: number;\n        /**\n         * The path to the file the stream is writing to as specified in the first\n         * argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a\n         * `Buffer`.\n         * @since v0.1.93\n         */\n        path: string | Buffer;\n        /**\n         * This property is `true` if the underlying file has not been opened yet,\n         * i.e. before the `'ready'` event is emitted.\n         * @since v11.2.0\n         */\n        pending: boolean;\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;\n        on<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;\n        once<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;\n        prependListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;\n        prependOnceListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;\n    }\n    /**\n     * Asynchronously rename file at `oldPath` to the pathname provided\n     * as `newPath`. In the case that `newPath` already exists, it will\n     * be overwritten. If there is a directory at `newPath`, an error will\n     * be raised instead. No arguments other than a possible exception are\n     * given to the completion callback.\n     *\n     * See also: [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html).\n     *\n     * ```js\n     * import { rename } from 'node:fs';\n     *\n     * rename('oldFile.txt', 'newFile.txt', (err) => {\n     *   if (err) throw err;\n     *   console.log('Rename complete!');\n     * });\n     * ```\n     * @since v0.0.2\n     */\n    export function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n    export namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n    /**\n     * Renames the file from `oldPath` to `newPath`. Returns `undefined`.\n     *\n     * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.\n     * @since v0.1.21\n     */\n    export function renameSync(oldPath: PathLike, newPath: PathLike): void;\n    /**\n     * Truncates the file. No arguments other than a possible exception are\n     * given to the completion callback. A file descriptor can also be passed as the\n     * first argument. In this case, `fs.ftruncate()` is called.\n     *\n     * ```js\n     * import { truncate } from 'node:fs';\n     * // Assuming that 'path/file.txt' is a regular file.\n     * truncate('path/file.txt', (err) => {\n     *   if (err) throw err;\n     *   console.log('path/file.txt was truncated');\n     * });\n     * ```\n     *\n     * Passing a file descriptor is deprecated and may result in an error being thrown\n     * in the future.\n     *\n     * See the POSIX [`truncate(2)`](http://man7.org/linux/man-pages/man2/truncate.2.html) documentation for more details.\n     * @since v0.8.6\n     * @param [len=0]\n     */\n    export function truncate(path: PathLike, len: number | undefined, callback: NoParamCallback): void;\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function truncate(path: PathLike, callback: NoParamCallback): void;\n    export namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(path: PathLike, len?: number): Promise<void>;\n    }\n    /**\n     * Truncates the file. Returns `undefined`. A file descriptor can also be\n     * passed as the first argument. In this case, `fs.ftruncateSync()` is called.\n     *\n     * Passing a file descriptor is deprecated and may result in an error being thrown\n     * in the future.\n     * @since v0.8.6\n     * @param [len=0]\n     */\n    export function truncateSync(path: PathLike, len?: number): void;\n    /**\n     * Truncates the file descriptor. No arguments other than a possible exception are\n     * given to the completion callback.\n     *\n     * See the POSIX [`ftruncate(2)`](http://man7.org/linux/man-pages/man2/ftruncate.2.html) documentation for more detail.\n     *\n     * If the file referred to by the file descriptor was larger than `len` bytes, only\n     * the first `len` bytes will be retained in the file.\n     *\n     * For example, the following program retains only the first four bytes of the\n     * file:\n     *\n     * ```js\n     * import { open, close, ftruncate } from 'node:fs';\n     *\n     * function closeFd(fd) {\n     *   close(fd, (err) => {\n     *     if (err) throw err;\n     *   });\n     * }\n     *\n     * open('temp.txt', 'r+', (err, fd) => {\n     *   if (err) throw err;\n     *\n     *   try {\n     *     ftruncate(fd, 4, (err) => {\n     *       closeFd(fd);\n     *       if (err) throw err;\n     *     });\n     *   } catch (err) {\n     *     closeFd(fd);\n     *     if (err) throw err;\n     *   }\n     * });\n     * ```\n     *\n     * If the file previously was shorter than `len` bytes, it is extended, and the\n     * extended part is filled with null bytes (`'\\0'`):\n     *\n     * If `len` is negative then `0` will be used.\n     * @since v0.8.6\n     * @param [len=0]\n     */\n    export function ftruncate(fd: number, len: number | undefined, callback: NoParamCallback): void;\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    export function ftruncate(fd: number, callback: NoParamCallback): void;\n    export namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to `0`.\n         */\n        function __promisify__(fd: number, len?: number): Promise<void>;\n    }\n    /**\n     * Truncates the file descriptor. Returns `undefined`.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link ftruncate}.\n     * @since v0.8.6\n     * @param [len=0]\n     */\n    export function ftruncateSync(fd: number, len?: number): void;\n    /**\n     * Asynchronously changes owner and group of a file. No arguments other than a\n     * possible exception are given to the completion callback.\n     *\n     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.\n     * @since v0.1.97\n     */\n    export function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n    export namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n    /**\n     * Synchronously changes owner and group of a file. Returns `undefined`.\n     * This is the synchronous version of {@link chown}.\n     *\n     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.\n     * @since v0.1.97\n     */\n    export function chownSync(path: PathLike, uid: number, gid: number): void;\n    /**\n     * Sets the owner of the file. No arguments other than a possible exception are\n     * given to the completion callback.\n     *\n     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.\n     * @since v0.4.7\n     */\n    export function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;\n    export namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n    /**\n     * Sets the owner of the file. Returns `undefined`.\n     *\n     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.\n     * @since v0.4.7\n     * @param uid The file's new owner's user id.\n     * @param gid The file's new group's group id.\n     */\n    export function fchownSync(fd: number, uid: number, gid: number): void;\n    /**\n     * Set the owner of the symbolic link. No arguments other than a possible\n     * exception are given to the completion callback.\n     *\n     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more detail.\n     */\n    export function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n    export namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n    /**\n     * Set the owner for the path. Returns `undefined`.\n     *\n     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.\n     * @param uid The file's new owner's user id.\n     * @param gid The file's new group's group id.\n     */\n    export function lchownSync(path: PathLike, uid: number, gid: number): void;\n    /**\n     * Changes the access and modification times of a file in the same way as {@link utimes}, with the difference that if the path refers to a symbolic\n     * link, then the link is not dereferenced: instead, the timestamps of the\n     * symbolic link itself are changed.\n     *\n     * No arguments other than a possible exception are given to the completion\n     * callback.\n     * @since v14.5.0, v12.19.0\n     */\n    export function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;\n    export namespace lutimes {\n        /**\n         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,\n         * with the difference that if the path refers to a symbolic link, then the link is not\n         * dereferenced: instead, the timestamps of the symbolic link itself are changed.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;\n    }\n    /**\n     * Change the file system timestamps of the symbolic link referenced by `path`.\n     * Returns `undefined`, or throws an exception when parameters are incorrect or\n     * the operation fails. This is the synchronous version of {@link lutimes}.\n     * @since v14.5.0, v12.19.0\n     */\n    export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;\n    /**\n     * Asynchronously changes the permissions of a file. No arguments other than a\n     * possible exception are given to the completion callback.\n     *\n     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.\n     *\n     * ```js\n     * import { chmod } from 'node:fs';\n     *\n     * chmod('my_file.txt', 0o775, (err) => {\n     *   if (err) throw err;\n     *   console.log('The permissions for file \"my_file.txt\" have been changed!');\n     * });\n     * ```\n     * @since v0.1.30\n     */\n    export function chmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;\n    export namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: Mode): Promise<void>;\n    }\n    /**\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link chmod}.\n     *\n     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.\n     * @since v0.6.7\n     */\n    export function chmodSync(path: PathLike, mode: Mode): void;\n    /**\n     * Sets the permissions on the file. No arguments other than a possible exception\n     * are given to the completion callback.\n     *\n     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.\n     * @since v0.4.7\n     */\n    export function fchmod(fd: number, mode: Mode, callback: NoParamCallback): void;\n    export namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: Mode): Promise<void>;\n    }\n    /**\n     * Sets the permissions on the file. Returns `undefined`.\n     *\n     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.\n     * @since v0.4.7\n     */\n    export function fchmodSync(fd: number, mode: Mode): void;\n    /**\n     * Changes the permissions on a symbolic link. No arguments other than a possible\n     * exception are given to the completion callback.\n     *\n     * This method is only implemented on macOS.\n     *\n     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.\n     * @deprecated Since v0.4.7\n     */\n    export function lchmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;\n    /** @deprecated */\n    export namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: Mode): Promise<void>;\n    }\n    /**\n     * Changes the permissions on a symbolic link. Returns `undefined`.\n     *\n     * This method is only implemented on macOS.\n     *\n     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.\n     * @deprecated Since v0.4.7\n     */\n    export function lchmodSync(path: PathLike, mode: Mode): void;\n    /**\n     * Asynchronous [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html). The callback gets two arguments `(err, stats)` where`stats` is an `fs.Stats` object.\n     *\n     * In case of an error, the `err.code` will be one of `Common System Errors`.\n     *\n     * {@link stat} follows symbolic links. Use {@link lstat} to look at the\n     * links themselves.\n     *\n     * Using `fs.stat()` to check for the existence of a file before calling`fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended.\n     * Instead, user code should open/read/write the file directly and handle the\n     * error raised if the file is not available.\n     *\n     * To check if a file exists without manipulating it afterwards, {@link access} is recommended.\n     *\n     * For example, given the following directory structure:\n     *\n     * ```text\n     * - txtDir\n     * -- file.txt\n     * - app.js\n     * ```\n     *\n     * The next program will check for the stats of the given paths:\n     *\n     * ```js\n     * import { stat } from 'node:fs';\n     *\n     * const pathsToCheck = ['./txtDir', './txtDir/file.txt'];\n     *\n     * for (let i = 0; i < pathsToCheck.length; i++) {\n     *   stat(pathsToCheck[i], (err, stats) => {\n     *     console.log(stats.isDirectory());\n     *     console.log(stats);\n     *   });\n     * }\n     * ```\n     *\n     * The resulting output will resemble:\n     *\n     * ```console\n     * true\n     * Stats {\n     *   dev: 16777220,\n     *   mode: 16877,\n     *   nlink: 3,\n     *   uid: 501,\n     *   gid: 20,\n     *   rdev: 0,\n     *   blksize: 4096,\n     *   ino: 14214262,\n     *   size: 96,\n     *   blocks: 0,\n     *   atimeMs: 1561174653071.963,\n     *   mtimeMs: 1561174614583.3518,\n     *   ctimeMs: 1561174626623.5366,\n     *   birthtimeMs: 1561174126937.2893,\n     *   atime: 2019-06-22T03:37:33.072Z,\n     *   mtime: 2019-06-22T03:36:54.583Z,\n     *   ctime: 2019-06-22T03:37:06.624Z,\n     *   birthtime: 2019-06-22T03:28:46.937Z\n     * }\n     * false\n     * Stats {\n     *   dev: 16777220,\n     *   mode: 33188,\n     *   nlink: 1,\n     *   uid: 501,\n     *   gid: 20,\n     *   rdev: 0,\n     *   blksize: 4096,\n     *   ino: 14214074,\n     *   size: 8,\n     *   blocks: 8,\n     *   atimeMs: 1561174616618.8555,\n     *   mtimeMs: 1561174614584,\n     *   ctimeMs: 1561174614583.8145,\n     *   birthtimeMs: 1561174007710.7478,\n     *   atime: 2019-06-22T03:36:56.619Z,\n     *   mtime: 2019-06-22T03:36:54.584Z,\n     *   ctime: 2019-06-22T03:36:54.584Z,\n     *   birthtime: 2019-06-22T03:26:47.711Z\n     * }\n     * ```\n     * @since v0.0.2\n     */\n    export function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    export function stat(\n        path: PathLike,\n        options:\n            | (StatOptions & {\n                bigint?: false | undefined;\n            })\n            | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,\n    ): void;\n    export function stat(\n        path: PathLike,\n        options: StatOptions & {\n            bigint: true;\n        },\n        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,\n    ): void;\n    export function stat(\n        path: PathLike,\n        options: StatOptions | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,\n    ): void;\n    export namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?: StatOptions & {\n                bigint?: false | undefined;\n            },\n        ): Promise<Stats>;\n        function __promisify__(\n            path: PathLike,\n            options: StatOptions & {\n                bigint: true;\n            },\n        ): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n    export interface StatSyncFn extends Function {\n        (path: PathLike, options?: undefined): Stats;\n        (\n            path: PathLike,\n            options?: StatSyncOptions & {\n                bigint?: false | undefined;\n                throwIfNoEntry: false;\n            },\n        ): Stats | undefined;\n        (\n            path: PathLike,\n            options: StatSyncOptions & {\n                bigint: true;\n                throwIfNoEntry: false;\n            },\n        ): BigIntStats | undefined;\n        (\n            path: PathLike,\n            options?: StatSyncOptions & {\n                bigint?: false | undefined;\n            },\n        ): Stats;\n        (\n            path: PathLike,\n            options: StatSyncOptions & {\n                bigint: true;\n            },\n        ): BigIntStats;\n        (\n            path: PathLike,\n            options: StatSyncOptions & {\n                bigint: boolean;\n                throwIfNoEntry?: false | undefined;\n            },\n        ): Stats | BigIntStats;\n        (path: PathLike, options?: StatSyncOptions): Stats | BigIntStats | undefined;\n    }\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export const statSync: StatSyncFn;\n    /**\n     * Invokes the callback with the `fs.Stats` for the file descriptor.\n     *\n     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.\n     * @since v0.1.95\n     */\n    export function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    export function fstat(\n        fd: number,\n        options:\n            | (StatOptions & {\n                bigint?: false | undefined;\n            })\n            | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,\n    ): void;\n    export function fstat(\n        fd: number,\n        options: StatOptions & {\n            bigint: true;\n        },\n        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,\n    ): void;\n    export function fstat(\n        fd: number,\n        options: StatOptions | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,\n    ): void;\n    export namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(\n            fd: number,\n            options?: StatOptions & {\n                bigint?: false | undefined;\n            },\n        ): Promise<Stats>;\n        function __promisify__(\n            fd: number,\n            options: StatOptions & {\n                bigint: true;\n            },\n        ): Promise<BigIntStats>;\n        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n    /**\n     * Retrieves the `fs.Stats` for the file descriptor.\n     *\n     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.\n     * @since v0.1.95\n     */\n    export function fstatSync(\n        fd: number,\n        options?: StatOptions & {\n            bigint?: false | undefined;\n        },\n    ): Stats;\n    export function fstatSync(\n        fd: number,\n        options: StatOptions & {\n            bigint: true;\n        },\n    ): BigIntStats;\n    export function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;\n    /**\n     * Retrieves the `fs.Stats` for the symbolic link referred to by the path.\n     * The callback gets two arguments `(err, stats)` where `stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if `path` is a symbolic\n     * link, then the link itself is stat-ed, not the file that it refers to.\n     *\n     * See the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) documentation for more details.\n     * @since v0.1.30\n     */\n    export function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    export function lstat(\n        path: PathLike,\n        options:\n            | (StatOptions & {\n                bigint?: false | undefined;\n            })\n            | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,\n    ): void;\n    export function lstat(\n        path: PathLike,\n        options: StatOptions & {\n            bigint: true;\n        },\n        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,\n    ): void;\n    export function lstat(\n        path: PathLike,\n        options: StatOptions | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,\n    ): void;\n    export namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?: StatOptions & {\n                bigint?: false | undefined;\n            },\n        ): Promise<Stats>;\n        function __promisify__(\n            path: PathLike,\n            options: StatOptions & {\n                bigint: true;\n            },\n        ): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n    /**\n     * Asynchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which\n     * contains `path`. The callback gets two arguments `(err, stats)` where `stats`is an `fs.StatFs` object.\n     *\n     * In case of an error, the `err.code` will be one of `Common System Errors`.\n     * @since v19.6.0, v18.15.0\n     * @param path A path to an existing file or directory on the file system to be queried.\n     */\n    export function statfs(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void): void;\n    export function statfs(\n        path: PathLike,\n        options:\n            | (StatFsOptions & {\n                bigint?: false | undefined;\n            })\n            | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void,\n    ): void;\n    export function statfs(\n        path: PathLike,\n        options: StatFsOptions & {\n            bigint: true;\n        },\n        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStatsFs) => void,\n    ): void;\n    export function statfs(\n        path: PathLike,\n        options: StatFsOptions | undefined,\n        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs | BigIntStatsFs) => void,\n    ): void;\n    export namespace statfs {\n        /**\n         * Asynchronous statfs(2) - Returns information about the mounted file system which contains path. The callback gets two arguments (err, stats) where stats is an <fs.StatFs> object.\n         * @param path A path to an existing file or directory on the file system to be queried.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?: StatFsOptions & {\n                bigint?: false | undefined;\n            },\n        ): Promise<StatsFs>;\n        function __promisify__(\n            path: PathLike,\n            options: StatFsOptions & {\n                bigint: true;\n            },\n        ): Promise<BigIntStatsFs>;\n        function __promisify__(path: PathLike, options?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;\n    }\n    /**\n     * Synchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which\n     * contains `path`.\n     *\n     * In case of an error, the `err.code` will be one of `Common System Errors`.\n     * @since v19.6.0, v18.15.0\n     * @param path A path to an existing file or directory on the file system to be queried.\n     */\n    export function statfsSync(\n        path: PathLike,\n        options?: StatFsOptions & {\n            bigint?: false | undefined;\n        },\n    ): StatsFs;\n    export function statfsSync(\n        path: PathLike,\n        options: StatFsOptions & {\n            bigint: true;\n        },\n    ): BigIntStatsFs;\n    export function statfsSync(path: PathLike, options?: StatFsOptions): StatsFs | BigIntStatsFs;\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export const lstatSync: StatSyncFn;\n    /**\n     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. No arguments other than\n     * a possible\n     * exception are given to the completion callback.\n     * @since v0.1.31\n     */\n    export function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n    export namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n    /**\n     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.\n     * @since v0.1.31\n     */\n    export function linkSync(existingPath: PathLike, newPath: PathLike): void;\n    /**\n     * Creates the link called `path` pointing to `target`. No arguments other than a\n     * possible exception are given to the completion callback.\n     *\n     * See the POSIX [`symlink(2)`](http://man7.org/linux/man-pages/man2/symlink.2.html) documentation for more details.\n     *\n     * The `type` argument is only available on Windows and ignored on other platforms.\n     * It can be set to `'dir'`, `'file'`, or `'junction'`. If the `type` argument is\n     * not a string, Node.js will autodetect `target` type and use `'file'` or `'dir'`.\n     * If the `target` does not exist, `'file'` will be used. Windows junction points\n     * require the destination path to be absolute. When using `'junction'`, the`target` argument will automatically be normalized to absolute path. Junction\n     * points on NTFS volumes can only point to directories.\n     *\n     * Relative targets are relative to the link's parent directory.\n     *\n     * ```js\n     * import { symlink } from 'node:fs';\n     *\n     * symlink('./mew', './mewtwo', callback);\n     * ```\n     *\n     * The above example creates a symbolic link `mewtwo` which points to `mew` in the\n     * same directory:\n     *\n     * ```bash\n     * $ tree .\n     * .\n     * ├── mew\n     * └── mewtwo -> ./mew\n     * ```\n     * @since v0.1.31\n     * @param [type='null']\n     */\n    export function symlink(\n        target: PathLike,\n        path: PathLike,\n        type: symlink.Type | undefined | null,\n        callback: NoParamCallback,\n    ): void;\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;\n    export namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.\n         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).\n         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n        type Type = \"dir\" | \"file\" | \"junction\";\n    }\n    /**\n     * Returns `undefined`.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link symlink}.\n     * @since v0.1.31\n     * @param [type='null']\n     */\n    export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n    /**\n     * Reads the contents of the symbolic link referred to by `path`. The callback gets\n     * two arguments `(err, linkString)`.\n     *\n     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the link path passed to the callback. If the `encoding` is set to `'buffer'`,\n     * the link path returned will be passed as a `Buffer` object.\n     * @since v0.1.31\n     */\n    export function readlink(\n        path: PathLike,\n        options: EncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,\n    ): void;\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readlink(\n        path: PathLike,\n        options: BufferEncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void,\n    ): void;\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readlink(\n        path: PathLike,\n        options: EncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void,\n    ): void;\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function readlink(\n        path: PathLike,\n        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,\n    ): void;\n    export namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;\n    }\n    /**\n     * Returns the symbolic link's string value.\n     *\n     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the link path returned. If the `encoding` is set to `'buffer'`,\n     * the link path returned will be passed as a `Buffer` object.\n     * @since v0.1.31\n     */\n    export function readlinkSync(path: PathLike, options?: EncodingOption): string;\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;\n    /**\n     * Asynchronously computes the canonical pathname by resolving `.`, `..`, and\n     * symbolic links.\n     *\n     * A canonical pathname is not necessarily unique. Hard links and bind mounts can\n     * expose a file system entity through many pathnames.\n     *\n     * This function behaves like [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html), with some exceptions:\n     *\n     * 1. No case conversion is performed on case-insensitive file systems.\n     * 2. The maximum number of symbolic links is platform-independent and generally\n     * (much) higher than what the native [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html) implementation supports.\n     *\n     * The `callback` gets two arguments `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.\n     *\n     * Only paths that can be converted to UTF8 strings are supported.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the path passed to the callback. If the `encoding` is set to `'buffer'`,\n     * the path returned will be passed as a `Buffer` object.\n     *\n     * If `path` resolves to a socket or a pipe, the function will return a system\n     * dependent name for that object.\n     * @since v0.1.31\n     */\n    export function realpath(\n        path: PathLike,\n        options: EncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,\n    ): void;\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function realpath(\n        path: PathLike,\n        options: BufferEncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,\n    ): void;\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function realpath(\n        path: PathLike,\n        options: EncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,\n    ): void;\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function realpath(\n        path: PathLike,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,\n    ): void;\n    export namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;\n        /**\n         * Asynchronous [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html).\n         *\n         * The `callback` gets two arguments `(err, resolvedPath)`.\n         *\n         * Only paths that can be converted to UTF8 strings are supported.\n         *\n         * The optional `options` argument can be a string specifying an encoding, or an\n         * object with an `encoding` property specifying the character encoding to use for\n         * the path passed to the callback. If the `encoding` is set to `'buffer'`,\n         * the path returned will be passed as a `Buffer` object.\n         *\n         * On Linux, when Node.js is linked against musl libc, the procfs file system must\n         * be mounted on `/proc` in order for this function to work. Glibc does not have\n         * this restriction.\n         * @since v9.2.0\n         */\n        function native(\n            path: PathLike,\n            options: EncodingOption,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,\n        ): void;\n        function native(\n            path: PathLike,\n            options: BufferEncodingOption,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,\n        ): void;\n        function native(\n            path: PathLike,\n            options: EncodingOption,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,\n        ): void;\n        function native(\n            path: PathLike,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,\n        ): void;\n    }\n    /**\n     * Returns the resolved pathname.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link realpath}.\n     * @since v0.1.31\n     */\n    export function realpathSync(path: PathLike, options?: EncodingOption): string;\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;\n    export namespace realpathSync {\n        function native(path: PathLike, options?: EncodingOption): string;\n        function native(path: PathLike, options: BufferEncodingOption): Buffer;\n        function native(path: PathLike, options?: EncodingOption): string | Buffer;\n    }\n    /**\n     * Asynchronously removes a file or symbolic link. No arguments other than a\n     * possible exception are given to the completion callback.\n     *\n     * ```js\n     * import { unlink } from 'node:fs';\n     * // Assuming that 'path/file.txt' is a regular file.\n     * unlink('path/file.txt', (err) => {\n     *   if (err) throw err;\n     *   console.log('path/file.txt was deleted');\n     * });\n     * ```\n     *\n     * `fs.unlink()` will not work on a directory, empty or otherwise. To remove a\n     * directory, use {@link rmdir}.\n     *\n     * See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more details.\n     * @since v0.0.2\n     */\n    export function unlink(path: PathLike, callback: NoParamCallback): void;\n    export namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n    /**\n     * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.\n     * @since v0.1.21\n     */\n    export function unlinkSync(path: PathLike): void;\n    export interface RmDirOptions {\n        /**\n         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or\n         * `EPERM` error is encountered, Node.js will retry the operation with a linear\n         * backoff wait of `retryDelay` ms longer on each try. This option represents the\n         * number of retries. This option is ignored if the `recursive` option is not\n         * `true`.\n         * @default 0\n         */\n        maxRetries?: number | undefined;\n        /**\n         * @deprecated since v14.14.0 In future versions of Node.js and will trigger a warning\n         * `fs.rmdir(path, { recursive: true })` will throw if `path` does not exist or is a file.\n         * Use `fs.rm(path, { recursive: true, force: true })` instead.\n         *\n         * If `true`, perform a recursive directory removal. In\n         * recursive mode, operations are retried on failure.\n         * @default false\n         */\n        recursive?: boolean | undefined;\n        /**\n         * The amount of time in milliseconds to wait between retries.\n         * This option is ignored if the `recursive` option is not `true`.\n         * @default 100\n         */\n        retryDelay?: number | undefined;\n    }\n    /**\n     * Asynchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). No arguments other than a possible exception are given\n     * to the completion callback.\n     *\n     * Using `fs.rmdir()` on a file (not a directory) results in an `ENOENT` error on\n     * Windows and an `ENOTDIR` error on POSIX.\n     *\n     * To get a behavior similar to the `rm -rf` Unix command, use {@link rm} with options `{ recursive: true, force: true }`.\n     * @since v0.0.2\n     */\n    export function rmdir(path: PathLike, callback: NoParamCallback): void;\n    export function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;\n    export namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         */\n        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;\n    }\n    /**\n     * Synchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). Returns `undefined`.\n     *\n     * Using `fs.rmdirSync()` on a file (not a directory) results in an `ENOENT` error\n     * on Windows and an `ENOTDIR` error on POSIX.\n     *\n     * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.\n     * @since v0.1.21\n     */\n    export function rmdirSync(path: PathLike, options?: RmDirOptions): void;\n    export interface RmOptions {\n        /**\n         * When `true`, exceptions will be ignored if `path` does not exist.\n         * @default false\n         */\n        force?: boolean | undefined;\n        /**\n         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or\n         * `EPERM` error is encountered, Node.js will retry the operation with a linear\n         * backoff wait of `retryDelay` ms longer on each try. This option represents the\n         * number of retries. This option is ignored if the `recursive` option is not\n         * `true`.\n         * @default 0\n         */\n        maxRetries?: number | undefined;\n        /**\n         * If `true`, perform a recursive directory removal. In\n         * recursive mode, operations are retried on failure.\n         * @default false\n         */\n        recursive?: boolean | undefined;\n        /**\n         * The amount of time in milliseconds to wait between retries.\n         * This option is ignored if the `recursive` option is not `true`.\n         * @default 100\n         */\n        retryDelay?: number | undefined;\n    }\n    /**\n     * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). No arguments other than a possible exception are given to the\n     * completion callback.\n     * @since v14.14.0\n     */\n    export function rm(path: PathLike, callback: NoParamCallback): void;\n    export function rm(path: PathLike, options: RmOptions, callback: NoParamCallback): void;\n    export namespace rm {\n        /**\n         * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).\n         */\n        function __promisify__(path: PathLike, options?: RmOptions): Promise<void>;\n    }\n    /**\n     * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.\n     * @since v14.14.0\n     */\n    export function rmSync(path: PathLike, options?: RmOptions): void;\n    export interface MakeDirectoryOptions {\n        /**\n         * Indicates whether parent folders should be created.\n         * If a folder was created, the path to the first created folder will be returned.\n         * @default false\n         */\n        recursive?: boolean | undefined;\n        /**\n         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified\n         * @default 0o777\n         */\n        mode?: Mode | undefined;\n    }\n    /**\n     * Asynchronously creates a directory.\n     *\n     * The callback is given a possible exception and, if `recursive` is `true`, the\n     * first directory path created, `(err[, path])`.`path` can still be `undefined` when `recursive` is `true`, if no directory was\n     * created (for instance, if it was previously created).\n     *\n     * The optional `options` argument can be an integer specifying `mode` (permission\n     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fs.mkdir()` when `path` is a directory that\n     * exists results in an error only\n     * when `recursive` is false. If `recursive` is false and the directory exists,\n     * an `EEXIST` error occurs.\n     *\n     * ```js\n     * import { mkdir } from 'node:fs';\n     *\n     * // Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.\n     * mkdir('./tmp/a/apple', { recursive: true }, (err) => {\n     *   if (err) throw err;\n     * });\n     * ```\n     *\n     * On Windows, using `fs.mkdir()` on the root directory even with recursion will\n     * result in an error:\n     *\n     * ```js\n     * import { mkdir } from 'node:fs';\n     *\n     * mkdir('/', { recursive: true }, (err) => {\n     *   // => [Error: EPERM: operation not permitted, mkdir 'C:\\']\n     * });\n     * ```\n     *\n     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.\n     * @since v0.1.8\n     */\n    export function mkdir(\n        path: PathLike,\n        options: MakeDirectoryOptions & {\n            recursive: true;\n        },\n        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,\n    ): void;\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    export function mkdir(\n        path: PathLike,\n        options:\n            | Mode\n            | (MakeDirectoryOptions & {\n                recursive?: false | undefined;\n            })\n            | null\n            | undefined,\n        callback: NoParamCallback,\n    ): void;\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    export function mkdir(\n        path: PathLike,\n        options: Mode | MakeDirectoryOptions | null | undefined,\n        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,\n    ): void;\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function mkdir(path: PathLike, callback: NoParamCallback): void;\n    export namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(\n            path: PathLike,\n            options: MakeDirectoryOptions & {\n                recursive: true;\n            },\n        ): Promise<string | undefined>;\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?:\n                | Mode\n                | (MakeDirectoryOptions & {\n                    recursive?: false | undefined;\n                })\n                | null,\n        ): Promise<void>;\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?: Mode | MakeDirectoryOptions | null,\n        ): Promise<string | undefined>;\n    }\n    /**\n     * Synchronously creates a directory. Returns `undefined`, or if `recursive` is `true`, the first directory path created.\n     * This is the synchronous version of {@link mkdir}.\n     *\n     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.\n     * @since v0.1.21\n     */\n    export function mkdirSync(\n        path: PathLike,\n        options: MakeDirectoryOptions & {\n            recursive: true;\n        },\n    ): string | undefined;\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    export function mkdirSync(\n        path: PathLike,\n        options?:\n            | Mode\n            | (MakeDirectoryOptions & {\n                recursive?: false | undefined;\n            })\n            | null,\n    ): void;\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.\n     */\n    export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;\n    /**\n     * Creates a unique temporary directory.\n     *\n     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory. Due to platform\n     * inconsistencies, avoid trailing `X` characters in `prefix`. Some platforms,\n     * notably the BSDs, can return more than six random characters, and replace\n     * trailing `X` characters in `prefix` with random characters.\n     *\n     * The created directory path is passed as a string to the callback's second\n     * parameter.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use.\n     *\n     * ```js\n     * import { mkdtemp } from 'node:fs';\n     * import { join } from 'node:path';\n     * import { tmpdir } from 'node:os';\n     *\n     * mkdtemp(join(tmpdir(), 'foo-'), (err, directory) => {\n     *   if (err) throw err;\n     *   console.log(directory);\n     *   // Prints: /tmp/foo-itXde2 or C:\\Users\\...\\AppData\\Local\\Temp\\foo-itXde2\n     * });\n     * ```\n     *\n     * The `fs.mkdtemp()` method will append the six randomly selected characters\n     * directly to the `prefix` string. For instance, given a directory `/tmp`, if the\n     * intention is to create a temporary directory _within_`/tmp`, the `prefix`must end with a trailing platform-specific path separator\n     * (`import { sep } from 'node:path'`).\n     *\n     * ```js\n     * import { tmpdir } from 'node:os';\n     * import { mkdtemp } from 'node:fs';\n     *\n     * // The parent directory for the new temporary directory\n     * const tmpDir = tmpdir();\n     *\n     * // This method is *INCORRECT*:\n     * mkdtemp(tmpDir, (err, directory) => {\n     *   if (err) throw err;\n     *   console.log(directory);\n     *   // Will print something similar to `/tmpabc123`.\n     *   // A new temporary directory is created at the file system root\n     *   // rather than *within* the /tmp directory.\n     * });\n     *\n     * // This method is *CORRECT*:\n     * import { sep } from 'node:path';\n     * mkdtemp(`${tmpDir}${sep}`, (err, directory) => {\n     *   if (err) throw err;\n     *   console.log(directory);\n     *   // Will print something similar to `/tmp/abc123`.\n     *   // A new temporary directory is created within\n     *   // the /tmp directory.\n     * });\n     * ```\n     * @since v5.10.0\n     */\n    export function mkdtemp(\n        prefix: string,\n        options: EncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,\n    ): void;\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function mkdtemp(\n        prefix: string,\n        options:\n            | \"buffer\"\n            | {\n                encoding: \"buffer\";\n            },\n        callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void,\n    ): void;\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function mkdtemp(\n        prefix: string,\n        options: EncodingOption,\n        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void,\n    ): void;\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    export function mkdtemp(\n        prefix: string,\n        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,\n    ): void;\n    export namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: EncodingOption): Promise<string>;\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options: BufferEncodingOption): Promise<Buffer>;\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(prefix: string, options?: EncodingOption): Promise<string | Buffer>;\n    }\n    /**\n     * Returns the created directory path.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link mkdtemp}.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use.\n     * @since v5.10.0\n     */\n    export function mkdtempSync(prefix: string, options?: EncodingOption): string;\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;\n    /**\n     * Reads the contents of a directory. The callback gets two arguments `(err, files)` where `files` is an array of the names of the files in the directory excluding `'.'` and `'..'`.\n     *\n     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the filenames passed to the callback. If the `encoding` is set to `'buffer'`,\n     * the filenames returned will be passed as `Buffer` objects.\n     *\n     * If `options.withFileTypes` is set to `true`, the `files` array will contain `fs.Dirent` objects.\n     * @since v0.1.8\n     */\n    export function readdir(\n        path: PathLike,\n        options:\n            | {\n                encoding: BufferEncoding | null;\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            }\n            | BufferEncoding\n            | undefined\n            | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,\n    ): void;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readdir(\n        path: PathLike,\n        options:\n            | {\n                encoding: \"buffer\";\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            }\n            | \"buffer\",\n        callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void,\n    ): void;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readdir(\n        path: PathLike,\n        options:\n            | (ObjectEncodingOptions & {\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            })\n            | BufferEncoding\n            | undefined\n            | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,\n    ): void;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function readdir(\n        path: PathLike,\n        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,\n    ): void;\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    export function readdir(\n        path: PathLike,\n        options: ObjectEncodingOptions & {\n            withFileTypes: true;\n            recursive?: boolean | undefined;\n        },\n        callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void,\n    ): void;\n    export namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?:\n                | {\n                    encoding: BufferEncoding | null;\n                    withFileTypes?: false | undefined;\n                    recursive?: boolean | undefined;\n                }\n                | BufferEncoding\n                | null,\n        ): Promise<string[]>;\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(\n            path: PathLike,\n            options:\n                | \"buffer\"\n                | {\n                    encoding: \"buffer\";\n                    withFileTypes?: false | undefined;\n                    recursive?: boolean | undefined;\n                },\n        ): Promise<Buffer[]>;\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n         */\n        function __promisify__(\n            path: PathLike,\n            options?:\n                | (ObjectEncodingOptions & {\n                    withFileTypes?: false | undefined;\n                    recursive?: boolean | undefined;\n                })\n                | BufferEncoding\n                | null,\n        ): Promise<string[] | Buffer[]>;\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent\n         */\n        function __promisify__(\n            path: PathLike,\n            options: ObjectEncodingOptions & {\n                withFileTypes: true;\n                recursive?: boolean | undefined;\n            },\n        ): Promise<Dirent[]>;\n    }\n    /**\n     * Reads the contents of the directory.\n     *\n     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.\n     *\n     * The optional `options` argument can be a string specifying an encoding, or an\n     * object with an `encoding` property specifying the character encoding to use for\n     * the filenames returned. If the `encoding` is set to `'buffer'`,\n     * the filenames returned will be passed as `Buffer` objects.\n     *\n     * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.\n     * @since v0.1.21\n     */\n    export function readdirSync(\n        path: PathLike,\n        options?:\n            | {\n                encoding: BufferEncoding | null;\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            }\n            | BufferEncoding\n            | null,\n    ): string[];\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readdirSync(\n        path: PathLike,\n        options:\n            | {\n                encoding: \"buffer\";\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            }\n            | \"buffer\",\n    ): Buffer[];\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.\n     */\n    export function readdirSync(\n        path: PathLike,\n        options?:\n            | (ObjectEncodingOptions & {\n                withFileTypes?: false | undefined;\n                recursive?: boolean | undefined;\n            })\n            | BufferEncoding\n            | null,\n    ): string[] | Buffer[];\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.\n     */\n    export function readdirSync(\n        path: PathLike,\n        options: ObjectEncodingOptions & {\n            withFileTypes: true;\n            recursive?: boolean | undefined;\n        },\n    ): Dirent[];\n    /**\n     * Closes the file descriptor. No arguments other than a possible exception are\n     * given to the completion callback.\n     *\n     * Calling `fs.close()` on any file descriptor (`fd`) that is currently in use\n     * through any other `fs` operation may lead to undefined behavior.\n     *\n     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.\n     * @since v0.0.2\n     */\n    export function close(fd: number, callback?: NoParamCallback): void;\n    export namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n    /**\n     * Closes the file descriptor. Returns `undefined`.\n     *\n     * Calling `fs.closeSync()` on any file descriptor (`fd`) that is currently in use\n     * through any other `fs` operation may lead to undefined behavior.\n     *\n     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.\n     * @since v0.1.21\n     */\n    export function closeSync(fd: number): void;\n    /**\n     * Asynchronous file open. See the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more details.\n     *\n     * `mode` sets the file mode (permission and sticky bits), but only if the file was\n     * created. On Windows, only the write permission can be manipulated; see {@link chmod}.\n     *\n     * The callback gets two arguments `(err, fd)`.\n     *\n     * Some characters (`< > : \" / \\ | ? *`) are reserved under Windows as documented\n     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains\n     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).\n     *\n     * Functions based on `fs.open()` exhibit this behavior as well:`fs.writeFile()`, `fs.readFile()`, etc.\n     * @since v0.0.2\n     * @param [flags='r'] See `support of file system `flags``.\n     * @param [mode=0o666]\n     */\n    export function open(\n        path: PathLike,\n        flags: OpenMode | undefined,\n        mode: Mode | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,\n    ): void;\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * @param [flags='r'] See `support of file system `flags``.\n     */\n    export function open(\n        path: PathLike,\n        flags: OpenMode | undefined,\n        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,\n    ): void;\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function open(path: PathLike, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n    export namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.\n         */\n        function __promisify__(path: PathLike, flags: OpenMode, mode?: Mode | null): Promise<number>;\n    }\n    /**\n     * Returns an integer representing the file descriptor.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link open}.\n     * @since v0.1.21\n     * @param [flags='r']\n     * @param [mode=0o666]\n     */\n    export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;\n    /**\n     * Change the file system timestamps of the object referenced by `path`.\n     *\n     * The `atime` and `mtime` arguments follow these rules:\n     *\n     * * Values can be either numbers representing Unix epoch time in seconds, `Date`s, or a numeric string like `'123456789.0'`.\n     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.\n     * @since v0.4.2\n     */\n    export function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;\n    export namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;\n    }\n    /**\n     * Returns `undefined`.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link utimes}.\n     * @since v0.4.2\n     */\n    export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;\n    /**\n     * Change the file system timestamps of the object referenced by the supplied file\n     * descriptor. See {@link utimes}.\n     * @since v0.4.2\n     */\n    export function futimes(fd: number, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;\n    export namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: TimeLike, mtime: TimeLike): Promise<void>;\n    }\n    /**\n     * Synchronous version of {@link futimes}. Returns `undefined`.\n     * @since v0.4.2\n     */\n    export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;\n    /**\n     * Request that all data for the open file descriptor is flushed to the storage\n     * device. The specific implementation is operating system and device specific.\n     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. No arguments other\n     * than a possible exception are given to the completion callback.\n     * @since v0.1.96\n     */\n    export function fsync(fd: number, callback: NoParamCallback): void;\n    export namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n    /**\n     * Request that all data for the open file descriptor is flushed to the storage\n     * device. The specific implementation is operating system and device specific.\n     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.\n     * @since v0.1.96\n     */\n    export function fsyncSync(fd: number): void;\n    /**\n     * Write `buffer` to the file specified by `fd`.\n     *\n     * `offset` determines the part of the buffer to be written, and `length` is\n     * an integer specifying the number of bytes to write.\n     *\n     * `position` refers to the offset from the beginning of the file where this data\n     * should be written. If `typeof position !== 'number'`, the data will be written\n     * at the current position. See [`pwrite(2)`](http://man7.org/linux/man-pages/man2/pwrite.2.html).\n     *\n     * The callback will be given three arguments `(err, bytesWritten, buffer)` where `bytesWritten` specifies how many _bytes_ were written from `buffer`.\n     *\n     * If this method is invoked as its `util.promisify()` ed version, it returns\n     * a promise for an `Object` with `bytesWritten` and `buffer` properties.\n     *\n     * It is unsafe to use `fs.write()` multiple times on the same file without waiting\n     * for the callback. For this scenario, {@link createWriteStream} is\n     * recommended.\n     *\n     * On Linux, positional writes don't work when the file is opened in append mode.\n     * The kernel ignores the position argument and always appends the data to\n     * the end of the file.\n     * @since v0.0.2\n     * @param [offset=0]\n     * @param [length=buffer.byteLength - offset]\n     * @param [position='null']\n     */\n    export function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n     */\n    export function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n     */\n    export function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n    /**\n     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    export function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    export function write(\n        fd: number,\n        string: string,\n        position: number | undefined | null,\n        encoding: BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,\n    ): void;\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    export function write(\n        fd: number,\n        string: string,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,\n    ): void;\n    /**\n     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write.\n     */\n    export function write(\n        fd: number,\n        string: string,\n        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,\n    ): void;\n    export namespace write {\n        /**\n         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.\n         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{\n            bytesWritten: number;\n            buffer: TBuffer;\n        }>;\n        /**\n         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(\n            fd: number,\n            string: string,\n            position?: number | null,\n            encoding?: BufferEncoding | null,\n        ): Promise<{\n            bytesWritten: number;\n            buffer: string;\n        }>;\n    }\n    /**\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link write}.\n     * @since v0.1.21\n     * @param [offset=0]\n     * @param [length=buffer.byteLength - offset]\n     * @param [position='null']\n     * @return The number of bytes written.\n     */\n    export function writeSync(\n        fd: number,\n        buffer: NodeJS.ArrayBufferView,\n        offset?: number | null,\n        length?: number | null,\n        position?: number | null,\n    ): number;\n    /**\n     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    export function writeSync(\n        fd: number,\n        string: string,\n        position?: number | null,\n        encoding?: BufferEncoding | null,\n    ): number;\n    export type ReadPosition = number | bigint;\n    export interface ReadSyncOptions {\n        /**\n         * @default 0\n         */\n        offset?: number | undefined;\n        /**\n         * @default `length of buffer`\n         */\n        length?: number | undefined;\n        /**\n         * @default null\n         */\n        position?: ReadPosition | null | undefined;\n    }\n    export interface ReadAsyncOptions<TBuffer extends NodeJS.ArrayBufferView> extends ReadSyncOptions {\n        buffer?: TBuffer;\n    }\n    /**\n     * Read data from the file specified by `fd`.\n     *\n     * The callback is given the three arguments, `(err, bytesRead, buffer)`.\n     *\n     * If the file is not modified concurrently, the end-of-file is reached when the\n     * number of bytes read is zero.\n     *\n     * If this method is invoked as its `util.promisify()` ed version, it returns\n     * a promise for an `Object` with `bytesRead` and `buffer` properties.\n     * @since v0.0.2\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The position in `buffer` to write the data to.\n     * @param length The number of bytes to read.\n     * @param position Specifies where to begin reading from in the file. If `position` is `null` or `-1 `, data will be read from the current file position, and the file position will be updated. If\n     * `position` is an integer, the file position will be unchanged.\n     */\n    export function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: ReadPosition | null,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n    /**\n     * Similar to the above `fs.read` function, this version takes an optional `options` object.\n     * If not otherwise specified in an `options` object,\n     * `buffer` defaults to `Buffer.alloc(16384)`,\n     * `offset` defaults to `0`,\n     * `length` defaults to `buffer.byteLength`, `- offset` as of Node 17.6.0\n     * `position` defaults to `null`\n     * @since v12.17.0, 13.11.0\n     */\n    export function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        options: ReadAsyncOptions<TBuffer>,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n    export function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        options: ReadSyncOptions,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n    export function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n    export function read(\n        fd: number,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: NodeJS.ArrayBufferView) => void,\n    ): void;\n    export namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer: TBuffer,\n            offset: number,\n            length: number,\n            position: number | null,\n        ): Promise<{\n            bytesRead: number;\n            buffer: TBuffer;\n        }>;\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            options: ReadAsyncOptions<TBuffer>,\n        ): Promise<{\n            bytesRead: number;\n            buffer: TBuffer;\n        }>;\n        function __promisify__(fd: number): Promise<{\n            bytesRead: number;\n            buffer: NodeJS.ArrayBufferView;\n        }>;\n    }\n    /**\n     * Returns the number of `bytesRead`.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link read}.\n     * @since v0.1.21\n     * @param [position='null']\n     */\n    export function readSync(\n        fd: number,\n        buffer: NodeJS.ArrayBufferView,\n        offset: number,\n        length: number,\n        position: ReadPosition | null,\n    ): number;\n    /**\n     * Similar to the above `fs.readSync` function, this version takes an optional `options` object.\n     * If no `options` object is specified, it will default with the above values.\n     */\n    export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     *\n     * ```js\n     * import { readFile } from 'node:fs';\n     *\n     * readFile('/etc/passwd', (err, data) => {\n     *   if (err) throw err;\n     *   console.log(data);\n     * });\n     * ```\n     *\n     * The callback is passed two arguments `(err, data)`, where `data` is the\n     * contents of the file.\n     *\n     * If no encoding is specified, then the raw buffer is returned.\n     *\n     * If `options` is a string, then it specifies the encoding:\n     *\n     * ```js\n     * import { readFile } from 'node:fs';\n     *\n     * readFile('/etc/passwd', 'utf8', callback);\n     * ```\n     *\n     * When the path is a directory, the behavior of `fs.readFile()` and {@link readFileSync} is platform-specific. On macOS, Linux, and Windows, an\n     * error will be returned. On FreeBSD, a representation of the directory's contents\n     * will be returned.\n     *\n     * ```js\n     * import { readFile } from 'node:fs';\n     *\n     * // macOS, Linux, and Windows\n     * readFile('<directory>', (err, data) => {\n     *   // => [Error: EISDIR: illegal operation on a directory, read <directory>]\n     * });\n     *\n     * //  FreeBSD\n     * readFile('<directory>', (err, data) => {\n     *   // => null, <data>\n     * });\n     * ```\n     *\n     * It is possible to abort an ongoing request using an `AbortSignal`. If a\n     * request is aborted the callback is called with an `AbortError`:\n     *\n     * ```js\n     * import { readFile } from 'node:fs';\n     *\n     * const controller = new AbortController();\n     * const signal = controller.signal;\n     * readFile(fileInfo[0].name, { signal }, (err, buf) => {\n     *   // ...\n     * });\n     * // When you want to abort the request\n     * controller.abort();\n     * ```\n     *\n     * The `fs.readFile()` function buffers the entire file. To minimize memory costs,\n     * when possible prefer streaming via `fs.createReadStream()`.\n     *\n     * Aborting an ongoing request does not abort individual operating\n     * system requests but rather the internal buffering `fs.readFile` performs.\n     * @since v0.1.29\n     * @param path filename or file descriptor\n     */\n    export function readFile(\n        path: PathOrFileDescriptor,\n        options:\n            | ({\n                encoding?: null | undefined;\n                flag?: string | undefined;\n            } & Abortable)\n            | undefined\n            | null,\n        callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void,\n    ): void;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    export function readFile(\n        path: PathOrFileDescriptor,\n        options:\n            | ({\n                encoding: BufferEncoding;\n                flag?: string | undefined;\n            } & Abortable)\n            | BufferEncoding,\n        callback: (err: NodeJS.ErrnoException | null, data: string) => void,\n    ): void;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    export function readFile(\n        path: PathOrFileDescriptor,\n        options:\n            | (ObjectEncodingOptions & {\n                flag?: string | undefined;\n            } & Abortable)\n            | BufferEncoding\n            | undefined\n            | null,\n        callback: (err: NodeJS.ErrnoException | null, data: string | Buffer) => void,\n    ): void;\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    export function readFile(\n        path: PathOrFileDescriptor,\n        callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void,\n    ): void;\n    export namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(\n            path: PathOrFileDescriptor,\n            options?: {\n                encoding?: null | undefined;\n                flag?: string | undefined;\n            } | null,\n        ): Promise<Buffer>;\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(\n            path: PathOrFileDescriptor,\n            options:\n                | {\n                    encoding: BufferEncoding;\n                    flag?: string | undefined;\n                }\n                | BufferEncoding,\n        ): Promise<string>;\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to `'r'`.\n         */\n        function __promisify__(\n            path: PathOrFileDescriptor,\n            options?:\n                | (ObjectEncodingOptions & {\n                    flag?: string | undefined;\n                })\n                | BufferEncoding\n                | null,\n        ): Promise<string | Buffer>;\n    }\n    /**\n     * Returns the contents of the `path`.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link readFile}.\n     *\n     * If the `encoding` option is specified then this function returns a\n     * string. Otherwise it returns a buffer.\n     *\n     * Similar to {@link readFile}, when the path is a directory, the behavior of `fs.readFileSync()` is platform-specific.\n     *\n     * ```js\n     * import { readFileSync } from 'node:fs';\n     *\n     * // macOS, Linux, and Windows\n     * readFileSync('<directory>');\n     * // => [Error: EISDIR: illegal operation on a directory, read <directory>]\n     *\n     * //  FreeBSD\n     * readFileSync('<directory>'); // => <data>\n     * ```\n     * @since v0.1.8\n     * @param path filename or file descriptor\n     */\n    export function readFileSync(\n        path: PathOrFileDescriptor,\n        options?: {\n            encoding?: null | undefined;\n            flag?: string | undefined;\n        } | null,\n    ): Buffer;\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    export function readFileSync(\n        path: PathOrFileDescriptor,\n        options:\n            | {\n                encoding: BufferEncoding;\n                flag?: string | undefined;\n            }\n            | BufferEncoding,\n    ): string;\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to `'r'`.\n     */\n    export function readFileSync(\n        path: PathOrFileDescriptor,\n        options?:\n            | (ObjectEncodingOptions & {\n                flag?: string | undefined;\n            })\n            | BufferEncoding\n            | null,\n    ): string | Buffer;\n    export type WriteFileOptions =\n        | (\n            & ObjectEncodingOptions\n            & Abortable\n            & {\n                mode?: Mode | undefined;\n                flag?: string | undefined;\n                flush?: boolean | undefined;\n            }\n        )\n        | BufferEncoding\n        | null;\n    /**\n     * When `file` is a filename, asynchronously writes data to the file, replacing the\n     * file if it already exists. `data` can be a string or a buffer.\n     *\n     * When `file` is a file descriptor, the behavior is similar to calling `fs.write()` directly (which is recommended). See the notes below on using\n     * a file descriptor.\n     *\n     * The `encoding` option is ignored if `data` is a buffer.\n     *\n     * The `mode` option only affects the newly created file. See {@link open} for more details.\n     *\n     * ```js\n     * import { writeFile } from 'node:fs';\n     * import { Buffer } from 'node:buffer';\n     *\n     * const data = new Uint8Array(Buffer.from('Hello Node.js'));\n     * writeFile('message.txt', data, (err) => {\n     *   if (err) throw err;\n     *   console.log('The file has been saved!');\n     * });\n     * ```\n     *\n     * If `options` is a string, then it specifies the encoding:\n     *\n     * ```js\n     * import { writeFile } from 'node:fs';\n     *\n     * writeFile('message.txt', 'Hello Node.js', 'utf8', callback);\n     * ```\n     *\n     * It is unsafe to use `fs.writeFile()` multiple times on the same file without\n     * waiting for the callback. For this scenario, {@link createWriteStream} is\n     * recommended.\n     *\n     * Similarly to `fs.readFile` \\- `fs.writeFile` is a convenience method that\n     * performs multiple `write` calls internally to write the buffer passed to it.\n     * For performance sensitive code consider using {@link createWriteStream}.\n     *\n     * It is possible to use an `AbortSignal` to cancel an `fs.writeFile()`.\n     * Cancelation is \"best effort\", and some amount of data is likely still\n     * to be written.\n     *\n     * ```js\n     * import { writeFile } from 'node:fs';\n     * import { Buffer } from 'node:buffer';\n     *\n     * const controller = new AbortController();\n     * const { signal } = controller;\n     * const data = new Uint8Array(Buffer.from('Hello Node.js'));\n     * writeFile('message.txt', data, { signal }, (err) => {\n     *   // When a request is aborted - the callback is called with an AbortError\n     * });\n     * // When the request should be aborted\n     * controller.abort();\n     * ```\n     *\n     * Aborting an ongoing request does not abort individual operating\n     * system requests but rather the internal buffering `fs.writeFile` performs.\n     * @since v0.1.29\n     * @param file filename or file descriptor\n     */\n    export function writeFile(\n        file: PathOrFileDescriptor,\n        data: string | NodeJS.ArrayBufferView,\n        options: WriteFileOptions,\n        callback: NoParamCallback,\n    ): void;\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    export function writeFile(\n        path: PathOrFileDescriptor,\n        data: string | NodeJS.ArrayBufferView,\n        callback: NoParamCallback,\n    ): void;\n    export namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'w'` is used.\n         */\n        function __promisify__(\n            path: PathOrFileDescriptor,\n            data: string | NodeJS.ArrayBufferView,\n            options?: WriteFileOptions,\n        ): Promise<void>;\n    }\n    /**\n     * Returns `undefined`.\n     *\n     * The `mode` option only affects the newly created file. See {@link open} for more details.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link writeFile}.\n     * @since v0.1.29\n     * @param file filename or file descriptor\n     */\n    export function writeFileSync(\n        file: PathOrFileDescriptor,\n        data: string | NodeJS.ArrayBufferView,\n        options?: WriteFileOptions,\n    ): void;\n    /**\n     * Asynchronously append data to a file, creating the file if it does not yet\n     * exist. `data` can be a string or a `Buffer`.\n     *\n     * The `mode` option only affects the newly created file. See {@link open} for more details.\n     *\n     * ```js\n     * import { appendFile } from 'node:fs';\n     *\n     * appendFile('message.txt', 'data to append', (err) => {\n     *   if (err) throw err;\n     *   console.log('The \"data to append\" was appended to file!');\n     * });\n     * ```\n     *\n     * If `options` is a string, then it specifies the encoding:\n     *\n     * ```js\n     * import { appendFile } from 'node:fs';\n     *\n     * appendFile('message.txt', 'data to append', 'utf8', callback);\n     * ```\n     *\n     * The `path` may be specified as a numeric file descriptor that has been opened\n     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will\n     * not be closed automatically.\n     *\n     * ```js\n     * import { open, close, appendFile } from 'node:fs';\n     *\n     * function closeFd(fd) {\n     *   close(fd, (err) => {\n     *     if (err) throw err;\n     *   });\n     * }\n     *\n     * open('message.txt', 'a', (err, fd) => {\n     *   if (err) throw err;\n     *\n     *   try {\n     *     appendFile(fd, 'data to append', 'utf8', (err) => {\n     *       closeFd(fd);\n     *       if (err) throw err;\n     *     });\n     *   } catch (err) {\n     *     closeFd(fd);\n     *     throw err;\n     *   }\n     * });\n     * ```\n     * @since v0.6.7\n     * @param path filename or file descriptor\n     */\n    export function appendFile(\n        path: PathOrFileDescriptor,\n        data: string | Uint8Array,\n        options: WriteFileOptions,\n        callback: NoParamCallback,\n    ): void;\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    export function appendFile(file: PathOrFileDescriptor, data: string | Uint8Array, callback: NoParamCallback): void;\n    export namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If `encoding` is not supplied, the default of `'utf8'` is used.\n         * If `mode` is not supplied, the default of `0o666` is used.\n         * If `mode` is a string, it is parsed as an octal integer.\n         * If `flag` is not supplied, the default of `'a'` is used.\n         */\n        function __promisify__(\n            file: PathOrFileDescriptor,\n            data: string | Uint8Array,\n            options?: WriteFileOptions,\n        ): Promise<void>;\n    }\n    /**\n     * Synchronously append data to a file, creating the file if it does not yet\n     * exist. `data` can be a string or a `Buffer`.\n     *\n     * The `mode` option only affects the newly created file. See {@link open} for more details.\n     *\n     * ```js\n     * import { appendFileSync } from 'node:fs';\n     *\n     * try {\n     *   appendFileSync('message.txt', 'data to append');\n     *   console.log('The \"data to append\" was appended to file!');\n     * } catch (err) {\n     *   // Handle the error\n     * }\n     * ```\n     *\n     * If `options` is a string, then it specifies the encoding:\n     *\n     * ```js\n     * import { appendFileSync } from 'node:fs';\n     *\n     * appendFileSync('message.txt', 'data to append', 'utf8');\n     * ```\n     *\n     * The `path` may be specified as a numeric file descriptor that has been opened\n     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will\n     * not be closed automatically.\n     *\n     * ```js\n     * import { openSync, closeSync, appendFileSync } from 'node:fs';\n     *\n     * let fd;\n     *\n     * try {\n     *   fd = openSync('message.txt', 'a');\n     *   appendFileSync(fd, 'data to append', 'utf8');\n     * } catch (err) {\n     *   // Handle the error\n     * } finally {\n     *   if (fd !== undefined)\n     *     closeSync(fd);\n     * }\n     * ```\n     * @since v0.6.7\n     * @param path filename or file descriptor\n     */\n    export function appendFileSync(\n        path: PathOrFileDescriptor,\n        data: string | Uint8Array,\n        options?: WriteFileOptions,\n    ): void;\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each\n     * time the file is accessed.\n     *\n     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates\n     * whether the process should continue to run as long as files are being watched.\n     * The `options` object may specify an `interval` property indicating how often the\n     * target should be polled in milliseconds.\n     *\n     * The `listener` gets two arguments the current stat object and the previous\n     * stat object:\n     *\n     * ```js\n     * import { watchFile } from 'node:fs';\n     *\n     * watchFile('message.text', (curr, prev) => {\n     *   console.log(`the current mtime is: ${curr.mtime}`);\n     *   console.log(`the previous mtime was: ${prev.mtime}`);\n     * });\n     * ```\n     *\n     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,\n     * the numeric values in these objects are specified as `BigInt`s.\n     *\n     * To be notified when the file was modified, not just accessed, it is necessary\n     * to compare `curr.mtimeMs` and `prev.mtimeMs`.\n     *\n     * When an `fs.watchFile` operation results in an `ENOENT` error, it\n     * will invoke the listener once, with all the fields zeroed (or, for dates, the\n     * Unix Epoch). If the file is created later on, the listener will be called\n     * again, with the latest stat objects. This is a change in functionality since\n     * v0.10.\n     *\n     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.\n     *\n     * When a file being watched by `fs.watchFile()` disappears and reappears,\n     * then the contents of `previous` in the second callback event (the file's\n     * reappearance) will be the same as the contents of `previous` in the first\n     * callback event (its disappearance).\n     *\n     * This happens when:\n     *\n     * * the file is deleted, followed by a restore\n     * * the file is renamed and then renamed a second time back to its original name\n     * @since v0.1.31\n     */\n    export interface WatchFileOptions {\n        bigint?: boolean | undefined;\n        persistent?: boolean | undefined;\n        interval?: number | undefined;\n    }\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each\n     * time the file is accessed.\n     *\n     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates\n     * whether the process should continue to run as long as files are being watched.\n     * The `options` object may specify an `interval` property indicating how often the\n     * target should be polled in milliseconds.\n     *\n     * The `listener` gets two arguments the current stat object and the previous\n     * stat object:\n     *\n     * ```js\n     * import { watchFile } from 'node:fs';\n     *\n     * watchFile('message.text', (curr, prev) => {\n     *   console.log(`the current mtime is: ${curr.mtime}`);\n     *   console.log(`the previous mtime was: ${prev.mtime}`);\n     * });\n     * ```\n     *\n     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,\n     * the numeric values in these objects are specified as `BigInt`s.\n     *\n     * To be notified when the file was modified, not just accessed, it is necessary\n     * to compare `curr.mtimeMs` and `prev.mtimeMs`.\n     *\n     * When an `fs.watchFile` operation results in an `ENOENT` error, it\n     * will invoke the listener once, with all the fields zeroed (or, for dates, the\n     * Unix Epoch). If the file is created later on, the listener will be called\n     * again, with the latest stat objects. This is a change in functionality since\n     * v0.10.\n     *\n     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.\n     *\n     * When a file being watched by `fs.watchFile()` disappears and reappears,\n     * then the contents of `previous` in the second callback event (the file's\n     * reappearance) will be the same as the contents of `previous` in the first\n     * callback event (its disappearance).\n     *\n     * This happens when:\n     *\n     * * the file is deleted, followed by a restore\n     * * the file is renamed and then renamed a second time back to its original name\n     * @since v0.1.31\n     */\n    export function watchFile(\n        filename: PathLike,\n        options:\n            | (WatchFileOptions & {\n                bigint?: false | undefined;\n            })\n            | undefined,\n        listener: StatsListener,\n    ): StatWatcher;\n    export function watchFile(\n        filename: PathLike,\n        options:\n            | (WatchFileOptions & {\n                bigint: true;\n            })\n            | undefined,\n        listener: BigIntStatsListener,\n    ): StatWatcher;\n    /**\n     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function watchFile(filename: PathLike, listener: StatsListener): StatWatcher;\n    /**\n     * Stop watching for changes on `filename`. If `listener` is specified, only that\n     * particular listener is removed. Otherwise, _all_ listeners are removed,\n     * effectively stopping watching of `filename`.\n     *\n     * Calling `fs.unwatchFile()` with a filename that is not being watched is a\n     * no-op, not an error.\n     *\n     * Using {@link watch} is more efficient than `fs.watchFile()` and `fs.unwatchFile()`. `fs.watch()` should be used instead of `fs.watchFile()` and `fs.unwatchFile()` when possible.\n     * @since v0.1.31\n     * @param listener Optional, a listener previously attached using `fs.watchFile()`\n     */\n    export function unwatchFile(filename: PathLike, listener?: StatsListener): void;\n    export function unwatchFile(filename: PathLike, listener?: BigIntStatsListener): void;\n    export interface WatchOptions extends Abortable {\n        encoding?: BufferEncoding | \"buffer\" | undefined;\n        persistent?: boolean | undefined;\n        recursive?: boolean | undefined;\n    }\n    export type WatchEventType = \"rename\" | \"change\";\n    export type WatchListener<T> = (event: WatchEventType, filename: T | null) => void;\n    export type StatsListener = (curr: Stats, prev: Stats) => void;\n    export type BigIntStatsListener = (curr: BigIntStats, prev: BigIntStats) => void;\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a\n     * directory.\n     *\n     * The second argument is optional. If `options` is provided as a string, it\n     * specifies the `encoding`. Otherwise `options` should be passed as an object.\n     *\n     * The listener callback gets two arguments `(eventType, filename)`. `eventType`is either `'rename'` or `'change'`, and `filename` is the name of the file\n     * which triggered the event.\n     *\n     * On most platforms, `'rename'` is emitted whenever a filename appears or\n     * disappears in the directory.\n     *\n     * The listener callback is attached to the `'change'` event fired by `fs.FSWatcher`, but it is not the same thing as the `'change'` value of `eventType`.\n     *\n     * If a `signal` is passed, aborting the corresponding AbortController will close\n     * the returned `fs.FSWatcher`.\n     * @since v0.5.10\n     * @param listener\n     */\n    export function watch(\n        filename: PathLike,\n        options:\n            | (WatchOptions & {\n                encoding: \"buffer\";\n            })\n            | \"buffer\",\n        listener?: WatchListener<Buffer>,\n    ): FSWatcher;\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    export function watch(\n        filename: PathLike,\n        options?: WatchOptions | BufferEncoding | null,\n        listener?: WatchListener<string>,\n    ): FSWatcher;\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If `encoding` is not supplied, the default of `'utf8'` is used.\n     * If `persistent` is not supplied, the default of `true` is used.\n     * If `recursive` is not supplied, the default of `false` is used.\n     */\n    export function watch(\n        filename: PathLike,\n        options: WatchOptions | string,\n        listener?: WatchListener<string | Buffer>,\n    ): FSWatcher;\n    /**\n     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function watch(filename: PathLike, listener?: WatchListener<string>): FSWatcher;\n    /**\n     * Test whether or not the given path exists by checking with the file system.\n     * Then call the `callback` argument with either true or false:\n     *\n     * ```js\n     * import { exists } from 'node:fs';\n     *\n     * exists('/etc/passwd', (e) => {\n     *   console.log(e ? 'it exists' : 'no passwd!');\n     * });\n     * ```\n     *\n     * **The parameters for this callback are not consistent with other Node.js**\n     * **callbacks.** Normally, the first parameter to a Node.js callback is an `err` parameter, optionally followed by other parameters. The `fs.exists()` callback\n     * has only one boolean parameter. This is one reason `fs.access()` is recommended\n     * instead of `fs.exists()`.\n     *\n     * Using `fs.exists()` to check for the existence of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended. Doing\n     * so introduces a race condition, since other processes may change the file's\n     * state between the two calls. Instead, user code should open/read/write the\n     * file directly and handle the error raised if the file does not exist.\n     *\n     * **write (NOT RECOMMENDED)**\n     *\n     * ```js\n     * import { exists, open, close } from 'node:fs';\n     *\n     * exists('myfile', (e) => {\n     *   if (e) {\n     *     console.error('myfile already exists');\n     *   } else {\n     *     open('myfile', 'wx', (err, fd) => {\n     *       if (err) throw err;\n     *\n     *       try {\n     *         writeMyData(fd);\n     *       } finally {\n     *         close(fd, (err) => {\n     *           if (err) throw err;\n     *         });\n     *       }\n     *     });\n     *   }\n     * });\n     * ```\n     *\n     * **write (RECOMMENDED)**\n     *\n     * ```js\n     * import { open, close } from 'node:fs';\n     * open('myfile', 'wx', (err, fd) => {\n     *   if (err) {\n     *     if (err.code === 'EEXIST') {\n     *       console.error('myfile already exists');\n     *       return;\n     *     }\n     *\n     *     throw err;\n     *   }\n     *\n     *   try {\n     *     writeMyData(fd);\n     *   } finally {\n     *     close(fd, (err) => {\n     *       if (err) throw err;\n     *     });\n     *   }\n     * });\n     * ```\n     *\n     * **read (NOT RECOMMENDED)**\n     *\n     * ```js\n     * import { open, close, exists } from 'node:fs';\n     *\n     * exists('myfile', (e) => {\n     *   if (e) {\n     *     open('myfile', 'r', (err, fd) => {\n     *       if (err) throw err;\n     *\n     *       try {\n     *         readMyData(fd);\n     *       } finally {\n     *         close(fd, (err) => {\n     *           if (err) throw err;\n     *         });\n     *       }\n     *     });\n     *   } else {\n     *     console.error('myfile does not exist');\n     *   }\n     * });\n     * ```\n     *\n     * **read (RECOMMENDED)**\n     *\n     * ```js\n     * import { open, close } from 'node:fs';\n     *\n     * open('myfile', 'r', (err, fd) => {\n     *   if (err) {\n     *     if (err.code === 'ENOENT') {\n     *       console.error('myfile does not exist');\n     *       return;\n     *     }\n     *\n     *     throw err;\n     *   }\n     *\n     *   try {\n     *     readMyData(fd);\n     *   } finally {\n     *     close(fd, (err) => {\n     *       if (err) throw err;\n     *     });\n     *   }\n     * });\n     * ```\n     *\n     * The \"not recommended\" examples above check for existence and then use the\n     * file; the \"recommended\" examples are better because they use the file directly\n     * and handle the error, if any.\n     *\n     * In general, check for the existence of a file only if the file won't be\n     * used directly, for example when its existence is a signal from another\n     * process.\n     * @since v0.0.2\n     * @deprecated Since v1.0.0 - Use {@link stat} or {@link access} instead.\n     */\n    export function exists(path: PathLike, callback: (exists: boolean) => void): void;\n    /** @deprecated */\n    export namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n    /**\n     * Returns `true` if the path exists, `false` otherwise.\n     *\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link exists}.\n     *\n     * `fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback` parameter to `fs.exists()` accepts parameters that are inconsistent with other\n     * Node.js callbacks. `fs.existsSync()` does not use a callback.\n     *\n     * ```js\n     * import { existsSync } from 'node:fs';\n     *\n     * if (existsSync('/etc/passwd'))\n     *   console.log('The path exists.');\n     * ```\n     * @since v0.1.21\n     */\n    export function existsSync(path: PathLike): boolean;\n    export namespace constants {\n        // File Access Constants\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n        // File Copy Constants\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n        // File Open Constants\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n        // File Type Constants\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\n        const S_IFREG: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\n        const S_IFDIR: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\n        const S_IFSOCK: number;\n        // File Mode Constants\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n        /**\n         * When set, a memory file mapping is used to access the file. This flag\n         * is available on Windows operating systems only. On other operating systems,\n         * this flag is ignored.\n         */\n        const UV_FS_O_FILEMAP: number;\n    }\n    /**\n     * Tests a user's permissions for the file or directory specified by `path`.\n     * The `mode` argument is an optional integer that specifies the accessibility\n     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`\n     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for\n     * possible values of `mode`.\n     *\n     * The final argument, `callback`, is a callback function that is invoked with\n     * a possible error argument. If any of the accessibility checks fail, the error\n     * argument will be an `Error` object. The following examples check if `package.json` exists, and if it is readable or writable.\n     *\n     * ```js\n     * import { access, constants } from 'node:fs';\n     *\n     * const file = 'package.json';\n     *\n     * // Check if the file exists in the current directory.\n     * access(file, constants.F_OK, (err) => {\n     *   console.log(`${file} ${err ? 'does not exist' : 'exists'}`);\n     * });\n     *\n     * // Check if the file is readable.\n     * access(file, constants.R_OK, (err) => {\n     *   console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);\n     * });\n     *\n     * // Check if the file is writable.\n     * access(file, constants.W_OK, (err) => {\n     *   console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);\n     * });\n     *\n     * // Check if the file is readable and writable.\n     * access(file, constants.R_OK | constants.W_OK, (err) => {\n     *   console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);\n     * });\n     * ```\n     *\n     * Do not use `fs.access()` to check for the accessibility of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()`. Doing\n     * so introduces a race condition, since other processes may change the file's\n     * state between the two calls. Instead, user code should open/read/write the\n     * file directly and handle the error raised if the file is not accessible.\n     *\n     * **write (NOT RECOMMENDED)**\n     *\n     * ```js\n     * import { access, open, close } from 'node:fs';\n     *\n     * access('myfile', (err) => {\n     *   if (!err) {\n     *     console.error('myfile already exists');\n     *     return;\n     *   }\n     *\n     *   open('myfile', 'wx', (err, fd) => {\n     *     if (err) throw err;\n     *\n     *     try {\n     *       writeMyData(fd);\n     *     } finally {\n     *       close(fd, (err) => {\n     *         if (err) throw err;\n     *       });\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * **write (RECOMMENDED)**\n     *\n     * ```js\n     * import { open, close } from 'node:fs';\n     *\n     * open('myfile', 'wx', (err, fd) => {\n     *   if (err) {\n     *     if (err.code === 'EEXIST') {\n     *       console.error('myfile already exists');\n     *       return;\n     *     }\n     *\n     *     throw err;\n     *   }\n     *\n     *   try {\n     *     writeMyData(fd);\n     *   } finally {\n     *     close(fd, (err) => {\n     *       if (err) throw err;\n     *     });\n     *   }\n     * });\n     * ```\n     *\n     * **read (NOT RECOMMENDED)**\n     *\n     * ```js\n     * import { access, open, close } from 'node:fs';\n     * access('myfile', (err) => {\n     *   if (err) {\n     *     if (err.code === 'ENOENT') {\n     *       console.error('myfile does not exist');\n     *       return;\n     *     }\n     *\n     *     throw err;\n     *   }\n     *\n     *   open('myfile', 'r', (err, fd) => {\n     *     if (err) throw err;\n     *\n     *     try {\n     *       readMyData(fd);\n     *     } finally {\n     *       close(fd, (err) => {\n     *         if (err) throw err;\n     *       });\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * **read (RECOMMENDED)**\n     *\n     * ```js\n     * import { open, close } from 'node:fs';\n     *\n     * open('myfile', 'r', (err, fd) => {\n     *   if (err) {\n     *     if (err.code === 'ENOENT') {\n     *       console.error('myfile does not exist');\n     *       return;\n     *     }\n     *\n     *     throw err;\n     *   }\n     *\n     *   try {\n     *     readMyData(fd);\n     *   } finally {\n     *     close(fd, (err) => {\n     *       if (err) throw err;\n     *     });\n     *   }\n     * });\n     * ```\n     *\n     * The \"not recommended\" examples above check for accessibility and then use the\n     * file; the \"recommended\" examples are better because they use the file directly\n     * and handle the error, if any.\n     *\n     * In general, check for the accessibility of a file only if the file will not be\n     * used directly, for example when its accessibility is a signal from another\n     * process.\n     *\n     * On Windows, access-control policies (ACLs) on a directory may limit access to\n     * a file or directory. The `fs.access()` function, however, does not check the\n     * ACL and therefore may report that a path is accessible even if the ACL restricts\n     * the user from reading or writing to it.\n     * @since v0.11.15\n     * @param [mode=fs.constants.F_OK]\n     */\n    export function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n     */\n    export function access(path: PathLike, callback: NoParamCallback): void;\n    export namespace access {\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n    /**\n     * Synchronously tests a user's permissions for the file or directory specified\n     * by `path`. The `mode` argument is an optional integer that specifies the\n     * accessibility checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and\n     * `fs.constants.X_OK` (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for\n     * possible values of `mode`.\n     *\n     * If any of the accessibility checks fail, an `Error` will be thrown. Otherwise,\n     * the method will return `undefined`.\n     *\n     * ```js\n     * import { accessSync, constants } from 'node:fs';\n     *\n     * try {\n     *   accessSync('etc/passwd', constants.R_OK | constants.W_OK);\n     *   console.log('can read/write');\n     * } catch (err) {\n     *   console.error('no access!');\n     * }\n     * ```\n     * @since v0.11.15\n     * @param [mode=fs.constants.F_OK]\n     */\n    export function accessSync(path: PathLike, mode?: number): void;\n    interface StreamOptions {\n        flags?: string | undefined;\n        encoding?: BufferEncoding | undefined;\n        fd?: number | promises.FileHandle | undefined;\n        mode?: number | undefined;\n        autoClose?: boolean | undefined;\n        emitClose?: boolean | undefined;\n        start?: number | undefined;\n        signal?: AbortSignal | null | undefined;\n        highWaterMark?: number | undefined;\n    }\n    interface FSImplementation {\n        open?: (...args: any[]) => any;\n        close?: (...args: any[]) => any;\n    }\n    interface CreateReadStreamFSImplementation extends FSImplementation {\n        read: (...args: any[]) => any;\n    }\n    interface CreateWriteStreamFSImplementation extends FSImplementation {\n        write: (...args: any[]) => any;\n        writev?: (...args: any[]) => any;\n    }\n    interface ReadStreamOptions extends StreamOptions {\n        fs?: CreateReadStreamFSImplementation | null | undefined;\n        end?: number | undefined;\n    }\n    interface WriteStreamOptions extends StreamOptions {\n        fs?: CreateWriteStreamFSImplementation | null | undefined;\n        flush?: boolean | undefined;\n    }\n    /**\n     * `options` can include `start` and `end` values to read a range of bytes from\n     * the file instead of the entire file. Both `start` and `end` are inclusive and\n     * start counting at 0, allowed values are in the\n     * \\[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\\] range. If `fd` is specified and `start` is\n     * omitted or `undefined`, `fs.createReadStream()` reads sequentially from the\n     * current file position. The `encoding` can be any one of those accepted by `Buffer`.\n     *\n     * If `fd` is specified, `ReadStream` will ignore the `path` argument and will use\n     * the specified file descriptor. This means that no `'open'` event will be\n     * emitted. `fd` should be blocking; non-blocking `fd`s should be passed to `net.Socket`.\n     *\n     * If `fd` points to a character device that only supports blocking reads\n     * (such as keyboard or sound card), read operations do not finish until data is\n     * available. This can prevent the process from exiting and the stream from\n     * closing naturally.\n     *\n     * By default, the stream will emit a `'close'` event after it has been\n     * destroyed.  Set the `emitClose` option to `false` to change this behavior.\n     *\n     * By providing the `fs` option, it is possible to override the corresponding `fs` implementations for `open`, `read`, and `close`. When providing the `fs` option,\n     * an override for `read` is required. If no `fd` is provided, an override for `open` is also required. If `autoClose` is `true`, an override for `close` is\n     * also required.\n     *\n     * ```js\n     * import { createReadStream } from 'node:fs';\n     *\n     * // Create a stream from some character device.\n     * const stream = createReadStream('/dev/input/event0');\n     * setTimeout(() => {\n     *   stream.close(); // This may not close the stream.\n     *   // Artificially marking end-of-stream, as if the underlying resource had\n     *   // indicated end-of-file by itself, allows the stream to close.\n     *   // This does not cancel pending read operations, and if there is such an\n     *   // operation, the process may still not be able to exit successfully\n     *   // until it finishes.\n     *   stream.push(null);\n     *   stream.read(0);\n     * }, 100);\n     * ```\n     *\n     * If `autoClose` is false, then the file descriptor won't be closed, even if\n     * there's an error. It is the application's responsibility to close it and make\n     * sure there's no file descriptor leak. If `autoClose` is set to true (default\n     * behavior), on `'error'` or `'end'` the file descriptor will be closed\n     * automatically.\n     *\n     * `mode` sets the file mode (permission and sticky bits), but only if the\n     * file was created.\n     *\n     * An example to read the last 10 bytes of a file which is 100 bytes long:\n     *\n     * ```js\n     * import { createReadStream } from 'node:fs';\n     *\n     * createReadStream('sample.txt', { start: 90, end: 99 });\n     * ```\n     *\n     * If `options` is a string, then it specifies the encoding.\n     * @since v0.1.31\n     */\n    export function createReadStream(path: PathLike, options?: BufferEncoding | ReadStreamOptions): ReadStream;\n    /**\n     * `options` may also include a `start` option to allow writing data at some\n     * position past the beginning of the file, allowed values are in the\n     * \\[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\\] range. Modifying a file rather than\n     * replacing it may require the `flags` option to be set to `r+` rather than the\n     * default `w`. The `encoding` can be any one of those accepted by `Buffer`.\n     *\n     * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,\n     * then the file descriptor won't be closed, even if there's an error.\n     * It is the application's responsibility to close it and make sure there's no\n     * file descriptor leak.\n     *\n     * By default, the stream will emit a `'close'` event after it has been\n     * destroyed.  Set the `emitClose` option to `false` to change this behavior.\n     *\n     * By providing the `fs` option it is possible to override the corresponding `fs` implementations for `open`, `write`, `writev`, and `close`. Overriding `write()` without `writev()` can reduce\n     * performance as some optimizations (`_writev()`)\n     * will be disabled. When providing the `fs` option, overrides for at least one of `write` and `writev` are required. If no `fd` option is supplied, an override\n     * for `open` is also required. If `autoClose` is `true`, an override for `close` is also required.\n     *\n     * Like `fs.ReadStream`, if `fd` is specified, `fs.WriteStream` will ignore the `path` argument and will use the specified file descriptor. This means that no `'open'` event will be\n     * emitted. `fd` should be blocking; non-blocking `fd`s\n     * should be passed to `net.Socket`.\n     *\n     * If `options` is a string, then it specifies the encoding.\n     * @since v0.1.31\n     */\n    export function createWriteStream(path: PathLike, options?: BufferEncoding | WriteStreamOptions): WriteStream;\n    /**\n     * Forces all currently queued I/O operations associated with the file to the\n     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. No arguments other\n     * than a possible\n     * exception are given to the completion callback.\n     * @since v0.1.96\n     */\n    export function fdatasync(fd: number, callback: NoParamCallback): void;\n    export namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n    /**\n     * Forces all currently queued I/O operations associated with the file to the\n     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.\n     * @since v0.1.96\n     */\n    export function fdatasyncSync(fd: number): void;\n    /**\n     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it\n     * already exists. No arguments other than a possible exception are given to the\n     * callback function. Node.js makes no guarantees about the atomicity of the copy\n     * operation. If an error occurs after the destination file has been opened for\n     * writing, Node.js will attempt to remove the destination.\n     *\n     * `mode` is an optional integer that specifies the behavior\n     * of the copy operation. It is possible to create a mask consisting of the bitwise\n     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).\n     *\n     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already\n     * exists.\n     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a\n     * copy-on-write reflink. If the platform does not support copy-on-write, then a\n     * fallback copy mechanism is used.\n     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to\n     * create a copy-on-write reflink. If the platform does not support\n     * copy-on-write, then the operation will fail.\n     *\n     * ```js\n     * import { copyFile, constants } from 'node:fs';\n     *\n     * function callback(err) {\n     *   if (err) throw err;\n     *   console.log('source.txt was copied to destination.txt');\n     * }\n     *\n     * // destination.txt will be created or overwritten by default.\n     * copyFile('source.txt', 'destination.txt', callback);\n     *\n     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.\n     * copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL, callback);\n     * ```\n     * @since v8.5.0\n     * @param src source filename to copy\n     * @param dest destination filename of the copy operation\n     * @param [mode=0] modifiers for copy operation.\n     */\n    export function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;\n    export function copyFile(src: PathLike, dest: PathLike, mode: number, callback: NoParamCallback): void;\n    export namespace copyFile {\n        function __promisify__(src: PathLike, dst: PathLike, mode?: number): Promise<void>;\n    }\n    /**\n     * Synchronously copies `src` to `dest`. By default, `dest` is overwritten if it\n     * already exists. Returns `undefined`. Node.js makes no guarantees about the\n     * atomicity of the copy operation. If an error occurs after the destination file\n     * has been opened for writing, Node.js will attempt to remove the destination.\n     *\n     * `mode` is an optional integer that specifies the behavior\n     * of the copy operation. It is possible to create a mask consisting of the bitwise\n     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).\n     *\n     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already\n     * exists.\n     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a\n     * copy-on-write reflink. If the platform does not support copy-on-write, then a\n     * fallback copy mechanism is used.\n     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to\n     * create a copy-on-write reflink. If the platform does not support\n     * copy-on-write, then the operation will fail.\n     *\n     * ```js\n     * import { copyFileSync, constants } from 'node:fs';\n     *\n     * // destination.txt will be created or overwritten by default.\n     * copyFileSync('source.txt', 'destination.txt');\n     * console.log('source.txt was copied to destination.txt');\n     *\n     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.\n     * copyFileSync('source.txt', 'destination.txt', constants.COPYFILE_EXCL);\n     * ```\n     * @since v8.5.0\n     * @param src source filename to copy\n     * @param dest destination filename of the copy operation\n     * @param [mode=0] modifiers for copy operation.\n     */\n    export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;\n    /**\n     * Write an array of `ArrayBufferView`s to the file specified by `fd` using `writev()`.\n     *\n     * `position` is the offset from the beginning of the file where this data\n     * should be written. If `typeof position !== 'number'`, the data will be written\n     * at the current position.\n     *\n     * The callback will be given three arguments: `err`, `bytesWritten`, and `buffers`. `bytesWritten` is how many bytes were written from `buffers`.\n     *\n     * If this method is `util.promisify()` ed, it returns a promise for an `Object` with `bytesWritten` and `buffers` properties.\n     *\n     * It is unsafe to use `fs.writev()` multiple times on the same file without\n     * waiting for the callback. For this scenario, use {@link createWriteStream}.\n     *\n     * On Linux, positional writes don't work when the file is opened in append mode.\n     * The kernel ignores the position argument and always appends the data to\n     * the end of the file.\n     * @since v12.9.0\n     * @param [position='null']\n     */\n    export function writev(\n        fd: number,\n        buffers: readonly NodeJS.ArrayBufferView[],\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,\n    ): void;\n    export function writev(\n        fd: number,\n        buffers: readonly NodeJS.ArrayBufferView[],\n        position: number | null,\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,\n    ): void;\n    export interface WriteVResult {\n        bytesWritten: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n    export namespace writev {\n        function __promisify__(\n            fd: number,\n            buffers: readonly NodeJS.ArrayBufferView[],\n            position?: number,\n        ): Promise<WriteVResult>;\n    }\n    /**\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link writev}.\n     * @since v12.9.0\n     * @param [position='null']\n     * @return The number of bytes written.\n     */\n    export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;\n    /**\n     * Read from a file specified by `fd` and write to an array of `ArrayBufferView`s\n     * using `readv()`.\n     *\n     * `position` is the offset from the beginning of the file from where data\n     * should be read. If `typeof position !== 'number'`, the data will be read\n     * from the current position.\n     *\n     * The callback will be given three arguments: `err`, `bytesRead`, and `buffers`. `bytesRead` is how many bytes were read from the file.\n     *\n     * If this method is invoked as its `util.promisify()` ed version, it returns\n     * a promise for an `Object` with `bytesRead` and `buffers` properties.\n     * @since v13.13.0, v12.17.0\n     * @param [position='null']\n     */\n    export function readv(\n        fd: number,\n        buffers: readonly NodeJS.ArrayBufferView[],\n        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,\n    ): void;\n    export function readv(\n        fd: number,\n        buffers: readonly NodeJS.ArrayBufferView[],\n        position: number | null,\n        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,\n    ): void;\n    export interface ReadVResult {\n        bytesRead: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n    export namespace readv {\n        function __promisify__(\n            fd: number,\n            buffers: readonly NodeJS.ArrayBufferView[],\n            position?: number,\n        ): Promise<ReadVResult>;\n    }\n    /**\n     * For detailed information, see the documentation of the asynchronous version of\n     * this API: {@link readv}.\n     * @since v13.13.0, v12.17.0\n     * @param [position='null']\n     * @return The number of bytes read.\n     */\n    export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;\n\n    export interface OpenAsBlobOptions {\n        /**\n         * An optional mime type for the blob.\n         *\n         * @default 'undefined'\n         */\n        type?: string | undefined;\n    }\n\n    /**\n     * Returns a `Blob` whose data is backed by the given file.\n     *\n     * The file must not be modified after the `Blob` is created. Any modifications\n     * will cause reading the `Blob` data to fail with a `DOMException` error.\n     * Synchronous stat operations on the file when the `Blob` is created, and before\n     * each read in order to detect whether the file data has been modified on disk.\n     *\n     * ```js\n     * import { openAsBlob } from 'node:fs';\n     *\n     * const blob = await openAsBlob('the.file.txt');\n     * const ab = await blob.arrayBuffer();\n     * blob.stream();\n     * ```\n     * @since v19.8.0\n     * @experimental\n     */\n    export function openAsBlob(path: PathLike, options?: OpenAsBlobOptions): Promise<Blob>;\n\n    export interface OpenDirOptions {\n        /**\n         * @default 'utf8'\n         */\n        encoding?: BufferEncoding | undefined;\n        /**\n         * Number of directory entries that are buffered\n         * internally when reading from the directory. Higher values lead to better\n         * performance but higher memory usage.\n         * @default 32\n         */\n        bufferSize?: number | undefined;\n        /**\n         * @default false\n         */\n        recursive?: boolean;\n    }\n    /**\n     * Synchronously open a directory. See [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html).\n     *\n     * Creates an `fs.Dir`, which contains all further functions for reading from\n     * and cleaning up the directory.\n     *\n     * The `encoding` option sets the encoding for the `path` while opening the\n     * directory and subsequent read operations.\n     * @since v12.12.0\n     */\n    export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;\n    /**\n     * Asynchronously open a directory. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for\n     * more details.\n     *\n     * Creates an `fs.Dir`, which contains all further functions for reading from\n     * and cleaning up the directory.\n     *\n     * The `encoding` option sets the encoding for the `path` while opening the\n     * directory and subsequent read operations.\n     * @since v12.12.0\n     */\n    export function opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n    export function opendir(\n        path: PathLike,\n        options: OpenDirOptions,\n        cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void,\n    ): void;\n    export namespace opendir {\n        function __promisify__(path: PathLike, options?: OpenDirOptions): Promise<Dir>;\n    }\n    export interface BigIntStats extends StatsBase<bigint> {\n        atimeNs: bigint;\n        mtimeNs: bigint;\n        ctimeNs: bigint;\n        birthtimeNs: bigint;\n    }\n    export interface BigIntOptions {\n        bigint: true;\n    }\n    export interface StatOptions {\n        bigint?: boolean | undefined;\n    }\n    export interface StatSyncOptions extends StatOptions {\n        throwIfNoEntry?: boolean | undefined;\n    }\n    interface CopyOptionsBase {\n        /**\n         * Dereference symlinks\n         * @default false\n         */\n        dereference?: boolean;\n        /**\n         * When `force` is `false`, and the destination\n         * exists, throw an error.\n         * @default false\n         */\n        errorOnExist?: boolean;\n        /**\n         * Overwrite existing file or directory. _The copy\n         * operation will ignore errors if you set this to false and the destination\n         * exists. Use the `errorOnExist` option to change this behavior.\n         * @default true\n         */\n        force?: boolean;\n        /**\n         * Modifiers for copy operation. See `mode` flag of {@link copyFileSync()}\n         */\n        mode?: number;\n        /**\n         * When `true` timestamps from `src` will\n         * be preserved.\n         * @default false\n         */\n        preserveTimestamps?: boolean;\n        /**\n         * Copy directories recursively.\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * When true, path resolution for symlinks will be skipped\n         * @default false\n         */\n        verbatimSymlinks?: boolean;\n    }\n    export interface CopyOptions extends CopyOptionsBase {\n        /**\n         * Function to filter copied files/directories. Return\n         * `true` to copy the item, `false` to ignore it.\n         */\n        filter?(source: string, destination: string): boolean | Promise<boolean>;\n    }\n    export interface CopySyncOptions extends CopyOptionsBase {\n        /**\n         * Function to filter copied files/directories. Return\n         * `true` to copy the item, `false` to ignore it.\n         */\n        filter?(source: string, destination: string): boolean;\n    }\n    /**\n     * Asynchronously copies the entire directory structure from `src` to `dest`,\n     * including subdirectories and files.\n     *\n     * When copying a directory to another directory, globs are not supported and\n     * behavior is similar to `cp dir1/ dir2/`.\n     * @since v16.7.0\n     * @experimental\n     * @param src source path to copy.\n     * @param dest destination path to copy to.\n     */\n    export function cp(\n        source: string | URL,\n        destination: string | URL,\n        callback: (err: NodeJS.ErrnoException | null) => void,\n    ): void;\n    export function cp(\n        source: string | URL,\n        destination: string | URL,\n        opts: CopyOptions,\n        callback: (err: NodeJS.ErrnoException | null) => void,\n    ): void;\n    /**\n     * Synchronously copies the entire directory structure from `src` to `dest`,\n     * including subdirectories and files.\n     *\n     * When copying a directory to another directory, globs are not supported and\n     * behavior is similar to `cp dir1/ dir2/`.\n     * @since v16.7.0\n     * @experimental\n     * @param src source path to copy.\n     * @param dest destination path to copy to.\n     */\n    export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;\n\n    interface _GlobOptions<T extends Dirent | string> {\n        /**\n         * Current working directory.\n         * @default process.cwd()\n         */\n        cwd?: string | undefined;\n        /**\n         * `true` if the glob should return paths as `Dirent`s, `false` otherwise.\n         * @default false\n         * @since v22.2.0\n         */\n        withFileTypes?: boolean | undefined;\n        /**\n         * Function to filter out files/directories or a\n         * list of glob patterns to be excluded. If a function is provided, return\n         * `true` to exclude the item, `false` to include it.\n         * @default undefined\n         */\n        exclude?: ((fileName: T) => boolean) | readonly string[] | undefined;\n    }\n    export interface GlobOptions extends _GlobOptions<Dirent | string> {}\n    export interface GlobOptionsWithFileTypes extends _GlobOptions<Dirent> {\n        withFileTypes: true;\n    }\n    export interface GlobOptionsWithoutFileTypes extends _GlobOptions<string> {\n        withFileTypes?: false | undefined;\n    }\n\n    /**\n     * Retrieves the files matching the specified pattern.\n     */\n    export function glob(\n        pattern: string | string[],\n        callback: (err: NodeJS.ErrnoException | null, matches: string[]) => void,\n    ): void;\n    export function glob(\n        pattern: string | string[],\n        options: GlobOptionsWithFileTypes,\n        callback: (\n            err: NodeJS.ErrnoException | null,\n            matches: Dirent[],\n        ) => void,\n    ): void;\n    export function glob(\n        pattern: string | string[],\n        options: GlobOptionsWithoutFileTypes,\n        callback: (\n            err: NodeJS.ErrnoException | null,\n            matches: string[],\n        ) => void,\n    ): void;\n    export function glob(\n        pattern: string | string[],\n        options: GlobOptions,\n        callback: (\n            err: NodeJS.ErrnoException | null,\n            matches: Dirent[] | string[],\n        ) => void,\n    ): void;\n    /**\n     * Retrieves the files matching the specified pattern.\n     */\n    export function globSync(pattern: string | string[]): string[];\n    export function globSync(\n        pattern: string | string[],\n        options: GlobOptionsWithFileTypes,\n    ): Dirent[];\n    export function globSync(\n        pattern: string | string[],\n        options: GlobOptionsWithoutFileTypes,\n    ): string[];\n    export function globSync(\n        pattern: string | string[],\n        options: GlobOptions,\n    ): Dirent[] | string[];\n}\ndeclare module \"node:fs\" {\n    export * from \"fs\";\n}\n"
        }
    ]
}