{
    "sourceFile": "node_modules/@types/node/timers.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891956205,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * The `timer` module exposes a global API for scheduling functions to\n * be called at some future period of time. Because the timer functions are\n * globals, there is no need to import `node:timers` to use the API.\n *\n * The timer functions within Node.js implement a similar API as the timers API\n * provided by Web Browsers but use a different internal implementation that is\n * built around the Node.js [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout).\n * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/timers.js)\n */\ndeclare module \"timers\" {\n    import { Abortable } from \"node:events\";\n    import * as promises from \"node:timers/promises\";\n    export interface TimerOptions extends Abortable {\n        /**\n         * Set to `false` to indicate that the scheduled `Timeout`\n         * should not require the Node.js event loop to remain active.\n         * @default true\n         */\n        ref?: boolean | undefined;\n    }\n    global {\n        namespace NodeJS {\n            /**\n             * This object is created internally and is returned from `setImmediate()`. It\n             * can be passed to `clearImmediate()` in order to cancel the scheduled\n             * actions.\n             *\n             * By default, when an immediate is scheduled, the Node.js event loop will continue\n             * running as long as the immediate is active. The `Immediate` object returned by\n             * `setImmediate()` exports both `immediate.ref()` and `immediate.unref()`\n             * functions that can be used to control this default behavior.\n             */\n            interface Immediate extends RefCounted, Disposable {\n                /**\n                 * If true, the `Immediate` object will keep the Node.js event loop active.\n                 * @since v11.0.0\n                 */\n                hasRef(): boolean;\n                /**\n                 * When called, requests that the Node.js event loop _not_ exit so long as the\n                 * `Immediate` is active. Calling `immediate.ref()` multiple times will have no\n                 * effect.\n                 *\n                 * By default, all `Immediate` objects are \"ref'ed\", making it normally unnecessary\n                 * to call `immediate.ref()` unless `immediate.unref()` had been called previously.\n                 * @since v9.7.0\n                 * @returns a reference to `immediate`\n                 */\n                ref(): this;\n                /**\n                 * When called, the active `Immediate` object will not require the Node.js event\n                 * loop to remain active. If there is no other activity keeping the event loop\n                 * running, the process may exit before the `Immediate` object's callback is\n                 * invoked. Calling `immediate.unref()` multiple times will have no effect.\n                 * @since v9.7.0\n                 * @returns a reference to `immediate`\n                 */\n                unref(): this;\n                /**\n                 * Cancels the immediate. This is similar to calling `clearImmediate()`.\n                 * @since v20.5.0, v18.18.0\n                 * @experimental\n                 */\n                [Symbol.dispose](): void;\n                _onImmediate(...args: any[]): void;\n            }\n            // Legacy interface used in Node.js v9 and prior\n            // TODO: remove in a future major version bump\n            /** @deprecated Use `NodeJS.Timeout` instead. */\n            interface Timer extends RefCounted {\n                hasRef(): boolean;\n                refresh(): this;\n                [Symbol.toPrimitive](): number;\n            }\n            /**\n             * This object is created internally and is returned from `setTimeout()` and\n             * `setInterval()`. It can be passed to either `clearTimeout()` or\n             * `clearInterval()` in order to cancel the scheduled actions.\n             *\n             * By default, when a timer is scheduled using either `setTimeout()` or\n             * `setInterval()`, the Node.js event loop will continue running as long as the\n             * timer is active. Each of the `Timeout` objects returned by these functions\n             * export both `timeout.ref()` and `timeout.unref()` functions that can be used to\n             * control this default behavior.\n             */\n            interface Timeout extends RefCounted, Disposable, Timer {\n                /**\n                 * Cancels the timeout.\n                 * @since v0.9.1\n                 * @legacy Use `clearTimeout()` instead.\n                 * @returns a reference to `timeout`\n                 */\n                close(): this;\n                /**\n                 * If true, the `Timeout` object will keep the Node.js event loop active.\n                 * @since v11.0.0\n                 */\n                hasRef(): boolean;\n                /**\n                 * When called, requests that the Node.js event loop _not_ exit so long as the\n                 * `Timeout` is active. Calling `timeout.ref()` multiple times will have no effect.\n                 *\n                 * By default, all `Timeout` objects are \"ref'ed\", making it normally unnecessary\n                 * to call `timeout.ref()` unless `timeout.unref()` had been called previously.\n                 * @since v0.9.1\n                 * @returns a reference to `timeout`\n                 */\n                ref(): this;\n                /**\n                 * Sets the timer's start time to the current time, and reschedules the timer to\n                 * call its callback at the previously specified duration adjusted to the current\n                 * time. This is useful for refreshing a timer without allocating a new\n                 * JavaScript object.\n                 *\n                 * Using this on a timer that has already called its callback will reactivate the\n                 * timer.\n                 * @since v10.2.0\n                 * @returns a reference to `timeout`\n                 */\n                refresh(): this;\n                /**\n                 * When called, the active `Timeout` object will not require the Node.js event loop\n                 * to remain active. If there is no other activity keeping the event loop running,\n                 * the process may exit before the `Timeout` object's callback is invoked. Calling\n                 * `timeout.unref()` multiple times will have no effect.\n                 * @since v0.9.1\n                 * @returns a reference to `timeout`\n                 */\n                unref(): this;\n                /**\n                 * Coerce a `Timeout` to a primitive. The primitive can be used to\n                 * clear the `Timeout`. The primitive can only be used in the\n                 * same thread where the timeout was created. Therefore, to use it\n                 * across `worker_threads` it must first be passed to the correct\n                 * thread. This allows enhanced compatibility with browser\n                 * `setTimeout()` and `setInterval()` implementations.\n                 * @since v14.9.0, v12.19.0\n                 */\n                [Symbol.toPrimitive](): number;\n                /**\n                 * Cancels the timeout.\n                 * @since v20.5.0, v18.18.0\n                 * @experimental\n                 */\n                [Symbol.dispose](): void;\n                _onTimeout(...args: any[]): void;\n            }\n        }\n        /**\n         * Schedules the \"immediate\" execution of the `callback` after I/O events'\n         * callbacks.\n         *\n         * When multiple calls to `setImmediate()` are made, the `callback` functions are\n         * queued for execution in the order in which they are created. The entire callback\n         * queue is processed every event loop iteration. If an immediate timer is queued\n         * from inside an executing callback, that timer will not be triggered until the\n         * next event loop iteration.\n         *\n         * If `callback` is not a function, a `TypeError` will be thrown.\n         *\n         * This method has a custom variant for promises that is available using\n         * `timersPromises.setImmediate()`.\n         * @since v0.9.1\n         * @param callback The function to call at the end of this turn of\n         * the Node.js [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout)\n         * @param args Optional arguments to pass when the `callback` is called.\n         * @returns for use with `clearImmediate()`\n         */\n        function setImmediate<TArgs extends any[]>(\n            callback: (...args: TArgs) => void,\n            ...args: TArgs\n        ): NodeJS.Immediate;\n        // Allow a single void-accepting argument to be optional in arguments lists.\n        // Allows usage such as `new Promise(resolve => setTimeout(resolve, ms))` (#54258)\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        function setImmediate(callback: (_: void) => void): NodeJS.Immediate;\n        namespace setImmediate {\n            import __promisify__ = promises.setImmediate;\n            export { __promisify__ };\n        }\n        /**\n         * Schedules repeated execution of `callback` every `delay` milliseconds.\n         *\n         * When `delay` is larger than `2147483647` or less than `1` or `NaN`, the `delay`\n         * will be set to `1`. Non-integer delays are truncated to an integer.\n         *\n         * If `callback` is not a function, a `TypeError` will be thrown.\n         *\n         * This method has a custom variant for promises that is available using\n         * `timersPromises.setInterval()`.\n         * @since v0.0.1\n         * @param callback The function to call when the timer elapses.\n         * @param delay The number of milliseconds to wait before calling the\n         * `callback`. **Default:** `1`.\n         * @param args Optional arguments to pass when the `callback` is called.\n         * @returns for use with `clearInterval()`\n         */\n        function setInterval<TArgs extends any[]>(\n            callback: (...args: TArgs) => void,\n            delay?: number,\n            ...args: TArgs\n        ): NodeJS.Timeout;\n        // Allow a single void-accepting argument to be optional in arguments lists.\n        // Allows usage such as `new Promise(resolve => setTimeout(resolve, ms))` (#54258)\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        function setInterval(callback: (_: void) => void, delay?: number): NodeJS.Timeout;\n        /**\n         * Schedules execution of a one-time `callback` after `delay` milliseconds.\n         *\n         * The `callback` will likely not be invoked in precisely `delay` milliseconds.\n         * Node.js makes no guarantees about the exact timing of when callbacks will fire,\n         * nor of their ordering. The callback will be called as close as possible to the\n         * time specified.\n         *\n         * When `delay` is larger than `2147483647` or less than `1` or `NaN`, the `delay`\n         * will be set to `1`. Non-integer delays are truncated to an integer.\n         *\n         * If `callback` is not a function, a `TypeError` will be thrown.\n         *\n         * This method has a custom variant for promises that is available using\n         * `timersPromises.setTimeout()`.\n         * @since v0.0.1\n         * @param callback The function to call when the timer elapses.\n         * @param delay The number of milliseconds to wait before calling the\n         * `callback`. **Default:** `1`.\n         * @param args Optional arguments to pass when the `callback` is called.\n         * @returns for use with `clearTimeout()`\n         */\n        function setTimeout<TArgs extends any[]>(\n            callback: (...args: TArgs) => void,\n            delay?: number,\n            ...args: TArgs\n        ): NodeJS.Timeout;\n        // Allow a single void-accepting argument to be optional in arguments lists.\n        // Allows usage such as `new Promise(resolve => setTimeout(resolve, ms))` (#54258)\n        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n        function setTimeout(callback: (_: void) => void, delay?: number): NodeJS.Timeout;\n        namespace setTimeout {\n            import __promisify__ = promises.setTimeout;\n            export { __promisify__ };\n        }\n        /**\n         * Cancels an `Immediate` object created by `setImmediate()`.\n         * @since v0.9.1\n         * @param immediate An `Immediate` object as returned by `setImmediate()`.\n         */\n        function clearImmediate(immediate: NodeJS.Immediate | undefined): void;\n        /**\n         * Cancels a `Timeout` object created by `setInterval()`.\n         * @since v0.0.1\n         * @param timeout A `Timeout` object as returned by `setInterval()`\n         * or the primitive of the `Timeout` object as a string or a number.\n         */\n        function clearInterval(timeout: NodeJS.Timeout | string | number | undefined): void;\n        /**\n         * Cancels a `Timeout` object created by `setTimeout()`.\n         * @since v0.0.1\n         * @param timeout A `Timeout` object as returned by `setTimeout()`\n         * or the primitive of the `Timeout` object as a string or a number.\n         */\n        function clearTimeout(timeout: NodeJS.Timeout | string | number | undefined): void;\n        /**\n         * The `queueMicrotask()` method queues a microtask to invoke `callback`. If\n         * `callback` throws an exception, the `process` object `'uncaughtException'`\n         * event will be emitted.\n         *\n         * The microtask queue is managed by V8 and may be used in a similar manner to\n         * the `process.nextTick()` queue, which is managed by Node.js. The\n         * `process.nextTick()` queue is always processed before the microtask queue\n         * within each turn of the Node.js event loop.\n         * @since v11.0.0\n         * @param callback Function to be queued.\n         */\n        function queueMicrotask(callback: () => void): void;\n    }\n    import clearImmediate = globalThis.clearImmediate;\n    import clearInterval = globalThis.clearInterval;\n    import clearTimeout = globalThis.clearTimeout;\n    import setImmediate = globalThis.setImmediate;\n    import setInterval = globalThis.setInterval;\n    import setTimeout = globalThis.setTimeout;\n    export { clearImmediate, clearInterval, clearTimeout, promises, setImmediate, setInterval, setTimeout };\n}\ndeclare module \"node:timers\" {\n    export * from \"timers\";\n}\n"
        }
    ]
}