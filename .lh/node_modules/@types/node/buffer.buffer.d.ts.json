{
    "sourceFile": "node_modules/@types/node/buffer.buffer.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891954721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "declare module \"buffer\" {\n    type ImplicitArrayBuffer<T extends WithImplicitCoercion<ArrayBufferLike>> = T extends\n        { valueOf(): infer V extends ArrayBufferLike } ? V : T;\n    global {\n        interface BufferConstructor {\n            // see buffer.d.ts for implementation shared with all TypeScript versions\n\n            /**\n             * Allocates a new buffer containing the given {str}.\n             *\n             * @param str String to store in buffer.\n             * @param encoding encoding to use, optional.  Default is 'utf8'\n             * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.\n             */\n            new(str: string, encoding?: BufferEncoding): Buffer<ArrayBuffer>;\n            /**\n             * Allocates a new buffer of {size} octets.\n             *\n             * @param size count of octets to allocate.\n             * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).\n             */\n            new(size: number): Buffer<ArrayBuffer>;\n            /**\n             * Allocates a new buffer containing the given {array} of octets.\n             *\n             * @param array The octets to store.\n             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.\n             */\n            new(array: ArrayLike<number>): Buffer<ArrayBuffer>;\n            /**\n             * Produces a Buffer backed by the same allocated memory as\n             * the given {ArrayBuffer}/{SharedArrayBuffer}.\n             *\n             * @param arrayBuffer The ArrayBuffer with which to share memory.\n             * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.\n             */\n            new<TArrayBuffer extends ArrayBufferLike = ArrayBuffer>(arrayBuffer: TArrayBuffer): Buffer<TArrayBuffer>;\n            /**\n             * Allocates a new `Buffer` using an `array` of bytes in the range `0` – `255`.\n             * Array entries outside that range will be truncated to fit into it.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.\n             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n             * ```\n             *\n             * If `array` is an `Array`-like object (that is, one with a `length` property of\n             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or\n             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an\n             * `Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use\n             * `Buffer.copyBytesFrom()`.\n             *\n             * A `TypeError` will be thrown if `array` is not an `Array` or another type\n             * appropriate for `Buffer.from()` variants.\n             *\n             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal\n             * `Buffer` pool like `Buffer.allocUnsafe()` does.\n             * @since v5.10.0\n             */\n            from(array: WithImplicitCoercion<ArrayLike<number>>): Buffer<ArrayBuffer>;\n            /**\n             * This creates a view of the `ArrayBuffer` without copying the underlying\n             * memory. For example, when passed a reference to the `.buffer` property of a\n             * `TypedArray` instance, the newly created `Buffer` will share the same\n             * allocated memory as the `TypedArray`'s underlying `ArrayBuffer`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const arr = new Uint16Array(2);\n             *\n             * arr[0] = 5000;\n             * arr[1] = 4000;\n             *\n             * // Shares memory with `arr`.\n             * const buf = Buffer.from(arr.buffer);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 88 13 a0 0f>\n             *\n             * // Changing the original Uint16Array changes the Buffer also.\n             * arr[1] = 6000;\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 88 13 70 17>\n             * ```\n             *\n             * The optional `byteOffset` and `length` arguments specify a memory range within\n             * the `arrayBuffer` that will be shared by the `Buffer`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const ab = new ArrayBuffer(10);\n             * const buf = Buffer.from(ab, 0, 2);\n             *\n             * console.log(buf.length);\n             * // Prints: 2\n             * ```\n             *\n             * A `TypeError` will be thrown if `arrayBuffer` is not an `ArrayBuffer` or a\n             * `SharedArrayBuffer` or another type appropriate for `Buffer.from()`\n             * variants.\n             *\n             * It is important to remember that a backing `ArrayBuffer` can cover a range\n             * of memory that extends beyond the bounds of a `TypedArray` view. A new\n             * `Buffer` created using the `buffer` property of a `TypedArray` may extend\n             * beyond the range of the `TypedArray`:\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements\n             * const arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements\n             * console.log(arrA.buffer === arrB.buffer); // true\n             *\n             * const buf = Buffer.from(arrB.buffer);\n             * console.log(buf);\n             * // Prints: <Buffer 63 64 65 66>\n             * ```\n             * @since v5.10.0\n             * @param arrayBuffer An `ArrayBuffer`, `SharedArrayBuffer`, for example the\n             * `.buffer` property of a `TypedArray`.\n             * @param byteOffset Index of first byte to expose. **Default:** `0`.\n             * @param length Number of bytes to expose. **Default:**\n             * `arrayBuffer.byteLength - byteOffset`.\n             */\n            from<TArrayBuffer extends WithImplicitCoercion<ArrayBufferLike>>(\n                arrayBuffer: TArrayBuffer,\n                byteOffset?: number,\n                length?: number,\n            ): Buffer<ImplicitArrayBuffer<TArrayBuffer>>;\n            /**\n             * Creates a new `Buffer` containing `string`. The `encoding` parameter identifies\n             * the character encoding to be used when converting `string` into bytes.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf1 = Buffer.from('this is a tést');\n             * const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\n             *\n             * console.log(buf1.toString());\n             * // Prints: this is a tést\n             * console.log(buf2.toString());\n             * // Prints: this is a tést\n             * console.log(buf1.toString('latin1'));\n             * // Prints: this is a tÃ©st\n             * ```\n             *\n             * A `TypeError` will be thrown if `string` is not a string or another type\n             * appropriate for `Buffer.from()` variants.\n             *\n             * `Buffer.from(string)` may also use the internal `Buffer` pool like\n             * `Buffer.allocUnsafe()` does.\n             * @since v5.10.0\n             * @param string A string to encode.\n             * @param encoding The encoding of `string`. **Default:** `'utf8'`.\n             */\n            from(string: WithImplicitCoercion<string>, encoding?: BufferEncoding): Buffer<ArrayBuffer>;\n            from(arrayOrString: WithImplicitCoercion<ArrayLike<number> | string>): Buffer<ArrayBuffer>;\n            /**\n             * Creates a new Buffer using the passed {data}\n             * @param values to create a new Buffer\n             */\n            of(...items: number[]): Buffer<ArrayBuffer>;\n            /**\n             * Returns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.\n             *\n             * If the list has no items, or if the `totalLength` is 0, then a new zero-length `Buffer` is returned.\n             *\n             * If `totalLength` is not provided, it is calculated from the `Buffer` instances\n             * in `list` by adding their lengths.\n             *\n             * If `totalLength` is provided, it is coerced to an unsigned integer. If the\n             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is\n             * truncated to `totalLength`. If the combined length of the `Buffer`s in `list` is\n             * less than `totalLength`, the remaining space is filled with zeros.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Create a single `Buffer` from a list of three `Buffer` instances.\n             *\n             * const buf1 = Buffer.alloc(10);\n             * const buf2 = Buffer.alloc(14);\n             * const buf3 = Buffer.alloc(18);\n             * const totalLength = buf1.length + buf2.length + buf3.length;\n             *\n             * console.log(totalLength);\n             * // Prints: 42\n             *\n             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);\n             *\n             * console.log(bufA);\n             * // Prints: <Buffer 00 00 00 00 ...>\n             * console.log(bufA.length);\n             * // Prints: 42\n             * ```\n             *\n             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.\n             * @since v0.7.11\n             * @param list List of `Buffer` or {@link Uint8Array} instances to concatenate.\n             * @param totalLength Total length of the `Buffer` instances in `list` when concatenated.\n             */\n            concat(list: readonly Uint8Array[], totalLength?: number): Buffer<ArrayBuffer>;\n            /**\n             * Copies the underlying memory of `view` into a new `Buffer`.\n             *\n             * ```js\n             * const u16 = new Uint16Array([0, 0xffff]);\n             * const buf = Buffer.copyBytesFrom(u16, 1, 1);\n             * u16[1] = 0;\n             * console.log(buf.length); // 2\n             * console.log(buf[0]); // 255\n             * console.log(buf[1]); // 255\n             * ```\n             * @since v19.8.0\n             * @param view The {TypedArray} to copy.\n             * @param [offset=0] The starting offset within `view`.\n             * @param [length=view.length - offset] The number of elements from `view` to copy.\n             */\n            copyBytesFrom(view: NodeJS.TypedArray, offset?: number, length?: number): Buffer<ArrayBuffer>;\n            /**\n             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(5);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 00 00 00 00 00>\n             * ```\n             *\n             * If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.\n             *\n             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(5, 'a');\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 61 61 61 61 61>\n             * ```\n             *\n             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be\n             * initialized by calling `buf.fill(fill, encoding)`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n             * ```\n             *\n             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance\n             * contents will never contain sensitive data from previous allocations, including\n             * data that might not have been allocated for `Buffer`s.\n             *\n             * A `TypeError` will be thrown if `size` is not a number.\n             * @since v5.10.0\n             * @param size The desired length of the new `Buffer`.\n             * @param [fill=0] A value to pre-fill the new `Buffer` with.\n             * @param [encoding='utf8'] If `fill` is a string, this is its encoding.\n             */\n            alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer<ArrayBuffer>;\n            /**\n             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.\n             *\n             * The underlying memory for `Buffer` instances created in this way is _not_\n             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.allocUnsafe(10);\n             *\n             * console.log(buf);\n             * // Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>\n             *\n             * buf.fill(0);\n             *\n             * console.log(buf);\n             * // Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>\n             * ```\n             *\n             * A `TypeError` will be thrown if `size` is not a number.\n             *\n             * The `Buffer` module pre-allocates an internal `Buffer` instance of\n             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new `Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,\n             * and `Buffer.concat()` only when `size` is less than `Buffer.poolSize >>> 1` (floor of `Buffer.poolSize` divided by two).\n             *\n             * Use of this pre-allocated internal memory pool is a key difference between\n             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.\n             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less\n             * than or equal to half `Buffer.poolSize`. The\n             * difference is subtle but can be important when an application requires the\n             * additional performance that `Buffer.allocUnsafe()` provides.\n             * @since v5.10.0\n             * @param size The desired length of the new `Buffer`.\n             */\n            allocUnsafe(size: number): Buffer<ArrayBuffer>;\n            /**\n             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if\n             * `size` is 0.\n             *\n             * The underlying memory for `Buffer` instances created in this way is _not_\n             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize\n             * such `Buffer` instances with zeroes.\n             *\n             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,\n             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This\n             * allows applications to avoid the garbage collection overhead of creating many\n             * individually allocated `Buffer` instances. This approach improves both\n             * performance and memory usage by eliminating the need to track and clean up as\n             * many individual `ArrayBuffer` objects.\n             *\n             * However, in the case where a developer may need to retain a small chunk of\n             * memory from a pool for an indeterminate amount of time, it may be appropriate\n             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and\n             * then copying out the relevant bits.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Need to keep around a few small chunks of memory.\n             * const store = [];\n             *\n             * socket.on('readable', () => {\n             *   let data;\n             *   while (null !== (data = readable.read())) {\n             *     // Allocate for retained data.\n             *     const sb = Buffer.allocUnsafeSlow(10);\n             *\n             *     // Copy the data into the new allocation.\n             *     data.copy(sb, 0, 0, 10);\n             *\n             *     store.push(sb);\n             *   }\n             * });\n             * ```\n             *\n             * A `TypeError` will be thrown if `size` is not a number.\n             * @since v5.12.0\n             * @param size The desired length of the new `Buffer`.\n             */\n            allocUnsafeSlow(size: number): Buffer<ArrayBuffer>;\n        }\n        interface Buffer<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> extends Uint8Array<TArrayBuffer> {\n            // see buffer.d.ts for implementation shared with all TypeScript versions\n\n            /**\n             * Returns a new `Buffer` that references the same memory as the original, but\n             * offset and cropped by the `start` and `end` indices.\n             *\n             * This method is not compatible with the `Uint8Array.prototype.slice()`,\n             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * const copiedBuf = Uint8Array.prototype.slice.call(buf);\n             * copiedBuf[0]++;\n             * console.log(copiedBuf.toString());\n             * // Prints: cuffer\n             *\n             * console.log(buf.toString());\n             * // Prints: buffer\n             *\n             * // With buf.slice(), the original buffer is modified.\n             * const notReallyCopiedBuf = buf.slice();\n             * notReallyCopiedBuf[0]++;\n             * console.log(notReallyCopiedBuf.toString());\n             * // Prints: cuffer\n             * console.log(buf.toString());\n             * // Also prints: cuffer (!)\n             * ```\n             * @since v0.3.0\n             * @deprecated Use `subarray` instead.\n             * @param [start=0] Where the new `Buffer` will start.\n             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).\n             */\n            slice(start?: number, end?: number): Buffer<ArrayBuffer>;\n            /**\n             * Returns a new `Buffer` that references the same memory as the original, but\n             * offset and cropped by the `start` and `end` indices.\n             *\n             * Specifying `end` greater than `buf.length` will return the same result as\n             * that of `end` equal to `buf.length`.\n             *\n             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).\n             *\n             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte\n             * // from the original `Buffer`.\n             *\n             * const buf1 = Buffer.allocUnsafe(26);\n             *\n             * for (let i = 0; i < 26; i++) {\n             *   // 97 is the decimal ASCII value for 'a'.\n             *   buf1[i] = i + 97;\n             * }\n             *\n             * const buf2 = buf1.subarray(0, 3);\n             *\n             * console.log(buf2.toString('ascii', 0, buf2.length));\n             * // Prints: abc\n             *\n             * buf1[0] = 33;\n             *\n             * console.log(buf2.toString('ascii', 0, buf2.length));\n             * // Prints: !bc\n             * ```\n             *\n             * Specifying negative indexes causes the slice to be generated relative to the\n             * end of `buf` rather than the beginning.\n             *\n             * ```js\n             * import { Buffer } from 'node:buffer';\n             *\n             * const buf = Buffer.from('buffer');\n             *\n             * console.log(buf.subarray(-6, -1).toString());\n             * // Prints: buffe\n             * // (Equivalent to buf.subarray(0, 5).)\n             *\n             * console.log(buf.subarray(-6, -2).toString());\n             * // Prints: buff\n             * // (Equivalent to buf.subarray(0, 4).)\n             *\n             * console.log(buf.subarray(-5, -2).toString());\n             * // Prints: uff\n             * // (Equivalent to buf.subarray(1, 4).)\n             * ```\n             * @since v3.0.0\n             * @param [start=0] Where the new `Buffer` will start.\n             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).\n             */\n            subarray(start?: number, end?: number): Buffer<TArrayBuffer>;\n        }\n    }\n    /** @deprecated Use `Buffer.allocUnsafeSlow()` instead. */\n    var SlowBuffer: {\n        /** @deprecated Use `Buffer.allocUnsafeSlow()` instead. */\n        new(size: number): Buffer<ArrayBuffer>;\n        prototype: Buffer;\n    };\n}\n"
        }
    ]
}