{
    "sourceFile": "node_modules/@types/formidable/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891954077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/// <reference types=\"node\" />\n\nimport { Stream, Writable } from \"stream\";\nimport Formidable = require(\"./Formidable\");\nimport parsers = require(\"./parsers/index\");\nimport PersistentFile = require(\"./PersistentFile\");\nimport VolatileFile = require(\"./VolatileFile\");\nimport errors = require(\"./FormidableError\");\n\ndeclare namespace formidable {\n    type BufferEncoding =\n        | \"ascii\"\n        | \"base64\"\n        | \"binary\"\n        | \"hex\"\n        | \"latin1\"\n        | \"ucs-2\"\n        | \"ucs2\"\n        | \"utf-8\"\n        | \"utf16le\"\n        | \"utf8\";\n\n    type EventNames =\n        /**\n         * Emitted when the request was aborted by the user. Right now this can be due to a 'timeout' or\n         * 'close' event on the socket. After this event is emitted, an error event will follow. In the\n         * future there will be a separate 'timeout' event (needs a change in the node core).\n         *\n         * @link https://github.com/node-formidable/formidable#aborted\n         */\n        | \"aborted\"\n        /**\n         * Emitted when the entire request has been received, and all contained files have finished\n         * flushing to disk. This is a great place for you to send your response.\n         *\n         * @link https://github.com/node-formidable/formidable#end\n         */\n        | \"end\"\n        /**\n         * Emitted when there is an error processing the incoming form. A request that experiences an\n         * error is automatically paused, you will have to manually call request.resume() if you want the\n         * request to continue firing 'data' events.\n         *\n         * @link https://github.com/node-formidable/formidable#error\n         */\n        | \"error\"\n        /**\n         * Emitted whenever a field / value pair has been received.\n         *\n         * @link https://github.com/node-formidable/formidable#field\n         */\n        | \"field\"\n        /**\n         * Emitted whenever a field / file pair has been received. file is an instance of File.\n         *\n         * @link https://github.com/node-formidable/formidable#file-1\n         */\n        | \"file\"\n        /**\n         * Emitted whenever a new file is detected in the upload stream. Use this event if you want to\n         * stream the file to somewhere else while buffering the upload on the file system.\n         *\n         * @link https://github.com/node-formidable/formidable#filebegin\n         */\n        | \"fileBegin\"\n        | \"headerEnd\"\n        | \"headerField\"\n        | \"headersEnd\"\n        | \"headerValue\"\n        | \"partBegin\"\n        | \"partData\"\n        /**\n         * Emitted after each incoming chunk of data that has been parsed. Can be used to roll your own\n         * progress bar.\n         *\n         * @link https://github.com/node-formidable/formidable#progress\n         */\n        | \"progress\";\n\n    interface Options {\n        /**\n         * sets encoding for incoming form fields\n         *\n         * @default 'utf-8'\n         */\n        encoding?: BufferEncoding | undefined;\n\n        /**\n         * the directory for placing file uploads in. You can move them later by using fs.rename()\n         *\n         * @default os.tmpdir()\n         */\n        uploadDir?: string | undefined;\n\n        /**\n         * to include the extensions of the original files or not\n         *\n         * @default false\n         */\n        keepExtensions?: boolean | undefined;\n\n        /**\n         * allow upload empty files\n         *\n         * @default true\n         */\n        allowEmptyFiles?: boolean | undefined;\n\n        /**\n         * the minium size of uploaded file\n         *\n         * @default 1\n         */\n        minFileSize?: number | undefined;\n\n        /**\n         * limit the amount of uploaded files, set Infinity for unlimited\n         *\n         * @default Infinity\n         */\n        maxFiles?: number | undefined;\n\n        /**\n         * limit the size of uploaded file\n         *\n         * @default 200 * 1024 * 1024\n         */\n        maxFileSize?: number | undefined;\n\n        /**\n         * limit the size of the batch of uploaded files\n         *\n         * @default options.maxFileSize\n         */\n        maxTotalFileSize?: number | undefined;\n\n        /**\n         * limit the number of fields, set 0 for unlimited\n         *\n         * @default 1000\n         */\n        maxFields?: number | undefined;\n\n        /**\n         * limit the amount of memory all fields together (except files) can allocate in bytes\n         *\n         * @default 20 * 1024 * 1024\n         */\n        maxFieldsSize?: number | undefined;\n\n        /**\n         * include checksums calculated for incoming files, set this to some hash algorithm, see\n         * crypto.createHash for available algorithms\n         *\n         * @default false\n         */\n        hashAlgorithm?: string | false | undefined;\n\n        /**\n         * which by default writes to host machine file system every file parsed; The function should\n         * return an instance of a Writable stream that will receive the uploaded file data. With this\n         * option, you can have any custom behavior regarding where the uploaded file data will be\n         * streamed for. If you are looking to write the file uploaded in other types of cloud storages\n         * (AWS S3, Azure blob storage, Google cloud storage) or private file storage, this is the option\n         * you're looking for. When this option is defined the default behavior of writing the file in the\n         * host machine file system is lost.\n         *\n         * @default null\n         */\n        fileWriteStreamHandler?: ((file?: VolatileFile) => Writable) | undefined;\n\n        /**\n         * when you call the .parse method, the files argument (of the callback) will contain arrays of\n         * files for inputs which submit multiple files using the HTML5 multiple attribute. Also, the\n         * fields argument will contain arrays of values for fields that have names ending with '[]'\n         *\n         * @default false\n         */\n        multiples?: boolean | undefined;\n\n        /**\n         * If true, makes direct folder uploads possible.\n         *\n         * @default false\n         */\n        createDirsFromUploads?: boolean | undefined;\n\n        /**\n         * Use it to control newFilename. Must return a string. Will be joined with\n         * options.uploadDir.\n         *\n         * @default undefined\n         */\n        filename?: (name: string, ext: string, part: Part, form: Formidable) => string;\n\n        enabledPlugins?: string[] | undefined;\n\n        filter?: (part: Part) => boolean;\n    }\n\n    type Fields<T extends string = string> = {\n        readonly [Prop in T]?: string[];\n    };\n    type Files<U extends string = string> = {\n        readonly [Prop in U]?: File[];\n    };\n\n    interface Part extends Stream {\n        name: string | null;\n        originalFilename: string | null;\n        mimetype: string | null;\n    }\n\n    /**\n     * @link https://github.com/node-formidable/formidable#file\n     */\n    interface FileJSON\n        extends Pick<File, \"size\" | \"filepath\" | \"originalFilename\" | \"mimetype\" | \"hash\" | \"newFilename\">\n    {\n        length: number;\n        mimetype: string | null;\n        mtime: Date | null;\n    }\n\n    interface File {\n        /**\n         * The size of the uploaded file in bytes. If the file is still being uploaded (see `'fileBegin'`\n         * event), this property says how many bytes of the file have been written to disk yet.\n         */\n        size: number;\n\n        /**\n         * The path this file is being written to. You can modify this in the `'fileBegin'` event in case\n         * you are unhappy with the way formidable generates a temporary path for your files.\n         */\n        filepath: string;\n\n        /**\n         * The name this file had according to the uploading client.\n         */\n        originalFilename: string | null;\n\n        /**\n         * Calculated based on options provided\n         */\n        newFilename: string;\n\n        /**\n         * The mime type of this file, according to the uploading client.\n         */\n        mimetype: string | null;\n\n        /**\n         * A Date object (or `null`) containing the time this file was last written to. Mostly here for\n         * compatibility with the [W3C File API Draft](http://dev.w3.org/2006/webapi/FileAPI/).\n         */\n        mtime?: Date | null | undefined;\n\n        hashAlgorithm: false | \"sha1\" | \"md5\" | \"sha256\";\n\n        /**\n         * If `options.hashAlgorithm` calculation was set, you can read the hex digest out of this var\n         * (at the end it will be a string).\n         */\n        hash?: string | null;\n\n        /**\n         * This method returns a JSON-representation of the file, allowing you to JSON.stringify() the\n         * file which is useful for logging and responding to requests.\n         *\n         * @link https://github.com/node-formidable/formidable#filetojson\n         */\n        toJSON(): FileJSON;\n\n        toString(): string;\n    }\n\n    interface EmitData {\n        formname: any;\n        key?: string | number | undefined;\n        name: \"fileBegin\" | \"file\";\n        value: File | string;\n    }\n\n    interface EventData {\n        name: EventNames;\n        buffer: string;\n        end: string;\n        formname: string;\n        key: string;\n        start: string;\n        value: string;\n    }\n\n    type PluginFunction = (formidable: Formidable, options: Partial<Options>) => void;\n\n    type MappedParsers = {\n        [P in keyof typeof parsers]: typeof parsers[P];\n    };\n\n    type Plugins = [\"octetstream\", \"querystring\", \"multipart\", \"json\"];\n\n    type Plugin = keyof { [K in Plugins[number]]: K };\n\n    type DefaultOptions = Required<Omit<Options, \"enabledPlugins\">> & {\n        enabledPlugins: EnabledPlugins;\n    };\n\n    type EnabledPlugins = {\n        [P in Plugin]: PluginFunction;\n    };\n}\n\ndeclare const formidable: {\n    (options?: formidable.Options): Formidable;\n    defaultOptions: formidable.DefaultOptions;\n    enabledPlugins: formidable.EnabledPlugins;\n    plugins: formidable.EnabledPlugins;\n    errors: typeof errors;\n    File: typeof PersistentFile;\n    PersistentFile: typeof PersistentFile;\n    VolatileFile: typeof VolatileFile;\n    Formidable: typeof Formidable;\n    formidable: (options?: formidable.Options) => Formidable;\n    // alias\n    IncomingForm: typeof Formidable;\n    // parsers and mapped parsers\n    parsers: typeof parsers;\n} & formidable.MappedParsers;\n\nexport = formidable;\n"
        }
    ]
}