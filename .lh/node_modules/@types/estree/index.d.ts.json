{
    "sourceFile": "node_modules/@types/estree/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891953889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// This definition file follows a somewhat unusual format. ESTree allows\n// runtime type checks based on the `type` parameter. In order to explain this\n// to typescript we want to use discriminated union types:\n// https://github.com/Microsoft/TypeScript/pull/9163\n//\n// For ESTree this is a bit tricky because the high level interfaces like\n// Node or Function are pulling double duty. We want to pass common fields down\n// to the interfaces that extend them (like Identifier or\n// ArrowFunctionExpression), but you can't extend a type union or enforce\n// common fields on them. So we've split the high level interfaces into two\n// types, a base type which passes down inherited fields, and a type union of\n// all types which extend the base type. Only the type union is exported, and\n// the union is how other types refer to the collection of inheriting types.\n//\n// This makes the definitions file here somewhat more difficult to maintain,\n// but it has the notable advantage of making ESTree much easier to use as\n// an end user.\n\nexport interface BaseNodeWithoutComments {\n    // Every leaf interface that extends BaseNode must specify a type property.\n    // The type property should be a string literal. For example, Identifier\n    // has: `type: \"Identifier\"`\n    type: string;\n    loc?: SourceLocation | null | undefined;\n    range?: [number, number] | undefined;\n}\n\nexport interface BaseNode extends BaseNodeWithoutComments {\n    leadingComments?: Comment[] | undefined;\n    trailingComments?: Comment[] | undefined;\n}\n\nexport interface NodeMap {\n    AssignmentProperty: AssignmentProperty;\n    CatchClause: CatchClause;\n    Class: Class;\n    ClassBody: ClassBody;\n    Expression: Expression;\n    Function: Function;\n    Identifier: Identifier;\n    Literal: Literal;\n    MethodDefinition: MethodDefinition;\n    ModuleDeclaration: ModuleDeclaration;\n    ModuleSpecifier: ModuleSpecifier;\n    Pattern: Pattern;\n    PrivateIdentifier: PrivateIdentifier;\n    Program: Program;\n    Property: Property;\n    PropertyDefinition: PropertyDefinition;\n    SpreadElement: SpreadElement;\n    Statement: Statement;\n    Super: Super;\n    SwitchCase: SwitchCase;\n    TemplateElement: TemplateElement;\n    VariableDeclarator: VariableDeclarator;\n}\n\nexport type Node = NodeMap[keyof NodeMap];\n\nexport interface Comment extends BaseNodeWithoutComments {\n    type: \"Line\" | \"Block\";\n    value: string;\n}\n\nexport interface SourceLocation {\n    source?: string | null | undefined;\n    start: Position;\n    end: Position;\n}\n\nexport interface Position {\n    /** >= 1 */\n    line: number;\n    /** >= 0 */\n    column: number;\n}\n\nexport interface Program extends BaseNode {\n    type: \"Program\";\n    sourceType: \"script\" | \"module\";\n    body: Array<Directive | Statement | ModuleDeclaration>;\n    comments?: Comment[] | undefined;\n}\n\nexport interface Directive extends BaseNode {\n    type: \"ExpressionStatement\";\n    expression: Literal;\n    directive: string;\n}\n\nexport interface BaseFunction extends BaseNode {\n    params: Pattern[];\n    generator?: boolean | undefined;\n    async?: boolean | undefined;\n    // The body is either BlockStatement or Expression because arrow functions\n    // can have a body that's either. FunctionDeclarations and\n    // FunctionExpressions have only BlockStatement bodies.\n    body: BlockStatement | Expression;\n}\n\nexport type Function = FunctionDeclaration | FunctionExpression | ArrowFunctionExpression;\n\nexport type Statement =\n    | ExpressionStatement\n    | BlockStatement\n    | StaticBlock\n    | EmptyStatement\n    | DebuggerStatement\n    | WithStatement\n    | ReturnStatement\n    | LabeledStatement\n    | BreakStatement\n    | ContinueStatement\n    | IfStatement\n    | SwitchStatement\n    | ThrowStatement\n    | TryStatement\n    | WhileStatement\n    | DoWhileStatement\n    | ForStatement\n    | ForInStatement\n    | ForOfStatement\n    | Declaration;\n\nexport interface BaseStatement extends BaseNode {}\n\nexport interface EmptyStatement extends BaseStatement {\n    type: \"EmptyStatement\";\n}\n\nexport interface BlockStatement extends BaseStatement {\n    type: \"BlockStatement\";\n    body: Statement[];\n    innerComments?: Comment[] | undefined;\n}\n\nexport interface StaticBlock extends Omit<BlockStatement, \"type\"> {\n    type: \"StaticBlock\";\n}\n\nexport interface ExpressionStatement extends BaseStatement {\n    type: \"ExpressionStatement\";\n    expression: Expression;\n}\n\nexport interface IfStatement extends BaseStatement {\n    type: \"IfStatement\";\n    test: Expression;\n    consequent: Statement;\n    alternate?: Statement | null | undefined;\n}\n\nexport interface LabeledStatement extends BaseStatement {\n    type: \"LabeledStatement\";\n    label: Identifier;\n    body: Statement;\n}\n\nexport interface BreakStatement extends BaseStatement {\n    type: \"BreakStatement\";\n    label?: Identifier | null | undefined;\n}\n\nexport interface ContinueStatement extends BaseStatement {\n    type: \"ContinueStatement\";\n    label?: Identifier | null | undefined;\n}\n\nexport interface WithStatement extends BaseStatement {\n    type: \"WithStatement\";\n    object: Expression;\n    body: Statement;\n}\n\nexport interface SwitchStatement extends BaseStatement {\n    type: \"SwitchStatement\";\n    discriminant: Expression;\n    cases: SwitchCase[];\n}\n\nexport interface ReturnStatement extends BaseStatement {\n    type: \"ReturnStatement\";\n    argument?: Expression | null | undefined;\n}\n\nexport interface ThrowStatement extends BaseStatement {\n    type: \"ThrowStatement\";\n    argument: Expression;\n}\n\nexport interface TryStatement extends BaseStatement {\n    type: \"TryStatement\";\n    block: BlockStatement;\n    handler?: CatchClause | null | undefined;\n    finalizer?: BlockStatement | null | undefined;\n}\n\nexport interface WhileStatement extends BaseStatement {\n    type: \"WhileStatement\";\n    test: Expression;\n    body: Statement;\n}\n\nexport interface DoWhileStatement extends BaseStatement {\n    type: \"DoWhileStatement\";\n    body: Statement;\n    test: Expression;\n}\n\nexport interface ForStatement extends BaseStatement {\n    type: \"ForStatement\";\n    init?: VariableDeclaration | Expression | null | undefined;\n    test?: Expression | null | undefined;\n    update?: Expression | null | undefined;\n    body: Statement;\n}\n\nexport interface BaseForXStatement extends BaseStatement {\n    left: VariableDeclaration | Pattern;\n    right: Expression;\n    body: Statement;\n}\n\nexport interface ForInStatement extends BaseForXStatement {\n    type: \"ForInStatement\";\n}\n\nexport interface DebuggerStatement extends BaseStatement {\n    type: \"DebuggerStatement\";\n}\n\nexport type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration;\n\nexport interface BaseDeclaration extends BaseStatement {}\n\nexport interface MaybeNamedFunctionDeclaration extends BaseFunction, BaseDeclaration {\n    type: \"FunctionDeclaration\";\n    /** It is null when a function declaration is a part of the `export default function` statement */\n    id: Identifier | null;\n    body: BlockStatement;\n}\n\nexport interface FunctionDeclaration extends MaybeNamedFunctionDeclaration {\n    id: Identifier;\n}\n\nexport interface VariableDeclaration extends BaseDeclaration {\n    type: \"VariableDeclaration\";\n    declarations: VariableDeclarator[];\n    kind: \"var\" | \"let\" | \"const\";\n}\n\nexport interface VariableDeclarator extends BaseNode {\n    type: \"VariableDeclarator\";\n    id: Pattern;\n    init?: Expression | null | undefined;\n}\n\nexport interface ExpressionMap {\n    ArrayExpression: ArrayExpression;\n    ArrowFunctionExpression: ArrowFunctionExpression;\n    AssignmentExpression: AssignmentExpression;\n    AwaitExpression: AwaitExpression;\n    BinaryExpression: BinaryExpression;\n    CallExpression: CallExpression;\n    ChainExpression: ChainExpression;\n    ClassExpression: ClassExpression;\n    ConditionalExpression: ConditionalExpression;\n    FunctionExpression: FunctionExpression;\n    Identifier: Identifier;\n    ImportExpression: ImportExpression;\n    Literal: Literal;\n    LogicalExpression: LogicalExpression;\n    MemberExpression: MemberExpression;\n    MetaProperty: MetaProperty;\n    NewExpression: NewExpression;\n    ObjectExpression: ObjectExpression;\n    SequenceExpression: SequenceExpression;\n    TaggedTemplateExpression: TaggedTemplateExpression;\n    TemplateLiteral: TemplateLiteral;\n    ThisExpression: ThisExpression;\n    UnaryExpression: UnaryExpression;\n    UpdateExpression: UpdateExpression;\n    YieldExpression: YieldExpression;\n}\n\nexport type Expression = ExpressionMap[keyof ExpressionMap];\n\nexport interface BaseExpression extends BaseNode {}\n\nexport type ChainElement = SimpleCallExpression | MemberExpression;\n\nexport interface ChainExpression extends BaseExpression {\n    type: \"ChainExpression\";\n    expression: ChainElement;\n}\n\nexport interface ThisExpression extends BaseExpression {\n    type: \"ThisExpression\";\n}\n\nexport interface ArrayExpression extends BaseExpression {\n    type: \"ArrayExpression\";\n    elements: Array<Expression | SpreadElement | null>;\n}\n\nexport interface ObjectExpression extends BaseExpression {\n    type: \"ObjectExpression\";\n    properties: Array<Property | SpreadElement>;\n}\n\nexport interface PrivateIdentifier extends BaseNode {\n    type: \"PrivateIdentifier\";\n    name: string;\n}\n\nexport interface Property extends BaseNode {\n    type: \"Property\";\n    key: Expression | PrivateIdentifier;\n    value: Expression | Pattern; // Could be an AssignmentProperty\n    kind: \"init\" | \"get\" | \"set\";\n    method: boolean;\n    shorthand: boolean;\n    computed: boolean;\n}\n\nexport interface PropertyDefinition extends BaseNode {\n    type: \"PropertyDefinition\";\n    key: Expression | PrivateIdentifier;\n    value?: Expression | null | undefined;\n    computed: boolean;\n    static: boolean;\n}\n\nexport interface FunctionExpression extends BaseFunction, BaseExpression {\n    id?: Identifier | null | undefined;\n    type: \"FunctionExpression\";\n    body: BlockStatement;\n}\n\nexport interface SequenceExpression extends BaseExpression {\n    type: \"SequenceExpression\";\n    expressions: Expression[];\n}\n\nexport interface UnaryExpression extends BaseExpression {\n    type: \"UnaryExpression\";\n    operator: UnaryOperator;\n    prefix: true;\n    argument: Expression;\n}\n\nexport interface BinaryExpression extends BaseExpression {\n    type: \"BinaryExpression\";\n    operator: BinaryOperator;\n    left: Expression | PrivateIdentifier;\n    right: Expression;\n}\n\nexport interface AssignmentExpression extends BaseExpression {\n    type: \"AssignmentExpression\";\n    operator: AssignmentOperator;\n    left: Pattern | MemberExpression;\n    right: Expression;\n}\n\nexport interface UpdateExpression extends BaseExpression {\n    type: \"UpdateExpression\";\n    operator: UpdateOperator;\n    argument: Expression;\n    prefix: boolean;\n}\n\nexport interface LogicalExpression extends BaseExpression {\n    type: \"LogicalExpression\";\n    operator: LogicalOperator;\n    left: Expression;\n    right: Expression;\n}\n\nexport interface ConditionalExpression extends BaseExpression {\n    type: \"ConditionalExpression\";\n    test: Expression;\n    alternate: Expression;\n    consequent: Expression;\n}\n\nexport interface BaseCallExpression extends BaseExpression {\n    callee: Expression | Super;\n    arguments: Array<Expression | SpreadElement>;\n}\nexport type CallExpression = SimpleCallExpression | NewExpression;\n\nexport interface SimpleCallExpression extends BaseCallExpression {\n    type: \"CallExpression\";\n    optional: boolean;\n}\n\nexport interface NewExpression extends BaseCallExpression {\n    type: \"NewExpression\";\n}\n\nexport interface MemberExpression extends BaseExpression, BasePattern {\n    type: \"MemberExpression\";\n    object: Expression | Super;\n    property: Expression | PrivateIdentifier;\n    computed: boolean;\n    optional: boolean;\n}\n\nexport type Pattern = Identifier | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | MemberExpression;\n\nexport interface BasePattern extends BaseNode {}\n\nexport interface SwitchCase extends BaseNode {\n    type: \"SwitchCase\";\n    test?: Expression | null | undefined;\n    consequent: Statement[];\n}\n\nexport interface CatchClause extends BaseNode {\n    type: \"CatchClause\";\n    param: Pattern | null;\n    body: BlockStatement;\n}\n\nexport interface Identifier extends BaseNode, BaseExpression, BasePattern {\n    type: \"Identifier\";\n    name: string;\n}\n\nexport type Literal = SimpleLiteral | RegExpLiteral | BigIntLiteral;\n\nexport interface SimpleLiteral extends BaseNode, BaseExpression {\n    type: \"Literal\";\n    value: string | boolean | number | null;\n    raw?: string | undefined;\n}\n\nexport interface RegExpLiteral extends BaseNode, BaseExpression {\n    type: \"Literal\";\n    value?: RegExp | null | undefined;\n    regex: {\n        pattern: string;\n        flags: string;\n    };\n    raw?: string | undefined;\n}\n\nexport interface BigIntLiteral extends BaseNode, BaseExpression {\n    type: \"Literal\";\n    value?: bigint | null | undefined;\n    bigint: string;\n    raw?: string | undefined;\n}\n\nexport type UnaryOperator = \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\";\n\nexport type BinaryOperator =\n    | \"==\"\n    | \"!=\"\n    | \"===\"\n    | \"!==\"\n    | \"<\"\n    | \"<=\"\n    | \">\"\n    | \">=\"\n    | \"<<\"\n    | \">>\"\n    | \">>>\"\n    | \"+\"\n    | \"-\"\n    | \"*\"\n    | \"/\"\n    | \"%\"\n    | \"**\"\n    | \"|\"\n    | \"^\"\n    | \"&\"\n    | \"in\"\n    | \"instanceof\";\n\nexport type LogicalOperator = \"||\" | \"&&\" | \"??\";\n\nexport type AssignmentOperator =\n    | \"=\"\n    | \"+=\"\n    | \"-=\"\n    | \"*=\"\n    | \"/=\"\n    | \"%=\"\n    | \"**=\"\n    | \"<<=\"\n    | \">>=\"\n    | \">>>=\"\n    | \"|=\"\n    | \"^=\"\n    | \"&=\"\n    | \"||=\"\n    | \"&&=\"\n    | \"??=\";\n\nexport type UpdateOperator = \"++\" | \"--\";\n\nexport interface ForOfStatement extends BaseForXStatement {\n    type: \"ForOfStatement\";\n    await: boolean;\n}\n\nexport interface Super extends BaseNode {\n    type: \"Super\";\n}\n\nexport interface SpreadElement extends BaseNode {\n    type: \"SpreadElement\";\n    argument: Expression;\n}\n\nexport interface ArrowFunctionExpression extends BaseExpression, BaseFunction {\n    type: \"ArrowFunctionExpression\";\n    expression: boolean;\n    body: BlockStatement | Expression;\n}\n\nexport interface YieldExpression extends BaseExpression {\n    type: \"YieldExpression\";\n    argument?: Expression | null | undefined;\n    delegate: boolean;\n}\n\nexport interface TemplateLiteral extends BaseExpression {\n    type: \"TemplateLiteral\";\n    quasis: TemplateElement[];\n    expressions: Expression[];\n}\n\nexport interface TaggedTemplateExpression extends BaseExpression {\n    type: \"TaggedTemplateExpression\";\n    tag: Expression;\n    quasi: TemplateLiteral;\n}\n\nexport interface TemplateElement extends BaseNode {\n    type: \"TemplateElement\";\n    tail: boolean;\n    value: {\n        /** It is null when the template literal is tagged and the text has an invalid escape (e.g. - tag`\\unicode and \\u{55}`) */\n        cooked?: string | null | undefined;\n        raw: string;\n    };\n}\n\nexport interface AssignmentProperty extends Property {\n    value: Pattern;\n    kind: \"init\";\n    method: boolean; // false\n}\n\nexport interface ObjectPattern extends BasePattern {\n    type: \"ObjectPattern\";\n    properties: Array<AssignmentProperty | RestElement>;\n}\n\nexport interface ArrayPattern extends BasePattern {\n    type: \"ArrayPattern\";\n    elements: Array<Pattern | null>;\n}\n\nexport interface RestElement extends BasePattern {\n    type: \"RestElement\";\n    argument: Pattern;\n}\n\nexport interface AssignmentPattern extends BasePattern {\n    type: \"AssignmentPattern\";\n    left: Pattern;\n    right: Expression;\n}\n\nexport type Class = ClassDeclaration | ClassExpression;\nexport interface BaseClass extends BaseNode {\n    superClass?: Expression | null | undefined;\n    body: ClassBody;\n}\n\nexport interface ClassBody extends BaseNode {\n    type: \"ClassBody\";\n    body: Array<MethodDefinition | PropertyDefinition | StaticBlock>;\n}\n\nexport interface MethodDefinition extends BaseNode {\n    type: \"MethodDefinition\";\n    key: Expression | PrivateIdentifier;\n    value: FunctionExpression;\n    kind: \"constructor\" | \"method\" | \"get\" | \"set\";\n    computed: boolean;\n    static: boolean;\n}\n\nexport interface MaybeNamedClassDeclaration extends BaseClass, BaseDeclaration {\n    type: \"ClassDeclaration\";\n    /** It is null when a class declaration is a part of the `export default class` statement */\n    id: Identifier | null;\n}\n\nexport interface ClassDeclaration extends MaybeNamedClassDeclaration {\n    id: Identifier;\n}\n\nexport interface ClassExpression extends BaseClass, BaseExpression {\n    type: \"ClassExpression\";\n    id?: Identifier | null | undefined;\n}\n\nexport interface MetaProperty extends BaseExpression {\n    type: \"MetaProperty\";\n    meta: Identifier;\n    property: Identifier;\n}\n\nexport type ModuleDeclaration =\n    | ImportDeclaration\n    | ExportNamedDeclaration\n    | ExportDefaultDeclaration\n    | ExportAllDeclaration;\nexport interface BaseModuleDeclaration extends BaseNode {}\n\nexport type ModuleSpecifier = ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier;\nexport interface BaseModuleSpecifier extends BaseNode {\n    local: Identifier;\n}\n\nexport interface ImportDeclaration extends BaseModuleDeclaration {\n    type: \"ImportDeclaration\";\n    specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;\n    source: Literal;\n}\n\nexport interface ImportSpecifier extends BaseModuleSpecifier {\n    type: \"ImportSpecifier\";\n    imported: Identifier | Literal;\n}\n\nexport interface ImportExpression extends BaseExpression {\n    type: \"ImportExpression\";\n    source: Expression;\n}\n\nexport interface ImportDefaultSpecifier extends BaseModuleSpecifier {\n    type: \"ImportDefaultSpecifier\";\n}\n\nexport interface ImportNamespaceSpecifier extends BaseModuleSpecifier {\n    type: \"ImportNamespaceSpecifier\";\n}\n\nexport interface ExportNamedDeclaration extends BaseModuleDeclaration {\n    type: \"ExportNamedDeclaration\";\n    declaration?: Declaration | null | undefined;\n    specifiers: ExportSpecifier[];\n    source?: Literal | null | undefined;\n}\n\nexport interface ExportSpecifier extends Omit<BaseModuleSpecifier, \"local\"> {\n    type: \"ExportSpecifier\";\n    local: Identifier | Literal;\n    exported: Identifier | Literal;\n}\n\nexport interface ExportDefaultDeclaration extends BaseModuleDeclaration {\n    type: \"ExportDefaultDeclaration\";\n    declaration: MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | Expression;\n}\n\nexport interface ExportAllDeclaration extends BaseModuleDeclaration {\n    type: \"ExportAllDeclaration\";\n    exported: Identifier | Literal | null;\n    source: Literal;\n}\n\nexport interface AwaitExpression extends BaseExpression {\n    type: \"AwaitExpression\";\n    argument: Expression;\n}\n"
        }
    ]
}