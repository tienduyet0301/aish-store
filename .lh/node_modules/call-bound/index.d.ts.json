{
    "sourceFile": "node_modules/call-bound/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892069319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "type Intrinsic = typeof globalThis;\n\ntype IntrinsicName = keyof Intrinsic | `%${keyof Intrinsic}%`;\n\ntype IntrinsicPath = IntrinsicName | `${StripPercents<IntrinsicName>}.${string}` | `%${StripPercents<IntrinsicName>}.${string}%`;\n\ntype AllowMissing = boolean;\n\ntype StripPercents<T extends string> = T extends `%${infer U}%` ? U : T;\n\ntype BindMethodPrecise<F> =\n  F extends (this: infer This, ...args: infer Args) => infer R\n  ? (obj: This, ...args: Args) => R\n  : F extends {\n    (this: infer This1, ...args: infer Args1): infer R1;\n    (this: infer This2, ...args: infer Args2): infer R2\n  }\n  ? {\n    (obj: This1, ...args: Args1): R1;\n    (obj: This2, ...args: Args2): R2\n  }\n  : never\n\n// Extract method type from a prototype\ntype GetPrototypeMethod<T extends keyof typeof globalThis, M extends string> =\n  (typeof globalThis)[T] extends { prototype: any }\n  ? M extends keyof (typeof globalThis)[T]['prototype']\n  ? (typeof globalThis)[T]['prototype'][M]\n  : never\n  : never\n\n// Get static property/method\ntype GetStaticMember<T extends keyof typeof globalThis, P extends string> =\n  P extends keyof (typeof globalThis)[T] ? (typeof globalThis)[T][P] : never\n\n// Type that maps string path to actual bound function or value with better precision\ntype BoundIntrinsic<S extends string> =\n  S extends `${infer Obj}.prototype.${infer Method}`\n  ? Obj extends keyof typeof globalThis\n  ? BindMethodPrecise<GetPrototypeMethod<Obj, Method & string>>\n  : unknown\n  : S extends `${infer Obj}.${infer Prop}`\n  ? Obj extends keyof typeof globalThis\n  ? GetStaticMember<Obj, Prop & string>\n  : unknown\n  : unknown\n\ndeclare function arraySlice<T>(array: readonly T[], start?: number, end?: number): T[];\ndeclare function arraySlice<T>(array: ArrayLike<T>, start?: number, end?: number): T[];\ndeclare function arraySlice<T>(array: IArguments, start?: number, end?: number): T[];\n\n// Special cases for methods that need explicit typing\ninterface SpecialCases {\n  '%Object.prototype.isPrototypeOf%': (thisArg: {}, obj: unknown) => boolean;\n  '%String.prototype.replace%': {\n    (str: string, searchValue: string | RegExp, replaceValue: string): string;\n    (str: string, searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string\n  };\n  '%Object.prototype.toString%': (obj: {}) => string;\n  '%Object.prototype.hasOwnProperty%': (obj: {}, v: PropertyKey) => boolean;\n  '%Array.prototype.slice%': typeof arraySlice;\n  '%Array.prototype.map%': <T, U>(array: readonly T[], callbackfn: (value: T, index: number, array: readonly T[]) => U, thisArg?: any) => U[];\n  '%Array.prototype.filter%': <T>(array: readonly T[], predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any) => T[];\n  '%Array.prototype.indexOf%': <T>(array: readonly T[], searchElement: T, fromIndex?: number) => number;\n  '%Function.prototype.apply%': <T, A extends any[], R>(fn: (...args: A) => R, thisArg: any, args: A) => R;\n  '%Function.prototype.call%': <T, A extends any[], R>(fn: (...args: A) => R, thisArg: any, ...args: A) => R;\n  '%Function.prototype.bind%': <T, A extends any[], R>(fn: (...args: A) => R, thisArg: any, ...args: A) => (...remainingArgs: A) => R;\n  '%Promise.prototype.then%': {\n    <T, R>(promise: Promise<T>, onfulfilled: (value: T) => R | PromiseLike<R>): Promise<R>;\n    <T, R>(promise: Promise<T>, onfulfilled: ((value: T) => R | PromiseLike<R>) | undefined | null, onrejected: (reason: any) => R | PromiseLike<R>): Promise<R>;\n  };\n  '%RegExp.prototype.test%': (regexp: RegExp, str: string) => boolean;\n  '%RegExp.prototype.exec%': (regexp: RegExp, str: string) => RegExpExecArray | null;\n  '%Error.prototype.toString%': (error: Error) => string;\n  '%TypeError.prototype.toString%': (error: TypeError) => string;\n  '%String.prototype.split%': (\n        obj: unknown,\n        splitter: string | RegExp | {\n            [Symbol.split](string: string, limit?: number): string[];\n        },\n        limit?: number | undefined\n    ) => string[];\n}\n\n/**\n * Returns a bound function for a prototype method, or a value for a static property.\n *\n * @param name - The name of the intrinsic (e.g. 'Array.prototype.slice')\n * @param {AllowMissing} [allowMissing] - Whether to allow missing intrinsics (default: false)\n */\ndeclare function callBound<K extends keyof SpecialCases | StripPercents<keyof SpecialCases>, S extends IntrinsicPath>(name: K, allowMissing?: AllowMissing): SpecialCases[`%${StripPercents<K>}%`];\ndeclare function callBound<K extends keyof SpecialCases | StripPercents<keyof SpecialCases>, S extends IntrinsicPath>(name: S, allowMissing?: AllowMissing): BoundIntrinsic<S>;\n\nexport = callBound;\n"
        }
    ]
}