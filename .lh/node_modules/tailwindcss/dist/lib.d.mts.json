{
    "sourceFile": "node_modules/tailwindcss/dist/lib.d.mts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893048716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { U as UserConfig, P as Plugin } from './types-B254mqw1.mjs';\nimport { V as Variant, C as Candidate } from './resolve-config-QUZ9b-Gn.mjs';\nimport './colors.mjs';\n\ndeclare const enum ThemeOptions {\n    NONE = 0,\n    INLINE = 1,\n    REFERENCE = 2,\n    DEFAULT = 4,\n    STATIC = 8,\n    USED = 16\n}\ndeclare class Theme {\n    #private;\n    private values;\n    private keyframes;\n    prefix: string | null;\n    constructor(values?: Map<string, {\n        value: string;\n        options: ThemeOptions;\n    }>, keyframes?: Set<AtRule>);\n    add(key: string, value: string, options?: ThemeOptions): void;\n    keysInNamespaces(themeKeys: Iterable<ThemeKey>): string[];\n    get(themeKeys: ThemeKey[]): string | null;\n    hasDefault(key: string): boolean;\n    getOptions(key: string): ThemeOptions;\n    entries(): IterableIterator<[string, {\n        value: string;\n        options: ThemeOptions;\n    }]> | [string, {\n        value: string;\n        options: ThemeOptions;\n    }][];\n    prefixKey(key: string): string;\n    clearNamespace(namespace: string, clearOptions: ThemeOptions): void;\n    markUsedVariable(themeKey: string): void;\n    resolve(candidateValue: string | null, themeKeys: ThemeKey[]): string | null;\n    resolveValue(candidateValue: string | null, themeKeys: ThemeKey[]): string | null;\n    resolveWith(candidateValue: string, themeKeys: ThemeKey[], nestedKeys?: `--${string}`[]): [string, Record<string, string>] | null;\n    namespace(namespace: string): Map<string | null, string>;\n    addKeyframes(value: AtRule): void;\n    getKeyframes(): AtRule[];\n}\ntype ThemeKey = `--${string}`;\n\ntype VariantFn<T extends Variant['kind']> = (rule: Rule, variant: Extract<Variant, {\n    kind: T;\n}>) => null | void;\ntype CompareFn = (a: Variant, z: Variant) => number;\ndeclare const enum Compounds {\n    Never = 0,\n    AtRules = 1,\n    StyleRules = 2\n}\ndeclare class Variants {\n    compareFns: Map<number, CompareFn>;\n    variants: Map<string, {\n        kind: Variant[\"kind\"];\n        order: number;\n        applyFn: VariantFn<any>;\n        compoundsWith: Compounds;\n        compounds: Compounds;\n    }>;\n    private completions;\n    /**\n     * Registering a group of variants should result in the same sort number for\n     * all the variants. This is to ensure that the variants are applied in the\n     * correct order.\n     */\n    private groupOrder;\n    /**\n     * Keep track of the last sort order instead of using the size of the map to\n     * avoid unnecessarily skipping order numbers.\n     */\n    private lastOrder;\n    static(name: string, applyFn: VariantFn<'static'>, { compounds, order }?: {\n        compounds?: Compounds;\n        order?: number;\n    }): void;\n    fromAst(name: string, ast: AstNode[]): void;\n    functional(name: string, applyFn: VariantFn<'functional'>, { compounds, order }?: {\n        compounds?: Compounds;\n        order?: number;\n    }): void;\n    compound(name: string, compoundsWith: Compounds, applyFn: VariantFn<'compound'>, { compounds, order }?: {\n        compounds?: Compounds;\n        order?: number;\n    }): void;\n    group(fn: () => void, compareFn?: CompareFn): void;\n    has(name: string): boolean;\n    get(name: string): {\n        kind: Variant[\"kind\"];\n        order: number;\n        applyFn: VariantFn<any>;\n        compoundsWith: Compounds;\n        compounds: Compounds;\n    } | undefined;\n    kind(name: string): \"arbitrary\" | \"static\" | \"functional\" | \"compound\";\n    compoundsWith(parent: string, child: string | Variant): boolean;\n    suggest(name: string, suggestions: () => string[]): void;\n    getCompletions(name: string): string[];\n    compare(a: Variant | null, z: Variant | null): number;\n    keys(): IterableIterator<string>;\n    entries(): IterableIterator<[string, {\n        kind: Variant[\"kind\"];\n        order: number;\n        applyFn: VariantFn<any>;\n        compoundsWith: Compounds;\n        compounds: Compounds;\n    }]>;\n    private set;\n    private nextOrder;\n}\n\ndeclare function compileAstNodes(candidate: Candidate, designSystem: DesignSystem): {\n    node: AstNode;\n    propertySort: {\n        order: number[];\n        count: number;\n    };\n}[];\n\ninterface ClassMetadata {\n    modifiers: string[];\n}\ntype ClassEntry = [string, ClassMetadata];\ninterface SelectorOptions {\n    modifier?: string;\n    value?: string;\n}\ninterface VariantEntry {\n    name: string;\n    isArbitrary: boolean;\n    values: string[];\n    hasDash: boolean;\n    selectors: (options: SelectorOptions) => string[];\n}\n\ntype CompileFn<T extends Candidate['kind']> = (value: Extract<Candidate, {\n    kind: T;\n}>) => AstNode[] | undefined | null;\ninterface SuggestionGroup {\n    supportsNegative?: boolean;\n    values: (string | null)[];\n    modifiers: string[];\n}\ntype UtilityOptions = {\n    types: string[];\n};\ntype Utility = {\n    kind: 'static' | 'functional';\n    compileFn: CompileFn<any>;\n    options?: UtilityOptions;\n};\ndeclare class Utilities {\n    private utilities;\n    private completions;\n    static(name: string, compileFn: CompileFn<'static'>): void;\n    functional(name: string, compileFn: CompileFn<'functional'>, options?: UtilityOptions): void;\n    has(name: string, kind: 'static' | 'functional'): boolean;\n    get(name: string): Utility[];\n    getCompletions(name: string): SuggestionGroup[];\n    suggest(name: string, groups: () => SuggestionGroup[]): void;\n    keys(kind: 'static' | 'functional'): string[];\n}\n\ntype DesignSystem = {\n    theme: Theme;\n    utilities: Utilities;\n    variants: Variants;\n    invalidCandidates: Set<string>;\n    important: boolean;\n    getClassOrder(classes: string[]): [string, bigint | null][];\n    getClassList(): ClassEntry[];\n    getVariants(): VariantEntry[];\n    parseCandidate(candidate: string): Readonly<Candidate>[];\n    parseVariant(variant: string): Readonly<Variant> | null;\n    compileAstNodes(candidate: Candidate): ReturnType<typeof compileAstNodes>;\n    getVariantOrder(): Map<Variant, number>;\n    resolveThemeValue(path: string): string | undefined;\n    trackUsedVariables(raw: string): void;\n    candidatesToCss(classes: string[]): (string | null)[];\n};\n\ntype StyleRule = {\n    kind: 'rule';\n    selector: string;\n    nodes: AstNode[];\n};\ntype AtRule = {\n    kind: 'at-rule';\n    name: string;\n    params: string;\n    nodes: AstNode[];\n};\ntype Declaration = {\n    kind: 'declaration';\n    property: string;\n    value: string | undefined;\n    important: boolean;\n};\ntype Comment = {\n    kind: 'comment';\n    value: string;\n};\ntype Context = {\n    kind: 'context';\n    context: Record<string, string | boolean>;\n    nodes: AstNode[];\n};\ntype AtRoot = {\n    kind: 'at-root';\n    nodes: AstNode[];\n};\ntype Rule = StyleRule | AtRule;\ntype AstNode = StyleRule | AtRule | Declaration | Comment | Context | AtRoot;\n\ntype Config = UserConfig;\ntype CompileOptions = {\n    base?: string;\n    loadModule?: (id: string, base: string, resourceHint: 'plugin' | 'config') => Promise<{\n        module: Plugin | Config;\n        base: string;\n    }>;\n    loadStylesheet?: (id: string, base: string) => Promise<{\n        content: string;\n        base: string;\n    }>;\n};\ntype Root = null | 'none' | {\n    base: string;\n    pattern: string;\n};\ndeclare const enum Features {\n    None = 0,\n    AtApply = 1,\n    AtImport = 2,\n    JsPluginCompat = 4,\n    ThemeFunction = 8,\n    Utilities = 16,\n    Variants = 32\n}\ndeclare function compileAst(input: AstNode[], opts?: CompileOptions): Promise<{\n    globs: {\n        base: string;\n        pattern: string;\n    }[];\n    root: Root;\n    features: Features;\n    build(candidates: string[]): AstNode[];\n}>;\ndeclare function compile(css: string, opts?: CompileOptions): Promise<{\n    globs: {\n        base: string;\n        pattern: string;\n    }[];\n    root: Root;\n    features: Features;\n    build(candidates: string[]): string;\n}>;\ndeclare function __unstable__loadDesignSystem(css: string, opts?: CompileOptions): Promise<DesignSystem>;\ndeclare function postcssPluginWarning(): void;\n\nexport { type Config, Features, __unstable__loadDesignSystem, compile, compileAst, postcssPluginWarning as default };\n"
        }
    ]
}