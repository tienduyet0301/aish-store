{
    "sourceFile": "node_modules/ts-api-utils/lib/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893059648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import ts from 'typescript';\n\n/**\n * Callback type used for {@link forEachComment}.\n * @category Callbacks\n * @param fullText Full parsed text of the comment.\n * @param comment Text range of the comment in its file.\n * @example\n * ```ts\n * let onComment: ForEachCommentCallback = (fullText, comment) => {\n *    console.log(`Found comment at position ${comment.pos}: '${fullText}'.`);\n * };\n * ```\n */\ntype ForEachCommentCallback = (fullText: string, comment: ts.CommentRange) => void;\n/**\n * Iterates over all comments owned by `node` or its children.\n * @category Nodes - Other Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * forEachComment(node, (fullText, comment) => {\n *    console.log(`Found comment at position ${comment.pos}: '${fullText}'.`);\n * });\n * ```\n */\ndeclare function forEachComment(node: ts.Node, callback: ForEachCommentCallback, sourceFile?: ts.SourceFile): void;\n\n/**\n * An option that can be tested with {@link isCompilerOptionEnabled}.\n * @category Compiler Options\n */\ntype BooleanCompilerOptions = keyof {\n    [K in keyof ts.CompilerOptions as NonNullable<ts.CompilerOptions[K]> extends boolean ? K : never]: unknown;\n};\n/**\n * An option that can be tested with {@link isStrictCompilerOptionEnabled}.\n * @category Compiler Options\n */\ntype StrictCompilerOption = \"alwaysStrict\" | \"noImplicitAny\" | \"noImplicitThis\" | \"strictBindCallApply\" | \"strictFunctionTypes\" | \"strictNullChecks\" | \"strictPropertyInitialization\";\n/**\n * Checks if a given compiler option is enabled.\n * It handles dependencies of options, e.g. `declaration` is implicitly enabled by `composite` or `strictNullChecks` is enabled by `strict`.\n * However, it does not check dependencies that are already checked and reported as errors, e.g. `checkJs` without `allowJs`.\n * This function only handles boolean flags.\n * @category Compiler Options\n * @example\n * ```ts\n * const options = {\n * \tallowJs: true,\n * };\n *\n * isCompilerOptionEnabled(options, \"allowJs\"); // true\n * isCompilerOptionEnabled(options, \"allowSyntheticDefaultImports\"); // false\n * ```\n */\ndeclare function isCompilerOptionEnabled(options: ts.CompilerOptions, option: BooleanCompilerOptions): boolean;\n/**\n * Checks if a given compiler option is enabled, accounting for whether all flags\n * (except `strictPropertyInitialization`) have been enabled by `strict: true`.\n * @category Compiler Options\n * @example\n * ```ts\n * const optionsLenient = {\n * \tnoImplicitAny: true,\n * };\n *\n * isStrictCompilerOptionEnabled(optionsLenient, \"noImplicitAny\"); // true\n * isStrictCompilerOptionEnabled(optionsLenient, \"noImplicitThis\"); // false\n * ```\n * @example\n * ```ts\n * const optionsStrict = {\n * \tnoImplicitThis: false,\n * \tstrict: true,\n * };\n *\n * isStrictCompilerOptionEnabled(optionsStrict, \"noImplicitAny\"); // true\n * isStrictCompilerOptionEnabled(optionsStrict, \"noImplicitThis\"); // false\n * ```\n */\ndeclare function isStrictCompilerOptionEnabled(options: ts.CompilerOptions, option: StrictCompilerOption): boolean;\n\n/**\n * Test if the given node has the given `ModifierFlags` set.\n * @category Nodes - Flag Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isModifierFlagSet(node, ts.ModifierFlags.Abstract)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isModifierFlagSet(node: ts.Declaration, flag: ts.ModifierFlags): boolean;\n/**\n * Test if the given node has the given `NodeFlags` set.\n * @category Nodes - Flag Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNodeFlagSet(node, ts.NodeFlags.AwaitContext)) {\n *   // ...\n * }\n * ```\n */\ndeclare const isNodeFlagSet: (node: ts.Node, flag: ts.NodeFlags) => boolean;\n/**\n * Test if the given node has the given `ObjectFlags` set.\n * @category Nodes - Flag Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isObjectFlagSet(node, ts.ObjectFlags.Anonymous)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isObjectFlagSet(objectType: ts.ObjectType, flag: ts.ObjectFlags): boolean;\n/**\n * Test if the given node has the given `SymbolFlags` set.\n * @category Nodes - Flag Utilities\n * @example\n * ```ts\n * declare const symbol: ts.Symbol;\n *\n * if (isSymbolFlagSet(symbol, ts.SymbolFlags.Accessor)) {\n *   // ...\n * }\n * ```\n */\ndeclare const isSymbolFlagSet: (symbol: ts.Symbol, flag: ts.SymbolFlags) => boolean;\n/**\n * Test if the given symbol's links has the given `CheckFlags` set.\n * @internal\n */\ndeclare function isTransientSymbolLinksFlagSet(links: ts.TransientSymbolLinks, flag: ts.CheckFlags): boolean;\n/**\n * Test if the given node has the given `TypeFlags` set.\n * @category Nodes - Flag Utilities\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTypeFlagSet(type, ts.TypeFlags.Any)) {\n *   // ...\n * }\n * ```\n */\ndeclare const isTypeFlagSet: (type: ts.Type, flag: ts.TypeFlags) => boolean;\n\n/**\n * Test if the given iterable includes a modifier of any of the given kinds.\n * @category Modifier Utilities\n * @example\n * ```ts\n * declare const modifiers: ts.Modifier[];\n *\n * includesModifier(modifiers, ts.SyntaxKind.AbstractKeyword);\n * ```\n */\ndeclare function includesModifier(modifiers: Iterable<ts.ModifierLike> | undefined, ...kinds: ts.ModifierSyntaxKind[]): boolean;\n\n/**\n * What operations(s), if any, an expression applies.\n */\ndeclare enum AccessKind {\n    None = 0,\n    Read = 1,\n    Write = 2,\n    Delete = 4,\n    ReadWrite = 3\n}\n/**\n * Determines which operation(s), if any, an expression applies.\n * @example\n * ```ts\n * declare const node: ts.Expression;\n *\n * if (getAccessKind(node).Write & AccessKind.Write) !== 0) {\n *   // this is a reassignment (write)\n * }\n * ```\n */\ndeclare function getAccessKind(node: ts.Expression): AccessKind;\n\n/**\n * An `AssertionExpression` that is declared as const.\n * @category Node Types\n */\ntype ConstAssertionExpression = ts.AssertionExpression & {\n    type: ts.TypeReferenceNode;\n    typeName: ConstAssertionIdentifier;\n};\n/**\n * An `Identifier` with an `escapedText` value of `\"const\"`.\n * @category Node Types\n */\ntype ConstAssertionIdentifier = ts.Identifier & {\n    escapedText: \"const\" & ts.__String;\n};\n/**\n * a `NamedDeclaration` that definitely has a name.\n * @category Node Types\n */\ninterface NamedDeclarationWithName extends ts.NamedDeclaration {\n    name: ts.DeclarationName;\n}\n/**\n * A number or string-like literal.\n * @category Node Types\n */\ntype NumericOrStringLikeLiteral = ts.NumericLiteral | ts.StringLiteralLike;\n/**\n * Test if a node is a {@link ConstAssertionExpression}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isConstAssertionExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link ConstAssertionExpression}.\n */\ndeclare function isConstAssertionExpression(node: ts.AssertionExpression): node is ConstAssertionExpression;\n/**\n * Test if a node is an `IterationStatement`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isIterationStatement(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `IterationStatement`.\n */\ndeclare function isIterationStatement(node: ts.Node): node is ts.IterationStatement;\n/**\n * Test if a node is a `JSDocNamespaceDeclaration`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJSDocNamespaceDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JSDocNamespaceDeclaration`.\n */\ndeclare function isJSDocNamespaceDeclaration(node: ts.Node): node is ts.JSDocNamespaceDeclaration;\n/**\n * Test if a node is a `JsxTagNamePropertyAccess`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsxTagNamePropertyAccess(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsxTagNamePropertyAccess`.\n */\ndeclare function isJsxTagNamePropertyAccess(node: ts.Node): node is ts.JsxTagNamePropertyAccess;\n/**\n * Test if a node is a {@link NamedDeclarationWithName}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNamedDeclarationWithName(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link NamedDeclarationWithName}.\n */\ndeclare function isNamedDeclarationWithName(node: ts.Declaration): node is NamedDeclarationWithName;\n/**\n * Test if a node is a `NamespaceDeclaration`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNamespaceDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `NamespaceDeclaration`.\n */\ndeclare function isNamespaceDeclaration(node: ts.Node): node is ts.NamespaceDeclaration;\n/**\n * Test if a node is a {@link NumericOrStringLikeLiteral}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNumericOrStringLikeLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link NumericOrStringLikeLiteral}.\n */\ndeclare function isNumericOrStringLikeLiteral(node: ts.Node): node is NumericOrStringLikeLiteral;\n/**\n * Test if a node is a `PropertyAccessEntityNameExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isPropertyAccessEntityNameExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `PropertyAccessEntityNameExpression`.\n */\ndeclare function isPropertyAccessEntityNameExpression(node: ts.Node): node is ts.PropertyAccessEntityNameExpression;\n/**\n * Test if a node is a `SuperElementAccessExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSuperElementAccessExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `SuperElementAccessExpression`.\n */\ndeclare function isSuperElementAccessExpression(node: ts.Node): node is ts.SuperElementAccessExpression;\n/**\n * Test if a node is a `SuperPropertyAccessExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSuperPropertyAccessExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `SuperPropertyAccessExpression`.\n */\ndeclare function isSuperPropertyAccessExpression(node: ts.Node): node is ts.SuperPropertyAccessExpression;\n\n/**\n * A node that represents the any keyword.\n * @category Node Types\n */\ntype AnyKeyword = ts.KeywordToken<ts.SyntaxKind.AnyKeyword>;\n/**\n * A node that represents the bigint keyword.\n * @category Node Types\n */\ntype BigIntKeyword = ts.KeywordToken<ts.SyntaxKind.BigIntKeyword>;\n/**\n * A node that represents the boolean keyword.\n * @category Node Types\n */\ntype BooleanKeyword = ts.KeywordToken<ts.SyntaxKind.BooleanKeyword>;\n/**\n * A node that represents the false keyword.\n * @category Node Types\n */\ntype FalseKeyword = ts.KeywordToken<ts.SyntaxKind.FalseKeyword>;\n/**\n * A node that represents the import keyword.\n * @category Node Types\n */\ntype ImportKeyword = ts.KeywordToken<ts.SyntaxKind.ImportKeyword>;\n/**\n * A node that represents the never keyword.\n * @category Node Types\n */\ntype NeverKeyword = ts.KeywordToken<ts.SyntaxKind.NeverKeyword>;\n/**\n * A node that represents the null keyword.\n * @category Node Types\n */\ntype NullKeyword = ts.KeywordToken<ts.SyntaxKind.NullKeyword>;\n/**\n * A node that represents the number keyword.\n * @category Node Types\n */\ntype NumberKeyword = ts.KeywordToken<ts.SyntaxKind.NumberKeyword>;\n/**\n * A node that represents the object keyword.\n * @category Node Types\n */\ntype ObjectKeyword = ts.KeywordToken<ts.SyntaxKind.ObjectKeyword>;\n/**\n * A node that represents the string keyword.\n * @category Node Types\n */\ntype StringKeyword = ts.KeywordToken<ts.SyntaxKind.StringKeyword>;\n/**\n * A node that represents the super keyword.\n * @category Node Types\n */\ntype SuperKeyword = ts.KeywordToken<ts.SyntaxKind.SuperKeyword>;\n/**\n * A node that represents the symbol keyword.\n * @category Node Types\n */\ntype SymbolKeyword = ts.KeywordToken<ts.SyntaxKind.SymbolKeyword>;\n/**\n * A node that represents the this keyword.\n * @category Node Types\n */\ntype ThisKeyword = ts.KeywordToken<ts.SyntaxKind.ThisKeyword>;\n/**\n * A node that represents the true keyword.\n * @category Node Types\n */\ntype TrueKeyword = ts.KeywordToken<ts.SyntaxKind.TrueKeyword>;\n/**\n * A node that represents the undefined keyword.\n * @category Node Types\n */\ntype UndefinedKeyword = ts.KeywordToken<ts.SyntaxKind.UndefinedKeyword>;\n/**\n * A node that represents the unknown keyword.\n * @category Node Types\n */\ntype UnknownKeyword = ts.KeywordToken<ts.SyntaxKind.UnknownKeyword>;\n/**\n * A node that represents the void keyword.\n * @category Node Types\n */\ntype VoidKeyword = ts.KeywordToken<ts.SyntaxKind.VoidKeyword>;\n/**\n * Test if a node is an `AbstractKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAbstractKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AbstractKeyword`.\n */\ndeclare function isAbstractKeyword(node: ts.Node): node is ts.AbstractKeyword;\n/**\n * Test if a node is an `AccessorKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAccessorKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AccessorKeyword`.\n */\ndeclare function isAccessorKeyword(node: ts.Node): node is ts.AccessorKeyword;\n/**\n * Test if a node is an {@link AnyKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAnyKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an {@link AnyKeyword}.\n */\ndeclare function isAnyKeyword(node: ts.Node): node is AnyKeyword;\n/**\n * Test if a node is an `AssertKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAssertKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AssertKeyword`.\n */\ndeclare function isAssertKeyword(node: ts.Node): node is ts.AssertKeyword;\n/**\n * Test if a node is an `AssertsKeyword`.\n * @deprecated With TypeScript v5, in favor of typescript's `isAssertsKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAssertsKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AssertsKeyword`.\n */\ndeclare function isAssertsKeyword(node: ts.Node): node is ts.AssertsKeyword;\n/**\n * Test if a node is an `AsyncKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAsyncKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AsyncKeyword`.\n */\ndeclare function isAsyncKeyword(node: ts.Node): node is ts.AsyncKeyword;\n/**\n * Test if a node is an `AwaitKeyword`.\n * @deprecated With TypeScript v5, in favor of typescript's `isAwaitKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAwaitKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AwaitKeyword`.\n */\ndeclare function isAwaitKeyword(node: ts.Node): node is ts.AwaitKeyword;\n/**\n * Test if a node is a {@link BigIntKeyword}.\n * @deprecated With TypeScript v5, in favor of typescript's `isBigIntKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBigIntKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link BigIntKeyword}.\n */\ndeclare function isBigIntKeyword(node: ts.Node): node is BigIntKeyword;\n/**\n * Test if a node is a {@link BooleanKeyword}.\n * @deprecated With TypeScript v5, in favor of typescript's `isBooleanKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBooleanKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link BooleanKeyword}.\n */\ndeclare function isBooleanKeyword(node: ts.Node): node is BooleanKeyword;\n/**\n * Test if a node is a `ColonToken`.\n * @deprecated With TypeScript v5, in favor of typescript's `isColonToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isColonToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ColonToken`.\n */\ndeclare function isColonToken(node: ts.Node): node is ts.ColonToken;\n/**\n * Test if a node is a `ConstKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isConstKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ConstKeyword`.\n */\ndeclare function isConstKeyword(node: ts.Node): node is ts.ConstKeyword;\n/**\n * Test if a node is a `DeclareKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDeclareKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DeclareKeyword`.\n */\ndeclare function isDeclareKeyword(node: ts.Node): node is ts.DeclareKeyword;\n/**\n * Test if a node is a `DefaultKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDefaultKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DefaultKeyword`.\n */\ndeclare function isDefaultKeyword(node: ts.Node): node is ts.DefaultKeyword;\n/**\n * Test if a node is a `DotToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDotToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DotToken`.\n */\ndeclare function isDotToken(node: ts.Node): node is ts.DotToken;\n/**\n * Test if a node is an `EndOfFileToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isEndOfFileToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `EndOfFileToken`.\n */\ndeclare function isEndOfFileToken(node: ts.Node): node is ts.EndOfFileToken;\n/**\n * Test if a node is an `EqualsGreaterThanToken`.\n * @deprecated With TypeScript v5, in favor of typescript's `isEqualsGreaterThanToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isEqualsGreaterThanToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `EqualsGreaterThanToken`.\n */\ndeclare function isEqualsGreaterThanToken(node: ts.Node): node is ts.EqualsGreaterThanToken;\n/**\n * Test if a node is an `EqualsToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isEqualsToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `EqualsToken`.\n */\ndeclare function isEqualsToken(node: ts.Node): node is ts.EqualsToken;\n/**\n * Test if a node is an `ExclamationToken`.\n * @deprecated With TypeScript v5, in favor of typescript's `isExclamationToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isExclamationToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ExclamationToken`.\n */\ndeclare function isExclamationToken(node: ts.Node): node is ts.ExclamationToken;\n/**\n * Test if a node is an `ExportKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isExportKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ExportKeyword`.\n */\ndeclare function isExportKeyword(node: ts.Node): node is ts.ExportKeyword;\n/**\n * Test if a node is a {@link FalseKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isFalseKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link FalseKeyword}.\n */\ndeclare function isFalseKeyword(node: ts.Node): node is FalseKeyword;\n/**\n * Test if a node is a `FalseLiteral`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isFalseLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `FalseLiteral`.\n */\ndeclare function isFalseLiteral(node: ts.Node): node is ts.FalseLiteral;\n/**\n * Test if a node is an `ImportExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isImportExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ImportExpression`.\n */\ndeclare function isImportExpression(node: ts.Node): node is ts.ImportExpression;\n/**\n * Test if a node is an {@link ImportKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isImportKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an {@link ImportKeyword}.\n */\ndeclare function isImportKeyword(node: ts.Node): node is ImportKeyword;\n/**\n * Test if a node is an `InKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isInKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `InKeyword`.\n */\ndeclare function isInKeyword(node: ts.Node): node is ts.InKeyword;\n/**\n * Test if a node is a `JSDocText`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJSDocText(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JSDocText`.\n */\ndeclare function isJSDocText(node: ts.Node): node is ts.JSDocText;\n/**\n * Test if a node is a `JsonMinusNumericLiteral`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsonMinusNumericLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsonMinusNumericLiteral`.\n */\ndeclare function isJsonMinusNumericLiteral(node: ts.Node): node is ts.JsonMinusNumericLiteral;\n/**\n * Test if a node is a {@link NeverKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNeverKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link NeverKeyword}.\n */\ndeclare function isNeverKeyword(node: ts.Node): node is NeverKeyword;\n/**\n * Test if a node is a {@link NullKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNullKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link NullKeyword}.\n */\ndeclare function isNullKeyword(node: ts.Node): node is NullKeyword;\n/**\n * Test if a node is a `NullLiteral`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNullLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `NullLiteral`.\n */\ndeclare function isNullLiteral(node: ts.Node): node is ts.NullLiteral;\n/**\n * Test if a node is a {@link NumberKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNumberKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link NumberKeyword}.\n */\ndeclare function isNumberKeyword(node: ts.Node): node is NumberKeyword;\n/**\n * Test if a node is an {@link ObjectKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isObjectKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an {@link ObjectKeyword}.\n */\ndeclare function isObjectKeyword(node: ts.Node): node is ObjectKeyword;\n/**\n * Test if a node is an `OutKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isOutKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `OutKeyword`.\n */\ndeclare function isOutKeyword(node: ts.Node): node is ts.OutKeyword;\n/**\n * Test if a node is an `OverrideKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isOverrideKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `OverrideKeyword`.\n */\ndeclare function isOverrideKeyword(node: ts.Node): node is ts.OverrideKeyword;\n/**\n * Test if a node is a `PrivateKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isPrivateKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `PrivateKeyword`.\n */\ndeclare function isPrivateKeyword(node: ts.Node): node is ts.PrivateKeyword;\n/**\n * Test if a node is a `ProtectedKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isProtectedKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ProtectedKeyword`.\n */\ndeclare function isProtectedKeyword(node: ts.Node): node is ts.ProtectedKeyword;\n/**\n * Test if a node is a `PublicKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isPublicKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `PublicKeyword`.\n */\ndeclare function isPublicKeyword(node: ts.Node): node is ts.PublicKeyword;\n/**\n * Test if a node is a `QuestionDotToken`.\n * @deprecated With TypeScript v5, in favor of typescript's `isQuestionDotToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isQuestionDotToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `QuestionDotToken`.\n */\ndeclare function isQuestionDotToken(node: ts.Node): node is ts.QuestionDotToken;\n/**\n * Test if a node is a `QuestionToken`.\n * @deprecated With TypeScript v5, in favor of typescript's `isQuestionToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isQuestionToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `QuestionToken`.\n */\ndeclare function isQuestionToken(node: ts.Node): node is ts.QuestionToken;\n/**\n * Test if a node is a `ReadonlyKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isReadonlyKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ReadonlyKeyword`.\n */\ndeclare function isReadonlyKeyword(node: ts.Node): node is ts.ReadonlyKeyword;\n/**\n * Test if a node is a `StaticKeyword`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isStaticKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `StaticKeyword`.\n */\ndeclare function isStaticKeyword(node: ts.Node): node is ts.StaticKeyword;\n/**\n * Test if a node is a {@link StringKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isStringKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link StringKeyword}.\n */\ndeclare function isStringKeyword(node: ts.Node): node is StringKeyword;\n/**\n * Test if a node is a `SuperExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSuperExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `SuperExpression`.\n */\ndeclare function isSuperExpression(node: ts.Node): node is ts.SuperExpression;\n/**\n * Test if a node is a {@link SuperKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSuperKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link SuperKeyword}.\n */\ndeclare function isSuperKeyword(node: ts.Node): node is SuperKeyword;\n/**\n * Test if a node is a {@link SymbolKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSymbolKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link SymbolKeyword}.\n */\ndeclare function isSymbolKeyword(node: ts.Node): node is SymbolKeyword;\n/**\n * Test if a node is a `SyntaxList`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSyntaxList(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `SyntaxList`.\n */\ndeclare function isSyntaxList(node: ts.Node): node is ts.SyntaxList;\n/**\n * Test if a node is a `ThisExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isThisExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ThisExpression`.\n */\ndeclare function isThisExpression(node: ts.Node): node is ts.ThisExpression;\n/**\n * Test if a node is a {@link ThisKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isThisKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link ThisKeyword}.\n */\ndeclare function isThisKeyword(node: ts.Node): node is ThisKeyword;\n/**\n * Test if a node is a {@link TrueKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isTrueKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link TrueKeyword}.\n */\ndeclare function isTrueKeyword(node: ts.Node): node is TrueKeyword;\n/**\n * Test if a node is a `TrueLiteral`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isTrueLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `TrueLiteral`.\n */\ndeclare function isTrueLiteral(node: ts.Node): node is ts.TrueLiteral;\n/**\n * Test if a node is an {@link UndefinedKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isUndefinedKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an {@link UndefinedKeyword}.\n */\ndeclare function isUndefinedKeyword(node: ts.Node): node is UndefinedKeyword;\n/**\n * Test if a node is an {@link UnknownKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isUnknownKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an {@link UnknownKeyword}.\n */\ndeclare function isUnknownKeyword(node: ts.Node): node is UnknownKeyword;\n/**\n * Test if a node is a {@link VoidKeyword}.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isVoidKeyword(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a {@link VoidKeyword}.\n */\ndeclare function isVoidKeyword(node: ts.Node): node is VoidKeyword;\n\n/**\n * Test if a node is a `HasDecorators`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasDecorators(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasDecorators`.\n */\ndeclare function hasDecorators(node: ts.Node): node is ts.HasDecorators;\n/**\n * Test if a node is a `HasExpressionInitializer`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasExpressionInitializer(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasExpressionInitializer`.\n */\ndeclare function hasExpressionInitializer(node: ts.Node): node is ts.HasExpressionInitializer;\n/**\n * Test if a node is a `HasInitializer`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasInitializer(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasInitializer`.\n */\ndeclare function hasInitializer(node: ts.Node): node is ts.HasInitializer;\n/**\n * Test if a node is a `HasJSDoc`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasJSDoc(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasJSDoc`.\n */\ndeclare function hasJSDoc(node: ts.Node): node is ts.HasJSDoc;\n/**\n * Test if a node is a `HasModifiers`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasModifiers(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasModifiers`.\n */\ndeclare function hasModifiers(node: ts.Node): node is ts.HasModifiers;\n/**\n * Test if a node is a `HasType`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasType(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasType`.\n */\ndeclare function hasType(node: ts.Node): node is ts.HasType;\n/**\n * Test if a node is a `HasTypeArguments`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (hasTypeArguments(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `HasTypeArguments`.\n */\ndeclare function hasTypeArguments(node: ts.Node): node is ts.HasTypeArguments;\n/**\n * Test if a node is an `AccessExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAccessExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AccessExpression`.\n */\ndeclare function isAccessExpression(node: ts.Node): node is ts.AccessExpression;\n/**\n * Test if a node is an `AccessibilityModifier`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAccessibilityModifier(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AccessibilityModifier`.\n */\ndeclare function isAccessibilityModifier(node: ts.Node): node is ts.AccessibilityModifier;\n/**\n * Test if a node is an `AccessorDeclaration`.\n * @deprecated With TypeScript v5, in favor of typescript's `isAccessor`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAccessorDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AccessorDeclaration`.\n */\ndeclare function isAccessorDeclaration(node: ts.Node): node is ts.AccessorDeclaration;\n/**\n * Test if a node is an `ArrayBindingElement`.\n * @deprecated With TypeScript v5, in favor of typescript's `isArrayBindingElement`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isArrayBindingElement(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ArrayBindingElement`.\n */\ndeclare function isArrayBindingElement(node: ts.Node): node is ts.ArrayBindingElement;\n/**\n * Test if a node is an `ArrayBindingOrAssignmentPattern`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isArrayBindingOrAssignmentPattern(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ArrayBindingOrAssignmentPattern`.\n */\ndeclare function isArrayBindingOrAssignmentPattern(node: ts.Node): node is ts.ArrayBindingOrAssignmentPattern;\n/**\n * Test if a node is an `AssignmentPattern`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isAssignmentPattern(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `AssignmentPattern`.\n */\ndeclare function isAssignmentPattern(node: ts.Node): node is ts.AssignmentPattern;\n/**\n * Test if a node is a `BindingOrAssignmentElementRestIndicator`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBindingOrAssignmentElementRestIndicator(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `BindingOrAssignmentElementRestIndicator`.\n */\ndeclare function isBindingOrAssignmentElementRestIndicator(node: ts.Node): node is ts.BindingOrAssignmentElementRestIndicator;\n/**\n * Test if a node is a `BindingOrAssignmentElementTarget`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBindingOrAssignmentElementTarget(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `BindingOrAssignmentElementTarget`.\n */\ndeclare function isBindingOrAssignmentElementTarget(node: ts.Node): node is ts.BindingOrAssignmentElementTarget;\n/**\n * Test if a node is a `BindingOrAssignmentPattern`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBindingOrAssignmentPattern(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `BindingOrAssignmentPattern`.\n */\ndeclare function isBindingOrAssignmentPattern(node: ts.Node): node is ts.BindingOrAssignmentPattern;\n/**\n * Test if a node is a `BindingPattern`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBindingPattern(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `BindingPattern`.\n */\ndeclare function isBindingPattern(node: ts.Node): node is ts.BindingPattern;\n/**\n * Test if a node is a `BlockLike`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBlockLike(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `BlockLike`.\n */\ndeclare function isBlockLike(node: ts.Node): node is ts.BlockLike;\n/**\n * Test if a node is a `BooleanLiteral`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isBooleanLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `BooleanLiteral`.\n */\ndeclare function isBooleanLiteral(node: ts.Node): node is ts.BooleanLiteral;\n/**\n * Test if a node is a `ClassLikeDeclaration`.\n * @deprecated With TypeScript v5, in favor of typescript's `isClassLike`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isClassLikeDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ClassLikeDeclaration`.\n */\ndeclare function isClassLikeDeclaration(node: ts.Node): node is ts.ClassLikeDeclaration;\n/**\n * Test if a node is a `ClassMemberModifier`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isClassMemberModifier(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ClassMemberModifier`.\n */\ndeclare function isClassMemberModifier(node: ts.Node): node is ts.ClassMemberModifier;\n/**\n * Test if a node is a `DeclarationName`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDeclarationName(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DeclarationName`.\n */\ndeclare function isDeclarationName(node: ts.Node): node is ts.DeclarationName;\n/**\n * Test if a node is a `DeclarationWithTypeParameterChildren`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDeclarationWithTypeParameterChildren(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DeclarationWithTypeParameterChildren`.\n */\ndeclare function isDeclarationWithTypeParameterChildren(node: ts.Node): node is ts.DeclarationWithTypeParameterChildren;\n/**\n * Test if a node is a `DeclarationWithTypeParameters`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDeclarationWithTypeParameters(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DeclarationWithTypeParameters`.\n */\ndeclare function isDeclarationWithTypeParameters(node: ts.Node): node is ts.DeclarationWithTypeParameters;\n/**\n * Test if a node is a `DestructuringPattern`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isDestructuringPattern(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `DestructuringPattern`.\n */\ndeclare function isDestructuringPattern(node: ts.Node): node is ts.DestructuringPattern;\n/**\n * Test if a node is an `EntityNameExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isEntityNameExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `EntityNameExpression`.\n */\ndeclare function isEntityNameExpression(node: ts.Node): node is ts.EntityNameExpression;\n/**\n * Test if a node is an `EntityNameOrEntityNameExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isEntityNameOrEntityNameExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `EntityNameOrEntityNameExpression`.\n */\ndeclare function isEntityNameOrEntityNameExpression(node: ts.Node): node is ts.EntityNameOrEntityNameExpression;\n/**\n * Test if a node is a `ForInOrOfStatement`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isForInOrOfStatement(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ForInOrOfStatement`.\n */\ndeclare function isForInOrOfStatement(node: ts.Node): node is ts.ForInOrOfStatement;\n/**\n * Test if a node is a `FunctionLikeDeclaration`.\n * @deprecated With TypeScript v5, in favor of typescript's `isFunctionLike`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isFunctionLikeDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `FunctionLikeDeclaration`.\n */\ndeclare function isFunctionLikeDeclaration(node: ts.Node): node is ts.FunctionLikeDeclaration;\n/**\n * Test if a node is a `JSDocComment`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJSDocComment(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JSDocComment`.\n */\ndeclare function isJSDocComment(node: ts.Node): node is ts.JSDocComment;\n/**\n * Test if a node is a `JSDocNamespaceBody`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJSDocNamespaceBody(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JSDocNamespaceBody`.\n */\ndeclare function isJSDocNamespaceBody(node: ts.Node): node is ts.JSDocNamespaceBody;\n/**\n * Test if a node is a `JSDocTypeReferencingNode`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJSDocTypeReferencingNode(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JSDocTypeReferencingNode`.\n */\ndeclare function isJSDocTypeReferencingNode(node: ts.Node): node is ts.JSDocTypeReferencingNode;\n/**\n * Test if a node is a `JsonObjectExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsonObjectExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsonObjectExpression`.\n */\ndeclare function isJsonObjectExpression(node: ts.Node): node is ts.JsonObjectExpression;\n/**\n * Test if a node is a `JsxAttributeLike`.\n * @deprecated With TypeScript v5, in favor of typescript's `isJsxAttributeLike`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsxAttributeLike(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsxAttributeLike`.\n */\ndeclare function isJsxAttributeLike(node: ts.Node): node is ts.JsxAttributeLike;\n/**\n * Test if a node is a `JsxAttributeValue`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsxAttributeValue(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsxAttributeValue`.\n */\ndeclare function isJsxAttributeValue(node: ts.Node): node is ts.JsxAttributeValue;\n/**\n * Test if a node is a `JsxChild`.\n * @deprecated With TypeScript v5, in favor of typescript's `isJsxChild`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsxChild(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsxChild`.\n */\ndeclare function isJsxChild(node: ts.Node): node is ts.JsxChild;\n/**\n * Test if a node is a `JsxTagNameExpression`.\n * @deprecated With TypeScript v5, in favor of typescript's `isJsxTagNameExpression`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isJsxTagNameExpression(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `JsxTagNameExpression`.\n */\ndeclare function isJsxTagNameExpression(node: ts.Node): node is ts.JsxTagNameExpression;\n/**\n * Test if a node is a `LiteralToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isLiteralToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `LiteralToken`.\n */\ndeclare function isLiteralToken(node: ts.Node): node is ts.LiteralToken;\n/**\n * Test if a node is a `ModuleBody`.\n * @deprecated With TypeScript v5, in favor of typescript's `isModuleBody`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isModuleBody(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ModuleBody`.\n */\ndeclare function isModuleBody(node: ts.Node): node is ts.ModuleBody;\n/**\n * Test if a node is a `ModuleName`.\n * @deprecated With TypeScript v5, in favor of typescript's `isModuleName`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isModuleName(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ModuleName`.\n */\ndeclare function isModuleName(node: ts.Node): node is ts.ModuleName;\n/**\n * Test if a node is a `ModuleReference`.\n * @deprecated With TypeScript v5, in favor of typescript's `isModuleReference`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isModuleReference(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ModuleReference`.\n */\ndeclare function isModuleReference(node: ts.Node): node is ts.ModuleReference;\n/**\n * Test if a node is a `NamedImportBindings`.\n * @deprecated With TypeScript v5, in favor of typescript's `isNamedImportBindings`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNamedImportBindings(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `NamedImportBindings`.\n */\ndeclare function isNamedImportBindings(node: ts.Node): node is ts.NamedImportBindings;\n/**\n * Test if a node is a `NamedImportsOrExports`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNamedImportsOrExports(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `NamedImportsOrExports`.\n */\ndeclare function isNamedImportsOrExports(node: ts.Node): node is ts.NamedImportsOrExports;\n/**\n * Test if a node is a `NamespaceBody`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isNamespaceBody(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `NamespaceBody`.\n */\ndeclare function isNamespaceBody(node: ts.Node): node is ts.NamespaceBody;\n/**\n * Test if a node is an `ObjectBindingOrAssignmentElement`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isObjectBindingOrAssignmentElement(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ObjectBindingOrAssignmentElement`.\n */\ndeclare function isObjectBindingOrAssignmentElement(node: ts.Node): node is ts.ObjectBindingOrAssignmentElement;\n/**\n * Test if a node is an `ObjectBindingOrAssignmentPattern`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isObjectBindingOrAssignmentPattern(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ObjectBindingOrAssignmentPattern`.\n */\ndeclare function isObjectBindingOrAssignmentPattern(node: ts.Node): node is ts.ObjectBindingOrAssignmentPattern;\n/**\n * Test if a node is an `ObjectTypeDeclaration`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isObjectTypeDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `ObjectTypeDeclaration`.\n */\ndeclare function isObjectTypeDeclaration(node: ts.Node): node is ts.ObjectTypeDeclaration;\n/**\n * Test if a node is a `ParameterPropertyModifier`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isParameterPropertyModifier(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `ParameterPropertyModifier`.\n */\ndeclare function isParameterPropertyModifier(node: ts.Node): node is ts.ParameterPropertyModifier;\n/**\n * Test if a node is a `PropertyNameLiteral`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isPropertyNameLiteral(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `PropertyNameLiteral`.\n */\ndeclare function isPropertyNameLiteral(node: ts.Node): node is ts.PropertyNameLiteral;\n/**\n * Test if a node is a `PseudoLiteralToken`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isPseudoLiteralToken(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `PseudoLiteralToken`.\n */\ndeclare function isPseudoLiteralToken(node: ts.Node): node is ts.PseudoLiteralToken;\n/**\n * Test if a node is a `SignatureDeclaration`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSignatureDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `SignatureDeclaration`.\n */\ndeclare function isSignatureDeclaration(node: ts.Node): node is ts.SignatureDeclaration;\n/**\n * Test if a node is a `SuperProperty`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isSuperProperty(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `SuperProperty`.\n */\ndeclare function isSuperProperty(node: ts.Node): node is ts.SuperProperty;\n/**\n * Test if a node is a `TypeOnlyCompatibleAliasDeclaration`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isTypeOnlyCompatibleAliasDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `TypeOnlyCompatibleAliasDeclaration`.\n */\ndeclare function isTypeOnlyCompatibleAliasDeclaration(node: ts.Node): node is ts.TypeOnlyCompatibleAliasDeclaration;\n/**\n * Test if a node is a `TypeReferenceType`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isTypeReferenceType(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `TypeReferenceType`.\n */\ndeclare function isTypeReferenceType(node: ts.Node): node is ts.TypeReferenceType;\n/**\n * Test if a node is an `UnionOrIntersectionTypeNode`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isUnionOrIntersectionTypeNode(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be an `UnionOrIntersectionTypeNode`.\n */\ndeclare function isUnionOrIntersectionTypeNode(node: ts.Node): node is ts.UnionOrIntersectionTypeNode;\n/**\n * Test if a node is a `VariableLikeDeclaration`.\n * @category Nodes - Type Guards\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isVariableLikeDeclaration(node)) {\n *   // ...\n * }\n * ```\n * @returns Whether the given node appears to be a `VariableLikeDeclaration`.\n */\ndeclare function isVariableLikeDeclaration(node: ts.Node): node is ts.VariableLikeDeclaration;\n\n/**\n * Is the node a scope boundary, specifically due to it being a function.\n * @category Scope Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * if (isFunctionScopeBoundary(node, ts.ObjectFlags.Anonymous)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isFunctionScopeBoundary(node: ts.Node): boolean;\n\n/**\n * Test of the kind given is for assignment.\n * @category Syntax Utilities\n * @example\n * ```ts\n * declare const kind: ts.SyntaxKind;\n *\n * isAssignmentKind(kind);\n * ```\n */\ndeclare function isAssignmentKind(kind: ts.SyntaxKind): boolean;\n/**\n * Test if a string is numeric.\n * @category Syntax Utilities\n * @example\n * ```ts\n * isNumericPropertyName(\"abc\"); // false\n * isNumericPropertyName(\"123\"); // true\n * ```\n */\ndeclare function isNumericPropertyName(name: string | ts.__String): boolean;\n/**\n * Determines whether the given text can be used to access a property with a `PropertyAccessExpression` while preserving the property's name.\n * @category Syntax Utilities\n * @example\n * ```ts\n * isValidPropertyAccess(\"abc\"); // true\n * isValidPropertyAccess(\"123\"); // false\n * ```\n */\ndeclare function isValidPropertyAccess(text: string, languageVersion?: ts.ScriptTarget): boolean;\n\n/**\n * Callback type used for {@link forEachToken}.\n * @category Callbacks\n * @example\n * ```ts\n * let onToken: ForEachTokenCallback = (token) => {\n *    console.log(`Found token at position: ${token.pos}.`);\n * };\n * ```\n */\ntype ForEachTokenCallback = (token: ts.Node) => void;\n/**\n * Iterates over all tokens of `node`\n * @category Nodes - Other Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n *\n * forEachToken(node, (token) => {\n * \tconsole.log(\"Found token:\", token.getText());\n * });\n * ```\n * @param node The node whose tokens should be visited\n * @param callback Is called for every token contained in `node`\n */\ndeclare function forEachToken(node: ts.Node, callback: ForEachTokenCallback, sourceFile?: ts.SourceFile): void;\n\n/**\n * Get the `CallSignatures` of the given type.\n * @category Types - Getters\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * getCallSignaturesOfType(type);\n * ```\n */\ndeclare function getCallSignaturesOfType(type: ts.Type): readonly ts.Signature[];\n/**\n * Get the property with the given name on the given type (if it exists).\n * @category Types - Getters\n * @example\n * ```ts\n * declare const property: ts.Symbol;\n * declare const type: ts.Type;\n *\n * getPropertyOfType(type, property.getEscapedName());\n * ```\n */\ndeclare function getPropertyOfType(type: ts.Type, name: ts.__String): ts.Symbol | undefined;\n/**\n * Retrieves a type symbol corresponding to a well-known string name.\n * @category Types - Getters\n * @example\n * ```ts\n * declare const type: ts.Type;\n * declare const typeChecker: ts.TypeChecker;\n *\n * getWellKnownSymbolPropertyOfType(type, \"asyncIterator\", typeChecker);\n * ```\n */\ndeclare function getWellKnownSymbolPropertyOfType(type: ts.Type, wellKnownSymbolName: string, typeChecker: ts.TypeChecker): ts.Symbol | undefined;\n\n/**\n * A \"any\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicAnyType extends IntrinsicType {\n    intrinsicName: \"any\";\n}\n/**\n * A \"bigint\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicBigIntType extends IntrinsicType {\n    intrinsicName: \"bigint\";\n}\n/**\n * A \"boolean\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicBooleanType extends IntrinsicType {\n    intrinsicName: \"boolean\";\n}\n/**\n * An \"error\" intrinsic type.\n *\n * This refers to a type generated when TypeScript encounters an error while\n * trying to resolve the type.\n * @category Type Types\n */\ninterface IntrinsicErrorType extends IntrinsicType {\n    intrinsicName: \"error\";\n}\n/**\n * A \"symbol\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicESSymbolType extends IntrinsicType {\n    intrinsicName: \"symbol\";\n}\n/**\n * An \"intrinsic\" (built-in to TypeScript) type.\n * @category Type Types\n */\ninterface IntrinsicType extends ts.Type {\n    intrinsicName: string;\n    objectFlags: ts.ObjectFlags;\n}\n/**\n * Determines whether the given type is the \"any\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicAnyType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicAnyType(type: ts.Type): type is IntrinsicAnyType;\n/**\n * Determines whether the given type is the \"bigint\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicBigIntType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicBigIntType(type: ts.Type): type is IntrinsicBigIntType;\n/**\n * Determines whether the given type is the \"boolean\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicBooleanType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicBooleanType(type: ts.Type): type is IntrinsicBooleanType;\n/**\n * Determines whether the given type is the \"error\" intrinsic type.\n *\n * The intrinsic error type occurs when TypeScript encounters an error while\n * trying to resolve the type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicErrorType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicErrorType(type: ts.Type): type is IntrinsicErrorType;\n/**\n * Determines whether the given type is the \"symbol\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicESSymbolType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicESSymbolType(type: ts.Type): type is IntrinsicESSymbolType;\n/**\n * A \"never\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicNeverType extends IntrinsicType {\n    intrinsicName: \"never\";\n}\n/**\n * A non-primitive intrinsic type.\n * E.g. An \"object\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicNonPrimitiveType extends IntrinsicType {\n    intrinsicName: \"\";\n}\n/**\n * A \"null\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicNullType extends IntrinsicType {\n    intrinsicName: \"null\";\n}\n/**\n * A \"number\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicNumberType extends IntrinsicType {\n    intrinsicName: \"number\";\n}\n/**\n * A \"string\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicStringType extends IntrinsicType {\n    intrinsicName: \"string\";\n}\n/**\n * The built-in `undefined` type.\n * @category Type Types\n */\ninterface IntrinsicUndefinedType extends IntrinsicType {\n    intrinsicName: \"undefined\";\n}\n/**\n * The built-in `unknown` type.\n * @category Type Types\n */\ninterface IntrinsicUnknownType extends IntrinsicType {\n    intrinsicName: \"unknown\";\n}\n/**\n * A \"void\" intrinsic type.\n * @category Type Types\n */\ninterface IntrinsicVoidType extends IntrinsicType {\n    intrinsicName: \"void\";\n}\n/**\n * Determines whether the given type is the \"never\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicNeverType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicNeverType(type: ts.Type): type is IntrinsicNeverType;\n/**\n * Determines whether the given type is a non-primitive intrinsic type.\n * E.g. An \"object\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicNonPrimitiveType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicNonPrimitiveType(type: ts.Type): type is IntrinsicNonPrimitiveType;\n/**\n * Determines whether the given type is the \"null\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicNullType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicNullType(type: ts.Type): type is IntrinsicNullType;\n/**\n * Determines whether the given type is the \"number\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicNumberType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicNumberType(type: ts.Type): type is IntrinsicNumberType;\n/**\n * Determines whether the given type is the \"string\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicStringType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicStringType(type: ts.Type): type is IntrinsicStringType;\n/**\n * Test if a type is an {@link IntrinsicType}.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicType(type: ts.Type): type is IntrinsicType;\n/**\n * Determines whether the given type is the \"undefined\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicUndefinedType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicUndefinedType(type: ts.Type): type is IntrinsicUndefinedType;\n/**\n * Determines whether the given type is the \"unknown\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicUnknownType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicUnknownType(type: ts.Type): type is IntrinsicUnknownType;\n/**\n * Determines whether the given type is the \"void\" intrinsic type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntrinsicVoidType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntrinsicVoidType(type: ts.Type): type is IntrinsicVoidType;\n\n/**\n * A type that is both an {@link IntrinsicType} and a `FreshableType`\n * @category Type Types\n */\ninterface FreshableIntrinsicType extends ts.FreshableType, IntrinsicType {\n}\n/**\n * Test if a type is a `FreshableIntrinsicType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isFreshableIntrinsicType(type)) {\n *   // ...\n * }\n */\ndeclare function isFreshableIntrinsicType(type: ts.Type): type is FreshableIntrinsicType;\n/**\n * Test if a type is a `TupleTypeReference`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTupleTypeReference(type)) {\n *   // ...\n * }\n */\ndeclare function isTupleTypeReference(type: ts.Type): type is ts.TupleTypeReference;\n\n/**\n * A boolean literal.\n * i.e. Either a \"true\" or \"false\" literal.\n * @category Type Types\n */\ninterface BooleanLiteralType extends FreshableIntrinsicType {\n    intrinsicName: \"false\" | \"true\";\n}\n/**\n * A \"false\" literal.\n * @category Type Types\n */\ninterface FalseLiteralType extends BooleanLiteralType {\n    intrinsicName: \"false\";\n}\n/**\n * A \"true\" literal.\n * @category Type Types\n */\ninterface TrueLiteralType extends BooleanLiteralType {\n    intrinsicName: \"true\";\n}\n/**\n * `LiteralType` from typescript except that it allows for it to work on arbitrary types.\n * @deprecated Use {@link FreshableIntrinsicType} instead.\n * @category Type Types\n */\ninterface UnknownLiteralType extends FreshableIntrinsicType {\n    value?: unknown;\n}\n/**\n * Test if a type is a `BigIntLiteralType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isBigIntLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isBigIntLiteralType(type: ts.Type): type is ts.BigIntLiteralType;\n/**\n * Determines whether the given type is a boolean literal type.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isBooleanLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isBooleanLiteralType(type: ts.Type): type is BooleanLiteralType;\n/**\n * Determines whether the given type is a boolean literal type for \"false\".\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isFalseLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isFalseLiteralType(type: ts.Type): type is FalseLiteralType;\n/**\n * Test if a type is a `LiteralType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isLiteralType(type: ts.Type): type is ts.LiteralType;\n/**\n * Test if a type is a `NumberLiteralType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isNumberLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isNumberLiteralType(type: ts.Type): type is ts.NumberLiteralType;\n/**\n * Test if a type is a `StringLiteralType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isStringLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isStringLiteralType(type: ts.Type): type is ts.StringLiteralType;\n/**\n * Test if a type is a `TemplateLiteralType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTemplateLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isTemplateLiteralType(type: ts.Type): type is ts.TemplateLiteralType;\n/**\n * Determines whether the given type is a boolean literal type for \"true\".\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTrueLiteralType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isTrueLiteralType(type: ts.Type): type is TrueLiteralType;\n\n/**\n * Test if a type is a `EvolvingArrayType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isEvolvingArrayType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isEvolvingArrayType(type: ts.Type): type is ts.EvolvingArrayType;\n/**\n * Test if a type is a `TupleType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTupleType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isTupleType(type: ts.Type): type is ts.TupleType;\n/**\n * Test if a type is a `TypeReference`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTypeReference(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isTypeReference(type: ts.Type): type is ts.TypeReference;\n\n/**\n * Test if a type is a `ConditionalType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isConditionalType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isConditionalType(type: ts.Type): type is ts.ConditionalType;\n/**\n * Test if a type is a `EnumType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isEnumType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isEnumType(type: ts.Type): type is ts.EnumType;\n/**\n * Test if a type is a `FreshableType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isFreshableType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isFreshableType(type: ts.Type): type is ts.FreshableType;\n/**\n * Test if a type is a `IndexedAccessType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIndexedAccessType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIndexedAccessType(type: ts.Type): type is ts.IndexedAccessType;\n/**\n * Test if a type is a `IndexType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIndexType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIndexType(type: ts.Type): type is ts.IndexType;\n/**\n * Test if a type is a `InstantiableType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isInstantiableType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isInstantiableType(type: ts.Type): type is ts.InstantiableType;\n/**\n * Test if a type is a `IntersectionType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isIntersectionType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isIntersectionType(type: ts.Type): type is ts.IntersectionType;\n/**\n * Test if a type is a `ObjectType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isObjectType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isObjectType(type: ts.Type): type is ts.ObjectType;\n/**\n * Test if a type is a `StringMappingType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isStringMappingType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isStringMappingType(type: ts.Type): type is ts.StringMappingType;\n/**\n * Test if a type is a `SubstitutionType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isSubstitutionType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isSubstitutionType(type: ts.Type): type is ts.SubstitutionType;\n/**\n * Test if a type is a `TypeParameter`.\n *\n * Note: It is intentional that this is not a type guard.\n * @see https://github.com/JoshuaKGoldberg/ts-api-utils/issues/382\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTypeParameter(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isTypeParameter(type: ts.Type): boolean;\n/**\n * Test if a type is a `TypeVariable`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isTypeVariable(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isTypeVariable(type: ts.Type): type is ts.TypeVariable;\n/**\n * Test if a type is a `UnionOrIntersectionType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isUnionOrIntersectionType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isUnionOrIntersectionType(type: ts.Type): type is ts.UnionOrIntersectionType;\n/**\n * Test if a type is a `UnionType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isUnionType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isUnionType(type: ts.Type): type is ts.UnionType;\n/**\n * Test if a type is a `UniqueESSymbolType`.\n * @category Types - Type Guards\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isUniqueESSymbolType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isUniqueESSymbolType(type: ts.Type): type is ts.UniqueESSymbolType;\n\n/**\n * Get the intersection type parts of the given type.\n *\n * If the given type is not a intersection type, an array contain only that type will be returned.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * for (const typePart of intersectionTypeParts(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function intersectionTypeParts(type: ts.Type): ts.Type[];\n/**\n * Determines whether a type is definitely falsy. This function doesn't unwrap union types.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (isFalsyType(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isFalsyType(type: ts.Type): boolean;\n/**\n * Determines whether writing to a certain property of a given type is allowed.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const property: ts.Symbol;\n * declare const type: ts.Type;\n * declare const typeChecker: ts.TypeChecker;\n *\n * if (isPropertyReadonlyInType(type, property.getEscapedName(), typeChecker)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isPropertyReadonlyInType(type: ts.Type, name: ts.__String, typeChecker: ts.TypeChecker): boolean;\n/**\n * Determines whether a type is thenable and thus can be used with `await`.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const node: ts.Node;\n * declare const type: ts.Type;\n * declare const typeChecker: ts.TypeChecker;\n *\n * if (isThenableType(typeChecker, node, type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isThenableType(typeChecker: ts.TypeChecker, node: ts.Node, type: ts.Type): boolean;\n/**\n * Determines whether a type is thenable and thus can be used with `await`.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const expression: ts.Expression;\n * declare const typeChecker: ts.TypeChecker;\n *\n * if (isThenableType(typeChecker, expression)) {\n *   // ...\n * }\n * ```\n * @example\n * ```ts\n * declare const expression: ts.Expression;\n * declare const typeChecker: ts.TypeChecker;\n * declare const type: ts.Type;\n *\n * if (isThenableType(typeChecker, expression, type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function isThenableType(typeChecker: ts.TypeChecker, node: ts.Expression, type?: ts.Type): boolean;\n/**\n * Test if the given symbol has a readonly declaration.\n * @category Symbols - Utilities\n * @example\n * ```ts\n * declare const symbol: ts.Symbol;\n * declare const typeChecker: ts.TypeChecker;\n *\n * if (symbolHasReadonlyDeclaration(symbol, typeChecker)) {\n *   // ...\n * }\n * ```\n */\ndeclare function symbolHasReadonlyDeclaration(symbol: ts.Symbol, typeChecker: ts.TypeChecker): boolean;\n/**\n * TS's `type.isLiteral()` is bugged before TS v5.0 and won't return `true` for\n * bigint literals. Use this function instead if you need to check for bigint\n * literals in TS versions before v5.0. Otherwise, you should just use\n * `type.isLiteral()`.\n * @see https://github.com/microsoft/TypeScript/pull/50929\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * if (typeIsLiteral(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function typeIsLiteral(type: ts.Type): type is ts.LiteralType;\n/**\n * Get the intersection or union type parts of the given type.\n *\n * Note that this is a shallow collection: it only returns `type.types` or `[type]`.\n *\n * If the given type is not an intersection or union type, an array contain only that type will be returned.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * for (const typePart of intersectionTypeParts(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function typeParts(type: ts.Type): ts.Type[];\n/**\n * Get the union type parts of the given type.\n *\n * If the given type is not a union type, an array contain only that type will be returned.\n * @category Types - Utilities\n * @example\n * ```ts\n * declare const type: ts.Type;\n *\n * for (const typePart of unionTypeParts(type)) {\n *   // ...\n * }\n * ```\n */\ndeclare function unionTypeParts(type: ts.Type): ts.Type[];\n\n/**\n * Which \"domain\"(s) (most commonly, type or value space) a declaration is within.\n */\ndeclare enum DeclarationDomain {\n    Namespace = 1,\n    Type = 2,\n    Value = 4,\n    Any = 7,\n    Import = 8\n}\n\n/**\n * Which \"domain\"(s) (most commonly, type or value space) a usage is within.\n */\ndeclare enum UsageDomain {\n    Namespace = 1,\n    Type = 2,\n    Value = 4,\n    Any = 7,\n    TypeQuery = 8,\n    ValueOrNamespace = 5\n}\n\n/**\n * An instance of an item (type or value) being used.\n */\ninterface Usage {\n    /**\n     * Which space(s) the usage is within.\n     */\n    domain: UsageDomain;\n    location: ts.Identifier;\n}\n/**\n * How an item (type or value) was declared and/or referenced.\n */\ninterface UsageInfo {\n    /**\n     * Locations where the item was declared.\n     */\n    declarations: ts.Identifier[];\n    /**\n     * Which space(s) the item is within.\n     */\n    domain: DeclarationDomain;\n    /**\n     * Whether the item was exported from its module or namespace scope.\n     */\n    exported: boolean;\n    /**\n     * Whether the item's declaration was in the global scope.\n     */\n    inGlobalScope: boolean;\n    /**\n     * Each reference to the item in the file.\n     */\n    uses: Usage[];\n}\n\n/**\n * Creates a mapping of each declared type and value to its type information.\n * @category Nodes - Other Utilities\n * @example\n * ```ts\n * declare const sourceFile: ts.SourceFile;\n *\n * const usage = collectVariableUsage(sourceFile);\n *\n * for (const [identifier, information] of usage) {\n * \tconsole.log(`${identifier.getText()} is used ${information.uses.length} time(s).`);\n * }\n * ```\n */\ndeclare function collectVariableUsage(sourceFile: ts.SourceFile): Map<ts.Identifier, UsageInfo>;\n\nexport { AccessKind, type AnyKeyword, type BigIntKeyword, type BooleanCompilerOptions, type BooleanKeyword, type BooleanLiteralType, type ConstAssertionExpression, type ConstAssertionIdentifier, DeclarationDomain, type FalseKeyword, type FalseLiteralType, type ForEachCommentCallback, type ForEachTokenCallback, type FreshableIntrinsicType, type ImportKeyword, type IntrinsicAnyType, type IntrinsicBigIntType, type IntrinsicBooleanType, type IntrinsicESSymbolType, type IntrinsicErrorType, type IntrinsicNeverType, type IntrinsicNonPrimitiveType, type IntrinsicNullType, type IntrinsicNumberType, type IntrinsicStringType, type IntrinsicType, type IntrinsicUndefinedType, type IntrinsicUnknownType, type IntrinsicVoidType, type NamedDeclarationWithName, type NeverKeyword, type NullKeyword, type NumberKeyword, type NumericOrStringLikeLiteral, type ObjectKeyword, type StrictCompilerOption, type StringKeyword, type SuperKeyword, type SymbolKeyword, type ThisKeyword, type TrueKeyword, type TrueLiteralType, type UndefinedKeyword, type UnknownKeyword, type UnknownLiteralType, UsageDomain, type UsageInfo as VariableInfo, type Usage as VariableUse, type VoidKeyword, collectVariableUsage, forEachComment, forEachToken, getAccessKind, getCallSignaturesOfType, getPropertyOfType, getWellKnownSymbolPropertyOfType, hasDecorators, hasExpressionInitializer, hasInitializer, hasJSDoc, hasModifiers, hasType, hasTypeArguments, includesModifier, intersectionTypeParts, isAbstractKeyword, isAccessExpression, isAccessibilityModifier, isAccessorDeclaration, isAccessorKeyword, isAnyKeyword, isArrayBindingElement, isArrayBindingOrAssignmentPattern, isAssertKeyword, isAssertsKeyword, isAssignmentKind, isAssignmentPattern, isAsyncKeyword, isAwaitKeyword, isBigIntKeyword, isBigIntLiteralType, isBindingOrAssignmentElementRestIndicator, isBindingOrAssignmentElementTarget, isBindingOrAssignmentPattern, isBindingPattern, isBlockLike, isBooleanKeyword, isBooleanLiteral, isBooleanLiteralType, isClassLikeDeclaration, isClassMemberModifier, isColonToken, isCompilerOptionEnabled, isConditionalType, isConstAssertionExpression, isConstKeyword, isDeclarationName, isDeclarationWithTypeParameterChildren, isDeclarationWithTypeParameters, isDeclareKeyword, isDefaultKeyword, isDestructuringPattern, isDotToken, isEndOfFileToken, isEntityNameExpression, isEntityNameOrEntityNameExpression, isEnumType, isEqualsGreaterThanToken, isEqualsToken, isEvolvingArrayType, isExclamationToken, isExportKeyword, isFalseKeyword, isFalseLiteral, isFalseLiteralType, isFalsyType, isForInOrOfStatement, isFreshableIntrinsicType, isFreshableType, isFunctionLikeDeclaration, isFunctionScopeBoundary, isImportExpression, isImportKeyword, isInKeyword, isIndexType, isIndexedAccessType, isInstantiableType, isIntersectionType, isIntrinsicAnyType, isIntrinsicBigIntType, isIntrinsicBooleanType, isIntrinsicESSymbolType, isIntrinsicErrorType, isIntrinsicNeverType, isIntrinsicNonPrimitiveType, isIntrinsicNullType, isIntrinsicNumberType, isIntrinsicStringType, isIntrinsicType, isIntrinsicUndefinedType, isIntrinsicUnknownType, isIntrinsicVoidType, isIterationStatement, isJSDocComment, isJSDocNamespaceBody, isJSDocNamespaceDeclaration, isJSDocText, isJSDocTypeReferencingNode, isJsonMinusNumericLiteral, isJsonObjectExpression, isJsxAttributeLike, isJsxAttributeValue, isJsxChild, isJsxTagNameExpression, isJsxTagNamePropertyAccess, isLiteralToken, isLiteralType, isModifierFlagSet, isModuleBody, isModuleName, isModuleReference, isNamedDeclarationWithName, isNamedImportBindings, isNamedImportsOrExports, isNamespaceBody, isNamespaceDeclaration, isNeverKeyword, isNodeFlagSet, isNullKeyword, isNullLiteral, isNumberKeyword, isNumberLiteralType, isNumericOrStringLikeLiteral, isNumericPropertyName, isObjectBindingOrAssignmentElement, isObjectBindingOrAssignmentPattern, isObjectFlagSet, isObjectKeyword, isObjectType, isObjectTypeDeclaration, isOutKeyword, isOverrideKeyword, isParameterPropertyModifier, isPrivateKeyword, isPropertyAccessEntityNameExpression, isPropertyNameLiteral, isPropertyReadonlyInType, isProtectedKeyword, isPseudoLiteralToken, isPublicKeyword, isQuestionDotToken, isQuestionToken, isReadonlyKeyword, isSignatureDeclaration, isStaticKeyword, isStrictCompilerOptionEnabled, isStringKeyword, isStringLiteralType, isStringMappingType, isSubstitutionType, isSuperElementAccessExpression, isSuperExpression, isSuperKeyword, isSuperProperty, isSuperPropertyAccessExpression, isSymbolFlagSet, isSymbolKeyword, isSyntaxList, isTemplateLiteralType, isThenableType, isThisExpression, isThisKeyword, isTransientSymbolLinksFlagSet, isTrueKeyword, isTrueLiteral, isTrueLiteralType, isTupleType, isTupleTypeReference, isTypeFlagSet, isTypeOnlyCompatibleAliasDeclaration, isTypeParameter, isTypeReference, isTypeReferenceType, isTypeVariable, isUndefinedKeyword, isUnionOrIntersectionType, isUnionOrIntersectionTypeNode, isUnionType, isUniqueESSymbolType, isUnknownKeyword, isValidPropertyAccess, isVariableLikeDeclaration, isVoidKeyword, symbolHasReadonlyDeclaration, typeIsLiteral, typeParts, unionTypeParts };\n"
        }
    ]
}