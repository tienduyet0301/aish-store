{
    "sourceFile": "node_modules/ts-api-utils/lib/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746893059729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import ts9 from 'typescript';\n\n// src/comments.ts\nfunction forEachToken(node, callback, sourceFile = node.getSourceFile()) {\n  const queue = [];\n  while (true) {\n    if (ts9.isTokenKind(node.kind)) {\n      callback(node);\n    } else {\n      const children = node.getChildren(sourceFile);\n      if (children.length === 1) {\n        node = children[0];\n        continue;\n      }\n      for (let i = children.length - 1; i >= 0; --i) {\n        queue.push(children[i]);\n      }\n    }\n    if (queue.length === 0) {\n      break;\n    }\n    node = queue.pop();\n  }\n}\n\n// src/comments.ts\nfunction forEachComment(node, callback, sourceFile = node.getSourceFile()) {\n  const fullText = sourceFile.text;\n  const notJsx = sourceFile.languageVariant !== ts9.LanguageVariant.JSX;\n  return forEachToken(\n    node,\n    (token) => {\n      if (token.pos === token.end) {\n        return;\n      }\n      if (token.kind !== ts9.SyntaxKind.JsxText) {\n        ts9.forEachLeadingCommentRange(\n          fullText,\n          // skip shebang at position 0\n          token.pos === 0 ? (ts9.getShebang(fullText) ?? \"\").length : token.pos,\n          commentCallback\n        );\n      }\n      if (notJsx || canHaveTrailingTrivia(token)) {\n        return ts9.forEachTrailingCommentRange(\n          fullText,\n          token.end,\n          commentCallback\n        );\n      }\n    },\n    sourceFile\n  );\n  function commentCallback(pos, end, kind) {\n    callback(fullText, { end, kind, pos });\n  }\n}\nfunction canHaveTrailingTrivia(token) {\n  switch (token.kind) {\n    case ts9.SyntaxKind.CloseBraceToken:\n      return token.parent.kind !== ts9.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);\n    case ts9.SyntaxKind.GreaterThanToken:\n      switch (token.parent.kind) {\n        case ts9.SyntaxKind.JsxClosingElement:\n        case ts9.SyntaxKind.JsxClosingFragment:\n          return !isJsxElementOrFragment(token.parent.parent.parent);\n        case ts9.SyntaxKind.JsxOpeningElement:\n          return token.end !== token.parent.end;\n        case ts9.SyntaxKind.JsxOpeningFragment:\n          return false;\n        // would be inside the fragment\n        case ts9.SyntaxKind.JsxSelfClosingElement:\n          return token.end !== token.parent.end || // if end is not equal, this is part of the type arguments list\n          !isJsxElementOrFragment(token.parent.parent);\n      }\n  }\n  return true;\n}\nfunction isJsxElementOrFragment(node) {\n  return node.kind === ts9.SyntaxKind.JsxElement || node.kind === ts9.SyntaxKind.JsxFragment;\n}\nfunction isCompilerOptionEnabled(options, option) {\n  switch (option) {\n    case \"allowJs\":\n      return options.allowJs === undefined ? isCompilerOptionEnabled(options, \"checkJs\") : options.allowJs;\n    case \"allowSyntheticDefaultImports\":\n      return options.allowSyntheticDefaultImports !== undefined ? options.allowSyntheticDefaultImports : isCompilerOptionEnabled(options, \"esModuleInterop\") || options.module === ts9.ModuleKind.System;\n    case \"alwaysStrict\":\n    case \"noImplicitAny\":\n    case \"noImplicitThis\":\n    case \"strictBindCallApply\":\n    case \"strictFunctionTypes\":\n    case \"strictNullChecks\":\n    case \"strictPropertyInitialization\":\n      return isStrictCompilerOptionEnabled(\n        options,\n        option\n      );\n    case \"declaration\":\n      return options.declaration || isCompilerOptionEnabled(options, \"composite\");\n    case \"declarationMap\":\n    case \"emitDeclarationOnly\":\n    case \"stripInternal\":\n      return options[option] === true && isCompilerOptionEnabled(options, \"declaration\");\n    case \"incremental\":\n      return options.incremental === undefined ? isCompilerOptionEnabled(options, \"composite\") : options.incremental;\n    case \"noUncheckedIndexedAccess\":\n      return options.noUncheckedIndexedAccess === true && isCompilerOptionEnabled(options, \"strictNullChecks\");\n    case \"skipDefaultLibCheck\":\n      return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, \"skipLibCheck\");\n    case \"suppressImplicitAnyIndexErrors\":\n      return (\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, \"noImplicitAny\")\n      );\n  }\n  return options[option] === true;\n}\nfunction isStrictCompilerOptionEnabled(options, option) {\n  return (options.strict ? options[option] !== false : options[option] === true) && (option !== \"strictPropertyInitialization\" || isStrictCompilerOptionEnabled(options, \"strictNullChecks\"));\n}\nfunction isModifierFlagSet(node, flag) {\n  return isFlagSet(ts9.getCombinedModifierFlags(node), flag);\n}\nfunction isFlagSet(allFlags, flag) {\n  return (allFlags & flag) !== 0;\n}\nfunction isFlagSetOnObject(obj, flag) {\n  return isFlagSet(obj.flags, flag);\n}\nvar isNodeFlagSet = isFlagSetOnObject;\nfunction isObjectFlagSet(objectType, flag) {\n  return isFlagSet(objectType.objectFlags, flag);\n}\nvar isSymbolFlagSet = isFlagSetOnObject;\nfunction isTransientSymbolLinksFlagSet(links, flag) {\n  return isFlagSet(links.checkFlags, flag);\n}\nvar isTypeFlagSet = isFlagSetOnObject;\n\n// src/modifiers.ts\nfunction includesModifier(modifiers, ...kinds) {\n  if (modifiers === undefined) {\n    return false;\n  }\n  for (const modifier of modifiers) {\n    if (kinds.includes(modifier.kind)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isAssignmentKind(kind) {\n  return kind >= ts9.SyntaxKind.FirstAssignment && kind <= ts9.SyntaxKind.LastAssignment;\n}\nfunction isNumericPropertyName(name) {\n  return String(+name) === name;\n}\nfunction isValidPropertyAccess(text, languageVersion = ts9.ScriptTarget.Latest) {\n  if (text.length === 0) {\n    return false;\n  }\n  let ch = text.codePointAt(0);\n  if (!ts9.isIdentifierStart(ch, languageVersion)) {\n    return false;\n  }\n  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {\n    ch = text.codePointAt(i);\n    if (!ts9.isIdentifierPart(ch, languageVersion)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction charSize(ch) {\n  return ch >= 65536 ? 2 : 1;\n}\n\n// src/nodes/access.ts\nvar AccessKind = /* @__PURE__ */ ((AccessKind2) => {\n  AccessKind2[AccessKind2[\"None\"] = 0] = \"None\";\n  AccessKind2[AccessKind2[\"Read\"] = 1] = \"Read\";\n  AccessKind2[AccessKind2[\"Write\"] = 2] = \"Write\";\n  AccessKind2[AccessKind2[\"Delete\"] = 4] = \"Delete\";\n  AccessKind2[AccessKind2[\"ReadWrite\"] = 3] = \"ReadWrite\";\n  return AccessKind2;\n})(AccessKind || {});\nfunction getAccessKind(node) {\n  const parent = node.parent;\n  switch (parent.kind) {\n    case ts9.SyntaxKind.ArrayLiteralExpression:\n    case ts9.SyntaxKind.SpreadAssignment:\n    case ts9.SyntaxKind.SpreadElement:\n      return isInDestructuringAssignment(\n        parent\n      ) ? 2 /* Write */ : 1 /* Read */;\n    case ts9.SyntaxKind.ArrowFunction:\n      return parent.body === node ? 1 /* Read */ : 2 /* Write */;\n    case ts9.SyntaxKind.AsExpression:\n    case ts9.SyntaxKind.NonNullExpression:\n    case ts9.SyntaxKind.ParenthesizedExpression:\n    case ts9.SyntaxKind.TypeAssertionExpression:\n      return getAccessKind(parent);\n    case ts9.SyntaxKind.AwaitExpression:\n    case ts9.SyntaxKind.CallExpression:\n    case ts9.SyntaxKind.CaseClause:\n    case ts9.SyntaxKind.ComputedPropertyName:\n    case ts9.SyntaxKind.ConditionalExpression:\n    case ts9.SyntaxKind.Decorator:\n    case ts9.SyntaxKind.DoStatement:\n    case ts9.SyntaxKind.ElementAccessExpression:\n    case ts9.SyntaxKind.ExpressionStatement:\n    case ts9.SyntaxKind.ForStatement:\n    case ts9.SyntaxKind.IfStatement:\n    case ts9.SyntaxKind.JsxElement:\n    case ts9.SyntaxKind.JsxExpression:\n    case ts9.SyntaxKind.JsxOpeningElement:\n    case ts9.SyntaxKind.JsxSelfClosingElement:\n    case ts9.SyntaxKind.JsxSpreadAttribute:\n    case ts9.SyntaxKind.NewExpression:\n    case ts9.SyntaxKind.ReturnStatement:\n    case ts9.SyntaxKind.SwitchStatement:\n    case ts9.SyntaxKind.TaggedTemplateExpression:\n    case ts9.SyntaxKind.TemplateSpan:\n    case ts9.SyntaxKind.ThrowStatement:\n    case ts9.SyntaxKind.TypeOfExpression:\n    case ts9.SyntaxKind.VoidExpression:\n    case ts9.SyntaxKind.WhileStatement:\n    case ts9.SyntaxKind.WithStatement:\n    case ts9.SyntaxKind.YieldExpression:\n      return 1 /* Read */;\n    case ts9.SyntaxKind.BinaryExpression:\n      return parent.right === node ? 1 /* Read */ : !isAssignmentKind(parent.operatorToken.kind) ? 1 /* Read */ : parent.operatorToken.kind === ts9.SyntaxKind.EqualsToken ? 2 /* Write */ : 3 /* ReadWrite */;\n    case ts9.SyntaxKind.BindingElement:\n    case ts9.SyntaxKind.EnumMember:\n    case ts9.SyntaxKind.JsxAttribute:\n    case ts9.SyntaxKind.Parameter:\n    case ts9.SyntaxKind.PropertyDeclaration:\n    case ts9.SyntaxKind.VariableDeclaration:\n      return parent.initializer === node ? 1 /* Read */ : 0 /* None */;\n    case ts9.SyntaxKind.DeleteExpression:\n      return 4 /* Delete */;\n    case ts9.SyntaxKind.ExportAssignment:\n      return parent.isExportEquals ? 1 /* Read */ : 0 /* None */;\n    case ts9.SyntaxKind.ExpressionWithTypeArguments:\n      return parent.parent.token === ts9.SyntaxKind.ExtendsKeyword && parent.parent.parent.kind !== ts9.SyntaxKind.InterfaceDeclaration ? 1 /* Read */ : 0 /* None */;\n    case ts9.SyntaxKind.ForInStatement:\n    case ts9.SyntaxKind.ForOfStatement:\n      return parent.initializer === node ? 2 /* Write */ : 1 /* Read */;\n    case ts9.SyntaxKind.PostfixUnaryExpression:\n      return 3 /* ReadWrite */;\n    case ts9.SyntaxKind.PrefixUnaryExpression:\n      return parent.operator === ts9.SyntaxKind.PlusPlusToken || parent.operator === ts9.SyntaxKind.MinusMinusToken ? 3 /* ReadWrite */ : 1 /* Read */;\n    case ts9.SyntaxKind.PropertyAccessExpression:\n      return parent.expression === node ? 1 /* Read */ : 0 /* None */;\n    case ts9.SyntaxKind.PropertyAssignment:\n      return parent.name === node ? 0 /* None */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;\n    case ts9.SyntaxKind.ShorthandPropertyAssignment:\n      return parent.objectAssignmentInitializer === node ? 1 /* Read */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;\n  }\n  return 0 /* None */;\n}\nfunction isInDestructuringAssignment(node) {\n  switch (node.kind) {\n    case ts9.SyntaxKind.ShorthandPropertyAssignment:\n      if (node.objectAssignmentInitializer !== undefined) {\n        return true;\n      }\n    // falls through\n    case ts9.SyntaxKind.PropertyAssignment:\n    case ts9.SyntaxKind.SpreadAssignment:\n      node = node.parent;\n      break;\n    case ts9.SyntaxKind.SpreadElement:\n      if (node.parent.kind !== ts9.SyntaxKind.ArrayLiteralExpression) {\n        return false;\n      }\n      node = node.parent;\n  }\n  while (true) {\n    switch (node.parent.kind) {\n      case ts9.SyntaxKind.ArrayLiteralExpression:\n      case ts9.SyntaxKind.ObjectLiteralExpression:\n        node = node.parent;\n        break;\n      case ts9.SyntaxKind.BinaryExpression:\n        return node.parent.left === node && node.parent.operatorToken.kind === ts9.SyntaxKind.EqualsToken;\n      case ts9.SyntaxKind.ForOfStatement:\n        return node.parent.initializer === node;\n      case ts9.SyntaxKind.PropertyAssignment:\n      case ts9.SyntaxKind.SpreadAssignment:\n        node = node.parent.parent;\n        break;\n      case ts9.SyntaxKind.SpreadElement:\n        if (node.parent.parent.kind !== ts9.SyntaxKind.ArrayLiteralExpression) {\n          return false;\n        }\n        node = node.parent.parent;\n        break;\n      default:\n        return false;\n    }\n  }\n}\nfunction isAbstractKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AbstractKeyword;\n}\nfunction isAccessorKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AccessorKeyword;\n}\nfunction isAnyKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AnyKeyword;\n}\nfunction isAssertKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AssertKeyword;\n}\nfunction isAssertsKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AssertsKeyword;\n}\nfunction isAsyncKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AsyncKeyword;\n}\nfunction isAwaitKeyword(node) {\n  return node.kind === ts9.SyntaxKind.AwaitKeyword;\n}\nfunction isBigIntKeyword(node) {\n  return node.kind === ts9.SyntaxKind.BigIntKeyword;\n}\nfunction isBooleanKeyword(node) {\n  return node.kind === ts9.SyntaxKind.BooleanKeyword;\n}\nfunction isColonToken(node) {\n  return node.kind === ts9.SyntaxKind.ColonToken;\n}\nfunction isConstKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ConstKeyword;\n}\nfunction isDeclareKeyword(node) {\n  return node.kind === ts9.SyntaxKind.DeclareKeyword;\n}\nfunction isDefaultKeyword(node) {\n  return node.kind === ts9.SyntaxKind.DefaultKeyword;\n}\nfunction isDotToken(node) {\n  return node.kind === ts9.SyntaxKind.DotToken;\n}\nfunction isEndOfFileToken(node) {\n  return node.kind === ts9.SyntaxKind.EndOfFileToken;\n}\nfunction isEqualsGreaterThanToken(node) {\n  return node.kind === ts9.SyntaxKind.EqualsGreaterThanToken;\n}\nfunction isEqualsToken(node) {\n  return node.kind === ts9.SyntaxKind.EqualsToken;\n}\nfunction isExclamationToken(node) {\n  return node.kind === ts9.SyntaxKind.ExclamationToken;\n}\nfunction isExportKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ExportKeyword;\n}\nfunction isFalseKeyword(node) {\n  return node.kind === ts9.SyntaxKind.FalseKeyword;\n}\nfunction isFalseLiteral(node) {\n  return node.kind === ts9.SyntaxKind.FalseKeyword;\n}\nfunction isImportExpression(node) {\n  return node.kind === ts9.SyntaxKind.ImportKeyword;\n}\nfunction isImportKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ImportKeyword;\n}\nfunction isInKeyword(node) {\n  return node.kind === ts9.SyntaxKind.InKeyword;\n}\nfunction isJSDocText(node) {\n  return node.kind === ts9.SyntaxKind.JSDocText;\n}\nfunction isJsonMinusNumericLiteral(node) {\n  return node.kind === ts9.SyntaxKind.PrefixUnaryExpression;\n}\nfunction isNeverKeyword(node) {\n  return node.kind === ts9.SyntaxKind.NeverKeyword;\n}\nfunction isNullKeyword(node) {\n  return node.kind === ts9.SyntaxKind.NullKeyword;\n}\nfunction isNullLiteral(node) {\n  return node.kind === ts9.SyntaxKind.NullKeyword;\n}\nfunction isNumberKeyword(node) {\n  return node.kind === ts9.SyntaxKind.NumberKeyword;\n}\nfunction isObjectKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ObjectKeyword;\n}\nfunction isOutKeyword(node) {\n  return node.kind === ts9.SyntaxKind.OutKeyword;\n}\nfunction isOverrideKeyword(node) {\n  return node.kind === ts9.SyntaxKind.OverrideKeyword;\n}\nfunction isPrivateKeyword(node) {\n  return node.kind === ts9.SyntaxKind.PrivateKeyword;\n}\nfunction isProtectedKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ProtectedKeyword;\n}\nfunction isPublicKeyword(node) {\n  return node.kind === ts9.SyntaxKind.PublicKeyword;\n}\nfunction isQuestionDotToken(node) {\n  return node.kind === ts9.SyntaxKind.QuestionDotToken;\n}\nfunction isQuestionToken(node) {\n  return node.kind === ts9.SyntaxKind.QuestionToken;\n}\nfunction isReadonlyKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ReadonlyKeyword;\n}\nfunction isStaticKeyword(node) {\n  return node.kind === ts9.SyntaxKind.StaticKeyword;\n}\nfunction isStringKeyword(node) {\n  return node.kind === ts9.SyntaxKind.StringKeyword;\n}\nfunction isSuperExpression(node) {\n  return node.kind === ts9.SyntaxKind.SuperKeyword;\n}\nfunction isSuperKeyword(node) {\n  return node.kind === ts9.SyntaxKind.SuperKeyword;\n}\nfunction isSymbolKeyword(node) {\n  return node.kind === ts9.SyntaxKind.SymbolKeyword;\n}\nfunction isSyntaxList(node) {\n  return node.kind === ts9.SyntaxKind.SyntaxList;\n}\nfunction isThisExpression(node) {\n  return node.kind === ts9.SyntaxKind.ThisKeyword;\n}\nfunction isThisKeyword(node) {\n  return node.kind === ts9.SyntaxKind.ThisKeyword;\n}\nfunction isTrueKeyword(node) {\n  return node.kind === ts9.SyntaxKind.TrueKeyword;\n}\nfunction isTrueLiteral(node) {\n  return node.kind === ts9.SyntaxKind.TrueKeyword;\n}\nfunction isUndefinedKeyword(node) {\n  return node.kind === ts9.SyntaxKind.UndefinedKeyword;\n}\nfunction isUnknownKeyword(node) {\n  return node.kind === ts9.SyntaxKind.UnknownKeyword;\n}\nfunction isVoidKeyword(node) {\n  return node.kind === ts9.SyntaxKind.VoidKeyword;\n}\nvar [tsMajor, tsMinor] = ts9.versionMajorMinor.split(\".\").map((raw) => Number.parseInt(raw, 10));\nfunction isTsVersionAtLeast(major, minor = 0) {\n  return tsMajor > major || tsMajor === major && tsMinor >= minor;\n}\n\n// src/nodes/typeGuards/union.ts\nfunction hasDecorators(node) {\n  return ts9.isParameter(node) || ts9.isPropertyDeclaration(node) || ts9.isMethodDeclaration(node) || ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node) || ts9.isClassExpression(node) || ts9.isClassDeclaration(node);\n}\nfunction hasExpressionInitializer(node) {\n  return ts9.isVariableDeclaration(node) || ts9.isParameter(node) || ts9.isBindingElement(node) || ts9.isPropertyDeclaration(node) || ts9.isPropertyAssignment(node) || ts9.isEnumMember(node);\n}\nfunction hasInitializer(node) {\n  return hasExpressionInitializer(node) || ts9.isForStatement(node) || ts9.isForInStatement(node) || ts9.isForOfStatement(node) || ts9.isJsxAttribute(node);\n}\nfunction hasJSDoc(node) {\n  if (\n    // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5\n    isAccessorDeclaration(node) || ts9.isArrowFunction(node) || ts9.isBlock(node) || ts9.isBreakStatement(node) || ts9.isCallSignatureDeclaration(node) || ts9.isCaseClause(node) || // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5\n    isClassLikeDeclaration(node) || ts9.isConstructorDeclaration(node) || ts9.isConstructorTypeNode(node) || ts9.isConstructSignatureDeclaration(node) || ts9.isContinueStatement(node) || ts9.isDebuggerStatement(node) || ts9.isDoStatement(node) || ts9.isEmptyStatement(node) || isEndOfFileToken(node) || ts9.isEnumDeclaration(node) || ts9.isEnumMember(node) || ts9.isExportAssignment(node) || ts9.isExportDeclaration(node) || ts9.isExportSpecifier(node) || ts9.isExpressionStatement(node) || ts9.isForInStatement(node) || ts9.isForOfStatement(node) || ts9.isForStatement(node) || ts9.isFunctionDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isFunctionTypeNode(node) || ts9.isIfStatement(node) || ts9.isImportDeclaration(node) || ts9.isImportEqualsDeclaration(node) || ts9.isIndexSignatureDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isJSDocFunctionType(node) || ts9.isLabeledStatement(node) || ts9.isMethodDeclaration(node) || ts9.isMethodSignature(node) || ts9.isModuleDeclaration(node) || ts9.isNamedTupleMember(node) || ts9.isNamespaceExportDeclaration(node) || ts9.isParameter(node) || ts9.isParenthesizedExpression(node) || ts9.isPropertyAssignment(node) || ts9.isPropertyDeclaration(node) || ts9.isPropertySignature(node) || ts9.isReturnStatement(node) || ts9.isShorthandPropertyAssignment(node) || ts9.isSpreadAssignment(node) || ts9.isSwitchStatement(node) || ts9.isThrowStatement(node) || ts9.isTryStatement(node) || ts9.isTypeAliasDeclaration(node) || ts9.isVariableDeclaration(node) || ts9.isVariableStatement(node) || ts9.isWhileStatement(node) || ts9.isWithStatement(node)\n  ) {\n    return true;\n  }\n  if (isTsVersionAtLeast(4, 4) && ts9.isClassStaticBlockDeclaration(node)) {\n    return true;\n  }\n  if (isTsVersionAtLeast(5, 0) && (ts9.isBinaryExpression(node) || ts9.isElementAccessExpression(node) || ts9.isIdentifier(node) || ts9.isJSDocSignature(node) || ts9.isObjectLiteralExpression(node) || ts9.isPropertyAccessExpression(node) || ts9.isTypeParameterDeclaration(node))) {\n    return true;\n  }\n  return false;\n}\nfunction hasModifiers(node) {\n  return ts9.isTypeParameterDeclaration(node) || ts9.isParameter(node) || ts9.isConstructorTypeNode(node) || ts9.isPropertySignature(node) || ts9.isPropertyDeclaration(node) || ts9.isMethodSignature(node) || ts9.isMethodDeclaration(node) || ts9.isConstructorDeclaration(node) || ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node) || ts9.isIndexSignatureDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isArrowFunction(node) || ts9.isClassExpression(node) || ts9.isVariableStatement(node) || ts9.isFunctionDeclaration(node) || ts9.isClassDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isTypeAliasDeclaration(node) || ts9.isEnumDeclaration(node) || ts9.isModuleDeclaration(node) || ts9.isImportEqualsDeclaration(node) || ts9.isImportDeclaration(node) || ts9.isExportAssignment(node) || ts9.isExportDeclaration(node);\n}\nfunction hasType(node) {\n  return isSignatureDeclaration(node) || ts9.isVariableDeclaration(node) || ts9.isParameter(node) || ts9.isPropertySignature(node) || ts9.isPropertyDeclaration(node) || ts9.isTypePredicateNode(node) || ts9.isParenthesizedTypeNode(node) || ts9.isTypeOperatorNode(node) || ts9.isMappedTypeNode(node) || ts9.isAssertionExpression(node) || ts9.isTypeAliasDeclaration(node) || ts9.isJSDocTypeExpression(node) || ts9.isJSDocNonNullableType(node) || ts9.isJSDocNullableType(node) || ts9.isJSDocOptionalType(node) || ts9.isJSDocVariadicType(node);\n}\nfunction hasTypeArguments(node) {\n  return ts9.isCallExpression(node) || ts9.isNewExpression(node) || ts9.isTaggedTemplateExpression(node) || ts9.isJsxOpeningElement(node) || ts9.isJsxSelfClosingElement(node);\n}\nfunction isAccessExpression(node) {\n  return ts9.isPropertyAccessExpression(node) || ts9.isElementAccessExpression(node);\n}\nfunction isAccessibilityModifier(node) {\n  return isPublicKeyword(node) || isPrivateKeyword(node) || isProtectedKeyword(node);\n}\nfunction isAccessorDeclaration(node) {\n  return ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node);\n}\nfunction isArrayBindingElement(node) {\n  return ts9.isBindingElement(node) || ts9.isOmittedExpression(node);\n}\nfunction isArrayBindingOrAssignmentPattern(node) {\n  return ts9.isArrayBindingPattern(node) || ts9.isArrayLiteralExpression(node);\n}\nfunction isAssignmentPattern(node) {\n  return ts9.isObjectLiteralExpression(node) || ts9.isArrayLiteralExpression(node);\n}\nfunction isBindingOrAssignmentElementRestIndicator(node) {\n  if (ts9.isSpreadElement(node) || ts9.isSpreadAssignment(node)) {\n    return true;\n  }\n  if (isTsVersionAtLeast(4, 4)) {\n    return ts9.isDotDotDotToken(node);\n  }\n  return false;\n}\nfunction isBindingOrAssignmentElementTarget(node) {\n  return isBindingOrAssignmentPattern(node) || ts9.isIdentifier(node) || ts9.isPropertyAccessExpression(node) || ts9.isElementAccessExpression(node) || ts9.isOmittedExpression(node);\n}\nfunction isBindingOrAssignmentPattern(node) {\n  return isObjectBindingOrAssignmentPattern(node) || isArrayBindingOrAssignmentPattern(node);\n}\nfunction isBindingPattern(node) {\n  return ts9.isObjectBindingPattern(node) || ts9.isArrayBindingPattern(node);\n}\nfunction isBlockLike(node) {\n  return ts9.isSourceFile(node) || ts9.isBlock(node) || ts9.isModuleBlock(node) || ts9.isCaseOrDefaultClause(node);\n}\nfunction isBooleanLiteral(node) {\n  return isTrueLiteral(node) || isFalseLiteral(node);\n}\nfunction isClassLikeDeclaration(node) {\n  return ts9.isClassDeclaration(node) || ts9.isClassExpression(node);\n}\nfunction isClassMemberModifier(node) {\n  return isAccessibilityModifier(node) || isReadonlyKeyword(node) || isStaticKeyword(node) || isAccessorKeyword(node);\n}\nfunction isDeclarationName(node) {\n  return ts9.isIdentifier(node) || ts9.isPrivateIdentifier(node) || ts9.isStringLiteralLike(node) || ts9.isNumericLiteral(node) || ts9.isComputedPropertyName(node) || ts9.isElementAccessExpression(node) || isBindingPattern(node) || isEntityNameExpression(node);\n}\nfunction isDeclarationWithTypeParameterChildren(node) {\n  return isSignatureDeclaration(node) || // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5\n  isClassLikeDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isTypeAliasDeclaration(node) || ts9.isJSDocTemplateTag(node);\n}\nfunction isDeclarationWithTypeParameters(node) {\n  return isDeclarationWithTypeParameterChildren(node) || ts9.isJSDocTypedefTag(node) || ts9.isJSDocCallbackTag(node) || ts9.isJSDocSignature(node);\n}\nfunction isDestructuringPattern(node) {\n  return isBindingPattern(node) || ts9.isObjectLiteralExpression(node) || ts9.isArrayLiteralExpression(node);\n}\nfunction isEntityNameExpression(node) {\n  return ts9.isIdentifier(node) || isPropertyAccessEntityNameExpression(node);\n}\nfunction isEntityNameOrEntityNameExpression(node) {\n  return ts9.isEntityName(node) || isEntityNameExpression(node);\n}\nfunction isForInOrOfStatement(node) {\n  return ts9.isForInStatement(node) || ts9.isForOfStatement(node);\n}\nfunction isFunctionLikeDeclaration(node) {\n  return ts9.isFunctionDeclaration(node) || ts9.isMethodDeclaration(node) || ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node) || ts9.isConstructorDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isArrowFunction(node);\n}\nfunction isJSDocComment(node) {\n  if (isJSDocText(node)) {\n    return true;\n  }\n  if (isTsVersionAtLeast(4, 4)) {\n    return ts9.isJSDocLink(node) || ts9.isJSDocLinkCode(node) || ts9.isJSDocLinkPlain(node);\n  }\n  return false;\n}\nfunction isJSDocNamespaceBody(node) {\n  return ts9.isIdentifier(node) || isJSDocNamespaceDeclaration(node);\n}\nfunction isJSDocTypeReferencingNode(node) {\n  return ts9.isJSDocVariadicType(node) || ts9.isJSDocOptionalType(node) || ts9.isJSDocNullableType(node) || ts9.isJSDocNonNullableType(node);\n}\nfunction isJsonObjectExpression(node) {\n  return ts9.isObjectLiteralExpression(node) || ts9.isArrayLiteralExpression(node) || isJsonMinusNumericLiteral(node) || ts9.isNumericLiteral(node) || ts9.isStringLiteral(node) || isBooleanLiteral(node) || isNullLiteral(node);\n}\nfunction isJsxAttributeLike(node) {\n  return ts9.isJsxAttribute(node) || ts9.isJsxSpreadAttribute(node);\n}\nfunction isJsxAttributeValue(node) {\n  return ts9.isStringLiteral(node) || ts9.isJsxExpression(node) || ts9.isJsxElement(node) || ts9.isJsxSelfClosingElement(node) || ts9.isJsxFragment(node);\n}\nfunction isJsxChild(node) {\n  return ts9.isJsxText(node) || ts9.isJsxExpression(node) || ts9.isJsxElement(node) || ts9.isJsxSelfClosingElement(node) || ts9.isJsxFragment(node);\n}\nfunction isJsxTagNameExpression(node) {\n  return ts9.isIdentifier(node) || isThisExpression(node) || isJsxTagNamePropertyAccess(node);\n}\nfunction isLiteralToken(node) {\n  return ts9.isNumericLiteral(node) || ts9.isBigIntLiteral(node) || ts9.isStringLiteral(node) || ts9.isJsxText(node) || ts9.isRegularExpressionLiteral(node) || ts9.isNoSubstitutionTemplateLiteral(node);\n}\nfunction isModuleBody(node) {\n  return isNamespaceBody(node) || isJSDocNamespaceBody(node);\n}\nfunction isModuleName(node) {\n  return ts9.isIdentifier(node) || ts9.isStringLiteral(node);\n}\nfunction isModuleReference(node) {\n  return ts9.isEntityName(node) || ts9.isExternalModuleReference(node);\n}\nfunction isNamedImportBindings(node) {\n  return ts9.isNamespaceImport(node) || ts9.isNamedImports(node);\n}\nfunction isNamedImportsOrExports(node) {\n  return ts9.isNamedImports(node) || ts9.isNamedExports(node);\n}\nfunction isNamespaceBody(node) {\n  return ts9.isModuleBlock(node) || isNamespaceDeclaration(node);\n}\nfunction isObjectBindingOrAssignmentElement(node) {\n  return ts9.isBindingElement(node) || ts9.isPropertyAssignment(node) || ts9.isShorthandPropertyAssignment(node) || ts9.isSpreadAssignment(node);\n}\nfunction isObjectBindingOrAssignmentPattern(node) {\n  return ts9.isObjectBindingPattern(node) || ts9.isObjectLiteralExpression(node);\n}\nfunction isObjectTypeDeclaration(node) {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5\n    isClassLikeDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isTypeLiteralNode(node)\n  );\n}\nfunction isParameterPropertyModifier(node) {\n  return isAccessibilityModifier(node) || isReadonlyKeyword(node);\n}\nfunction isPropertyNameLiteral(node) {\n  return ts9.isIdentifier(node) || ts9.isStringLiteralLike(node) || ts9.isNumericLiteral(node);\n}\nfunction isPseudoLiteralToken(node) {\n  return ts9.isTemplateHead(node) || ts9.isTemplateMiddle(node) || ts9.isTemplateTail(node);\n}\nfunction isSignatureDeclaration(node) {\n  return ts9.isCallSignatureDeclaration(node) || ts9.isConstructSignatureDeclaration(node) || ts9.isMethodSignature(node) || ts9.isIndexSignatureDeclaration(node) || ts9.isFunctionTypeNode(node) || ts9.isConstructorTypeNode(node) || ts9.isJSDocFunctionType(node) || ts9.isFunctionDeclaration(node) || ts9.isMethodDeclaration(node) || ts9.isConstructorDeclaration(node) || // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5\n  isAccessorDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isArrowFunction(node);\n}\nfunction isSuperProperty(node) {\n  return isSuperPropertyAccessExpression(node) || isSuperElementAccessExpression(node);\n}\nfunction isTypeOnlyCompatibleAliasDeclaration(node) {\n  if (ts9.isImportClause(node) || ts9.isImportEqualsDeclaration(node) || ts9.isNamespaceImport(node) || ts9.isImportOrExportSpecifier(node)) {\n    return true;\n  }\n  if (isTsVersionAtLeast(5, 0) && (ts9.isExportDeclaration(node) || ts9.isNamespaceExport(node))) {\n    return true;\n  }\n  return false;\n}\nfunction isTypeReferenceType(node) {\n  return ts9.isTypeReferenceNode(node) || ts9.isExpressionWithTypeArguments(node);\n}\nfunction isUnionOrIntersectionTypeNode(node) {\n  return ts9.isUnionTypeNode(node) || ts9.isIntersectionTypeNode(node);\n}\nfunction isVariableLikeDeclaration(node) {\n  return ts9.isVariableDeclaration(node) || ts9.isParameter(node) || ts9.isBindingElement(node) || ts9.isPropertyDeclaration(node) || ts9.isPropertyAssignment(node) || ts9.isPropertySignature(node) || ts9.isJsxAttribute(node) || ts9.isShorthandPropertyAssignment(node) || ts9.isEnumMember(node) || ts9.isJSDocPropertyTag(node) || ts9.isJSDocParameterTag(node);\n}\n\n// src/nodes/typeGuards/compound.ts\nfunction isConstAssertionExpression(node) {\n  return ts9.isTypeReferenceNode(node.type) && ts9.isIdentifier(node.type.typeName) && node.type.typeName.escapedText === \"const\";\n}\nfunction isIterationStatement(node) {\n  switch (node.kind) {\n    case ts9.SyntaxKind.DoStatement:\n    case ts9.SyntaxKind.ForInStatement:\n    case ts9.SyntaxKind.ForOfStatement:\n    case ts9.SyntaxKind.ForStatement:\n    case ts9.SyntaxKind.WhileStatement:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isJSDocNamespaceDeclaration(node) {\n  return ts9.isModuleDeclaration(node) && ts9.isIdentifier(node.name) && (node.body === undefined || isJSDocNamespaceBody(node.body));\n}\nfunction isJsxTagNamePropertyAccess(node) {\n  return ts9.isPropertyAccessExpression(node) && // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts < 5\n  isJsxTagNameExpression(node.expression);\n}\nfunction isNamedDeclarationWithName(node) {\n  return \"name\" in node && node.name !== undefined && node.name !== null && isDeclarationName(node.name);\n}\nfunction isNamespaceDeclaration(node) {\n  return ts9.isModuleDeclaration(node) && ts9.isIdentifier(node.name) && node.body !== undefined && isNamespaceBody(node.body);\n}\nfunction isNumericOrStringLikeLiteral(node) {\n  switch (node.kind) {\n    case ts9.SyntaxKind.NoSubstitutionTemplateLiteral:\n    case ts9.SyntaxKind.NumericLiteral:\n    case ts9.SyntaxKind.StringLiteral:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isPropertyAccessEntityNameExpression(node) {\n  return ts9.isPropertyAccessExpression(node) && ts9.isIdentifier(node.name) && isEntityNameExpression(node.expression);\n}\nfunction isSuperElementAccessExpression(node) {\n  return ts9.isElementAccessExpression(node) && isSuperExpression(node.expression);\n}\nfunction isSuperPropertyAccessExpression(node) {\n  return ts9.isPropertyAccessExpression(node) && isSuperExpression(node.expression);\n}\nfunction isFunctionScopeBoundary(node) {\n  switch (node.kind) {\n    case ts9.SyntaxKind.ArrowFunction:\n    case ts9.SyntaxKind.CallSignature:\n    case ts9.SyntaxKind.ClassDeclaration:\n    case ts9.SyntaxKind.ClassExpression:\n    case ts9.SyntaxKind.Constructor:\n    case ts9.SyntaxKind.ConstructorType:\n    case ts9.SyntaxKind.ConstructSignature:\n    case ts9.SyntaxKind.EnumDeclaration:\n    case ts9.SyntaxKind.FunctionDeclaration:\n    case ts9.SyntaxKind.FunctionExpression:\n    case ts9.SyntaxKind.FunctionType:\n    case ts9.SyntaxKind.GetAccessor:\n    case ts9.SyntaxKind.MethodDeclaration:\n    case ts9.SyntaxKind.MethodSignature:\n    case ts9.SyntaxKind.ModuleDeclaration:\n    case ts9.SyntaxKind.SetAccessor:\n      return true;\n    case ts9.SyntaxKind.SourceFile:\n      return ts9.isExternalModule(node);\n    default:\n      return false;\n  }\n}\nfunction isIntrinsicAnyType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Any);\n}\nfunction isIntrinsicBigIntType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.BigInt);\n}\nfunction isIntrinsicBooleanType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Boolean);\n}\nfunction isIntrinsicErrorType(type) {\n  return isIntrinsicType(type) && type.intrinsicName === \"error\";\n}\nfunction isIntrinsicESSymbolType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.ESSymbol);\n}\nvar IntrinsicTypeFlags = ts9.TypeFlags.Intrinsic ?? ts9.TypeFlags.Any | ts9.TypeFlags.Unknown | ts9.TypeFlags.String | ts9.TypeFlags.Number | ts9.TypeFlags.BigInt | ts9.TypeFlags.Boolean | ts9.TypeFlags.BooleanLiteral | ts9.TypeFlags.ESSymbol | ts9.TypeFlags.Void | ts9.TypeFlags.Undefined | ts9.TypeFlags.Null | ts9.TypeFlags.Never | ts9.TypeFlags.NonPrimitive;\nfunction isIntrinsicNeverType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Never);\n}\nfunction isIntrinsicNonPrimitiveType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.NonPrimitive);\n}\nfunction isIntrinsicNullType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Null);\n}\nfunction isIntrinsicNumberType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Number);\n}\nfunction isIntrinsicStringType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.String);\n}\nfunction isIntrinsicType(type) {\n  return isTypeFlagSet(type, IntrinsicTypeFlags);\n}\nfunction isIntrinsicUndefinedType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Undefined);\n}\nfunction isIntrinsicUnknownType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Unknown);\n}\nfunction isIntrinsicVoidType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Void);\n}\nfunction isConditionalType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Conditional);\n}\nfunction isEnumType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Enum);\n}\nfunction isFreshableType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Freshable);\n}\nfunction isIndexedAccessType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.IndexedAccess);\n}\nfunction isIndexType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Index);\n}\nfunction isInstantiableType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Instantiable);\n}\nfunction isIntersectionType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Intersection);\n}\nfunction isObjectType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Object);\n}\nfunction isStringMappingType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.StringMapping);\n}\nfunction isSubstitutionType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Substitution);\n}\nfunction isTypeParameter(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.TypeParameter);\n}\nfunction isTypeVariable(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.TypeVariable);\n}\nfunction isUnionOrIntersectionType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.UnionOrIntersection);\n}\nfunction isUnionType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Union);\n}\nfunction isUniqueESSymbolType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.UniqueESSymbol);\n}\n\n// src/types/typeGuards/objects.ts\nfunction isEvolvingArrayType(type) {\n  return isObjectType(type) && isObjectFlagSet(type, ts9.ObjectFlags.EvolvingArray);\n}\nfunction isTupleType(type) {\n  return isObjectType(type) && isObjectFlagSet(type, ts9.ObjectFlags.Tuple);\n}\nfunction isTypeReference(type) {\n  return isObjectType(type) && isObjectFlagSet(type, ts9.ObjectFlags.Reference);\n}\n\n// src/types/typeGuards/compound.ts\nfunction isFreshableIntrinsicType(type) {\n  return isIntrinsicType(type) && isFreshableType(type);\n}\nfunction isTupleTypeReference(type) {\n  return isTypeReference(type) && isTupleType(type.target);\n}\nfunction isBigIntLiteralType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.BigIntLiteral);\n}\nfunction isBooleanLiteralType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.BooleanLiteral);\n}\nfunction isFalseLiteralType(type) {\n  return isBooleanLiteralType(type) && type.intrinsicName === \"false\";\n}\nfunction isLiteralType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.Literal);\n}\nfunction isNumberLiteralType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.NumberLiteral);\n}\nfunction isStringLiteralType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.StringLiteral);\n}\nfunction isTemplateLiteralType(type) {\n  return isTypeFlagSet(type, ts9.TypeFlags.TemplateLiteral);\n}\nfunction isTrueLiteralType(type) {\n  return isBooleanLiteralType(type) && type.intrinsicName === \"true\";\n}\n\n// src/types/getters.ts\nfunction getCallSignaturesOfType(type) {\n  if (isUnionType(type)) {\n    const signatures = [];\n    for (const subType of type.types) {\n      signatures.push(...getCallSignaturesOfType(subType));\n    }\n    return signatures;\n  }\n  if (isIntersectionType(type)) {\n    let signatures;\n    for (const subType of type.types) {\n      const sig = getCallSignaturesOfType(subType);\n      if (sig.length !== 0) {\n        if (signatures !== undefined) {\n          return [];\n        }\n        signatures = sig;\n      }\n    }\n    return signatures === undefined ? [] : signatures;\n  }\n  return type.getCallSignatures();\n}\nfunction getPropertyOfType(type, name) {\n  if (!name.startsWith(\"__\")) {\n    return type.getProperty(name);\n  }\n  return type.getProperties().find((s) => s.escapedName === name);\n}\nfunction getWellKnownSymbolPropertyOfType(type, wellKnownSymbolName, typeChecker) {\n  const prefix = \"__@\" + wellKnownSymbolName;\n  for (const prop of type.getProperties()) {\n    if (!prop.name.startsWith(prefix)) {\n      continue;\n    }\n    const declaration = prop.valueDeclaration ?? prop.getDeclarations()?.[0];\n    if (!declaration || !isNamedDeclarationWithName(declaration) || declaration.name === undefined || !ts9.isComputedPropertyName(declaration.name)) {\n      continue;\n    }\n    const globalSymbol = typeChecker.getApparentType(\n      typeChecker.getTypeAtLocation(declaration.name.expression)\n    ).symbol;\n    if (prop.escapedName === getPropertyNameOfWellKnownSymbol(\n      typeChecker,\n      globalSymbol,\n      wellKnownSymbolName\n    )) {\n      return prop;\n    }\n  }\n  return undefined;\n}\nfunction getPropertyNameOfWellKnownSymbol(typeChecker, symbolConstructor, symbolName) {\n  const knownSymbol = symbolConstructor && typeChecker.getTypeOfSymbolAtLocation(\n    symbolConstructor,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n    symbolConstructor.valueDeclaration\n  ).getProperty(symbolName);\n  const knownSymbolType = knownSymbol && typeChecker.getTypeOfSymbolAtLocation(\n    knownSymbol,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n    knownSymbol.valueDeclaration\n  );\n  if (knownSymbolType && isUniqueESSymbolType(knownSymbolType)) {\n    return knownSymbolType.escapedName;\n  }\n  return \"__@\" + symbolName;\n}\nfunction isBindableObjectDefinePropertyCall(node) {\n  return node.arguments.length === 3 && isEntityNameExpression(node.arguments[0]) && isNumericOrStringLikeLiteral(node.arguments[1]) && ts9.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === \"defineProperty\" && ts9.isIdentifier(node.expression.expression) && node.expression.expression.escapedText === \"Object\";\n}\nfunction isInConstContext(node, typeChecker) {\n  let current = node;\n  while (true) {\n    const parent = current.parent;\n    outer: switch (parent.kind) {\n      case ts9.SyntaxKind.ArrayLiteralExpression:\n      case ts9.SyntaxKind.ObjectLiteralExpression:\n      case ts9.SyntaxKind.ParenthesizedExpression:\n      case ts9.SyntaxKind.TemplateExpression:\n        current = parent;\n        break;\n      case ts9.SyntaxKind.AsExpression:\n      case ts9.SyntaxKind.TypeAssertionExpression:\n        return isConstAssertionExpression(parent);\n      case ts9.SyntaxKind.CallExpression: {\n        if (!ts9.isExpression(current)) {\n          return false;\n        }\n        const functionSignature = typeChecker.getResolvedSignature(\n          parent\n        );\n        if (functionSignature === undefined) {\n          return false;\n        }\n        const argumentIndex = parent.arguments.indexOf(\n          current\n        );\n        if (argumentIndex < 0) {\n          return false;\n        }\n        const parameterSymbol = functionSignature.getParameters()[argumentIndex];\n        if (parameterSymbol === undefined || !(\"links\" in parameterSymbol)) {\n          return false;\n        }\n        const parameterSymbolLinks = parameterSymbol.links;\n        const propertySymbol = parameterSymbolLinks.type?.getProperties()?.[argumentIndex];\n        if (propertySymbol === undefined || !(\"links\" in propertySymbol)) {\n          return false;\n        }\n        return isTransientSymbolLinksFlagSet(\n          propertySymbol.links,\n          ts9.CheckFlags.Readonly\n        );\n      }\n      case ts9.SyntaxKind.PrefixUnaryExpression:\n        if (current.kind !== ts9.SyntaxKind.NumericLiteral) {\n          return false;\n        }\n        switch (parent.operator) {\n          case ts9.SyntaxKind.MinusToken:\n          case ts9.SyntaxKind.PlusToken:\n            current = parent;\n            break outer;\n          default:\n            return false;\n        }\n      case ts9.SyntaxKind.PropertyAssignment:\n        if (parent.initializer !== current) {\n          return false;\n        }\n        current = parent.parent;\n        break;\n      case ts9.SyntaxKind.ShorthandPropertyAssignment:\n        current = parent.parent;\n        break;\n      default:\n        return false;\n    }\n  }\n}\n\n// src/types/utilities.ts\nfunction intersectionTypeParts(type) {\n  return isIntersectionType(type) ? type.types : [type];\n}\nfunction isFalsyType(type) {\n  if (isTypeFlagSet(\n    type,\n    ts9.TypeFlags.Undefined | ts9.TypeFlags.Null | ts9.TypeFlags.Void\n  )) {\n    return true;\n  }\n  if (typeIsLiteral(type)) {\n    if (typeof type.value === \"object\") {\n      return type.value.base10Value === \"0\";\n    } else {\n      return !type.value;\n    }\n  }\n  return isFalseLiteralType(type);\n}\nfunction isPropertyReadonlyInType(type, name, typeChecker) {\n  let seenProperty = false;\n  let seenReadonlySignature = false;\n  for (const subType of unionTypeParts(type)) {\n    if (getPropertyOfType(subType, name) === undefined) {\n      const index = (isNumericPropertyName(name) ? typeChecker.getIndexInfoOfType(subType, ts9.IndexKind.Number) : undefined) ?? typeChecker.getIndexInfoOfType(subType, ts9.IndexKind.String);\n      if (index?.isReadonly) {\n        if (seenProperty) {\n          return true;\n        }\n        seenReadonlySignature = true;\n      }\n    } else if (seenReadonlySignature || isReadonlyPropertyIntersection(subType, name, typeChecker)) {\n      return true;\n    } else {\n      seenProperty = true;\n    }\n  }\n  return false;\n}\nfunction isThenableType(typeChecker, node, type = typeChecker.getTypeAtLocation(node)) {\n  for (const typePart of unionTypeParts(typeChecker.getApparentType(type))) {\n    const then = typePart.getProperty(\"then\");\n    if (then === undefined) {\n      continue;\n    }\n    const thenType = typeChecker.getTypeOfSymbolAtLocation(then, node);\n    for (const subTypePart of unionTypeParts(thenType)) {\n      for (const signature of subTypePart.getCallSignatures()) {\n        if (signature.parameters.length !== 0 && isCallback(typeChecker, signature.parameters[0], node)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction symbolHasReadonlyDeclaration(symbol, typeChecker) {\n  return !!((symbol.flags & ts9.SymbolFlags.Accessor) === ts9.SymbolFlags.GetAccessor || symbol.declarations?.some(\n    (node) => isModifierFlagSet(node, ts9.ModifierFlags.Readonly) || ts9.isVariableDeclaration(node) && isNodeFlagSet(node.parent, ts9.NodeFlags.Const) || ts9.isCallExpression(node) && isReadonlyAssignmentDeclaration(node, typeChecker) || ts9.isEnumMember(node) || (ts9.isPropertyAssignment(node) || ts9.isShorthandPropertyAssignment(node)) && isInConstContext(node, typeChecker)\n  ));\n}\nfunction typeIsLiteral(type) {\n  if (isTsVersionAtLeast(5, 0)) {\n    return type.isLiteral();\n  } else {\n    return isTypeFlagSet(\n      type,\n      ts9.TypeFlags.StringLiteral | ts9.TypeFlags.NumberLiteral | ts9.TypeFlags.BigIntLiteral\n    );\n  }\n}\nfunction typeParts(type) {\n  return isIntersectionType(type) || isUnionType(type) ? type.types : [type];\n}\nfunction unionTypeParts(type) {\n  return isUnionType(type) ? type.types : [type];\n}\nfunction isCallback(typeChecker, param, node) {\n  let type = typeChecker.getApparentType(\n    typeChecker.getTypeOfSymbolAtLocation(param, node)\n  );\n  if (param.valueDeclaration.dotDotDotToken) {\n    type = type.getNumberIndexType();\n    if (type === undefined) {\n      return false;\n    }\n  }\n  for (const subType of unionTypeParts(type)) {\n    if (subType.getCallSignatures().length !== 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isReadonlyAssignmentDeclaration(node, typeChecker) {\n  if (!isBindableObjectDefinePropertyCall(node)) {\n    return false;\n  }\n  const descriptorType = typeChecker.getTypeAtLocation(node.arguments[2]);\n  if (descriptorType.getProperty(\"value\") === undefined) {\n    return descriptorType.getProperty(\"set\") === undefined;\n  }\n  const writableProp = descriptorType.getProperty(\"writable\");\n  if (writableProp === undefined) {\n    return false;\n  }\n  const writableType = writableProp.valueDeclaration !== undefined && ts9.isPropertyAssignment(writableProp.valueDeclaration) ? typeChecker.getTypeAtLocation(writableProp.valueDeclaration.initializer) : typeChecker.getTypeOfSymbolAtLocation(writableProp, node.arguments[2]);\n  return isFalseLiteralType(writableType);\n}\nfunction isReadonlyPropertyFromMappedType(type, name, typeChecker) {\n  if (!isObjectType(type) || !isObjectFlagSet(type, ts9.ObjectFlags.Mapped)) {\n    return;\n  }\n  const declaration = type.symbol.declarations[0];\n  if (declaration.readonlyToken !== undefined && !/^__@[^@]+$/.test(name)) {\n    return declaration.readonlyToken.kind !== ts9.SyntaxKind.MinusToken;\n  }\n  const { modifiersType } = type;\n  return modifiersType && isPropertyReadonlyInType(modifiersType, name, typeChecker);\n}\nfunction isReadonlyPropertyIntersection(type, name, typeChecker) {\n  const typeParts2 = isIntersectionType(type) ? type.types : [type];\n  return typeParts2.some((subType) => {\n    const prop = getPropertyOfType(subType, name);\n    if (prop === undefined) {\n      return false;\n    }\n    if (prop.flags & ts9.SymbolFlags.Transient) {\n      if (/^(?:[1-9]\\d*|0)$/.test(name) && isTupleTypeReference(subType)) {\n        return subType.target.readonly;\n      }\n      switch (isReadonlyPropertyFromMappedType(subType, name, typeChecker)) {\n        case false:\n          return false;\n        case true:\n          return true;\n      }\n    }\n    return !!// members of namespace import\n    (isSymbolFlagSet(prop, ts9.SymbolFlags.ValueModule) || // we unwrapped every mapped type, now we can check the actual declarations\n    symbolHasReadonlyDeclaration(prop, typeChecker));\n  });\n}\nfunction identifierToKeywordKind(node) {\n  return \"originalKeywordKind\" in node ? node.originalKeywordKind : ts9.identifierToKeywordKind(node);\n}\n\n// src/usage/declarations.ts\nvar DeclarationDomain = /* @__PURE__ */ ((DeclarationDomain2) => {\n  DeclarationDomain2[DeclarationDomain2[\"Namespace\"] = 1] = \"Namespace\";\n  DeclarationDomain2[DeclarationDomain2[\"Type\"] = 2] = \"Type\";\n  DeclarationDomain2[DeclarationDomain2[\"Value\"] = 4] = \"Value\";\n  DeclarationDomain2[DeclarationDomain2[\"Any\"] = 7] = \"Any\";\n  DeclarationDomain2[DeclarationDomain2[\"Import\"] = 8] = \"Import\";\n  return DeclarationDomain2;\n})(DeclarationDomain || {});\nfunction getDeclarationDomain(node) {\n  switch (node.parent.kind) {\n    case ts9.SyntaxKind.ClassDeclaration:\n    case ts9.SyntaxKind.ClassExpression:\n      return 2 /* Type */ | 4 /* Value */;\n    case ts9.SyntaxKind.EnumDeclaration:\n      return 7 /* Any */;\n    case ts9.SyntaxKind.FunctionDeclaration:\n    case ts9.SyntaxKind.FunctionExpression:\n      return 4 /* Value */;\n    case ts9.SyntaxKind.ImportClause:\n    case ts9.SyntaxKind.NamespaceImport:\n      return 7 /* Any */ | 8 /* Import */;\n    // TODO handle type-only imports\n    case ts9.SyntaxKind.ImportEqualsDeclaration:\n    case ts9.SyntaxKind.ImportSpecifier:\n      return node.parent.name === node ? 7 /* Any */ | 8 /* Import */ : undefined;\n    case ts9.SyntaxKind.InterfaceDeclaration:\n    case ts9.SyntaxKind.TypeAliasDeclaration:\n    case ts9.SyntaxKind.TypeParameter:\n      return 2 /* Type */;\n    case ts9.SyntaxKind.ModuleDeclaration:\n      return 1 /* Namespace */;\n    case ts9.SyntaxKind.Parameter:\n      if (node.parent.parent.kind === ts9.SyntaxKind.IndexSignature || identifierToKeywordKind(node) === ts9.SyntaxKind.ThisKeyword) {\n        return;\n      }\n    // falls through\n    case ts9.SyntaxKind.BindingElement:\n    case ts9.SyntaxKind.VariableDeclaration:\n      return node.parent.name === node ? 4 /* Value */ : undefined;\n  }\n}\nfunction getPropertyName(propertyName) {\n  if (propertyName.kind === ts9.SyntaxKind.ComputedPropertyName) {\n    const expression = unwrapParentheses(propertyName.expression);\n    if (ts9.isPrefixUnaryExpression(expression)) {\n      let negate = false;\n      switch (expression.operator) {\n        case ts9.SyntaxKind.MinusToken:\n          negate = true;\n        // falls through\n        case ts9.SyntaxKind.PlusToken:\n          return ts9.isNumericLiteral(expression.operand) ? `${negate ? \"-\" : \"\"}${expression.operand.text}` : ts9.isBigIntLiteral(expression.operand) ? `${negate ? \"-\" : \"\"}${expression.operand.text.slice(0, -1)}` : undefined;\n        default:\n          return;\n      }\n    }\n    if (ts9.isBigIntLiteral(expression)) {\n      return expression.text.slice(0, -1);\n    }\n    if (isNumericOrStringLikeLiteral(expression)) {\n      return expression.text;\n    }\n    return;\n  }\n  return propertyName.kind === ts9.SyntaxKind.PrivateIdentifier ? undefined : propertyName.text;\n}\nfunction unwrapParentheses(node) {\n  while (node.kind === ts9.SyntaxKind.ParenthesizedExpression) {\n    node = node.expression;\n  }\n  return node;\n}\nvar UsageDomain = /* @__PURE__ */ ((UsageDomain2) => {\n  UsageDomain2[UsageDomain2[\"Namespace\"] = 1] = \"Namespace\";\n  UsageDomain2[UsageDomain2[\"Type\"] = 2] = \"Type\";\n  UsageDomain2[UsageDomain2[\"Value\"] = 4] = \"Value\";\n  UsageDomain2[UsageDomain2[\"Any\"] = 7] = \"Any\";\n  UsageDomain2[UsageDomain2[\"TypeQuery\"] = 8] = \"TypeQuery\";\n  UsageDomain2[UsageDomain2[\"ValueOrNamespace\"] = 5] = \"ValueOrNamespace\";\n  return UsageDomain2;\n})(UsageDomain || {});\nfunction getUsageDomain(node) {\n  const parent = node.parent;\n  switch (parent.kind) {\n    // Value\n    case ts9.SyntaxKind.BindingElement:\n      if (parent.initializer === node) {\n        return 5 /* ValueOrNamespace */;\n      }\n      break;\n    case ts9.SyntaxKind.BreakStatement:\n    case ts9.SyntaxKind.ClassDeclaration:\n    case ts9.SyntaxKind.ClassExpression:\n    case ts9.SyntaxKind.ContinueStatement:\n    case ts9.SyntaxKind.EnumDeclaration:\n    case ts9.SyntaxKind.FunctionDeclaration:\n    case ts9.SyntaxKind.FunctionExpression:\n    case ts9.SyntaxKind.GetAccessor:\n    case ts9.SyntaxKind.ImportClause:\n    case ts9.SyntaxKind.ImportSpecifier:\n    case ts9.SyntaxKind.InterfaceDeclaration:\n    case ts9.SyntaxKind.JsxAttribute:\n    case ts9.SyntaxKind.LabeledStatement:\n    case ts9.SyntaxKind.MethodDeclaration:\n    case ts9.SyntaxKind.MethodSignature:\n    case ts9.SyntaxKind.ModuleDeclaration:\n    case ts9.SyntaxKind.NamedTupleMember:\n    case ts9.SyntaxKind.NamespaceExport:\n    case ts9.SyntaxKind.NamespaceExportDeclaration:\n    case ts9.SyntaxKind.NamespaceImport:\n    case ts9.SyntaxKind.PropertySignature:\n    case ts9.SyntaxKind.SetAccessor:\n    case ts9.SyntaxKind.TypeAliasDeclaration:\n    case ts9.SyntaxKind.TypeParameter:\n    case ts9.SyntaxKind.TypePredicate:\n      break;\n    case ts9.SyntaxKind.EnumMember:\n    case ts9.SyntaxKind.ImportEqualsDeclaration:\n    case ts9.SyntaxKind.Parameter:\n    case ts9.SyntaxKind.PropertyAccessExpression:\n    case ts9.SyntaxKind.PropertyAssignment:\n    case ts9.SyntaxKind.PropertyDeclaration:\n    case ts9.SyntaxKind.VariableDeclaration:\n      if (parent.name !== node) {\n        return 5 /* ValueOrNamespace */;\n      }\n      break;\n    case ts9.SyntaxKind.ExportAssignment:\n      return 7 /* Any */;\n    case ts9.SyntaxKind.ExportSpecifier:\n      if (parent.propertyName === undefined || parent.propertyName === node) {\n        return 7 /* Any */;\n      }\n      break;\n    case ts9.SyntaxKind.ExpressionWithTypeArguments:\n      return parent.parent.token === ts9.SyntaxKind.ImplementsKeyword || parent.parent.parent.kind === ts9.SyntaxKind.InterfaceDeclaration ? 2 /* Type */ : 4 /* Value */;\n    case ts9.SyntaxKind.QualifiedName:\n      if (parent.left === node) {\n        if (getEntityNameParent(parent).kind === ts9.SyntaxKind.TypeQuery) {\n          return 1 /* Namespace */ | 8 /* TypeQuery */;\n        }\n        return 1 /* Namespace */;\n      }\n      break;\n    case ts9.SyntaxKind.TypeQuery:\n      return 5 /* ValueOrNamespace */ | 8 /* TypeQuery */;\n    case ts9.SyntaxKind.TypeReference:\n      return identifierToKeywordKind(node) !== ts9.SyntaxKind.ConstKeyword ? 2 /* Type */ : undefined;\n    default:\n      return 5 /* ValueOrNamespace */;\n  }\n}\nfunction getEntityNameParent(name) {\n  let parent = name.parent;\n  while (parent.kind === ts9.SyntaxKind.QualifiedName) {\n    parent = parent.parent;\n  }\n  return parent;\n}\nfunction isBlockScopeBoundary(node) {\n  switch (node.kind) {\n    case ts9.SyntaxKind.Block: {\n      const parent = node.parent;\n      return parent.kind !== ts9.SyntaxKind.CatchClause && // blocks inside SourceFile are block scope boundaries\n      (parent.kind === ts9.SyntaxKind.SourceFile || // blocks that are direct children of a function scope boundary are no scope boundary\n      // for example the FunctionBlock is part of the function scope of the containing function\n      !isFunctionScopeBoundary(parent)) ? 2 /* Block */ : 0 /* None */;\n    }\n    case ts9.SyntaxKind.CaseBlock:\n    case ts9.SyntaxKind.CatchClause:\n    case ts9.SyntaxKind.ForInStatement:\n    case ts9.SyntaxKind.ForOfStatement:\n    case ts9.SyntaxKind.ForStatement:\n    case ts9.SyntaxKind.WithStatement:\n      return 2 /* Block */;\n    default:\n      return 0 /* None */;\n  }\n}\n\n// src/usage/scopes.ts\nvar AbstractScope = class {\n  constructor(global) {\n    this.global = global;\n  }\n  namespaceScopes = undefined;\n  uses = [];\n  variables = /* @__PURE__ */ new Map();\n  #enumScopes = undefined;\n  addUse(use) {\n    this.uses.push(use);\n  }\n  addVariable(identifier, name, selector, exported, domain) {\n    const variables = this.getDestinationScope(selector).getVariables();\n    const declaration = {\n      declaration: name,\n      domain,\n      exported\n    };\n    const variable = variables.get(identifier);\n    if (variable === undefined) {\n      variables.set(identifier, {\n        declarations: [declaration],\n        domain,\n        uses: []\n      });\n    } else {\n      variable.domain |= domain;\n      variable.declarations.push(declaration);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createOrReuseEnumScope(name, _exported) {\n    let scope;\n    if (this.#enumScopes === undefined) {\n      this.#enumScopes = /* @__PURE__ */ new Map();\n    } else {\n      scope = this.#enumScopes.get(name);\n    }\n    if (scope === undefined) {\n      scope = new EnumScope(this);\n      this.#enumScopes.set(name, scope);\n    }\n    return scope;\n  }\n  // only relevant for the root scope\n  createOrReuseNamespaceScope(name, _exported, ambient, hasExportStatement) {\n    let scope;\n    if (this.namespaceScopes === undefined) {\n      this.namespaceScopes = /* @__PURE__ */ new Map();\n    } else {\n      scope = this.namespaceScopes.get(name);\n    }\n    if (scope === undefined) {\n      scope = new NamespaceScope(ambient, hasExportStatement, this);\n      this.namespaceScopes.set(name, scope);\n    } else {\n      scope.refresh(ambient, hasExportStatement);\n    }\n    return scope;\n  }\n  end(cb) {\n    if (this.namespaceScopes !== undefined) {\n      this.namespaceScopes.forEach((value) => value.finish(cb));\n    }\n    this.namespaceScopes = this.#enumScopes = undefined;\n    this.applyUses();\n    this.variables.forEach((variable) => {\n      for (const declaration of variable.declarations) {\n        const result = {\n          declarations: [],\n          domain: declaration.domain,\n          exported: declaration.exported,\n          inGlobalScope: this.global,\n          uses: []\n        };\n        for (const other of variable.declarations) {\n          if (other.domain & declaration.domain) {\n            result.declarations.push(other.declaration);\n          }\n        }\n        for (const use of variable.uses) {\n          if (use.domain & declaration.domain) {\n            result.uses.push(use);\n          }\n        }\n        cb(result, declaration.declaration, this);\n      }\n    });\n  }\n  getFunctionScope() {\n    return this;\n  }\n  getVariables() {\n    return this.variables;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n  markExported(_name) {\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n  addUseToParent(_use) {\n  }\n  applyUse(use, variables = this.variables) {\n    const variable = variables.get(use.location.text);\n    if (variable === undefined || (variable.domain & use.domain) === 0) {\n      return false;\n    }\n    variable.uses.push(use);\n    return true;\n  }\n  applyUses() {\n    for (const use of this.uses) {\n      if (!this.applyUse(use)) {\n        this.addUseToParent(use);\n      }\n    }\n    this.uses = [];\n  }\n};\nvar NonRootScope = class extends AbstractScope {\n  constructor(parent, boundary) {\n    super(false);\n    this.parent = parent;\n    this.boundary = boundary;\n  }\n  getDestinationScope(selector) {\n    return this.boundary & selector ? this : this.parent.getDestinationScope(selector);\n  }\n  addUseToParent(use) {\n    return this.parent.addUse(use, this);\n  }\n};\nvar AbstractNamedExpressionScope = class extends NonRootScope {\n  #domain;\n  #name;\n  constructor(name, domain, parent) {\n    super(parent, 1 /* Function */);\n    this.#name = name;\n    this.#domain = domain;\n  }\n  addUse(use, source) {\n    if (source !== this.innerScope) {\n      return this.innerScope.addUse(use);\n    }\n    if (use.domain & this.#domain && use.location.text === this.#name.text) {\n      this.uses.push(use);\n    } else {\n      return this.parent.addUse(use, this);\n    }\n  }\n  end(cb) {\n    this.innerScope.end(cb);\n    return cb(\n      {\n        declarations: [this.#name],\n        domain: this.#domain,\n        exported: false,\n        inGlobalScope: false,\n        uses: this.uses\n      },\n      this.#name,\n      this\n    );\n  }\n  getDestinationScope() {\n    return this.innerScope;\n  }\n  getFunctionScope() {\n    return this.innerScope;\n  }\n};\nvar BlockScope = class extends NonRootScope {\n  #functionScope;\n  constructor(functionScope, parent) {\n    super(parent, 2 /* Block */);\n    this.#functionScope = functionScope;\n  }\n  getFunctionScope() {\n    return this.#functionScope;\n  }\n};\nvar ClassExpressionScope = class extends AbstractNamedExpressionScope {\n  innerScope = new NonRootScope(this, 1 /* Function */);\n  constructor(name, parent) {\n    super(name, 4 /* Value */ | 2 /* Type */, parent);\n  }\n};\nvar ConditionalTypeScope = class extends NonRootScope {\n  #state = 0 /* Initial */;\n  constructor(parent) {\n    super(parent, 8 /* ConditionalType */);\n  }\n  addUse(use) {\n    if (this.#state === 2 /* TrueType */) {\n      return void this.uses.push(use);\n    }\n    return this.parent.addUse(use, this);\n  }\n  updateState(newState) {\n    this.#state = newState;\n  }\n};\nvar EnumScope = class extends NonRootScope {\n  constructor(parent) {\n    super(parent, 1 /* Function */);\n  }\n  end() {\n    this.applyUses();\n  }\n};\nvar FunctionScope = class extends NonRootScope {\n  constructor(parent) {\n    super(parent, 1 /* Function */);\n  }\n  beginBody() {\n    this.applyUses();\n  }\n};\nvar FunctionExpressionScope = class extends AbstractNamedExpressionScope {\n  innerScope = new FunctionScope(this);\n  constructor(name, parent) {\n    super(name, 4 /* Value */, parent);\n  }\n  beginBody() {\n    return this.innerScope.beginBody();\n  }\n};\nvar NamespaceScope = class extends NonRootScope {\n  #ambient;\n  #exports = undefined;\n  #hasExport;\n  #innerScope = new NonRootScope(this, 1 /* Function */);\n  constructor(ambient, hasExport, parent) {\n    super(parent, 1 /* Function */);\n    this.#ambient = ambient;\n    this.#hasExport = hasExport;\n  }\n  addUse(use, source) {\n    if (source !== this.#innerScope) {\n      return this.#innerScope.addUse(use);\n    }\n    this.uses.push(use);\n  }\n  createOrReuseEnumScope(name, exported) {\n    if (!exported && (!this.#ambient || this.#hasExport)) {\n      return this.#innerScope.createOrReuseEnumScope(name, exported);\n    }\n    return super.createOrReuseEnumScope(name, exported);\n  }\n  createOrReuseNamespaceScope(name, exported, ambient, hasExportStatement) {\n    if (!exported && (!this.#ambient || this.#hasExport)) {\n      return this.#innerScope.createOrReuseNamespaceScope(\n        name,\n        exported,\n        ambient || this.#ambient,\n        hasExportStatement\n      );\n    }\n    return super.createOrReuseNamespaceScope(\n      name,\n      exported,\n      ambient || this.#ambient,\n      hasExportStatement\n    );\n  }\n  end(cb) {\n    this.#innerScope.end((variable, key, scope) => {\n      if (scope !== this.#innerScope || !variable.exported && (!this.#ambient || this.#exports !== undefined && !this.#exports.has(key.text))) {\n        return cb(variable, key, scope);\n      }\n      const namespaceVar = this.variables.get(key.text);\n      if (namespaceVar === undefined) {\n        this.variables.set(key.text, {\n          declarations: variable.declarations.map(mapDeclaration),\n          domain: variable.domain,\n          uses: [...variable.uses]\n        });\n      } else {\n        outer: for (const declaration of variable.declarations) {\n          for (const existing of namespaceVar.declarations) {\n            if (existing.declaration === declaration) {\n              continue outer;\n            }\n            namespaceVar.declarations.push(mapDeclaration(declaration));\n          }\n        }\n        namespaceVar.domain |= variable.domain;\n        for (const use of variable.uses) {\n          if (namespaceVar.uses.includes(use)) {\n            continue;\n          }\n          namespaceVar.uses.push(use);\n        }\n      }\n    });\n    this.applyUses();\n    this.#innerScope = new NonRootScope(this, 1 /* Function */);\n  }\n  finish(cb) {\n    return super.end(cb);\n  }\n  getDestinationScope() {\n    return this.#innerScope;\n  }\n  markExported(name) {\n    if (this.#exports === undefined) {\n      this.#exports = /* @__PURE__ */ new Set();\n    }\n    this.#exports.add(name.text);\n  }\n  refresh(ambient, hasExport) {\n    this.#ambient = ambient;\n    this.#hasExport = hasExport;\n  }\n};\nvar RootScope = class extends AbstractScope {\n  #exportAll;\n  #exports = undefined;\n  #innerScope = new NonRootScope(this, 1 /* Function */);\n  constructor(exportAll, global) {\n    super(global);\n    this.#exportAll = exportAll;\n  }\n  addUse(use, origin) {\n    if (origin === this.#innerScope) {\n      return super.addUse(use);\n    }\n    return this.#innerScope.addUse(use);\n  }\n  addVariable(identifier, name, selector, exported, domain) {\n    if (domain & 8 /* Import */) {\n      return super.addVariable(identifier, name, selector, exported, domain);\n    }\n    return this.#innerScope.addVariable(\n      identifier,\n      name,\n      selector,\n      exported,\n      domain\n    );\n  }\n  end(cb) {\n    this.#innerScope.end((value, key) => {\n      value.exported ||= this.#exportAll || this.#exports !== undefined && this.#exports.includes(key.text);\n      value.inGlobalScope = this.global;\n      return cb(value, key, this);\n    });\n    return super.end((value, key, scope) => {\n      value.exported ||= scope === this && this.#exports !== undefined && this.#exports.includes(key.text);\n      return cb(value, key, scope);\n    });\n  }\n  getDestinationScope() {\n    return this;\n  }\n  markExported(id) {\n    if (this.#exports === undefined) {\n      this.#exports = [id.text];\n    } else {\n      this.#exports.push(id.text);\n    }\n  }\n};\nfunction mapDeclaration(declaration) {\n  return {\n    declaration,\n    domain: getDeclarationDomain(declaration),\n    exported: true\n  };\n}\n\n// src/usage/UsageWalker.ts\nvar UsageWalker = class {\n  #result = /* @__PURE__ */ new Map();\n  #scope;\n  getUsage(sourceFile) {\n    const variableCallback = (variable, key) => {\n      this.#result.set(key, variable);\n    };\n    const isModule = ts9.isExternalModule(sourceFile);\n    this.#scope = new RootScope(\n      sourceFile.isDeclarationFile && isModule && !containsExportStatement(sourceFile),\n      !isModule\n    );\n    const cb = (node) => {\n      if (isBlockScopeBoundary(node)) {\n        return continueWithScope(\n          node,\n          new BlockScope(this.#scope.getFunctionScope(), this.#scope),\n          handleBlockScope\n        );\n      }\n      switch (node.kind) {\n        case ts9.SyntaxKind.ArrowFunction:\n        case ts9.SyntaxKind.CallSignature:\n        case ts9.SyntaxKind.Constructor:\n        case ts9.SyntaxKind.ConstructorType:\n        case ts9.SyntaxKind.ConstructSignature:\n        case ts9.SyntaxKind.FunctionDeclaration:\n        case ts9.SyntaxKind.FunctionExpression:\n        case ts9.SyntaxKind.FunctionType:\n        case ts9.SyntaxKind.GetAccessor:\n        case ts9.SyntaxKind.MethodDeclaration:\n        case ts9.SyntaxKind.MethodSignature:\n        case ts9.SyntaxKind.SetAccessor:\n          return this.#handleFunctionLikeDeclaration(\n            node,\n            cb,\n            variableCallback\n          );\n        case ts9.SyntaxKind.ClassDeclaration:\n          this.#handleDeclaration(\n            node,\n            true,\n            4 /* Value */ | 2 /* Type */\n          );\n          return continueWithScope(\n            node,\n            new NonRootScope(this.#scope, 1 /* Function */)\n          );\n        case ts9.SyntaxKind.ClassExpression:\n          return continueWithScope(\n            node,\n            node.name !== undefined ? new ClassExpressionScope(\n              node.name,\n              this.#scope\n            ) : new NonRootScope(this.#scope, 1 /* Function */)\n          );\n        case ts9.SyntaxKind.ConditionalType:\n          return this.#handleConditionalType(\n            node,\n            cb,\n            variableCallback\n          );\n        case ts9.SyntaxKind.EnumDeclaration:\n          this.#handleDeclaration(\n            node,\n            true,\n            7 /* Any */\n          );\n          return continueWithScope(\n            node,\n            this.#scope.createOrReuseEnumScope(\n              node.name.text,\n              includesModifier(\n                node.modifiers,\n                ts9.SyntaxKind.ExportKeyword\n              )\n            )\n          );\n        case ts9.SyntaxKind.EnumMember:\n          this.#scope.addVariable(\n            getPropertyName(node.name),\n            node.name,\n            1 /* Function */,\n            true,\n            4 /* Value */\n          );\n          break;\n        case ts9.SyntaxKind.ExportAssignment:\n          if (node.expression.kind === ts9.SyntaxKind.Identifier) {\n            return this.#scope.markExported(\n              node.expression\n            );\n          }\n          break;\n        case ts9.SyntaxKind.ExportSpecifier:\n          if (node.propertyName !== undefined) {\n            return this.#scope.markExported(\n              node.propertyName,\n              node.name\n            );\n          }\n          return this.#scope.markExported(node.name);\n        case ts9.SyntaxKind.Identifier: {\n          const domain = getUsageDomain(node);\n          if (domain !== undefined) {\n            this.#scope.addUse({ domain, location: node });\n          }\n          return;\n        }\n        case ts9.SyntaxKind.ImportClause:\n        case ts9.SyntaxKind.ImportEqualsDeclaration:\n        case ts9.SyntaxKind.ImportSpecifier:\n        case ts9.SyntaxKind.NamespaceImport:\n          this.#handleDeclaration(\n            node,\n            false,\n            7 /* Any */ | 8 /* Import */\n          );\n          break;\n        case ts9.SyntaxKind.InterfaceDeclaration:\n        case ts9.SyntaxKind.TypeAliasDeclaration:\n          this.#handleDeclaration(\n            node,\n            true,\n            2 /* Type */\n          );\n          return continueWithScope(\n            node,\n            new NonRootScope(this.#scope, 4 /* Type */)\n          );\n        case ts9.SyntaxKind.MappedType:\n          return continueWithScope(\n            node,\n            new NonRootScope(this.#scope, 4 /* Type */)\n          );\n        case ts9.SyntaxKind.ModuleDeclaration:\n          return this.#handleModule(\n            node,\n            continueWithScope\n          );\n        case ts9.SyntaxKind.Parameter:\n          if (node.parent.kind !== ts9.SyntaxKind.IndexSignature && (node.name.kind !== ts9.SyntaxKind.Identifier || identifierToKeywordKind(\n            node.name\n          ) !== ts9.SyntaxKind.ThisKeyword)) {\n            this.#handleBindingName(\n              node.name,\n              false,\n              false\n            );\n          }\n          break;\n        case ts9.SyntaxKind.TypeParameter:\n          this.#scope.addVariable(\n            node.name.text,\n            node.name,\n            node.parent.kind === ts9.SyntaxKind.InferType ? 8 /* InferType */ : 7 /* Type */,\n            false,\n            2 /* Type */\n          );\n          break;\n        // End of Scope specific handling\n        case ts9.SyntaxKind.VariableDeclarationList:\n          this.#handleVariableDeclaration(node);\n          break;\n      }\n      return ts9.forEachChild(node, cb);\n    };\n    const continueWithScope = (node, scope, next = forEachChild) => {\n      const savedScope = this.#scope;\n      this.#scope = scope;\n      next(node);\n      this.#scope.end(variableCallback);\n      this.#scope = savedScope;\n    };\n    const handleBlockScope = (node) => {\n      if (node.kind === ts9.SyntaxKind.CatchClause && node.variableDeclaration !== undefined) {\n        this.#handleBindingName(\n          node.variableDeclaration.name,\n          true,\n          false\n        );\n      }\n      return ts9.forEachChild(node, cb);\n    };\n    ts9.forEachChild(sourceFile, cb);\n    this.#scope.end(variableCallback);\n    return this.#result;\n    function forEachChild(node) {\n      return ts9.forEachChild(node, cb);\n    }\n  }\n  #handleBindingName(name, blockScoped, exported) {\n    if (name.kind === ts9.SyntaxKind.Identifier) {\n      return this.#scope.addVariable(\n        name.text,\n        name,\n        blockScoped ? 3 /* Block */ : 1 /* Function */,\n        exported,\n        4 /* Value */\n      );\n    }\n    forEachDestructuringIdentifier(name, (declaration) => {\n      this.#scope.addVariable(\n        declaration.name.text,\n        declaration.name,\n        blockScoped ? 3 /* Block */ : 1 /* Function */,\n        exported,\n        4 /* Value */\n      );\n    });\n  }\n  #handleConditionalType(node, cb, varCb) {\n    const savedScope = this.#scope;\n    const scope = this.#scope = new ConditionalTypeScope(savedScope);\n    cb(node.checkType);\n    scope.updateState(1 /* Extends */);\n    cb(node.extendsType);\n    scope.updateState(2 /* TrueType */);\n    cb(node.trueType);\n    scope.updateState(3 /* FalseType */);\n    cb(node.falseType);\n    scope.end(varCb);\n    this.#scope = savedScope;\n  }\n  #handleDeclaration(node, blockScoped, domain) {\n    if (node.name !== undefined) {\n      this.#scope.addVariable(\n        node.name.text,\n        node.name,\n        blockScoped ? 3 /* Block */ : 1 /* Function */,\n        includesModifier(\n          node.modifiers,\n          ts9.SyntaxKind.ExportKeyword\n        ),\n        domain\n      );\n    }\n  }\n  #handleFunctionLikeDeclaration(node, cb, varCb) {\n    if (ts9.canHaveDecorators(node)) {\n      ts9.getDecorators(node)?.forEach(cb);\n    }\n    const savedScope = this.#scope;\n    if (node.kind === ts9.SyntaxKind.FunctionDeclaration) {\n      this.#handleDeclaration(node, false, 4 /* Value */);\n    }\n    const scope = this.#scope = node.kind === ts9.SyntaxKind.FunctionExpression && node.name !== undefined ? new FunctionExpressionScope(node.name, savedScope) : new FunctionScope(savedScope);\n    if (node.name !== undefined) {\n      cb(node.name);\n    }\n    if (node.typeParameters !== undefined) {\n      node.typeParameters.forEach(cb);\n    }\n    node.parameters.forEach(cb);\n    if (node.type !== undefined) {\n      cb(node.type);\n    }\n    if (node.body !== undefined) {\n      scope.beginBody();\n      cb(node.body);\n    }\n    scope.end(varCb);\n    this.#scope = savedScope;\n  }\n  #handleModule(node, next) {\n    if (node.flags & ts9.NodeFlags.GlobalAugmentation) {\n      return next(\n        node,\n        this.#scope.createOrReuseNamespaceScope(\"-global\", false, true, false)\n      );\n    }\n    if (node.name.kind === ts9.SyntaxKind.Identifier) {\n      const exported = isNamespaceExported(node);\n      this.#scope.addVariable(\n        node.name.text,\n        node.name,\n        1 /* Function */,\n        exported,\n        1 /* Namespace */ | 4 /* Value */\n      );\n      const ambient = includesModifier(\n        node.modifiers,\n        ts9.SyntaxKind.DeclareKeyword\n      );\n      return next(\n        node,\n        this.#scope.createOrReuseNamespaceScope(\n          node.name.text,\n          exported,\n          ambient,\n          ambient && namespaceHasExportStatement(node)\n        )\n      );\n    }\n    return next(\n      node,\n      this.#scope.createOrReuseNamespaceScope(\n        `\"${node.name.text}\"`,\n        false,\n        true,\n        namespaceHasExportStatement(node)\n      )\n    );\n  }\n  #handleVariableDeclaration(declarationList) {\n    const blockScoped = isBlockScopedVariableDeclarationList(declarationList);\n    const exported = declarationList.parent.kind === ts9.SyntaxKind.VariableStatement && includesModifier(\n      declarationList.parent.modifiers,\n      ts9.SyntaxKind.ExportKeyword\n    );\n    for (const declaration of declarationList.declarations) {\n      this.#handleBindingName(declaration.name, blockScoped, exported);\n    }\n  }\n};\nfunction containsExportStatement(block) {\n  for (const statement of block.statements) {\n    if (statement.kind === ts9.SyntaxKind.ExportDeclaration || statement.kind === ts9.SyntaxKind.ExportAssignment) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction forEachDestructuringIdentifier(pattern, fn) {\n  for (const element of pattern.elements) {\n    if (element.kind !== ts9.SyntaxKind.BindingElement) {\n      continue;\n    }\n    let result;\n    if (element.name.kind === ts9.SyntaxKind.Identifier) {\n      result = fn(element);\n    } else {\n      result = forEachDestructuringIdentifier(element.name, fn);\n    }\n    if (result) {\n      return result;\n    }\n  }\n}\nfunction isBlockScopedVariableDeclarationList(declarationList) {\n  return (declarationList.flags & ts9.NodeFlags.BlockScoped) !== 0;\n}\nfunction isNamespaceExported(node) {\n  return node.parent.kind === ts9.SyntaxKind.ModuleDeclaration || includesModifier(node.modifiers, ts9.SyntaxKind.ExportKeyword);\n}\nfunction namespaceHasExportStatement(ns) {\n  if (ns.body === undefined || ns.body.kind !== ts9.SyntaxKind.ModuleBlock) {\n    return false;\n  }\n  return containsExportStatement(ns.body);\n}\n\n// src/usage/collectVariableUsage.ts\nfunction collectVariableUsage(sourceFile) {\n  return new UsageWalker().getUsage(sourceFile);\n}\n\nexport { AccessKind, DeclarationDomain, UsageDomain, collectVariableUsage, forEachComment, forEachToken, getAccessKind, getCallSignaturesOfType, getPropertyOfType, getWellKnownSymbolPropertyOfType, hasDecorators, hasExpressionInitializer, hasInitializer, hasJSDoc, hasModifiers, hasType, hasTypeArguments, includesModifier, intersectionTypeParts, isAbstractKeyword, isAccessExpression, isAccessibilityModifier, isAccessorDeclaration, isAccessorKeyword, isAnyKeyword, isArrayBindingElement, isArrayBindingOrAssignmentPattern, isAssertKeyword, isAssertsKeyword, isAssignmentKind, isAssignmentPattern, isAsyncKeyword, isAwaitKeyword, isBigIntKeyword, isBigIntLiteralType, isBindingOrAssignmentElementRestIndicator, isBindingOrAssignmentElementTarget, isBindingOrAssignmentPattern, isBindingPattern, isBlockLike, isBooleanKeyword, isBooleanLiteral, isBooleanLiteralType, isClassLikeDeclaration, isClassMemberModifier, isColonToken, isCompilerOptionEnabled, isConditionalType, isConstAssertionExpression, isConstKeyword, isDeclarationName, isDeclarationWithTypeParameterChildren, isDeclarationWithTypeParameters, isDeclareKeyword, isDefaultKeyword, isDestructuringPattern, isDotToken, isEndOfFileToken, isEntityNameExpression, isEntityNameOrEntityNameExpression, isEnumType, isEqualsGreaterThanToken, isEqualsToken, isEvolvingArrayType, isExclamationToken, isExportKeyword, isFalseKeyword, isFalseLiteral, isFalseLiteralType, isFalsyType, isForInOrOfStatement, isFreshableIntrinsicType, isFreshableType, isFunctionLikeDeclaration, isFunctionScopeBoundary, isImportExpression, isImportKeyword, isInKeyword, isIndexType, isIndexedAccessType, isInstantiableType, isIntersectionType, isIntrinsicAnyType, isIntrinsicBigIntType, isIntrinsicBooleanType, isIntrinsicESSymbolType, isIntrinsicErrorType, isIntrinsicNeverType, isIntrinsicNonPrimitiveType, isIntrinsicNullType, isIntrinsicNumberType, isIntrinsicStringType, isIntrinsicType, isIntrinsicUndefinedType, isIntrinsicUnknownType, isIntrinsicVoidType, isIterationStatement, isJSDocComment, isJSDocNamespaceBody, isJSDocNamespaceDeclaration, isJSDocText, isJSDocTypeReferencingNode, isJsonMinusNumericLiteral, isJsonObjectExpression, isJsxAttributeLike, isJsxAttributeValue, isJsxChild, isJsxTagNameExpression, isJsxTagNamePropertyAccess, isLiteralToken, isLiteralType, isModifierFlagSet, isModuleBody, isModuleName, isModuleReference, isNamedDeclarationWithName, isNamedImportBindings, isNamedImportsOrExports, isNamespaceBody, isNamespaceDeclaration, isNeverKeyword, isNodeFlagSet, isNullKeyword, isNullLiteral, isNumberKeyword, isNumberLiteralType, isNumericOrStringLikeLiteral, isNumericPropertyName, isObjectBindingOrAssignmentElement, isObjectBindingOrAssignmentPattern, isObjectFlagSet, isObjectKeyword, isObjectType, isObjectTypeDeclaration, isOutKeyword, isOverrideKeyword, isParameterPropertyModifier, isPrivateKeyword, isPropertyAccessEntityNameExpression, isPropertyNameLiteral, isPropertyReadonlyInType, isProtectedKeyword, isPseudoLiteralToken, isPublicKeyword, isQuestionDotToken, isQuestionToken, isReadonlyKeyword, isSignatureDeclaration, isStaticKeyword, isStrictCompilerOptionEnabled, isStringKeyword, isStringLiteralType, isStringMappingType, isSubstitutionType, isSuperElementAccessExpression, isSuperExpression, isSuperKeyword, isSuperProperty, isSuperPropertyAccessExpression, isSymbolFlagSet, isSymbolKeyword, isSyntaxList, isTemplateLiteralType, isThenableType, isThisExpression, isThisKeyword, isTransientSymbolLinksFlagSet, isTrueKeyword, isTrueLiteral, isTrueLiteralType, isTupleType, isTupleTypeReference, isTypeFlagSet, isTypeOnlyCompatibleAliasDeclaration, isTypeParameter, isTypeReference, isTypeReferenceType, isTypeVariable, isUndefinedKeyword, isUnionOrIntersectionType, isUnionOrIntersectionTypeNode, isUnionType, isUniqueESSymbolType, isUnknownKeyword, isValidPropertyAccess, isVariableLikeDeclaration, isVoidKeyword, symbolHasReadonlyDeclaration, typeIsLiteral, typeParts, unionTypeParts };\n"
        }
    ]
}