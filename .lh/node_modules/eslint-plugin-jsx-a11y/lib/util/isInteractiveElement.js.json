{
    "sourceFile": "node_modules/eslint-plugin-jsx-a11y/lib/util/isInteractiveElement.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892262796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _ariaQuery = require(\"aria-query\");\nvar _axobjectQuery = require(\"axobject-query\");\nvar _arrayIncludes = _interopRequireDefault(require(\"array-includes\"));\nvar _arrayPrototype = _interopRequireDefault(require(\"array.prototype.flatmap\"));\nvar _attributesComparator = _interopRequireDefault(require(\"./attributesComparator\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar roleKeys = _ariaQuery.roles.keys();\nvar elementRoleEntries = _toConsumableArray(_ariaQuery.elementRoles);\nvar nonInteractiveRoles = new Set(roleKeys.filter(function (name) {\n  var role = _ariaQuery.roles.get(name);\n  return !role[\"abstract\"]\n  // 'toolbar' does not descend from widget, but it does support\n  // aria-activedescendant, thus in practice we treat it as a widget.\n  && name !== 'toolbar' && !role.superClass.some(function (classes) {\n    return (0, _arrayIncludes[\"default\"])(classes, 'widget');\n  });\n}).concat(\n// The `progressbar` is descended from `widget`, but in practice, its\n// value is always `readonly`, so we treat it as a non-interactive role.\n'progressbar'));\nvar interactiveRoles = new Set(roleKeys.filter(function (name) {\n  var role = _ariaQuery.roles.get(name);\n  return !role[\"abstract\"]\n  // The `progressbar` is descended from `widget`, but in practice, its\n  // value is always `readonly`, so we treat it as a non-interactive role.\n  && name !== 'progressbar' && role.superClass.some(function (classes) {\n    return (0, _arrayIncludes[\"default\"])(classes, 'widget');\n  });\n}).concat(\n// 'toolbar' does not descend from widget, but it does support\n// aria-activedescendant, thus in practice we treat it as a widget.\n'toolbar'));\nvar interactiveElementRoleSchemas = (0, _arrayPrototype[\"default\"])(elementRoleEntries, function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    elementSchema = _ref2[0],\n    rolesArr = _ref2[1];\n  return rolesArr.some(function (role) {\n    return interactiveRoles.has(role);\n  }) ? [elementSchema] : [];\n});\nvar nonInteractiveElementRoleSchemas = (0, _arrayPrototype[\"default\"])(elementRoleEntries, function (_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n    elementSchema = _ref4[0],\n    rolesArr = _ref4[1];\n  return rolesArr.every(function (role) {\n    return nonInteractiveRoles.has(role);\n  }) ? [elementSchema] : [];\n});\nvar interactiveAXObjects = new Set(_axobjectQuery.AXObjects.keys().filter(function (name) {\n  return _axobjectQuery.AXObjects.get(name).type === 'widget';\n}));\nvar interactiveElementAXObjectSchemas = (0, _arrayPrototype[\"default\"])(_toConsumableArray(_axobjectQuery.elementAXObjects), function (_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n    elementSchema = _ref6[0],\n    AXObjectsArr = _ref6[1];\n  return AXObjectsArr.every(function (role) {\n    return interactiveAXObjects.has(role);\n  }) ? [elementSchema] : [];\n});\nfunction checkIsInteractiveElement(tagName, attributes) {\n  function elementSchemaMatcher(elementSchema) {\n    return tagName === elementSchema.name && (0, _attributesComparator[\"default\"])(elementSchema.attributes, attributes);\n  }\n\n  // Check in elementRoles for inherent interactive role associations for\n  // this element.\n  var isInherentInteractiveElement = interactiveElementRoleSchemas.some(elementSchemaMatcher);\n  if (isInherentInteractiveElement) {\n    return true;\n  }\n  // Check in elementRoles for inherent non-interactive role associations for\n  // this element.\n  var isInherentNonInteractiveElement = nonInteractiveElementRoleSchemas.some(elementSchemaMatcher);\n  if (isInherentNonInteractiveElement) {\n    return false;\n  }\n  // Check in elementAXObjects for AX Tree associations for this element.\n  var isInteractiveAXElement = interactiveElementAXObjectSchemas.some(elementSchemaMatcher);\n  if (isInteractiveAXElement) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns boolean indicating whether the given element is\n * interactive on the DOM or not. Usually used when an element\n * has a dynamic handler on it and we need to discern whether or not\n * it's intention is to be interacted with on the DOM.\n */\nvar isInteractiveElement = function isInteractiveElement(tagName, attributes) {\n  // Do not test higher level JSX components, as we do not know what\n  // low-level DOM element this maps to.\n  if (!_ariaQuery.dom.has(tagName)) {\n    return false;\n  }\n  return checkIsInteractiveElement(tagName, attributes);\n};\nvar _default = exports[\"default\"] = isInteractiveElement;\nmodule.exports = exports.default;"
        }
    ]
}