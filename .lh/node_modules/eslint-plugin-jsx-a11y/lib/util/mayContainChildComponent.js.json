{
    "sourceFile": "node_modules/eslint-plugin-jsx-a11y/lib/util/mayContainChildComponent.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892263013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = mayContainChildComponent;\nvar _jsxAstUtils = require(\"jsx-ast-utils\");\nvar _minimatch = _interopRequireDefault(require(\"minimatch\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\n/**\n * Returns true if it can positively determine that the element lacks an\n * accessible label. If no determination is possible, it returns false. Treat\n * false as an unknown value. The element might still have an accessible label,\n * but this module cannot determine it positively.\n *\n * \n */\n\nfunction mayContainChildComponent(root, componentName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var elementType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _jsxAstUtils.elementType;\n  function traverseChildren(node, depth) {\n    // Bail when maxDepth is exceeded.\n    if (depth > maxDepth) {\n      return false;\n    }\n    if (node.children) {\n      /* $FlowFixMe */\n      for (var i = 0; i < node.children.length; i += 1) {\n        /* $FlowFixMe */\n        var childNode = node.children[i];\n        // Assume an expression container renders a label. It is the best we can\n        // do in this case.\n        if (childNode.type === 'JSXExpressionContainer') {\n          return true;\n        }\n        // Check for components with the provided name.\n        if (childNode.type === 'JSXElement' && childNode.openingElement && (0, _minimatch[\"default\"])(elementType(childNode.openingElement), componentName)) {\n          return true;\n        }\n        if (traverseChildren(childNode, depth + 1)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  return traverseChildren(root, 1);\n}\nmodule.exports = exports.default;"
        }
    ]
}