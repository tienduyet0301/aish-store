{
    "sourceFile": "node_modules/eslint-plugin-jsx-a11y/lib/rules/prefer-tag-over-role.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892260977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _ariaQuery = require(\"aria-query\");\nvar _jsxAstUtils = require(\"jsx-ast-utils\");\nvar _getElementType = _interopRequireDefault(require(\"../util/getElementType\"));\nvar _schemas = require(\"../util/schemas\");\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { \"default\": e }; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar errorMessage = 'Use {{tag}} instead of the \"{{role}}\" role to ensure accessibility across all devices.';\nvar schema = (0, _schemas.generateObjSchema)();\nvar formatTag = function formatTag(tag) {\n  if (!tag.attributes) {\n    return \"<\".concat(tag.name, \">\");\n  }\n  var _tag$attributes = _slicedToArray(tag.attributes, 1),\n    attribute = _tag$attributes[0];\n  var value = attribute.value ? \"\\\"\".concat(attribute.value, \"\\\"\") : '...';\n  return \"<\".concat(tag.name, \" \").concat(attribute.name, \"=\").concat(value, \">\");\n};\nvar getLastPropValue = function getLastPropValue(rawProp) {\n  var propValue = (0, _jsxAstUtils.getPropValue)(rawProp);\n  if (!propValue) {\n    return propValue;\n  }\n  var lastSpaceIndex = propValue.lastIndexOf(' ');\n  return lastSpaceIndex === -1 ? propValue : propValue.substring(lastSpaceIndex + 1);\n};\nvar _default = exports[\"default\"] = {\n  meta: {\n    docs: {\n      description: 'Enforces using semantic DOM elements over the ARIA `role` property.',\n      url: 'https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/tree/HEAD/docs/rules/prefer-tag-over-role.md'\n    },\n    schema: [schema]\n  },\n  create: function create(context) {\n    var elementType = (0, _getElementType[\"default\"])(context);\n    return {\n      JSXOpeningElement: function JSXOpeningElement(node) {\n        var role = getLastPropValue((0, _jsxAstUtils.getProp)(node.attributes, 'role'));\n        if (!role) {\n          return;\n        }\n        var matchedTagsSet = _ariaQuery.roleElements.get(role);\n        if (!matchedTagsSet) {\n          return;\n        }\n        var matchedTags = Array.from(matchedTagsSet);\n        if (matchedTags.some(function (matchedTag) {\n          return matchedTag.name === elementType(node);\n        })) {\n          return;\n        }\n        context.report({\n          data: {\n            tag: matchedTags.length === 1 ? formatTag(matchedTags[0]) : [matchedTags.slice(0, matchedTags.length - 1).map(formatTag).join(', '), formatTag(matchedTags[matchedTags.length - 1])].join(', or '),\n            role\n          },\n          node,\n          message: errorMessage\n        });\n      }\n    };\n  }\n};\nmodule.exports = exports.default;"
        }
    ]
}