{
    "sourceFile": "node_modules/eslint-plugin-jsx-a11y/__mocks__/genInteractives.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892263284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @flow\n */\n\nimport { dom, roles } from 'aria-query';\nimport includes from 'array-includes';\nimport fromEntries from 'object.fromentries';\n\nimport JSXAttributeMock from './JSXAttributeMock';\nimport JSXElementMock from './JSXElementMock';\n\nimport type { JSXAttributeMockType } from './JSXAttributeMock';\nimport type { JSXElementMockType } from './JSXElementMock';\n\nconst domElements = dom.keys();\nconst roleNames = roles.keys();\n\nconst interactiveElementsMap = {\n  a: [{ prop: 'href', value: '#' }],\n  area: [{ prop: 'href', value: '#' }],\n  audio: [],\n  button: [],\n  canvas: [],\n  datalist: [],\n  embed: [],\n  input: [],\n  'input[type=\"button\"]': [{ prop: 'type', value: 'button' }],\n  'input[type=\"checkbox\"]': [{ prop: 'type', value: 'checkbox' }],\n  'input[type=\"color\"]': [{ prop: 'type', value: 'color' }],\n  'input[type=\"date\"]': [{ prop: 'type', value: 'date' }],\n  'input[type=\"datetime\"]': [{ prop: 'type', value: 'datetime' }],\n  'input[type=\"email\"]': [{ prop: 'type', value: 'email' }],\n  'input[type=\"file\"]': [{ prop: 'type', value: 'file' }],\n  'input[type=\"image\"]': [{ prop: 'type', value: 'image' }],\n  'input[type=\"month\"]': [{ prop: 'type', value: 'month' }],\n  'input[type=\"number\"]': [{ prop: 'type', value: 'number' }],\n  'input[type=\"password\"]': [{ prop: 'type', value: 'password' }],\n  'input[type=\"radio\"]': [{ prop: 'type', value: 'radio' }],\n  'input[type=\"range\"]': [{ prop: 'type', value: 'range' }],\n  'input[type=\"reset\"]': [{ prop: 'type', value: 'reset' }],\n  'input[type=\"search\"]': [{ prop: 'type', value: 'search' }],\n  'input[type=\"submit\"]': [{ prop: 'type', value: 'submit' }],\n  'input[type=\"tel\"]': [{ prop: 'type', value: 'tel' }],\n  'input[type=\"text\"]': [{ prop: 'type', value: 'text' }],\n  'input[type=\"time\"]': [{ prop: 'type', value: 'time' }],\n  'input[type=\"url\"]': [{ prop: 'type', value: 'url' }],\n  'input[type=\"week\"]': [{ prop: 'type', value: 'week' }],\n  menuitem: [],\n  option: [],\n  select: [],\n  summary: [],\n  // Whereas ARIA makes a distinction between cell and gridcell, the AXObject\n  // treats them both as CellRole and since gridcell is interactive, we consider\n  // cell interactive as well.\n  td: [],\n  th: [],\n  tr: [],\n  textarea: [],\n  video: [],\n};\n\nconst nonInteractiveElementsMap: {[string]: Array<{[string]: string}>} = {\n  abbr: [],\n  address: [],\n  article: [],\n  aside: [],\n  blockquote: [],\n  br: [],\n  caption: [],\n  code: [],\n  dd: [],\n  del: [],\n  details: [],\n  dfn: [],\n  dialog: [],\n  dir: [],\n  dl: [],\n  dt: [],\n  em: [],\n  fieldset: [],\n  figcaption: [],\n  figure: [],\n  footer: [],\n  form: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  hr: [],\n  html: [],\n  iframe: [],\n  img: [],\n  ins: [],\n  label: [],\n  legend: [],\n  li: [],\n  main: [],\n  mark: [],\n  marquee: [],\n  menu: [],\n  meter: [],\n  nav: [],\n  ol: [],\n  optgroup: [],\n  output: [],\n  p: [],\n  pre: [],\n  progress: [],\n  ruby: [],\n  'section[aria-label]': [{ prop: 'aria-label' }],\n  'section[aria-labelledby]': [{ prop: 'aria-labelledby' }],\n  strong: [],\n  sub: [],\n  sup: [],\n  table: [],\n  tbody: [],\n  tfoot: [],\n  thead: [],\n  time: [],\n  ul: [],\n};\n\nconst indeterminantInteractiveElementsMap: { [key: string]: Array<any> } = fromEntries(domElements.map((name) => [name, []]));\n\nObject.keys(interactiveElementsMap)\n  .concat(Object.keys(nonInteractiveElementsMap))\n  .forEach((name) => delete indeterminantInteractiveElementsMap[name]);\n\nconst abstractRoles = roleNames.filter((role) => roles.get(role).abstract);\n\nconst nonAbstractRoles = roleNames.filter((role) => !roles.get(role).abstract);\n\nconst interactiveRoles = []\n  .concat(\n    roleNames,\n    // 'toolbar' does not descend from widget, but it does support\n    // aria-activedescendant, thus in practice we treat it as a widget.\n    'toolbar',\n  )\n  .filter((role) => (\n    !roles.get(role).abstract\n    && roles.get(role).superClass.some((klasses) => includes(klasses, 'widget'))\n  ));\n\nconst nonInteractiveRoles = roleNames\n  .filter((role) => (\n    !roles.get(role).abstract\n    && !roles.get(role).superClass.some((klasses) => includes(klasses, 'widget'))\n\n    // 'toolbar' does not descend from widget, but it does support\n    // aria-activedescendant, thus in practice we treat it as a widget.\n    && !includes(['toolbar'], role)\n  ));\n\nexport function genElementSymbol(openingElement: Object): string {\n  return (\n    openingElement.name.name + (openingElement.attributes.length > 0\n      ? `${openingElement.attributes.map((attr) => `[${attr.name.name}=\"${attr.value.value}\"]`).join('')}`\n      : ''\n    )\n  );\n}\n\nexport function genInteractiveElements(): Array<JSXElementMockType> {\n  return Object.keys(interactiveElementsMap).map((elementSymbol: string): JSXElementMockType => {\n    const bracketIndex = elementSymbol.indexOf('[');\n    let name = elementSymbol;\n    if (bracketIndex > -1) {\n      name = elementSymbol.slice(0, bracketIndex);\n    }\n    const attributes = interactiveElementsMap[elementSymbol].map(({ prop, value }) => JSXAttributeMock(prop, value));\n    return JSXElementMock(name, attributes);\n  });\n}\n\nexport function genInteractiveRoleElements(): Array<JSXElementMockType> {\n  return interactiveRoles.concat('button article', 'fakerole button article').map((value): JSXElementMockType => JSXElementMock(\n    'div',\n    [JSXAttributeMock('role', value)],\n  ));\n}\n\nexport function genNonInteractiveElements(): Array<JSXElementMockType> {\n  return Object.keys(nonInteractiveElementsMap).map((elementSymbol): JSXElementMockType => {\n    const bracketIndex = elementSymbol.indexOf('[');\n    let name = elementSymbol;\n    if (bracketIndex > -1) {\n      name = elementSymbol.slice(0, bracketIndex);\n    }\n    const attributes = nonInteractiveElementsMap[elementSymbol].map(({ prop, value }) => JSXAttributeMock(prop, value));\n    return JSXElementMock(name, attributes);\n  });\n}\n\nexport function genNonInteractiveRoleElements(): Array<JSXElementMockType> {\n  return [\n    ...nonInteractiveRoles,\n    'article button',\n    'fakerole article button',\n  ].map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));\n}\n\nexport function genAbstractRoleElements(): Array<JSXElementMockType> {\n  return abstractRoles.map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));\n}\n\nexport function genNonAbstractRoleElements(): Array<JSXElementMockType> {\n  return nonAbstractRoles.map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));\n}\n\nexport function genIndeterminantInteractiveElements(): Array<JSXElementMockType> {\n  return Object.keys(indeterminantInteractiveElementsMap).map((name) => {\n    const attributes = indeterminantInteractiveElementsMap[name].map(({ prop, value }): JSXAttributeMockType => JSXAttributeMock(prop, value));\n    return JSXElementMock(name, attributes);\n  });\n}\n"
        }
    ]
}