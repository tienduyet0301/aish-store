{
    "sourceFile": "node_modules/jsx-ast-utils/lib/getProp.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892377158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = getProp;\n\nvar _propName = require('./propName');\n\nvar _propName2 = _interopRequireDefault(_propName);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nvar DEFAULT_OPTIONS = {\n  ignoreCase: true\n};\n\n/**\n * Returns the JSXAttribute itself or undefined, indicating the prop\n * is not present on the JSXOpeningElement.\n *\n */\nfunction getProp() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n  function getName(name) {\n    return options.ignoreCase ? name.toUpperCase() : name;\n  }\n  var propToFind = getName(prop);\n  function isPropToFind(property) {\n    return property.type === 'Property' && property.key.type === 'Identifier' && propToFind === getName(property.key.name);\n  }\n\n  var foundAttribute = props.find(function (attribute) {\n    // If the props contain a spread prop, try to find the property in the object expression.\n    if (attribute.type === 'JSXSpreadAttribute') {\n      return attribute.argument.type === 'ObjectExpression' && propToFind !== getName('key') // https://github.com/reactjs/rfcs/pull/107\n      && attribute.argument.properties.some(isPropToFind);\n    }\n\n    return propToFind === getName((0, _propName2.default)(attribute));\n  });\n\n  if (foundAttribute && foundAttribute.type === 'JSXSpreadAttribute') {\n    return propertyToJSXAttribute(foundAttribute.argument.properties.find(isPropToFind));\n  }\n\n  return foundAttribute;\n}\n\nfunction propertyToJSXAttribute(node) {\n  var key = node.key,\n      value = node.value;\n\n  return _extends({\n    type: 'JSXAttribute',\n    name: _extends({ type: 'JSXIdentifier', name: key.name }, getBaseProps(key)),\n    value: value.type === 'Literal' ? adjustRangeOfNode(value) : _extends({ type: 'JSXExpressionContainer', expression: adjustExpressionRange(value) }, getBaseProps(value))\n  }, getBaseProps(node));\n}\n\nfunction adjustRangeOfNode(node) {\n  var _ref = node.range || [node.start, node.end],\n      _ref2 = _slicedToArray(_ref, 2),\n      start = _ref2[0],\n      end = _ref2[1];\n\n  return _extends({}, node, {\n    end: undefined,\n    range: [start, end],\n    start: undefined\n  });\n}\n\nfunction adjustExpressionRange(_ref3) {\n  var expressions = _ref3.expressions,\n      quasis = _ref3.quasis,\n      expression = _objectWithoutProperties(_ref3, ['expressions', 'quasis']);\n\n  return _extends({}, adjustRangeOfNode(expression), expressions ? { expressions: expressions.map(adjustRangeOfNode) } : {}, quasis ? { quasis: quasis.map(adjustRangeOfNode) } : {});\n}\n\nfunction getBaseProps(_ref4) {\n  var loc = _ref4.loc,\n      node = _objectWithoutProperties(_ref4, ['loc']);\n\n  var _adjustRangeOfNode = adjustRangeOfNode(node),\n      range = _adjustRangeOfNode.range;\n\n  return {\n    loc: getBaseLocation(loc),\n    range: range\n  };\n}\n\nfunction getBaseLocation(_ref5) {\n  var start = _ref5.start,\n      end = _ref5.end,\n      source = _ref5.source,\n      filename = _ref5.filename;\n\n  return _extends({\n    start: start,\n    end: end\n  }, source !== undefined ? { source: source } : {}, filename !== undefined ? { filename: filename } : {});\n}"
        }
    ]
}