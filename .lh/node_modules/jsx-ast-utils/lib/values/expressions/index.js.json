{
    "sourceFile": "node_modules/jsx-ast-utils/lib/values/expressions/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892377917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = extract;\nexports.extractLiteral = extractLiteral;\n\nvar _Literal = require('../Literal');\n\nvar _Literal2 = _interopRequireDefault(_Literal);\n\nvar _JSXElement = require('../JSXElement');\n\nvar _JSXElement2 = _interopRequireDefault(_JSXElement);\n\nvar _JSXFragment = require('../JSXFragment');\n\nvar _JSXFragment2 = _interopRequireDefault(_JSXFragment);\n\nvar _JSXText = require('../JSXText');\n\nvar _JSXText2 = _interopRequireDefault(_JSXText);\n\nvar _Identifier = require('./Identifier');\n\nvar _Identifier2 = _interopRequireDefault(_Identifier);\n\nvar _TaggedTemplateExpression = require('./TaggedTemplateExpression');\n\nvar _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);\n\nvar _TemplateLiteral = require('./TemplateLiteral');\n\nvar _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);\n\nvar _FunctionExpression = require('./FunctionExpression');\n\nvar _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);\n\nvar _LogicalExpression = require('./LogicalExpression');\n\nvar _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);\n\nvar _MemberExpression = require('./MemberExpression');\n\nvar _MemberExpression2 = _interopRequireDefault(_MemberExpression);\n\nvar _ChainExpression = require('./ChainExpression');\n\nvar _ChainExpression2 = _interopRequireDefault(_ChainExpression);\n\nvar _OptionalCallExpression = require('./OptionalCallExpression');\n\nvar _OptionalCallExpression2 = _interopRequireDefault(_OptionalCallExpression);\n\nvar _OptionalMemberExpression = require('./OptionalMemberExpression');\n\nvar _OptionalMemberExpression2 = _interopRequireDefault(_OptionalMemberExpression);\n\nvar _CallExpression = require('./CallExpression');\n\nvar _CallExpression2 = _interopRequireDefault(_CallExpression);\n\nvar _UnaryExpression = require('./UnaryExpression');\n\nvar _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);\n\nvar _ThisExpression = require('./ThisExpression');\n\nvar _ThisExpression2 = _interopRequireDefault(_ThisExpression);\n\nvar _ConditionalExpression = require('./ConditionalExpression');\n\nvar _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);\n\nvar _BinaryExpression = require('./BinaryExpression');\n\nvar _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);\n\nvar _ObjectExpression = require('./ObjectExpression');\n\nvar _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);\n\nvar _NewExpression = require('./NewExpression');\n\nvar _NewExpression2 = _interopRequireDefault(_NewExpression);\n\nvar _UpdateExpression = require('./UpdateExpression');\n\nvar _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);\n\nvar _ArrayExpression = require('./ArrayExpression');\n\nvar _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);\n\nvar _BindExpression = require('./BindExpression');\n\nvar _BindExpression2 = _interopRequireDefault(_BindExpression);\n\nvar _SpreadElement = require('./SpreadElement');\n\nvar _SpreadElement2 = _interopRequireDefault(_SpreadElement);\n\nvar _TypeCastExpression = require('./TypeCastExpression');\n\nvar _TypeCastExpression2 = _interopRequireDefault(_TypeCastExpression);\n\nvar _SequenceExpression = require('./SequenceExpression');\n\nvar _SequenceExpression2 = _interopRequireDefault(_SequenceExpression);\n\nvar _TSNonNullExpression = require('./TSNonNullExpression');\n\nvar _TSNonNullExpression2 = _interopRequireDefault(_TSNonNullExpression);\n\nvar _AssignmentExpression = require('./AssignmentExpression');\n\nvar _AssignmentExpression2 = _interopRequireDefault(_AssignmentExpression);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Composition map of types to their extractor functions.\nvar TYPES = {\n  Identifier: _Identifier2.default,\n  Literal: _Literal2.default,\n  JSXElement: _JSXElement2.default,\n  JSXFragment: _JSXFragment2.default,\n  JSXText: _JSXText2.default,\n  TaggedTemplateExpression: _TaggedTemplateExpression2.default,\n  TemplateLiteral: _TemplateLiteral2.default,\n  ArrowFunctionExpression: _FunctionExpression2.default,\n  FunctionExpression: _FunctionExpression2.default,\n  LogicalExpression: _LogicalExpression2.default,\n  MemberExpression: _MemberExpression2.default,\n  ChainExpression: _ChainExpression2.default,\n  OptionalCallExpression: _OptionalCallExpression2.default,\n  OptionalMemberExpression: _OptionalMemberExpression2.default,\n  CallExpression: _CallExpression2.default,\n  UnaryExpression: _UnaryExpression2.default,\n  ThisExpression: _ThisExpression2.default,\n  ConditionalExpression: _ConditionalExpression2.default,\n  BinaryExpression: _BinaryExpression2.default,\n  ObjectExpression: _ObjectExpression2.default,\n  NewExpression: _NewExpression2.default,\n  UpdateExpression: _UpdateExpression2.default,\n  ArrayExpression: _ArrayExpression2.default,\n  BindExpression: _BindExpression2.default,\n  SpreadElement: _SpreadElement2.default,\n  TypeCastExpression: _TypeCastExpression2.default,\n  SequenceExpression: _SequenceExpression2.default,\n  TSNonNullExpression: _TSNonNullExpression2.default,\n  AssignmentExpression: _AssignmentExpression2.default\n};\n\nvar noop = function noop() {\n  return null;\n};\n\nvar errorMessage = function errorMessage(expression) {\n  return 'The prop value with an expression type of ' + expression + ' could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.';\n};\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nfunction extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  var expression = void 0;\n  if (typeof value.expression !== 'boolean' && value.expression) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n  var _expression = expression,\n      type = _expression.type;\n\n  // Typescript NonNull Expression is wrapped & it would end up in the wrong extractor\n\n  if (expression.object && expression.object.type === 'TSNonNullExpression') {\n    type = 'TSNonNullExpression';\n  }\n\n  while (type === 'TSAsExpression') {\n    var _expression2 = expression;\n    type = _expression2.type;\n\n    if (expression.expression) {\n      var _expression3 = expression;\n      expression = _expression3.expression;\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n}\n\n// Composition map of types to their extractor functions to handle literals.\nvar LITERAL_TYPES = _extends({}, TYPES, {\n  Literal: function Literal(value) {\n    var extractedVal = TYPES.Literal.call(undefined, value);\n    var isNull = extractedVal === null;\n    // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: function Identifier(value) {\n    var isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  JSXFragment: noop,\n  JSXText: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: function UnaryExpression(value) {\n    var extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: function UpdateExpression(value) {\n    var extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: function ArrayExpression(value) {\n    var extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter(function (val) {\n      return val !== null;\n    });\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop,\n  SequenceExpression: noop,\n  ChainExpression: noop\n});\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nfunction extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  var expression = value.expression || value;\n  var type = expression.type;\n\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}"
        }
    ]
}