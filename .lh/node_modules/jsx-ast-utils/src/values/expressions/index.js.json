{
    "sourceFile": "node_modules/jsx-ast-utils/src/values/expressions/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892380977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import Literal from '../Literal';\nimport JSXElement from '../JSXElement';\nimport JSXFragment from '../JSXFragment';\nimport JSXText from '../JSXText';\nimport Identifier from './Identifier';\nimport TaggedTemplateExpression from './TaggedTemplateExpression';\nimport TemplateLiteral from './TemplateLiteral';\nimport FunctionExpression from './FunctionExpression';\nimport LogicalExpression from './LogicalExpression';\nimport MemberExpression from './MemberExpression';\nimport ChainExpression from './ChainExpression';\nimport OptionalCallExpression from './OptionalCallExpression';\nimport OptionalMemberExpression from './OptionalMemberExpression';\nimport CallExpression from './CallExpression';\nimport UnaryExpression from './UnaryExpression';\nimport ThisExpression from './ThisExpression';\nimport ConditionalExpression from './ConditionalExpression';\nimport BinaryExpression from './BinaryExpression';\nimport ObjectExpression from './ObjectExpression';\nimport NewExpression from './NewExpression';\nimport UpdateExpression from './UpdateExpression';\nimport ArrayExpression from './ArrayExpression';\nimport BindExpression from './BindExpression';\nimport SpreadElement from './SpreadElement';\nimport TypeCastExpression from './TypeCastExpression';\nimport SequenceExpression from './SequenceExpression';\nimport TSNonNullExpression from './TSNonNullExpression';\nimport AssignmentExpression from './AssignmentExpression';\n\n// Composition map of types to their extractor functions.\nconst TYPES = {\n  Identifier,\n  Literal,\n  JSXElement,\n  JSXFragment,\n  JSXText,\n  TaggedTemplateExpression,\n  TemplateLiteral,\n  ArrowFunctionExpression: FunctionExpression,\n  FunctionExpression,\n  LogicalExpression,\n  MemberExpression,\n  ChainExpression,\n  OptionalCallExpression,\n  OptionalMemberExpression,\n  CallExpression,\n  UnaryExpression,\n  ThisExpression,\n  ConditionalExpression,\n  BinaryExpression,\n  ObjectExpression,\n  NewExpression,\n  UpdateExpression,\n  ArrayExpression,\n  BindExpression,\n  SpreadElement,\n  TypeCastExpression,\n  SequenceExpression,\n  TSNonNullExpression,\n  AssignmentExpression,\n};\n\nconst noop = () => null;\n\nconst errorMessage = (expression) => `The prop value with an expression type of ${expression} could not be resolved. Please file an issue ( https://github.com/jsx-eslint/jsx-ast-utils/issues/new ) to get this fixed immediately.`;\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *all* possible expression types.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nexport default function extract(value) {\n  // Value will not have the expression property when we recurse.\n  // The type for expression on ArrowFunctionExpression is a boolean.\n  let expression;\n  if (\n    typeof value.expression !== 'boolean'\n    && value.expression\n  ) {\n    expression = value.expression; // eslint-disable-line prefer-destructuring\n  } else {\n    expression = value;\n  }\n  let { type } = expression;\n\n  // Typescript NonNull Expression is wrapped & it would end up in the wrong extractor\n  if (expression.object && expression.object.type === 'TSNonNullExpression') {\n    type = 'TSNonNullExpression';\n  }\n\n  while (type === 'TSAsExpression') {\n    ({ type } = expression);\n    if (expression.expression) {\n      ({ expression } = expression);\n    }\n  }\n\n  if (TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return TYPES[type](expression);\n}\n\n// Composition map of types to their extractor functions to handle literals.\nconst LITERAL_TYPES = {\n  ...TYPES,\n  Literal: (value) => {\n    const extractedVal = TYPES.Literal.call(undefined, value);\n    const isNull = extractedVal === null;\n    // This will be convention for attributes that have null\n    // value explicitly defined (<div prop={null} /> maps to 'null').\n    return isNull ? 'null' : extractedVal;\n  },\n  Identifier: (value) => {\n    const isUndefined = TYPES.Identifier.call(undefined, value) === undefined;\n    return isUndefined ? undefined : null;\n  },\n  JSXElement: noop,\n  JSXFragment: noop,\n  JSXText: noop,\n  ArrowFunctionExpression: noop,\n  FunctionExpression: noop,\n  LogicalExpression: noop,\n  MemberExpression: noop,\n  OptionalCallExpression: noop,\n  OptionalMemberExpression: noop,\n  CallExpression: noop,\n  UnaryExpression: (value) => {\n    const extractedVal = TYPES.UnaryExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  UpdateExpression: (value) => {\n    const extractedVal = TYPES.UpdateExpression.call(undefined, value);\n    return extractedVal === undefined ? null : extractedVal;\n  },\n  ThisExpression: noop,\n  ConditionalExpression: noop,\n  BinaryExpression: noop,\n  ObjectExpression: noop,\n  NewExpression: noop,\n  ArrayExpression: (value) => {\n    const extractedVal = TYPES.ArrayExpression.call(undefined, value);\n    return extractedVal.filter((val) => val !== null);\n  },\n  BindExpression: noop,\n  SpreadElement: noop,\n  TSNonNullExpression: noop,\n  TSAsExpression: noop,\n  TypeCastExpression: noop,\n  SequenceExpression: noop,\n  ChainExpression: noop,\n};\n\n/**\n * This function maps an AST value node\n * to its correct extractor function for its\n * given type.\n *\n * This will map correctly for *some* possible types that map to literals.\n *\n * @param - value - AST Value object with type `JSXExpressionContainer`\n * @returns The extracted value.\n */\nexport function extractLiteral(value) {\n  // Value will not have the expression property when we recurse.\n  const expression = value.expression || value;\n  const { type } = expression;\n\n  if (LITERAL_TYPES[type] === undefined) {\n    // eslint-disable-next-line no-console\n    console.error(errorMessage(type));\n    return null;\n  }\n\n  return LITERAL_TYPES[type](expression);\n}\n"
        }
    ]
}