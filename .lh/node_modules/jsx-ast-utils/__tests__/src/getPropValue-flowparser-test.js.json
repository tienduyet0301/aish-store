{
    "sourceFile": "node_modules/jsx-ast-utils/__tests__/src/getPropValue-flowparser-test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892382292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/* eslint-env mocha */\n/* eslint no-template-curly-in-string: 0 */\nimport assert from 'assert';\nimport {\n  extractProp,\n  changePlugins,\n  describeIfNotBabylon,\n  setParserName,\n} from '../helper';\nimport getPropValue from '../../src/getPropValue';\n\ndescribe('getPropValue', () => {\n  beforeEach(() => {\n    setParserName('flow');\n  });\n\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof getPropValue;\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return undefined when not provided with a JSXAttribute', () => {\n    const expected = undefined;\n    const actual = getPropValue(1);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should throw not error when trying to get value from unknown node type', () => {\n    const prop = {\n      type: 'JSXAttribute',\n      value: {\n        type: 'JSXExpressionContainer',\n      },\n    };\n    let counter = 0;\n    // eslint-disable-next-line no-console\n    const errorOrig = console.error;\n    // eslint-disable-next-line no-console\n    console.error = () => {\n      counter += 1;\n    };\n    let value;\n    assert.doesNotThrow(() => {\n      value = getPropValue(prop);\n    }, Error);\n\n    assert.equal(null, value);\n    assert.equal(counter, 1);\n    // eslint-disable-next-line no-console\n    console.error = errorOrig;\n  });\n\n  describe('Null', () => {\n    it('should return true when no value is given', () => {\n      const prop = extractProp('<div foo />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Literal', () => {\n    it('should return correct string if value is a string', () => {\n      const prop = extractProp('<div foo=\"bar\" />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct string if value is a string expression', () => {\n      const prop = extractProp('<div foo={\"bar\"} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct integer if value is a integer expression', () => {\n      const prop = extractProp('<div foo={1} />');\n\n      const expected = 1;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"true\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"true\" />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"false\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"false\" />');\n\n      const expected = false;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('JSXElement', () => {\n    it('should return correct representation of JSX element as a string', () => {\n      const prop = extractProp('<div foo={<bar />} />');\n\n      const expected = '<bar />';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Identifier', () => {\n    it('should return string representation of variable identifier', () => {\n      const prop = extractProp('<div foo={bar} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when identifier is literally `undefined`', () => {\n      const prop = extractProp('<div foo={undefined} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return String object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={String} />');\n\n      const expected = String;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Array object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Array} />');\n\n      const expected = Array;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Date object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Date} />');\n\n      const expected = Date;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Infinity object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Infinity} />');\n\n      const expected = Infinity;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Math object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Math} />');\n\n      const expected = Math;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Number object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Number} />');\n\n      const expected = Number;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Object object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Object} />');\n\n      const expected = Object;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz}`} />');\n\n      const expected = 'bar {baz}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={`bar ${undefined}`} />');\n\n      const expected = 'bar undefined';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return template literal with expression type wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz()}`} />');\n\n      const expected = 'bar {CallExpression}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should ignore non-expressions in the template literal', () => {\n      const prop = extractProp('<div foo={`bar ${<baz />}`} />');\n\n      const expected = 'bar ';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Tagged Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz}`} />');\n\n      const expected = 'bar {baz}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={noop`bar ${undefined}`} />');\n\n      const expected = 'bar undefined';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return template literal with expression type wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz()}`} />');\n\n      const expected = 'bar {CallExpression}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should ignore non-expressions in the template literal', () => {\n      const prop = extractProp('<div foo={noop`bar ${<baz />}`} />');\n\n      const expected = 'bar ';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Arrow function expression', () => {\n    it('should return a function', () => {\n      const prop = extractProp('<div foo={ () => { return \"bar\"; }} />');\n\n      const expected = 'function';\n      const actual = getPropValue(prop);\n\n      assert.equal(expected, typeof actual);\n\n      // For code coverage ¯\\_(ツ)_/¯\n      actual();\n    });\n    it('should handle ArrowFunctionExpression as conditional consequent', () => {\n      const prop = extractProp('<div foo={ (true) ? () => null : () => ({})} />');\n\n      const expected = 'function';\n      const actual = getPropValue(prop);\n\n      assert.equal(expected, typeof actual);\n\n      // For code coverage ¯\\_(ツ)_/¯\n      actual();\n    });\n  });\n\n  describe('Function expression', () => {\n    it('should return a function', () => {\n      const prop = extractProp('<div foo={ function() { return \"bar\"; } } />');\n\n      const expected = 'function';\n      const actual = getPropValue(prop);\n\n      assert.equal(expected, typeof actual);\n\n      // For code coverage ¯\\_(ツ)_/¯\n      actual();\n    });\n  });\n\n  describe('Logical expression', () => {\n    it('should correctly infer result of && logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={bar && baz} />');\n\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `undefined && undefined` ', () => {\n      const prop = extractProp('<div foo={undefined && undefined} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly infer result of || logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={bar || baz} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly infer result of || logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={undefined || baz} />');\n\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `undefined || undefined` ', () => {\n      const prop = extractProp('<div foo={undefined || undefined} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Member expression', () => {\n    it('should return string representation of form `object.property`', () => {\n      const prop = extractProp('<div foo={bar.baz} />');\n\n      const expected = 'bar.baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of member expression with a nullable member', () => {\n      const prop = extractProp('<div foo={bar?.baz} />');\n\n      const expected = 'bar?.baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Call expression', () => {\n    it('should return string representation of callee', () => {\n      const prop = extractProp('<div foo={bar()} />');\n\n      const expected = 'bar()';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of callee', () => {\n      const prop = extractProp('<div foo={bar.call()} />');\n\n      const expected = 'bar.call()';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Unary expression', () => {\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-bar} />');\n\n      // -\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-42} />');\n\n      const expected = -42;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+bar} />');\n\n      // +\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+42} />');\n\n      const expected = 42;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with !', () => {\n      const prop = extractProp('<div foo={!bar} />');\n\n      const expected = false; // !\"bar\" === false\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with ~', () => {\n      const prop = extractProp('<div foo={~bar} />');\n\n      const expected = -1; // ~\"bar\" === -1\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return true when evaluating `delete foo`', () => {\n      const prop = extractProp('<div foo={delete x} />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `void foo`', () => {\n      const prop = extractProp('<div foo={void x} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    // TODO: We should fix this to check to see if we can evaluate it.\n    it('should return undefined when evaluating `typeof foo`', () => {\n      const prop = extractProp('<div foo={typeof x} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Update expression', () => {\n    it('should correctly evaluate an expression that prefixes with ++', () => {\n      const prop = extractProp('<div foo={++bar} />');\n\n      // ++\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with --', () => {\n      const prop = extractProp('<div foo={--bar} />');\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that suffixes with ++', () => {\n      const prop = extractProp('<div foo={bar++} />');\n\n      // \"bar\"++ => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that suffixes with --', () => {\n      const prop = extractProp('<div foo={bar--} />');\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('This expression', () => {\n    it('should return string value `this`', () => {\n      const prop = extractProp('<div foo={this} />');\n\n      const expected = 'this';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Conditional expression', () => {\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={bar ? baz : bam} />');\n\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={undefined ? baz : bam} />');\n\n      const expected = 'bam';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={(1 > 2) ? baz : bam} />');\n\n      const expected = 'bam';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Binary expression', () => {\n    it('should evaluate the `==` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 == \"1\"} />');\n      const falseProp = extractProp('<div foo={1 == bar} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `!=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 != \"2\"} />');\n      const falseProp = extractProp('<div foo={1 != \"1\"} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `===` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 === 1} />');\n      const falseProp = extractProp('<div foo={1 === \"1\"} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `!==` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 !== \"1\"} />');\n      const falseProp = extractProp('<div foo={1 !== 1} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `<` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 < 2} />');\n      const falseProp = extractProp('<div foo={1 < 0} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `>` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 > 0} />');\n      const falseProp = extractProp('<div foo={1 > 2} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `<=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 <= 1} />');\n      const falseProp = extractProp('<div foo={1 <= 0} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `>=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 >= 1} />');\n      const falseProp = extractProp('<div foo={1 >= 2} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `<<` operator correctly', () => {\n      const prop = extractProp('<div foo={1 << 2} />');\n\n      const expected = 4;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `>>` operator correctly', () => {\n      const prop = extractProp('<div foo={1 >> 2} />');\n\n      const expected = 0;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `>>>` operator correctly', () => {\n      const prop = extractProp('<div foo={2 >>> 1} />');\n\n      const expected = 1;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `+` operator correctly', () => {\n      const prop = extractProp('<div foo={1 + 1} />');\n\n      const expected = 2;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `-` operator correctly', () => {\n      const prop = extractProp('<div foo={1 - 1} />');\n\n      const expected = 0;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `*` operator correctly', () => {\n      const prop = extractProp('<div foo={10 * 10} />');\n\n      const expected = 100;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `/` operator correctly', () => {\n      const prop = extractProp('<div foo={10 / 2} />');\n\n      const expected = 5;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `%` operator correctly', () => {\n      const prop = extractProp('<div foo={10 % 3} />');\n\n      const expected = 1;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `|` operator correctly', () => {\n      const prop = extractProp('<div foo={10 | 1} />');\n\n      const expected = 11;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `^` operator correctly', () => {\n      const prop = extractProp('<div foo={10 ^ 1} />');\n\n      const expected = 11;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `&` operator correctly', () => {\n      const prop = extractProp('<div foo={10 & 1} />');\n\n      const expected = 0;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `in` operator correctly', () => {\n      const prop = extractProp('<div foo={foo in bar} />');\n\n      const expected = false;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `instanceof` operator correctly', () => {\n      const prop = extractProp('<div foo={{} instanceof Object} />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `instanceof` operator when right side is not a function', () => {\n      const prop = extractProp('<div foo={\"bar\" instanceof Baz} />');\n\n      const expected = false;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Object expression', () => {\n    it('should evaluate to a correct representation of the object in props', () => {\n      const prop = extractProp('<div foo={ { bar: \"baz\" } } />');\n\n      const expected = { bar: 'baz' };\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of the object, ignore spread properties', () => {\n      const prop = extractProp('<div foo={{bar: \"baz\", ...{baz: \"bar\", foo: {...{bar: \"meh\"}}}}} />');\n\n      const expected = { bar: 'baz', baz: 'bar', foo: { bar: 'meh' } };\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of the object, ignore spread properties', () => {\n      const prop = extractProp('<div foo={{ pathname: manageRoute, state: {...data}}} />');\n\n      const expected = { pathname: 'manageRoute', state: {} };\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('New expression', () => {\n    it('should return a new empty object', () => {\n      const prop = extractProp('<div foo={new Bar()} />');\n\n      const expected = {};\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('Sequence array expression', () => {\n    it('should evaluate to correct representation of the the array in props', () => {\n      const prop = extractProp('<div foo={[{\"type\":\"Literal\",\"start\":821,\"end\":827}]} />');\n\n      const expected = [{\n        type: 'Literal',\n        start: 821,\n        end: 827,\n      }];\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('Array expression', () => {\n    it('should evaluate to correct representation of the the array in props', () => {\n      const prop = extractProp('<div foo={[\"bar\", 42, null]} />');\n\n      const expected = ['bar', 42, null];\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of an array with spread elements', () => {\n      const prop = extractProp('<div foo={[...this.props.params, bar]} />');\n\n      const expected = [undefined, 'bar'];\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  it('should return an empty array provided an empty array in props', () => {\n    const prop = extractProp('<div foo={[]} />');\n\n    const expected = [];\n    const actual = getPropValue(prop);\n\n    assert.deepEqual(actual, expected);\n  });\n\n  describe('Bind expression', () => {\n    it('should return string representation of bind function call when object is null', () => {\n      const prop = extractProp('<div foo={::this.handleClick} />');\n\n      const expected = null;\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should return string representation of bind function call when object is not null', () => {\n      const prop = extractProp('<div foo={foo::bar} />');\n\n      const expected = 'foo';\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should return string representation of bind function call when binding to object properties', () => {\n      const prop = extractProp('<div foo={a.b::c} />');\n      const otherProp = extractProp('<div foo={::a.b.c} />');\n\n      const expected = 'a.b';\n      const actual = getPropValue(prop);\n\n      const otherExpected = null;\n      const otherActual = getPropValue(otherProp);\n\n      assert.deepEqual(actual, expected);\n      assert.deepEqual(otherActual, otherExpected);\n    });\n  });\n\n  describe('Type Cast Expression', () => {\n    it('should return the expression from a type cast', () => {\n      const prop = extractProp('<div foo={(this.handleClick: (event: MouseEvent) => void))} />');\n\n      const expected = 'this.handleClick';\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describeIfNotBabylon('Typescript', () => {\n    beforeEach(() => {\n      changePlugins((pls) => [...pls, 'typescript']);\n    });\n\n    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={bar!} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => {\n      changePlugins((pls) => [...pls, 'typescript']);\n      const prop = extractProp('<div foo={bar as any} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('JSX empty expression', () => {\n    it('should work with an empty expression', () => {\n      const prop = extractProp('<div>\\n{/* Hello there */}\\n</div>', 'children');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n});\n"
        }
    ]
}