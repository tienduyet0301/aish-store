{
    "sourceFile": "node_modules/jsx-ast-utils/__tests__/src/elementType-test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892382008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/* eslint-env mocha */\nimport assert from 'assert';\nimport { getOpeningElement, setParserName, describeIfNotBabylon } from '../helper';\nimport elementType from '../../src/elementType';\n\ndescribe('elementType tests', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof elementType;\n\n    assert.equal(actual, expected);\n  });\n\n  it('should throw an error if the argument is missing', () => {\n    assert.throws(() => { elementType(); }, Error);\n  });\n\n  it('should throw an error if the argument not a JSX node', () => {\n    assert.throws(() => { elementType({ a: 'foo' }); }, Error);\n  });\n\n  it('should return the correct type of the DOM element given its node object', () => {\n    const code = '<div />';\n    const node = getOpeningElement(code);\n\n    const expected = 'div';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the custom element given its node object', () => {\n    const code = '<Slider />';\n    const node = getOpeningElement(code);\n\n    const expected = 'Slider';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the custom object element given its node object', () => {\n    const code = '<UX.Slider />';\n    const node = getOpeningElement(code);\n\n    const expected = 'UX.Slider';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the namespaced element given its node object', () => {\n    const code = '<UX:Slider />';\n    const node = getOpeningElement(code);\n\n    const expected = 'UX:Slider';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the multiple custom object element given its node object', () => {\n    const code = '<UX.Slider.Blue.Light />';\n    const node = getOpeningElement(code);\n\n    const expected = 'UX.Slider.Blue.Light';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return this.Component when given its node object', () => {\n    const code = '<this.Component />';\n    const node = getOpeningElement(code);\n\n    const expected = 'this.Component';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  describeIfNotBabylon('fragments', () => {\n    it('should work with fragments', () => {\n      const code = '<>foo</>';\n      const node = getOpeningElement(code);\n\n      const expected = '<>';\n      const actual = elementType(node);\n\n      assert.equal(actual, expected);\n    });\n\n    it('works with nested fragments', () => {\n      const code = `\n        <Hello\n          role=\"checkbox\"\n          frag={\n            <>\n              <div>Hello</div>\n              <>\n                <div>There</div>\n              </>\n            </>\n          }\n        />\n      `;\n      const node = getOpeningElement(code);\n\n      const expected = 'Hello';\n      const actual = elementType(node);\n\n      assert.equal(actual, expected);\n    });\n  });\n});\n"
        }
    ]
}