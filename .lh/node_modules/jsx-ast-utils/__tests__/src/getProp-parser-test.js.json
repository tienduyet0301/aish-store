{
    "sourceFile": "node_modules/jsx-ast-utils/__tests__/src/getProp-parser-test.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892382077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/* eslint-env mocha */\nimport assert from 'assert';\nimport entries from 'object.entries';\nimport fromEntries from 'object.fromentries';\nimport { getOpeningElement, setParserName, fallbackToBabylon } from '../helper';\nimport getProp from '../../src/getProp';\n\nconst literal = {\n  source: '<div {...{ id: \"foo\" }} />',\n  target: '<div id=\"foo\" />',\n  offset: { keyOffset: -6, valueOffset: -7 },\n};\n\nconst expression1 = {\n  source: '<div {...{ id }} />',\n  target: '<div id={id} />',\n  offset: { keyOffset: -6, valueOffset: -2 },\n};\n\nconst expression2 = {\n  source: '<div {...{ id: `foo${bar}baz` }} />', // eslint-disable-line no-template-curly-in-string\n  target: '<div id={`foo${bar}baz`} />', // eslint-disable-line no-template-curly-in-string\n  offset: { keyOffset: -6, valueOffset: -6 },\n};\n\ndescribe('getProp', () => {\n  it('should create the correct AST for literal with flow parser', () => {\n    actualTest('flow', literal);\n  });\n  it('should create the correct AST for literal with babel parser', () => {\n    actualTest('babel', literal);\n  });\n  it('should create the correct AST for expression with flow parser (1)', () => {\n    actualTest('flow', expression1);\n  });\n  it('should create the correct AST for expression with babel parser (1)', () => {\n    actualTest('babel', expression1);\n  });\n  it('should create the correct AST for expression with flow parser (2)', () => {\n    actualTest('flow', expression2);\n  });\n  it('should create the correct AST for expression with babel parser (2)', () => {\n    actualTest('babel', expression2);\n  });\n});\n\nfunction actualTest(parserName, test) {\n  setParserName(parserName);\n  const { source, target, offset } = test;\n  const sourceProps = stripConstructors(getOpeningElement(source).attributes);\n  const targetProps = stripConstructors(getOpeningElement(target).attributes);\n  const prop = 'id';\n  const sourceResult = getProp(sourceProps, prop);\n  const targetResult = getProp(targetProps, prop);\n\n  if (fallbackToBabylon && parserName === 'babel' && test === literal) {\n    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a\n    // JSXAttribute, other literals don't get this.\n    sourceResult.value.extra = null;\n  }\n\n  assert.deepStrictEqual(\n    adjustLocations(sourceResult, offset),\n    adjustRange(targetResult),\n  );\n}\n\nfunction adjustRange({ name, value: { expression, ...value }, ...node }) {\n  return {\n    ...adjustNodeRange(node),\n    name: adjustNodeRange(name),\n    value: {\n      ...adjustNodeRange(value),\n      ...(expression ? { expression: adjustNodeRangeRecursively(expression) } : {}),\n    },\n  };\n}\n\nfunction adjustNodeRange(node) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [node.start, node.end];\n  return {\n    ...node,\n    end: undefined,\n    range: [start, end],\n    start: undefined,\n  };\n}\n\nfunction adjustNodeRangeRecursively(node) {\n  if (Array.isArray(node)) {\n    return node.map(adjustNodeRangeRecursively);\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeRange(mapValues(node, adjustNodeRangeRecursively));\n  }\n\n  return node;\n}\n\nfunction stripConstructors(value) {\n  return JSON.parse(JSON.stringify(value));\n}\n\nfunction adjustLocations(node, { keyOffset, valueOffset }) {\n  const hasExpression = !!node.value.expression;\n  return {\n    ...adjustNodeLocations(node, {\n      startOffset: keyOffset,\n      endOffset: valueOffset + (hasExpression ? 1 : 0),\n    }),\n    name: adjustNodeLocations(node.name, { startOffset: keyOffset, endOffset: keyOffset }),\n    value: {\n      ...adjustNodeLocations(node.value, {\n        startOffset: valueOffset - (hasExpression ? 1 : 0),\n        endOffset: valueOffset + (hasExpression ? 1 : 0),\n      }),\n      ...(hasExpression\n        ? {\n          expression: adjustLocationsRecursively(\n            node.value.expression,\n            { startOffset: valueOffset, endOffset: valueOffset },\n          ),\n        }\n        : {}\n      ),\n    },\n  };\n}\n\nfunction adjustNodeLocations(node, { startOffset, endOffset }) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [];\n  return {\n    ...node,\n    end: undefined,\n    loc: {\n      ...node.loc,\n      start: {\n        ...node.loc.start,\n        column: node.loc.start.column + startOffset,\n      },\n      end: {\n        ...node.loc.end,\n        column: node.loc.end.column + endOffset,\n      },\n    },\n    range: [start + startOffset, end + endOffset],\n    start: undefined,\n  };\n}\n\nfunction adjustLocationsRecursively(node, { startOffset, endOffset }) {\n  if (Array.isArray(node)) {\n    return node.map((x) => adjustLocationsRecursively(x, { startOffset, endOffset }));\n  }\n  if (node && typeof node === 'object') {\n    return adjustNodeLocations(\n      mapValues(node, (x) => adjustLocationsRecursively(x, { startOffset, endOffset })),\n      { startOffset, endOffset },\n    );\n  }\n\n  return node;\n}\n\nfunction mapValues(o, f) {\n  return fromEntries(entries(o).map(([k, v]) => [k, f(v)]));\n}\n"
        }
    ]
}