{
    "sourceFile": "node_modules/levn/lib/cast.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892383771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Generated by LiveScript 1.6.0\n(function(){\n  var parsedTypeCheck, types, toString$ = {}.toString;\n  parsedTypeCheck = require('type-check').parsedTypeCheck;\n  types = {\n    '*': function(value, options){\n      switch (toString$.call(value).slice(8, -1)) {\n      case 'Array':\n        return typeCast(value, {\n          type: 'Array'\n        }, options);\n      case 'Object':\n        return typeCast(value, {\n          type: 'Object'\n        }, options);\n      default:\n        return {\n          type: 'Just',\n          value: typesCast(value, [\n            {\n              type: 'Undefined'\n            }, {\n              type: 'Null'\n            }, {\n              type: 'NaN'\n            }, {\n              type: 'Boolean'\n            }, {\n              type: 'Number'\n            }, {\n              type: 'Date'\n            }, {\n              type: 'RegExp'\n            }, {\n              type: 'Array'\n            }, {\n              type: 'Object'\n            }, {\n              type: 'String'\n            }\n          ], (options.explicit = true, options))\n        };\n      }\n    },\n    Undefined: function(it){\n      if (it === 'undefined' || it === void 8) {\n        return {\n          type: 'Just',\n          value: void 8\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Null: function(it){\n      if (it === 'null') {\n        return {\n          type: 'Just',\n          value: null\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    NaN: function(it){\n      if (it === 'NaN') {\n        return {\n          type: 'Just',\n          value: NaN\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Boolean: function(it){\n      if (it === 'true') {\n        return {\n          type: 'Just',\n          value: true\n        };\n      } else if (it === 'false') {\n        return {\n          type: 'Just',\n          value: false\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Number: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Int: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Float: function(it){\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Date: function(value, options){\n      var that;\n      if (that = /^\\#([\\s\\S]*)\\#$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new Date(+that[1] || that[1])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new Date(+value || value)\n        };\n      }\n    },\n    RegExp: function(value, options){\n      var that;\n      if (that = /^\\/([\\s\\S]*)\\/([gimy]*)$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new RegExp(that[1], that[2])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new RegExp(value)\n        };\n      }\n    },\n    Array: function(value, options){\n      return castArray(value, {\n        of: [{\n          type: '*'\n        }]\n      }, options);\n    },\n    Object: function(value, options){\n      return castFields(value, {\n        of: {}\n      }, options);\n    },\n    String: function(it){\n      var replace, that;\n      if (toString$.call(it).slice(8, -1) !== 'String') {\n        return {\n          type: 'Nothing'\n        };\n      }\n      replace = function(value, quote){\n        return value.replace(/\\\\([^u]|u[0-9a-fA-F]{4})/g, function(all, escaped){\n          switch (escaped[0]) {\n          case quote:\n            return quote;\n          case '\\\\':\n            return '\\\\';\n          case 'b':\n            return '\\b';\n          case 'f':\n            return '\\f';\n          case 'n':\n            return '\\n';\n          case 'r':\n            return '\\r';\n          case 't':\n            return '\\t';\n          case 'u':\n            return JSON.parse(\"\\\"\" + all + \"\\\"\");\n          default:\n            return escaped;\n          }\n        });\n      };\n      if (that = it.match(/^'([\\s\\S]*)'$/)) {\n        return {\n          type: 'Just',\n          value: replace(that[1], \"'\")\n        };\n      } else if (that = it.match(/^\"([\\s\\S]*)\"$/)) {\n        return {\n          type: 'Just',\n          value: replace(that[1], '\"')\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: it\n        };\n      }\n    }\n  };\n  function castArray(node, type, options){\n    var typeOf, element;\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: (function(){\n        var i$, ref$, len$, results$ = [];\n        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {\n          element = ref$[i$];\n          results$.push(typesCast(element, typeOf, options));\n        }\n        return results$;\n      }())\n    };\n  }\n  function castTuple(node, type, options){\n    var result, i, i$, ref$, len$, types, cast;\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    result = [];\n    i = 0;\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\n      types = ref$[i$];\n      cast = typesCast(node[i], types, options);\n      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {\n        result.push(cast);\n      }\n      i++;\n    }\n    if (node.length <= i) {\n      return {\n        type: 'Just',\n        value: result\n      };\n    } else {\n      return {\n        type: 'Nothing'\n      };\n    }\n  }\n  function castFields(node, type, options){\n    var typeOf, key, value;\n    if (toString$.call(node).slice(8, -1) !== 'Object') {\n      return {\n        type: 'Nothing'\n      };\n    }\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: (function(){\n        var ref$, resultObj$ = {};\n        for (key in ref$ = node) {\n          value = ref$[key];\n          resultObj$[typesCast(key, [{\n            type: 'String'\n          }], options)] = typesCast(value, typeOf[key] || [{\n            type: '*'\n          }], options);\n        }\n        return resultObj$;\n      }())\n    };\n  }\n  function typeCast(node, typeObj, options){\n    var type, structure, castFunc, ref$;\n    type = typeObj.type, structure = typeObj.structure;\n    if (type) {\n      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];\n      if (!castFunc) {\n        throw new Error(\"Type not defined: \" + type + \".\");\n      }\n      return castFunc(node, options, typesCast);\n    } else {\n      switch (structure) {\n      case 'array':\n        return castArray(node, typeObj, options);\n      case 'tuple':\n        return castTuple(node, typeObj, options);\n      case 'fields':\n        return castFields(node, typeObj, options);\n      }\n    }\n  }\n  function typesCast(node, types, options){\n    var i$, len$, type, ref$, valueType, value;\n    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {\n      type = types[i$];\n      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;\n      if (valueType === 'Nothing') {\n        continue;\n      }\n      if (parsedTypeCheck([type], value, {\n        customTypes: options.customTypes\n      })) {\n        return value;\n      }\n    }\n    throw new Error(\"Value \" + JSON.stringify(node) + \" does not type check against \" + JSON.stringify(types) + \".\");\n  }\n  module.exports = function(node, types, options){\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\n      return node;\n    }\n    return typesCast(node, types, options);\n  };\n}).call(this);\n"
        }
    ]
}