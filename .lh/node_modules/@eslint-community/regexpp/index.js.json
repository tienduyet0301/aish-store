{
    "sourceFile": "node_modules/@eslint-community/regexpp/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891760280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst latestEcmaVersion = 2025;\n\nlet largeIdStartRanges = undefined;\nlet largeIdContinueRanges = undefined;\nfunction isIdStart(cp) {\n    if (cp < 0x41)\n        return false;\n    if (cp < 0x5b)\n        return true;\n    if (cp < 0x61)\n        return false;\n    if (cp < 0x7b)\n        return true;\n    return isLargeIdStart(cp);\n}\nfunction isIdContinue(cp) {\n    if (cp < 0x30)\n        return false;\n    if (cp < 0x3a)\n        return true;\n    if (cp < 0x41)\n        return false;\n    if (cp < 0x5b)\n        return true;\n    if (cp === 0x5f)\n        return true;\n    if (cp < 0x61)\n        return false;\n    if (cp < 0x7b)\n        return true;\n    return isLargeIdStart(cp) || isLargeIdContinue(cp);\n}\nfunction isLargeIdStart(cp) {\n    return isInRange(cp, largeIdStartRanges !== null && largeIdStartRanges !== void 0 ? largeIdStartRanges : (largeIdStartRanges = initLargeIdStartRanges()));\n}\nfunction isLargeIdContinue(cp) {\n    return isInRange(cp, largeIdContinueRanges !== null && largeIdContinueRanges !== void 0 ? largeIdContinueRanges : (largeIdContinueRanges = initLargeIdContinueRanges()));\n}\nfunction initLargeIdStartRanges() {\n    return restoreRanges(\"4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 6 n 2 5 i 15 1n 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 3 0 3 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 w 1 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 h e i f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 7 1j t e 1 b 17 r z 16 2 b z 3 a 6 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 6c 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t h3g 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1u 3 1 2 0 2 7 m f 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f d a 2 e 2 6 2 1 2 a 2 e 2 6 2 1 4 1f d 8m a l b 7 p 5 2 15 2 8 1y 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 13 r a m 6z 15 7 1 h 2 1o s b 0 9 l 17 h 1b k s m d 1g 1m 1 3 0 e 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o k 1 1s 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 v 9 2 0 3 0 2 11 2 0 q 0 2 0 19 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 12 6 56 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 j 20 5k w w 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i g 0 2 c 2 x 3h 0 28 pl 2v 32 i 5f 219 2o g tr i 5 q 32y 6 g6 5a2 t 1cz fs 8 u i 26 i t j 1b h 3 w k 6 i c1 18 5w 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 16 9 6w8 3 2 6 2 1 2 82 g 0 u 2 3 0 f 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1f9 u 7 5 7a 1p 43 18 b 6 h 0 8y t j 17 dh r 6d t 3 0 ds 6 2 3 2 1 2 e 2 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyn x 37d 7 65 3 4g1 f 5rk g h9 1wj f1 15v 3t6 6 38f\");\n}\nfunction initLargeIdContinueRanges() {\n    return restoreRanges(\"53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 1o 8 17 n 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1k 0 2 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 4 0 d 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 6 2 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 3 t 2 u 1 v 1 1t v a 0 3 9 y 2 2 a 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 f 1e 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1r el 1 1e 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 2p 0 n51 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 12 0 ig 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 7 9 w 4 8u 1 28 3 1z a 1e 3 3f 2 1i e w a 3 1 b 3 1a a 8 0 1a 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 3 0 4e b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 1w 8 2 0 3 0 2 3 2 4 2 0 f 1 2b h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 7 j 1m e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f 9j 9 1i 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 a 1 2 0 1d 6 4 4 e a 44m 0 7 e 8uh r 1t3 9 2f 9 13 4 1o 6 q 9 ev 9 d2 0 2 1i 8 3 2a 0 c 1 f58 1 382 9 ef 19 3 m f3 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 2t 0 4h 6 a 9 9x 0 1q d dv d 6t 1 2 9 k6 6 32 6 6 9 3o7 9 gvt3 6n\");\n}\nfunction isInRange(cp, ranges) {\n    let l = 0, r = (ranges.length / 2) | 0, i = 0, min = 0, max = 0;\n    while (l < r) {\n        i = ((l + r) / 2) | 0;\n        min = ranges[2 * i];\n        max = ranges[2 * i + 1];\n        if (cp < min) {\n            r = i;\n        }\n        else if (cp > max) {\n            l = i + 1;\n        }\n        else {\n            return true;\n        }\n    }\n    return false;\n}\nfunction restoreRanges(data) {\n    let last = 0;\n    return data.split(\" \").map((s) => (last += parseInt(s, 36) | 0));\n}\n\nclass DataSet {\n    constructor(raw2018, raw2019, raw2020, raw2021, raw2022, raw2023, raw2024, raw2025) {\n        this._raw2018 = raw2018;\n        this._raw2019 = raw2019;\n        this._raw2020 = raw2020;\n        this._raw2021 = raw2021;\n        this._raw2022 = raw2022;\n        this._raw2023 = raw2023;\n        this._raw2024 = raw2024;\n        this._raw2025 = raw2025;\n    }\n    get es2018() {\n        var _a;\n        return ((_a = this._set2018) !== null && _a !== void 0 ? _a : (this._set2018 = new Set(this._raw2018.split(\" \"))));\n    }\n    get es2019() {\n        var _a;\n        return ((_a = this._set2019) !== null && _a !== void 0 ? _a : (this._set2019 = new Set(this._raw2019.split(\" \"))));\n    }\n    get es2020() {\n        var _a;\n        return ((_a = this._set2020) !== null && _a !== void 0 ? _a : (this._set2020 = new Set(this._raw2020.split(\" \"))));\n    }\n    get es2021() {\n        var _a;\n        return ((_a = this._set2021) !== null && _a !== void 0 ? _a : (this._set2021 = new Set(this._raw2021.split(\" \"))));\n    }\n    get es2022() {\n        var _a;\n        return ((_a = this._set2022) !== null && _a !== void 0 ? _a : (this._set2022 = new Set(this._raw2022.split(\" \"))));\n    }\n    get es2023() {\n        var _a;\n        return ((_a = this._set2023) !== null && _a !== void 0 ? _a : (this._set2023 = new Set(this._raw2023.split(\" \"))));\n    }\n    get es2024() {\n        var _a;\n        return ((_a = this._set2024) !== null && _a !== void 0 ? _a : (this._set2024 = new Set(this._raw2024.split(\" \"))));\n    }\n    get es2025() {\n        var _a;\n        return ((_a = this._set2025) !== null && _a !== void 0 ? _a : (this._set2025 = new Set(this._raw2025.split(\" \"))));\n    }\n}\nconst gcNameSet = new Set([\"General_Category\", \"gc\"]);\nconst scNameSet = new Set([\"Script\", \"Script_Extensions\", \"sc\", \"scx\"]);\nconst gcValueSets = new DataSet(\"C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct\", \"\", \"\", \"\", \"\", \"\", \"\", \"\");\nconst scValueSets = new DataSet(\"Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy\", \"Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo\", \"Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho\", \"Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\", \"Cpmn Cypro_Minoan Old_Uyghur Ougr Tangsa Tnsa Toto Vith Vithkuqi\", \"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\", \"\", \"\");\nconst binPropertySets = new DataSet(\"AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space\", \"Extended_Pictographic\", \"\", \"EBase EComp EMod EPres ExtPict\", \"\", \"\", \"\", \"\");\nconst binPropertyOfStringsSets = new DataSet(\"\", \"\", \"\", \"\", \"\", \"\", \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji RGI_Emoji_Flag_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence\", \"\");\nfunction isValidUnicodeProperty(version, name, value) {\n    if (gcNameSet.has(name)) {\n        return version >= 2018 && gcValueSets.es2018.has(value);\n    }\n    if (scNameSet.has(name)) {\n        return ((version >= 2018 && scValueSets.es2018.has(value)) ||\n            (version >= 2019 && scValueSets.es2019.has(value)) ||\n            (version >= 2020 && scValueSets.es2020.has(value)) ||\n            (version >= 2021 && scValueSets.es2021.has(value)) ||\n            (version >= 2022 && scValueSets.es2022.has(value)) ||\n            (version >= 2023 && scValueSets.es2023.has(value)));\n    }\n    return false;\n}\nfunction isValidLoneUnicodeProperty(version, value) {\n    return ((version >= 2018 && binPropertySets.es2018.has(value)) ||\n        (version >= 2019 && binPropertySets.es2019.has(value)) ||\n        (version >= 2021 && binPropertySets.es2021.has(value)));\n}\nfunction isValidLoneUnicodePropertyOfString(version, value) {\n    return version >= 2024 && binPropertyOfStringsSets.es2024.has(value);\n}\n\nconst BACKSPACE = 0x08;\nconst CHARACTER_TABULATION = 0x09;\nconst LINE_FEED = 0x0a;\nconst LINE_TABULATION = 0x0b;\nconst FORM_FEED = 0x0c;\nconst CARRIAGE_RETURN = 0x0d;\nconst EXCLAMATION_MARK = 0x21;\nconst NUMBER_SIGN = 0x23;\nconst DOLLAR_SIGN = 0x24;\nconst PERCENT_SIGN = 0x25;\nconst AMPERSAND = 0x26;\nconst LEFT_PARENTHESIS = 0x28;\nconst RIGHT_PARENTHESIS = 0x29;\nconst ASTERISK = 0x2a;\nconst PLUS_SIGN = 0x2b;\nconst COMMA = 0x2c;\nconst HYPHEN_MINUS = 0x2d;\nconst FULL_STOP = 0x2e;\nconst SOLIDUS = 0x2f;\nconst DIGIT_ZERO = 0x30;\nconst DIGIT_ONE = 0x31;\nconst DIGIT_SEVEN = 0x37;\nconst DIGIT_NINE = 0x39;\nconst COLON = 0x3a;\nconst SEMICOLON = 0x3b;\nconst LESS_THAN_SIGN = 0x3c;\nconst EQUALS_SIGN = 0x3d;\nconst GREATER_THAN_SIGN = 0x3e;\nconst QUESTION_MARK = 0x3f;\nconst COMMERCIAL_AT = 0x40;\nconst LATIN_CAPITAL_LETTER_A = 0x41;\nconst LATIN_CAPITAL_LETTER_B = 0x42;\nconst LATIN_CAPITAL_LETTER_D = 0x44;\nconst LATIN_CAPITAL_LETTER_F = 0x46;\nconst LATIN_CAPITAL_LETTER_P = 0x50;\nconst LATIN_CAPITAL_LETTER_S = 0x53;\nconst LATIN_CAPITAL_LETTER_W = 0x57;\nconst LATIN_CAPITAL_LETTER_Z = 0x5a;\nconst LOW_LINE = 0x5f;\nconst LATIN_SMALL_LETTER_A = 0x61;\nconst LATIN_SMALL_LETTER_B = 0x62;\nconst LATIN_SMALL_LETTER_C = 0x63;\nconst LATIN_SMALL_LETTER_D = 0x64;\nconst LATIN_SMALL_LETTER_F = 0x66;\nconst LATIN_SMALL_LETTER_G = 0x67;\nconst LATIN_SMALL_LETTER_I = 0x69;\nconst LATIN_SMALL_LETTER_K = 0x6b;\nconst LATIN_SMALL_LETTER_M = 0x6d;\nconst LATIN_SMALL_LETTER_N = 0x6e;\nconst LATIN_SMALL_LETTER_P = 0x70;\nconst LATIN_SMALL_LETTER_Q = 0x71;\nconst LATIN_SMALL_LETTER_R = 0x72;\nconst LATIN_SMALL_LETTER_S = 0x73;\nconst LATIN_SMALL_LETTER_T = 0x74;\nconst LATIN_SMALL_LETTER_U = 0x75;\nconst LATIN_SMALL_LETTER_V = 0x76;\nconst LATIN_SMALL_LETTER_W = 0x77;\nconst LATIN_SMALL_LETTER_X = 0x78;\nconst LATIN_SMALL_LETTER_Y = 0x79;\nconst LATIN_SMALL_LETTER_Z = 0x7a;\nconst LEFT_SQUARE_BRACKET = 0x5b;\nconst REVERSE_SOLIDUS = 0x5c;\nconst RIGHT_SQUARE_BRACKET = 0x5d;\nconst CIRCUMFLEX_ACCENT = 0x5e;\nconst GRAVE_ACCENT = 0x60;\nconst LEFT_CURLY_BRACKET = 0x7b;\nconst VERTICAL_LINE = 0x7c;\nconst RIGHT_CURLY_BRACKET = 0x7d;\nconst TILDE = 0x7e;\nconst ZERO_WIDTH_NON_JOINER = 0x200c;\nconst ZERO_WIDTH_JOINER = 0x200d;\nconst LINE_SEPARATOR = 0x2028;\nconst PARAGRAPH_SEPARATOR = 0x2029;\nconst MIN_CODE_POINT = 0x00;\nconst MAX_CODE_POINT = 0x10ffff;\nfunction isLatinLetter(code) {\n    return ((code >= LATIN_CAPITAL_LETTER_A && code <= LATIN_CAPITAL_LETTER_Z) ||\n        (code >= LATIN_SMALL_LETTER_A && code <= LATIN_SMALL_LETTER_Z));\n}\nfunction isDecimalDigit(code) {\n    return code >= DIGIT_ZERO && code <= DIGIT_NINE;\n}\nfunction isOctalDigit(code) {\n    return code >= DIGIT_ZERO && code <= DIGIT_SEVEN;\n}\nfunction isHexDigit(code) {\n    return ((code >= DIGIT_ZERO && code <= DIGIT_NINE) ||\n        (code >= LATIN_CAPITAL_LETTER_A && code <= LATIN_CAPITAL_LETTER_F) ||\n        (code >= LATIN_SMALL_LETTER_A && code <= LATIN_SMALL_LETTER_F));\n}\nfunction isLineTerminator(code) {\n    return (code === LINE_FEED ||\n        code === CARRIAGE_RETURN ||\n        code === LINE_SEPARATOR ||\n        code === PARAGRAPH_SEPARATOR);\n}\nfunction isValidUnicode(code) {\n    return code >= MIN_CODE_POINT && code <= MAX_CODE_POINT;\n}\nfunction digitToInt(code) {\n    if (code >= LATIN_SMALL_LETTER_A && code <= LATIN_SMALL_LETTER_F) {\n        return code - LATIN_SMALL_LETTER_A + 10;\n    }\n    if (code >= LATIN_CAPITAL_LETTER_A && code <= LATIN_CAPITAL_LETTER_F) {\n        return code - LATIN_CAPITAL_LETTER_A + 10;\n    }\n    return code - DIGIT_ZERO;\n}\nfunction isLeadSurrogate(code) {\n    return code >= 0xd800 && code <= 0xdbff;\n}\nfunction isTrailSurrogate(code) {\n    return code >= 0xdc00 && code <= 0xdfff;\n}\nfunction combineSurrogatePair(lead, trail) {\n    return (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;\n}\n\nclass GroupSpecifiersAsES2018 {\n    constructor() {\n        this.groupName = new Set();\n    }\n    clear() {\n        this.groupName.clear();\n    }\n    isEmpty() {\n        return !this.groupName.size;\n    }\n    hasInPattern(name) {\n        return this.groupName.has(name);\n    }\n    hasInScope(name) {\n        return this.hasInPattern(name);\n    }\n    addToScope(name) {\n        this.groupName.add(name);\n    }\n    enterDisjunction() {\n    }\n    enterAlternative() {\n    }\n    leaveDisjunction() {\n    }\n}\nclass BranchID {\n    constructor(parent, base) {\n        this.parent = parent;\n        this.base = base !== null && base !== void 0 ? base : this;\n    }\n    separatedFrom(other) {\n        var _a, _b;\n        if (this.base === other.base && this !== other) {\n            return true;\n        }\n        if (other.parent && this.separatedFrom(other.parent)) {\n            return true;\n        }\n        return (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.separatedFrom(other)) !== null && _b !== void 0 ? _b : false;\n    }\n    child() {\n        return new BranchID(this, null);\n    }\n    sibling() {\n        return new BranchID(this.parent, this.base);\n    }\n}\nclass GroupSpecifiersAsES2025 {\n    constructor() {\n        this.branchID = new BranchID(null, null);\n        this.groupNames = new Map();\n    }\n    clear() {\n        this.branchID = new BranchID(null, null);\n        this.groupNames.clear();\n    }\n    isEmpty() {\n        return !this.groupNames.size;\n    }\n    enterDisjunction() {\n        this.branchID = this.branchID.child();\n    }\n    enterAlternative(index) {\n        if (index === 0) {\n            return;\n        }\n        this.branchID = this.branchID.sibling();\n    }\n    leaveDisjunction() {\n        this.branchID = this.branchID.parent;\n    }\n    hasInPattern(name) {\n        return this.groupNames.has(name);\n    }\n    hasInScope(name) {\n        const branches = this.groupNames.get(name);\n        if (!branches) {\n            return false;\n        }\n        for (const branch of branches) {\n            if (!branch.separatedFrom(this.branchID)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    addToScope(name) {\n        const branches = this.groupNames.get(name);\n        if (branches) {\n            branches.push(this.branchID);\n            return;\n        }\n        this.groupNames.set(name, [this.branchID]);\n    }\n}\n\nconst legacyImpl = {\n    at(s, end, i) {\n        return i < end ? s.charCodeAt(i) : -1;\n    },\n    width(c) {\n        return 1;\n    },\n};\nconst unicodeImpl = {\n    at(s, end, i) {\n        return i < end ? s.codePointAt(i) : -1;\n    },\n    width(c) {\n        return c > 0xffff ? 2 : 1;\n    },\n};\nclass Reader {\n    constructor() {\n        this._impl = legacyImpl;\n        this._s = \"\";\n        this._i = 0;\n        this._end = 0;\n        this._cp1 = -1;\n        this._w1 = 1;\n        this._cp2 = -1;\n        this._w2 = 1;\n        this._cp3 = -1;\n        this._w3 = 1;\n        this._cp4 = -1;\n    }\n    get source() {\n        return this._s;\n    }\n    get index() {\n        return this._i;\n    }\n    get currentCodePoint() {\n        return this._cp1;\n    }\n    get nextCodePoint() {\n        return this._cp2;\n    }\n    get nextCodePoint2() {\n        return this._cp3;\n    }\n    get nextCodePoint3() {\n        return this._cp4;\n    }\n    reset(source, start, end, uFlag) {\n        this._impl = uFlag ? unicodeImpl : legacyImpl;\n        this._s = source;\n        this._end = end;\n        this.rewind(start);\n    }\n    rewind(index) {\n        const impl = this._impl;\n        this._i = index;\n        this._cp1 = impl.at(this._s, this._end, index);\n        this._w1 = impl.width(this._cp1);\n        this._cp2 = impl.at(this._s, this._end, index + this._w1);\n        this._w2 = impl.width(this._cp2);\n        this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);\n        this._w3 = impl.width(this._cp3);\n        this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);\n    }\n    advance() {\n        if (this._cp1 !== -1) {\n            const impl = this._impl;\n            this._i += this._w1;\n            this._cp1 = this._cp2;\n            this._w1 = this._w2;\n            this._cp2 = this._cp3;\n            this._w2 = impl.width(this._cp2);\n            this._cp3 = this._cp4;\n            this._w3 = impl.width(this._cp3);\n            this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);\n        }\n    }\n    eat(cp) {\n        if (this._cp1 === cp) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    eat2(cp1, cp2) {\n        if (this._cp1 === cp1 && this._cp2 === cp2) {\n            this.advance();\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    eat3(cp1, cp2, cp3) {\n        if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {\n            this.advance();\n            this.advance();\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n}\n\nclass RegExpSyntaxError extends SyntaxError {\n    constructor(message, index) {\n        super(message);\n        this.index = index;\n    }\n}\nfunction newRegExpSyntaxError(srcCtx, flags, index, message) {\n    let source = \"\";\n    if (srcCtx.kind === \"literal\") {\n        const literal = srcCtx.source.slice(srcCtx.start, srcCtx.end);\n        if (literal) {\n            source = `: ${literal}`;\n        }\n    }\n    else if (srcCtx.kind === \"pattern\") {\n        const pattern = srcCtx.source.slice(srcCtx.start, srcCtx.end);\n        const flagsText = `${flags.unicode ? \"u\" : \"\"}${flags.unicodeSets ? \"v\" : \"\"}`;\n        source = `: /${pattern}/${flagsText}`;\n    }\n    return new RegExpSyntaxError(`Invalid regular expression${source}: ${message}`, index);\n}\n\nconst SYNTAX_CHARACTER = new Set([\n    CIRCUMFLEX_ACCENT,\n    DOLLAR_SIGN,\n    REVERSE_SOLIDUS,\n    FULL_STOP,\n    ASTERISK,\n    PLUS_SIGN,\n    QUESTION_MARK,\n    LEFT_PARENTHESIS,\n    RIGHT_PARENTHESIS,\n    LEFT_SQUARE_BRACKET,\n    RIGHT_SQUARE_BRACKET,\n    LEFT_CURLY_BRACKET,\n    RIGHT_CURLY_BRACKET,\n    VERTICAL_LINE,\n]);\nconst CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR_CHARACTER = new Set([\n    AMPERSAND,\n    EXCLAMATION_MARK,\n    NUMBER_SIGN,\n    DOLLAR_SIGN,\n    PERCENT_SIGN,\n    ASTERISK,\n    PLUS_SIGN,\n    COMMA,\n    FULL_STOP,\n    COLON,\n    SEMICOLON,\n    LESS_THAN_SIGN,\n    EQUALS_SIGN,\n    GREATER_THAN_SIGN,\n    QUESTION_MARK,\n    COMMERCIAL_AT,\n    CIRCUMFLEX_ACCENT,\n    GRAVE_ACCENT,\n    TILDE,\n]);\nconst CLASS_SET_SYNTAX_CHARACTER = new Set([\n    LEFT_PARENTHESIS,\n    RIGHT_PARENTHESIS,\n    LEFT_SQUARE_BRACKET,\n    RIGHT_SQUARE_BRACKET,\n    LEFT_CURLY_BRACKET,\n    RIGHT_CURLY_BRACKET,\n    SOLIDUS,\n    HYPHEN_MINUS,\n    REVERSE_SOLIDUS,\n    VERTICAL_LINE,\n]);\nconst CLASS_SET_RESERVED_PUNCTUATOR = new Set([\n    AMPERSAND,\n    HYPHEN_MINUS,\n    EXCLAMATION_MARK,\n    NUMBER_SIGN,\n    PERCENT_SIGN,\n    COMMA,\n    COLON,\n    SEMICOLON,\n    LESS_THAN_SIGN,\n    EQUALS_SIGN,\n    GREATER_THAN_SIGN,\n    COMMERCIAL_AT,\n    GRAVE_ACCENT,\n    TILDE,\n]);\nconst FLAG_PROP_TO_CODEPOINT = {\n    global: LATIN_SMALL_LETTER_G,\n    ignoreCase: LATIN_SMALL_LETTER_I,\n    multiline: LATIN_SMALL_LETTER_M,\n    unicode: LATIN_SMALL_LETTER_U,\n    sticky: LATIN_SMALL_LETTER_Y,\n    dotAll: LATIN_SMALL_LETTER_S,\n    hasIndices: LATIN_SMALL_LETTER_D,\n    unicodeSets: LATIN_SMALL_LETTER_V,\n};\nconst FLAG_CODEPOINT_TO_PROP = Object.fromEntries(Object.entries(FLAG_PROP_TO_CODEPOINT).map(([k, v]) => [v, k]));\nfunction isSyntaxCharacter(cp) {\n    return SYNTAX_CHARACTER.has(cp);\n}\nfunction isClassSetReservedDoublePunctuatorCharacter(cp) {\n    return CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR_CHARACTER.has(cp);\n}\nfunction isClassSetSyntaxCharacter(cp) {\n    return CLASS_SET_SYNTAX_CHARACTER.has(cp);\n}\nfunction isClassSetReservedPunctuator(cp) {\n    return CLASS_SET_RESERVED_PUNCTUATOR.has(cp);\n}\nfunction isIdentifierStartChar(cp) {\n    return isIdStart(cp) || cp === DOLLAR_SIGN || cp === LOW_LINE;\n}\nfunction isIdentifierPartChar(cp) {\n    return (isIdContinue(cp) ||\n        cp === DOLLAR_SIGN ||\n        cp === ZERO_WIDTH_NON_JOINER ||\n        cp === ZERO_WIDTH_JOINER);\n}\nfunction isUnicodePropertyNameCharacter(cp) {\n    return isLatinLetter(cp) || cp === LOW_LINE;\n}\nfunction isUnicodePropertyValueCharacter(cp) {\n    return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);\n}\nfunction isRegularExpressionModifier(ch) {\n    return (ch === LATIN_SMALL_LETTER_I ||\n        ch === LATIN_SMALL_LETTER_M ||\n        ch === LATIN_SMALL_LETTER_S);\n}\nclass RegExpValidator {\n    constructor(options) {\n        this._reader = new Reader();\n        this._unicodeMode = false;\n        this._unicodeSetsMode = false;\n        this._nFlag = false;\n        this._lastIntValue = 0;\n        this._lastRange = {\n            min: 0,\n            max: Number.POSITIVE_INFINITY,\n        };\n        this._lastStrValue = \"\";\n        this._lastAssertionIsQuantifiable = false;\n        this._numCapturingParens = 0;\n        this._backreferenceNames = new Set();\n        this._srcCtx = null;\n        this._options = options !== null && options !== void 0 ? options : {};\n        this._groupSpecifiers =\n            this.ecmaVersion >= 2025\n                ? new GroupSpecifiersAsES2025()\n                : new GroupSpecifiersAsES2018();\n    }\n    validateLiteral(source, start = 0, end = source.length) {\n        this._srcCtx = { source, start, end, kind: \"literal\" };\n        this._unicodeSetsMode = this._unicodeMode = this._nFlag = false;\n        this.reset(source, start, end);\n        this.onLiteralEnter(start);\n        if (this.eat(SOLIDUS) && this.eatRegExpBody() && this.eat(SOLIDUS)) {\n            const flagStart = this.index;\n            const unicode = source.includes(\"u\", flagStart);\n            const unicodeSets = source.includes(\"v\", flagStart);\n            this.validateFlagsInternal(source, flagStart, end);\n            this.validatePatternInternal(source, start + 1, flagStart - 1, {\n                unicode,\n                unicodeSets,\n            });\n        }\n        else if (start >= end) {\n            this.raise(\"Empty\");\n        }\n        else {\n            const c = String.fromCodePoint(this.currentCodePoint);\n            this.raise(`Unexpected character '${c}'`);\n        }\n        this.onLiteralLeave(start, end);\n    }\n    validateFlags(source, start = 0, end = source.length) {\n        this._srcCtx = { source, start, end, kind: \"flags\" };\n        this.validateFlagsInternal(source, start, end);\n    }\n    validatePattern(source, start = 0, end = source.length, uFlagOrFlags = undefined) {\n        this._srcCtx = { source, start, end, kind: \"pattern\" };\n        this.validatePatternInternal(source, start, end, uFlagOrFlags);\n    }\n    validatePatternInternal(source, start = 0, end = source.length, uFlagOrFlags = undefined) {\n        const mode = this._parseFlagsOptionToMode(uFlagOrFlags, end);\n        this._unicodeMode = mode.unicodeMode;\n        this._nFlag = mode.nFlag;\n        this._unicodeSetsMode = mode.unicodeSetsMode;\n        this.reset(source, start, end);\n        this.consumePattern();\n        if (!this._nFlag &&\n            this.ecmaVersion >= 2018 &&\n            !this._groupSpecifiers.isEmpty()) {\n            this._nFlag = true;\n            this.rewind(start);\n            this.consumePattern();\n        }\n    }\n    validateFlagsInternal(source, start, end) {\n        const flags = this.parseFlags(source, start, end);\n        this.onRegExpFlags(start, end, flags);\n    }\n    _parseFlagsOptionToMode(uFlagOrFlags, sourceEnd) {\n        let unicode = false;\n        let unicodeSets = false;\n        if (uFlagOrFlags && this.ecmaVersion >= 2015) {\n            if (typeof uFlagOrFlags === \"object\") {\n                unicode = Boolean(uFlagOrFlags.unicode);\n                if (this.ecmaVersion >= 2024) {\n                    unicodeSets = Boolean(uFlagOrFlags.unicodeSets);\n                }\n            }\n            else {\n                unicode = uFlagOrFlags;\n            }\n        }\n        if (unicode && unicodeSets) {\n            this.raise(\"Invalid regular expression flags\", {\n                index: sourceEnd + 1,\n                unicode,\n                unicodeSets,\n            });\n        }\n        const unicodeMode = unicode || unicodeSets;\n        const nFlag = (unicode && this.ecmaVersion >= 2018) ||\n            unicodeSets ||\n            Boolean(this._options.strict && this.ecmaVersion >= 2023);\n        const unicodeSetsMode = unicodeSets;\n        return { unicodeMode, nFlag, unicodeSetsMode };\n    }\n    get strict() {\n        return Boolean(this._options.strict) || this._unicodeMode;\n    }\n    get ecmaVersion() {\n        var _a;\n        return (_a = this._options.ecmaVersion) !== null && _a !== void 0 ? _a : latestEcmaVersion;\n    }\n    onLiteralEnter(start) {\n        if (this._options.onLiteralEnter) {\n            this._options.onLiteralEnter(start);\n        }\n    }\n    onLiteralLeave(start, end) {\n        if (this._options.onLiteralLeave) {\n            this._options.onLiteralLeave(start, end);\n        }\n    }\n    onRegExpFlags(start, end, flags) {\n        if (this._options.onRegExpFlags) {\n            this._options.onRegExpFlags(start, end, flags);\n        }\n        if (this._options.onFlags) {\n            this._options.onFlags(start, end, flags.global, flags.ignoreCase, flags.multiline, flags.unicode, flags.sticky, flags.dotAll, flags.hasIndices);\n        }\n    }\n    onPatternEnter(start) {\n        if (this._options.onPatternEnter) {\n            this._options.onPatternEnter(start);\n        }\n    }\n    onPatternLeave(start, end) {\n        if (this._options.onPatternLeave) {\n            this._options.onPatternLeave(start, end);\n        }\n    }\n    onDisjunctionEnter(start) {\n        if (this._options.onDisjunctionEnter) {\n            this._options.onDisjunctionEnter(start);\n        }\n    }\n    onDisjunctionLeave(start, end) {\n        if (this._options.onDisjunctionLeave) {\n            this._options.onDisjunctionLeave(start, end);\n        }\n    }\n    onAlternativeEnter(start, index) {\n        if (this._options.onAlternativeEnter) {\n            this._options.onAlternativeEnter(start, index);\n        }\n    }\n    onAlternativeLeave(start, end, index) {\n        if (this._options.onAlternativeLeave) {\n            this._options.onAlternativeLeave(start, end, index);\n        }\n    }\n    onGroupEnter(start) {\n        if (this._options.onGroupEnter) {\n            this._options.onGroupEnter(start);\n        }\n    }\n    onGroupLeave(start, end) {\n        if (this._options.onGroupLeave) {\n            this._options.onGroupLeave(start, end);\n        }\n    }\n    onModifiersEnter(start) {\n        if (this._options.onModifiersEnter) {\n            this._options.onModifiersEnter(start);\n        }\n    }\n    onModifiersLeave(start, end) {\n        if (this._options.onModifiersLeave) {\n            this._options.onModifiersLeave(start, end);\n        }\n    }\n    onAddModifiers(start, end, flags) {\n        if (this._options.onAddModifiers) {\n            this._options.onAddModifiers(start, end, flags);\n        }\n    }\n    onRemoveModifiers(start, end, flags) {\n        if (this._options.onRemoveModifiers) {\n            this._options.onRemoveModifiers(start, end, flags);\n        }\n    }\n    onCapturingGroupEnter(start, name) {\n        if (this._options.onCapturingGroupEnter) {\n            this._options.onCapturingGroupEnter(start, name);\n        }\n    }\n    onCapturingGroupLeave(start, end, name) {\n        if (this._options.onCapturingGroupLeave) {\n            this._options.onCapturingGroupLeave(start, end, name);\n        }\n    }\n    onQuantifier(start, end, min, max, greedy) {\n        if (this._options.onQuantifier) {\n            this._options.onQuantifier(start, end, min, max, greedy);\n        }\n    }\n    onLookaroundAssertionEnter(start, kind, negate) {\n        if (this._options.onLookaroundAssertionEnter) {\n            this._options.onLookaroundAssertionEnter(start, kind, negate);\n        }\n    }\n    onLookaroundAssertionLeave(start, end, kind, negate) {\n        if (this._options.onLookaroundAssertionLeave) {\n            this._options.onLookaroundAssertionLeave(start, end, kind, negate);\n        }\n    }\n    onEdgeAssertion(start, end, kind) {\n        if (this._options.onEdgeAssertion) {\n            this._options.onEdgeAssertion(start, end, kind);\n        }\n    }\n    onWordBoundaryAssertion(start, end, kind, negate) {\n        if (this._options.onWordBoundaryAssertion) {\n            this._options.onWordBoundaryAssertion(start, end, kind, negate);\n        }\n    }\n    onAnyCharacterSet(start, end, kind) {\n        if (this._options.onAnyCharacterSet) {\n            this._options.onAnyCharacterSet(start, end, kind);\n        }\n    }\n    onEscapeCharacterSet(start, end, kind, negate) {\n        if (this._options.onEscapeCharacterSet) {\n            this._options.onEscapeCharacterSet(start, end, kind, negate);\n        }\n    }\n    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings) {\n        if (this._options.onUnicodePropertyCharacterSet) {\n            this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings);\n        }\n    }\n    onCharacter(start, end, value) {\n        if (this._options.onCharacter) {\n            this._options.onCharacter(start, end, value);\n        }\n    }\n    onBackreference(start, end, ref) {\n        if (this._options.onBackreference) {\n            this._options.onBackreference(start, end, ref);\n        }\n    }\n    onCharacterClassEnter(start, negate, unicodeSets) {\n        if (this._options.onCharacterClassEnter) {\n            this._options.onCharacterClassEnter(start, negate, unicodeSets);\n        }\n    }\n    onCharacterClassLeave(start, end, negate) {\n        if (this._options.onCharacterClassLeave) {\n            this._options.onCharacterClassLeave(start, end, negate);\n        }\n    }\n    onCharacterClassRange(start, end, min, max) {\n        if (this._options.onCharacterClassRange) {\n            this._options.onCharacterClassRange(start, end, min, max);\n        }\n    }\n    onClassIntersection(start, end) {\n        if (this._options.onClassIntersection) {\n            this._options.onClassIntersection(start, end);\n        }\n    }\n    onClassSubtraction(start, end) {\n        if (this._options.onClassSubtraction) {\n            this._options.onClassSubtraction(start, end);\n        }\n    }\n    onClassStringDisjunctionEnter(start) {\n        if (this._options.onClassStringDisjunctionEnter) {\n            this._options.onClassStringDisjunctionEnter(start);\n        }\n    }\n    onClassStringDisjunctionLeave(start, end) {\n        if (this._options.onClassStringDisjunctionLeave) {\n            this._options.onClassStringDisjunctionLeave(start, end);\n        }\n    }\n    onStringAlternativeEnter(start, index) {\n        if (this._options.onStringAlternativeEnter) {\n            this._options.onStringAlternativeEnter(start, index);\n        }\n    }\n    onStringAlternativeLeave(start, end, index) {\n        if (this._options.onStringAlternativeLeave) {\n            this._options.onStringAlternativeLeave(start, end, index);\n        }\n    }\n    get index() {\n        return this._reader.index;\n    }\n    get currentCodePoint() {\n        return this._reader.currentCodePoint;\n    }\n    get nextCodePoint() {\n        return this._reader.nextCodePoint;\n    }\n    get nextCodePoint2() {\n        return this._reader.nextCodePoint2;\n    }\n    get nextCodePoint3() {\n        return this._reader.nextCodePoint3;\n    }\n    reset(source, start, end) {\n        this._reader.reset(source, start, end, this._unicodeMode);\n    }\n    rewind(index) {\n        this._reader.rewind(index);\n    }\n    advance() {\n        this._reader.advance();\n    }\n    eat(cp) {\n        return this._reader.eat(cp);\n    }\n    eat2(cp1, cp2) {\n        return this._reader.eat2(cp1, cp2);\n    }\n    eat3(cp1, cp2, cp3) {\n        return this._reader.eat3(cp1, cp2, cp3);\n    }\n    raise(message, context) {\n        var _a, _b, _c;\n        throw newRegExpSyntaxError(this._srcCtx, {\n            unicode: (_a = context === null || context === void 0 ? void 0 : context.unicode) !== null && _a !== void 0 ? _a : (this._unicodeMode && !this._unicodeSetsMode),\n            unicodeSets: (_b = context === null || context === void 0 ? void 0 : context.unicodeSets) !== null && _b !== void 0 ? _b : this._unicodeSetsMode,\n        }, (_c = context === null || context === void 0 ? void 0 : context.index) !== null && _c !== void 0 ? _c : this.index, message);\n    }\n    eatRegExpBody() {\n        const start = this.index;\n        let inClass = false;\n        let escaped = false;\n        for (;;) {\n            const cp = this.currentCodePoint;\n            if (cp === -1 || isLineTerminator(cp)) {\n                const kind = inClass ? \"character class\" : \"regular expression\";\n                this.raise(`Unterminated ${kind}`);\n            }\n            if (escaped) {\n                escaped = false;\n            }\n            else if (cp === REVERSE_SOLIDUS) {\n                escaped = true;\n            }\n            else if (cp === LEFT_SQUARE_BRACKET) {\n                inClass = true;\n            }\n            else if (cp === RIGHT_SQUARE_BRACKET) {\n                inClass = false;\n            }\n            else if ((cp === SOLIDUS && !inClass) ||\n                (cp === ASTERISK && this.index === start)) {\n                break;\n            }\n            this.advance();\n        }\n        return this.index !== start;\n    }\n    consumePattern() {\n        const start = this.index;\n        this._numCapturingParens = this.countCapturingParens();\n        this._groupSpecifiers.clear();\n        this._backreferenceNames.clear();\n        this.onPatternEnter(start);\n        this.consumeDisjunction();\n        const cp = this.currentCodePoint;\n        if (this.currentCodePoint !== -1) {\n            if (cp === RIGHT_PARENTHESIS) {\n                this.raise(\"Unmatched ')'\");\n            }\n            if (cp === REVERSE_SOLIDUS) {\n                this.raise(\"\\\\ at end of pattern\");\n            }\n            if (cp === RIGHT_SQUARE_BRACKET || cp === RIGHT_CURLY_BRACKET) {\n                this.raise(\"Lone quantifier brackets\");\n            }\n            const c = String.fromCodePoint(cp);\n            this.raise(`Unexpected character '${c}'`);\n        }\n        for (const name of this._backreferenceNames) {\n            if (!this._groupSpecifiers.hasInPattern(name)) {\n                this.raise(\"Invalid named capture referenced\");\n            }\n        }\n        this.onPatternLeave(start, this.index);\n    }\n    countCapturingParens() {\n        const start = this.index;\n        let inClass = false;\n        let escaped = false;\n        let count = 0;\n        let cp = 0;\n        while ((cp = this.currentCodePoint) !== -1) {\n            if (escaped) {\n                escaped = false;\n            }\n            else if (cp === REVERSE_SOLIDUS) {\n                escaped = true;\n            }\n            else if (cp === LEFT_SQUARE_BRACKET) {\n                inClass = true;\n            }\n            else if (cp === RIGHT_SQUARE_BRACKET) {\n                inClass = false;\n            }\n            else if (cp === LEFT_PARENTHESIS &&\n                !inClass &&\n                (this.nextCodePoint !== QUESTION_MARK ||\n                    (this.nextCodePoint2 === LESS_THAN_SIGN &&\n                        this.nextCodePoint3 !== EQUALS_SIGN &&\n                        this.nextCodePoint3 !== EXCLAMATION_MARK))) {\n                count += 1;\n            }\n            this.advance();\n        }\n        this.rewind(start);\n        return count;\n    }\n    consumeDisjunction() {\n        const start = this.index;\n        let i = 0;\n        this._groupSpecifiers.enterDisjunction();\n        this.onDisjunctionEnter(start);\n        do {\n            this.consumeAlternative(i++);\n        } while (this.eat(VERTICAL_LINE));\n        if (this.consumeQuantifier(true)) {\n            this.raise(\"Nothing to repeat\");\n        }\n        if (this.eat(LEFT_CURLY_BRACKET)) {\n            this.raise(\"Lone quantifier brackets\");\n        }\n        this.onDisjunctionLeave(start, this.index);\n        this._groupSpecifiers.leaveDisjunction();\n    }\n    consumeAlternative(i) {\n        const start = this.index;\n        this._groupSpecifiers.enterAlternative(i);\n        this.onAlternativeEnter(start, i);\n        while (this.currentCodePoint !== -1 && this.consumeTerm()) {\n        }\n        this.onAlternativeLeave(start, this.index, i);\n    }\n    consumeTerm() {\n        if (this._unicodeMode || this.strict) {\n            return (this.consumeAssertion() ||\n                (this.consumeAtom() && this.consumeOptionalQuantifier()));\n        }\n        return ((this.consumeAssertion() &&\n            (!this._lastAssertionIsQuantifiable ||\n                this.consumeOptionalQuantifier())) ||\n            (this.consumeExtendedAtom() && this.consumeOptionalQuantifier()));\n    }\n    consumeOptionalQuantifier() {\n        this.consumeQuantifier();\n        return true;\n    }\n    consumeAssertion() {\n        const start = this.index;\n        this._lastAssertionIsQuantifiable = false;\n        if (this.eat(CIRCUMFLEX_ACCENT)) {\n            this.onEdgeAssertion(start, this.index, \"start\");\n            return true;\n        }\n        if (this.eat(DOLLAR_SIGN)) {\n            this.onEdgeAssertion(start, this.index, \"end\");\n            return true;\n        }\n        if (this.eat2(REVERSE_SOLIDUS, LATIN_CAPITAL_LETTER_B)) {\n            this.onWordBoundaryAssertion(start, this.index, \"word\", true);\n            return true;\n        }\n        if (this.eat2(REVERSE_SOLIDUS, LATIN_SMALL_LETTER_B)) {\n            this.onWordBoundaryAssertion(start, this.index, \"word\", false);\n            return true;\n        }\n        if (this.eat2(LEFT_PARENTHESIS, QUESTION_MARK)) {\n            const lookbehind = this.ecmaVersion >= 2018 && this.eat(LESS_THAN_SIGN);\n            let negate = false;\n            if (this.eat(EQUALS_SIGN) ||\n                (negate = this.eat(EXCLAMATION_MARK))) {\n                const kind = lookbehind ? \"lookbehind\" : \"lookahead\";\n                this.onLookaroundAssertionEnter(start, kind, negate);\n                this.consumeDisjunction();\n                if (!this.eat(RIGHT_PARENTHESIS)) {\n                    this.raise(\"Unterminated group\");\n                }\n                this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;\n                this.onLookaroundAssertionLeave(start, this.index, kind, negate);\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeQuantifier(noConsume = false) {\n        const start = this.index;\n        let min = 0;\n        let max = 0;\n        let greedy = false;\n        if (this.eat(ASTERISK)) {\n            min = 0;\n            max = Number.POSITIVE_INFINITY;\n        }\n        else if (this.eat(PLUS_SIGN)) {\n            min = 1;\n            max = Number.POSITIVE_INFINITY;\n        }\n        else if (this.eat(QUESTION_MARK)) {\n            min = 0;\n            max = 1;\n        }\n        else if (this.eatBracedQuantifier(noConsume)) {\n            ({ min, max } = this._lastRange);\n        }\n        else {\n            return false;\n        }\n        greedy = !this.eat(QUESTION_MARK);\n        if (!noConsume) {\n            this.onQuantifier(start, this.index, min, max, greedy);\n        }\n        return true;\n    }\n    eatBracedQuantifier(noError) {\n        const start = this.index;\n        if (this.eat(LEFT_CURLY_BRACKET)) {\n            if (this.eatDecimalDigits()) {\n                const min = this._lastIntValue;\n                let max = min;\n                if (this.eat(COMMA)) {\n                    max = this.eatDecimalDigits()\n                        ? this._lastIntValue\n                        : Number.POSITIVE_INFINITY;\n                }\n                if (this.eat(RIGHT_CURLY_BRACKET)) {\n                    if (!noError && max < min) {\n                        this.raise(\"numbers out of order in {} quantifier\");\n                    }\n                    this._lastRange = { min, max };\n                    return true;\n                }\n            }\n            if (!noError && (this._unicodeMode || this.strict)) {\n                this.raise(\"Incomplete quantifier\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeAtom() {\n        return (this.consumePatternCharacter() ||\n            this.consumeDot() ||\n            this.consumeReverseSolidusAtomEscape() ||\n            Boolean(this.consumeCharacterClass()) ||\n            this.consumeCapturingGroup() ||\n            this.consumeUncapturingGroup());\n    }\n    consumeDot() {\n        if (this.eat(FULL_STOP)) {\n            this.onAnyCharacterSet(this.index - 1, this.index, \"any\");\n            return true;\n        }\n        return false;\n    }\n    consumeReverseSolidusAtomEscape() {\n        const start = this.index;\n        if (this.eat(REVERSE_SOLIDUS)) {\n            if (this.consumeAtomEscape()) {\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeUncapturingGroup() {\n        const start = this.index;\n        if (this.eat2(LEFT_PARENTHESIS, QUESTION_MARK)) {\n            this.onGroupEnter(start);\n            if (this.ecmaVersion >= 2025) {\n                this.consumeModifiers();\n            }\n            if (!this.eat(COLON)) {\n                this.rewind(start + 1);\n                this.raise(\"Invalid group\");\n            }\n            this.consumeDisjunction();\n            if (!this.eat(RIGHT_PARENTHESIS)) {\n                this.raise(\"Unterminated group\");\n            }\n            this.onGroupLeave(start, this.index);\n            return true;\n        }\n        return false;\n    }\n    consumeModifiers() {\n        const start = this.index;\n        const hasAddModifiers = this.eatModifiers();\n        const addModifiersEnd = this.index;\n        const hasHyphen = this.eat(HYPHEN_MINUS);\n        if (!hasAddModifiers && !hasHyphen) {\n            return false;\n        }\n        this.onModifiersEnter(start);\n        const addModifiers = this.parseModifiers(start, addModifiersEnd);\n        this.onAddModifiers(start, addModifiersEnd, addModifiers);\n        if (hasHyphen) {\n            const modifiersStart = this.index;\n            if (!this.eatModifiers() &&\n                !hasAddModifiers &&\n                this.currentCodePoint === COLON) {\n                this.raise(\"Invalid empty flags\");\n            }\n            const modifiers = this.parseModifiers(modifiersStart, this.index);\n            for (const [flagName] of Object.entries(modifiers).filter(([, enable]) => enable)) {\n                if (addModifiers[flagName]) {\n                    this.raise(`Duplicated flag '${String.fromCodePoint(FLAG_PROP_TO_CODEPOINT[flagName])}'`);\n                }\n            }\n            this.onRemoveModifiers(modifiersStart, this.index, modifiers);\n        }\n        this.onModifiersLeave(start, this.index);\n        return true;\n    }\n    consumeCapturingGroup() {\n        const start = this.index;\n        if (this.eat(LEFT_PARENTHESIS)) {\n            let name = null;\n            if (this.ecmaVersion >= 2018) {\n                if (this.consumeGroupSpecifier()) {\n                    name = this._lastStrValue;\n                }\n                else if (this.currentCodePoint === QUESTION_MARK) {\n                    this.rewind(start);\n                    return false;\n                }\n            }\n            else if (this.currentCodePoint === QUESTION_MARK) {\n                this.rewind(start);\n                return false;\n            }\n            this.onCapturingGroupEnter(start, name);\n            this.consumeDisjunction();\n            if (!this.eat(RIGHT_PARENTHESIS)) {\n                this.raise(\"Unterminated group\");\n            }\n            this.onCapturingGroupLeave(start, this.index, name);\n            return true;\n        }\n        return false;\n    }\n    consumeExtendedAtom() {\n        return (this.consumeDot() ||\n            this.consumeReverseSolidusAtomEscape() ||\n            this.consumeReverseSolidusFollowedByC() ||\n            Boolean(this.consumeCharacterClass()) ||\n            this.consumeCapturingGroup() ||\n            this.consumeUncapturingGroup() ||\n            this.consumeInvalidBracedQuantifier() ||\n            this.consumeExtendedPatternCharacter());\n    }\n    consumeReverseSolidusFollowedByC() {\n        const start = this.index;\n        if (this.currentCodePoint === REVERSE_SOLIDUS &&\n            this.nextCodePoint === LATIN_SMALL_LETTER_C) {\n            this._lastIntValue = this.currentCodePoint;\n            this.advance();\n            this.onCharacter(start, this.index, REVERSE_SOLIDUS);\n            return true;\n        }\n        return false;\n    }\n    consumeInvalidBracedQuantifier() {\n        if (this.eatBracedQuantifier(true)) {\n            this.raise(\"Nothing to repeat\");\n        }\n        return false;\n    }\n    consumePatternCharacter() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== -1 && !isSyntaxCharacter(cp)) {\n            this.advance();\n            this.onCharacter(start, this.index, cp);\n            return true;\n        }\n        return false;\n    }\n    consumeExtendedPatternCharacter() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== -1 &&\n            cp !== CIRCUMFLEX_ACCENT &&\n            cp !== DOLLAR_SIGN &&\n            cp !== REVERSE_SOLIDUS &&\n            cp !== FULL_STOP &&\n            cp !== ASTERISK &&\n            cp !== PLUS_SIGN &&\n            cp !== QUESTION_MARK &&\n            cp !== LEFT_PARENTHESIS &&\n            cp !== RIGHT_PARENTHESIS &&\n            cp !== LEFT_SQUARE_BRACKET &&\n            cp !== VERTICAL_LINE) {\n            this.advance();\n            this.onCharacter(start, this.index, cp);\n            return true;\n        }\n        return false;\n    }\n    consumeGroupSpecifier() {\n        const start = this.index;\n        if (this.eat(QUESTION_MARK)) {\n            if (this.eatGroupName()) {\n                if (!this._groupSpecifiers.hasInScope(this._lastStrValue)) {\n                    this._groupSpecifiers.addToScope(this._lastStrValue);\n                    return true;\n                }\n                this.raise(\"Duplicate capture group name\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeAtomEscape() {\n        if (this.consumeBackreference() ||\n            this.consumeCharacterClassEscape() ||\n            this.consumeCharacterEscape() ||\n            (this._nFlag && this.consumeKGroupName())) {\n            return true;\n        }\n        if (this.strict || this._unicodeMode) {\n            this.raise(\"Invalid escape\");\n        }\n        return false;\n    }\n    consumeBackreference() {\n        const start = this.index;\n        if (this.eatDecimalEscape()) {\n            const n = this._lastIntValue;\n            if (n <= this._numCapturingParens) {\n                this.onBackreference(start - 1, this.index, n);\n                return true;\n            }\n            if (this.strict || this._unicodeMode) {\n                this.raise(\"Invalid escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeCharacterClassEscape() {\n        var _a;\n        const start = this.index;\n        if (this.eat(LATIN_SMALL_LETTER_D)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"digit\", false);\n            return {};\n        }\n        if (this.eat(LATIN_CAPITAL_LETTER_D)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"digit\", true);\n            return {};\n        }\n        if (this.eat(LATIN_SMALL_LETTER_S)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"space\", false);\n            return {};\n        }\n        if (this.eat(LATIN_CAPITAL_LETTER_S)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"space\", true);\n            return {};\n        }\n        if (this.eat(LATIN_SMALL_LETTER_W)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"word\", false);\n            return {};\n        }\n        if (this.eat(LATIN_CAPITAL_LETTER_W)) {\n            this._lastIntValue = -1;\n            this.onEscapeCharacterSet(start - 1, this.index, \"word\", true);\n            return {};\n        }\n        let negate = false;\n        if (this._unicodeMode &&\n            this.ecmaVersion >= 2018 &&\n            (this.eat(LATIN_SMALL_LETTER_P) ||\n                (negate = this.eat(LATIN_CAPITAL_LETTER_P)))) {\n            this._lastIntValue = -1;\n            let result = null;\n            if (this.eat(LEFT_CURLY_BRACKET) &&\n                (result = this.eatUnicodePropertyValueExpression()) &&\n                this.eat(RIGHT_CURLY_BRACKET)) {\n                if (negate && result.strings) {\n                    this.raise(\"Invalid property name\");\n                }\n                this.onUnicodePropertyCharacterSet(start - 1, this.index, \"property\", result.key, result.value, negate, (_a = result.strings) !== null && _a !== void 0 ? _a : false);\n                return { mayContainStrings: result.strings };\n            }\n            this.raise(\"Invalid property name\");\n        }\n        return null;\n    }\n    consumeCharacterEscape() {\n        const start = this.index;\n        if (this.eatControlEscape() ||\n            this.eatCControlLetter() ||\n            this.eatZero() ||\n            this.eatHexEscapeSequence() ||\n            this.eatRegExpUnicodeEscapeSequence() ||\n            (!this.strict &&\n                !this._unicodeMode &&\n                this.eatLegacyOctalEscapeSequence()) ||\n            this.eatIdentityEscape()) {\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        return false;\n    }\n    consumeKGroupName() {\n        const start = this.index;\n        if (this.eat(LATIN_SMALL_LETTER_K)) {\n            if (this.eatGroupName()) {\n                const groupName = this._lastStrValue;\n                this._backreferenceNames.add(groupName);\n                this.onBackreference(start - 1, this.index, groupName);\n                return true;\n            }\n            this.raise(\"Invalid named reference\");\n        }\n        return false;\n    }\n    consumeCharacterClass() {\n        const start = this.index;\n        if (this.eat(LEFT_SQUARE_BRACKET)) {\n            const negate = this.eat(CIRCUMFLEX_ACCENT);\n            this.onCharacterClassEnter(start, negate, this._unicodeSetsMode);\n            const result = this.consumeClassContents();\n            if (!this.eat(RIGHT_SQUARE_BRACKET)) {\n                if (this.currentCodePoint === -1) {\n                    this.raise(\"Unterminated character class\");\n                }\n                this.raise(\"Invalid character in character class\");\n            }\n            if (negate && result.mayContainStrings) {\n                this.raise(\"Negated character class may contain strings\");\n            }\n            this.onCharacterClassLeave(start, this.index, negate);\n            return result;\n        }\n        return null;\n    }\n    consumeClassContents() {\n        if (this._unicodeSetsMode) {\n            if (this.currentCodePoint === RIGHT_SQUARE_BRACKET) {\n                return {};\n            }\n            const result = this.consumeClassSetExpression();\n            return result;\n        }\n        const strict = this.strict || this._unicodeMode;\n        for (;;) {\n            const rangeStart = this.index;\n            if (!this.consumeClassAtom()) {\n                break;\n            }\n            const min = this._lastIntValue;\n            if (!this.eat(HYPHEN_MINUS)) {\n                continue;\n            }\n            this.onCharacter(this.index - 1, this.index, HYPHEN_MINUS);\n            if (!this.consumeClassAtom()) {\n                break;\n            }\n            const max = this._lastIntValue;\n            if (min === -1 || max === -1) {\n                if (strict) {\n                    this.raise(\"Invalid character class\");\n                }\n                continue;\n            }\n            if (min > max) {\n                this.raise(\"Range out of order in character class\");\n            }\n            this.onCharacterClassRange(rangeStart, this.index, min, max);\n        }\n        return {};\n    }\n    consumeClassAtom() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== -1 &&\n            cp !== REVERSE_SOLIDUS &&\n            cp !== RIGHT_SQUARE_BRACKET) {\n            this.advance();\n            this._lastIntValue = cp;\n            this.onCharacter(start, this.index, this._lastIntValue);\n            return true;\n        }\n        if (this.eat(REVERSE_SOLIDUS)) {\n            if (this.consumeClassEscape()) {\n                return true;\n            }\n            if (!this.strict &&\n                this.currentCodePoint === LATIN_SMALL_LETTER_C) {\n                this._lastIntValue = REVERSE_SOLIDUS;\n                this.onCharacter(start, this.index, this._lastIntValue);\n                return true;\n            }\n            if (this.strict || this._unicodeMode) {\n                this.raise(\"Invalid escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    consumeClassEscape() {\n        const start = this.index;\n        if (this.eat(LATIN_SMALL_LETTER_B)) {\n            this._lastIntValue = BACKSPACE;\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        if (this._unicodeMode && this.eat(HYPHEN_MINUS)) {\n            this._lastIntValue = HYPHEN_MINUS;\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        let cp = 0;\n        if (!this.strict &&\n            !this._unicodeMode &&\n            this.currentCodePoint === LATIN_SMALL_LETTER_C &&\n            (isDecimalDigit((cp = this.nextCodePoint)) || cp === LOW_LINE)) {\n            this.advance();\n            this.advance();\n            this._lastIntValue = cp % 0x20;\n            this.onCharacter(start - 1, this.index, this._lastIntValue);\n            return true;\n        }\n        return (Boolean(this.consumeCharacterClassEscape()) ||\n            this.consumeCharacterEscape());\n    }\n    consumeClassSetExpression() {\n        const start = this.index;\n        let mayContainStrings = false;\n        let result = null;\n        if (this.consumeClassSetCharacter()) {\n            if (this.consumeClassSetRangeFromOperator(start)) {\n                this.consumeClassUnionRight({});\n                return {};\n            }\n            mayContainStrings = false;\n        }\n        else if ((result = this.consumeClassSetOperand())) {\n            mayContainStrings = result.mayContainStrings;\n        }\n        else {\n            const cp = this.currentCodePoint;\n            if (cp === REVERSE_SOLIDUS) {\n                this.advance();\n                this.raise(\"Invalid escape\");\n            }\n            if (cp === this.nextCodePoint &&\n                isClassSetReservedDoublePunctuatorCharacter(cp)) {\n                this.raise(\"Invalid set operation in character class\");\n            }\n            this.raise(\"Invalid character in character class\");\n        }\n        if (this.eat2(AMPERSAND, AMPERSAND)) {\n            while (this.currentCodePoint !== AMPERSAND &&\n                (result = this.consumeClassSetOperand())) {\n                this.onClassIntersection(start, this.index);\n                if (!result.mayContainStrings) {\n                    mayContainStrings = false;\n                }\n                if (this.eat2(AMPERSAND, AMPERSAND)) {\n                    continue;\n                }\n                return { mayContainStrings };\n            }\n            this.raise(\"Invalid character in character class\");\n        }\n        if (this.eat2(HYPHEN_MINUS, HYPHEN_MINUS)) {\n            while (this.consumeClassSetOperand()) {\n                this.onClassSubtraction(start, this.index);\n                if (this.eat2(HYPHEN_MINUS, HYPHEN_MINUS)) {\n                    continue;\n                }\n                return { mayContainStrings };\n            }\n            this.raise(\"Invalid character in character class\");\n        }\n        return this.consumeClassUnionRight({ mayContainStrings });\n    }\n    consumeClassUnionRight(leftResult) {\n        let mayContainStrings = leftResult.mayContainStrings;\n        for (;;) {\n            const start = this.index;\n            if (this.consumeClassSetCharacter()) {\n                this.consumeClassSetRangeFromOperator(start);\n                continue;\n            }\n            const result = this.consumeClassSetOperand();\n            if (result) {\n                if (result.mayContainStrings) {\n                    mayContainStrings = true;\n                }\n                continue;\n            }\n            break;\n        }\n        return { mayContainStrings };\n    }\n    consumeClassSetRangeFromOperator(start) {\n        const currentStart = this.index;\n        const min = this._lastIntValue;\n        if (this.eat(HYPHEN_MINUS)) {\n            if (this.consumeClassSetCharacter()) {\n                const max = this._lastIntValue;\n                if (min === -1 || max === -1) {\n                    this.raise(\"Invalid character class\");\n                }\n                if (min > max) {\n                    this.raise(\"Range out of order in character class\");\n                }\n                this.onCharacterClassRange(start, this.index, min, max);\n                return true;\n            }\n            this.rewind(currentStart);\n        }\n        return false;\n    }\n    consumeClassSetOperand() {\n        let result = null;\n        if ((result = this.consumeNestedClass())) {\n            return result;\n        }\n        if ((result = this.consumeClassStringDisjunction())) {\n            return result;\n        }\n        if (this.consumeClassSetCharacter()) {\n            return {};\n        }\n        return null;\n    }\n    consumeNestedClass() {\n        const start = this.index;\n        if (this.eat(LEFT_SQUARE_BRACKET)) {\n            const negate = this.eat(CIRCUMFLEX_ACCENT);\n            this.onCharacterClassEnter(start, negate, true);\n            const result = this.consumeClassContents();\n            if (!this.eat(RIGHT_SQUARE_BRACKET)) {\n                this.raise(\"Unterminated character class\");\n            }\n            if (negate && result.mayContainStrings) {\n                this.raise(\"Negated character class may contain strings\");\n            }\n            this.onCharacterClassLeave(start, this.index, negate);\n            return result;\n        }\n        if (this.eat(REVERSE_SOLIDUS)) {\n            const result = this.consumeCharacterClassEscape();\n            if (result) {\n                return result;\n            }\n            this.rewind(start);\n        }\n        return null;\n    }\n    consumeClassStringDisjunction() {\n        const start = this.index;\n        if (this.eat3(REVERSE_SOLIDUS, LATIN_SMALL_LETTER_Q, LEFT_CURLY_BRACKET)) {\n            this.onClassStringDisjunctionEnter(start);\n            let i = 0;\n            let mayContainStrings = false;\n            do {\n                if (this.consumeClassString(i++).mayContainStrings) {\n                    mayContainStrings = true;\n                }\n            } while (this.eat(VERTICAL_LINE));\n            if (this.eat(RIGHT_CURLY_BRACKET)) {\n                this.onClassStringDisjunctionLeave(start, this.index);\n                return { mayContainStrings };\n            }\n            this.raise(\"Unterminated class string disjunction\");\n        }\n        return null;\n    }\n    consumeClassString(i) {\n        const start = this.index;\n        let count = 0;\n        this.onStringAlternativeEnter(start, i);\n        while (this.currentCodePoint !== -1 &&\n            this.consumeClassSetCharacter()) {\n            count++;\n        }\n        this.onStringAlternativeLeave(start, this.index, i);\n        return { mayContainStrings: count !== 1 };\n    }\n    consumeClassSetCharacter() {\n        const start = this.index;\n        const cp = this.currentCodePoint;\n        if (cp !== this.nextCodePoint ||\n            !isClassSetReservedDoublePunctuatorCharacter(cp)) {\n            if (cp !== -1 && !isClassSetSyntaxCharacter(cp)) {\n                this._lastIntValue = cp;\n                this.advance();\n                this.onCharacter(start, this.index, this._lastIntValue);\n                return true;\n            }\n        }\n        if (this.eat(REVERSE_SOLIDUS)) {\n            if (this.consumeCharacterEscape()) {\n                return true;\n            }\n            if (isClassSetReservedPunctuator(this.currentCodePoint)) {\n                this._lastIntValue = this.currentCodePoint;\n                this.advance();\n                this.onCharacter(start, this.index, this._lastIntValue);\n                return true;\n            }\n            if (this.eat(LATIN_SMALL_LETTER_B)) {\n                this._lastIntValue = BACKSPACE;\n                this.onCharacter(start, this.index, this._lastIntValue);\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatGroupName() {\n        if (this.eat(LESS_THAN_SIGN)) {\n            if (this.eatRegExpIdentifierName() && this.eat(GREATER_THAN_SIGN)) {\n                return true;\n            }\n            this.raise(\"Invalid capture group name\");\n        }\n        return false;\n    }\n    eatRegExpIdentifierName() {\n        if (this.eatRegExpIdentifierStart()) {\n            this._lastStrValue = String.fromCodePoint(this._lastIntValue);\n            while (this.eatRegExpIdentifierPart()) {\n                this._lastStrValue += String.fromCodePoint(this._lastIntValue);\n            }\n            return true;\n        }\n        return false;\n    }\n    eatRegExpIdentifierStart() {\n        const start = this.index;\n        const forceUFlag = !this._unicodeMode && this.ecmaVersion >= 2020;\n        let cp = this.currentCodePoint;\n        this.advance();\n        if (cp === REVERSE_SOLIDUS &&\n            this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {\n            cp = this._lastIntValue;\n        }\n        else if (forceUFlag &&\n            isLeadSurrogate(cp) &&\n            isTrailSurrogate(this.currentCodePoint)) {\n            cp = combineSurrogatePair(cp, this.currentCodePoint);\n            this.advance();\n        }\n        if (isIdentifierStartChar(cp)) {\n            this._lastIntValue = cp;\n            return true;\n        }\n        if (this.index !== start) {\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatRegExpIdentifierPart() {\n        const start = this.index;\n        const forceUFlag = !this._unicodeMode && this.ecmaVersion >= 2020;\n        let cp = this.currentCodePoint;\n        this.advance();\n        if (cp === REVERSE_SOLIDUS &&\n            this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {\n            cp = this._lastIntValue;\n        }\n        else if (forceUFlag &&\n            isLeadSurrogate(cp) &&\n            isTrailSurrogate(this.currentCodePoint)) {\n            cp = combineSurrogatePair(cp, this.currentCodePoint);\n            this.advance();\n        }\n        if (isIdentifierPartChar(cp)) {\n            this._lastIntValue = cp;\n            return true;\n        }\n        if (this.index !== start) {\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatCControlLetter() {\n        const start = this.index;\n        if (this.eat(LATIN_SMALL_LETTER_C)) {\n            if (this.eatControlLetter()) {\n                return true;\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatZero() {\n        if (this.currentCodePoint === DIGIT_ZERO &&\n            !isDecimalDigit(this.nextCodePoint)) {\n            this._lastIntValue = 0;\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    eatControlEscape() {\n        if (this.eat(LATIN_SMALL_LETTER_F)) {\n            this._lastIntValue = FORM_FEED;\n            return true;\n        }\n        if (this.eat(LATIN_SMALL_LETTER_N)) {\n            this._lastIntValue = LINE_FEED;\n            return true;\n        }\n        if (this.eat(LATIN_SMALL_LETTER_R)) {\n            this._lastIntValue = CARRIAGE_RETURN;\n            return true;\n        }\n        if (this.eat(LATIN_SMALL_LETTER_T)) {\n            this._lastIntValue = CHARACTER_TABULATION;\n            return true;\n        }\n        if (this.eat(LATIN_SMALL_LETTER_V)) {\n            this._lastIntValue = LINE_TABULATION;\n            return true;\n        }\n        return false;\n    }\n    eatControlLetter() {\n        const cp = this.currentCodePoint;\n        if (isLatinLetter(cp)) {\n            this.advance();\n            this._lastIntValue = cp % 0x20;\n            return true;\n        }\n        return false;\n    }\n    eatRegExpUnicodeEscapeSequence(forceUFlag = false) {\n        const start = this.index;\n        const uFlag = forceUFlag || this._unicodeMode;\n        if (this.eat(LATIN_SMALL_LETTER_U)) {\n            if ((uFlag && this.eatRegExpUnicodeSurrogatePairEscape()) ||\n                this.eatFixedHexDigits(4) ||\n                (uFlag && this.eatRegExpUnicodeCodePointEscape())) {\n                return true;\n            }\n            if (this.strict || uFlag) {\n                this.raise(\"Invalid unicode escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatRegExpUnicodeSurrogatePairEscape() {\n        const start = this.index;\n        if (this.eatFixedHexDigits(4)) {\n            const lead = this._lastIntValue;\n            if (isLeadSurrogate(lead) &&\n                this.eat(REVERSE_SOLIDUS) &&\n                this.eat(LATIN_SMALL_LETTER_U) &&\n                this.eatFixedHexDigits(4)) {\n                const trail = this._lastIntValue;\n                if (isTrailSurrogate(trail)) {\n                    this._lastIntValue = combineSurrogatePair(lead, trail);\n                    return true;\n                }\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatRegExpUnicodeCodePointEscape() {\n        const start = this.index;\n        if (this.eat(LEFT_CURLY_BRACKET) &&\n            this.eatHexDigits() &&\n            this.eat(RIGHT_CURLY_BRACKET) &&\n            isValidUnicode(this._lastIntValue)) {\n            return true;\n        }\n        this.rewind(start);\n        return false;\n    }\n    eatIdentityEscape() {\n        const cp = this.currentCodePoint;\n        if (this.isValidIdentityEscape(cp)) {\n            this._lastIntValue = cp;\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n    isValidIdentityEscape(cp) {\n        if (cp === -1) {\n            return false;\n        }\n        if (this._unicodeMode) {\n            return isSyntaxCharacter(cp) || cp === SOLIDUS;\n        }\n        if (this.strict) {\n            return !isIdContinue(cp);\n        }\n        if (this._nFlag) {\n            return !(cp === LATIN_SMALL_LETTER_C || cp === LATIN_SMALL_LETTER_K);\n        }\n        return cp !== LATIN_SMALL_LETTER_C;\n    }\n    eatDecimalEscape() {\n        this._lastIntValue = 0;\n        let cp = this.currentCodePoint;\n        if (cp >= DIGIT_ONE && cp <= DIGIT_NINE) {\n            do {\n                this._lastIntValue = 10 * this._lastIntValue + (cp - DIGIT_ZERO);\n                this.advance();\n            } while ((cp = this.currentCodePoint) >= DIGIT_ZERO &&\n                cp <= DIGIT_NINE);\n            return true;\n        }\n        return false;\n    }\n    eatUnicodePropertyValueExpression() {\n        const start = this.index;\n        if (this.eatUnicodePropertyName() && this.eat(EQUALS_SIGN)) {\n            const key = this._lastStrValue;\n            if (this.eatUnicodePropertyValue()) {\n                const value = this._lastStrValue;\n                if (isValidUnicodeProperty(this.ecmaVersion, key, value)) {\n                    return {\n                        key,\n                        value: value || null,\n                    };\n                }\n                this.raise(\"Invalid property name\");\n            }\n        }\n        this.rewind(start);\n        if (this.eatLoneUnicodePropertyNameOrValue()) {\n            const nameOrValue = this._lastStrValue;\n            if (isValidUnicodeProperty(this.ecmaVersion, \"General_Category\", nameOrValue)) {\n                return {\n                    key: \"General_Category\",\n                    value: nameOrValue || null,\n                };\n            }\n            if (isValidLoneUnicodeProperty(this.ecmaVersion, nameOrValue)) {\n                return {\n                    key: nameOrValue,\n                    value: null,\n                };\n            }\n            if (this._unicodeSetsMode &&\n                isValidLoneUnicodePropertyOfString(this.ecmaVersion, nameOrValue)) {\n                return {\n                    key: nameOrValue,\n                    value: null,\n                    strings: true,\n                };\n            }\n            this.raise(\"Invalid property name\");\n        }\n        return null;\n    }\n    eatUnicodePropertyName() {\n        this._lastStrValue = \"\";\n        while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {\n            this._lastStrValue += String.fromCodePoint(this.currentCodePoint);\n            this.advance();\n        }\n        return this._lastStrValue !== \"\";\n    }\n    eatUnicodePropertyValue() {\n        this._lastStrValue = \"\";\n        while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {\n            this._lastStrValue += String.fromCodePoint(this.currentCodePoint);\n            this.advance();\n        }\n        return this._lastStrValue !== \"\";\n    }\n    eatLoneUnicodePropertyNameOrValue() {\n        return this.eatUnicodePropertyValue();\n    }\n    eatHexEscapeSequence() {\n        const start = this.index;\n        if (this.eat(LATIN_SMALL_LETTER_X)) {\n            if (this.eatFixedHexDigits(2)) {\n                return true;\n            }\n            if (this._unicodeMode || this.strict) {\n                this.raise(\"Invalid escape\");\n            }\n            this.rewind(start);\n        }\n        return false;\n    }\n    eatDecimalDigits() {\n        const start = this.index;\n        this._lastIntValue = 0;\n        while (isDecimalDigit(this.currentCodePoint)) {\n            this._lastIntValue =\n                10 * this._lastIntValue + digitToInt(this.currentCodePoint);\n            this.advance();\n        }\n        return this.index !== start;\n    }\n    eatHexDigits() {\n        const start = this.index;\n        this._lastIntValue = 0;\n        while (isHexDigit(this.currentCodePoint)) {\n            this._lastIntValue =\n                16 * this._lastIntValue + digitToInt(this.currentCodePoint);\n            this.advance();\n        }\n        return this.index !== start;\n    }\n    eatLegacyOctalEscapeSequence() {\n        if (this.eatOctalDigit()) {\n            const n1 = this._lastIntValue;\n            if (this.eatOctalDigit()) {\n                const n2 = this._lastIntValue;\n                if (n1 <= 3 && this.eatOctalDigit()) {\n                    this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;\n                }\n                else {\n                    this._lastIntValue = n1 * 8 + n2;\n                }\n            }\n            else {\n                this._lastIntValue = n1;\n            }\n            return true;\n        }\n        return false;\n    }\n    eatOctalDigit() {\n        const cp = this.currentCodePoint;\n        if (isOctalDigit(cp)) {\n            this.advance();\n            this._lastIntValue = cp - DIGIT_ZERO;\n            return true;\n        }\n        this._lastIntValue = 0;\n        return false;\n    }\n    eatFixedHexDigits(length) {\n        const start = this.index;\n        this._lastIntValue = 0;\n        for (let i = 0; i < length; ++i) {\n            const cp = this.currentCodePoint;\n            if (!isHexDigit(cp)) {\n                this.rewind(start);\n                return false;\n            }\n            this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);\n            this.advance();\n        }\n        return true;\n    }\n    eatModifiers() {\n        let ate = false;\n        while (isRegularExpressionModifier(this.currentCodePoint)) {\n            this.advance();\n            ate = true;\n        }\n        return ate;\n    }\n    parseModifiers(start, end) {\n        const { ignoreCase, multiline, dotAll } = this.parseFlags(this._reader.source, start, end);\n        return { ignoreCase, multiline, dotAll };\n    }\n    parseFlags(source, start, end) {\n        const flags = {\n            global: false,\n            ignoreCase: false,\n            multiline: false,\n            unicode: false,\n            sticky: false,\n            dotAll: false,\n            hasIndices: false,\n            unicodeSets: false,\n        };\n        const validFlags = new Set();\n        validFlags.add(LATIN_SMALL_LETTER_G);\n        validFlags.add(LATIN_SMALL_LETTER_I);\n        validFlags.add(LATIN_SMALL_LETTER_M);\n        if (this.ecmaVersion >= 2015) {\n            validFlags.add(LATIN_SMALL_LETTER_U);\n            validFlags.add(LATIN_SMALL_LETTER_Y);\n            if (this.ecmaVersion >= 2018) {\n                validFlags.add(LATIN_SMALL_LETTER_S);\n                if (this.ecmaVersion >= 2022) {\n                    validFlags.add(LATIN_SMALL_LETTER_D);\n                    if (this.ecmaVersion >= 2024) {\n                        validFlags.add(LATIN_SMALL_LETTER_V);\n                    }\n                }\n            }\n        }\n        for (let i = start; i < end; ++i) {\n            const flag = source.charCodeAt(i);\n            if (validFlags.has(flag)) {\n                const prop = FLAG_CODEPOINT_TO_PROP[flag];\n                if (flags[prop]) {\n                    this.raise(`Duplicated flag '${source[i]}'`, {\n                        index: start,\n                    });\n                }\n                flags[prop] = true;\n            }\n            else {\n                this.raise(`Invalid flag '${source[i]}'`, { index: start });\n            }\n        }\n        return flags;\n    }\n}\n\nconst DUMMY_PATTERN = {};\nconst DUMMY_FLAGS = {};\nconst DUMMY_CAPTURING_GROUP = {};\nfunction isClassSetOperand(node) {\n    return (node.type === \"Character\" ||\n        node.type === \"CharacterSet\" ||\n        node.type === \"CharacterClass\" ||\n        node.type === \"ExpressionCharacterClass\" ||\n        node.type === \"ClassStringDisjunction\");\n}\nclass RegExpParserState {\n    constructor(options) {\n        var _a;\n        this._node = DUMMY_PATTERN;\n        this._expressionBufferMap = new Map();\n        this._flags = DUMMY_FLAGS;\n        this._backreferences = [];\n        this._capturingGroups = [];\n        this.source = \"\";\n        this.strict = Boolean(options === null || options === void 0 ? void 0 : options.strict);\n        this.ecmaVersion = (_a = options === null || options === void 0 ? void 0 : options.ecmaVersion) !== null && _a !== void 0 ? _a : latestEcmaVersion;\n    }\n    get pattern() {\n        if (this._node.type !== \"Pattern\") {\n            throw new Error(\"UnknownError\");\n        }\n        return this._node;\n    }\n    get flags() {\n        if (this._flags.type !== \"Flags\") {\n            throw new Error(\"UnknownError\");\n        }\n        return this._flags;\n    }\n    onRegExpFlags(start, end, { global, ignoreCase, multiline, unicode, sticky, dotAll, hasIndices, unicodeSets, }) {\n        this._flags = {\n            type: \"Flags\",\n            parent: null,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            global,\n            ignoreCase,\n            multiline,\n            unicode,\n            sticky,\n            dotAll,\n            hasIndices,\n            unicodeSets,\n        };\n    }\n    onPatternEnter(start) {\n        this._node = {\n            type: \"Pattern\",\n            parent: null,\n            start,\n            end: start,\n            raw: \"\",\n            alternatives: [],\n        };\n        this._backreferences.length = 0;\n        this._capturingGroups.length = 0;\n    }\n    onPatternLeave(start, end) {\n        this._node.end = end;\n        this._node.raw = this.source.slice(start, end);\n        for (const reference of this._backreferences) {\n            const ref = reference.ref;\n            const groups = typeof ref === \"number\"\n                ? [this._capturingGroups[ref - 1]]\n                : this._capturingGroups.filter((g) => g.name === ref);\n            if (groups.length === 1) {\n                const group = groups[0];\n                reference.ambiguous = false;\n                reference.resolved = group;\n            }\n            else {\n                reference.ambiguous = true;\n                reference.resolved = groups;\n            }\n            for (const group of groups) {\n                group.references.push(reference);\n            }\n        }\n    }\n    onAlternativeEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"Assertion\" &&\n            parent.type !== \"CapturingGroup\" &&\n            parent.type !== \"Group\" &&\n            parent.type !== \"Pattern\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"Alternative\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            elements: [],\n        };\n        parent.alternatives.push(this._node);\n    }\n    onAlternativeLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onGroupEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const group = {\n            type: \"Group\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            modifiers: null,\n            alternatives: [],\n        };\n        this._node = group;\n        parent.elements.push(this._node);\n    }\n    onGroupLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Group\" || node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onModifiersEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"Group\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"Modifiers\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            add: null,\n            remove: null,\n        };\n        parent.modifiers = this._node;\n    }\n    onModifiersLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Modifiers\" || node.parent.type !== \"Group\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onAddModifiers(start, end, { ignoreCase, multiline, dotAll, }) {\n        const parent = this._node;\n        if (parent.type !== \"Modifiers\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.add = {\n            type: \"ModifierFlags\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            ignoreCase,\n            multiline,\n            dotAll,\n        };\n    }\n    onRemoveModifiers(start, end, { ignoreCase, multiline, dotAll, }) {\n        const parent = this._node;\n        if (parent.type !== \"Modifiers\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.remove = {\n            type: \"ModifierFlags\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            ignoreCase,\n            multiline,\n            dotAll,\n        };\n    }\n    onCapturingGroupEnter(start, name) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"CapturingGroup\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            name,\n            alternatives: [],\n            references: [],\n        };\n        parent.elements.push(this._node);\n        this._capturingGroups.push(this._node);\n    }\n    onCapturingGroupLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"CapturingGroup\" ||\n            node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onQuantifier(start, end, min, max, greedy) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const element = parent.elements.pop();\n        if (element == null ||\n            element.type === \"Quantifier\" ||\n            (element.type === \"Assertion\" && element.kind !== \"lookahead\")) {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"Quantifier\",\n            parent,\n            start: element.start,\n            end,\n            raw: this.source.slice(element.start, end),\n            min,\n            max,\n            greedy,\n            element,\n        };\n        parent.elements.push(node);\n        element.parent = node;\n    }\n    onLookaroundAssertionEnter(start, kind, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const node = (this._node = {\n            type: \"Assertion\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            kind,\n            negate,\n            alternatives: [],\n        });\n        parent.elements.push(node);\n    }\n    onLookaroundAssertionLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"Assertion\" || node.parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onEdgeAssertion(start, end, kind) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"Assertion\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n        });\n    }\n    onWordBoundaryAssertion(start, end, kind, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"Assertion\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            negate,\n        });\n    }\n    onAnyCharacterSet(start, end, kind) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"CharacterSet\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n        });\n    }\n    onEscapeCharacterSet(start, end, kind, negate) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\" && parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"CharacterSet\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            negate,\n        });\n    }\n    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\" && parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        const base = {\n            type: \"CharacterSet\",\n            parent: null,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            kind,\n            strings: null,\n            key,\n        };\n        if (strings) {\n            if ((parent.type === \"CharacterClass\" && !parent.unicodeSets) ||\n                negate ||\n                value !== null) {\n                throw new Error(\"UnknownError\");\n            }\n            parent.elements.push(Object.assign(Object.assign({}, base), { parent, strings, value, negate }));\n        }\n        else {\n            parent.elements.push(Object.assign(Object.assign({}, base), { parent, strings, value, negate }));\n        }\n    }\n    onCharacter(start, end, value) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\" &&\n            parent.type !== \"CharacterClass\" &&\n            parent.type !== \"StringAlternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push({\n            type: \"Character\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            value,\n        });\n    }\n    onBackreference(start, end, ref) {\n        const parent = this._node;\n        if (parent.type !== \"Alternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"Backreference\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            ref,\n            ambiguous: false,\n            resolved: DUMMY_CAPTURING_GROUP,\n        };\n        parent.elements.push(node);\n        this._backreferences.push(node);\n    }\n    onCharacterClassEnter(start, negate, unicodeSets) {\n        const parent = this._node;\n        const base = {\n            type: \"CharacterClass\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            unicodeSets,\n            negate,\n            elements: [],\n        };\n        if (parent.type === \"Alternative\") {\n            const node = Object.assign(Object.assign({}, base), { parent });\n            this._node = node;\n            parent.elements.push(node);\n        }\n        else if (parent.type === \"CharacterClass\" &&\n            parent.unicodeSets &&\n            unicodeSets) {\n            const node = Object.assign(Object.assign({}, base), { parent,\n                unicodeSets });\n            this._node = node;\n            parent.elements.push(node);\n        }\n        else {\n            throw new Error(\"UnknownError\");\n        }\n    }\n    onCharacterClassLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"CharacterClass\" ||\n            (node.parent.type !== \"Alternative\" &&\n                node.parent.type !== \"CharacterClass\")) {\n            throw new Error(\"UnknownError\");\n        }\n        const parent = node.parent;\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = parent;\n        const expression = this._expressionBufferMap.get(node);\n        if (!expression) {\n            return;\n        }\n        if (node.elements.length > 0) {\n            throw new Error(\"UnknownError\");\n        }\n        this._expressionBufferMap.delete(node);\n        const newNode = {\n            type: \"ExpressionCharacterClass\",\n            parent,\n            start: node.start,\n            end: node.end,\n            raw: node.raw,\n            negate: node.negate,\n            expression,\n        };\n        expression.parent = newNode;\n        if (node !== parent.elements.pop()) {\n            throw new Error(\"UnknownError\");\n        }\n        parent.elements.push(newNode);\n    }\n    onCharacterClassRange(start, end) {\n        const parent = this._node;\n        if (parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        const elements = parent.elements;\n        const max = elements.pop();\n        if (!max || max.type !== \"Character\") {\n            throw new Error(\"UnknownError\");\n        }\n        if (!parent.unicodeSets) {\n            const hyphen = elements.pop();\n            if (!hyphen ||\n                hyphen.type !== \"Character\" ||\n                hyphen.value !== HYPHEN_MINUS) {\n                throw new Error(\"UnknownError\");\n            }\n        }\n        const min = elements.pop();\n        if (!min || min.type !== \"Character\") {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"CharacterClassRange\",\n            parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            min,\n            max,\n        };\n        min.parent = node;\n        max.parent = node;\n        elements.push(node);\n    }\n    onClassIntersection(start, end) {\n        var _a;\n        const parent = this._node;\n        if (parent.type !== \"CharacterClass\" || !parent.unicodeSets) {\n            throw new Error(\"UnknownError\");\n        }\n        const right = parent.elements.pop();\n        const left = (_a = this._expressionBufferMap.get(parent)) !== null && _a !== void 0 ? _a : parent.elements.pop();\n        if (!left ||\n            !right ||\n            left.type === \"ClassSubtraction\" ||\n            (left.type !== \"ClassIntersection\" && !isClassSetOperand(left)) ||\n            !isClassSetOperand(right)) {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"ClassIntersection\",\n            parent: parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            left,\n            right,\n        };\n        left.parent = node;\n        right.parent = node;\n        this._expressionBufferMap.set(parent, node);\n    }\n    onClassSubtraction(start, end) {\n        var _a;\n        const parent = this._node;\n        if (parent.type !== \"CharacterClass\" || !parent.unicodeSets) {\n            throw new Error(\"UnknownError\");\n        }\n        const right = parent.elements.pop();\n        const left = (_a = this._expressionBufferMap.get(parent)) !== null && _a !== void 0 ? _a : parent.elements.pop();\n        if (!left ||\n            !right ||\n            left.type === \"ClassIntersection\" ||\n            (left.type !== \"ClassSubtraction\" && !isClassSetOperand(left)) ||\n            !isClassSetOperand(right)) {\n            throw new Error(\"UnknownError\");\n        }\n        const node = {\n            type: \"ClassSubtraction\",\n            parent: parent,\n            start,\n            end,\n            raw: this.source.slice(start, end),\n            left,\n            right,\n        };\n        left.parent = node;\n        right.parent = node;\n        this._expressionBufferMap.set(parent, node);\n    }\n    onClassStringDisjunctionEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"CharacterClass\" || !parent.unicodeSets) {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"ClassStringDisjunction\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            alternatives: [],\n        };\n        parent.elements.push(this._node);\n    }\n    onClassStringDisjunctionLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"ClassStringDisjunction\" ||\n            node.parent.type !== \"CharacterClass\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n    onStringAlternativeEnter(start) {\n        const parent = this._node;\n        if (parent.type !== \"ClassStringDisjunction\") {\n            throw new Error(\"UnknownError\");\n        }\n        this._node = {\n            type: \"StringAlternative\",\n            parent,\n            start,\n            end: start,\n            raw: \"\",\n            elements: [],\n        };\n        parent.alternatives.push(this._node);\n    }\n    onStringAlternativeLeave(start, end) {\n        const node = this._node;\n        if (node.type !== \"StringAlternative\") {\n            throw new Error(\"UnknownError\");\n        }\n        node.end = end;\n        node.raw = this.source.slice(start, end);\n        this._node = node.parent;\n    }\n}\nclass RegExpParser {\n    constructor(options) {\n        this._state = new RegExpParserState(options);\n        this._validator = new RegExpValidator(this._state);\n    }\n    parseLiteral(source, start = 0, end = source.length) {\n        this._state.source = source;\n        this._validator.validateLiteral(source, start, end);\n        const pattern = this._state.pattern;\n        const flags = this._state.flags;\n        const literal = {\n            type: \"RegExpLiteral\",\n            parent: null,\n            start,\n            end,\n            raw: source,\n            pattern,\n            flags,\n        };\n        pattern.parent = literal;\n        flags.parent = literal;\n        return literal;\n    }\n    parseFlags(source, start = 0, end = source.length) {\n        this._state.source = source;\n        this._validator.validateFlags(source, start, end);\n        return this._state.flags;\n    }\n    parsePattern(source, start = 0, end = source.length, uFlagOrFlags = undefined) {\n        this._state.source = source;\n        this._validator.validatePattern(source, start, end, uFlagOrFlags);\n        return this._state.pattern;\n    }\n}\n\nclass RegExpVisitor {\n    constructor(handlers) {\n        this._handlers = handlers;\n    }\n    visit(node) {\n        switch (node.type) {\n            case \"Alternative\":\n                this.visitAlternative(node);\n                break;\n            case \"Assertion\":\n                this.visitAssertion(node);\n                break;\n            case \"Backreference\":\n                this.visitBackreference(node);\n                break;\n            case \"CapturingGroup\":\n                this.visitCapturingGroup(node);\n                break;\n            case \"Character\":\n                this.visitCharacter(node);\n                break;\n            case \"CharacterClass\":\n                this.visitCharacterClass(node);\n                break;\n            case \"CharacterClassRange\":\n                this.visitCharacterClassRange(node);\n                break;\n            case \"CharacterSet\":\n                this.visitCharacterSet(node);\n                break;\n            case \"ClassIntersection\":\n                this.visitClassIntersection(node);\n                break;\n            case \"ClassStringDisjunction\":\n                this.visitClassStringDisjunction(node);\n                break;\n            case \"ClassSubtraction\":\n                this.visitClassSubtraction(node);\n                break;\n            case \"ExpressionCharacterClass\":\n                this.visitExpressionCharacterClass(node);\n                break;\n            case \"Flags\":\n                this.visitFlags(node);\n                break;\n            case \"Group\":\n                this.visitGroup(node);\n                break;\n            case \"Modifiers\":\n                this.visitModifiers(node);\n                break;\n            case \"ModifierFlags\":\n                this.visitModifierFlags(node);\n                break;\n            case \"Pattern\":\n                this.visitPattern(node);\n                break;\n            case \"Quantifier\":\n                this.visitQuantifier(node);\n                break;\n            case \"RegExpLiteral\":\n                this.visitRegExpLiteral(node);\n                break;\n            case \"StringAlternative\":\n                this.visitStringAlternative(node);\n                break;\n            default:\n                throw new Error(`Unknown type: ${node.type}`);\n        }\n    }\n    visitAlternative(node) {\n        if (this._handlers.onAlternativeEnter) {\n            this._handlers.onAlternativeEnter(node);\n        }\n        node.elements.forEach(this.visit, this);\n        if (this._handlers.onAlternativeLeave) {\n            this._handlers.onAlternativeLeave(node);\n        }\n    }\n    visitAssertion(node) {\n        if (this._handlers.onAssertionEnter) {\n            this._handlers.onAssertionEnter(node);\n        }\n        if (node.kind === \"lookahead\" || node.kind === \"lookbehind\") {\n            node.alternatives.forEach(this.visit, this);\n        }\n        if (this._handlers.onAssertionLeave) {\n            this._handlers.onAssertionLeave(node);\n        }\n    }\n    visitBackreference(node) {\n        if (this._handlers.onBackreferenceEnter) {\n            this._handlers.onBackreferenceEnter(node);\n        }\n        if (this._handlers.onBackreferenceLeave) {\n            this._handlers.onBackreferenceLeave(node);\n        }\n    }\n    visitCapturingGroup(node) {\n        if (this._handlers.onCapturingGroupEnter) {\n            this._handlers.onCapturingGroupEnter(node);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onCapturingGroupLeave) {\n            this._handlers.onCapturingGroupLeave(node);\n        }\n    }\n    visitCharacter(node) {\n        if (this._handlers.onCharacterEnter) {\n            this._handlers.onCharacterEnter(node);\n        }\n        if (this._handlers.onCharacterLeave) {\n            this._handlers.onCharacterLeave(node);\n        }\n    }\n    visitCharacterClass(node) {\n        if (this._handlers.onCharacterClassEnter) {\n            this._handlers.onCharacterClassEnter(node);\n        }\n        node.elements.forEach(this.visit, this);\n        if (this._handlers.onCharacterClassLeave) {\n            this._handlers.onCharacterClassLeave(node);\n        }\n    }\n    visitCharacterClassRange(node) {\n        if (this._handlers.onCharacterClassRangeEnter) {\n            this._handlers.onCharacterClassRangeEnter(node);\n        }\n        this.visitCharacter(node.min);\n        this.visitCharacter(node.max);\n        if (this._handlers.onCharacterClassRangeLeave) {\n            this._handlers.onCharacterClassRangeLeave(node);\n        }\n    }\n    visitCharacterSet(node) {\n        if (this._handlers.onCharacterSetEnter) {\n            this._handlers.onCharacterSetEnter(node);\n        }\n        if (this._handlers.onCharacterSetLeave) {\n            this._handlers.onCharacterSetLeave(node);\n        }\n    }\n    visitClassIntersection(node) {\n        if (this._handlers.onClassIntersectionEnter) {\n            this._handlers.onClassIntersectionEnter(node);\n        }\n        this.visit(node.left);\n        this.visit(node.right);\n        if (this._handlers.onClassIntersectionLeave) {\n            this._handlers.onClassIntersectionLeave(node);\n        }\n    }\n    visitClassStringDisjunction(node) {\n        if (this._handlers.onClassStringDisjunctionEnter) {\n            this._handlers.onClassStringDisjunctionEnter(node);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onClassStringDisjunctionLeave) {\n            this._handlers.onClassStringDisjunctionLeave(node);\n        }\n    }\n    visitClassSubtraction(node) {\n        if (this._handlers.onClassSubtractionEnter) {\n            this._handlers.onClassSubtractionEnter(node);\n        }\n        this.visit(node.left);\n        this.visit(node.right);\n        if (this._handlers.onClassSubtractionLeave) {\n            this._handlers.onClassSubtractionLeave(node);\n        }\n    }\n    visitExpressionCharacterClass(node) {\n        if (this._handlers.onExpressionCharacterClassEnter) {\n            this._handlers.onExpressionCharacterClassEnter(node);\n        }\n        this.visit(node.expression);\n        if (this._handlers.onExpressionCharacterClassLeave) {\n            this._handlers.onExpressionCharacterClassLeave(node);\n        }\n    }\n    visitFlags(node) {\n        if (this._handlers.onFlagsEnter) {\n            this._handlers.onFlagsEnter(node);\n        }\n        if (this._handlers.onFlagsLeave) {\n            this._handlers.onFlagsLeave(node);\n        }\n    }\n    visitGroup(node) {\n        if (this._handlers.onGroupEnter) {\n            this._handlers.onGroupEnter(node);\n        }\n        if (node.modifiers) {\n            this.visit(node.modifiers);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onGroupLeave) {\n            this._handlers.onGroupLeave(node);\n        }\n    }\n    visitModifiers(node) {\n        if (this._handlers.onModifiersEnter) {\n            this._handlers.onModifiersEnter(node);\n        }\n        if (node.add) {\n            this.visit(node.add);\n        }\n        if (node.remove) {\n            this.visit(node.remove);\n        }\n        if (this._handlers.onModifiersLeave) {\n            this._handlers.onModifiersLeave(node);\n        }\n    }\n    visitModifierFlags(node) {\n        if (this._handlers.onModifierFlagsEnter) {\n            this._handlers.onModifierFlagsEnter(node);\n        }\n        if (this._handlers.onModifierFlagsLeave) {\n            this._handlers.onModifierFlagsLeave(node);\n        }\n    }\n    visitPattern(node) {\n        if (this._handlers.onPatternEnter) {\n            this._handlers.onPatternEnter(node);\n        }\n        node.alternatives.forEach(this.visit, this);\n        if (this._handlers.onPatternLeave) {\n            this._handlers.onPatternLeave(node);\n        }\n    }\n    visitQuantifier(node) {\n        if (this._handlers.onQuantifierEnter) {\n            this._handlers.onQuantifierEnter(node);\n        }\n        this.visit(node.element);\n        if (this._handlers.onQuantifierLeave) {\n            this._handlers.onQuantifierLeave(node);\n        }\n    }\n    visitRegExpLiteral(node) {\n        if (this._handlers.onRegExpLiteralEnter) {\n            this._handlers.onRegExpLiteralEnter(node);\n        }\n        this.visitPattern(node.pattern);\n        this.visitFlags(node.flags);\n        if (this._handlers.onRegExpLiteralLeave) {\n            this._handlers.onRegExpLiteralLeave(node);\n        }\n    }\n    visitStringAlternative(node) {\n        if (this._handlers.onStringAlternativeEnter) {\n            this._handlers.onStringAlternativeEnter(node);\n        }\n        node.elements.forEach(this.visit, this);\n        if (this._handlers.onStringAlternativeLeave) {\n            this._handlers.onStringAlternativeLeave(node);\n        }\n    }\n}\n\nfunction parseRegExpLiteral(source, options) {\n    return new RegExpParser(options).parseLiteral(String(source));\n}\nfunction validateRegExpLiteral(source, options) {\n    new RegExpValidator(options).validateLiteral(source);\n}\nfunction visitRegExpAST(node, handlers) {\n    new RegExpVisitor(handlers).visit(node);\n}\n\nexports.AST = ast;\nexports.RegExpParser = RegExpParser;\nexports.RegExpSyntaxError = RegExpSyntaxError;\nexports.RegExpValidator = RegExpValidator;\nexports.parseRegExpLiteral = parseRegExpLiteral;\nexports.validateRegExpLiteral = validateRegExpLiteral;\nexports.visitRegExpAST = visitRegExpAST;\n//# sourceMappingURL=index.js.map\n"
        }
    ]
}