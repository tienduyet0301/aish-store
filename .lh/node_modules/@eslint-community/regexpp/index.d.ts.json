{
    "sourceFile": "node_modules/@eslint-community/regexpp/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746891760243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "// Generated by dts-bundle v0.7.3\n\ndeclare module \"@eslint-community/regexpp\" {\n  import * as AST from \"@eslint-community/regexpp/ast\";\n  import { RegExpParser } from \"@eslint-community/regexpp/parser\";\n  import { RegExpValidator } from \"@eslint-community/regexpp/validator\";\n  import { RegExpVisitor } from \"@eslint-community/regexpp/visitor\";\n  export { RegExpSyntaxError } from \"@eslint-community/regexpp/regexp-syntax-error\";\n  export { AST, RegExpParser, RegExpValidator };\n  /**\n   * Parse a given regular expression literal then make AST object.\n   * @param source The source code to parse.\n   * @param options The options to parse.\n   * @returns The AST of the regular expression.\n   */\n  export function parseRegExpLiteral(\n    source: RegExp | string,\n    options?: RegExpParser.Options\n  ): AST.RegExpLiteral;\n  /**\n   * Validate a given regular expression literal.\n   * @param source The source code to validate.\n   * @param options The options to validate.\n   */\n  export function validateRegExpLiteral(\n    source: string,\n    options?: RegExpValidator.Options\n  ): void;\n  export function visitRegExpAST(\n    node: AST.Node,\n    handlers: RegExpVisitor.Handlers\n  ): void;\n}\n\ndeclare module \"@eslint-community/regexpp/ast\" {\n  /**\n   * The type which includes all nodes.\n   */\n  export type Node = BranchNode | LeafNode;\n  /**\n   * The type which includes all branch nodes.\n   */\n  export type BranchNode =\n    | Alternative\n    | CapturingGroup\n    | CharacterClass\n    | CharacterClassRange\n    | ClassIntersection\n    | ClassStringDisjunction\n    | ClassSubtraction\n    | ExpressionCharacterClass\n    | Group\n    | LookaroundAssertion\n    | Modifiers\n    | Pattern\n    | Quantifier\n    | RegExpLiteral\n    | StringAlternative;\n  /**\n   * The type which includes all leaf nodes.\n   */\n  export type LeafNode =\n    | Backreference\n    | BoundaryAssertion\n    | Character\n    | CharacterSet\n    | Flags\n    | ModifierFlags;\n  /**\n   * The type which includes all atom nodes.\n   */\n  export type Element = Assertion | QuantifiableElement | Quantifier;\n  /**\n   * The type which includes all atom nodes that Quantifier node can have as children.\n   */\n  export type QuantifiableElement =\n    | Backreference\n    | CapturingGroup\n    | Character\n    | CharacterClass\n    | CharacterSet\n    | ExpressionCharacterClass\n    | Group\n    | LookaheadAssertion;\n  /**\n   * The type which includes all character class atom nodes.\n   */\n  export type CharacterClassElement =\n    | ClassRangesCharacterClassElement\n    | UnicodeSetsCharacterClassElement;\n  export type ClassRangesCharacterClassElement =\n    | Character\n    | CharacterClassRange\n    | CharacterUnicodePropertyCharacterSet\n    | EscapeCharacterSet;\n  export type UnicodeSetsCharacterClassElement =\n    | Character\n    | CharacterClassRange\n    | ClassStringDisjunction\n    | EscapeCharacterSet\n    | ExpressionCharacterClass\n    | UnicodePropertyCharacterSet\n    | UnicodeSetsCharacterClass;\n  /**\n   * The type which defines common properties for all node types.\n   */\n  export interface NodeBase {\n    /** The node type. */\n    type: Node[\"type\"];\n    /** The parent node. */\n    parent: Node[\"parent\"];\n    /** The 0-based index that this node starts. */\n    start: number;\n    /** The 0-based index that this node ends. */\n    end: number;\n    /** The raw text of this node. */\n    raw: string;\n  }\n  /**\n   * The root node.\n   */\n  export interface RegExpLiteral extends NodeBase {\n    type: \"RegExpLiteral\";\n    parent: null;\n    pattern: Pattern;\n    flags: Flags;\n  }\n  /**\n   * The pattern.\n   */\n  export interface Pattern extends NodeBase {\n    type: \"Pattern\";\n    parent: RegExpLiteral | null;\n    alternatives: Alternative[];\n  }\n  /**\n   * The alternative.\n   * E.g. `a|b`\n   */\n  export interface Alternative extends NodeBase {\n    type: \"Alternative\";\n    parent: CapturingGroup | Group | LookaroundAssertion | Pattern;\n    elements: Element[];\n  }\n  /**\n   * The uncapturing group.\n   * E.g. `(?:ab)`\n   */\n  export interface Group extends NodeBase {\n    type: \"Group\";\n    parent: Alternative | Quantifier;\n    modifiers: Modifiers | null;\n    alternatives: Alternative[];\n  }\n  /**\n   * The capturing group.\n   * E.g. `(ab)`, `(?<name>ab)`\n   */\n  export interface CapturingGroup extends NodeBase {\n    type: \"CapturingGroup\";\n    parent: Alternative | Quantifier;\n    name: string | null;\n    alternatives: Alternative[];\n    references: Backreference[];\n  }\n  /**\n   * The lookaround assertion.\n   */\n  export type LookaroundAssertion = LookaheadAssertion | LookbehindAssertion;\n  /**\n   * The lookahead assertion.\n   * E.g. `(?=ab)`, `(?!ab)`\n   */\n  export interface LookaheadAssertion extends NodeBase {\n    type: \"Assertion\";\n    parent: Alternative | Quantifier;\n    kind: \"lookahead\";\n    negate: boolean;\n    alternatives: Alternative[];\n  }\n  /**\n   * The lookbehind assertion.\n   * E.g. `(?<=ab)`, `(?<!ab)`\n   */\n  export interface LookbehindAssertion extends NodeBase {\n    type: \"Assertion\";\n    parent: Alternative;\n    kind: \"lookbehind\";\n    negate: boolean;\n    alternatives: Alternative[];\n  }\n  /**\n   * The quantifier.\n   * E.g. `a?`, `a*`, `a+`, `a{1,2}`, `a??`, `a*?`, `a+?`, `a{1,2}?`\n   */\n  export interface Quantifier extends NodeBase {\n    type: \"Quantifier\";\n    parent: Alternative;\n    min: number;\n    max: number;\n    greedy: boolean;\n    element: QuantifiableElement;\n  }\n  /**\n   * The character class.\n   * E.g. `[ab]`, `[^ab]`\n   */\n  export type CharacterClass =\n    | ClassRangesCharacterClass\n    | UnicodeSetsCharacterClass;\n  interface BaseCharacterClass extends NodeBase {\n    type: \"CharacterClass\";\n    parent:\n      | Alternative\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier\n      | UnicodeSetsCharacterClass;\n    unicodeSets: boolean;\n    negate: boolean;\n    elements: CharacterClassElement[];\n  }\n  /**\n   * The character class used in legacy (neither `u` nor `v` flag) and Unicode mode (`u` flag).\n   *\n   * This character class is guaranteed to **not** contain strings.\n   *\n   * In Unicode sets mode (`v` flag), {@link UnicodeSetsCharacterClass} is used.\n   */\n  export interface ClassRangesCharacterClass extends BaseCharacterClass {\n    parent: Alternative | Quantifier;\n    unicodeSets: false;\n    elements: ClassRangesCharacterClassElement[];\n  }\n  /**\n   * The character class used in Unicode sets mode (`v` flag).\n   *\n   * This character class may contain strings.\n   */\n  export interface UnicodeSetsCharacterClass extends BaseCharacterClass {\n    parent:\n      | Alternative\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier\n      | UnicodeSetsCharacterClass;\n    unicodeSets: true;\n    elements: UnicodeSetsCharacterClassElement[];\n  }\n  /**\n   * The character class.\n   * E.g. `[a-b]`\n   */\n  export interface CharacterClassRange extends NodeBase {\n    type: \"CharacterClassRange\";\n    parent: CharacterClass;\n    min: Character;\n    max: Character;\n  }\n  /**\n   * The assertion.\n   */\n  export type Assertion = BoundaryAssertion | LookaroundAssertion;\n  /**\n   * The boundary assertion.\n   */\n  export type BoundaryAssertion = EdgeAssertion | WordBoundaryAssertion;\n  /**\n   * The edge boundary assertion.\n   * E.g. `^`, `$`\n   */\n  export interface EdgeAssertion extends NodeBase {\n    type: \"Assertion\";\n    parent: Alternative | Quantifier;\n    kind: \"end\" | \"start\";\n  }\n  /**\n   * The word bondary assertion.\n   * E.g. `\\b`, `\\B`\n   */\n  export interface WordBoundaryAssertion extends NodeBase {\n    type: \"Assertion\";\n    parent: Alternative | Quantifier;\n    kind: \"word\";\n    negate: boolean;\n  }\n  /**\n   * The character set.\n   */\n  export type CharacterSet =\n    | AnyCharacterSet\n    | EscapeCharacterSet\n    | UnicodePropertyCharacterSet;\n  /**\n   * The dot.\n   * E.g. `.`\n   */\n  export interface AnyCharacterSet extends NodeBase {\n    type: \"CharacterSet\";\n    parent: Alternative | Quantifier;\n    kind: \"any\";\n  }\n  /**\n   * The character class escape.\n   * E.g. `\\d`, `\\s`, `\\w`, `\\D`, `\\S`, `\\W`\n   */\n  export interface EscapeCharacterSet extends NodeBase {\n    type: \"CharacterSet\";\n    parent:\n      | Alternative\n      | CharacterClass\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier;\n    kind: \"digit\" | \"space\" | \"word\";\n    negate: boolean;\n  }\n  /**\n   * The unicode property escape.\n   * E.g. `\\p{ASCII}`, `\\P{ASCII}`, `\\p{Script=Hiragana}`\n   */\n  export type UnicodePropertyCharacterSet =\n    | CharacterUnicodePropertyCharacterSet\n    | StringsUnicodePropertyCharacterSet;\n  interface BaseUnicodePropertyCharacterSet extends NodeBase {\n    type: \"CharacterSet\";\n    parent:\n      | Alternative\n      | CharacterClass\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier;\n    kind: \"property\";\n    strings: boolean;\n    key: string;\n    value: string | null;\n    negate: boolean;\n  }\n  export interface CharacterUnicodePropertyCharacterSet\n    extends BaseUnicodePropertyCharacterSet {\n    strings: false;\n    value: string | null;\n    negate: boolean;\n  }\n  /** StringsUnicodePropertyCharacterSet is Unicode property escape with property of strings. */\n  export interface StringsUnicodePropertyCharacterSet\n    extends BaseUnicodePropertyCharacterSet {\n    parent:\n      | Alternative\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier\n      | UnicodeSetsCharacterClass;\n    strings: true;\n    value: null;\n    negate: false;\n  }\n  /**\n   * The expression character class.\n   * E.g. `[a--b]`, `[a&&b]`,`[^a--b]`, `[^a&&b]`\n   */\n  export interface ExpressionCharacterClass extends NodeBase {\n    type: \"ExpressionCharacterClass\";\n    parent:\n      | Alternative\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier\n      | UnicodeSetsCharacterClass;\n    negate: boolean;\n    expression: ClassIntersection | ClassSubtraction;\n  }\n  export type ClassSetOperand =\n    | Character\n    | ClassStringDisjunction\n    | EscapeCharacterSet\n    | ExpressionCharacterClass\n    | UnicodePropertyCharacterSet\n    | UnicodeSetsCharacterClass;\n  /**\n   * The character class intersection.\n   * E.g. `a&&b`\n   */\n  export interface ClassIntersection extends NodeBase {\n    type: \"ClassIntersection\";\n    parent: ClassIntersection | ExpressionCharacterClass;\n    left: ClassIntersection | ClassSetOperand;\n    right: ClassSetOperand;\n  }\n  /**\n   * The character class subtraction.\n   * E.g. `a--b`\n   */\n  export interface ClassSubtraction extends NodeBase {\n    type: \"ClassSubtraction\";\n    parent: ClassSubtraction | ExpressionCharacterClass;\n    left: ClassSetOperand | ClassSubtraction;\n    right: ClassSetOperand;\n  }\n  /**\n   * The character class string disjunction.\n   * E.g. `\\q{a|b}`\n   */\n  export interface ClassStringDisjunction extends NodeBase {\n    type: \"ClassStringDisjunction\";\n    parent: ClassIntersection | ClassSubtraction | UnicodeSetsCharacterClass;\n    alternatives: StringAlternative[];\n  }\n  /** StringAlternative is only used for `\\q{alt}`({@link ClassStringDisjunction}). */\n  export interface StringAlternative extends NodeBase {\n    type: \"StringAlternative\";\n    parent: ClassStringDisjunction;\n    elements: Character[];\n  }\n  /**\n   * The character.\n   * This includes escape sequences which mean a character.\n   * E.g. `a`, `あ`, `✿`, `\\x65`, `\\u0065`, `\\u{65}`, `\\/`\n   */\n  export interface Character extends NodeBase {\n    type: \"Character\";\n    parent:\n      | Alternative\n      | CharacterClass\n      | CharacterClassRange\n      | ClassIntersection\n      | ClassSubtraction\n      | Quantifier\n      | StringAlternative;\n    value: number;\n  }\n  /**\n   * The backreference.\n   * E.g. `\\1`, `\\k<name>`\n   */\n  export type Backreference = AmbiguousBackreference | UnambiguousBackreference;\n  interface BaseBackreference extends NodeBase {\n    type: \"Backreference\";\n    parent: Alternative | Quantifier;\n    ref: number | string;\n    ambiguous: boolean;\n    resolved: CapturingGroup | CapturingGroup[];\n  }\n  export interface AmbiguousBackreference extends BaseBackreference {\n    ref: string;\n    ambiguous: true;\n    resolved: CapturingGroup[];\n  }\n  export interface UnambiguousBackreference extends BaseBackreference {\n    ambiguous: false;\n    resolved: CapturingGroup;\n  }\n  /**\n   * The modifiers.\n   */\n  export interface Modifiers extends NodeBase {\n    type: \"Modifiers\";\n    parent: Group;\n    /**\n     * The add modifier flags.\n     */\n    add: ModifierFlags;\n    /**\n     * The remove modifier flags.\n     *\n     * `null` means no remove modifier flags. e.g. `(?ims:x)`\n     * The reason for `null` is that there is no position where the remove modifier flags appears. Must be behind the minus mark.\n     */\n    remove: ModifierFlags | null;\n  }\n  /**\n   * The modifier flags.\n   */\n  export interface ModifierFlags extends NodeBase {\n    type: \"ModifierFlags\";\n    parent: Modifiers;\n    dotAll: boolean;\n    ignoreCase: boolean;\n    multiline: boolean;\n  }\n  /**\n   * The flags.\n   */\n  export interface Flags extends NodeBase {\n    type: \"Flags\";\n    parent: RegExpLiteral | null;\n    dotAll: boolean;\n    global: boolean;\n    hasIndices: boolean;\n    ignoreCase: boolean;\n    multiline: boolean;\n    sticky: boolean;\n    unicode: boolean;\n    unicodeSets: boolean;\n  }\n  export {};\n}\n\ndeclare module \"@eslint-community/regexpp/parser\" {\n  import type {\n    Flags,\n    RegExpLiteral,\n    Pattern,\n  } from \"@eslint-community/regexpp/ast\";\n  import type { EcmaVersion } from \"@eslint-community/regexpp/ecma-versions\";\n  export namespace RegExpParser {\n    /**\n     * The options for RegExpParser construction.\n     */\n    interface Options {\n      /**\n       * The flag to disable Annex B syntax. Default is `false`.\n       */\n      strict?: boolean;\n      /**\n       * ECMAScript version. Default is `2025`.\n       * - `2015` added `u` and `y` flags.\n       * - `2018` added `s` flag, Named Capturing Group, Lookbehind Assertion,\n       *   and Unicode Property Escape.\n       * - `2019`, `2020`, and `2021` added more valid Unicode Property Escapes.\n       * - `2022` added `d` flag.\n       * - `2023` added more valid Unicode Property Escapes.\n       * - `2024` added `v` flag.\n       * - `2025` added duplicate named capturing groups, modifiers.\n       */\n      ecmaVersion?: EcmaVersion;\n    }\n  }\n  export class RegExpParser {\n    /**\n     * Initialize this parser.\n     * @param options The options of parser.\n     */\n    constructor(options?: RegExpParser.Options);\n    /**\n     * Parse a regular expression literal. E.g. \"/abc/g\"\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @returns The AST of the given regular expression.\n     */\n    parseLiteral(source: string, start?: number, end?: number): RegExpLiteral;\n    /**\n     * Parse a regular expression flags. E.g. \"gim\"\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @returns The AST of the given flags.\n     */\n    parseFlags(source: string, start?: number, end?: number): Flags;\n    /**\n     * Parse a regular expression pattern. E.g. \"abc\"\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @param flags The flags.\n     * @returns The AST of the given pattern.\n     */\n    parsePattern(\n      source: string,\n      start?: number,\n      end?: number,\n      flags?: {\n        unicode?: boolean;\n        unicodeSets?: boolean;\n      }\n    ): Pattern;\n    /**\n     * @deprecated Backward compatibility\n     * Use object `flags` instead of boolean `uFlag`.\n     *\n     * @param source The source code to parse.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @param uFlag The flag to set unicode mode.\n     * @returns The AST of the given pattern.\n     */\n    parsePattern(\n      source: string,\n      start?: number,\n      end?: number,\n      uFlag?: boolean\n    ): Pattern;\n  }\n}\n\ndeclare module \"@eslint-community/regexpp/validator\" {\n  import type { EcmaVersion } from \"@eslint-community/regexpp/ecma-versions\";\n  export type RegExpValidatorSourceContext = {\n    readonly source: string;\n    readonly start: number;\n    readonly end: number;\n    readonly kind: \"flags\" | \"literal\" | \"pattern\";\n  };\n  export namespace RegExpValidator {\n    /**\n     * The options for RegExpValidator construction.\n     */\n    interface Options {\n      /**\n       * The flag to disable Annex B syntax. Default is `false`.\n       */\n      strict?: boolean;\n      /**\n       * ECMAScript version. Default is `2025`.\n       * - `2015` added `u` and `y` flags.\n       * - `2018` added `s` flag, Named Capturing Group, Lookbehind Assertion,\n       *   and Unicode Property Escape.\n       * - `2019`, `2020`, and `2021` added more valid Unicode Property Escapes.\n       * - `2022` added `d` flag.\n       * - `2023` added more valid Unicode Property Escapes.\n       * - `2024` added `v` flag.\n       * - `2025` added duplicate named capturing groups, modifiers.\n       */\n      ecmaVersion?: EcmaVersion;\n      /**\n       * A function that is called when the validator entered a RegExp literal.\n       * @param start The 0-based index of the first character.\n       */\n      onLiteralEnter?: (start: number) => void;\n      /**\n       * A function that is called when the validator left a RegExp literal.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onLiteralLeave?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator found flags.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param flags.global `g` flag.\n       * @param flags.ignoreCase `i` flag.\n       * @param flags.multiline `m` flag.\n       * @param flags.unicode `u` flag.\n       * @param flags.sticky `y` flag.\n       * @param flags.dotAll `s` flag.\n       * @param flags.hasIndices `d` flag.\n       * @param flags.unicodeSets `v` flag.\n       */\n      onRegExpFlags?: (\n        start: number,\n        end: number,\n        flags: {\n          global: boolean;\n          ignoreCase: boolean;\n          multiline: boolean;\n          unicode: boolean;\n          sticky: boolean;\n          dotAll: boolean;\n          hasIndices: boolean;\n          unicodeSets: boolean;\n        }\n      ) => void;\n      /**\n       * A function that is called when the validator found flags.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param global `g` flag.\n       * @param ignoreCase `i` flag.\n       * @param multiline `m` flag.\n       * @param unicode `u` flag.\n       * @param sticky `y` flag.\n       * @param dotAll `s` flag.\n       * @param hasIndices `d` flag.\n       *\n       * @deprecated Use `onRegExpFlags` instead.\n       */\n      onFlags?: (\n        start: number,\n        end: number,\n        global: boolean,\n        ignoreCase: boolean,\n        multiline: boolean,\n        unicode: boolean,\n        sticky: boolean,\n        dotAll: boolean,\n        hasIndices: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator entered a pattern.\n       * @param start The 0-based index of the first character.\n       */\n      onPatternEnter?: (start: number) => void;\n      /**\n       * A function that is called when the validator left a pattern.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onPatternLeave?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator entered a disjunction.\n       * @param start The 0-based index of the first character.\n       */\n      onDisjunctionEnter?: (start: number) => void;\n      /**\n       * A function that is called when the validator left a disjunction.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onDisjunctionLeave?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator entered an alternative.\n       * @param start The 0-based index of the first character.\n       * @param index The 0-based index of alternatives in a disjunction.\n       */\n      onAlternativeEnter?: (start: number, index: number) => void;\n      /**\n       * A function that is called when the validator left an alternative.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param index The 0-based index of alternatives in a disjunction.\n       */\n      onAlternativeLeave?: (start: number, end: number, index: number) => void;\n      /**\n       * A function that is called when the validator entered an uncapturing group.\n       * @param start The 0-based index of the first character.\n       */\n      onGroupEnter?: (start: number) => void;\n      /**\n       * A function that is called when the validator left an uncapturing group.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onGroupLeave?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator entered a modifiers.\n       * @param start The 0-based index of the first character.\n       */\n      onModifiersEnter?: (start: number) => void;\n      /**\n       * A function that is called when the validator left a modifiers.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onModifiersLeave?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator found an add modifiers.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param flags flags.\n       * @param flags.ignoreCase `i` flag.\n       * @param flags.multiline `m` flag.\n       * @param flags.dotAll `s` flag.\n       */\n      onAddModifiers?: (\n        start: number,\n        end: number,\n        flags: {\n          ignoreCase: boolean;\n          multiline: boolean;\n          dotAll: boolean;\n        }\n      ) => void;\n      /**\n       * A function that is called when the validator found a remove modifiers.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param flags flags.\n       * @param flags.ignoreCase `i` flag.\n       * @param flags.multiline `m` flag.\n       * @param flags.dotAll `s` flag.\n       */\n      onRemoveModifiers?: (\n        start: number,\n        end: number,\n        flags: {\n          ignoreCase: boolean;\n          multiline: boolean;\n          dotAll: boolean;\n        }\n      ) => void;\n      /**\n       * A function that is called when the validator entered a capturing group.\n       * @param start The 0-based index of the first character.\n       * @param name The group name.\n       */\n      onCapturingGroupEnter?: (start: number, name: string | null) => void;\n      /**\n       * A function that is called when the validator left a capturing group.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param name The group name.\n       */\n      onCapturingGroupLeave?: (\n        start: number,\n        end: number,\n        name: string | null\n      ) => void;\n      /**\n       * A function that is called when the validator found a quantifier.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param min The minimum number of repeating.\n       * @param max The maximum number of repeating.\n       * @param greedy The flag to choose the longest matching.\n       */\n      onQuantifier?: (\n        start: number,\n        end: number,\n        min: number,\n        max: number,\n        greedy: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator entered a lookahead/lookbehind assertion.\n       * @param start The 0-based index of the first character.\n       * @param kind The kind of the assertion.\n       * @param negate The flag which represents that the assertion is negative.\n       */\n      onLookaroundAssertionEnter?: (\n        start: number,\n        kind: \"lookahead\" | \"lookbehind\",\n        negate: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator left a lookahead/lookbehind assertion.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param kind The kind of the assertion.\n       * @param negate The flag which represents that the assertion is negative.\n       */\n      onLookaroundAssertionLeave?: (\n        start: number,\n        end: number,\n        kind: \"lookahead\" | \"lookbehind\",\n        negate: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator found an edge boundary assertion.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param kind The kind of the assertion.\n       */\n      onEdgeAssertion?: (\n        start: number,\n        end: number,\n        kind: \"end\" | \"start\"\n      ) => void;\n      /**\n       * A function that is called when the validator found a word boundary assertion.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param kind The kind of the assertion.\n       * @param negate The flag which represents that the assertion is negative.\n       */\n      onWordBoundaryAssertion?: (\n        start: number,\n        end: number,\n        kind: \"word\",\n        negate: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator found a dot.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param kind The kind of the character set.\n       */\n      onAnyCharacterSet?: (start: number, end: number, kind: \"any\") => void;\n      /**\n       * A function that is called when the validator found a character set escape.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param kind The kind of the character set.\n       * @param negate The flag which represents that the character set is negative.\n       */\n      onEscapeCharacterSet?: (\n        start: number,\n        end: number,\n        kind: \"digit\" | \"space\" | \"word\",\n        negate: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator found a Unicode proerty escape.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param kind The kind of the character set.\n       * @param key The property name.\n       * @param value The property value.\n       * @param negate The flag which represents that the character set is negative.\n       * @param strings If true, the given property is property of strings.\n       */\n      onUnicodePropertyCharacterSet?: (\n        start: number,\n        end: number,\n        kind: \"property\",\n        key: string,\n        value: string | null,\n        negate: boolean,\n        strings: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator found a character.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param value The code point of the character.\n       */\n      onCharacter?: (start: number, end: number, value: number) => void;\n      /**\n       * A function that is called when the validator found a backreference.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param ref The key of the referred capturing group.\n       */\n      onBackreference?: (\n        start: number,\n        end: number,\n        ref: number | string\n      ) => void;\n      /**\n       * A function that is called when the validator entered a character class.\n       * @param start The 0-based index of the first character.\n       * @param negate The flag which represents that the character class is negative.\n       * @param unicodeSets `true` if unicodeSets mode.\n       */\n      onCharacterClassEnter?: (\n        start: number,\n        negate: boolean,\n        unicodeSets: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator left a character class.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param negate The flag which represents that the character class is negative.\n       */\n      onCharacterClassLeave?: (\n        start: number,\n        end: number,\n        negate: boolean\n      ) => void;\n      /**\n       * A function that is called when the validator found a character class range.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param min The minimum code point of the range.\n       * @param max The maximum code point of the range.\n       */\n      onCharacterClassRange?: (\n        start: number,\n        end: number,\n        min: number,\n        max: number\n      ) => void;\n      /**\n       * A function that is called when the validator found a class intersection.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onClassIntersection?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator found a class subtraction.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onClassSubtraction?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator entered a class string disjunction.\n       * @param start The 0-based index of the first character.\n       */\n      onClassStringDisjunctionEnter?: (start: number) => void;\n      /**\n       * A function that is called when the validator left a class string disjunction.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       */\n      onClassStringDisjunctionLeave?: (start: number, end: number) => void;\n      /**\n       * A function that is called when the validator entered a string alternative.\n       * @param start The 0-based index of the first character.\n       * @param index The 0-based index of alternatives in a disjunction.\n       */\n      onStringAlternativeEnter?: (start: number, index: number) => void;\n      /**\n       * A function that is called when the validator left a string alternative.\n       * @param start The 0-based index of the first character.\n       * @param end The next 0-based index of the last character.\n       * @param index The 0-based index of alternatives in a disjunction.\n       */\n      onStringAlternativeLeave?: (\n        start: number,\n        end: number,\n        index: number\n      ) => void;\n    }\n  }\n  /**\n   * The regular expression validator.\n   */\n  export class RegExpValidator {\n    /**\n     * Initialize this validator.\n     * @param options The options of validator.\n     */\n    constructor(options?: RegExpValidator.Options);\n    /**\n     * Validate a regular expression literal. E.g. \"/abc/g\"\n     * @param source The source code to validate.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     */\n    validateLiteral(source: string, start?: number, end?: number): void;\n    /**\n     * Validate a regular expression flags. E.g. \"gim\"\n     * @param source The source code to validate.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     */\n    validateFlags(source: string, start?: number, end?: number): void;\n    /**\n     * Validate a regular expression pattern. E.g. \"abc\"\n     * @param source The source code to validate.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @param flags The flags.\n     */\n    validatePattern(\n      source: string,\n      start?: number,\n      end?: number,\n      flags?: {\n        unicode?: boolean;\n        unicodeSets?: boolean;\n      }\n    ): void;\n    /**\n     * @deprecated Backward compatibility\n     * Use object `flags` instead of boolean `uFlag`.\n     * @param source The source code to validate.\n     * @param start The start index in the source code.\n     * @param end The end index in the source code.\n     * @param uFlag The flag to set unicode mode.\n     */\n    validatePattern(\n      source: string,\n      start?: number,\n      end?: number,\n      uFlag?: boolean\n    ): void;\n  }\n}\n\ndeclare module \"@eslint-community/regexpp/visitor\" {\n  import type {\n    Alternative,\n    Assertion,\n    Backreference,\n    CapturingGroup,\n    Character,\n    CharacterClass,\n    CharacterClassRange,\n    CharacterSet,\n    ClassIntersection,\n    ClassStringDisjunction,\n    ClassSubtraction,\n    ExpressionCharacterClass,\n    Flags,\n    Group,\n    ModifierFlags,\n    Modifiers,\n    Node,\n    Pattern,\n    Quantifier,\n    RegExpLiteral,\n    StringAlternative,\n  } from \"@eslint-community/regexpp/ast\";\n  /**\n   * The visitor to walk on AST.\n   */\n  export class RegExpVisitor {\n    /**\n     * Initialize this visitor.\n     * @param handlers Callbacks for each node.\n     */\n    constructor(handlers: RegExpVisitor.Handlers);\n    /**\n     * Visit a given node and descendant nodes.\n     * @param node The root node to visit tree.\n     */\n    visit(node: Node): void;\n  }\n  export namespace RegExpVisitor {\n    interface Handlers {\n      onAlternativeEnter?: (node: Alternative) => void;\n      onAlternativeLeave?: (node: Alternative) => void;\n      onAssertionEnter?: (node: Assertion) => void;\n      onAssertionLeave?: (node: Assertion) => void;\n      onBackreferenceEnter?: (node: Backreference) => void;\n      onBackreferenceLeave?: (node: Backreference) => void;\n      onCapturingGroupEnter?: (node: CapturingGroup) => void;\n      onCapturingGroupLeave?: (node: CapturingGroup) => void;\n      onCharacterEnter?: (node: Character) => void;\n      onCharacterLeave?: (node: Character) => void;\n      onCharacterClassEnter?: (node: CharacterClass) => void;\n      onCharacterClassLeave?: (node: CharacterClass) => void;\n      onCharacterClassRangeEnter?: (node: CharacterClassRange) => void;\n      onCharacterClassRangeLeave?: (node: CharacterClassRange) => void;\n      onCharacterSetEnter?: (node: CharacterSet) => void;\n      onCharacterSetLeave?: (node: CharacterSet) => void;\n      onClassIntersectionEnter?: (node: ClassIntersection) => void;\n      onClassIntersectionLeave?: (node: ClassIntersection) => void;\n      onClassStringDisjunctionEnter?: (node: ClassStringDisjunction) => void;\n      onClassStringDisjunctionLeave?: (node: ClassStringDisjunction) => void;\n      onClassSubtractionEnter?: (node: ClassSubtraction) => void;\n      onClassSubtractionLeave?: (node: ClassSubtraction) => void;\n      onExpressionCharacterClassEnter?: (\n        node: ExpressionCharacterClass\n      ) => void;\n      onExpressionCharacterClassLeave?: (\n        node: ExpressionCharacterClass\n      ) => void;\n      onFlagsEnter?: (node: Flags) => void;\n      onFlagsLeave?: (node: Flags) => void;\n      onGroupEnter?: (node: Group) => void;\n      onGroupLeave?: (node: Group) => void;\n      onModifierFlagsEnter?: (node: ModifierFlags) => void;\n      onModifierFlagsLeave?: (node: ModifierFlags) => void;\n      onModifiersEnter?: (node: Modifiers) => void;\n      onModifiersLeave?: (node: Modifiers) => void;\n      onPatternEnter?: (node: Pattern) => void;\n      onPatternLeave?: (node: Pattern) => void;\n      onQuantifierEnter?: (node: Quantifier) => void;\n      onQuantifierLeave?: (node: Quantifier) => void;\n      onRegExpLiteralEnter?: (node: RegExpLiteral) => void;\n      onRegExpLiteralLeave?: (node: RegExpLiteral) => void;\n      onStringAlternativeEnter?: (node: StringAlternative) => void;\n      onStringAlternativeLeave?: (node: StringAlternative) => void;\n    }\n  }\n}\n\ndeclare module \"@eslint-community/regexpp/regexp-syntax-error\" {\n  import type { RegExpValidatorSourceContext } from \"@eslint-community/regexpp/validator\";\n  export class RegExpSyntaxError extends SyntaxError {\n    index: number;\n    constructor(message: string, index: number);\n  }\n  export function newRegExpSyntaxError(\n    srcCtx: RegExpValidatorSourceContext,\n    flags: {\n      unicode: boolean;\n      unicodeSets: boolean;\n    },\n    index: number,\n    message: string\n  ): RegExpSyntaxError;\n}\n\ndeclare module \"@eslint-community/regexpp/ecma-versions\" {\n  export type EcmaVersion =\n    | 5\n    | 2015\n    | 2016\n    | 2017\n    | 2018\n    | 2019\n    | 2020\n    | 2021\n    | 2022\n    | 2023\n    | 2024\n    | 2025;\n  export const latestEcmaVersion = 2025;\n}\n"
        }
    ]
}