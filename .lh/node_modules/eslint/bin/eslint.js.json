{
    "sourceFile": "node_modules/eslint/bin/eslint.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892207319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "#!/usr/bin/env node\n\n/**\n * @fileoverview Main CLI that is run via the eslint command.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-console:off -- CLI */\n\n\"use strict\";\n\nconst mod = require(\"node:module\");\n\n// to use V8's code cache to speed up instantiation time\nmod.enableCompileCache?.();\n\n// must do this initialization *before* other requires in order to work\nif (process.argv.includes(\"--debug\")) {\n    require(\"debug\").enable(\"eslint:*,-eslint:code-path,eslintrc:*\");\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Read data from stdin til the end.\n *\n * Note: See\n * - https://github.com/nodejs/node/blob/master/doc/api/process.md#processstdin\n * - https://github.com/nodejs/node/blob/master/doc/api/process.md#a-note-on-process-io\n * - https://lists.gnu.org/archive/html/bug-gnu-emacs/2016-01/msg00419.html\n * - https://github.com/nodejs/node/issues/7439 (historical)\n *\n * On Windows using `fs.readFileSync(STDIN_FILE_DESCRIPTOR, \"utf8\")` seems\n * to read 4096 bytes before blocking and never drains to read further data.\n *\n * The investigation on the Emacs thread indicates:\n *\n * > Emacs on MS-Windows uses pipes to communicate with subprocesses; a\n * > pipe on Windows has a 4K buffer. So as soon as Emacs writes more than\n * > 4096 bytes to the pipe, the pipe becomes full, and Emacs then waits for\n * > the subprocess to read its end of the pipe, at which time Emacs will\n * > write the rest of the stuff.\n * @returns {Promise<string>} The read text.\n */\nfunction readStdin() {\n    return new Promise((resolve, reject) => {\n        let content = \"\";\n        let chunk = \"\";\n\n        process.stdin\n            .setEncoding(\"utf8\")\n            .on(\"readable\", () => {\n                while ((chunk = process.stdin.read()) !== null) {\n                    content += chunk;\n                }\n            })\n            .on(\"end\", () => resolve(content))\n            .on(\"error\", reject);\n    });\n}\n\n/**\n * Get the error message of a given value.\n * @param {any} error The value to get.\n * @returns {string} The error message.\n */\nfunction getErrorMessage(error) {\n\n    // Lazy loading because this is used only if an error happened.\n    const util = require(\"node:util\");\n\n    // Foolproof -- third-party module might throw non-object.\n    if (typeof error !== \"object\" || error === null) {\n        return String(error);\n    }\n\n    // Use templates if `error.messageTemplate` is present.\n    if (typeof error.messageTemplate === \"string\") {\n        try {\n            const template = require(`../messages/${error.messageTemplate}.js`);\n\n            return template(error.messageData || {});\n        } catch {\n\n            // Ignore template error then fallback to use `error.stack`.\n        }\n    }\n\n    // Use the stacktrace if it's an error object.\n    if (typeof error.stack === \"string\") {\n        return error.stack;\n    }\n\n    // Otherwise, dump the object.\n    return util.format(\"%o\", error);\n}\n\n/**\n * Tracks error messages that are shown to the user so we only ever show the\n * same message once.\n * @type {Set<string>}\n */\nconst displayedErrors = new Set();\n\n/**\n * Tracks whether an unexpected error was caught\n * @type {boolean}\n */\nlet hadFatalError = false;\n\n/**\n * Catch and report unexpected error.\n * @param {any} error The thrown error object.\n * @returns {void}\n */\nfunction onFatalError(error) {\n    process.exitCode = 2;\n    hadFatalError = true;\n\n    const { version } = require(\"../package.json\");\n    const message = `\nOops! Something went wrong! :(\n\nESLint: ${version}\n\n${getErrorMessage(error)}`;\n\n    if (!displayedErrors.has(message)) {\n        console.error(message);\n        displayedErrors.add(message);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Execution\n//------------------------------------------------------------------------------\n\n(async function main() {\n    process.on(\"uncaughtException\", onFatalError);\n    process.on(\"unhandledRejection\", onFatalError);\n\n    // Call the config initializer if `--init` is present.\n    if (process.argv.includes(\"--init\")) {\n\n        // `eslint --init` has been moved to `@eslint/create-config`\n        console.warn(\"You can also run this command directly using 'npm init @eslint/config@latest'.\");\n\n        const spawn = require(\"cross-spawn\");\n\n        spawn.sync(\"npm\", [\"init\", \"@eslint/config@latest\"], { encoding: \"utf8\", stdio: \"inherit\" });\n        return;\n    }\n\n    // Otherwise, call the CLI.\n    const cli = require(\"../lib/cli\");\n    const exitCode = await cli.execute(\n        process.argv,\n        process.argv.includes(\"--stdin\") ? await readStdin() : null,\n        true\n    );\n\n    /*\n     * If an uncaught exception or unhandled rejection was detected in the meantime,\n     * keep the fatal exit code 2 that is already assigned to `process.exitCode`.\n     * Without this condition, exit code 2 (unsuccessful execution) could be overwritten with\n     * 1 (successful execution, lint problems found) or even 0 (successful execution, no lint problems found).\n     * This ensures that unexpected errors that seemingly don't affect the success\n     * of the execution will still cause a non-zero exit code, as it's a common\n     * practice and the default behavior of Node.js to exit with non-zero\n     * in case of an uncaught exception or unhandled rejection.\n     *\n     * Otherwise, assign the exit code returned from CLI.\n     */\n    if (!hadFatalError) {\n        process.exitCode = exitCode;\n    }\n}()).catch(onFatalError);\n"
        }
    ]
}