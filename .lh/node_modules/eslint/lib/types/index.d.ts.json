{
    "sourceFile": "node_modules/eslint/lib/types/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892242545,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview This file contains the core types for ESLint. It was initially extracted\n * from the `@types/eslint` package.\n */\n\n/*\n * MIT License\n * Copyright (c) Microsoft Corporation.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE\n */\n\nimport * as ESTree from \"estree\";\nimport type {\n    RuleVisitor,\n    TextSourceCode,\n    Language,\n    SourceRange,\n    TraversalStep,\n    LanguageOptions as GenericLanguageOptions,\n    RuleDefinition,\n    RuleContext as CoreRuleContext,\n    RuleContextTypeOptions,\n    DeprecatedInfo\n} from \"@eslint/core\";\nimport { JSONSchema4 } from \"json-schema\";\nimport { LegacyESLint } from \"./use-at-your-own-risk.js\";\n\n/*\n * Need to extend the `RuleContext` interface to include the\n * deprecated methods that have not yet been removed.\n * TODO: Remove in v10.0.0.\n */\ndeclare module \"@eslint/core\" {\n    interface RuleContext {\n\n        /** @deprecated Use `sourceCode.getAncestors()` instead */\n        getAncestors(): ESTree.Node[];\n\n        /** @deprecated Use `sourceCode.getDeclaredVariables()` instead */\n        getDeclaredVariables(node: ESTree.Node): Scope.Variable[];\n\n        /** @deprecated Use `sourceCode.getScope()` instead */\n        getScope(): Scope.Scope;\n\n        /** @deprecated Use `sourceCode.markVariableAsUsed()` instead */\n        markVariableAsUsed(name: string): boolean;\n    }\n}\n\nexport namespace AST {\n    type TokenType =\n        | \"Boolean\"\n        | \"Null\"\n        | \"Identifier\"\n        | \"Keyword\"\n        | \"Punctuator\"\n        | \"JSXIdentifier\"\n        | \"JSXText\"\n        | \"Numeric\"\n        | \"String\"\n        | \"RegularExpression\";\n\n    interface Token {\n        type: TokenType;\n        value: string;\n        range: Range;\n        loc: SourceLocation;\n    }\n\n    interface SourceLocation {\n        start: ESTree.Position;\n        end: ESTree.Position;\n    }\n\n    type Range = [number, number];\n\n    interface Program extends ESTree.Program {\n        comments: ESTree.Comment[];\n        tokens: Token[];\n        loc: SourceLocation;\n        range: Range;\n    }\n}\n\nexport namespace Scope {\n    interface ScopeManager {\n        scopes: Scope[];\n        globalScope: Scope | null;\n\n        acquire(node: ESTree.Node, inner?: boolean): Scope | null;\n\n        getDeclaredVariables(node: ESTree.Node): Variable[];\n    }\n\n    interface Scope {\n        type:\n        | \"block\"\n        | \"catch\"\n        | \"class\"\n        | \"for\"\n        | \"function\"\n        | \"function-expression-name\"\n        | \"global\"\n        | \"module\"\n        | \"switch\"\n        | \"with\"\n        | \"TDZ\";\n        isStrict: boolean;\n        upper: Scope | null;\n        childScopes: Scope[];\n        variableScope: Scope;\n        block: ESTree.Node;\n        variables: Variable[];\n        set: Map<string, Variable>;\n        references: Reference[];\n        through: Reference[];\n        functionExpressionScope: boolean;\n    }\n\n    interface Variable {\n        name: string;\n        scope: Scope;\n        identifiers: ESTree.Identifier[];\n        references: Reference[];\n        defs: Definition[];\n    }\n\n    interface Reference {\n        identifier: ESTree.Identifier;\n        from: Scope;\n        resolved: Variable | null;\n        writeExpr: ESTree.Node | null;\n        init: boolean;\n\n        isWrite(): boolean;\n\n        isRead(): boolean;\n\n        isWriteOnly(): boolean;\n\n        isReadOnly(): boolean;\n\n        isReadWrite(): boolean;\n    }\n\n    type DefinitionType =\n        | { type: \"CatchClause\"; node: ESTree.CatchClause; parent: null }\n        | { type: \"ClassName\"; node: ESTree.ClassDeclaration | ESTree.ClassExpression; parent: null }\n        | { type: \"FunctionName\"; node: ESTree.FunctionDeclaration | ESTree.FunctionExpression; parent: null }\n        | { type: \"ImplicitGlobalVariable\"; node: ESTree.Program; parent: null }\n        | {\n            type: \"ImportBinding\";\n            node: ESTree.ImportSpecifier | ESTree.ImportDefaultSpecifier | ESTree.ImportNamespaceSpecifier;\n            parent: ESTree.ImportDeclaration;\n        }\n        | {\n            type: \"Parameter\";\n            node: ESTree.FunctionDeclaration | ESTree.FunctionExpression | ESTree.ArrowFunctionExpression;\n            parent: null;\n        }\n        | { type: \"TDZ\"; node: any; parent: null }\n        | { type: \"Variable\"; node: ESTree.VariableDeclarator; parent: ESTree.VariableDeclaration };\n\n    type Definition = DefinitionType & { name: ESTree.Identifier };\n}\n\n// #region SourceCode\n\nexport class SourceCode implements TextSourceCode<{\n    LangOptions: Linter.LanguageOptions;\n    RootNode: AST.Program;\n    SyntaxElementWithLoc: AST.Token | ESTree.Node;\n    ConfigNode: ESTree.Comment;\n}> {\n    text: string;\n    ast: AST.Program;\n    lines: string[];\n    hasBOM: boolean;\n    parserServices: SourceCode.ParserServices;\n    scopeManager: Scope.ScopeManager;\n    visitorKeys: SourceCode.VisitorKeys;\n\n    constructor(text: string, ast: AST.Program);\n    constructor(config: SourceCode.Config);\n\n    static splitLines(text: string): string[];\n\n    getLoc(syntaxElement: AST.Token | ESTree.Node): ESTree.SourceLocation;\n    getRange(syntaxElement: AST.Token | ESTree.Node): SourceRange;\n\n    getText(node?: ESTree.Node, beforeCount?: number, afterCount?: number): string;\n\n    getLines(): string[];\n\n    getAllComments(): ESTree.Comment[];\n\n    getAncestors(node: ESTree.Node): ESTree.Node[];\n\n    getDeclaredVariables(node: ESTree.Node): Scope.Variable[];\n\n    getJSDocComment(node: ESTree.Node): ESTree.Comment | null;\n\n    getNodeByRangeIndex(index: number): ESTree.Node | null;\n\n    isSpaceBetweenTokens(first: AST.Token, second: AST.Token): boolean;\n\n    getLocFromIndex(index: number): ESTree.Position;\n\n    getIndexFromLoc(location: ESTree.Position): number;\n\n    // Inherited methods from TokenStore\n    // ---------------------------------\n\n    getTokenByRangeStart(offset: number, options?: { includeComments: false }): AST.Token | null;\n    getTokenByRangeStart(offset: number, options: { includeComments: boolean }): AST.Token | ESTree.Comment | null;\n\n    getFirstToken: SourceCode.UnaryNodeCursorWithSkipOptions;\n\n    getFirstTokens: SourceCode.UnaryNodeCursorWithCountOptions;\n\n    getLastToken: SourceCode.UnaryNodeCursorWithSkipOptions;\n\n    getLastTokens: SourceCode.UnaryNodeCursorWithCountOptions;\n\n    getTokenBefore: SourceCode.UnaryCursorWithSkipOptions;\n\n    getTokensBefore: SourceCode.UnaryCursorWithCountOptions;\n\n    getTokenAfter: SourceCode.UnaryCursorWithSkipOptions;\n\n    getTokensAfter: SourceCode.UnaryCursorWithCountOptions;\n\n    getFirstTokenBetween: SourceCode.BinaryCursorWithSkipOptions;\n\n    getFirstTokensBetween: SourceCode.BinaryCursorWithCountOptions;\n\n    getLastTokenBetween: SourceCode.BinaryCursorWithSkipOptions;\n\n    getLastTokensBetween: SourceCode.BinaryCursorWithCountOptions;\n\n    getTokensBetween: SourceCode.BinaryCursorWithCountOptions;\n\n    getTokens:\n        & ((node: ESTree.Node, beforeCount?: number, afterCount?: number) => AST.Token[])\n        & SourceCode.UnaryNodeCursorWithCountOptions;\n\n    commentsExistBetween(\n        left: ESTree.Node | AST.Token | ESTree.Comment,\n        right: ESTree.Node | AST.Token | ESTree.Comment,\n    ): boolean;\n\n    getCommentsBefore(nodeOrToken: ESTree.Node | AST.Token): ESTree.Comment[];\n\n    getCommentsAfter(nodeOrToken: ESTree.Node | AST.Token): ESTree.Comment[];\n\n    getCommentsInside(node: ESTree.Node): ESTree.Comment[];\n\n    getScope(node: ESTree.Node): Scope.Scope;\n\n    isSpaceBetween(\n        first: ESTree.Node | AST.Token,\n        second: ESTree.Node | AST.Token,\n    ): boolean;\n\n    markVariableAsUsed(name: string, refNode?: ESTree.Node): boolean;\n\n    traverse(): Iterable<TraversalStep>;\n}\n\nexport namespace SourceCode {\n    interface Config {\n        text: string;\n        ast: AST.Program;\n        parserServices?: ParserServices | undefined;\n        scopeManager?: Scope.ScopeManager | undefined;\n        visitorKeys?: VisitorKeys | undefined;\n    }\n\n    type ParserServices = any;\n\n    interface VisitorKeys {\n        [nodeType: string]: string[];\n    }\n\n    interface UnaryNodeCursorWithSkipOptions {\n        <T extends AST.Token>(\n            node: ESTree.Node,\n            options:\n                | ((token: AST.Token) => token is T)\n                | {\n                    filter: (token: AST.Token) => token is T;\n                    includeComments?: false | undefined;\n                    skip?: number | undefined;\n                },\n        ): T | null;\n        <T extends AST.Token | ESTree.Comment>(\n            node: ESTree.Node,\n            options: {\n                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;\n                includeComments: boolean;\n                skip?: number | undefined;\n            },\n        ): T | null;\n        (\n            node: ESTree.Node,\n            options?:\n                | {\n                    filter?: ((token: AST.Token) => boolean) | undefined;\n                    includeComments?: false | undefined;\n                    skip?: number | undefined;\n                }\n                | ((token: AST.Token) => boolean)\n                | number,\n        ): AST.Token | null;\n        (\n            node: ESTree.Node,\n            options: {\n                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;\n                includeComments: boolean;\n                skip?: number | undefined;\n            },\n        ): AST.Token | ESTree.Comment | null;\n    }\n\n    interface UnaryNodeCursorWithCountOptions {\n        <T extends AST.Token>(\n            node: ESTree.Node,\n            options:\n                | ((token: AST.Token) => token is T)\n                | {\n                    filter: (token: AST.Token) => token is T;\n                    includeComments?: false | undefined;\n                    count?: number | undefined;\n                },\n        ): T[];\n        <T extends AST.Token | ESTree.Comment>(\n            node: ESTree.Node,\n            options: {\n                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;\n                includeComments: boolean;\n                count?: number | undefined;\n            },\n        ): T[];\n        (\n            node: ESTree.Node,\n            options?:\n                | {\n                    filter?: ((token: AST.Token) => boolean) | undefined;\n                    includeComments?: false | undefined;\n                    count?: number | undefined;\n                }\n                | ((token: AST.Token) => boolean)\n                | number,\n        ): AST.Token[];\n        (\n            node: ESTree.Node,\n            options: {\n                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;\n                includeComments: boolean;\n                count?: number | undefined;\n            },\n        ): Array<AST.Token | ESTree.Comment>;\n    }\n\n    interface UnaryCursorWithSkipOptions {\n        <T extends AST.Token>(\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options:\n                | ((token: AST.Token) => token is T)\n                | {\n                    filter: (token: AST.Token) => token is T;\n                    includeComments?: false | undefined;\n                    skip?: number | undefined;\n                },\n        ): T | null;\n        <T extends AST.Token | ESTree.Comment>(\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;\n                includeComments: boolean;\n                skip?: number | undefined;\n            },\n        ): T | null;\n        (\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options?:\n                | {\n                    filter?: ((token: AST.Token) => boolean) | undefined;\n                    includeComments?: false | undefined;\n                    skip?: number | undefined;\n                }\n                | ((token: AST.Token) => boolean)\n                | number,\n        ): AST.Token | null;\n        (\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;\n                includeComments: boolean;\n                skip?: number | undefined;\n            },\n        ): AST.Token | ESTree.Comment | null;\n    }\n\n    interface UnaryCursorWithCountOptions {\n        <T extends AST.Token>(\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options:\n                | ((token: AST.Token) => token is T)\n                | {\n                    filter: (token: AST.Token) => token is T;\n                    includeComments?: false | undefined;\n                    count?: number | undefined;\n                },\n        ): T[];\n        <T extends AST.Token | ESTree.Comment>(\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;\n                includeComments: boolean;\n                count?: number | undefined;\n            },\n        ): T[];\n        (\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options?:\n                | {\n                    filter?: ((token: AST.Token) => boolean) | undefined;\n                    includeComments?: false | undefined;\n                    count?: number | undefined;\n                }\n                | ((token: AST.Token) => boolean)\n                | number,\n        ): AST.Token[];\n        (\n            node: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;\n                includeComments: boolean;\n                count?: number | undefined;\n            },\n        ): Array<AST.Token | ESTree.Comment>;\n    }\n\n    interface BinaryCursorWithSkipOptions {\n        <T extends AST.Token>(\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options:\n                | ((token: AST.Token) => token is T)\n                | {\n                    filter: (token: AST.Token) => token is T;\n                    includeComments?: false | undefined;\n                    skip?: number | undefined;\n                },\n        ): T | null;\n        <T extends AST.Token | ESTree.Comment>(\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;\n                includeComments: boolean;\n                skip?: number | undefined;\n            },\n        ): T | null;\n        (\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options?:\n                | {\n                    filter?: ((token: AST.Token) => boolean) | undefined;\n                    includeComments?: false | undefined;\n                    skip?: number | undefined;\n                }\n                | ((token: AST.Token) => boolean)\n                | number,\n        ): AST.Token | null;\n        (\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;\n                includeComments: boolean;\n                skip?: number | undefined;\n            },\n        ): AST.Token | ESTree.Comment | null;\n    }\n\n    interface BinaryCursorWithCountOptions {\n        <T extends AST.Token>(\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options:\n                | ((token: AST.Token) => token is T)\n                | {\n                    filter: (token: AST.Token) => token is T;\n                    includeComments?: false | undefined;\n                    count?: number | undefined;\n                },\n        ): T[];\n        <T extends AST.Token | ESTree.Comment>(\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter: (tokenOrComment: AST.Token | ESTree.Comment) => tokenOrComment is T;\n                includeComments: boolean;\n                count?: number | undefined;\n            },\n        ): T[];\n        (\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options?:\n                | {\n                    filter?: ((token: AST.Token) => boolean) | undefined;\n                    includeComments?: false | undefined;\n                    count?: number | undefined;\n                }\n                | ((token: AST.Token) => boolean)\n                | number,\n        ): AST.Token[];\n        (\n            left: ESTree.Node | AST.Token | ESTree.Comment,\n            right: ESTree.Node | AST.Token | ESTree.Comment,\n            options: {\n                filter?: ((token: AST.Token | ESTree.Comment) => boolean) | undefined;\n                includeComments: boolean;\n                count?: number | undefined;\n            },\n        ): Array<AST.Token | ESTree.Comment>;\n    }\n}\n\n// #endregion\n\nexport namespace Rule {\n\n    type RuleModule = RuleDefinition<{\n        LangOptions: Linter.LanguageOptions,\n        Code: SourceCode,\n        RuleOptions: any[],\n        Visitor: NodeListener,\n        Node: ESTree.Node,\n        MessageIds: string,\n        ExtRuleDocs: {}\n    }>;\n\n    type NodeTypes = ESTree.Node[\"type\"];\n    interface NodeListener extends RuleVisitor {\n        ArrayExpression?: ((node: ESTree.ArrayExpression & NodeParentExtension) => void) | undefined;\n        \"ArrayExpression:exit\"?: ((node: ESTree.ArrayExpression & NodeParentExtension) => void) | undefined;\n        ArrayPattern?: ((node: ESTree.ArrayPattern & NodeParentExtension) => void) | undefined;\n        \"ArrayPattern:exit\"?: ((node: ESTree.ArrayPattern & NodeParentExtension) => void) | undefined;\n        ArrowFunctionExpression?: ((node: ESTree.ArrowFunctionExpression & NodeParentExtension) => void) | undefined;\n        \"ArrowFunctionExpression:exit\"?: ((node: ESTree.ArrowFunctionExpression & NodeParentExtension) => void) | undefined;\n        AssignmentExpression?: ((node: ESTree.AssignmentExpression & NodeParentExtension) => void) | undefined;\n        \"AssignmentExpression:exit\"?: ((node: ESTree.AssignmentExpression & NodeParentExtension) => void) | undefined;\n        AssignmentPattern?: ((node: ESTree.AssignmentPattern & NodeParentExtension) => void) | undefined;\n        \"AssignmentPattern:exit\"?: ((node: ESTree.AssignmentPattern & NodeParentExtension) => void) | undefined;\n        AwaitExpression?: ((node: ESTree.AwaitExpression & NodeParentExtension) => void) | undefined;\n        \"AwaitExpression:exit\"?: ((node: ESTree.AwaitExpression & NodeParentExtension) => void) | undefined;\n        BinaryExpression?: ((node: ESTree.BinaryExpression & NodeParentExtension) => void) | undefined;\n        \"BinaryExpression:exit\"?: ((node: ESTree.BinaryExpression & NodeParentExtension) => void) | undefined;\n        BlockStatement?: ((node: ESTree.BlockStatement & NodeParentExtension) => void) | undefined;\n        \"BlockStatement:exit\"?: ((node: ESTree.BlockStatement & NodeParentExtension) => void) | undefined;\n        BreakStatement?: ((node: ESTree.BreakStatement & NodeParentExtension) => void) | undefined;\n        \"BreakStatement:exit\"?: ((node: ESTree.BreakStatement & NodeParentExtension) => void) | undefined;\n        CallExpression?: ((node: ESTree.CallExpression & NodeParentExtension) => void) | undefined;\n        \"CallExpression:exit\"?: ((node: ESTree.CallExpression & NodeParentExtension) => void) | undefined;\n        CatchClause?: ((node: ESTree.CatchClause & NodeParentExtension) => void) | undefined;\n        \"CatchClause:exit\"?: ((node: ESTree.CatchClause & NodeParentExtension) => void) | undefined;\n        ChainExpression?: ((node: ESTree.ChainExpression & NodeParentExtension) => void) | undefined;\n        \"ChainExpression:exit\"?: ((node: ESTree.ChainExpression & NodeParentExtension) => void) | undefined;\n        ClassBody?: ((node: ESTree.ClassBody & NodeParentExtension) => void) | undefined;\n        \"ClassBody:exit\"?: ((node: ESTree.ClassBody & NodeParentExtension) => void) | undefined;\n        ClassDeclaration?: ((node: ESTree.ClassDeclaration & NodeParentExtension) => void) | undefined;\n        \"ClassDeclaration:exit\"?: ((node: ESTree.ClassDeclaration & NodeParentExtension) => void) | undefined;\n        ClassExpression?: ((node: ESTree.ClassExpression & NodeParentExtension) => void) | undefined;\n        \"ClassExpression:exit\"?: ((node: ESTree.ClassExpression & NodeParentExtension) => void) | undefined;\n        ConditionalExpression?: ((node: ESTree.ConditionalExpression & NodeParentExtension) => void) | undefined;\n        \"ConditionalExpression:exit\"?: ((node: ESTree.ConditionalExpression & NodeParentExtension) => void) | undefined;\n        ContinueStatement?: ((node: ESTree.ContinueStatement & NodeParentExtension) => void) | undefined;\n        \"ContinueStatement:exit\"?: ((node: ESTree.ContinueStatement & NodeParentExtension) => void) | undefined;\n        DebuggerStatement?: ((node: ESTree.DebuggerStatement & NodeParentExtension) => void) | undefined;\n        \"DebuggerStatement:exit\"?: ((node: ESTree.DebuggerStatement & NodeParentExtension) => void) | undefined;\n        DoWhileStatement?: ((node: ESTree.DoWhileStatement & NodeParentExtension) => void) | undefined;\n        \"DoWhileStatement:exit\"?: ((node: ESTree.DoWhileStatement & NodeParentExtension) => void) | undefined;\n        EmptyStatement?: ((node: ESTree.EmptyStatement & NodeParentExtension) => void) | undefined;\n        \"EmptyStatement:exit\"?: ((node: ESTree.EmptyStatement & NodeParentExtension) => void) | undefined;\n        ExportAllDeclaration?: ((node: ESTree.ExportAllDeclaration & NodeParentExtension) => void) | undefined;\n        \"ExportAllDeclaration:exit\"?: ((node: ESTree.ExportAllDeclaration & NodeParentExtension) => void) | undefined;\n        ExportDefaultDeclaration?: ((node: ESTree.ExportDefaultDeclaration & NodeParentExtension) => void) | undefined;\n        \"ExportDefaultDeclaration:exit\"?: ((node: ESTree.ExportDefaultDeclaration & NodeParentExtension) => void) | undefined;\n        ExportNamedDeclaration?: ((node: ESTree.ExportNamedDeclaration & NodeParentExtension) => void) | undefined;\n        \"ExportNamedDeclaration:exit\"?: ((node: ESTree.ExportNamedDeclaration & NodeParentExtension) => void) | undefined;\n        ExportSpecifier?: ((node: ESTree.ExportSpecifier & NodeParentExtension) => void) | undefined;\n        \"ExportSpecifier:exit\"?: ((node: ESTree.ExportSpecifier & NodeParentExtension) => void) | undefined;\n        ExpressionStatement?: ((node: ESTree.ExpressionStatement & NodeParentExtension) => void) | undefined;\n        \"ExpressionStatement:exit\"?: ((node: ESTree.ExpressionStatement & NodeParentExtension) => void) | undefined;\n        ForInStatement?: ((node: ESTree.ForInStatement & NodeParentExtension) => void) | undefined;\n        \"ForInStatement:exit\"?: ((node: ESTree.ForInStatement & NodeParentExtension) => void) | undefined;\n        ForOfStatement?: ((node: ESTree.ForOfStatement & NodeParentExtension) => void) | undefined;\n        \"ForOfStatement:exit\"?: ((node: ESTree.ForOfStatement & NodeParentExtension) => void) | undefined;\n        ForStatement?: ((node: ESTree.ForStatement & NodeParentExtension) => void) | undefined;\n        \"ForStatement:exit\"?: ((node: ESTree.ForStatement & NodeParentExtension) => void) | undefined;\n        FunctionDeclaration?: ((node: ESTree.FunctionDeclaration & NodeParentExtension) => void) | undefined;\n        \"FunctionDeclaration:exit\"?: ((node: ESTree.FunctionDeclaration & NodeParentExtension) => void) | undefined;\n        FunctionExpression?: ((node: ESTree.FunctionExpression & NodeParentExtension) => void) | undefined;\n        \"FunctionExpression:exit\"?: ((node: ESTree.FunctionExpression & NodeParentExtension) => void) | undefined;\n        Identifier?: ((node: ESTree.Identifier & NodeParentExtension) => void) | undefined;\n        \"Identifier:exit\"?: ((node: ESTree.Identifier & NodeParentExtension) => void) | undefined;\n        IfStatement?: ((node: ESTree.IfStatement & NodeParentExtension) => void) | undefined;\n        \"IfStatement:exit\"?: ((node: ESTree.IfStatement & NodeParentExtension) => void) | undefined;\n        ImportDeclaration?: ((node: ESTree.ImportDeclaration & NodeParentExtension) => void) | undefined;\n        \"ImportDeclaration:exit\"?: ((node: ESTree.ImportDeclaration & NodeParentExtension) => void) | undefined;\n        ImportDefaultSpecifier?: ((node: ESTree.ImportDefaultSpecifier & NodeParentExtension) => void) | undefined;\n        \"ImportDefaultSpecifier:exit\"?: ((node: ESTree.ImportDefaultSpecifier & NodeParentExtension) => void) | undefined;\n        ImportExpression?: ((node: ESTree.ImportExpression & NodeParentExtension) => void) | undefined;\n        \"ImportExpression:exit\"?: ((node: ESTree.ImportExpression & NodeParentExtension) => void) | undefined;\n        ImportNamespaceSpecifier?: ((node: ESTree.ImportNamespaceSpecifier & NodeParentExtension) => void) | undefined;\n        \"ImportNamespaceSpecifier:exit\"?: ((node: ESTree.ImportNamespaceSpecifier & NodeParentExtension) => void) | undefined;\n        ImportSpecifier?: ((node: ESTree.ImportSpecifier & NodeParentExtension) => void) | undefined;\n        \"ImportSpecifier:exit\"?: ((node: ESTree.ImportSpecifier & NodeParentExtension) => void) | undefined;\n        LabeledStatement?: ((node: ESTree.LabeledStatement & NodeParentExtension) => void) | undefined;\n        \"LabeledStatement:exit\"?: ((node: ESTree.LabeledStatement & NodeParentExtension) => void) | undefined;\n        Literal?: ((node: ESTree.Literal & NodeParentExtension) => void) | undefined;\n        \"Literal:exit\"?: ((node: ESTree.Literal & NodeParentExtension) => void) | undefined;\n        LogicalExpression?: ((node: ESTree.LogicalExpression & NodeParentExtension) => void) | undefined;\n        \"LogicalExpression:exit\"?: ((node: ESTree.LogicalExpression & NodeParentExtension) => void) | undefined;\n        MemberExpression?: ((node: ESTree.MemberExpression & NodeParentExtension) => void) | undefined;\n        \"MemberExpression:exit\"?: ((node: ESTree.MemberExpression & NodeParentExtension) => void) | undefined;\n        MetaProperty?: ((node: ESTree.MetaProperty & NodeParentExtension) => void) | undefined;\n        \"MetaProperty:exit\"?: ((node: ESTree.MetaProperty & NodeParentExtension) => void) | undefined;\n        MethodDefinition?: ((node: ESTree.MethodDefinition & NodeParentExtension) => void) | undefined;\n        \"MethodDefinition:exit\"?: ((node: ESTree.MethodDefinition & NodeParentExtension) => void) | undefined;\n        NewExpression?: ((node: ESTree.NewExpression & NodeParentExtension) => void) | undefined;\n        \"NewExpression:exit\"?: ((node: ESTree.NewExpression & NodeParentExtension) => void) | undefined;\n        ObjectExpression?: ((node: ESTree.ObjectExpression & NodeParentExtension) => void) | undefined;\n        \"ObjectExpression:exit\"?: ((node: ESTree.ObjectExpression & NodeParentExtension) => void) | undefined;\n        ObjectPattern?: ((node: ESTree.ObjectPattern & NodeParentExtension) => void) | undefined;\n        \"ObjectPattern:exit\"?: ((node: ESTree.ObjectPattern & NodeParentExtension) => void) | undefined;\n        PrivateIdentifier?: ((node: ESTree.PrivateIdentifier & NodeParentExtension) => void) | undefined;\n        \"PrivateIdentifier:exit\"?: ((node: ESTree.PrivateIdentifier & NodeParentExtension) => void) | undefined;\n        Program?: ((node: ESTree.Program) => void) | undefined;\n        \"Program:exit\"?: ((node: ESTree.Program) => void) | undefined;\n        Property?: ((node: ESTree.Property & NodeParentExtension) => void) | undefined;\n        \"Property:exit\"?: ((node: ESTree.Property & NodeParentExtension) => void) | undefined;\n        PropertyDefinition?: ((node: ESTree.PropertyDefinition & NodeParentExtension) => void) | undefined;\n        \"PropertyDefinition:exit\"?: ((node: ESTree.PropertyDefinition & NodeParentExtension) => void) | undefined;\n        RestElement?: ((node: ESTree.RestElement & NodeParentExtension) => void) | undefined;\n        \"RestElement:exit\"?: ((node: ESTree.RestElement & NodeParentExtension) => void) | undefined;\n        ReturnStatement?: ((node: ESTree.ReturnStatement & NodeParentExtension) => void) | undefined;\n        \"ReturnStatement:exit\"?: ((node: ESTree.ReturnStatement & NodeParentExtension) => void) | undefined;\n        SequenceExpression?: ((node: ESTree.SequenceExpression & NodeParentExtension) => void) | undefined;\n        \"SequenceExpression:exit\"?: ((node: ESTree.SequenceExpression & NodeParentExtension) => void) | undefined;\n        SpreadElement?: ((node: ESTree.SpreadElement & NodeParentExtension) => void) | undefined;\n        \"SpreadElement:exit\"?: ((node: ESTree.SpreadElement & NodeParentExtension) => void) | undefined;\n        StaticBlock?: ((node: ESTree.StaticBlock & NodeParentExtension) => void) | undefined;\n        \"StaticBlock:exit\"?: ((node: ESTree.StaticBlock & NodeParentExtension) => void) | undefined;\n        Super?: ((node: ESTree.Super & NodeParentExtension) => void) | undefined;\n        \"Super:exit\"?: ((node: ESTree.Super & NodeParentExtension) => void) | undefined;\n        SwitchCase?: ((node: ESTree.SwitchCase & NodeParentExtension) => void) | undefined;\n        \"SwitchCase:exit\"?: ((node: ESTree.SwitchCase & NodeParentExtension) => void) | undefined;\n        SwitchStatement?: ((node: ESTree.SwitchStatement & NodeParentExtension) => void) | undefined;\n        \"SwitchStatement:exit\"?: ((node: ESTree.SwitchStatement & NodeParentExtension) => void) | undefined;\n        TaggedTemplateExpression?: ((node: ESTree.TaggedTemplateExpression & NodeParentExtension) => void) | undefined;\n        \"TaggedTemplateExpression:exit\"?: ((node: ESTree.TaggedTemplateExpression & NodeParentExtension) => void) | undefined;\n        TemplateElement?: ((node: ESTree.TemplateElement & NodeParentExtension) => void) | undefined;\n        \"TemplateElement:exit\"?: ((node: ESTree.TemplateElement & NodeParentExtension) => void) | undefined;\n        TemplateLiteral?: ((node: ESTree.TemplateLiteral & NodeParentExtension) => void) | undefined;\n        \"TemplateLiteral:exit\"?: ((node: ESTree.TemplateLiteral & NodeParentExtension) => void) | undefined;\n        ThisExpression?: ((node: ESTree.ThisExpression & NodeParentExtension) => void) | undefined;\n        \"ThisExpression:exit\"?: ((node: ESTree.ThisExpression & NodeParentExtension) => void) | undefined;\n        ThrowStatement?: ((node: ESTree.ThrowStatement & NodeParentExtension) => void) | undefined;\n        \"ThrowStatement:exit\"?: ((node: ESTree.ThrowStatement & NodeParentExtension) => void) | undefined;\n        TryStatement?: ((node: ESTree.TryStatement & NodeParentExtension) => void) | undefined;\n        \"TryStatement:exit\"?: ((node: ESTree.TryStatement & NodeParentExtension) => void) | undefined;\n        UnaryExpression?: ((node: ESTree.UnaryExpression & NodeParentExtension) => void) | undefined;\n        \"UnaryExpression:exit\"?: ((node: ESTree.UnaryExpression & NodeParentExtension) => void) | undefined;\n        UpdateExpression?: ((node: ESTree.UpdateExpression & NodeParentExtension) => void) | undefined;\n        \"UpdateExpression:exit\"?: ((node: ESTree.UpdateExpression & NodeParentExtension) => void) | undefined;\n        VariableDeclaration?: ((node: ESTree.VariableDeclaration & NodeParentExtension) => void) | undefined;\n        \"VariableDeclaration:exit\"?: ((node: ESTree.VariableDeclaration & NodeParentExtension) => void) | undefined;\n        VariableDeclarator?: ((node: ESTree.VariableDeclarator & NodeParentExtension) => void) | undefined;\n        \"VariableDeclarator:exit\"?: ((node: ESTree.VariableDeclarator & NodeParentExtension) => void) | undefined;\n        WhileStatement?: ((node: ESTree.WhileStatement & NodeParentExtension) => void) | undefined;\n        \"WhileStatement:exit\"?: ((node: ESTree.WhileStatement & NodeParentExtension) => void) | undefined;\n        WithStatement?: ((node: ESTree.WithStatement & NodeParentExtension) => void) | undefined;\n        \"WithStatement:exit\"?: ((node: ESTree.WithStatement & NodeParentExtension) => void) | undefined;\n        YieldExpression?: ((node: ESTree.YieldExpression & NodeParentExtension) => void) | undefined;\n        \"YieldExpression:exit\"?: ((node: ESTree.YieldExpression & NodeParentExtension) => void) | undefined;\n    }\n\n    interface NodeParentExtension {\n        parent: Node;\n    }\n    type Node = ESTree.Node & NodeParentExtension;\n\n    interface RuleListener extends NodeListener {\n        onCodePathStart?(codePath: CodePath, node: Node): void;\n\n        onCodePathEnd?(codePath: CodePath, node: Node): void;\n\n        onCodePathSegmentStart?(segment: CodePathSegment, node: Node): void;\n\n        onCodePathSegmentEnd?(segment: CodePathSegment, node: Node): void;\n\n        onCodePathSegmentLoop?(fromSegment: CodePathSegment, toSegment: CodePathSegment, node: Node): void;\n\n        [key: string]:\n        | ((codePath: CodePath, node: Node) => void)\n        | ((segment: CodePathSegment, node: Node) => void)\n        | ((fromSegment: CodePathSegment, toSegment: CodePathSegment, node: Node) => void)\n        | ((node: Node) => void)\n        | NodeListener[keyof NodeListener]\n        | undefined;\n    }\n\n    type CodePathOrigin = \"program\" | \"function\" | \"class-field-initializer\" | \"class-static-block\";\n\n    interface CodePath {\n        id: string;\n        origin: CodePathOrigin;\n        initialSegment: CodePathSegment;\n        finalSegments: CodePathSegment[];\n        returnedSegments: CodePathSegment[];\n        thrownSegments: CodePathSegment[];\n        upper: CodePath | null;\n        childCodePaths: CodePath[];\n    }\n\n    interface CodePathSegment {\n        id: string;\n        nextSegments: CodePathSegment[];\n        prevSegments: CodePathSegment[];\n        reachable: boolean;\n    }\n\n    interface RuleMetaData {\n        /** Properties often used for documentation generation and tooling. */\n        docs?: {\n            /** Provides a short description of the rule. Commonly used when generating lists of rules. */\n            description?: string | undefined;\n            /** Historically used by some plugins that divide rules into categories in their documentation. */\n            category?: string | undefined;\n            /** Historically used by some plugins to indicate a rule belongs in their `recommended` configuration. */\n            recommended?: boolean | undefined;\n            /** Specifies the URL at which the full documentation can be accessed. Code editors often use this to provide a helpful link on highlighted rule violations. */\n            url?: string | undefined;\n        } | undefined;\n        /** Violation and suggestion messages. */\n        messages?: { [messageId: string]: string } | undefined;\n        /**\n         * Specifies if the `--fix` option on the command line automatically fixes problems reported by the rule.\n         * Mandatory for fixable rules.\n         */\n        fixable?: \"code\" | \"whitespace\" | undefined;\n        /**\n         * Specifies the [options](https://eslint.org/docs/latest/extend/custom-rules#options-schemas)\n         * so ESLint can prevent invalid [rule configurations](https://eslint.org/docs/latest/use/configure/rules#configuring-rules).\n         * Mandatory for rules with options.\n         */\n        schema?: JSONSchema4 | JSONSchema4[] | false | undefined;\n\n        /** Any default options to be recursively merged on top of any user-provided options. */\n        defaultOptions?: unknown[];\n\n        /** Indicates whether the rule has been deprecated or provides additional metadata about the deprecation. Omit if not deprecated. */\n        deprecated?: boolean | DeprecatedInfo | undefined;\n        /**\n         * @deprecated Use deprecated.replacedBy instead.\n         * The name of the rule(s) this rule was replaced by, if it was deprecated.\n         */\n        replacedBy?: readonly string[];\n\n        /**\n         * Indicates the type of rule:\n         * - `\"problem\"` means the rule is identifying code that either will cause an error or may cause a confusing behavior. Developers should consider this a high priority to resolve.\n         * - `\"suggestion\"` means the rule is identifying something that could be done in a better way but no errors will occur if the code isn’t changed.\n         * - `\"layout\"` means the rule cares primarily about whitespace, semicolons, commas, and parentheses,\n         *   all the parts of the program that determine how the code looks rather than how it executes.\n         *   These rules work on parts of the code that aren’t specified in the AST.\n         */\n        type?: \"problem\" | \"suggestion\" | \"layout\" | undefined;\n        /**\n         * Specifies whether the rule can return suggestions (defaults to `false` if omitted).\n         * Mandatory for rules that provide suggestions.\n         */\n        hasSuggestions?: boolean | undefined;\n    }\n\n    interface RuleContext extends CoreRuleContext<RuleContextTypeOptions & {\n        LangOptions: Linter.LanguageOptions;\n        Code: SourceCode;\n        Node: ESTree.Node; }> {\n        // report(descriptor: ReportDescriptor): void;\n    }\n\n    type ReportFixer = (fixer: RuleFixer) => null | Fix | IterableIterator<Fix> | Fix[];\n\n    interface ReportDescriptorOptionsBase {\n        data?: { [key: string]: string };\n\n        fix?: null | ReportFixer;\n    }\n\n    interface SuggestionReportOptions {\n        data?: { [key: string]: string };\n\n        fix: ReportFixer;\n    }\n\n    type SuggestionDescriptorMessage = { desc: string } | { messageId: string };\n    type SuggestionReportDescriptor = SuggestionDescriptorMessage & SuggestionReportOptions;\n\n    interface ReportDescriptorOptions extends ReportDescriptorOptionsBase {\n        suggest?: SuggestionReportDescriptor[] | null | undefined;\n    }\n\n    type ReportDescriptor = ReportDescriptorMessage & ReportDescriptorLocation & ReportDescriptorOptions;\n    type ReportDescriptorMessage = { message: string } | { messageId: string };\n    type ReportDescriptorLocation =\n        | { node: ESTree.Node }\n        | { loc: AST.SourceLocation | { line: number; column: number } };\n\n    interface RuleFixer {\n        insertTextAfter(nodeOrToken: ESTree.Node | AST.Token, text: string): Fix;\n\n        insertTextAfterRange(range: AST.Range, text: string): Fix;\n\n        insertTextBefore(nodeOrToken: ESTree.Node | AST.Token, text: string): Fix;\n\n        insertTextBeforeRange(range: AST.Range, text: string): Fix;\n\n        remove(nodeOrToken: ESTree.Node | AST.Token): Fix;\n\n        removeRange(range: AST.Range): Fix;\n\n        replaceText(nodeOrToken: ESTree.Node | AST.Token, text: string): Fix;\n\n        replaceTextRange(range: AST.Range, text: string): Fix;\n    }\n\n    interface Fix {\n        range: AST.Range;\n        text: string;\n    }\n}\n\n// #region Linter\n\nexport class Linter {\n    static readonly version: string;\n\n    version: string;\n\n    constructor(options?: { cwd?: string | undefined; configType?: \"flat\" | \"eslintrc\" });\n\n    verify(\n        code: SourceCode | string,\n        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],\n        filename?: string,\n    ): Linter.LintMessage[];\n    verify(\n        code: SourceCode | string,\n        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],\n        options: Linter.LintOptions,\n    ): Linter.LintMessage[];\n\n    verifyAndFix(\n        code: string,\n        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],\n        filename?: string,\n    ): Linter.FixReport;\n    verifyAndFix(\n        code: string,\n        config: Linter.LegacyConfig | Linter.Config | Linter.Config[],\n        options: Linter.FixOptions,\n    ): Linter.FixReport;\n\n    getSourceCode(): SourceCode;\n\n    defineRule(name: string, rule: Rule.RuleModule): void;\n\n    defineRules(rules: { [name: string]: Rule.RuleModule }): void;\n\n    getRules(): Map<string, Rule.RuleModule>;\n\n    defineParser(name: string, parser: Linter.Parser): void;\n\n    getTimes(): Linter.Stats[\"times\"];\n\n    getFixPassCount(): Linter.Stats[\"fixPasses\"];\n}\n\nexport namespace Linter {\n    /**\n     * The numeric severity level for a rule.\n     *\n     * - `0` means off.\n     * - `1` means warn.\n     * - `2` means error.\n     *\n     * @see [Rule Severities](https://eslint.org/docs/latest/use/configure/rules#rule-severities)\n     */\n    type Severity = 0 | 1 | 2;\n\n    /**\n     * The human readable severity level for a rule.\n     *\n     * @see [Rule Severities](https://eslint.org/docs/latest/use/configure/rules#rule-severities)\n     */\n    type StringSeverity = \"off\" | \"warn\" | \"error\";\n\n    /**\n     * The numeric or human readable severity level for a rule.\n     *\n     * @see [Rule Severities](https://eslint.org/docs/latest/use/configure/rules#rule-severities)\n     */\n    type RuleSeverity = Severity | StringSeverity;\n\n    /**\n     * An array containing the rule severity level, followed by the rule options.\n     *\n     * @see [Rules](https://eslint.org/docs/latest/use/configure/rules)\n     */\n    type RuleSeverityAndOptions<Options extends any[] = any[]> = [RuleSeverity, ...Partial<Options>];\n\n    /**\n     * The severity level for the rule or an array containing the rule severity level, followed by the rule options.\n     *\n     * @see [Rules](https://eslint.org/docs/latest/use/configure/rules)\n     */\n    type RuleEntry<Options extends any[] = any[]> = RuleSeverity | RuleSeverityAndOptions<Options>;\n\n    /**\n     * The rules config object is a key/value map of rule names and their severity and options.\n     */\n    interface RulesRecord {\n        [rule: string]: RuleEntry;\n    }\n\n    /**\n     * A configuration object that may have a `rules` block.\n     */\n    interface HasRules<Rules extends RulesRecord = RulesRecord> {\n        rules?: Partial<Rules> | undefined;\n    }\n\n    /**\n     * The ECMAScript version of the code being linted.\n     */\n    type EcmaVersion =\n        | 3\n        | 5\n        | 6\n        | 7\n        | 8\n        | 9\n        | 10\n        | 11\n        | 12\n        | 13\n        | 14\n        | 15\n        | 16\n        | 2015\n        | 2016\n        | 2017\n        | 2018\n        | 2019\n        | 2020\n        | 2021\n        | 2022\n        | 2023\n        | 2024\n        | 2025\n        | \"latest\";\n\n    /**\n     * The type of JavaScript source code.\n     */\n    type SourceType = \"script\" | \"module\" | \"commonjs\";\n\n    /**\n     * ESLint legacy configuration.\n     *\n     * @see [ESLint Legacy Configuration](https://eslint.org/docs/latest/use/configure/)\n     */\n    interface BaseConfig<Rules extends RulesRecord = RulesRecord, OverrideRules extends RulesRecord = Rules>\n        extends HasRules<Rules> {\n        $schema?: string | undefined;\n\n        /**\n         * An environment provides predefined global variables.\n         *\n         * @see [Environments](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-environments)\n         */\n        env?: { [name: string]: boolean } | undefined;\n\n        /**\n         * Extending configuration files.\n         *\n         * @see [Extends](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#extending-configuration-files)\n         */\n        extends?: string | string[] | undefined;\n\n        /**\n         * Specifying globals.\n         *\n         * @see [Globals](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-globals)\n         */\n        globals?: Linter.Globals | undefined;\n\n        /**\n         * Disable processing of inline comments.\n         *\n         * @see [Disabling Inline Comments](https://eslint.org/docs/latest/use/configure/rules-deprecated#disabling-inline-comments)\n         */\n        noInlineConfig?: boolean | undefined;\n\n        /**\n         * Overrides can be used to use a differing configuration for matching sub-directories and files.\n         *\n         * @see [How do overrides work](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#how-do-overrides-work)\n         */\n        overrides?: Array<ConfigOverride<OverrideRules>> | undefined;\n\n        /**\n         * Parser.\n         *\n         * @see [Working with Custom Parsers](https://eslint.org/docs/latest/extend/custom-parsers)\n         * @see [Specifying Parser](https://eslint.org/docs/latest/use/configure/parser-deprecated)\n         */\n        parser?: string | undefined;\n\n        /**\n         * Parser options.\n         *\n         * @see [Working with Custom Parsers](https://eslint.org/docs/latest/extend/custom-parsers)\n         * @see [Specifying Parser Options](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options)\n         */\n        parserOptions?: ParserOptions | undefined;\n\n        /**\n         * Which third-party plugins define additional rules, environments, configs, etc. for ESLint to use.\n         *\n         * @see [Configuring Plugins](https://eslint.org/docs/latest/use/configure/plugins-deprecated#configure-plugins)\n         */\n        plugins?: string[] | undefined;\n\n        /**\n         * Specifying processor.\n         *\n         * @see [processor](https://eslint.org/docs/latest/use/configure/plugins-deprecated#specify-a-processor)\n         */\n        processor?: string | undefined;\n\n        /**\n         * Report unused eslint-disable comments as warning.\n         *\n         * @see [Report unused eslint-disable comments](https://eslint.org/docs/latest/use/configure/rules-deprecated#report-unused-eslint-disable-comments)\n         */\n        reportUnusedDisableDirectives?: boolean | undefined;\n\n        /**\n         * Settings.\n         *\n         * @see [Settings](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#adding-shared-settings)\n         */\n        settings?: { [name: string]: any } | undefined;\n    }\n\n    /**\n     * The overwrites that apply more differing configuration to specific files or directories.\n     */\n    interface ConfigOverride<Rules extends RulesRecord = RulesRecord> extends BaseConfig<Rules> {\n        /**\n         * The glob patterns for excluded files.\n         */\n        excludedFiles?: string | string[] | undefined;\n\n        /**\n         * The glob patterns for target files.\n         */\n        files: string | string[];\n    }\n\n    /**\n     * ESLint legacy configuration.\n     *\n     * @see [ESLint Legacy Configuration](https://eslint.org/docs/latest/use/configure/)\n     */\n    // https://github.com/eslint/eslint/blob/v8.57.0/conf/config-schema.js\n    interface LegacyConfig<Rules extends RulesRecord = RulesRecord, OverrideRules extends RulesRecord = Rules>\n        extends BaseConfig<Rules, OverrideRules> {\n        /**\n         * Tell ESLint to ignore specific files and directories.\n         *\n         * @see [Ignore Patterns](https://eslint.org/docs/latest/use/configure/ignore-deprecated#ignorepatterns-in-config-files)\n         */\n        ignorePatterns?: string | string[] | undefined;\n\n        /**\n         * @see [Using Configuration Files](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#using-configuration-files)\n         */\n        root?: boolean | undefined;\n    }\n\n    /**\n     * Parser options.\n     *\n     * @see [Specifying Parser Options](https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options)\n     */\n    interface ParserOptions {\n        /**\n         * Accepts any valid ECMAScript version number or `'latest'`:\n         *\n         * - A version: es3, es5, es6, es7, es8, es9, es10, es11, es12, es13, es14, ..., or\n         * - A year: es2015, es2016, es2017, es2018, es2019, es2020, es2021, es2022, es2023, ..., or\n         * - `'latest'`\n         *\n         * When it's a version or a year, the value must be a number - so do not include the `es` prefix.\n         *\n         * Specifies the version of ECMAScript syntax you want to use. This is used by the parser to determine how to perform scope analysis, and it affects the default\n         *\n         * @default 5\n         */\n        ecmaVersion?: EcmaVersion | undefined;\n\n        /**\n         * The type of JavaScript source code. Possible values are \"script\" for\n         * traditional script files, \"module\" for ECMAScript modules (ESM), and\n         * \"commonjs\" for CommonJS files.\n         *\n         * @default 'script'\n         *\n         * @see https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options\n         */\n        sourceType?: SourceType | undefined;\n\n        /**\n         * An object indicating which additional language features you'd like to use.\n         *\n         * @see https://eslint.org/docs/latest/use/configure/language-options-deprecated#specifying-parser-options\n         */\n        ecmaFeatures?: {\n            globalReturn?: boolean | undefined;\n            impliedStrict?: boolean | undefined;\n            jsx?: boolean | undefined;\n            experimentalObjectRestSpread?: boolean | undefined;\n            [key: string]: any;\n        } | undefined;\n        [key: string]: any;\n    }\n\n    interface LintOptions {\n        filename?: string | undefined;\n        preprocess?: ((code: string) => string[]) | undefined;\n        postprocess?: ((problemLists: LintMessage[][]) => LintMessage[]) | undefined;\n        filterCodeBlock?: boolean | undefined;\n        disableFixes?: boolean | undefined;\n        allowInlineConfig?: boolean | undefined;\n        reportUnusedDisableDirectives?: boolean | undefined;\n    }\n\n    interface LintSuggestion {\n        desc: string;\n        fix: Rule.Fix;\n        messageId?: string | undefined;\n    }\n\n    interface LintMessage {\n        column: number;\n        line: number;\n        endColumn?: number | undefined;\n        endLine?: number | undefined;\n        ruleId: string | null;\n        message: string;\n        messageId?: string | undefined;\n        /**\n         * @deprecated `nodeType` is deprecated and will be removed in the next major version.\n         */\n        nodeType?: string | undefined;\n        fatal?: true | undefined;\n        severity: Exclude<Severity, 0>;\n        fix?: Rule.Fix | undefined;\n        suggestions?: LintSuggestion[] | undefined;\n    }\n\n    interface LintSuppression {\n        kind: string;\n        justification: string;\n    }\n\n    interface SuppressedLintMessage extends LintMessage {\n        suppressions: LintSuppression[];\n    }\n\n    interface FixOptions extends LintOptions {\n        fix?: boolean | undefined;\n    }\n\n    interface FixReport {\n        fixed: boolean;\n        output: string;\n        messages: LintMessage[];\n    }\n\n    // Temporarily loosen type for just flat config files (see #68232)\n    type NonESTreeParser =\n        & Omit<ESTreeParser, \"parseForESLint\">\n        & ({\n            parse(text: string, options?: any): unknown;\n        } | {\n            parseForESLint(text: string, options?: any): Omit<ESLintParseResult, \"ast\" | \"scopeManager\"> & {\n                ast: unknown;\n                scopeManager?: unknown;\n            };\n        });\n\n    type ESTreeParser =\n        & ESLint.ObjectMetaProperties\n        & (\n            | { parse(text: string, options?: any): AST.Program }\n            | { parseForESLint(text: string, options?: any): ESLintParseResult }\n        );\n\n    type Parser = NonESTreeParser | ESTreeParser;\n\n    interface ESLintParseResult {\n        ast: AST.Program;\n        parserServices?: SourceCode.ParserServices | undefined;\n        scopeManager?: Scope.ScopeManager | undefined;\n        visitorKeys?: SourceCode.VisitorKeys | undefined;\n    }\n\n    interface ProcessorFile {\n        text: string;\n        filename: string;\n    }\n\n    // https://eslint.org/docs/latest/extend/plugins#processors-in-plugins\n    interface Processor<T extends string | ProcessorFile = string | ProcessorFile> extends ESLint.ObjectMetaProperties {\n        supportsAutofix?: boolean | undefined;\n        preprocess?(text: string, filename: string): T[];\n        postprocess?(messages: LintMessage[][], filename: string): LintMessage[];\n    }\n\n    interface Config<Rules extends RulesRecord = RulesRecord> {\n        /**\n         * An string to identify the configuration object. Used in error messages and\n         * inspection tools.\n         */\n        name?: string;\n\n        /**\n         * An array of glob patterns indicating the files that the configuration\n         * object should apply to. If not specified, the configuration object applies\n         * to all files\n         */\n        files?: Array<string | string[]>;\n\n        /**\n         * An array of glob patterns indicating the files that the configuration\n         * object should not apply to. If not specified, the configuration object\n         * applies to all files matched by files\n         */\n        ignores?: string[];\n\n        /**\n         * The name of the language used for linting. This is used to determine the\n         * parser and other language-specific settings.\n         * @since 9.7.0\n         */\n        language?: string;\n\n        /**\n         * An object containing settings related to how JavaScript is configured for\n         * linting.\n         */\n        languageOptions?: LanguageOptions;\n\n        /**\n         * An object containing settings related to the linting process\n         */\n        linterOptions?: LinterOptions;\n\n        /**\n         * Either an object containing preprocess() and postprocess() methods or a\n         * string indicating the name of a processor inside of a plugin\n         * (i.e., \"pluginName/processorName\").\n         */\n        processor?: string | Processor;\n\n        /**\n         * An object containing a name-value mapping of plugin names to plugin objects.\n         * When files is specified, these plugins are only available to the matching files.\n         */\n        plugins?: Record<string, ESLint.Plugin>;\n\n        /**\n         * An object containing the configured rules. When files or ignores are specified,\n         * these rule configurations are only available to the matching files.\n         */\n        rules?: Partial<Rules>;\n\n        /**\n         * An object containing name-value pairs of information that should be\n         * available to all rules.\n         */\n        settings?: Record<string, unknown>;\n    }\n\n    /** @deprecated  Use `Config` instead of `FlatConfig` */\n    type FlatConfig = Config;\n\n    type GlobalConf = boolean | \"off\" | \"readable\" | \"readonly\" | \"writable\" | \"writeable\";\n\n    interface Globals {\n        [name: string]: GlobalConf;\n    }\n\n    interface LanguageOptions extends GenericLanguageOptions {\n        /**\n         * The version of ECMAScript to support. May be any year (i.e., 2022) or\n         * version (i.e., 5). Set to \"latest\" for the most recent supported version.\n         * @default \"latest\"\n         */\n        ecmaVersion?: EcmaVersion | undefined;\n\n        /**\n         * The type of JavaScript source code. Possible values are \"script\" for\n         * traditional script files, \"module\" for ECMAScript modules (ESM), and\n         * \"commonjs\" for CommonJS files. (default: \"module\" for .js and .mjs\n         * files; \"commonjs\" for .cjs files)\n         */\n        sourceType?: SourceType | undefined;\n\n        /**\n         * An object specifying additional objects that should be added to the\n         * global scope during linting.\n         */\n        globals?: Globals | undefined;\n\n        /**\n         * An object containing a parse() or parseForESLint() method.\n         * If not configured, the default ESLint parser (Espree) will be used.\n         */\n        parser?: Parser | undefined;\n\n        /**\n         * An object specifying additional options that are passed directly to the\n         * parser() method on the parser. The available options are parser-dependent\n         */\n        parserOptions?: Linter.ParserOptions | undefined;\n    }\n\n    interface LinterOptions {\n        /**\n         * A boolean value indicating if inline configuration is allowed.\n         */\n        noInlineConfig?: boolean;\n\n        /**\n         * A severity value indicating if and how unused disable directives should be\n         * tracked and reported.\n         */\n        reportUnusedDisableDirectives?: Severity | StringSeverity | boolean;\n\n        /**\n         * A severity value indicating if and how unused inline configs should be\n         * tracked and reported.\n         */\n        reportUnusedInlineConfigs?: Severity | StringSeverity;\n    }\n\n    interface Stats {\n        /**\n         * The number of times ESLint has applied at least one fix after linting.\n         */\n        fixPasses: number;\n\n        /**\n         * The times spent on (parsing, fixing, linting) a file, where the linting refers to the timing information for each rule.\n         */\n        times: { passes: TimePass[] };\n    }\n\n    interface TimePass {\n        parse: { total: number };\n        rules?: Record<string, { total: number }>;\n        fix: { total: number };\n        total: number;\n    }\n}\n\n// #endregion\n\n// #region ESLint\n\nexport class ESLint {\n    static configType: \"flat\";\n\n    static readonly version: string;\n\n    /**\n     * The default configuration that ESLint uses internally. This is provided for tooling that wants to calculate configurations using the same defaults as ESLint.\n     * Keep in mind that the default configuration may change from version to version, so you shouldn't rely on any particular keys or values to be present.\n     */\n    static readonly defaultConfig: Linter.Config[];\n\n    static outputFixes(results: ESLint.LintResult[]): Promise<void>;\n\n    static getErrorResults(results: ESLint.LintResult[]): ESLint.LintResult[];\n\n    constructor(options?: ESLint.Options);\n\n    lintFiles(patterns: string | string[]): Promise<ESLint.LintResult[]>;\n\n    lintText(\n        code: string,\n        options?: { filePath?: string | undefined; warnIgnored?: boolean | undefined },\n    ): Promise<ESLint.LintResult[]>;\n\n    getRulesMetaForResults(results: ESLint.LintResult[]): ESLint.LintResultData[\"rulesMeta\"];\n\n    hasFlag(flag: string): boolean;\n\n    calculateConfigForFile(filePath: string): Promise<any>;\n\n    findConfigFile(): Promise<string | undefined>;\n\n    isPathIgnored(filePath: string): Promise<boolean>;\n\n    loadFormatter(nameOrPath?: string): Promise<ESLint.LoadedFormatter>;\n}\n\nexport namespace ESLint {\n    type ConfigData<Rules extends Linter.RulesRecord = Linter.RulesRecord> = Omit<\n        Linter.LegacyConfig<Rules>,\n        \"$schema\"\n    >;\n\n    interface Environment {\n        globals?: Linter.Globals | undefined;\n        parserOptions?: Linter.ParserOptions | undefined;\n    }\n\n    interface ObjectMetaProperties {\n        /** @deprecated Use `meta.name` instead. */\n        name?: string | undefined;\n\n        /** @deprecated Use `meta.version` instead. */\n        version?: string | undefined;\n\n        meta?: {\n            name?: string | undefined;\n            version?: string | undefined;\n        };\n    }\n\n    interface Plugin extends ObjectMetaProperties {\n        configs?: Record<string, Linter.LegacyConfig | Linter.Config | Linter.Config[]> | undefined;\n        environments?: Record<string, Environment> | undefined;\n        languages?: Record<string, Language> | undefined;\n        processors?: Record<string, Linter.Processor> | undefined;\n        rules?: Record<string, RuleDefinition> | undefined;\n    }\n\n    type FixType = \"directive\" | \"problem\" | \"suggestion\" | \"layout\";\n\n    type CacheStrategy = \"content\" | \"metadata\";\n\n    interface Options {\n        // File enumeration\n        cwd?: string | undefined;\n        errorOnUnmatchedPattern?: boolean | undefined;\n        globInputPaths?: boolean | undefined;\n        ignore?: boolean | undefined;\n        ignorePatterns?: string[] | null | undefined;\n        passOnNoPatterns?: boolean | undefined;\n        warnIgnored?: boolean | undefined;\n\n        // Linting\n        allowInlineConfig?: boolean | undefined;\n        baseConfig?: Linter.Config | Linter.Config[] | null | undefined;\n        overrideConfig?: Linter.Config | Linter.Config[] | null | undefined;\n        overrideConfigFile?: string | true | null | undefined;\n        plugins?: Record<string, Plugin> | null | undefined;\n        ruleFilter?: ((arg: { ruleId: string; severity: Exclude<Linter.Severity, 0> }) => boolean) | undefined;\n        stats?: boolean | undefined;\n\n        // Autofix\n        fix?: boolean | ((message: Linter.LintMessage) => boolean) | undefined;\n        fixTypes?: FixType[] | undefined;\n\n        // Cache-related\n        cache?: boolean | undefined;\n        cacheLocation?: string | undefined;\n        cacheStrategy?: CacheStrategy | undefined;\n\n        // Other Options\n        flags?: string[] | undefined;\n    }\n\n    interface LegacyOptions {\n        // File enumeration\n        cwd?: string | undefined;\n        errorOnUnmatchedPattern?: boolean | undefined;\n        extensions?: string[] | undefined;\n        globInputPaths?: boolean | undefined;\n        ignore?: boolean | undefined;\n        ignorePath?: string | undefined;\n\n        // Linting\n        allowInlineConfig?: boolean | undefined;\n        baseConfig?: Linter.LegacyConfig | undefined;\n        overrideConfig?: Linter.LegacyConfig | undefined;\n        overrideConfigFile?: string | undefined;\n        plugins?: Record<string, Plugin> | undefined;\n        reportUnusedDisableDirectives?: Linter.StringSeverity | undefined;\n        resolvePluginsRelativeTo?: string | undefined;\n        rulePaths?: string[] | undefined;\n        useEslintrc?: boolean | undefined;\n\n        // Autofix\n        fix?: boolean | ((message: Linter.LintMessage) => boolean) | undefined;\n        fixTypes?: FixType[] | undefined;\n\n        // Cache-related\n        cache?: boolean | undefined;\n        cacheLocation?: string | undefined;\n        cacheStrategy?: CacheStrategy | undefined;\n\n        // Other Options\n        flags?: string[] | undefined;\n    }\n\n    interface LintResult {\n        filePath: string;\n        messages: Linter.LintMessage[];\n        suppressedMessages: Linter.SuppressedLintMessage[];\n        errorCount: number;\n        fatalErrorCount: number;\n        warningCount: number;\n        fixableErrorCount: number;\n        fixableWarningCount: number;\n        output?: string | undefined;\n        source?: string | undefined;\n        stats?: Linter.Stats | undefined;\n        usedDeprecatedRules: DeprecatedRuleUse[];\n    }\n\n    interface MaxWarningsExceeded {\n\n        /**\n         * Number of warnings to trigger nonzero exit code.\n         */\n        maxWarnings: number;\n\n        /**\n         * Number of warnings found while linting.\n         */\n        foundWarnings: number;\n    }\n\n    interface LintResultData {\n        cwd: string;\n        maxWarningsExceeded?: MaxWarningsExceeded | undefined;\n        rulesMeta: {\n            [ruleId: string]: Rule.RuleMetaData;\n        };\n    }\n\n    interface DeprecatedRuleUse {\n        ruleId: string;\n        replacedBy: string[];\n    }\n\n    interface ResultsMeta {\n        maxWarningsExceeded?: MaxWarningsExceeded | undefined;\n    }\n\n    /** The type of an object resolved by {@link ESLint.loadFormatter}. */\n    interface LoadedFormatter {\n\n        /**\n         * Used to call the underlying formatter.\n         * @param results An array of lint results to format.\n         * @param resultsMeta An object with an optional `maxWarningsExceeded` property that will be\n         * passed to the underlying formatter function along with other properties set by ESLint.\n         * This argument can be omitted if `maxWarningsExceeded` is not needed.\n         * @return The formatter output.\n         */\n        format(results: LintResult[], resultsMeta?: ResultsMeta): string | Promise<string>;\n    }\n\n    // The documented type name is `LoadedFormatter`, but `Formatter` has been historically more used.\n    type Formatter = LoadedFormatter;\n\n    /**\n     * The expected signature of a custom formatter.\n     * @param results An array of lint results to format.\n     * @param context Additional information for the formatter.\n     * @return The formatter output.\n     */\n    type FormatterFunction =\n    (results: LintResult[], context: LintResultData) => string | Promise<string>;\n\n    // Docs reference the types by those name\n    type EditInfo = Rule.Fix;\n}\n\n// #endregion\n\nexport function loadESLint(options: { useFlatConfig: true }): Promise<typeof ESLint>;\nexport function loadESLint(options: { useFlatConfig: false }): Promise<typeof LegacyESLint>;\nexport function loadESLint(\n    options?: { useFlatConfig?: boolean | undefined },\n): Promise<typeof ESLint | typeof LegacyESLint>;\n\n// #region RuleTester\n\nexport class RuleTester {\n    static describe: ((...args: any) => any) | null;\n    static it: ((...args: any) => any) | null;\n    static itOnly: ((...args: any) => any) | null;\n\n    constructor(config?: Linter.Config);\n\n    run(\n        name: string,\n        rule: Rule.RuleModule,\n        tests: {\n            valid: Array<string | RuleTester.ValidTestCase>;\n            invalid: RuleTester.InvalidTestCase[];\n        },\n    ): void;\n\n    static only(\n        item: string | RuleTester.ValidTestCase | RuleTester.InvalidTestCase,\n    ): RuleTester.ValidTestCase | RuleTester.InvalidTestCase;\n}\n\nexport namespace RuleTester {\n    interface ValidTestCase {\n        name?: string;\n        code: string;\n        options?: any;\n        filename?: string | undefined;\n        only?: boolean;\n        languageOptions?: Linter.LanguageOptions | undefined;\n        settings?: { [name: string]: any } | undefined;\n    }\n\n    interface SuggestionOutput {\n        messageId?: string;\n        desc?: string;\n        data?: Record<string, unknown> | undefined;\n        output: string;\n    }\n\n    interface InvalidTestCase extends ValidTestCase {\n        errors: number | Array<TestCaseError | string>;\n        output?: string | null | undefined;\n    }\n\n    interface TestCaseError {\n        message?: string | RegExp;\n        messageId?: string;\n        /**\n         * @deprecated `type` is deprecated and will be removed in the next major version.\n         */\n        type?: string | undefined;\n        data?: any;\n        line?: number | undefined;\n        column?: number | undefined;\n        endLine?: number | undefined;\n        endColumn?: number | undefined;\n        suggestions?: SuggestionOutput[] | undefined;\n    }\n}\n\n// #endregion\n"
        }
    ]
}