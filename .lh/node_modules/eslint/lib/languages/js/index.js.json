{
    "sourceFile": "node_modules/eslint/lib/languages/js/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview JavaScript Language Object\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst { SourceCode } = require(\"./source-code\");\nconst createDebug = require(\"debug\");\nconst astUtils = require(\"../../shared/ast-utils\");\nconst espree = require(\"espree\");\nconst eslintScope = require(\"eslint-scope\");\nconst evk = require(\"eslint-visitor-keys\");\nconst { validateLanguageOptions } = require(\"./validate-language-options\");\nconst { LATEST_ECMA_VERSION } = require(\"../../../conf/ecma-version\");\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/** @typedef {import(\"@eslint/core\").File} File */\n/** @typedef {import(\"@eslint/core\").Language} Language */\n/** @typedef {import(\"@eslint/core\").OkParseResult} OkParseResult */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst debug = createDebug(\"eslint:languages:js\");\nconst DEFAULT_ECMA_VERSION = 5;\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {LanguageOptions} languageOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, languageOptions, visitorKeys) {\n    const parserOptions = languageOptions.parserOptions;\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\n    const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n\n    return eslintScope.analyze(ast, {\n        ignoreEval: true,\n        nodejsScope: ecmaFeatures.globalReturn,\n        impliedStrict: ecmaFeatures.impliedStrict,\n        ecmaVersion: typeof ecmaVersion === \"number\" ? ecmaVersion : 6,\n        sourceType: languageOptions.sourceType || \"script\",\n        childVisitorKeys: visitorKeys || evk.KEYS,\n        fallback: evk.getKeys\n    });\n}\n\n/**\n * Determines if a given object is Espree.\n * @param {Object} parser The parser to check.\n * @returns {boolean} True if the parser is Espree or false if not.\n */\nfunction isEspree(parser) {\n    return !!(parser === espree || parser[parserSymbol] === espree);\n}\n\n/**\n * Normalize ECMAScript version from the initial config into languageOptions (year)\n * format.\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersionForLanguageOptions(ecmaVersion) {\n\n    switch (ecmaVersion) {\n        case 3:\n            return 3;\n\n        // void 0 = no ecmaVersion specified so use the default\n        case 5:\n        case void 0:\n            return 5;\n\n        default:\n            if (typeof ecmaVersion === \"number\") {\n                return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;\n            }\n    }\n\n    /*\n     * We default to the latest supported ecmaVersion for everything else.\n     * Remember, this is for languageOptions.ecmaVersion, which sets the version\n     * that is used for a number of processes inside of ESLint. It's normally\n     * safe to assume people want the latest unless otherwise specified.\n     */\n    return LATEST_ECMA_VERSION;\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * @type {Language}\n */\nmodule.exports = {\n\n    fileType: \"text\",\n    lineStart: 1,\n    columnStart: 0,\n    nodeTypeKey: \"type\",\n    visitorKeys: evk.KEYS,\n\n    defaultLanguageOptions: {\n        sourceType: \"module\",\n        ecmaVersion: \"latest\",\n        parser: espree,\n        parserOptions: {}\n    },\n\n    validateLanguageOptions,\n\n    /**\n     * Normalizes the language options.\n     * @param {Object} languageOptions The language options to normalize.\n     * @returns {Object} The normalized language options.\n     */\n    normalizeLanguageOptions(languageOptions) {\n\n        languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(\n            languageOptions.ecmaVersion\n        );\n\n        // Espree expects this information to be passed in\n        if (isEspree(languageOptions.parser)) {\n            const parserOptions = languageOptions.parserOptions;\n\n            if (languageOptions.sourceType) {\n\n                parserOptions.sourceType = languageOptions.sourceType;\n\n                if (\n                    parserOptions.sourceType === \"module\" &&\n                    parserOptions.ecmaFeatures &&\n                    parserOptions.ecmaFeatures.globalReturn\n                ) {\n                    parserOptions.ecmaFeatures.globalReturn = false;\n                }\n            }\n        }\n\n        return languageOptions;\n\n    },\n\n    /**\n     * Determines if a given node matches a given selector class.\n     * @param {string} className The class name to check.\n     * @param {ASTNode} node The node to check.\n     * @param {Array<ASTNode>} ancestry The ancestry of the node.\n     * @returns {boolean} True if there's a match, false if not.\n     * @throws {Error} When an unknown class name is passed.\n     */\n    matchesSelectorClass(className, node, ancestry) {\n\n        /*\n         * Copyright (c) 2013, Joel Feenstra\n         * All rights reserved.\n         *\n         * Redistribution and use in source and binary forms, with or without\n         * modification, are permitted provided that the following conditions are met:\n         *    * Redistributions of source code must retain the above copyright\n         *      notice, this list of conditions and the following disclaimer.\n         *    * Redistributions in binary form must reproduce the above copyright\n         *      notice, this list of conditions and the following disclaimer in the\n         *      documentation and/or other materials provided with the distribution.\n         *    * Neither the name of the ESQuery nor the names of its contributors may\n         *      be used to endorse or promote products derived from this software without\n         *      specific prior written permission.\n         *\n         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n         * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n         * DISCLAIMED. IN NO EVENT SHALL JOEL FEENSTRA BE LIABLE FOR ANY\n         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n         * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n         */\n\n        switch (className.toLowerCase()) {\n\n            case \"statement\":\n                if (node.type.slice(-9) === \"Statement\") {\n                    return true;\n                }\n\n                // fallthrough: interface Declaration <: Statement { }\n\n            case \"declaration\":\n                return node.type.slice(-11) === \"Declaration\";\n\n            case \"pattern\":\n                if (node.type.slice(-7) === \"Pattern\") {\n                    return true;\n                }\n\n                // fallthrough: interface Expression <: Node, Pattern { }\n\n            case \"expression\":\n                return node.type.slice(-10) === \"Expression\" ||\n                    node.type.slice(-7) === \"Literal\" ||\n                    (\n                        node.type === \"Identifier\" &&\n                        (ancestry.length === 0 || ancestry[0].type !== \"MetaProperty\")\n                    ) ||\n                    node.type === \"MetaProperty\";\n\n            case \"function\":\n                return node.type === \"FunctionDeclaration\" ||\n                    node.type === \"FunctionExpression\" ||\n                    node.type === \"ArrowFunctionExpression\";\n\n            default:\n                throw new Error(`Unknown class name: ${className}`);\n        }\n    },\n\n    /**\n     * Parses the given file into an AST.\n     * @param {File} file The virtual file to parse.\n     * @param {Object} options Additional options passed from ESLint.\n     * @param {LanguageOptions} options.languageOptions The language options.\n     * @returns {Object} The result of parsing.\n     */\n    parse(file, { languageOptions }) {\n\n        // Note: BOM already removed\n        const { body: text, path: filePath } = file;\n        const textToParse = text.replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n        const { ecmaVersion, sourceType, parser } = languageOptions;\n        const parserOptions = Object.assign(\n            { ecmaVersion, sourceType },\n            languageOptions.parserOptions,\n            {\n                loc: true,\n                range: true,\n                raw: true,\n                tokens: true,\n                comment: true,\n                eslintVisitorKeys: true,\n                eslintScopeManager: true,\n                filePath\n            }\n        );\n\n        /*\n         * Check for parsing errors first. If there's a parsing error, nothing\n         * else can happen. However, a parsing error does not throw an error\n         * from this method - it's just considered a fatal error message, a\n         * problem that ESLint identified just like any other.\n         */\n        try {\n            debug(\"Parsing:\", filePath);\n            const parseResult = (typeof parser.parseForESLint === \"function\")\n                ? parser.parseForESLint(textToParse, parserOptions)\n                : { ast: parser.parse(textToParse, parserOptions) };\n\n            debug(\"Parsing successful:\", filePath);\n\n            const {\n                ast,\n                services: parserServices = {},\n                visitorKeys = evk.KEYS,\n                scopeManager\n            } = parseResult;\n\n            return {\n                ok: true,\n                ast,\n                parserServices,\n                visitorKeys,\n                scopeManager\n            };\n        } catch (ex) {\n\n            // If the message includes a leading line number, strip it:\n            const message = ex.message.replace(/^line \\d+:/iu, \"\").trim();\n\n            debug(\"%s\\n%s\", message, ex.stack);\n\n            return {\n                ok: false,\n                errors: [{\n                    message,\n                    line: ex.lineNumber,\n                    column: ex.column\n                }]\n            };\n        }\n\n    },\n\n    /**\n     * Creates a new `SourceCode` object from the given information.\n     * @param {File} file The virtual file to create a `SourceCode` object from.\n     * @param {OkParseResult} parseResult The result returned from `parse()`.\n     * @param {Object} options Additional options passed from ESLint.\n     * @param {LanguageOptions} options.languageOptions The language options.\n     * @returns {SourceCode} The new `SourceCode` object.\n     */\n    createSourceCode(file, parseResult, { languageOptions }) {\n\n        const { body: text, path: filePath, bom: hasBOM } = file;\n        const { ast, parserServices, visitorKeys } = parseResult;\n\n        debug(\"Scope analysis:\", filePath);\n        const scopeManager = parseResult.scopeManager || analyzeScope(ast, languageOptions, visitorKeys);\n\n        debug(\"Scope analysis successful:\", filePath);\n\n        return new SourceCode({\n            text,\n            ast,\n            hasBOM,\n            parserServices,\n            scopeManager,\n            visitorKeys\n        });\n    }\n\n};\n"
        }
    ]
}