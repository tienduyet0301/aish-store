{
    "sourceFile": "node_modules/eslint/lib/languages/js/source-code/source-code.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892210263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    { isCommentToken } = require(\"@eslint-community/eslint-utils\"),\n    TokenStore = require(\"./token-store\"),\n    astUtils = require(\"../../../shared/ast-utils\"),\n    Traverser = require(\"../../../shared/traverser\"),\n    globals = require(\"../../../../conf/globals\"),\n    {\n        directivesPattern\n    } = require(\"../../../shared/directives\"),\n\n    CodePathAnalyzer = require(\"../../../linter/code-path-analysis/code-path-analyzer\"),\n    createEmitter = require(\"../../../linter/safe-emitter\"),\n    { ConfigCommentParser, VisitNodeStep, CallMethodStep, Directive } = require(\"@eslint/plugin-kit\"),\n\n    eslintScope = require(\"eslint-scope\");\n\n//------------------------------------------------------------------------------\n// Type Definitions\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n/** @typedef {import(\"eslint-scope\").Scope} Scope */\n/** @typedef {import(\"@eslint/core\").SourceCode} ISourceCode */\n/** @typedef {import(\"@eslint/core\").Directive} IDirective */\n/** @typedef {import(\"@eslint/core\").TraversalStep} ITraversalStep */\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst commentParser = new ConfigCommentParser();\n\nconst CODE_PATH_EVENTS = [\n    \"onCodePathStart\",\n    \"onCodePathEnd\",\n    \"onCodePathSegmentStart\",\n    \"onCodePathSegmentEnd\",\n    \"onCodePathSegmentLoop\",\n    \"onUnreachableCodePathSegmentStart\",\n    \"onUnreachableCodePathSegmentEnd\"\n];\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Retrieves globals for the given ecmaVersion.\n * @param {number} ecmaVersion The version to retrieve globals for.\n * @returns {Object} The globals for the given ecmaVersion.\n */\nfunction getGlobalsForEcmaVersion(ecmaVersion) {\n\n    switch (ecmaVersion) {\n        case 3:\n            return globals.es3;\n\n        case 5:\n            return globals.es5;\n\n        default:\n            if (ecmaVersion < 2015) {\n                return globals[`es${ecmaVersion + 2009}`];\n            }\n\n            return globals[`es${ecmaVersion}`];\n    }\n}\n\n/**\n * Check to see if its a ES6 export declaration.\n * @param {ASTNode} astNode An AST node.\n * @returns {boolean} whether the given node represents an export declaration.\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time.\n * @param {Token[]} tokens The list of tokens.\n * @param {Token[]} comments The list of comments.\n * @returns {Token[]} A sorted list of tokens and comments.\n * @private\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n/**\n * Normalizes a value for a global in a config\n * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in\n * a global directive comment\n * @returns {(\"readable\"|\"writeable\"|\"off\")} The value normalized as a string\n * @throws Error if global value is invalid\n */\nfunction normalizeConfigGlobal(configuredValue) {\n    switch (configuredValue) {\n        case \"off\":\n            return \"off\";\n\n        case true:\n        case \"true\":\n        case \"writeable\":\n        case \"writable\":\n            return \"writable\";\n\n        case null:\n        case false:\n        case \"false\":\n        case \"readable\":\n        case \"readonly\":\n            return \"readonly\";\n\n        default:\n            throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);\n    }\n}\n\n/**\n * Determines if two nodes or tokens overlap.\n * @param {ASTNode|Token} first The first node or token to check.\n * @param {ASTNode|Token} second The second node or token to check.\n * @returns {boolean} True if the two nodes or tokens overlap.\n * @private\n */\nfunction nodesOrTokensOverlap(first, second) {\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\n}\n\n/**\n * Determines if two nodes or tokens have at least one whitespace character\n * between them. Order does not matter. Returns false if the given nodes or\n * tokens overlap.\n * @param {SourceCode} sourceCode The source code object.\n * @param {ASTNode|Token} first The first node or token to check between.\n * @param {ASTNode|Token} second The second node or token to check between.\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\n * @returns {boolean} True if there is a whitespace character between\n * any of the tokens found between the two given nodes or tokens.\n * @public\n */\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n    if (nodesOrTokensOverlap(first, second)) {\n        return false;\n    }\n\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\n        ? [first, second]\n        : [second, first];\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n    let currentToken = firstToken;\n\n    while (currentToken !== finalToken) {\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n\n        if (\n            currentToken.range[1] !== nextToken.range[0] ||\n\n                /*\n                 * For backward compatibility, check spaces in JSXText.\n                 * https://github.com/eslint/eslint/issues/12614\n                 */\n                (\n                    checkInsideOfJSXText &&\n                    nextToken !== finalToken &&\n                    nextToken.type === \"JSXText\" &&\n                    /\\s/u.test(nextToken.value)\n                )\n        ) {\n            return true;\n        }\n\n        currentToken = nextToken;\n    }\n\n    return false;\n}\n\n//-----------------------------------------------------------------------------\n// Directive Comments\n//-----------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object|undefined} configGlobals The globals declared in configuration\n * @param {Object|undefined} inlineGlobals The globals declared in the source code\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals = {}, inlineGlobals = {}) {\n\n    // Define configured global variables.\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(inlineGlobals)])) {\n\n        /*\n         * `normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n        const configValue = configGlobals[id] === void 0 ? void 0 : normalizeConfigGlobal(configGlobals[id]);\n        const commentValue = inlineGlobals[id] && inlineGlobals[id].value;\n        const value = commentValue || configValue;\n        const sourceComments = inlineGlobals[id] && inlineGlobals[id].comments;\n\n        if (value === \"off\") {\n            continue;\n        }\n\n        let variable = globalScope.set.get(id);\n\n        if (!variable) {\n            variable = new eslintScope.Variable(id, globalScope);\n\n            globalScope.variables.push(variable);\n            globalScope.set.set(id, variable);\n        }\n\n        variable.eslintImplicitGlobalSetting = configValue;\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\n        variable.eslintExplicitGlobalComments = sourceComments;\n        variable.writeable = (value === \"writable\");\n    }\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * Sets the given variable names as exported so they won't be triggered by\n * the `no-unused-vars` rule.\n * @param {eslint.Scope} globalScope The global scope to define exports in.\n * @param {Record<string,string>} variables An object whose keys are the variable\n *      names to export.\n * @returns {void}\n */\nfunction markExportedVariables(globalScope, variables) {\n\n    Object.keys(variables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            variable.eslintExported = true;\n        }\n    });\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst caches = Symbol(\"caches\");\n\n/**\n * Represents parsed source code.\n * @implements {ISourceCode}\n */\nclass SourceCode extends TokenStore {\n\n    /**\n     * The cache of steps that were taken while traversing the source code.\n     * @type {Array<ITraversalStep>}\n     */\n    #steps;\n\n    /**\n     * Creates a new instance.\n     * @param {string|Object} textOrConfig The source code text or config object.\n     * @param {string} textOrConfig.text The source code text.\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     * @param {boolean} textOrConfig.hasBOM Indicates if the text has a Unicode BOM.\n     * @param {Object|null} textOrConfig.parserServices The parser services.\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n     */\n    constructor(textOrConfig, astIfNoConfig) {\n        let text, hasBOM, ast, parserServices, scopeManager, visitorKeys;\n\n        // Process overloading of arguments\n        if (typeof textOrConfig === \"string\") {\n            text = textOrConfig;\n            ast = astIfNoConfig;\n            hasBOM = false;\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n            text = textOrConfig.text;\n            ast = textOrConfig.ast;\n            hasBOM = textOrConfig.hasBOM;\n            parserServices = textOrConfig.parserServices;\n            scopeManager = textOrConfig.scopeManager;\n            visitorKeys = textOrConfig.visitorKeys;\n        }\n\n        validate(ast);\n        super(ast.tokens, ast.comments);\n\n        /**\n         * General purpose caching for the class.\n         */\n        this[caches] = new Map([\n            [\"scopes\", new WeakMap()],\n            [\"vars\", new Map()],\n            [\"configNodes\", void 0]\n        ]);\n\n        /**\n         * Indicates if the AST is ESTree compatible.\n         * @type {boolean}\n         */\n        this.isESTree = ast.type === \"Program\";\n\n        /*\n         * Backwards compatibility for BOM handling.\n         *\n         * The `hasBOM` property has been available on the `SourceCode` object\n         * for a long time and is used to indicate if the source contains a BOM.\n         * The linter strips the BOM and just passes the `hasBOM` property to the\n         * `SourceCode` constructor to make it easier for languages to not deal with\n         * the BOM.\n         *\n         * However, the text passed in to the `SourceCode` constructor might still\n         * have a BOM if the constructor is called outside of the linter, so we still\n         * need to check for the BOM in the text.\n         */\n        const textHasBOM = text.charCodeAt(0) === 0xFEFF;\n\n        /**\n         * The flag to indicate that the source code has Unicode BOM.\n         * @type {boolean}\n         */\n        this.hasBOM = textHasBOM || !!hasBOM;\n\n        /**\n         * The original text source code.\n         * BOM was stripped from this text.\n         * @type {string}\n         */\n        this.text = (textHasBOM ? text.slice(1) : text);\n\n        /**\n         * The parsed AST for the source code.\n         * @type {ASTNode}\n         */\n        this.ast = ast;\n\n        /**\n         * The parser services of this source code.\n         * @type {Object}\n         */\n        this.parserServices = parserServices || {};\n\n        /**\n         * The scope of this source code.\n         * @type {ScopeManager|null}\n         */\n        this.scopeManager = scopeManager || null;\n\n        /**\n         * The visitor keys to traverse AST.\n         * @type {Object}\n         */\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\n\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n        if (hasShebang) {\n            ast.comments[0].type = \"Shebang\";\n        }\n\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n        /**\n         * The source code split into lines according to ECMA-262 specification.\n         * This is done to avoid each rule needing to do so separately.\n         * @type {string[]}\n         */\n        this.lines = [];\n        this.lineStartIndices = [0];\n\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n\n        /*\n         * Previously, this was implemented using a regex that\n         * matched a sequence of non-linebreak characters followed by a\n         * linebreak, then adding the lengths of the matches. However,\n         * this caused a catastrophic backtracking issue when the end\n         * of a file contained a large number of non-newline characters.\n         * To avoid this, the current implementation just matches newlines\n         * and uses match.index to get the correct line start indices.\n         */\n        while ((match = lineEndingPattern.exec(this.text))) {\n            this.lines.push(this.text.slice(this.lineStartIndices.at(-1), match.index));\n            this.lineStartIndices.push(match.index + match[0].length);\n        }\n        this.lines.push(this.text.slice(this.lineStartIndices.at(-1)));\n\n        // don't allow further modification of this object\n        Object.freeze(this);\n        Object.freeze(this.lines);\n    }\n\n    /**\n     * Split the source code into multiple lines based on the line delimiters.\n     * @param {string} text Source code as a string.\n     * @returns {string[]} Array of source code lines.\n     * @public\n     */\n    static splitLines(text) {\n        return text.split(astUtils.createGlobalLinebreakMatcher());\n    }\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode} [node] The AST node to get the text for.\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     * @public\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n    }\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     * @public\n     */\n    getLines() {\n        return this.lines;\n    }\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     * @public\n     */\n    getAllComments() {\n        return this.ast.comments;\n    }\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\n     *      for the given node or null if not found.\n     * @public\n     * @deprecated\n     */\n    getJSDocComment(node) {\n\n        /**\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\n         * @param {ASTNode} astNode The AST node to get the comment for.\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\n         *      for the given node or null if not found.\n         * @private\n         */\n        const findJSDocComment = astNode => {\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\n\n            if (\n                tokenBefore &&\n                isCommentToken(tokenBefore) &&\n                tokenBefore.type === \"Block\" &&\n                tokenBefore.value.charAt(0) === \"*\" &&\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\n            ) {\n                return tokenBefore;\n            }\n\n            return null;\n        };\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (\n                        !this.getCommentsBefore(parent).length &&\n                        !/Function/u.test(parent.type) &&\n                        parent.type !== \"MethodDefinition\" &&\n                        parent.type !== \"Property\"\n                    ) {\n                        parent = parent.parent;\n\n                        if (!parent) {\n                            break;\n                        }\n                    }\n\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n                        return findJSDocComment(parent);\n                    }\n                }\n\n                return findJSDocComment(node);\n\n            // falls through\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     * @public\n     */\n    getNodeByRangeIndex(index) {\n        let result = null;\n\n        Traverser.traverse(this.ast, {\n            visitorKeys: this.visitorKeys,\n            enter(node) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @public\n     */\n    isSpaceBetween(first, second) {\n        return isSpaceBetween(this, first, second, false);\n    }\n\n    /**\n     * Determines if two nodes or tokens have at least one whitespace character\n     * between them. Order does not matter. Returns false if the given nodes or\n     * tokens overlap.\n     * For backward compatibility, this method returns true if there are\n     * `JSXText` tokens that contain whitespaces between the two.\n     * @param {ASTNode|Token} first The first node or token to check between.\n     * @param {ASTNode|Token} second The second node or token to check between.\n     * @returns {boolean} True if there is a whitespace character between\n     * any of the tokens found between the two given nodes or tokens.\n     * @deprecated in favor of isSpaceBetween().\n     * @public\n     */\n    isSpaceBetweenTokens(first, second) {\n        return isSpaceBetween(this, first, second, true);\n    }\n\n    /**\n     * Converts a source text index into a (line, column) pair.\n     * @param {number} index The index of a character in a file\n     * @throws {TypeError} If non-numeric index or index out of range.\n     * @returns {Object} A {line, column} location object with a 0-indexed column\n     * @public\n     */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines.at(-1).length };\n        }\n\n        /*\n         * To figure out which line index is on, determine the last place at which index could\n         * be inserted into lineStartIndices to keep the list sorted.\n         */\n        const lineNumber = index >= this.lineStartIndices.at(-1)\n            ? this.lineStartIndices.length\n            : this.lineStartIndices.findIndex(el => index < el);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n    }\n\n    /**\n     * Converts a (line, column) pair into a range index.\n     * @param {Object} loc A line/column location\n     * @param {number} loc.line The line number of the location (1-indexed)\n     * @param {number} loc.column The column number of the location (0-indexed)\n     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric\n     *   `line` and `column`, if the `line` is less than or equal to zero or\n     *   the line or column is out of the expected range.\n     * @returns {number} The range index of the location in the file.\n     * @public\n     */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n\n    /**\n     * Gets the scope for the given node\n     * @param {ASTNode} currentNode The node to get the scope of\n     * @returns {Scope} The scope information for this node\n     * @throws {TypeError} If the `currentNode` argument is missing.\n     */\n    getScope(currentNode) {\n\n        if (!currentNode) {\n            throw new TypeError(\"Missing required argument: node.\");\n        }\n\n        // check cache first\n        const cache = this[caches].get(\"scopes\");\n        const cachedScope = cache.get(currentNode);\n\n        if (cachedScope) {\n            return cachedScope;\n        }\n\n        // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n        const inner = currentNode.type !== \"Program\";\n\n        for (let node = currentNode; node; node = node.parent) {\n            const scope = this.scopeManager.acquire(node, inner);\n\n            if (scope) {\n                if (scope.type === \"function-expression-name\") {\n                    cache.set(currentNode, scope.childScopes[0]);\n                    return scope.childScopes[0];\n                }\n\n                cache.set(currentNode, scope);\n                return scope;\n            }\n        }\n\n        cache.set(currentNode, this.scopeManager.scopes[0]);\n        return this.scopeManager.scopes[0];\n    }\n\n    /**\n     * Get the variables that `node` defines.\n     * This is a convenience method that passes through\n     * to the same method on the `scopeManager`.\n     * @param {ASTNode} node The node for which the variables are obtained.\n     * @returns {Array<Variable>} An array of variable nodes representing\n     *      the variables that `node` defines.\n     */\n    getDeclaredVariables(node) {\n        return this.scopeManager.getDeclaredVariables(node);\n    }\n\n    /* eslint-disable class-methods-use-this -- node is owned by SourceCode */\n    /**\n     * Gets all the ancestors of a given node\n     * @param {ASTNode} node The node\n     * @returns {Array<ASTNode>} All the ancestor nodes in the AST, not including the provided node, starting\n     * from the root node at index 0 and going inwards to the parent node.\n     * @throws {TypeError} When `node` is missing.\n     */\n    getAncestors(node) {\n\n        if (!node) {\n            throw new TypeError(\"Missing required argument: node.\");\n        }\n\n        const ancestorsStartingAtParent = [];\n\n        for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            ancestorsStartingAtParent.push(ancestor);\n        }\n\n        return ancestorsStartingAtParent.reverse();\n    }\n\n    /**\n     * Returns the location of the given node or token.\n     * @param {ASTNode|Token} nodeOrToken The node or token to get the location of.\n     * @returns {SourceLocation} The location of the node or token.\n     */\n    getLoc(nodeOrToken) {\n        return nodeOrToken.loc;\n    }\n\n    /**\n     * Returns the range of the given node or token.\n     * @param {ASTNode|Token} nodeOrToken The node or token to get the range of.\n     * @returns {[number, number]} The range of the node or token.\n     */\n    getRange(nodeOrToken) {\n        return nodeOrToken.range;\n    }\n\n    /* eslint-enable class-methods-use-this -- node is owned by SourceCode */\n\n    /**\n     * Marks a variable as used in the current scope\n     * @param {string} name The name of the variable to mark as used.\n     * @param {ASTNode} [refNode] The closest node to the variable reference.\n     * @returns {boolean} True if the variable was found and marked as used, false if not.\n     */\n    markVariableAsUsed(name, refNode = this.ast) {\n\n        const currentScope = this.getScope(refNode);\n        let initialScope = currentScope;\n\n        /*\n         * When we are in an ESM or CommonJS module, we need to start searching\n         * from the top-level scope, not the global scope. For ESM the top-level\n         * scope is the module scope; for CommonJS the top-level scope is the\n         * outer function scope.\n         *\n         * Without this check, we might miss a variable declared with `var` at\n         * the top-level because it won't exist in the global scope.\n         */\n        if (\n            currentScope.type === \"global\" &&\n            currentScope.childScopes.length > 0 &&\n\n            // top-level scopes refer to a `Program` node\n            currentScope.childScopes[0].block === this.ast\n        ) {\n            initialScope = currentScope.childScopes[0];\n        }\n\n        for (let scope = initialScope; scope; scope = scope.upper) {\n            const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n            if (variable) {\n                variable.eslintUsed = true;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Returns an array of all inline configuration nodes found in the\n     * source code.\n     * @returns {Array<Token>} An array of all inline configuration nodes.\n     */\n    getInlineConfigNodes() {\n\n        // check the cache first\n        let configNodes = this[caches].get(\"configNodes\");\n\n        if (configNodes) {\n            return configNodes;\n        }\n\n        // calculate fresh config nodes\n        configNodes = this.ast.comments.filter(comment => {\n\n            // shebang comments are never directives\n            if (comment.type === \"Shebang\") {\n                return false;\n            }\n\n            const directive = commentParser.parseDirective(comment.value);\n\n            if (!directive) {\n                return false;\n            }\n\n            if (!directivesPattern.test(directive.label)) {\n                return false;\n            }\n\n            // only certain comment types are supported as line comments\n            return comment.type !== \"Line\" || !!/^eslint-disable-(next-)?line$/u.test(directive.label);\n        });\n\n        this[caches].set(\"configNodes\", configNodes);\n\n        return configNodes;\n    }\n\n    /**\n     * Returns an all directive nodes that enable or disable rules along with any problems\n     * encountered while parsing the directives.\n     * @returns {{problems:Array<Problem>,directives:Array<Directive>}} Information\n     *      that ESLint needs to further process the directives.\n     */\n    getDisableDirectives() {\n\n        // check the cache first\n        const cachedDirectives = this[caches].get(\"disableDirectives\");\n\n        if (cachedDirectives) {\n            return cachedDirectives;\n        }\n\n        const problems = [];\n        const directives = [];\n\n        this.getInlineConfigNodes().forEach(comment => {\n\n            // Step 1: Parse the directive\n            const {\n                label,\n                value,\n                justification: justificationPart\n            } = commentParser.parseDirective(comment.value);\n\n            // Step 2: Extract the directive value\n            const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(label);\n\n            if (comment.type === \"Line\" && !lineCommentSupported) {\n                return;\n            }\n\n            // Step 3: Validate the directive does not span multiple lines\n            if (label === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\n                const message = `${label} comment should not span multiple lines.`;\n\n                problems.push({\n                    ruleId: null,\n                    message,\n                    loc: comment.loc\n                });\n                return;\n            }\n\n            // Step 4: Extract the directive value and create the Directive object\n            switch (label) {\n                case \"eslint-disable\":\n                case \"eslint-enable\":\n                case \"eslint-disable-next-line\":\n                case \"eslint-disable-line\": {\n                    const directiveType = label.slice(\"eslint-\".length);\n\n                    directives.push(new Directive({\n                        type: directiveType,\n                        node: comment,\n                        value,\n                        justification: justificationPart\n                    }));\n                }\n\n                // no default\n            }\n        });\n\n        const result = { problems, directives };\n\n        this[caches].set(\"disableDirectives\", result);\n\n        return result;\n    }\n\n    /**\n     * Applies language options sent in from the core.\n     * @param {Object} languageOptions The language options for this run.\n     * @returns {void}\n     */\n    applyLanguageOptions(languageOptions) {\n\n        /*\n         * Add configured globals and language globals\n         *\n         * Using Object.assign instead of object spread for performance reasons\n         * https://github.com/eslint/eslint/issues/16302\n         */\n        const configGlobals = Object.assign(\n            Object.create(null), // https://github.com/eslint/eslint/issues/18363\n            getGlobalsForEcmaVersion(languageOptions.ecmaVersion),\n            languageOptions.sourceType === \"commonjs\" ? globals.commonjs : void 0,\n            languageOptions.globals\n        );\n        const varsCache = this[caches].get(\"vars\");\n\n        varsCache.set(\"configGlobals\", configGlobals);\n    }\n\n    /**\n     * Applies configuration found inside of the source code. This method is only\n     * called when ESLint is running with inline configuration allowed.\n     * @returns {{problems:Array<Problem>,configs:{config:FlatConfigArray,loc:Location}}} Information\n     *      that ESLint needs to further process the inline configuration.\n     */\n    applyInlineConfig() {\n\n        const problems = [];\n        const configs = [];\n        const exportedVariables = {};\n        const inlineGlobals = Object.create(null);\n\n        this.getInlineConfigNodes().forEach(comment => {\n\n            const { label, value } = commentParser.parseDirective(comment.value);\n\n            switch (label) {\n                case \"exported\":\n                    Object.assign(exportedVariables, commentParser.parseListConfig(value));\n                    break;\n\n                case \"globals\":\n                case \"global\":\n                    for (const [id, idSetting] of Object.entries(commentParser.parseStringConfig(value))) {\n                        let normalizedValue;\n\n                        try {\n                            normalizedValue = normalizeConfigGlobal(idSetting);\n                        } catch (err) {\n                            problems.push({\n                                ruleId: null,\n                                loc: comment.loc,\n                                message: err.message\n                            });\n                            continue;\n                        }\n\n                        if (inlineGlobals[id]) {\n                            inlineGlobals[id].comments.push(comment);\n                            inlineGlobals[id].value = normalizedValue;\n                        } else {\n                            inlineGlobals[id] = {\n                                comments: [comment],\n                                value: normalizedValue\n                            };\n                        }\n                    }\n                    break;\n\n                case \"eslint\": {\n                    const parseResult = commentParser.parseJSONLikeConfig(value);\n\n                    if (parseResult.ok) {\n                        configs.push({\n                            config: {\n                                rules: parseResult.config\n                            },\n                            loc: comment.loc\n                        });\n                    } else {\n                        problems.push({\n                            ruleId: null,\n                            loc: comment.loc,\n                            message: parseResult.error.message\n                        });\n                    }\n\n                    break;\n                }\n\n                // no default\n            }\n        });\n\n        // save all the new variables for later\n        const varsCache = this[caches].get(\"vars\");\n\n        varsCache.set(\"inlineGlobals\", inlineGlobals);\n        varsCache.set(\"exportedVariables\", exportedVariables);\n\n        return {\n            configs,\n            problems\n        };\n    }\n\n    /**\n     * Called by ESLint core to indicate that it has finished providing\n     * information. We now add in all the missing variables and ensure that\n     * state-changing methods cannot be called by rules.\n     * @returns {void}\n     */\n    finalize() {\n\n        const varsCache = this[caches].get(\"vars\");\n        const configGlobals = varsCache.get(\"configGlobals\");\n        const inlineGlobals = varsCache.get(\"inlineGlobals\");\n        const exportedVariables = varsCache.get(\"exportedVariables\");\n        const globalScope = this.scopeManager.scopes[0];\n\n        addDeclaredGlobals(globalScope, configGlobals, inlineGlobals);\n\n        if (exportedVariables) {\n            markExportedVariables(globalScope, exportedVariables);\n        }\n\n    }\n\n    /**\n     * Traverse the source code and return the steps that were taken.\n     * @returns {Array<TraversalStep>} The steps that were taken while traversing the source code.\n     */\n    traverse() {\n\n        // Because the AST doesn't mutate, we can cache the steps\n        if (this.#steps) {\n            return this.#steps;\n        }\n\n        const steps = this.#steps = [];\n\n        /*\n         * This logic works for any AST, not just ESTree. Because ESLint has allowed\n         * custom parsers to return any AST, we need to ensure that the traversal\n         * logic works for any AST.\n         */\n        const emitter = createEmitter();\n        let analyzer = {\n            enterNode(node) {\n                steps.push(new VisitNodeStep({\n                    target: node,\n                    phase: 1,\n                    args: [node, node.parent]\n                }));\n            },\n            leaveNode(node) {\n                steps.push(new VisitNodeStep({\n                    target: node,\n                    phase: 2,\n                    args: [node, node.parent]\n                }));\n            },\n            emitter\n        };\n\n        /*\n         * We do code path analysis for ESTree only. Code path analysis is not\n         * necessary for other ASTs, and it's also not possible to do for other\n         * ASTs because the necessary information is not available.\n         *\n         * Generally speaking, we can tell that the AST is an ESTree if it has a\n         * Program node at the top level. This is not a perfect heuristic, but it\n         * is good enough for now.\n         */\n        if (this.isESTree) {\n            analyzer = new CodePathAnalyzer(analyzer);\n\n            CODE_PATH_EVENTS.forEach(eventName => {\n                emitter.on(eventName, (...args) => {\n                    steps.push(new CallMethodStep({\n                        target: eventName,\n                        args\n                    }));\n                });\n            });\n        }\n\n        /*\n         * The actual AST traversal is done by the `Traverser` class. This class\n         * is responsible for walking the AST and calling the appropriate methods\n         * on the `analyzer` object, which is appropriate for the given AST.\n         */\n        Traverser.traverse(this.ast, {\n            enter(node, parent) {\n\n                // save the parent node on a property for backwards compatibility\n                node.parent = parent;\n\n                analyzer.enterNode(node);\n            },\n            leave(node) {\n                analyzer.leaveNode(node);\n            },\n            visitorKeys: this.visitorKeys\n        });\n\n        return steps;\n    }\n}\n\nmodule.exports = SourceCode;\n"
        }
    ]
}