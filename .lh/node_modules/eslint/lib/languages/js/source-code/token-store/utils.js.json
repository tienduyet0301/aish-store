{
    "sourceFile": "node_modules/eslint/lib/languages/js/source-code/token-store/utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892211457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Define utility functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Finds the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\n * @param {number} location The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    for (let minIndex = 0, maxIndex = tokens.length - 1; minIndex <= maxIndex;) {\n\n        /*\n         * Calculate the index in the middle between minIndex and maxIndex.\n         * `| 0` is used to round a fractional value down to the nearest integer: this is similar to\n         * using `Math.trunc()` or `Math.floor()`, but performance tests have shown this method to\n         * be faster.\n         */\n        const index = (minIndex + maxIndex) / 2 | 0;\n        const token = tokens[index];\n        const tokenStartLocation = token.range[0];\n\n        if (location <= tokenStartLocation) {\n            if (index === minIndex) {\n                return index;\n            }\n            maxIndex = index;\n        } else {\n            minIndex = index + 1;\n        }\n    }\n    return tokens.length;\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} startLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = tokens[index];\n\n        // If the mapped index is out of bounds, the returned cursor index will point after the end of the tokens array.\n        if (!token) {\n            return tokens.length;\n        }\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, +1 is unnecessary.\n         */\n        if (token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\n * @param {Object} indexMap The map from locations to indices.\n * @param {number} endLoc The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = tokens[index];\n\n        // If the mapped index is out of bounds, the returned cursor index will point before the end of the tokens array.\n        if (!token) {\n            return tokens.length - 1;\n        }\n\n        /*\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\n         * In that case, -1 is necessary.\n         */\n        if (token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n"
        }
    ]
}