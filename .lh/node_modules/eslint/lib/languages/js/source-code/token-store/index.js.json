{
    "sourceFile": "node_modules/eslint/lib/languages/js/source-code/token-store/index.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892211148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { isCommentToken } = require(\"@eslint-community/eslint-utils\");\nconst assert = require(\"../../../../shared/assert\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart;\n    let range;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n * @param {Token[]} tokens The array of tokens.\n * @param {Comment[]} comments The array of comments.\n * @param {Object} indexMap The map from locations to indices in `tokens`.\n * @param {number} startLoc The start location of the iteration range.\n * @param {number} endLoc The end location of the iteration range.\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n/**\n * Gets comment tokens that are adjacent to the current cursor position.\n * @param {Cursor} cursor A cursor instance.\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\n * @private\n */\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n    const tokens = [];\n    let currentToken = cursor.getOneToken();\n\n    while (currentToken && isCommentToken(currentToken)) {\n        tokens.push(currentToken);\n        currentToken = cursor.getOneToken();\n    }\n\n    return tokens;\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     * @param {Token[]} tokens The array of tokens.\n     * @param {Comment[]} comments The array of comments.\n     */\n    constructor(tokens, comments) {\n        this[TOKENS] = tokens;\n        this[COMMENTS] = comments;\n        this[INDEX_MAP] = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset Index of the start of the token's range.\n     * @param {Object} [options=0] The option object.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.skip=0] The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node The AST node.\n     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n\n    //--------------------------------------------------------------------------\n    // Others.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether any comments exist or not between the given 2 nodes.\n     * @param {ASTNode} left The node to check.\n     * @param {ASTNode} right The node to check.\n     * @returns {boolean} `true` if one or more comments exist.\n     */\n    commentsExistBetween(left, right) {\n        const index = utils.search(this[COMMENTS], left.range[1]);\n\n        return (\n            index < this[COMMENTS].length &&\n            this[COMMENTS][index].range[1] <= right.range[0]\n        );\n    }\n\n    /**\n     * Gets all comment tokens directly before the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsBefore(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.backward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            -1,\n            nodeOrToken.range[0],\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor).reverse();\n    }\n\n    /**\n     * Gets all comment tokens directly after the given node or token.\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsAfter(nodeOrToken) {\n        const cursor = createCursorWithCount(\n            cursors.forward,\n            this[TOKENS],\n            this[COMMENTS],\n            this[INDEX_MAP],\n            nodeOrToken.range[1],\n            -1,\n            { includeComments: true }\n        );\n\n        return getAdjacentCommentTokensFromCursor(cursor);\n    }\n\n    /**\n     * Gets all comment tokens inside the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Array} An array of comments in occurrence order.\n     */\n    getCommentsInside(node) {\n        return this.getTokens(node, {\n            includeComments: true,\n            filter: isCommentToken\n        });\n    }\n};\n"
        }
    ]
}