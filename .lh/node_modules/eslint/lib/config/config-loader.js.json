{
    "sourceFile": "node_modules/eslint/lib/config/config-loader.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Utility to load config files\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"node:path\");\nconst fs = require(\"node:fs/promises\");\nconst findUp = require(\"find-up\");\nconst { pathToFileURL } = require(\"node:url\");\nconst debug = require(\"debug\")(\"eslint:config-loader\");\nconst { FlatConfigArray } = require(\"./flat-config-array\");\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef {import(\"../shared/types\").FlatConfigObject} FlatConfigObject\n * @typedef {import(\"../shared/types\").FlatConfigArray} FlatConfigArray\n * @typedef {Object} ConfigLoaderOptions\n * @property {string|false|undefined} configFile The path to the config file to use.\n * @property {string} cwd The current working directory.\n * @property {boolean} ignoreEnabled Indicates if ignore patterns should be honored.\n * @property {FlatConfigArray} [baseConfig] The base config to use.\n * @property {Array<FlatConfigObject>} [defaultConfigs] The default configs to use.\n * @property {Array<string>} [ignorePatterns] The ignore patterns to use.\n * @property {FlatConfigObject|Array<FlatConfigObject>} overrideConfig The override config to use.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FLAT_CONFIG_FILENAMES = [\n    \"eslint.config.js\",\n    \"eslint.config.mjs\",\n    \"eslint.config.cjs\",\n    \"eslint.config.ts\",\n    \"eslint.config.mts\",\n    \"eslint.config.cts\"\n];\n\nconst importedConfigFileModificationTime = new Map();\n\n/**\n * Asserts that the given file path is valid.\n * @param {string} filePath The file path to check.\n * @returns {void}\n * @throws {Error} If `filePath` is not a non-empty string.\n */\nfunction assertValidFilePath(filePath) {\n    if (!filePath || typeof filePath !== \"string\") {\n        throw new Error(\"'filePath' must be a non-empty string\");\n    }\n}\n\n/**\n * Asserts that a configuration exists. A configuration exists if any\n * of the following are true:\n * - `configFilePath` is defined.\n * - `useConfigFile` is `false`.\n * @param {string|undefined} configFilePath The path to the config file.\n * @param {ConfigLoaderOptions} loaderOptions The options to use when loading configuration files.\n * @returns {void}\n * @throws {Error} If no configuration exists.\n */\nfunction assertConfigurationExists(configFilePath, loaderOptions) {\n\n    const {\n        configFile: useConfigFile\n    } = loaderOptions;\n\n    if (!configFilePath && useConfigFile !== false) {\n        const error = new Error(\"Could not find config file.\");\n\n        error.messageTemplate = \"config-file-missing\";\n        throw error;\n    }\n\n}\n\n/**\n * Check if the file is a TypeScript file.\n * @param {string} filePath The file path to check.\n * @returns {boolean} `true` if the file is a TypeScript file, `false` if it's not.\n */\nfunction isFileTS(filePath) {\n    const fileExtension = path.extname(filePath);\n\n    return /^\\.[mc]?ts$/u.test(fileExtension);\n}\n\n/**\n * Check if ESLint is running in Bun.\n * @returns {boolean} `true` if the ESLint is running Bun, `false` if it's not.\n */\nfunction isRunningInBun() {\n    return !!globalThis.Bun;\n}\n\n/**\n * Check if ESLint is running in Deno.\n * @returns {boolean} `true` if the ESLint is running in Deno, `false` if it's not.\n */\nfunction isRunningInDeno() {\n    return !!globalThis.Deno;\n}\n\n/**\n * Load the config array from the given filename.\n * @param {string} filePath The filename to load from.\n * @returns {Promise<any>} The config loaded from the config file.\n */\nasync function loadConfigFile(filePath) {\n\n    debug(`Loading config from ${filePath}`);\n\n    const fileURL = pathToFileURL(filePath);\n\n    debug(`Config file URL is ${fileURL}`);\n\n    const mtime = (await fs.stat(filePath)).mtime.getTime();\n\n    /*\n     * Append a query with the config file's modification time (`mtime`) in order\n     * to import the current version of the config file. Without the query, `import()` would\n     * cache the config file module by the pathname only, and then always return\n     * the same version (the one that was actual when the module was imported for the first time).\n     *\n     * This ensures that the config file module is loaded and executed again\n     * if it has been changed since the last time it was imported.\n     * If it hasn't been changed, `import()` will just return the cached version.\n     *\n     * Note that we should not overuse queries (e.g., by appending the current time\n     * to always reload the config file module) as that could cause memory leaks\n     * because entries are never removed from the import cache.\n     */\n    fileURL.searchParams.append(\"mtime\", mtime);\n\n    /*\n     * With queries, we can bypass the import cache. However, when import-ing a CJS module,\n     * Node.js uses the require infrastructure under the hood. That includes the require cache,\n     * which caches the config file module by its file path (queries have no effect).\n     * Therefore, we also need to clear the require cache before importing the config file module.\n     * In order to get the same behavior with ESM and CJS config files, in particular - to reload\n     * the config file only if it has been changed, we track file modification times and clear\n     * the require cache only if the file has been changed.\n     */\n    if (importedConfigFileModificationTime.get(filePath) !== mtime) {\n        delete require.cache[filePath];\n    }\n\n    const isTS = isFileTS(filePath);\n    const isBun = isRunningInBun();\n    const isDeno = isRunningInDeno();\n\n    /*\n     * If we are dealing with a TypeScript file, then we need to use `jiti` to load it\n     * in Node.js. Deno and Bun both allow native importing of TypeScript files.\n     *\n     * When Node.js supports native TypeScript imports, we can remove this check.\n     */\n    if (isTS && !isDeno && !isBun) {\n\n        // eslint-disable-next-line no-use-before-define -- `ConfigLoader.loadJiti` can be overwritten for testing\n        const { createJiti } = await ConfigLoader.loadJiti().catch(() => {\n            throw new Error(\"The 'jiti' library is required for loading TypeScript configuration files. Make sure to install it.\");\n        });\n\n        // `createJiti` was added in jiti v2.\n        if (typeof createJiti !== \"function\") {\n            throw new Error(\"You are using an outdated version of the 'jiti' library. Please update to the latest version of 'jiti' to ensure compatibility and access to the latest features.\");\n        }\n\n        /*\n         * Disabling `moduleCache` allows us to reload a\n         * config file when the last modified timestamp changes.\n         */\n\n        const jiti = createJiti(__filename, { moduleCache: false, interopDefault: false });\n        const config = await jiti.import(fileURL.href);\n\n        importedConfigFileModificationTime.set(filePath, mtime);\n\n        return config?.default ?? config;\n    }\n\n\n    // fallback to normal runtime behavior\n\n    const config = (await import(fileURL)).default;\n\n    importedConfigFileModificationTime.set(filePath, mtime);\n\n    return config;\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Encapsulates the loading and caching of configuration files when looking up\n * from the file being linted.\n */\nclass ConfigLoader {\n\n    /**\n     * Map of config file paths to the config arrays for those directories.\n     * @type {Map<string, FlatConfigArray|Promise<FlatConfigArray>>}\n     */\n    #configArrays = new Map();\n\n    /**\n     * Map of absolute directory names to the config file paths for those directories.\n     * @type {Map<string, {configFilePath:string,basePath:string}|Promise<{configFilePath:string,basePath:string}>>}\n     */\n    #configFilePaths = new Map();\n\n    /**\n     * The options to use when loading configuration files.\n     * @type {ConfigLoaderOptions}\n     */\n    #options;\n\n    /**\n     * Creates a new instance.\n     * @param {ConfigLoaderOptions} options The options to use when loading configuration files.\n     */\n    constructor(options) {\n        this.#options = options;\n    }\n\n    /**\n     * Determines which config file to use. This is determined by seeing if an\n     * override config file was specified, and if so, using it; otherwise, as long\n     * as override config file is not explicitly set to `false`, it will search\n     * upwards from `fromDirectory` for a file named `eslint.config.js`.\n     * @param {string} fromDirectory The directory from which to start searching.\n     * @returns {Promise<{configFilePath:string|undefined,basePath:string}>} Location information for\n     *      the config file.\n     */\n    async #locateConfigFileToUse(fromDirectory) {\n\n        // check cache first\n        if (this.#configFilePaths.has(fromDirectory)) {\n            return this.#configFilePaths.get(fromDirectory);\n        }\n\n        const resultPromise = ConfigLoader.locateConfigFileToUse({\n            useConfigFile: this.#options.configFile,\n            cwd: this.#options.cwd,\n            fromDirectory\n        });\n\n        // ensure `ConfigLoader.locateConfigFileToUse` is called only once for `fromDirectory`\n        this.#configFilePaths.set(fromDirectory, resultPromise);\n\n        // Unwrap the promise. This is primarily for the sync `getCachedConfigArrayForPath` method.\n        const result = await resultPromise;\n\n        this.#configFilePaths.set(fromDirectory, result);\n\n        return result;\n    }\n\n    /**\n     * Calculates the config array for this run based on inputs.\n     * @param {string} configFilePath The absolute path to the config file to use if not overridden.\n     * @param {string} basePath The base path to use for relative paths in the config file.\n     * @returns {Promise<FlatConfigArray>} The config array for `eslint`.\n     */\n    async #calculateConfigArray(configFilePath, basePath) {\n\n        // check for cached version first\n        if (this.#configArrays.has(configFilePath)) {\n            return this.#configArrays.get(configFilePath);\n        }\n\n        const configsPromise = ConfigLoader.calculateConfigArray(configFilePath, basePath, this.#options);\n\n        // ensure `ConfigLoader.calculateConfigArray` is called only once for `configFilePath`\n        this.#configArrays.set(configFilePath, configsPromise);\n\n        // Unwrap the promise. This is primarily for the sync `getCachedConfigArrayForPath` method.\n        const configs = await configsPromise;\n\n        this.#configArrays.set(configFilePath, configs);\n\n        return configs;\n    }\n\n    /**\n     * Returns the config file path for the given directory or file. This will either use\n     * the override config file that was specified in the constructor options or\n     * search for a config file from the directory.\n     * @param {string} fileOrDirPath The file or directory path to get the config file path for.\n     * @returns {Promise<string|undefined>} The config file path or `undefined` if not found.\n     * @throws {Error} If `fileOrDirPath` is not a non-empty string.\n     * @throws {Error} If `fileOrDirPath` is not an absolute path.\n     */\n    async findConfigFileForPath(fileOrDirPath) {\n\n        assertValidFilePath(fileOrDirPath);\n\n        const absoluteDirPath = path.resolve(this.#options.cwd, path.dirname(fileOrDirPath));\n        const { configFilePath } = await this.#locateConfigFileToUse(absoluteDirPath);\n\n        return configFilePath;\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file or directory to retrieve config for.\n     * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n     *      or `undefined` if there is no configuration data for the file.\n     * @throws {Error} If no configuration for `filePath` exists.\n     */\n    async loadConfigArrayForFile(filePath) {\n\n        assertValidFilePath(filePath);\n\n        debug(`Calculating config for file ${filePath}`);\n\n        const configFilePath = await this.findConfigFileForPath(filePath);\n\n        assertConfigurationExists(configFilePath, this.#options);\n\n        return this.loadConfigArrayForDirectory(filePath);\n    }\n\n    /**\n     * Returns a configuration object for the given directory based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} dirPath The path of the directory to retrieve config for.\n     * @returns {Promise<ConfigData|undefined>} A configuration object for the directory\n     *      or `undefined` if there is no configuration data for the directory.\n     */\n    async loadConfigArrayForDirectory(dirPath) {\n\n        assertValidFilePath(dirPath);\n\n        debug(`Calculating config for directory ${dirPath}`);\n\n        const absoluteDirPath = path.resolve(this.#options.cwd, path.dirname(dirPath));\n        const { configFilePath, basePath } = await this.#locateConfigFileToUse(absoluteDirPath);\n\n        debug(`Using config file ${configFilePath} and base path ${basePath}`);\n        return this.#calculateConfigArray(configFilePath, basePath);\n    }\n\n    /**\n     * Returns a configuration array for the given file based on the CLI options.\n     * This is a synchronous operation and does not read any files from disk. It's\n     * intended to be used in locations where we know the config file has already\n     * been loaded and we just need to get the configuration for a file.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {ConfigData|undefined} A configuration object for the file\n     *     or `undefined` if there is no configuration data for the file.\n     * @throws {Error} If `filePath` is not a non-empty string.\n     * @throws {Error} If `filePath` is not an absolute path.\n     * @throws {Error} If the config file was not already loaded.\n     */\n    getCachedConfigArrayForFile(filePath) {\n        assertValidFilePath(filePath);\n\n        debug(`Looking up cached config for ${filePath}`);\n\n        return this.getCachedConfigArrayForPath(path.dirname(filePath));\n    }\n\n    /**\n     * Returns a configuration array for the given directory based on the CLI options.\n     * This is a synchronous operation and does not read any files from disk. It's\n     * intended to be used in locations where we know the config file has already\n     * been loaded and we just need to get the configuration for a file.\n     * @param {string} fileOrDirPath The path of the directory to retrieve a config object for.\n     * @returns {ConfigData|undefined} A configuration object for the directory\n     *     or `undefined` if there is no configuration data for the directory.\n     * @throws {Error} If `dirPath` is not a non-empty string.\n     * @throws {Error} If `dirPath` is not an absolute path.\n     * @throws {Error} If the config file was not already loaded.\n     */\n    getCachedConfigArrayForPath(fileOrDirPath) {\n        assertValidFilePath(fileOrDirPath);\n\n        debug(`Looking up cached config for ${fileOrDirPath}`);\n\n        const absoluteDirPath = path.resolve(this.#options.cwd, fileOrDirPath);\n\n        if (!this.#configFilePaths.has(absoluteDirPath)) {\n            throw new Error(`Could not find config file for ${fileOrDirPath}`);\n        }\n\n        const configFilePathInfo = this.#configFilePaths.get(absoluteDirPath);\n\n        if (typeof configFilePathInfo.then === \"function\") {\n            throw new Error(`Config file path for ${fileOrDirPath} has not yet been calculated or an error occurred during the calculation`);\n        }\n\n        const { configFilePath } = configFilePathInfo;\n\n        const configArray = this.#configArrays.get(configFilePath);\n\n        if (!configArray || typeof configArray.then === \"function\") {\n            throw new Error(`Config array for ${fileOrDirPath} has not yet been calculated or an error occurred during the calculation`);\n        }\n\n        return configArray;\n    }\n\n    /**\n     * Used to import the jiti dependency. This method is exposed internally for testing purposes.\n     * @returns {Promise<Record<string, unknown>>} A promise that fulfills with a module object\n     *      or rejects with an error if jiti is not found.\n     */\n    static loadJiti() {\n        return import(\"jiti\");\n    }\n\n    /**\n     * Determines which config file to use. This is determined by seeing if an\n     * override config file was specified, and if so, using it; otherwise, as long\n     * as override config file is not explicitly set to `false`, it will search\n     * upwards from `fromDirectory` for a file named `eslint.config.js`.\n     * This method is exposed internally for testing purposes.\n     * @param {Object} [options] the options object\n     * @param {string|false|undefined} options.useConfigFile The path to the config file to use.\n     * @param {string} options.cwd Path to a directory that should be considered as the current working directory.\n     * @param {string} [options.fromDirectory] The directory from which to start searching. Defaults to `cwd`.\n     * @returns {Promise<{configFilePath:string|undefined,basePath:string}>} Location information for\n     *      the config file.\n     */\n    static async locateConfigFileToUse({ useConfigFile, cwd, fromDirectory = cwd }) {\n\n        // determine where to load config file from\n        let configFilePath;\n        let basePath = cwd;\n\n        if (typeof useConfigFile === \"string\") {\n            debug(`Override config file path is ${useConfigFile}`);\n            configFilePath = path.resolve(cwd, useConfigFile);\n            basePath = cwd;\n        } else if (useConfigFile !== false) {\n            debug(\"Searching for eslint.config.js\");\n            configFilePath = await findUp(\n                FLAT_CONFIG_FILENAMES,\n                { cwd: fromDirectory }\n            );\n\n            if (configFilePath) {\n                basePath = path.dirname(configFilePath);\n            }\n\n        }\n\n        return {\n            configFilePath,\n            basePath\n        };\n\n    }\n\n    /**\n     * Calculates the config array for this run based on inputs.\n     * This method is exposed internally for testing purposes.\n     * @param {string} configFilePath The absolute path to the config file to use if not overridden.\n     * @param {string} basePath The base path to use for relative paths in the config file.\n     * @param {ConfigLoaderOptions} options The options to use when loading configuration files.\n     * @returns {Promise<FlatConfigArray>} The config array for `eslint`.\n     */\n    static async calculateConfigArray(configFilePath, basePath, options) {\n\n        const {\n            cwd,\n            baseConfig,\n            ignoreEnabled,\n            ignorePatterns,\n            overrideConfig,\n            defaultConfigs = []\n        } = options;\n\n        debug(`Calculating config array from config file ${configFilePath} and base path ${basePath}`);\n\n        const configs = new FlatConfigArray(baseConfig || [], { basePath, shouldIgnore: ignoreEnabled });\n\n        // load config file\n        if (configFilePath) {\n\n            debug(`Loading config file ${configFilePath}`);\n            const fileConfig = await loadConfigFile(configFilePath);\n\n            /*\n             * It's possible that a config file could be empty or else\n             * have an empty object or array. In this case, we want to\n             * warn the user that they have an empty config.\n             *\n             * An empty CommonJS file exports an empty object while\n             * an empty ESM file exports undefined.\n             */\n\n            let emptyConfig = typeof fileConfig === \"undefined\";\n\n            debug(`Config file ${configFilePath} is ${emptyConfig ? \"empty\" : \"not empty\"}`);\n\n            if (!emptyConfig) {\n                if (Array.isArray(fileConfig)) {\n                    if (fileConfig.length === 0) {\n                        debug(`Config file ${configFilePath} is an empty array`);\n                        emptyConfig = true;\n                    } else {\n                        configs.push(...fileConfig);\n                    }\n                } else {\n                    if (typeof fileConfig === \"object\" && fileConfig !== null && Object.keys(fileConfig).length === 0) {\n                        debug(`Config file ${configFilePath} is an empty object`);\n                        emptyConfig = true;\n                    } else {\n                        configs.push(fileConfig);\n                    }\n                }\n            }\n\n            if (emptyConfig) {\n                globalThis.process?.emitWarning?.(`Running ESLint with an empty config (from ${configFilePath}). Please double-check that this is what you want. If you want to run ESLint with an empty config, export [{}] to remove this warning.`, \"ESLintEmptyConfigWarning\");\n            }\n\n        }\n\n        // add in any configured defaults\n        configs.push(...defaultConfigs);\n\n        // append command line ignore patterns\n        if (ignorePatterns && ignorePatterns.length > 0) {\n\n            let relativeIgnorePatterns;\n\n            /*\n             * If the config file basePath is different than the cwd, then\n             * the ignore patterns won't work correctly. Here, we adjust the\n             * ignore pattern to include the correct relative path. Patterns\n             * passed as `ignorePatterns` are relative to the cwd, whereas\n             * the config file basePath can be an ancestor of the cwd.\n             */\n            if (basePath === cwd) {\n                relativeIgnorePatterns = ignorePatterns;\n            } else {\n\n                // relative path must only have Unix-style separators\n                const relativeIgnorePath = path.relative(basePath, cwd).replace(/\\\\/gu, \"/\");\n\n                relativeIgnorePatterns = ignorePatterns.map(pattern => {\n                    const negated = pattern.startsWith(\"!\");\n                    const basePattern = negated ? pattern.slice(1) : pattern;\n\n                    return (negated ? \"!\" : \"\") +\n                    path.posix.join(relativeIgnorePath, basePattern);\n                });\n            }\n\n            /*\n             * Ignore patterns are added to the end of the config array\n             * so they can override default ignores.\n             */\n            configs.push({\n                ignores: relativeIgnorePatterns\n            });\n        }\n\n        if (overrideConfig) {\n            if (Array.isArray(overrideConfig)) {\n                configs.push(...overrideConfig);\n            } else {\n                configs.push(overrideConfig);\n            }\n        }\n\n        await configs.normalize();\n\n        return configs;\n    }\n\n}\n\n/**\n * Encapsulates the loading and caching of configuration files when looking up\n * from the current working directory.\n */\nclass LegacyConfigLoader extends ConfigLoader {\n\n    /**\n     * The options to use when loading configuration files.\n     * @type {ConfigLoaderOptions}\n     */\n    #options;\n\n    /**\n     * The cached config file path for this instance.\n     * @type {Promise<{configFilePath:string,basePath:string}|undefined>}\n     */\n    #configFilePath;\n\n    /**\n     * The cached config array for this instance.\n     * @type {FlatConfigArray|Promise<FlatConfigArray>}\n     */\n    #configArray;\n\n    /**\n     * Creates a new instance.\n     * @param {ConfigLoaderOptions} options The options to use when loading configuration files.\n     */\n    constructor(options) {\n        super(options);\n        this.#options = options;\n    }\n\n    /**\n     * Determines which config file to use. This is determined by seeing if an\n     * override config file was specified, and if so, using it; otherwise, as long\n     * as override config file is not explicitly set to `false`, it will search\n     * upwards from the cwd for a file named `eslint.config.js`.\n     * @returns {Promise<{configFilePath:string|undefined,basePath:string}>} Location information for\n     *      the config file.\n     */\n    #locateConfigFileToUse() {\n        if (!this.#configFilePath) {\n            this.#configFilePath = ConfigLoader.locateConfigFileToUse({\n                useConfigFile: this.#options.configFile,\n                cwd: this.#options.cwd\n            });\n        }\n\n        return this.#configFilePath;\n    }\n\n    /**\n     * Calculates the config array for this run based on inputs.\n     * @param {string} configFilePath The absolute path to the config file to use if not overridden.\n     * @param {string} basePath The base path to use for relative paths in the config file.\n     * @returns {Promise<FlatConfigArray>} The config array for `eslint`.\n     */\n    async #calculateConfigArray(configFilePath, basePath) {\n\n        // check for cached version first\n        if (this.#configArray) {\n            return this.#configArray;\n        }\n\n        // ensure `ConfigLoader.calculateConfigArray` is called only once\n        this.#configArray = ConfigLoader.calculateConfigArray(configFilePath, basePath, this.#options);\n\n        // Unwrap the promise. This is primarily for the sync `getCachedConfigArrayForPath` method.\n        this.#configArray = await this.#configArray;\n\n        return this.#configArray;\n    }\n\n\n    /**\n     * Returns the config file path for the given directory. This will either use\n     * the override config file that was specified in the constructor options or\n     * search for a config file from the directory of the file being linted.\n     * @param {string} dirPath The directory path to get the config file path for.\n     * @returns {Promise<string|undefined>} The config file path or `undefined` if not found.\n     * @throws {Error} If `fileOrDirPath` is not a non-empty string.\n     * @throws {Error} If `fileOrDirPath` is not an absolute path.\n     */\n    async findConfigFileForPath(dirPath) {\n\n        assertValidFilePath(dirPath);\n\n        const { configFilePath } = await this.#locateConfigFileToUse();\n\n        return configFilePath;\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} dirPath The path of the directory to retrieve config for.\n     * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n     *      or `undefined` if there is no configuration data for the file.\n     */\n    async loadConfigArrayForDirectory(dirPath) {\n\n        assertValidFilePath(dirPath);\n\n        debug(`[Legacy]: Calculating config for ${dirPath}`);\n\n        const { configFilePath, basePath } = await this.#locateConfigFileToUse();\n\n        debug(`[Legacy]: Using config file ${configFilePath} and base path ${basePath}`);\n        return this.#calculateConfigArray(configFilePath, basePath);\n    }\n\n    /**\n     * Returns a configuration array for the given directory based on the CLI options.\n     * This is a synchronous operation and does not read any files from disk. It's\n     * intended to be used in locations where we know the config file has already\n     * been loaded and we just need to get the configuration for a file.\n     * @param {string} dirPath The path of the directory to retrieve a config object for.\n     * @returns {ConfigData|undefined} A configuration object for the file\n     *     or `undefined` if there is no configuration data for the file.\n     * @throws {Error} If `dirPath` is not a non-empty string.\n     * @throws {Error} If `dirPath` is not an absolute path.\n     * @throws {Error} If the config file was not already loaded.\n     */\n    getCachedConfigArrayForPath(dirPath) {\n        assertValidFilePath(dirPath);\n\n        debug(`[Legacy]: Looking up cached config for ${dirPath}`);\n\n        if (!this.#configArray) {\n            throw new Error(`Could not find config file for ${dirPath}`);\n        }\n\n        if (typeof this.#configArray.then === \"function\") {\n            throw new Error(`Config array for ${dirPath} has not yet been calculated or an error occurred during the calculation`);\n        }\n\n        return this.#configArray;\n    }\n}\n\nmodule.exports = { ConfigLoader, LegacyConfigLoader };\n"
        }
    ]
}