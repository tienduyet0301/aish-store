{
    "sourceFile": "node_modules/eslint/lib/config/config.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview The `Config` class\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst { deepMergeArrays } = require(\"../shared/deep-merge-arrays\");\nconst { getRuleFromConfig } = require(\"./flat-config-helpers\");\nconst { flatConfigSchema, hasMethod } = require(\"./flat-config-schema\");\nconst { RuleValidator } = require(\"./rule-validator\");\nconst { ObjectSchema } = require(\"@eslint/config-array\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleValidator = new RuleValidator();\n\nconst severities = new Map([\n    [0, 0],\n    [1, 1],\n    [2, 2],\n    [\"off\", 0],\n    [\"warn\", 1],\n    [\"error\", 2]\n]);\n\n/**\n * Splits a plugin identifier in the form a/b/c into two parts: a/b and c.\n * @param {string} identifier The identifier to parse.\n * @returns {{objectName: string, pluginName: string}} The parts of the plugin\n *      name.\n */\nfunction splitPluginIdentifier(identifier) {\n    const parts = identifier.split(\"/\");\n\n    return {\n        objectName: parts.pop(),\n        pluginName: parts.join(\"/\")\n    };\n}\n\n/**\n * Returns the name of an object in the config by reading its `meta` key.\n * @param {Object} object The object to check.\n * @returns {string?} The name of the object if found or `null` if there\n *      is no name.\n */\nfunction getObjectId(object) {\n\n    // first check old-style name\n    let name = object.name;\n\n    if (!name) {\n\n        if (!object.meta) {\n            return null;\n        }\n\n        name = object.meta.name;\n\n        if (!name) {\n            return null;\n        }\n    }\n\n    // now check for old-style version\n    let version = object.version;\n\n    if (!version) {\n        version = object.meta && object.meta.version;\n    }\n\n    // if there's a version then append that\n    if (version) {\n        return `${name}@${version}`;\n    }\n\n    return name;\n}\n\n/**\n * Converts a languageOptions object to a JSON representation.\n * @param {Record<string, any>} languageOptions The options to create a JSON\n *     representation of.\n * @param {string} objectKey The key of the object being converted.\n * @returns {Record<string, any>} The JSON representation of the languageOptions.\n * @throws {TypeError} If a function is found in the languageOptions.\n */\nfunction languageOptionsToJSON(languageOptions, objectKey = \"languageOptions\") {\n\n    const result = {};\n\n    for (const [key, value] of Object.entries(languageOptions)) {\n        if (value) {\n            if (typeof value === \"object\") {\n                const name = getObjectId(value);\n\n                if (name && hasMethod(value)) {\n                    result[key] = name;\n                } else {\n                    result[key] = languageOptionsToJSON(value, key);\n                }\n                continue;\n            }\n\n            if (typeof value === \"function\") {\n                const error = new TypeError(`Cannot serialize key \"${key}\" in ${objectKey}: Function values are not supported.`);\n\n                error.messageTemplate = \"config-serialize-function\";\n                error.messageData = { key, objectKey };\n\n                throw error;\n            }\n\n        }\n\n        result[key] = value;\n    }\n\n    return result;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Represents a normalized configuration object.\n */\nclass Config {\n\n    /**\n     * The name to use for the language when serializing to JSON.\n     * @type {string|undefined}\n     */\n    #languageName;\n\n    /**\n     * The name to use for the processor when serializing to JSON.\n     * @type {string|undefined}\n     */\n    #processorName;\n\n    /**\n     * Creates a new instance.\n     * @param {Object} config The configuration object.\n     */\n    constructor(config) {\n\n        const { plugins, language, languageOptions, processor, ...otherKeys } = config;\n\n        // Validate config object\n        const schema = new ObjectSchema(flatConfigSchema);\n\n        schema.validate(config);\n\n        // first, copy all the other keys over\n        Object.assign(this, otherKeys);\n\n        // ensure that a language is specified\n        if (!language) {\n            throw new TypeError(\"Key 'language' is required.\");\n        }\n\n        // copy the rest over\n        this.plugins = plugins;\n        this.language = language;\n\n        // Check language value\n        const { pluginName: languagePluginName, objectName: localLanguageName } = splitPluginIdentifier(language);\n\n        this.#languageName = language;\n\n        if (!plugins || !plugins[languagePluginName] || !plugins[languagePluginName].languages || !plugins[languagePluginName].languages[localLanguageName]) {\n            throw new TypeError(`Key \"language\": Could not find \"${localLanguageName}\" in plugin \"${languagePluginName}\".`);\n        }\n\n        this.language = plugins[languagePluginName].languages[localLanguageName];\n\n        if (this.language.defaultLanguageOptions ?? languageOptions) {\n            this.languageOptions = flatConfigSchema.languageOptions.merge(\n                this.language.defaultLanguageOptions,\n                languageOptions\n            );\n        } else {\n            this.languageOptions = {};\n        }\n\n        // Validate language options\n        try {\n            this.language.validateLanguageOptions(this.languageOptions);\n        } catch (error) {\n            throw new TypeError(`Key \"languageOptions\": ${error.message}`, { cause: error });\n        }\n\n        // Normalize language options if necessary\n        if (this.language.normalizeLanguageOptions) {\n            this.languageOptions = this.language.normalizeLanguageOptions(this.languageOptions);\n        }\n\n        // Check processor value\n        if (processor) {\n            this.processor = processor;\n\n            if (typeof processor === \"string\") {\n                const { pluginName, objectName: localProcessorName } = splitPluginIdentifier(processor);\n\n                this.#processorName = processor;\n\n                if (!plugins || !plugins[pluginName] || !plugins[pluginName].processors || !plugins[pluginName].processors[localProcessorName]) {\n                    throw new TypeError(`Key \"processor\": Could not find \"${localProcessorName}\" in plugin \"${pluginName}\".`);\n                }\n\n                this.processor = plugins[pluginName].processors[localProcessorName];\n            } else if (typeof processor === \"object\") {\n                this.#processorName = getObjectId(processor);\n                this.processor = processor;\n            } else {\n                throw new TypeError(\"Key 'processor' must be a string or an object.\");\n            }\n        }\n\n        // Process the rules\n        if (this.rules) {\n            this.#normalizeRulesConfig();\n            ruleValidator.validate(this);\n        }\n    }\n\n    /**\n     * Converts the configuration to a JSON representation.\n     * @returns {Record<string, any>} The JSON representation of the configuration.\n     * @throws {Error} If the configuration cannot be serialized.\n     */\n    toJSON() {\n\n        if (this.processor && !this.#processorName) {\n            throw new Error(\"Could not serialize processor object (missing 'meta' object).\");\n        }\n\n        if (!this.#languageName) {\n            throw new Error(\"Could not serialize language object (missing 'meta' object).\");\n        }\n\n        return {\n            ...this,\n            plugins: Object.entries(this.plugins).map(([namespace, plugin]) => {\n\n                const pluginId = getObjectId(plugin);\n\n                if (!pluginId) {\n                    return namespace;\n                }\n\n                return `${namespace}:${pluginId}`;\n            }),\n            language: this.#languageName,\n            languageOptions: languageOptionsToJSON(this.languageOptions),\n            processor: this.#processorName\n        };\n    }\n\n    /**\n     * Normalizes the rules configuration. Ensures that each rule config is\n     * an array and that the severity is a number. Applies meta.defaultOptions.\n     * This function modifies `this.rules`.\n     * @returns {void}\n     */\n    #normalizeRulesConfig() {\n        for (const [ruleId, originalConfig] of Object.entries(this.rules)) {\n\n            // ensure rule config is an array\n            let ruleConfig = Array.isArray(originalConfig)\n                ? originalConfig\n                : [originalConfig];\n\n            // normalize severity\n            ruleConfig[0] = severities.get(ruleConfig[0]);\n\n            const rule = getRuleFromConfig(ruleId, this);\n\n            // apply meta.defaultOptions\n            const slicedOptions = ruleConfig.slice(1);\n            const mergedOptions = deepMergeArrays(rule?.meta?.defaultOptions, slicedOptions);\n\n            if (mergedOptions.length) {\n                ruleConfig = [ruleConfig[0], ...mergedOptions];\n            }\n\n            this.rules[ruleId] = ruleConfig;\n        }\n    }\n}\n\nmodule.exports = { Config };\n"
        }
    ]
}