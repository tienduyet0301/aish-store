{
    "sourceFile": "node_modules/eslint/lib/config/flat-config-helpers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Shared functions to work with configs.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n// JSON schema that disallows passing any options\nconst noOptionsSchema = Object.freeze({\n    type: \"array\",\n    minItems: 0,\n    maxItems: 0\n});\n\n//-----------------------------------------------------------------------------\n// Functions\n//-----------------------------------------------------------------------------\n\n/**\n * Parses a ruleId into its plugin and rule parts.\n * @param {string} ruleId The rule ID to parse.\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\n *      parts of the ruleId;\n */\nfunction parseRuleId(ruleId) {\n    let pluginName, ruleName;\n\n    // distinguish between core rules and plugin rules\n    if (ruleId.includes(\"/\")) {\n\n        // mimic scoped npm packages\n        if (ruleId.startsWith(\"@\")) {\n            pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\n        } else {\n            pluginName = ruleId.slice(0, ruleId.indexOf(\"/\"));\n        }\n\n        ruleName = ruleId.slice(pluginName.length + 1);\n    } else {\n        pluginName = \"@\";\n        ruleName = ruleId;\n    }\n\n    return {\n        pluginName,\n        ruleName\n    };\n}\n\n/**\n * Retrieves a rule instance from a given config based on the ruleId.\n * @param {string} ruleId The rule ID to look for.\n * @param {FlatConfig} config The config to search.\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\n *      or undefined if not.\n */\nfunction getRuleFromConfig(ruleId, config) {\n    const { pluginName, ruleName } = parseRuleId(ruleId);\n\n    return config.plugins?.[pluginName]?.rules?.[ruleName];\n}\n\n/**\n * Gets a complete options schema for a rule.\n * @param {Rule} rule A rule object\n * @throws {TypeError} If `meta.schema` is specified but is not an array, object or `false`.\n * @returns {Object|null} JSON Schema for the rule's options. `null` if `meta.schema` is `false`.\n */\nfunction getRuleOptionsSchema(rule) {\n\n    if (!rule.meta) {\n        return { ...noOptionsSchema }; // default if `meta.schema` is not specified\n    }\n\n    const schema = rule.meta.schema;\n\n    if (typeof schema === \"undefined\") {\n        return { ...noOptionsSchema }; // default if `meta.schema` is not specified\n    }\n\n    // `schema:false` is an allowed explicit opt-out of options validation for the rule\n    if (schema === false) {\n        return null;\n    }\n\n    if (typeof schema !== \"object\" || schema === null) {\n        throw new TypeError(\"Rule's `meta.schema` must be an array or object\");\n    }\n\n    // ESLint-specific array form needs to be converted into a valid JSON Schema definition\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n\n        // `schema:[]` is an explicit way to specify that the rule does not accept any options\n        return { ...noOptionsSchema };\n    }\n\n    // `schema:<object>` is assumed to be a valid JSON Schema definition\n    return schema;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    parseRuleId,\n    getRuleFromConfig,\n    getRuleOptionsSchema\n};\n"
        }
    ]
}