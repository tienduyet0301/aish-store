{
    "sourceFile": "node_modules/eslint/lib/config/flat-config-schema.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Flat config schema\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst { normalizeSeverityToNumber } = require(\"../shared/severity\");\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef ObjectPropertySchema\n * @property {Function|string} merge The function or name of the function to call\n *      to merge multiple objects with this property.\n * @property {Function|string} validate The function or name of the function to call\n *      to validate the value of this property.\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleSeverities = new Map([\n    [0, 0], [\"off\", 0],\n    [1, 1], [\"warn\", 1],\n    [2, 2], [\"error\", 2]\n]);\n\n/**\n * Check if a value is a non-null object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Check if a value is a non-null non-array object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null non-array object.\n */\nfunction isNonArrayObject(value) {\n    return isNonNullObject(value) && !Array.isArray(value);\n}\n\n/**\n * Check if a value is undefined.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is undefined.\n */\nfunction isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n\n/**\n * Deeply merges two non-array objects.\n * @param {Object} first The base object.\n * @param {Object} second The overrides object.\n * @param {Map<string, Map<string, Object>>} [mergeMap] Maps the combination of first and second arguments to a merged result.\n * @returns {Object} An object with properties from both first and second.\n */\nfunction deepMerge(first, second, mergeMap = new Map()) {\n\n    let secondMergeMap = mergeMap.get(first);\n\n    if (secondMergeMap) {\n        const result = secondMergeMap.get(second);\n\n        if (result) {\n\n            // If this combination of first and second arguments has been already visited, return the previously created result.\n            return result;\n        }\n    } else {\n        secondMergeMap = new Map();\n        mergeMap.set(first, secondMergeMap);\n    }\n\n    /*\n     * First create a result object where properties from the second object\n     * overwrite properties from the first. This sets up a baseline to use\n     * later rather than needing to inspect and change every property\n     * individually.\n     */\n    const result = {\n        ...first,\n        ...second\n    };\n\n    delete result.__proto__; // eslint-disable-line no-proto -- don't merge own property \"__proto__\"\n\n    // Store the pending result for this combination of first and second arguments.\n    secondMergeMap.set(second, result);\n\n    for (const key of Object.keys(second)) {\n\n        // avoid hairy edge case\n        if (key === \"__proto__\" || !Object.prototype.propertyIsEnumerable.call(first, key)) {\n            continue;\n        }\n\n        const firstValue = first[key];\n        const secondValue = second[key];\n\n        if (isNonArrayObject(firstValue) && isNonArrayObject(secondValue)) {\n            result[key] = deepMerge(firstValue, secondValue, mergeMap);\n        } else if (isUndefined(secondValue)) {\n            result[key] = firstValue;\n        }\n    }\n\n    return result;\n\n}\n\n/**\n * Normalizes the rule options config for a given rule by ensuring that\n * it is an array and that the first item is 0, 1, or 2.\n * @param {Array|string|number} ruleOptions The rule options config.\n * @returns {Array} An array of rule options.\n */\nfunction normalizeRuleOptions(ruleOptions) {\n\n    const finalOptions = Array.isArray(ruleOptions)\n        ? ruleOptions.slice(0)\n        : [ruleOptions];\n\n    finalOptions[0] = ruleSeverities.get(finalOptions[0]);\n    return structuredClone(finalOptions);\n}\n\n/**\n * Determines if an object has any methods.\n * @param {Object} object The object to check.\n * @returns {boolean} `true` if the object has any methods.\n */\nfunction hasMethod(object) {\n\n    for (const key of Object.keys(object)) {\n\n        if (typeof object[key] === \"function\") {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//-----------------------------------------------------------------------------\n// Assertions\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when a rule's options are configured with an invalid type.\n */\nclass InvalidRuleOptionsError extends Error {\n\n    /**\n     * @param {string} ruleId Rule name being configured.\n     * @param {any} value The invalid value.\n     */\n    constructor(ruleId, value) {\n        super(`Key \"${ruleId}\": Expected severity of \"off\", 0, \"warn\", 1, \"error\", or 2.`);\n        this.messageTemplate = \"invalid-rule-options\";\n        this.messageData = { ruleId, value };\n    }\n}\n\n/**\n * Validates that a value is a valid rule options entry.\n * @param {string} ruleId Rule name being configured.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {InvalidRuleOptionsError} If the value isn't a valid rule options.\n */\nfunction assertIsRuleOptions(ruleId, value) {\n    if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\n        throw new InvalidRuleOptionsError(ruleId, value);\n    }\n}\n\n/**\n * The error type when a rule's severity is invalid.\n */\nclass InvalidRuleSeverityError extends Error {\n\n    /**\n     * @param {string} ruleId Rule name being configured.\n     * @param {any} value The invalid value.\n     */\n    constructor(ruleId, value) {\n        super(`Key \"${ruleId}\": Expected severity of \"off\", 0, \"warn\", 1, \"error\", or 2.`);\n        this.messageTemplate = \"invalid-rule-severity\";\n        this.messageData = { ruleId, value };\n    }\n}\n\n/**\n * Validates that a value is valid rule severity.\n * @param {string} ruleId Rule name being configured.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {InvalidRuleSeverityError} If the value isn't a valid rule severity.\n */\nfunction assertIsRuleSeverity(ruleId, value) {\n    const severity = ruleSeverities.get(value);\n\n    if (typeof severity === \"undefined\") {\n        throw new InvalidRuleSeverityError(ruleId, value);\n    }\n}\n\n/**\n * Validates that a given string is the form pluginName/objectName.\n * @param {string} value The string to check.\n * @returns {void}\n * @throws {TypeError} If the string isn't in the correct format.\n */\nfunction assertIsPluginMemberName(value) {\n    if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\n        throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\n    }\n}\n\n/**\n * Validates that a value is an object.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object.\n */\nfunction assertIsObject(value) {\n    if (!isNonNullObject(value)) {\n        throw new TypeError(\"Expected an object.\");\n    }\n}\n\n/**\n * The error type when there's an eslintrc-style options in a flat config.\n */\nclass IncompatibleKeyError extends Error {\n\n    /**\n     * @param {string} key The invalid key.\n     */\n    constructor(key) {\n        super(\"This appears to be in eslintrc format rather than flat config format.\");\n        this.messageTemplate = \"eslintrc-incompat\";\n        this.messageData = { key };\n    }\n}\n\n/**\n * The error type when there's an eslintrc-style plugins array found.\n */\nclass IncompatiblePluginsError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {Array<string>} plugins The plugins array.\n     */\n    constructor(plugins) {\n        super(\"This appears to be in eslintrc format (array of strings) rather than flat config format (object).\");\n        this.messageTemplate = \"eslintrc-plugins\";\n        this.messageData = { plugins };\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// Low-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst booleanSchema = {\n    merge: \"replace\",\n    validate: \"boolean\"\n};\n\nconst ALLOWED_SEVERITIES = new Set([\"error\", \"warn\", \"off\", 2, 1, 0]);\n\n/** @type {ObjectPropertySchema} */\nconst disableDirectiveSeveritySchema = {\n    merge(first, second) {\n        const value = second === void 0 ? first : second;\n\n        if (typeof value === \"boolean\") {\n            return value ? \"warn\" : \"off\";\n        }\n\n        return normalizeSeverityToNumber(value);\n    },\n    validate(value) {\n        if (!(ALLOWED_SEVERITIES.has(value) || typeof value === \"boolean\")) {\n            throw new TypeError(\"Expected one of: \\\"error\\\", \\\"warn\\\", \\\"off\\\", 0, 1, 2, or a boolean.\");\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst unusedInlineConfigsSeveritySchema = {\n    merge(first, second) {\n        const value = second === void 0 ? first : second;\n\n        return normalizeSeverityToNumber(value);\n    },\n    validate(value) {\n        if (!ALLOWED_SEVERITIES.has(value)) {\n            throw new TypeError(\"Expected one of: \\\"error\\\", \\\"warn\\\", \\\"off\\\", 0, 1, or 2.\");\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst deepObjectAssignSchema = {\n    merge(first = {}, second = {}) {\n        return deepMerge(first, second);\n    },\n    validate: \"object\"\n};\n\n\n//-----------------------------------------------------------------------------\n// High-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst languageOptionsSchema = {\n    merge(first = {}, second = {}) {\n\n        const result = deepMerge(first, second);\n\n        for (const [key, value] of Object.entries(result)) {\n\n            /*\n             * Special case: Because the `parser` property is an object, it should\n             * not be deep merged. Instead, it should be replaced if it exists in\n             * the second object. To make this more generic, we just check for\n             * objects with methods and replace them if they exist in the second\n             * object.\n             */\n            if (isNonArrayObject(value)) {\n                if (hasMethod(value)) {\n                    result[key] = second[key] ?? first[key];\n                    continue;\n                }\n\n                // for other objects, make sure we aren't reusing the same object\n                result[key] = { ...result[key] };\n                continue;\n            }\n\n        }\n\n        return result;\n    },\n    validate: \"object\"\n};\n\n/** @type {ObjectPropertySchema} */\nconst languageSchema = {\n    merge: \"replace\",\n    validate: assertIsPluginMemberName\n};\n\n/** @type {ObjectPropertySchema} */\nconst pluginsSchema = {\n    merge(first = {}, second = {}) {\n        const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\n        const result = {};\n\n        // manually validate that plugins are not redefined\n        for (const key of keys) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (key in first && key in second && first[key] !== second[key]) {\n                throw new TypeError(`Cannot redefine plugin \"${key}\".`);\n            }\n\n            result[key] = second[key] || first[key];\n        }\n\n        return result;\n    },\n    validate(value) {\n\n        // first check the value to be sure it's an object\n        if (value === null || typeof value !== \"object\") {\n            throw new TypeError(\"Expected an object.\");\n        }\n\n        // make sure it's not an array, which would mean eslintrc-style is used\n        if (Array.isArray(value)) {\n            throw new IncompatiblePluginsError(value);\n        }\n\n        // second check the keys to make sure they are objects\n        for (const key of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (value[key] === null || typeof value[key] !== \"object\") {\n                throw new TypeError(`Key \"${key}\": Expected an object.`);\n            }\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst processorSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value === \"string\") {\n            assertIsPluginMemberName(value);\n        } else if (value && typeof value === \"object\") {\n            if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\n                throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\n            }\n        } else {\n            throw new TypeError(\"Expected an object or a string.\");\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst rulesSchema = {\n    merge(first = {}, second = {}) {\n\n        const result = {\n            ...first,\n            ...second\n        };\n\n\n        for (const ruleId of Object.keys(result)) {\n\n            try {\n\n                // avoid hairy edge case\n                if (ruleId === \"__proto__\") {\n\n                    /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\n                    delete result.__proto__;\n                    continue;\n                }\n\n                result[ruleId] = normalizeRuleOptions(result[ruleId]);\n\n                /*\n                 * If either rule config is missing, then the correct\n                 * config is already present and we just need to normalize\n                 * the severity.\n                 */\n                if (!(ruleId in first) || !(ruleId in second)) {\n                    continue;\n                }\n\n                const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\n                const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\n\n                /*\n                 * If the second rule config only has a severity (length of 1),\n                 * then use that severity and keep the rest of the options from\n                 * the first rule config.\n                 */\n                if (secondRuleOptions.length === 1) {\n                    result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\n                    continue;\n                }\n\n                /*\n                 * In any other situation, then the second rule config takes\n                 * precedence. That means the value at `result[ruleId]` is\n                 * already correct and no further work is necessary.\n                 */\n            } catch (ex) {\n                throw new Error(`Key \"${ruleId}\": ${ex.message}`, { cause: ex });\n            }\n\n        }\n\n        return result;\n\n\n    },\n\n    validate(value) {\n        assertIsObject(value);\n\n        /*\n         * We are not checking the rule schema here because there is no\n         * guarantee that the rule definition is present at this point. Instead\n         * we wait and check the rule schema during the finalization step\n         * of calculating a config.\n         */\n        for (const ruleId of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (ruleId === \"__proto__\") {\n                continue;\n            }\n\n            const ruleOptions = value[ruleId];\n\n            assertIsRuleOptions(ruleId, ruleOptions);\n\n            if (Array.isArray(ruleOptions)) {\n                assertIsRuleSeverity(ruleId, ruleOptions[0]);\n            } else {\n                assertIsRuleSeverity(ruleId, ruleOptions);\n            }\n        }\n    }\n};\n\n/**\n * Creates a schema that always throws an error. Useful for warning\n * about eslintrc-style keys.\n * @param {string} key The eslintrc key to create a schema for.\n * @returns {ObjectPropertySchema} The schema.\n */\nfunction createEslintrcErrorSchema(key) {\n    return {\n        merge: \"replace\",\n        validate() {\n            throw new IncompatibleKeyError(key);\n        }\n    };\n}\n\nconst eslintrcKeys = [\n    \"env\",\n    \"extends\",\n    \"globals\",\n    \"ignorePatterns\",\n    \"noInlineConfig\",\n    \"overrides\",\n    \"parser\",\n    \"parserOptions\",\n    \"reportUnusedDisableDirectives\",\n    \"root\"\n];\n\n//-----------------------------------------------------------------------------\n// Full schema\n//-----------------------------------------------------------------------------\n\nconst flatConfigSchema = {\n\n    // eslintrc-style keys that should always error\n    ...Object.fromEntries(eslintrcKeys.map(key => [key, createEslintrcErrorSchema(key)])),\n\n    // flat config keys\n    settings: deepObjectAssignSchema,\n    linterOptions: {\n        schema: {\n            noInlineConfig: booleanSchema,\n            reportUnusedDisableDirectives: disableDirectiveSeveritySchema,\n            reportUnusedInlineConfigs: unusedInlineConfigsSeveritySchema\n        }\n    },\n    language: languageSchema,\n    languageOptions: languageOptionsSchema,\n    processor: processorSchema,\n    plugins: pluginsSchema,\n    rules: rulesSchema\n};\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    flatConfigSchema,\n    hasMethod,\n    assertIsRuleSeverity\n};\n"
        }
    ]
}