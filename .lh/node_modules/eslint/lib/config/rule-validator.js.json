{
    "sourceFile": "node_modules/eslint/lib/config/rule-validator.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule Validator\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst ajvImport = require(\"../shared/ajv\");\nconst ajv = ajvImport();\nconst {\n    parseRuleId,\n    getRuleFromConfig,\n    getRuleOptionsSchema\n} = require(\"./flat-config-helpers\");\nconst ruleReplacements = require(\"../../conf/replacements.json\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Throws a helpful error when a rule cannot be found.\n * @param {Object} ruleId The rule identifier.\n * @param {string} ruleId.pluginName The ID of the rule to find.\n * @param {string} ruleId.ruleName The ID of the rule to find.\n * @param {Object} config The config to search in.\n * @throws {TypeError} For missing plugin or rule.\n * @returns {void}\n */\nfunction throwRuleNotFoundError({ pluginName, ruleName }, config) {\n\n    const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\n\n    const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\n\n    let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\" in configuration.`;\n\n    const missingPluginErrorMessage = errorMessage;\n\n    // if the plugin exists then we need to check if the rule exists\n    if (config.plugins && config.plugins[pluginName]) {\n        const replacementRuleName = ruleReplacements.rules[ruleName];\n\n        if (pluginName === \"@\" && replacementRuleName) {\n\n            errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\n\n        } else {\n\n            errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`;\n\n            // otherwise, let's see if we can find the rule name elsewhere\n            for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\n                if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\n                    errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\n                    break;\n                }\n            }\n\n        }\n\n        // falls through to throw error\n    }\n\n    const error = new TypeError(errorMessage);\n\n    if (errorMessage === missingPluginErrorMessage) {\n        error.messageTemplate = \"config-plugin-missing\";\n        error.messageData = { pluginName, ruleId };\n    }\n\n    throw error;\n}\n\n/**\n * The error type when a rule has an invalid `meta.schema`.\n */\nclass InvalidRuleOptionsSchemaError extends Error {\n\n    /**\n     * Creates a new instance.\n     * @param {string} ruleId Id of the rule that has an invalid `meta.schema`.\n     * @param {Error} processingError Error caught while processing the `meta.schema`.\n     */\n    constructor(ruleId, processingError) {\n        super(\n            `Error while processing options validation schema of rule '${ruleId}': ${processingError.message}`,\n            { cause: processingError }\n        );\n        this.code = \"ESLINT_INVALID_RULE_OPTIONS_SCHEMA\";\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Implements validation functionality for the rules portion of a config.\n */\nclass RuleValidator {\n\n    /**\n     * Creates a new instance.\n     */\n    constructor() {\n\n        /**\n         * A collection of compiled validators for rules that have already\n         * been validated.\n         * @type {WeakMap}\n         */\n        this.validators = new WeakMap();\n    }\n\n    /**\n     * Validates all of the rule configurations in a config against each\n     * rule's schema.\n     * @param {Object} config The full config to validate. This object must\n     *      contain both the rules section and the plugins section.\n     * @returns {void}\n     * @throws {Error} If a rule's configuration does not match its schema.\n     */\n    validate(config) {\n\n        if (!config.rules) {\n            return;\n        }\n\n        for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\n\n            // check for edge case\n            if (ruleId === \"__proto__\") {\n                continue;\n            }\n\n            /*\n             * If a rule is disabled, we don't do any validation. This allows\n             * users to safely set any value to 0 or \"off\" without worrying\n             * that it will cause a validation error.\n             *\n             * Note: ruleOptions is always an array at this point because\n             * this validation occurs after FlatConfigArray has merged and\n             * normalized values.\n             */\n            if (ruleOptions[0] === 0) {\n                continue;\n            }\n\n            const rule = getRuleFromConfig(ruleId, config);\n\n            if (!rule) {\n                throwRuleNotFoundError(parseRuleId(ruleId), config);\n            }\n\n            // Precompile and cache validator the first time\n            if (!this.validators.has(rule)) {\n                try {\n                    const schema = getRuleOptionsSchema(rule);\n\n                    if (schema) {\n                        this.validators.set(rule, ajv.compile(schema));\n                    }\n                } catch (err) {\n                    throw new InvalidRuleOptionsSchemaError(ruleId, err);\n                }\n            }\n\n            const validateRule = this.validators.get(rule);\n\n            if (validateRule) {\n\n                validateRule(ruleOptions.slice(1));\n\n                if (validateRule.errors) {\n                    throw new Error(`Key \"rules\": Key \"${ruleId}\":\\n${\n                        validateRule.errors.map(\n                            error => {\n                                if (\n                                    error.keyword === \"additionalProperties\" &&\n                                    error.schema === false &&\n                                    typeof error.parentSchema?.properties === \"object\" &&\n                                    typeof error.params?.additionalProperty === \"string\"\n                                ) {\n                                    const expectedProperties = Object.keys(error.parentSchema.properties).map(property => `\"${property}\"`);\n\n                                    return `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n\\t\\tUnexpected property \"${error.params.additionalProperty}\". Expected properties: ${expectedProperties.join(\", \")}.\\n`;\n                                }\n\n                                return `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`;\n                            }\n                        ).join(\"\")\n                    }`);\n                }\n            }\n        }\n    }\n}\n\nexports.RuleValidator = RuleValidator;\n"
        }
    ]
}