{
    "sourceFile": "node_modules/eslint/lib/cli-engine/cli-engine.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892208033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"node:fs\");\nconst path = require(\"node:path\");\nconst defaultOptions = require(\"../../conf/default-cli-options\");\nconst pkg = require(\"../../package.json\");\n\n\nconst {\n    Legacy: {\n        ConfigOps,\n        naming,\n        CascadingConfigArrayFactory,\n        IgnorePattern,\n        getUsedExtractedConfigs,\n        ModuleResolver\n    }\n} = require(\"@eslint/eslintrc\");\n\nconst { FileEnumerator } = require(\"./file-enumerator\");\n\nconst { Linter } = require(\"../linter\");\nconst builtInRules = require(\"../rules\");\nconst loadRules = require(\"./load-rules\");\nconst hash = require(\"./hash\");\nconst LintResultCache = require(\"./lint-result-cache\");\n\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\nconst removedFormatters = new Set([\n    \"checkstyle\",\n    \"codeframe\",\n    \"compact\",\n    \"jslint-xml\",\n    \"junit\",\n    \"table\",\n    \"tap\",\n    \"unix\",\n    \"visualstudio\"\n]);\nconst validFixTypes = new Set([\"directive\", \"problem\", \"suggestion\", \"layout\"]);\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {import(\"../shared/types\").FormatterFunction} FormatterFunction */\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {string} [configFile] The configuration file to use.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {string[]} [envs] An array of environments to load.\n * @property {string[]|null} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {string[]} [globals] An array of global variables to declare.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\n * @property {string} [parser] The name of the parser to use.\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\n * @property {string[]} [plugins] An array of plugins to load.\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean|string} [reportUnusedDisableDirectives] `true`, `\"error\"` or '\"warn\"' adds reports for unused eslint-disable directives\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {SuppressedLintMessage[]} suppressedMessages All of the suppressed messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} fatalErrorCount Number of fatal errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n/**\n * Linting results.\n * @typedef {Object} LintReport\n * @property {LintResult[]} results All of the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} fatalErrorCount Number of fatal errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private data for CLIEngine.\n * @typedef {Object} CLIEngineInternalSlots\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cacheFilePath The path to the cache of lint results.\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\n * @property {FileEnumerator} fileEnumerator The file enumerator.\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\n * @property {Linter} linter The linter instance which has loaded rules.\n * @property {CLIEngineOptions} options The normalized options of this instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Determines if each fix type in an array is supported by ESLint and throws\n * an error if not.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {void}\n * @throws {Error} If an invalid fix type is found.\n */\nfunction validateFixTypes(fixTypes) {\n    for (const fixType of fixTypes) {\n        if (!validFixTypes.has(fixType)) {\n            throw new Error(`Invalid fix type \"${fixType}\" found.`);\n        }\n    }\n}\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    const stat = {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n\n    for (let i = 0; i < messages.length; i++) {\n        const message = messages[i];\n\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n            if (message.fatal) {\n                stat.fatalErrorCount++;\n            }\n            if (message.fix) {\n                stat.fixableErrorCount++;\n            }\n        } else {\n            stat.warningCount++;\n            if (message.fix) {\n                stat.fixableWarningCount++;\n            }\n        }\n    }\n    return stat;\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    const stat = {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n\n    for (let i = 0; i < results.length; i++) {\n        const result = results[i];\n\n        stat.errorCount += result.errorCount;\n        stat.fatalErrorCount += result.fatalErrorCount;\n        stat.warningCount += result.warningCount;\n        stat.fixableErrorCount += result.fixableErrorCount;\n        stat.fixableWarningCount += result.fixableWarningCount;\n    }\n\n    return stat;\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {ConfigArray} config.config The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean|string} config.reportUnusedDisableDirectives If `true`, `\"error\"` or '\"warn\"', then it reports unused `eslint-disable` comments.\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n    text,\n    cwd,\n    filePath: providedFilePath,\n    config,\n    fix,\n    allowInlineConfig,\n    reportUnusedDisableDirectives,\n    fileEnumerator,\n    linter\n}) {\n    const filePath = providedFilePath || \"<text>\";\n\n    debug(`Lint ${filePath}`);\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n    const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, filePath) : filePath;\n    const { fixed, messages, output } = linter.verifyAndFix(\n        text,\n        config,\n        {\n            allowInlineConfig,\n            filename: filePathToVerify,\n            fix,\n            reportUnusedDisableDirectives,\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n            filterCodeBlock(blockFilename) {\n                return fileEnumerator.isTargetPath(blockFilename);\n            }\n        }\n    );\n\n    // Tweak and return.\n    const result = {\n        filePath,\n        messages,\n        suppressedMessages: linter.getSuppressedMessages(),\n        ...calculateStatsPerFile(messages)\n    };\n\n    if (fixed) {\n        result.output = output;\n    }\n    if (\n        result.errorCount + result.warningCount > 0 &&\n        typeof result.output === \"undefined\"\n    ) {\n        result.source = text;\n    }\n\n    return result;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isHidden = filePath.split(path.sep)\n        .find(segment => /^\\./u.test(segment));\n    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                ruleId: null,\n                fatal: false,\n                severity: 1,\n                message,\n                nodeType: null\n            }\n        ],\n        suppressedMessages: [],\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 1,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n}\n\n/**\n * Get a rule.\n * @param {string} ruleId The rule ID to get.\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\n * @returns {Rule|null} The rule or null.\n */\nfunction getRule(ruleId, configArrays) {\n    for (const configArray of configArrays) {\n        const rule = configArray.pluginRules.get(ruleId);\n\n        if (rule) {\n            return rule;\n        }\n    }\n    return builtInRules.get(ruleId) || null;\n}\n\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\nfunction shouldMessageBeFixed(message, lastConfigArrays, fixTypes) {\n    if (!message.ruleId) {\n        return fixTypes.has(\"directive\");\n    }\n\n    const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);\n\n    return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n\n/**\n * Collect used deprecated rules.\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\nfunction *iterateRuleDeprecationWarnings(usedConfigArrays) {\n    const processedRuleIds = new Set();\n\n    // Flatten used configs.\n    /** @type {ExtractedConfig[]} */\n    const configs = usedConfigArrays.flatMap(getUsedExtractedConfigs);\n\n    // Traverse rule configs.\n    for (const config of configs) {\n        for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\n\n            // Skip if it was processed.\n            if (processedRuleIds.has(ruleId)) {\n                continue;\n            }\n            processedRuleIds.add(ruleId);\n\n            // Skip if it's not used.\n            if (!ConfigOps.getRuleSeverity(ruleConfig)) {\n                continue;\n            }\n            const rule = getRule(ruleId, usedConfigArrays);\n\n            // Skip if it's not deprecated.\n            if (!(rule && rule.meta && rule.meta.deprecated)) {\n                continue;\n            }\n\n            // This rule was used and deprecated.\n            yield {\n                ruleId,\n                replacedBy: rule.meta.replacedBy || []\n            };\n        }\n    }\n}\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then it will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    const normalizedCacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n/**\n * Convert a string array to a boolean map.\n * @param {string[]|null} keys The keys to assign true.\n * @param {boolean} defaultValue The default value for each property.\n * @param {string} displayName The property name which is used in error message.\n * @throws {Error} Requires array.\n * @returns {Record<string,boolean>} The boolean map.\n */\nfunction toBooleanMap(keys, defaultValue, displayName) {\n    if (keys && !Array.isArray(keys)) {\n        throw new Error(`${displayName} must be an array.`);\n    }\n    if (keys && keys.length > 0) {\n        return keys.reduce((map, def) => {\n            const [key, value] = def.split(\":\");\n\n            if (key !== \"__proto__\") {\n                map[key] = value === void 0\n                    ? defaultValue\n                    : value === \"true\";\n            }\n\n            return map;\n        }, {});\n    }\n    return void 0;\n}\n\n/**\n * Create a config data from CLI options.\n * @param {CLIEngineOptions} options The options\n * @returns {ConfigData|null} The created config data.\n */\nfunction createConfigDataFromOptions(options) {\n    const {\n        ignorePattern,\n        parser,\n        parserOptions,\n        plugins,\n        rules\n    } = options;\n    const env = toBooleanMap(options.envs, true, \"envs\");\n    const globals = toBooleanMap(options.globals, false, \"globals\");\n\n    if (\n        env === void 0 &&\n        globals === void 0 &&\n        (ignorePattern === void 0 || ignorePattern.length === 0) &&\n        parser === void 0 &&\n        parserOptions === void 0 &&\n        plugins === void 0 &&\n        rules === void 0\n    ) {\n        return null;\n    }\n    return {\n        env,\n        globals,\n        ignorePatterns: ignorePattern,\n        parser,\n        parserOptions,\n        plugins,\n        rules\n    };\n}\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @throws {Error} As thrown by `fs.statSync` or `fs.isDirectory`.\n * @returns {boolean} `true` if a directory exists\n */\nfunction directoryExists(resolvedPath) {\n    try {\n        return fs.statSync(resolvedPath).isDirectory();\n    } catch (error) {\n        if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n            return false;\n        }\n        throw error;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Core CLI.\n */\nclass CLIEngine {\n\n    /**\n     * Creates a new instance of the core CLI engine.\n     * @param {CLIEngineOptions} providedOptions The options for this instance.\n     * @param {Object} [additionalData] Additional settings that are not CLIEngineOptions.\n     * @param {Record<string,Plugin>|null} [additionalData.preloadedPlugins] Preloaded plugins.\n     */\n    constructor(providedOptions, { preloadedPlugins } = {}) {\n        const options = Object.assign(\n            Object.create(null),\n            defaultOptions,\n            { cwd: process.cwd() },\n            providedOptions\n        );\n\n        if (options.fix === void 0) {\n            options.fix = false;\n        }\n\n        const additionalPluginPool = new Map();\n\n        if (preloadedPlugins) {\n            for (const [id, plugin] of Object.entries(preloadedPlugins)) {\n                additionalPluginPool.set(id, plugin);\n            }\n        }\n\n        const cacheFilePath = getCacheFile(\n            options.cacheLocation || options.cacheFile,\n            options.cwd\n        );\n        const configArrayFactory = new CascadingConfigArrayFactory({\n            additionalPluginPool,\n            baseConfig: options.baseConfig || null,\n            cliConfig: createConfigDataFromOptions(options),\n            cwd: options.cwd,\n            ignorePath: options.ignorePath,\n            resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,\n            rulePaths: options.rulePaths,\n            specificConfigPath: options.configFile,\n            useEslintrc: options.useEslintrc,\n            builtInRules,\n            loadRules,\n            getEslintRecommendedConfig: () => require(\"@eslint/js\").configs.recommended,\n            getEslintAllConfig: () => require(\"@eslint/js\").configs.all\n        });\n        const fileEnumerator = new FileEnumerator({\n            configArrayFactory,\n            cwd: options.cwd,\n            extensions: options.extensions,\n            globInputPaths: options.globInputPaths,\n            errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,\n            ignore: options.ignore\n        });\n        const lintResultCache =\n            options.cache ? new LintResultCache(cacheFilePath, options.cacheStrategy) : null;\n        const linter = new Linter({ cwd: options.cwd, configType: \"eslintrc\" });\n\n        /** @type {ConfigArray[]} */\n        const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()];\n\n        // Store private data.\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cacheFilePath,\n            configArrayFactory,\n            defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),\n            fileEnumerator,\n            lastConfigArrays,\n            lintResultCache,\n            linter,\n            options\n        });\n\n        // setup special filter for fixes\n        if (options.fix && options.fixTypes && options.fixTypes.length > 0) {\n            debug(`Using fix types ${options.fixTypes}`);\n\n            // throw an error if any invalid fix types are found\n            validateFixTypes(options.fixTypes);\n\n            // convert to Set for faster lookup\n            const fixTypes = new Set(options.fixTypes);\n\n            // save original value of options.fix in case it's a function\n            const originalFix = (typeof options.fix === \"function\")\n                ? options.fix : () => true;\n\n            options.fix = message => shouldMessageBeFixed(message, lastConfigArrays, fixTypes) && originalFix(message);\n        }\n    }\n\n    getRules() {\n        const { lastConfigArrays } = internalSlotsMap.get(this);\n\n        return new Map(function *() {\n            yield* builtInRules;\n\n            for (const configArray of lastConfigArrays) {\n                yield* configArray.pluginRules;\n            }\n        }());\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        const filtered = [];\n\n        results.forEach(result => {\n            const filteredMessages = result.messages.filter(isErrorMessage);\n            const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n\n            if (filteredMessages.length > 0) {\n                filtered.push({\n                    ...result,\n                    messages: filteredMessages,\n                    suppressedMessages: filteredSuppressedMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0,\n                    fixableErrorCount: result.fixableErrorCount,\n                    fixableWarningCount: 0\n                });\n            }\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintReport} report The report object created by CLIEngine.\n     * @returns {void}\n     */\n    static outputFixes(report) {\n        report.results.filter(result => Object.hasOwn(result, \"output\")).forEach(result => {\n            fs.writeFileSync(result.filePath, result.output);\n        });\n    }\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n    resolveFileGlobPatterns(patterns) {\n        const { options } = internalSlotsMap.get(this);\n\n        if (options.globInputPaths === false) {\n            return patterns.filter(Boolean);\n        }\n\n        const extensions = (options.extensions || [\".js\"]).map(ext => ext.replace(/^\\./u, \"\"));\n        const dirSuffix = `/**/*.{${extensions.join(\",\")}}`;\n\n        return patterns.filter(Boolean).map(pathname => {\n            const resolvedPath = path.resolve(options.cwd, pathname);\n            const newPath = directoryExists(resolvedPath)\n                ? pathname.replace(/[/\\\\]$/u, \"\") + dirSuffix\n                : pathname;\n\n            return path.normalize(newPath).replace(/\\\\/gu, \"/\");\n        });\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @throws {Error} As may be thrown by `fs.unlinkSync`.\n     * @returns {LintReport} The results for all files that were linted.\n     */\n    executeOnFiles(patterns) {\n        const {\n            cacheFilePath,\n            fileEnumerator,\n            lastConfigArrays,\n            lintResultCache,\n            linter,\n            options: {\n                allowInlineConfig,\n                cache,\n                cwd,\n                fix,\n                reportUnusedDisableDirectives\n            }\n        } = internalSlotsMap.get(this);\n        const results = [];\n        const startTime = Date.now();\n\n        // Clear the last used config arrays.\n        lastConfigArrays.length = 0;\n\n        // Delete cache file; should this do here?\n        if (!cache) {\n            try {\n                fs.unlinkSync(cacheFilePath);\n            } catch (error) {\n                const errorCode = error && error.code;\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n                if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !fs.existsSync(cacheFilePath))) {\n                    throw error;\n                }\n            }\n        }\n\n        // Iterate source code files.\n        for (const { config, filePath, ignored } of fileEnumerator.iterateFiles(patterns)) {\n            if (ignored) {\n                results.push(createIgnoreResult(filePath, cwd));\n                continue;\n            }\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n            if (!lastConfigArrays.includes(config)) {\n                lastConfigArrays.push(config);\n            }\n\n            // Skip if there is cached result.\n            if (lintResultCache) {\n                const cachedResult =\n                    lintResultCache.getCachedLintResults(filePath, config);\n\n                if (cachedResult) {\n                    const hadMessages =\n                        cachedResult.messages &&\n                        cachedResult.messages.length > 0;\n\n                    if (hadMessages && fix) {\n                        debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n                    } else {\n                        debug(`Skipping file since it hasn't changed: ${filePath}`);\n                        results.push(cachedResult);\n                        continue;\n                    }\n                }\n            }\n\n            // Do lint.\n            const result = verifyText({\n                text: fs.readFileSync(filePath, \"utf8\"),\n                filePath,\n                config,\n                cwd,\n                fix,\n                allowInlineConfig,\n                reportUnusedDisableDirectives,\n                fileEnumerator,\n                linter\n            });\n\n            results.push(result);\n\n            /*\n             * Store the lint result in the LintResultCache.\n             * NOTE: The LintResultCache will remove the file source and any\n             * other properties that are difficult to serialize, and will\n             * hydrate those properties back in on future lint runs.\n             */\n            if (lintResultCache) {\n                lintResultCache.setCachedLintResults(filePath, config, result);\n            }\n        }\n\n        // Persist the cache to disk.\n        if (lintResultCache) {\n            lintResultCache.reconcile();\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n        let usedDeprecatedRules;\n\n        return {\n            results,\n            ...calculateStatsPerRun(results),\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n            get usedDeprecatedRules() {\n                if (!usedDeprecatedRules) {\n                    usedDeprecatedRules = Array.from(\n                        iterateRuleDeprecationWarnings(lastConfigArrays)\n                    );\n                }\n                return usedDeprecatedRules;\n            }\n        };\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} [filename] An optional string representing the texts filename.\n     * @param {boolean} [warnIgnored] Always warn when a file is ignored\n     * @returns {LintReport} The results for the linting.\n     */\n    executeOnText(text, filename, warnIgnored) {\n        const {\n            configArrayFactory,\n            fileEnumerator,\n            lastConfigArrays,\n            linter,\n            options: {\n                allowInlineConfig,\n                cwd,\n                fix,\n                reportUnusedDisableDirectives\n            }\n        } = internalSlotsMap.get(this);\n        const results = [];\n        const startTime = Date.now();\n        const resolvedFilename = filename && path.resolve(cwd, filename);\n\n\n        // Clear the last used config arrays.\n        lastConfigArrays.length = 0;\n        if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {\n            if (warnIgnored) {\n                results.push(createIgnoreResult(resolvedFilename, cwd));\n            }\n        } else {\n            const config = configArrayFactory.getConfigArrayForFile(\n                resolvedFilename || \"__placeholder__.js\"\n            );\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n            lastConfigArrays.push(config);\n\n            // Do lint.\n            results.push(verifyText({\n                text,\n                filePath: resolvedFilename,\n                config,\n                cwd,\n                fix,\n                allowInlineConfig,\n                reportUnusedDisableDirectives,\n                fileEnumerator,\n                linter\n            }));\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n        let usedDeprecatedRules;\n\n        return {\n            results,\n            ...calculateStatsPerRun(results),\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n            get usedDeprecatedRules() {\n                if (!usedDeprecatedRules) {\n                    usedDeprecatedRules = Array.from(\n                        iterateRuleDeprecationWarnings(lastConfigArrays)\n                    );\n                }\n                return usedDeprecatedRules;\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @throws {Error} If filepath a directory path.\n     * @returns {ConfigData} A configuration object for the file.\n     */\n    getConfigForFile(filePath) {\n        const { configArrayFactory, options } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(options.cwd, filePath);\n\n        if (directoryExists(absolutePath)) {\n            throw Object.assign(\n                new Error(\"'filePath' should not be a directory path.\"),\n                { messageTemplate: \"print-config-with-directory-path\" }\n            );\n        }\n\n        return configArrayFactory\n            .getConfigArrayForFile(absolutePath)\n            .extractConfig(absolutePath)\n            .toCompatibleObjectAsConfigFileContent();\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n    isPathIgnored(filePath) {\n        const {\n            configArrayFactory,\n            defaultIgnores,\n            options: { cwd, ignore }\n        } = internalSlotsMap.get(this);\n        const absolutePath = path.resolve(cwd, filePath);\n\n        if (ignore) {\n            const config = configArrayFactory\n                .getConfigArrayForFile(absolutePath)\n                .extractConfig(absolutePath);\n            const ignores = config.ignores || defaultIgnores;\n\n            return ignores(absolutePath);\n        }\n\n        return defaultIgnores(absolutePath);\n    }\n\n    /**\n     * Returns the formatter representing the given format or null if the `format` is not a string.\n     * @param {string} [format] The name of the format to load or the path to a\n     *      custom formatter.\n     * @throws {any} As may be thrown by requiring of formatter\n     * @returns {(FormatterFunction|null)} The formatter function or null if the `format` is not a string.\n     */\n    getFormatter(format) {\n\n        // default is stylish\n        const resolvedFormatName = format || \"stylish\";\n\n        // only strings are valid formatters\n        if (typeof resolvedFormatName === \"string\") {\n\n            // replace \\ with / for Windows compatibility\n            const normalizedFormatName = resolvedFormatName.replace(/\\\\/gu, \"/\");\n\n            const slots = internalSlotsMap.get(this);\n            const cwd = slots ? slots.options.cwd : process.cwd();\n            const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n            let formatterPath;\n\n            // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n            if (!namespace && normalizedFormatName.includes(\"/\")) {\n                formatterPath = path.resolve(cwd, normalizedFormatName);\n            } else {\n                try {\n                    const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n                    formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\n                } catch {\n                    formatterPath = path.resolve(__dirname, \"formatters\", normalizedFormatName);\n                }\n            }\n\n            try {\n                return require(formatterPath);\n            } catch (ex) {\n                if (removedFormatters.has(format)) {\n                    ex.message = `The ${format} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${format}\\``;\n                } else {\n                    ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n                }\n                throw ex;\n            }\n\n        } else {\n            return null;\n        }\n    }\n}\n\nCLIEngine.version = pkg.version;\nCLIEngine.getFormatter = CLIEngine.prototype.getFormatter;\n\nmodule.exports = {\n    CLIEngine,\n\n    /**\n     * Get the internal slots of a given CLIEngine instance for tests.\n     * @param {CLIEngine} instance The CLIEngine instance to get.\n     * @returns {CLIEngineInternalSlots} The internal slots.\n     */\n    getCLIEngineInternalSlots(instance) {\n        return internalSlotsMap.get(instance);\n    }\n};\n"
        }
    ]
}