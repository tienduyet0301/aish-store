{
    "sourceFile": "node_modules/eslint/lib/cli-engine/lint-result-cache.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892208923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Utility for caching lint results.\n * @author Kevin Partington\n */\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst fs = require(\"node:fs\");\nconst fileEntryCache = require(\"file-entry-cache\");\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\nconst pkg = require(\"../../package.json\");\nconst assert = require(\"../shared/assert\");\nconst hash = require(\"./hash\");\n\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\n\nconst validCacheStrategies = [\"metadata\", \"content\"];\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies\n    .map(strategy => `\"${strategy}\"`)\n    .join(\", \")}`;\n\n/**\n * Tests whether a provided cacheStrategy is valid\n * @param {string} cacheStrategy The cache strategy to use\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\n */\nfunction isValidCacheStrategy(cacheStrategy) {\n    return (\n        validCacheStrategies.includes(cacheStrategy)\n    );\n}\n\n/**\n * Calculates the hash of the config\n * @param {ConfigArray} config The config.\n * @returns {string} The hash of the config\n */\nfunction hashOfConfigFor(config) {\n    if (!configHashCache.has(config)) {\n        configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n    }\n\n    return configHashCache.get(config);\n}\n\n//-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\n * Lint result cache. This wraps around the file-entry-cache module,\n * transparently removing properties that are difficult or expensive to\n * serialize and adding them back in on retrieval.\n */\nclass LintResultCache {\n\n    /**\n     * Creates a new LintResultCache instance.\n     * @param {string} cacheFileLocation The cache file location.\n     * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\n     */\n    constructor(cacheFileLocation, cacheStrategy) {\n        assert(cacheFileLocation, \"Cache file location is required\");\n        assert(cacheStrategy, \"Cache strategy is required\");\n        assert(\n            isValidCacheStrategy(cacheStrategy),\n            invalidCacheStrategyErrorMessage\n        );\n\n        debug(`Caching results to ${cacheFileLocation}`);\n\n        const useChecksum = cacheStrategy === \"content\";\n\n        debug(\n            `Using \"${cacheStrategy}\" strategy to detect changes`\n        );\n\n        this.fileEntryCache = fileEntryCache.create(\n            cacheFileLocation,\n            void 0,\n            useChecksum\n        );\n        this.cacheFileLocation = cacheFileLocation;\n    }\n\n    /**\n     * Retrieve cached lint results for a given file path, if present in the\n     * cache. If the file is present and has not been changed, rebuild any\n     * missing result information.\n     * @param {string} filePath The file for which to retrieve lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @returns {Object|null} The rebuilt lint results, or null if the file is\n     *   changed or not in the filesystem.\n     */\n    getCachedLintResults(filePath, config) {\n\n        /*\n         * Cached lint results are valid if and only if:\n         * 1. The file is present in the filesystem\n         * 2. The file has not changed since the time it was previously linted\n         * 3. The ESLint configuration has not changed since the time the file\n         *    was previously linted\n         * If any of these are not true, we will not reuse the lint results.\n         */\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n        const hashOfConfig = hashOfConfigFor(config);\n        const changed =\n            fileDescriptor.changed ||\n            fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n        if (fileDescriptor.notFound) {\n            debug(`File not found on the file system: ${filePath}`);\n            return null;\n        }\n\n        if (changed) {\n            debug(`Cache entry not found or no longer valid: ${filePath}`);\n            return null;\n        }\n\n        const cachedResults = fileDescriptor.meta.results;\n\n        // Just in case, not sure if this can ever happen.\n        if (!cachedResults) {\n            return cachedResults;\n        }\n\n        /*\n         * Shallow clone the object to ensure that any properties added or modified afterwards\n         * will not be accidentally stored in the cache file when `reconcile()` is called.\n         * https://github.com/eslint/eslint/issues/13507\n         * All intentional changes to the cache file must be done through `setCachedLintResults()`.\n         */\n        const results = { ...cachedResults };\n\n        // If source is present but null, need to reread the file from the filesystem.\n        if (results.source === null) {\n            debug(`Rereading cached result source from filesystem: ${filePath}`);\n            results.source = fs.readFileSync(filePath, \"utf-8\");\n        }\n\n        return results;\n    }\n\n    /**\n     * Set the cached lint results for a given file path, after removing any\n     * information that will be both unnecessary and difficult to serialize.\n     * Avoids caching results with an \"output\" property (meaning fixes were\n     * applied), to prevent potentially incorrect results if fixes are not\n     * written to disk.\n     * @param {string} filePath The file for which to set lint results.\n     * @param {ConfigArray} config The config of the file.\n     * @param {Object} result The lint result to be set for the file.\n     * @returns {void}\n     */\n    setCachedLintResults(filePath, config, result) {\n        if (result && Object.hasOwn(result, \"output\")) {\n            return;\n        }\n\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n        if (fileDescriptor && !fileDescriptor.notFound) {\n            debug(`Updating cached result: ${filePath}`);\n\n            // Serialize the result, except that we want to remove the file source if present.\n            const resultToSerialize = Object.assign({}, result);\n\n            /*\n             * Set result.source to null.\n             * In `getCachedLintResults`, if source is explicitly null, we will\n             * read the file from the filesystem to set the value again.\n             */\n            if (Object.hasOwn(resultToSerialize, \"source\")) {\n                resultToSerialize.source = null;\n            }\n\n            fileDescriptor.meta.results = resultToSerialize;\n            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n        }\n    }\n\n    /**\n     * Persists the in-memory cache to disk.\n     * @returns {void}\n     */\n    reconcile() {\n        debug(`Persisting cached results: ${this.cacheFileLocation}`);\n        this.fileEntryCache.reconcile();\n    }\n}\n\nmodule.exports = LintResultCache;\n"
        }
    ]
}