{
    "sourceFile": "node_modules/eslint/lib/rules/lines-around-comment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892217455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with any line numbers that contain comments.\n * @param {Array} comments An array of comment tokens.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"lines-around-comment\",\n                        url: \"https://eslint.style/rules/js/lines-around-comment\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require empty lines around comments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/lines-around-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    afterLineComment: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowClassStart: {\n                        type: \"boolean\"\n                    },\n                    allowClassEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    },\n                    afterHashbangComment: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            after: \"Expected line after comment.\",\n            before: \"Expected line before comment.\"\n        }\n    },\n\n    create(context) {\n\n        const options = Object.assign({}, context.options[0]);\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n\n        const sourceCode = context.sourceCode;\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = new Set(commentLines.concat(emptyLines));\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {token} token The comment token to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(token) {\n            let currentToken = token;\n\n            do {\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n                return true;\n            }\n\n            currentToken = token;\n            do {\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n            } while (currentToken && astUtils.isCommentToken(currentToken));\n\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isParentNodeType(parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns the parent node that contains the given token.\n         * @param {token} token The token to check.\n         * @returns {ASTNode|null} The parent node that contains the given token.\n         */\n        function getParentNodeOfToken(token) {\n            const node = sourceCode.getNodeByRangeIndex(token.range[0]);\n\n            /*\n             * For the purpose of this rule, the comment token is in a `StaticBlock` node only\n             * if it's inside the braces of that `StaticBlock` node.\n             *\n             * Example where this function returns `null`:\n             *\n             *   static\n             *   // comment\n             *   {\n             *   }\n             *\n             * Example where this function returns `StaticBlock` node:\n             *\n             *   static\n             *   {\n             *   // comment\n             *   }\n             *\n             */\n            if (node && node.type === \"StaticBlock\") {\n                const openingBrace = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\n\n                return token.range[0] >= openingBrace.range[0]\n                    ? node\n                    : null;\n            }\n\n            return node;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            if (parent && isParentNodeType(parent, nodeType)) {\n                let parentStartNodeOrToken = parent;\n\n                if (parent.type === \"StaticBlock\") {\n                    parentStartNodeOrToken = sourceCode.getFirstToken(parent, { skip: 1 }); // opening brace of the static block\n                } else if (parent.type === \"SwitchStatement\") {\n                    parentStartNodeOrToken = sourceCode.getTokenAfter(parent.discriminant, {\n                        filter: astUtils.isOpeningBraceToken\n                    }); // opening brace of the switch statement\n                }\n\n                return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {token} token The Comment token.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(token, nodeType) {\n            const parent = getParentNodeOfToken(token);\n\n            return !!parent && isParentNodeType(parent, nodeType) &&\n                    parent.loc.end.line - token.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(token) {\n            return (\n                isCommentAtParentStart(token, \"ClassBody\") ||\n                isCommentAtParentStart(token, \"BlockStatement\") ||\n                isCommentAtParentStart(token, \"StaticBlock\") ||\n                isCommentAtParentStart(token, \"SwitchCase\") ||\n                isCommentAtParentStart(token, \"SwitchStatement\")\n            );\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(token) {\n            return (\n                isCommentAtParentEnd(token, \"ClassBody\") ||\n                isCommentAtParentEnd(token, \"BlockStatement\") ||\n                isCommentAtParentEnd(token, \"StaticBlock\") ||\n                isCommentAtParentEnd(token, \"SwitchCase\") ||\n                isCommentAtParentEnd(token, \"SwitchStatement\")\n            );\n        }\n\n        /**\n         * Returns whether or not comments are at the class start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class start.\n         */\n        function isCommentAtClassStart(token) {\n            return isCommentAtParentStart(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the class end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at class end.\n         */\n        function isCommentAtClassEnd(token) {\n            return isCommentAtParentEnd(token, \"ClassBody\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(token) {\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(token) {\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(token) {\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {token} token The Comment token.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(token) {\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment token has lines around it (ignores inline comments)\n         * @param {token} token The Comment token.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(token, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = token.loc.start.line - 1,\n                nextLineNum = token.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(token);\n\n            const blockStartAllowed = options.allowBlockStart &&\n                    isCommentAtBlockStart(token) &&\n                    !(options.allowClassStart === false &&\n                    isCommentAtClassStart(token)),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n                classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n                classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n\n            const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !commentAndEmptyLines.has(prevLineNum) &&\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n                const lineStart = token.range[0] - token.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node: token,\n                    messageId: \"before\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !commentAndEmptyLines.has(nextLineNum) &&\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n                context.report({\n                    node: token,\n                    messageId: \"after\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                comments.forEach(token => {\n                    if (token.type === \"Line\") {\n                        if (options.beforeLineComment || options.afterLineComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterLineComment,\n                                before: options.beforeLineComment\n                            });\n                        }\n                    } else if (token.type === \"Block\") {\n                        if (options.beforeBlockComment || options.afterBlockComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterBlockComment,\n                                before: options.beforeBlockComment\n                            });\n                        }\n                    } else if (token.type === \"Shebang\") {\n                        if (options.afterHashbangComment) {\n                            checkForEmptyLine(token, {\n                                after: options.afterHashbangComment,\n                                before: false\n                            });\n                        }\n                    }\n                });\n            }\n        };\n    }\n};\n"
        }
    ]
}