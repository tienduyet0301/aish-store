{
    "sourceFile": "node_modules/eslint/lib/rules/no-trailing-spaces.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892231784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"no-trailing-spaces\",\n                        url: \"https://eslint.style/rules/js/no-trailing-spaces\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Disallow trailing whitespace at the end of lines\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-trailing-spaces\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            trailingSpace: \"Trailing spaces not allowed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false,\n            ignoreComments = options.ignoreComments || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                messageId: \"trailingSpace\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n        /**\n         * Given a list of comment nodes, return the line numbers for those comments.\n         * @param {Array} comments An array of comment nodes.\n         * @returns {number[]} An array of line numbers containing comments.\n         */\n        function getCommentLineNumbers(comments) {\n            const lines = new Set();\n\n            comments.forEach(comment => {\n                const endLine = comment.type === \"Block\"\n                    ? comment.loc.end.line - 1\n                    : comment.loc.end.line;\n\n                for (let i = comment.loc.start.line; i <= endLine; i++) {\n                    lines.add(i);\n                }\n            });\n\n            return lines;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                /*\n                 * Let's hack. Since Espree does not return whitespace nodes,\n                 * fetch the source code and do matching via regexps.\n                 */\n\n                const re = new RegExp(NONBLANK, \"u\"),\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n                    comments = sourceCode.getAllComments(),\n                    commentLineNumbers = getCommentLineNumbers(comments);\n\n                let totalLength = 0;\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const lineNumber = i + 1;\n\n                    /*\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                     * Because during the fix time they also reserve one spot in the array.\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                     */\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    const matches = re.exec(lines[i]);\n\n                    if (matches) {\n                        const location = {\n                            start: {\n                                line: lineNumber,\n                                column: matches.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: lineLength - linebreakLength\n                            }\n                        };\n\n                        const rangeStart = totalLength + location.start.column;\n                        const rangeEnd = totalLength + location.end.column;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        /*\n                         * If the line has only whitespace, and skipBlankLines\n                         * is true, don't report it\n                         */\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        const fixRange = [rangeStart, rangeEnd];\n\n                        if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n                            report(node, location, fixRange);\n                        }\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n"
        }
    ]
}