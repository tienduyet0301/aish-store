{
    "sourceFile": "node_modules/eslint/lib/rules/accessor-pairs.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce getter and setter pairs in objects and classes.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\n * @typedef {string|Token[]} Key\n */\n\n/**\n * Accessor nodes with the same key.\n * @typedef {Object} AccessorData\n * @property {Key} key Accessor's key\n * @property {ASTNode[]} getters List of getter nodes.\n * @property {ASTNode[]} setters List of setter nodes.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not the given lists represent the equal tokens in the same order.\n * Tokens are compared by their properties, not by instance.\n * @param {Token[]} left First list of tokens.\n * @param {Token[]} right Second list of tokens.\n * @returns {boolean} `true` if the lists have same tokens.\n */\nfunction areEqualTokenLists(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n\n    for (let i = 0; i < left.length; i++) {\n        const leftToken = left[i],\n            rightToken = right[i];\n\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not the given keys are equal.\n * @param {Key} left First key.\n * @param {Key} right Second key.\n * @returns {boolean} `true` if the keys are equal.\n */\nfunction areEqualKeys(left, right) {\n    if (typeof left === \"string\" && typeof right === \"string\") {\n\n        // Statically computed names.\n        return left === right;\n    }\n    if (Array.isArray(left) && Array.isArray(right)) {\n\n        // Token lists.\n        return areEqualTokenLists(left, right);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is of an accessor kind.\n */\nfunction isAccessorKind(node) {\n    return node.kind === \"get\" || node.kind === \"set\";\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node A node to check.\n * @param {number} index An expected index of the node in arguments.\n * @param {string} object An expected name of the object of the method.\n * @param {string} property An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(parent.callee, object, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    const grandparent = node.parent.parent;\n\n    return grandparent.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            enforceForClassMembers: true,\n            getWithoutSet: false,\n            setWithoutGet: true\n        }],\n\n        docs: {\n            description: \"Enforce getter and setter pairs in objects and classes\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/accessor-pairs\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\"\n                },\n                setWithoutGet: {\n                    type: \"boolean\"\n                },\n                enforceForClassMembers: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\n            missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\n            missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\n            missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\n            missingGetterInClass: \"Getter is not present for class {{ name }}.\",\n            missingSetterInClass: \"Setter is not present for class {{ name }}.\"\n        }\n    },\n    create(context) {\n        const [{\n            getWithoutSet: checkGetWithoutSet,\n            setWithoutGet: checkSetWithoutGet,\n            enforceForClassMembers\n        }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n         * @returns {void}\n         * @private\n         */\n        function report(node, messageKind) {\n            if (node.type === \"Property\") {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InObjectLiteral`,\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\n                });\n            } else if (node.type === \"MethodDefinition\") {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InClass`,\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: `${messageKind}InPropertyDescriptor`\n                });\n            }\n        }\n\n        /**\n         * Reports each of the nodes in the given list using the same messageId.\n         * @param {ASTNode[]} nodes Nodes to report.\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\n         * @returns {void}\n         * @private\n         */\n        function reportList(nodes, messageKind) {\n            for (const node of nodes) {\n                report(node, messageKind);\n            }\n        }\n\n        /**\n         * Checks accessor pairs in the given list of nodes.\n         * @param {ASTNode[]} nodes The list to check.\n         * @returns {void}\n         * @private\n         */\n        function checkList(nodes) {\n            const accessors = [];\n            let found = false;\n\n            for (let i = 0; i < nodes.length; i++) {\n                const node = nodes[i];\n\n                if (isAccessorKind(node)) {\n\n                    // Creates a new `AccessorData` object for the given getter or setter node.\n                    const name = astUtils.getStaticPropertyName(node);\n                    const key = (name !== null) ? name : sourceCode.getTokens(node.key);\n\n                    // Merges the given `AccessorData` object into the given accessors list.\n                    for (let j = 0; j < accessors.length; j++) {\n                        const accessor = accessors[j];\n\n                        if (areEqualKeys(accessor.key, key)) {\n                            accessor.getters.push(...node.kind === \"get\" ? [node] : []);\n                            accessor.setters.push(...node.kind === \"set\" ? [node] : []);\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        accessors.push({\n                            key,\n                            getters: node.kind === \"get\" ? [node] : [],\n                            setters: node.kind === \"set\" ? [node] : []\n                        });\n                    }\n                    found = false;\n                }\n            }\n\n            for (const { getters, setters } of accessors) {\n                if (checkSetWithoutGet && setters.length && !getters.length) {\n                    reportList(setters, \"missingGetter\");\n                }\n                if (checkGetWithoutSet && getters.length && !setters.length) {\n                    reportList(getters, \"missingSetter\");\n                }\n            }\n        }\n\n        /**\n         * Checks accessor pairs in an object literal.\n         * @param {ASTNode} node `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkObjectLiteral(node) {\n            checkList(node.properties.filter(p => p.type === \"Property\"));\n        }\n\n        /**\n         * Checks accessor pairs in a property descriptor.\n         * @param {ASTNode} node Property descriptor `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkPropertyDescriptor(node) {\n            const namesToCheck = new Set(node.properties\n                .filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed)\n                .map(({ key }) => key.name));\n\n            const hasGetter = namesToCheck.has(\"get\");\n            const hasSetter = namesToCheck.has(\"set\");\n\n            if (checkSetWithoutGet && hasSetter && !hasGetter) {\n                report(node, \"missingGetter\");\n            }\n            if (checkGetWithoutSet && hasGetter && !hasSetter) {\n                report(node, \"missingSetter\");\n            }\n        }\n\n        /**\n         * Checks the given object expression as an object literal and as a possible property descriptor.\n         * @param {ASTNode} node `ObjectExpression` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkObjectExpression(node) {\n            checkObjectLiteral(node);\n            if (isPropertyDescriptor(node)) {\n                checkPropertyDescriptor(node);\n            }\n        }\n\n        /**\n         * Checks the given class body.\n         * @param {ASTNode} node `ClassBody` node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkClassBody(node) {\n            const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\n\n            checkList(methodDefinitions.filter(m => m.static));\n            checkList(methodDefinitions.filter(m => !m.static));\n        }\n\n        const listeners = {};\n\n        if (checkSetWithoutGet || checkGetWithoutSet) {\n            listeners.ObjectExpression = checkObjectExpression;\n            if (enforceForClassMembers) {\n                listeners.ClassBody = checkClassBody;\n            }\n        }\n\n        return listeners;\n    }\n};\n"
        }
    ]
}