{
    "sourceFile": "node_modules/eslint/lib/rules/no-unused-labels.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unused labels\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-labels\"\n        },\n\n        schema: [],\n\n        fixable: \"code\",\n\n        messages: {\n            unused: \"'{{name}}:' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        let scopeInfo = null;\n\n        /**\n         * Adds a scope info to the stack.\n         * @param {ASTNode} node A node to add. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledScope(node) {\n            scopeInfo = {\n                label: node.label.name,\n                used: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Checks if a `LabeledStatement` node is fixable.\n         * For a node to be fixable, there must be no comments between the label and the body.\n         * Furthermore, is must be possible to remove the label without turning the body statement into a\n         * directive after other fixes are applied.\n         * @param {ASTNode} node The node to evaluate.\n         * @returns {boolean} Whether or not the node is fixable.\n         */\n        function isFixable(node) {\n\n            /*\n             * Only perform a fix if there are no comments between the label and the body. This will be the case\n             * when there is exactly one token/comment (the \":\") between the label and the body.\n             */\n            if (sourceCode.getTokenAfter(node.label, { includeComments: true }) !==\n                sourceCode.getTokenBefore(node.body, { includeComments: true })) {\n                return false;\n            }\n\n            // Looking for the node's deepest ancestor which is not a `LabeledStatement`.\n            let ancestor = node.parent;\n\n            while (ancestor.type === \"LabeledStatement\") {\n                ancestor = ancestor.parent;\n            }\n\n            if (ancestor.type === \"Program\" ||\n                (ancestor.type === \"BlockStatement\" && astUtils.isFunction(ancestor.parent))) {\n                const { body } = node;\n\n                if (body.type === \"ExpressionStatement\" &&\n                    ((body.expression.type === \"Literal\" && typeof body.expression.value === \"string\") ||\n                    astUtils.isStaticTemplateLiteral(body.expression))) {\n                    return false; // potential directive\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Removes the top of the stack.\n         * At the same time, this reports the label if it's never used.\n         * @param {ASTNode} node A node to report. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledScope(node) {\n            if (!scopeInfo.used) {\n                context.report({\n                    node: node.label,\n                    messageId: \"unused\",\n                    data: node.label,\n                    fix: isFixable(node) ? fixer => fixer.removeRange([node.range[0], node.body.range[0]]) : null\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Marks the label of a given node as used.\n         * @param {ASTNode} node A node to mark. This is a BreakStatement or\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function markAsUsed(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const label = node.label.name;\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    info.used = true;\n                    break;\n                }\n                info = info.upper;\n            }\n        }\n\n        return {\n            LabeledStatement: enterLabeledScope,\n            \"LabeledStatement:exit\": exitLabeledScope,\n            BreakStatement: markAsUsed,\n            ContinueStatement: markAsUsed\n        };\n    }\n};\n"
        }
    ]
}