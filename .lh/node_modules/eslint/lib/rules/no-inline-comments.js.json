{
    "sourceFile": "node_modules/eslint/lib/rules/no-inline-comments.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{}],\n\n        docs: {\n            description: \"Disallow inline comments after code\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-inline-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignorePattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedInlineComment: \"Unexpected comment inline with code.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const [{ ignorePattern }] = context.options;\n        const customIgnoreRegExp = ignorePattern && new RegExp(ignorePattern, \"u\");\n\n        /**\n         * Will check that comments are not on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check\n         * @private\n         * @returns {void}\n         */\n        function testCodeAroundComment(node) {\n\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\n                endLine = String(sourceCode.lines[node.loc.end.line - 1]),\n                preamble = startLine.slice(0, node.loc.start.column).trim(),\n                postamble = endLine.slice(node.loc.end.column).trim(),\n                isPreambleEmpty = !preamble,\n                isPostambleEmpty = !postamble;\n\n            // Nothing on both sides\n            if (isPreambleEmpty && isPostambleEmpty) {\n                return;\n            }\n\n            // Matches the ignore pattern\n            if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\n                return;\n            }\n\n            // JSX Exception\n            if (\n                (isPreambleEmpty || preamble === \"{\") &&\n                (isPostambleEmpty || postamble === \"}\")\n            ) {\n                const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\n\n                if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\n                    return;\n                }\n            }\n\n            // Don't report ESLint directive comments\n            if (astUtils.isDirectiveComment(node)) {\n                return;\n            }\n\n            context.report({\n                node,\n                messageId: \"unexpectedInlineComment\"\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n                sourceCode.getAllComments()\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(testCodeAroundComment);\n            }\n        };\n    }\n};\n"
        }
    ]
}