{
    "sourceFile": "node_modules/eslint/lib/rules/id-length.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892216567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { getGraphemeCount } = require(\"../shared/string-utils\");\nconst { getModuleExportName, isImportAttributeKey } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            exceptionPatterns: [],\n            exceptions: [],\n            min: 2,\n            properties: \"always\"\n        }],\n\n        docs: {\n            description: \"Enforce minimum and maximum identifier lengths\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/id-length\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    min: {\n                        type: \"integer\"\n                    },\n                    max: {\n                        type: \"integer\"\n                    },\n                    exceptions: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    exceptionPatterns: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n            tooShortPrivate: \"Identifier name '#{{name}}' is too short (< {{min}}).\",\n            tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\",\n            tooLongPrivate: \"Identifier name #'{{name}}' is too long (> {{max}}).\"\n        }\n    },\n\n    create(context) {\n        const [options] = context.options;\n        const { max: maxLength = Infinity, min: minLength } = options;\n        const properties = options.properties !== \"never\";\n        const exceptions = new Set(options.exceptions);\n        const exceptionPatterns = options.exceptionPatterns.map(pattern => new RegExp(pattern, \"u\"));\n        const reportedNodes = new Set();\n\n        /**\n         * Checks if a string matches the provided exception patterns\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function matchesExceptionPattern(name) {\n            return exceptionPatterns.some(pattern => pattern.test(name));\n        }\n\n        const SUPPORTED_EXPRESSIONS = {\n            MemberExpression: properties && function(parent) {\n                return !parent.computed && (\n\n                    // regular property assignment\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n\n                    // or the last identifier in an ObjectPattern destructuring\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\n                );\n            },\n            AssignmentPattern(parent, node) {\n                return parent.left === node;\n            },\n            VariableDeclarator(parent, node) {\n                return parent.id === node;\n            },\n            Property(parent, node) {\n\n                if (parent.parent.type === \"ObjectPattern\") {\n                    const isKeyAndValueSame = parent.value.name === parent.key.name;\n\n                    return (\n                        !isKeyAndValueSame && parent.value === node ||\n                        isKeyAndValueSame && parent.key === node && properties\n                    );\n                }\n                return properties && !isImportAttributeKey(node) && !parent.computed && parent.key.name === node.name;\n            },\n            ImportSpecifier(parent, node) {\n                return (\n                    parent.local === node &&\n                    getModuleExportName(parent.imported) !== getModuleExportName(parent.local)\n                );\n            },\n            ImportDefaultSpecifier: true,\n            ImportNamespaceSpecifier: true,\n            RestElement: true,\n            FunctionExpression: true,\n            ArrowFunctionExpression: true,\n            ClassDeclaration: true,\n            FunctionDeclaration: true,\n            MethodDefinition: true,\n            PropertyDefinition: true,\n            CatchClause: true,\n            ArrayPattern: true\n        };\n\n        return {\n            [[\n                \"Identifier\",\n                \"PrivateIdentifier\"\n            ]](node) {\n                const name = node.name;\n                const parent = node.parent;\n\n                const nameLength = getGraphemeCount(name);\n\n                const isShort = nameLength < minLength;\n                const isLong = nameLength > maxLength;\n\n                if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\n                    return; // Nothing to report\n                }\n\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n                /*\n                 * We used the range instead of the node because it's possible\n                 * for the same identifier to be represented by two different\n                 * nodes, with the most clear example being shorthand properties:\n                 * { foo }\n                 * In this case, \"foo\" is represented by one node for the name\n                 * and one for the value. The only way to know they are the same\n                 * is to look at the range.\n                 */\n                if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {\n                    reportedNodes.add(node.range.toString());\n\n                    let messageId = isShort ? \"tooShort\" : \"tooLong\";\n\n                    if (node.type === \"PrivateIdentifier\") {\n                        messageId += \"Private\";\n                    }\n\n                    context.report({\n                        node,\n                        messageId,\n                        data: { name, min: minLength, max: maxLength }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}