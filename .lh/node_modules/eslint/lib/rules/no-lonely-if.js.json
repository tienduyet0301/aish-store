{
    "sourceFile": "node_modules/eslint/lib/rules/no-lonely-if.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow if as the only statement in an else block\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow `if` statements as the only statement in `else` blocks\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-lonely-if\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedLonelyIf: \"Unexpected if as the only statement in an else block.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        return {\n            IfStatement(node) {\n                const parent = node.parent,\n                    grandparent = parent.parent;\n\n                if (parent && parent.type === \"BlockStatement\" &&\n                        parent.body.length === 1 && !astUtils.areBracesNecessary(parent, sourceCode) &&\n                        grandparent && grandparent.type === \"IfStatement\" &&\n                        parent === grandparent.alternate) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedLonelyIf\",\n                        fix(fixer) {\n                            const openingElseCurly = sourceCode.getFirstToken(parent);\n                            const closingElseCurly = sourceCode.getLastToken(parent);\n                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);\n                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);\n                            const lastIfToken = sourceCode.getLastToken(node.consequent);\n                            const sourceText = sourceCode.getText();\n\n                            if (sourceText.slice(openingElseCurly.range[1],\n                                node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {\n\n                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)\n                                return null;\n                            }\n\n                            if (\n                                node.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\" && tokenAfterElseBlock &&\n                                (\n                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||\n                                    /^[([/+`-]/u.test(tokenAfterElseBlock.value) ||\n                                    lastIfToken.value === \"++\" ||\n                                    lastIfToken.value === \"--\"\n                                )\n                            ) {\n\n                                /*\n                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing\n                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [openingElseCurly.range[0], closingElseCurly.range[1]],\n                                (elseKeyword.range[1] === openingElseCurly.range[0] ? \" \" : \"\") + sourceCode.getText(node)\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}