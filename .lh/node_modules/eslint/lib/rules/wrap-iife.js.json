{
    "sourceFile": "node_modules/eslint/lib/rules/wrap-iife.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892241273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"@eslint-community/eslint-utils\");\n\n//----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\n * Check if the given node is callee of a `NewExpression` node\n * @param {ASTNode} node node to check\n * @returns {boolean} True if the node is callee of a `NewExpression` node\n * @private\n */\nfunction isCalleeOfNewExpression(node) {\n    const maybeCallee = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n\n    return (\n        maybeCallee.parent.type === \"NewExpression\" &&\n        maybeCallee.parent.callee === maybeCallee\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"wrap-iife\",\n                        url: \"https://eslint.style/rules/js/wrap-iife\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require parentheses around immediate `function` invocations\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/wrap-iife\"\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n            wrapExpression: \"Wrap only the function expression in parens.\",\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in any parens\n         * @private\n         */\n        function isWrappedInAnyParens(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in grouping parens\n         * @private\n         */\n        function isWrappedInGroupingParens(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Get the function node from an IIFE\n         * @param {ASTNode} node node to evaluate\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n         */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const isCallExpressionWrapped = isWrappedInAnyParens(node),\n                    isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n                if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapInvocation\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapExpression\",\n                        fix(fixer) {\n\n                            // The outer call expression will always be wrapped at this point.\n\n                            if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n\n                                /*\n                                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\n                                 * Replace the range between the end of the function expression and the end of the call expression.\n                                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                                 */\n\n                                const parenAfter = sourceCode.getTokenAfter(node);\n\n                                return fixer.replaceTextRange(\n                                    [innerNode.range[1], parenAfter.range[1]],\n                                    `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                                );\n                            }\n\n                            /*\n                             * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\n                             * These parens cannot be removed, so just parenthesize the function expression.\n                             */\n\n                            return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n                        }\n                    });\n                } else if (style === \"outside\" && !isCallExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"moveInvocation\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}