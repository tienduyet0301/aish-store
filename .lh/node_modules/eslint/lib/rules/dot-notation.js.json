{
    "sourceFile": "node_modules/eslint/lib/rules/dot-notation.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892215318,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst keywords = require(\"./utils/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\n\n// `null` literal must be handled separately.\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allowKeywords: true,\n            allowPattern: \"\"\n        }],\n\n        docs: {\n            description: \"Enforce dot notation whenever possible\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/dot-notation\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\"\n                    },\n                    allowPattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            useDot: \"[{{key}}] is better written in dot notation.\",\n            useBrackets: \".{{key}} is a syntax error.\"\n        }\n    },\n\n    create(context) {\n        const [options] = context.options;\n        const allowKeywords = options.allowKeywords;\n        const sourceCode = context.sourceCode;\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern, \"u\");\n        }\n\n        /**\n         * Check if the property is valid dot notation\n         * @param {ASTNode} node The dot notation node\n         * @param {string} value Value which is to be checked\n         * @returns {void}\n         */\n        function checkComputedProperty(node, value) {\n            if (\n                validIdentifier.test(value) &&\n                (allowKeywords || !keywords.includes(String(value))) &&\n                !(allowPattern && allowPattern.test(value))\n            ) {\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n\n                context.report({\n                    node: node.property,\n                    messageId: \"useDot\",\n                    data: {\n                        key: formattedValue\n                    },\n                    *fix(fixer) {\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                        const rightBracket = sourceCode.getLastToken(node);\n                        const nextToken = sourceCode.getTokenAfter(node);\n\n                        // Don't perform any fixes if there are comments inside the brackets.\n                        if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n                            return;\n                        }\n\n                        // Replace the brackets by an identifier.\n                        if (!node.optional) {\n                            yield fixer.insertTextBefore(\n                                leftBracket,\n                                astUtils.isDecimalInteger(node.object) ? \" .\" : \".\"\n                            );\n                        }\n                        yield fixer.replaceTextRange(\n                            [leftBracket.range[0], rightBracket.range[1]],\n                            value\n                        );\n\n                        // Insert a space after the property if it will be connected to the next token.\n                        if (\n                            nextToken &&\n                            rightBracket.range[1] === nextToken.range[0] &&\n                            !astUtils.canTokensBeAdjacent(String(value), nextToken)\n                        ) {\n                            yield fixer.insertTextAfter(node, \" \");\n                        }\n                    }\n                });\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\" &&\n                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))\n                ) {\n                    checkComputedProperty(node, node.property.value);\n                }\n                if (\n                    node.computed &&\n                    astUtils.isStaticTemplateLiteral(node.property)\n                ) {\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    node.property.type === \"Identifier\" &&\n                    keywords.includes(String(node.property.name))\n                ) {\n                    context.report({\n                        node: node.property,\n                        messageId: \"useBrackets\",\n                        data: {\n                            key: node.property.name\n                        },\n                        *fix(fixer) {\n                            const dotToken = sourceCode.getTokenBefore(node.property);\n\n                            // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                                return;\n                            }\n\n                            // Don't perform any fixes if there are comments between the dot and the property name.\n                            if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                                return;\n                            }\n\n                            // Replace the identifier to brackets.\n                            if (!node.optional) {\n                                yield fixer.remove(dotToken);\n                            }\n                            yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}