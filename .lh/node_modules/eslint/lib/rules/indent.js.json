{
    "sourceFile": "node_modules/eslint/lib/rules/indent.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892216975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview This rule sets a specific indentation style and width for your code\n *\n * @author Teddy Katz\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst KNOWN_NODES = new Set([\n    \"AssignmentExpression\",\n    \"AssignmentPattern\",\n    \"ArrayExpression\",\n    \"ArrayPattern\",\n    \"ArrowFunctionExpression\",\n    \"AwaitExpression\",\n    \"BlockStatement\",\n    \"BinaryExpression\",\n    \"BreakStatement\",\n    \"CallExpression\",\n    \"CatchClause\",\n    \"ChainExpression\",\n    \"ClassBody\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"ConditionalExpression\",\n    \"ContinueStatement\",\n    \"DoWhileStatement\",\n    \"DebuggerStatement\",\n    \"EmptyStatement\",\n    \"ExperimentalRestProperty\",\n    \"ExperimentalSpreadProperty\",\n    \"ExpressionStatement\",\n    \"ForStatement\",\n    \"ForInStatement\",\n    \"ForOfStatement\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"IfStatement\",\n    \"Literal\",\n    \"LabeledStatement\",\n    \"LogicalExpression\",\n    \"MemberExpression\",\n    \"MetaProperty\",\n    \"MethodDefinition\",\n    \"NewExpression\",\n    \"ObjectExpression\",\n    \"ObjectPattern\",\n    \"PrivateIdentifier\",\n    \"Program\",\n    \"Property\",\n    \"PropertyDefinition\",\n    \"RestElement\",\n    \"ReturnStatement\",\n    \"SequenceExpression\",\n    \"SpreadElement\",\n    \"StaticBlock\",\n    \"Super\",\n    \"SwitchCase\",\n    \"SwitchStatement\",\n    \"TaggedTemplateExpression\",\n    \"TemplateElement\",\n    \"TemplateLiteral\",\n    \"ThisExpression\",\n    \"ThrowStatement\",\n    \"TryStatement\",\n    \"UnaryExpression\",\n    \"UpdateExpression\",\n    \"VariableDeclaration\",\n    \"VariableDeclarator\",\n    \"WhileStatement\",\n    \"WithStatement\",\n    \"YieldExpression\",\n    \"JSXFragment\",\n    \"JSXOpeningFragment\",\n    \"JSXClosingFragment\",\n    \"JSXIdentifier\",\n    \"JSXNamespacedName\",\n    \"JSXMemberExpression\",\n    \"JSXEmptyExpression\",\n    \"JSXExpressionContainer\",\n    \"JSXElement\",\n    \"JSXClosingElement\",\n    \"JSXOpeningElement\",\n    \"JSXAttribute\",\n    \"JSXSpreadAttribute\",\n    \"JSXText\",\n    \"ExportDefaultDeclaration\",\n    \"ExportNamedDeclaration\",\n    \"ExportAllDeclaration\",\n    \"ExportSpecifier\",\n    \"ImportDeclaration\",\n    \"ImportSpecifier\",\n    \"ImportDefaultSpecifier\",\n    \"ImportNamespaceSpecifier\",\n    \"ImportExpression\"\n]);\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n\n/**\n * A mutable map that stores (key, value) pairs. The keys are numeric indices, and must be unique.\n * This is intended to be a generic wrapper around a map with non-negative integer keys, so that the underlying implementation\n * can easily be swapped out.\n */\nclass IndexMap {\n\n    /**\n     * Creates an empty map\n     * @param {number} maxKey The maximum key\n     */\n    constructor(maxKey) {\n\n        // Initializing the array with the maximum expected size avoids dynamic reallocations that could degrade performance.\n        this._values = Array(maxKey + 1);\n    }\n\n    /**\n     * Inserts an entry into the map.\n     * @param {number} key The entry's key\n     * @param {any} value The entry's value\n     * @returns {void}\n     */\n    insert(key, value) {\n        this._values[key] = value;\n    }\n\n    /**\n     * Finds the value of the entry with the largest key less than or equal to the provided key\n     * @param {number} key The provided key\n     * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.\n     */\n    findLastNotAfter(key) {\n        const values = this._values;\n\n        for (let index = key; index >= 0; index--) {\n            const value = values[index];\n\n            if (value) {\n                return value;\n            }\n        }\n        return void 0;\n    }\n\n    /**\n     * Deletes all of the keys in the interval [start, end)\n     * @param {number} start The start of the range\n     * @param {number} end The end of the range\n     * @returns {void}\n     */\n    deleteRange(start, end) {\n        this._values.fill(void 0, start, end);\n    }\n}\n\n/**\n * A helper class to get token-based info related to indentation\n */\nclass TokenInfo {\n\n    /**\n     * @param {SourceCode} sourceCode A SourceCode object\n     */\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.firstTokensByLineNumber = new Map();\n        const tokens = sourceCode.tokensAndComments;\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {\n                this.firstTokensByLineNumber.set(token.loc.start.line, token);\n            }\n            if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n                this.firstTokensByLineNumber.set(token.loc.end.line, token);\n            }\n        }\n    }\n\n    /**\n     * Gets the first token on a given token's line\n     * @param {Token|ASTNode} token a node or token\n     * @returns {Token} The first token on the given line\n     */\n    getFirstTokenOfLine(token) {\n        return this.firstTokensByLineNumber.get(token.loc.start.line);\n    }\n\n    /**\n     * Determines whether a token is the first token in its line\n     * @param {Token} token The token\n     * @returns {boolean} `true` if the token is the first on its line\n     */\n    isFirstTokenOfLine(token) {\n        return this.getFirstTokenOfLine(token) === token;\n    }\n\n    /**\n     * Get the actual indent of a token\n     * @param {Token} token Token to examine. This should be the first token on its line.\n     * @returns {string} The indentation characters that precede the token\n     */\n    getTokenIndent(token) {\n        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n    }\n}\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\nclass OffsetStorage {\n\n    /**\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\n     * @param {number} indentSize The desired size of each indentation level\n     * @param {string} indentType The indentation character\n     * @param {number} maxIndex The maximum end index of any token\n     */\n    constructor(tokenInfo, indentSize, indentType, maxIndex) {\n        this._tokenInfo = tokenInfo;\n        this._indentSize = indentSize;\n        this._indentType = indentType;\n\n        this._indexMap = new IndexMap(maxIndex);\n        this._indexMap.insert(0, { offset: 0, from: null, force: false });\n\n        this._lockedFirstTokens = new WeakMap();\n        this._desiredIndentCache = new WeakMap();\n        this._ignoredTokens = new WeakSet();\n    }\n\n    _getOffsetDescriptor(token) {\n        return this._indexMap.findLastNotAfter(token.range[0]);\n    }\n\n    /**\n     * Sets the offset column of token B to match the offset column of token A.\n     * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\n     * most cases, `setDesiredOffset` should be used instead.\n     * @param {Token} baseToken The first token\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n     * @returns {void}\n     */\n    matchOffsetOf(baseToken, offsetToken) {\n\n        /*\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n         * token of each element in the array after the first will be mapped to the first token of the first\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\n         * of the \"first\" element, rather than through the normal offset mechanism.\n         */\n        this._lockedFirstTokens.set(offsetToken, baseToken);\n    }\n\n    /**\n     * Sets the desired offset of a token.\n     *\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n     * For example, consider the following two cases:\n     *\n     * (\n     *     [\n     *         bar\n     *     ]\n     * )\n     *\n     * ([\n     *     bar\n     * ])\n     *\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n     * from the start of its line.\n     *\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n     * by 1 indent level from the start of the line.\n     *\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n     * without needing to check which lines those tokens are on.\n     *\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n     * behavior can occur. For example, consider the following cases:\n     *\n     * foo(\n     * ).\n     *     bar(\n     *         baz\n     *     )\n     *\n     * foo(\n     * ).bar(\n     *     baz\n     * )\n     *\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n     * collapsing would occur).\n     *\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n     * in the second case.\n     * @param {Token} token The token\n     * @param {Token} fromToken The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n    setDesiredOffset(token, fromToken, offset) {\n        return this.setDesiredOffsets(token.range, fromToken, offset);\n    }\n\n    /**\n     * Sets the desired offset of all tokens in a range\n     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\n     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\n     * it). This means that the offset of each token is updated O(AST depth) times.\n     * It would not be performant to store and update the offsets for each token independently, because the rule would end\n     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\n     *\n     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\n     * list could represent the state of the offset tree at a given point:\n     *\n     * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file\n     * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\n     * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\n     * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\n     * - Tokens starting in the interval [820, ∞) are offset by 1 indent level from the `baz` token\n     *\n     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\n     * `setDesiredOffsets([30, 43], fooToken, 1);`\n     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\n     * @param {Token} fromToken The token that this is offset from\n     * @param {number} offset The desired indent level\n     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\n     * @returns {void}\n     */\n    setDesiredOffsets(range, fromToken, offset, force) {\n\n        /*\n         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\n         * descriptor. The tree for the example above would have the following nodes:\n         *\n         * * key: 0, value: { offset: 0, from: null }\n         * * key: 15, value: { offset: 1, from: barToken }\n         * * key: 30, value: { offset: 1, from: fooToken }\n         * * key: 43, value: { offset: 2, from: barToken }\n         * * key: 820, value: { offset: 1, from: bazToken }\n         *\n         * To find the offset descriptor for any given token, one needs to find the node with the largest key\n         * which is <= token.start. To make this operation fast, the nodes are stored in a map indexed by key.\n         */\n\n        const descriptorToInsert = { offset, from: fromToken, force };\n\n        const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);\n\n        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\n\n        // First, remove any existing nodes in the range from the map.\n        this._indexMap.deleteRange(range[0] + 1, range[1]);\n\n        // Insert a new node into the map for this range\n        this._indexMap.insert(range[0], descriptorToInsert);\n\n        /*\n         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\n         * even if it's in the current range.\n         */\n        if (fromTokenIsInRange) {\n            this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);\n            this._indexMap.insert(fromToken.range[1], descriptorToInsert);\n        }\n\n        /*\n         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\n         * tokens the same as it was before.\n         */\n        this._indexMap.insert(range[1], descriptorAfterRange);\n    }\n\n    /**\n     * Gets the desired indent of a token\n     * @param {Token} token The token\n     * @returns {string} The desired indent of the token\n     */\n    getDesiredIndent(token) {\n        if (!this._desiredIndentCache.has(token)) {\n\n            if (this._ignoredTokens.has(token)) {\n\n                /*\n                 * If the token is ignored, use the actual indent of the token as the desired indent.\n                 * This ensures that no errors are reported for this token.\n                 */\n                this._desiredIndentCache.set(\n                    token,\n                    this._tokenInfo.getTokenIndent(token)\n                );\n            } else if (this._lockedFirstTokens.has(token)) {\n                const firstToken = this._lockedFirstTokens.get(token);\n\n                this._desiredIndentCache.set(\n                    token,\n\n                    // (indentation for the first element's line)\n                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\n\n                        // (space between the start of the first element's line and the first element)\n                        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)\n                );\n            } else {\n                const offsetInfo = this._getOffsetDescriptor(token);\n                const offset = (\n                    offsetInfo.from &&\n                    offsetInfo.from.loc.start.line === token.loc.start.line &&\n                    !/^\\s*?\\n/u.test(token.value) &&\n                    !offsetInfo.force\n                ) ? 0 : offsetInfo.offset * this._indentSize;\n\n                this._desiredIndentCache.set(\n                    token,\n                    (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset)\n                );\n            }\n        }\n        return this._desiredIndentCache.get(token);\n    }\n\n    /**\n     * Ignores a token, preventing it from being reported.\n     * @param {Token} token The token\n     * @returns {void}\n     */\n    ignoreToken(token) {\n        if (this._tokenInfo.isFirstTokenOfLine(token)) {\n            this._ignoredTokens.add(token);\n        }\n    }\n\n    /**\n     * Gets the first token that the given token's indentation is dependent on\n     * @param {Token} token The token\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n     */\n    getFirstDependency(token) {\n        return this._getOffsetDescriptor(token).from;\n    }\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n    oneOf: [\n        {\n            type: \"integer\",\n            minimum: 0\n        },\n        {\n            enum: [\"first\", \"off\"]\n        }\n    ]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"indent\",\n                        url: \"https://eslint.style/rules/js/indent\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent indentation\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/indent\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0,\n                        default: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            ELEMENT_LIST_SCHEMA,\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: ELEMENT_LIST_SCHEMA,\n                                    let: ELEMENT_LIST_SCHEMA,\n                                    const: ELEMENT_LIST_SCHEMA\n                                },\n                                additionalProperties: false\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    MemberExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"off\"]\n                            }\n                        ]\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: ELEMENT_LIST_SCHEMA,\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    StaticBlock: {\n                        type: \"object\",\n                        properties: {\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            arguments: ELEMENT_LIST_SCHEMA\n                        },\n                        additionalProperties: false\n                    },\n                    ArrayExpression: ELEMENT_LIST_SCHEMA,\n                    ObjectExpression: ELEMENT_LIST_SCHEMA,\n                    ImportDeclaration: ELEMENT_LIST_SCHEMA,\n                    flatTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    offsetTernaryExpressions: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoredNodes: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            not: {\n                                pattern: \":exit$\"\n                            }\n                        }\n                    },\n                    ignoreComments: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = 1;\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: 1,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            StaticBlock: {\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            MemberExpression: 1,\n            ArrayExpression: 1,\n            ObjectExpression: 1,\n            ImportDeclaration: 1,\n            flatTernaryExpressions: false,\n            ignoredNodes: [],\n            ignoreComments: false\n        };\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                Object.assign(options, context.options[1]);\n\n                if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n                    options.VariableDeclarator = {\n                        var: options.VariableDeclarator,\n                        let: options.VariableDeclarator,\n                        const: options.VariableDeclarator\n                    };\n                }\n            }\n        }\n\n        const sourceCode = context.sourceCode;\n        const tokenInfo = new TokenInfo(sourceCode);\n        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\", sourceCode.text.length);\n        const parameterParens = new WeakSet();\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {Token} token Token violating the indent rule\n         * @param {string} neededIndent Expected indentation string\n         * @returns {void}\n         */\n        function report(token, neededIndent) {\n            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n            const numSpaces = actualIndent.filter(char => char === \" \").length;\n            const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n\n            context.report({\n                node: token,\n                messageId: \"wrongIndentation\",\n                data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n                loc: {\n                    start: { line: token.loc.start.line, column: 0 },\n                    end: { line: token.loc.start.line, column: token.loc.start.column }\n                },\n                fix(fixer) {\n                    const range = [token.range[0] - token.loc.start.column, token.range[0]];\n                    const newText = neededIndent;\n\n                    return fixer.replaceTextRange(range, newText);\n                }\n            });\n        }\n\n        /**\n         * Checks if a token's indentation is correct\n         * @param {Token} token Token to examine\n         * @param {string} desiredIndent Desired indentation of the string\n         * @returns {boolean} `true` if the token's indentation is correct\n         */\n        function validateTokenIndent(token, desiredIndent) {\n            const indentation = tokenInfo.getTokenIndent(token);\n\n            return indentation === desiredIndent ||\n\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n                indentation.includes(\" \") && indentation.includes(\"\\t\");\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n\n            /*\n             * Verify that the node is an IIFE\n             */\n            if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIFE is outer.\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n             */\n            let statement = node.parent && node.parent.parent;\n\n            while (\n                statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].includes(statement.operator) ||\n                statement.type === \"AssignmentExpression\" ||\n                statement.type === \"LogicalExpression\" ||\n                statement.type === \"SequenceExpression\" ||\n                statement.type === \"VariableDeclarator\"\n            ) {\n                statement = statement.parent;\n            }\n\n            return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n        }\n\n        /**\n         * Counts the number of linebreaks that follow the last non-whitespace character in a string\n         * @param {string} string The string to check\n         * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\n         * or the total number of linebreaks if the string is all whitespace.\n         */\n        function countTrailingLinebreaks(string) {\n            const trailingWhitespace = string.match(/\\s*$/u)[0];\n            const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n\n            return linebreakMatches === null ? 0 : linebreakMatches.length;\n        }\n\n        /**\n         * Check indentation for lists of elements (arrays, objects, function params)\n         * @param {ASTNode[]} elements List of elements that should be offset\n         * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n         * @param {Token} endToken The end token of the list, e.g. ']'\n         * @param {number|string} offset The amount that the elements should be offset\n         * @returns {void}\n         */\n        function addElementListIndent(elements, startToken, endToken, offset) {\n\n            /**\n             * Gets the first token of a given element, including surrounding parentheses.\n             * @param {ASTNode} element A node in the `elements` list\n             * @returns {Token} The first token of this element\n             */\n            function getFirstToken(element) {\n                let token = sourceCode.getTokenBefore(element);\n\n                while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n                    token = sourceCode.getTokenBefore(token);\n                }\n                return sourceCode.getTokenAfter(token);\n            }\n\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n            offsets.setDesiredOffsets(\n                [startToken.range[1], endToken.range[0]],\n                startToken,\n                typeof offset === \"number\" ? offset : 1\n            );\n            offsets.setDesiredOffset(endToken, startToken, 0);\n\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n            if (offset === \"first\" && elements.length && !elements[0]) {\n                return;\n            }\n            elements.forEach((element, index) => {\n                if (!element) {\n\n                    // Skip holes in arrays\n                    return;\n                }\n                if (offset === \"off\") {\n\n                    // Ignore the first token of every element if the \"off\" option is used\n                    offsets.ignoreToken(getFirstToken(element));\n                }\n\n                // Offset the following elements correctly relative to the first element\n                if (index === 0) {\n                    return;\n                }\n                if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n                } else {\n                    const previousElement = elements[index - 1];\n                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n                    const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n\n                    if (\n                        previousElement &&\n                        previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line\n                    ) {\n                        offsets.setDesiredOffsets(\n                            [previousElement.range[1], element.range[1]],\n                            firstTokenOfPreviousElement,\n                            0\n                        );\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function addBlocklessNodeIndent(node) {\n            if (node.type !== \"BlockStatement\") {\n                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n\n                let firstBodyToken = sourceCode.getFirstToken(node);\n                let lastBodyToken = sourceCode.getLastToken(node);\n\n                while (\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&\n                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))\n                ) {\n                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n                }\n\n                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n            }\n        }\n\n        /**\n         * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n         * @param {ASTNode} node A CallExpression or NewExpression node\n         * @returns {void}\n         */\n        function addFunctionCallIndent(node) {\n            let openingParen;\n\n            if (node.arguments.length) {\n                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n            } else {\n                openingParen = sourceCode.getLastToken(node, 1);\n            }\n            const closingParen = sourceCode.getLastToken(node);\n\n            parameterParens.add(openingParen);\n            parameterParens.add(closingParen);\n\n            /*\n             * If `?.` token exists, set desired offset for that.\n             * This logic is copied from `MemberExpression`'s.\n             */\n            if (node.optional) {\n                const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\n                const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: astUtils.isClosingParenToken }).length;\n                const firstTokenOfCallee = calleeParenCount\n                    ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 })\n                    : sourceCode.getFirstToken(node.callee);\n                const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\n                const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line\n                    ? lastTokenOfCallee\n                    : firstTokenOfCallee;\n\n                offsets.setDesiredOffset(dotToken, offsetBase, 1);\n            }\n\n            const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\n            const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\n\n            offsets.setDesiredOffset(openingParen, offsetToken, 0);\n\n            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n        }\n\n        /**\n         * Checks the indentation of parenthesized values, given a list of tokens in a program\n         * @param {Token[]} tokens A list of tokens\n         * @returns {void}\n         */\n        function addParensIndent(tokens) {\n            const parenStack = [];\n            const parenPairs = [];\n\n            for (let i = 0; i < tokens.length; i++) {\n                const nextToken = tokens[i];\n\n                if (astUtils.isOpeningParenToken(nextToken)) {\n                    parenStack.push(nextToken);\n                } else if (astUtils.isClosingParenToken(nextToken)) {\n                    parenPairs.push({ left: parenStack.pop(), right: nextToken });\n                }\n            }\n\n            for (let i = parenPairs.length - 1; i >= 0; i--) {\n                const leftParen = parenPairs[i].left;\n                const rightParen = parenPairs[i].right;\n\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n\n                    parenthesizedTokens.forEach(token => {\n                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n                            offsets.setDesiredOffset(token, leftParen, 1);\n                        }\n                    });\n                }\n\n                offsets.setDesiredOffset(rightParen, leftParen, 0);\n            }\n        }\n\n        /**\n         * Ignore all tokens within an unknown node whose offset do not depend\n         * on another token's offset within the unknown node\n         * @param {ASTNode} node Unknown Node\n         * @returns {void}\n         */\n        function ignoreNode(node) {\n            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));\n\n            unknownNodeTokens.forEach(token => {\n                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n                    if (token === firstTokenOfLine) {\n                        offsets.ignoreToken(token);\n                    } else {\n                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n                    }\n                }\n            });\n        }\n\n        /**\n         * Check whether the given token is on the first line of a statement.\n         * @param {Token} token The token to check.\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\n         * @returns {boolean} `true` if the token is on the first line of a statement.\n         */\n        function isOnFirstLineOfStatement(token, leafNode) {\n            let node = leafNode;\n\n            while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n                node = node.parent;\n            }\n            node = node.parent;\n\n            return !node || node.loc.start.line === token.loc.start.line;\n        }\n\n        /**\n         * Check whether there are any blank (whitespace-only) lines between\n         * two tokens on separate lines.\n         * @param {Token} firstToken The first token.\n         * @param {Token} secondToken The second token.\n         * @returns {boolean} `true` if the tokens are on separate lines and\n         *   there exists a blank line between them, `false` otherwise.\n         */\n        function hasBlankLinesBetween(firstToken, secondToken) {\n            const firstTokenLine = firstToken.loc.end.line;\n            const secondTokenLine = secondToken.loc.start.line;\n\n            if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n                return false;\n            }\n\n            for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n                if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        const ignoredNodeFirstTokens = new Set();\n\n        const baseOffsetListeners = {\n            \"ArrayExpression, ArrayPattern\"(node) {\n                const openingBracket = sourceCode.getFirstToken(node);\n                const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);\n\n                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n            },\n\n            \"ObjectExpression, ObjectPattern\"(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getTokenAfter(\n                    node.properties.length ? node.properties.at(-1) : openingCurly,\n                    astUtils.isClosingBraceToken\n                );\n\n                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n            },\n\n            ArrowFunctionExpression(node) {\n                const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });\n\n                if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\n                    const openingParen = maybeOpeningParen;\n                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n\n                    parameterParens.add(openingParen);\n                    parameterParens.add(closingParen);\n                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n                }\n\n                addBlocklessNodeIndent(node.body);\n            },\n\n            AssignmentExpression(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n            },\n\n            \"BinaryExpression, LogicalExpression\"(node) {\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n\n                /*\n                 * For backwards compatibility, don't check BinaryExpression indents, e.g.\n                 * var foo = bar &&\n                 *                   baz;\n                 */\n\n                const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n\n                offsets.ignoreToken(operator);\n                offsets.ignoreToken(tokenAfterOperator);\n                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n            },\n\n            \"BlockStatement, ClassBody\"(node) {\n                let blockIndentLevel;\n\n                if (node.parent && isOuterIIFE(node.parent)) {\n                    blockIndentLevel = options.outerIIFEBody;\n                } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n                    blockIndentLevel = options.FunctionExpression.body;\n                } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n                    blockIndentLevel = options.FunctionDeclaration.body;\n                } else {\n                    blockIndentLevel = 1;\n                }\n\n                /*\n                 * For blocks that aren't lone statements, ensure that the opening curly brace\n                 * is aligned with the parent.\n                 */\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n                }\n\n                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n            },\n\n            CallExpression: addFunctionCallIndent,\n\n            \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n                const classToken = sourceCode.getFirstToken(node);\n                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n\n                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n            },\n\n            ConditionalExpression(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // `flatTernaryExpressions` option is for the following style:\n                // var a =\n                //     foo > 0 ? bar :\n                //     foo < 0 ? baz :\n                //     /*else*/ qiz ;\n                if (!options.flatTernaryExpressions ||\n                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||\n                    isOnFirstLineOfStatement(firstToken, node)\n                ) {\n                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n\n                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n\n                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n                    offsets.setDesiredOffset(colonToken, firstToken, 1);\n\n                    offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === \"Punctuator\" &&\n                        options.offsetTernaryExpressions ? 2 : 1);\n\n                    /*\n                     * The alternate and the consequent should usually have the same indentation.\n                     * If they share part of a line, align the alternate against the first token of the consequent.\n                     * This allows the alternate to be indented correctly in cases like this:\n                     * foo ? (\n                     *   bar\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\n                     * )\n                     */\n                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n                    } else {\n\n                        /**\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\n                         * token of the conditional expression. For example:\n                         * foo ? bar\n                         *   : baz\n                         *\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n                         * having no expected indentation.\n                         */\n                        offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === \"Punctuator\" &&\n                            options.offsetTernaryExpressions ? 2 : 1);\n                    }\n                }\n            },\n\n            \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement\": node => addBlocklessNodeIndent(node.body),\n\n            ExportNamedDeclaration(node) {\n                if (node.declaration === null) {\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    // Indent the specifiers in `export {foo, bar, baz}`\n                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);\n\n                    if (node.source) {\n\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n                    }\n                }\n            },\n\n            ForStatement(node) {\n                const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n                if (node.init) {\n                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n                }\n                if (node.test) {\n                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n                }\n                if (node.update) {\n                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n                }\n                addBlocklessNodeIndent(node.body);\n            },\n\n            \"FunctionDeclaration, FunctionExpression\"(node) {\n                const closingParen = sourceCode.getTokenBefore(node.body);\n                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n            },\n\n            IfStatement(node) {\n                addBlocklessNodeIndent(node.consequent);\n                if (node.alternate) {\n                    addBlocklessNodeIndent(node.alternate);\n                }\n            },\n\n            /*\n             * For blockless nodes with semicolon-first style, don't indent the semicolon.\n             * e.g.\n             * if (foo)\n             *     bar()\n             * ; [1, 2, 3].map(foo)\n             *\n             * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.\n             */\n            \":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit\"(node) {\n                let nodesToCheck;\n\n                if (node.type === \"IfStatement\") {\n                    nodesToCheck = [node.consequent];\n                    if (node.alternate) {\n                        nodesToCheck.push(node.alternate);\n                    }\n                } else {\n                    nodesToCheck = [node.body];\n                }\n\n                for (const nodeToCheck of nodesToCheck) {\n                    const lastToken = sourceCode.getLastToken(nodeToCheck);\n\n                    if (astUtils.isSemicolonToken(lastToken)) {\n                        const tokenBeforeLast = sourceCode.getTokenBefore(lastToken);\n                        const tokenAfterLast = sourceCode.getTokenAfter(lastToken);\n\n                        // override indentation of `;` only if its line looks like a semicolon-first style line\n                        if (\n                            !astUtils.isTokenOnSameLine(tokenBeforeLast, lastToken) &&\n                            tokenAfterLast &&\n                            astUtils.isTokenOnSameLine(lastToken, tokenAfterLast)\n                        ) {\n                            offsets.setDesiredOffset(\n                                lastToken,\n                                sourceCode.getFirstToken(node),\n                                0\n                            );\n                        }\n                    }\n                }\n            },\n\n            ImportDeclaration(node) {\n                if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n\n                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n                }\n\n                const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n                const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n                const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n\n                if (fromToken) {\n                    const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n\n                    offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n                }\n            },\n\n            ImportExpression(node) {\n                const openingParen = sourceCode.getFirstToken(node, 1);\n                const closingParen = sourceCode.getLastToken(node);\n\n                parameterParens.add(openingParen);\n                parameterParens.add(closingParen);\n                offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n\n                addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\n            },\n\n            \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n                const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n\n                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;\n                const firstObjectToken = objectParenCount\n                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })\n                    : sourceCode.getFirstToken(object);\n                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n                if (node.computed) {\n\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n                }\n\n                /*\n                 * If the object ends on the same line that the property starts, match against the last token\n                 * of the object, to ensure that the MemberExpression is not indented.\n                 *\n                 * Otherwise, match against the first token of the object, e.g.\n                 * foo\n                 *   .bar\n                 *   .baz // <-- offset by 1 from `foo`\n                 */\n                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line\n                    ? lastObjectToken\n                    : firstObjectToken;\n\n                if (typeof options.MemberExpression === \"number\") {\n\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n\n                    /*\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\n                     * Otherwise, match the first token of the property against the object.\n                     */\n                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n                } else {\n\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\n                    offsets.ignoreToken(firstNonObjectToken);\n                    offsets.ignoreToken(secondNonObjectToken);\n\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n                }\n            },\n\n            NewExpression(node) {\n\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n                if (node.arguments.length > 0 ||\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node)) &&\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n                    addFunctionCallIndent(node);\n                }\n            },\n\n            Property(node) {\n                if (!node.shorthand && !node.method && node.kind === \"init\") {\n                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n\n                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n                }\n            },\n\n            PropertyDefinition(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const maybeSemicolonToken = sourceCode.getLastToken(node);\n                let keyLastToken;\n\n                // Indent key.\n                if (node.computed) {\n                    const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);\n                    const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);\n                    const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];\n\n                    if (bracketTokenL !== firstToken) {\n                        offsets.setDesiredOffset(bracketTokenL, firstToken, 0);\n                    }\n                    offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);\n                    offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);\n                } else {\n                    const idToken = keyLastToken = sourceCode.getFirstToken(node.key);\n\n                    if (idToken !== firstToken) {\n                        offsets.setDesiredOffset(idToken, firstToken, 1);\n                    }\n                }\n\n                // Indent initializer.\n                if (node.value) {\n                    const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);\n                    const valueToken = sourceCode.getTokenAfter(eqToken);\n\n                    offsets.setDesiredOffset(eqToken, keyLastToken, 1);\n                    offsets.setDesiredOffset(valueToken, eqToken, 1);\n                    if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n                        offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);\n                    }\n                } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n                    offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);\n                }\n            },\n\n            StaticBlock(node) {\n                const openingCurly = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\n                const closingCurly = sourceCode.getLastToken(node);\n\n                addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);\n            },\n\n            SwitchStatement(node) {\n                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n                if (node.cases.length) {\n                    sourceCode.getTokensBetween(\n                        node.cases.at(-1),\n                        closingCurly,\n                        { includeComments: true, filter: astUtils.isCommentToken }\n                    ).forEach(token => offsets.ignoreToken(token));\n                }\n            },\n\n            SwitchCase(node) {\n                if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n                    const caseKeyword = sourceCode.getFirstToken(node);\n                    const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n\n                    offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n                }\n            },\n\n            TemplateLiteral(node) {\n                node.expressions.forEach((expression, index) => {\n                    const previousQuasi = node.quasis[index];\n                    const nextQuasi = node.quasis[index + 1];\n                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line\n                        ? sourceCode.getFirstToken(previousQuasi)\n                        : null;\n\n                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n                });\n            },\n\n            VariableDeclaration(node) {\n                let variableIndent = Object.hasOwn(options.VariableDeclarator, node.kind)\n                    ? options.VariableDeclarator[node.kind]\n                    : DEFAULT_VARIABLE_INDENT;\n\n                const firstToken = sourceCode.getFirstToken(node),\n                    lastToken = sourceCode.getLastToken(node);\n\n                if (options.VariableDeclarator[node.kind] === \"first\") {\n                    if (node.declarations.length > 1) {\n                        addElementListIndent(\n                            node.declarations,\n                            firstToken,\n                            lastToken,\n                            \"first\"\n                        );\n                        return;\n                    }\n\n                    variableIndent = DEFAULT_VARIABLE_INDENT;\n                }\n\n                if (node.declarations.at(-1).loc.start.line > node.loc.start.line) {\n\n                    /*\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n                     * the following indentations are correct:\n                     *\n                     * var foo = {\n                     *   ok: true\n                     * };\n                     *\n                     * var foo = {\n                     *     ok: true,\n                     *   },\n                     *   bar = 1;\n                     *\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\n                     * on the same line as the start of the declaration, provided that there are declarators that\n                     * follow this one.\n                     */\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n                } else {\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n                }\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    offsets.ignoreToken(lastToken);\n                }\n            },\n\n            VariableDeclarator(node) {\n                if (node.init) {\n                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n\n                    offsets.ignoreToken(equalOperator);\n                    offsets.ignoreToken(tokenAfterOperator);\n                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n                }\n            },\n\n            \"JSXAttribute[value]\"(node) {\n                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n\n                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n            },\n\n            JSXElement(node) {\n                if (node.closingElement) {\n                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n                }\n            },\n\n            JSXOpeningElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                let closingToken;\n\n                if (node.selfClosing) {\n                    closingToken = sourceCode.getLastToken(node, { skip: 1 });\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n                } else {\n                    closingToken = sourceCode.getLastToken(node);\n                }\n                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n                addElementListIndent(node.attributes, firstToken, closingToken, 1);\n            },\n\n            JSXClosingElement(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n            },\n\n            JSXFragment(node) {\n                const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\n                const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\n\n                addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\n            },\n\n            JSXOpeningFragment(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const closingToken = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\n                offsets.matchOffsetOf(firstToken, closingToken);\n            },\n\n            JSXClosingFragment(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n                const slashToken = sourceCode.getLastToken(node, { skip: 1 });\n                const closingToken = sourceCode.getLastToken(node);\n                const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\n\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\n                offsets.matchOffsetOf(firstToken, tokenToMatch);\n            },\n\n            JSXExpressionContainer(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            JSXSpreadAttribute(node) {\n                const openingCurly = sourceCode.getFirstToken(node);\n                const closingCurly = sourceCode.getLastToken(node);\n\n                offsets.setDesiredOffsets(\n                    [openingCurly.range[1], closingCurly.range[0]],\n                    openingCurly,\n                    1\n                );\n            },\n\n            \"*\"(node) {\n                const firstToken = sourceCode.getFirstToken(node);\n\n                // Ensure that the children of every node are indented at least as much as the first token.\n                if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n                    offsets.setDesiredOffsets(node.range, firstToken, 0);\n                }\n            }\n        };\n\n        const listenerCallQueue = [];\n\n        /*\n         * To ignore the indentation of a node:\n         * 1. Don't call the node's listener when entering it (if it has a listener)\n         * 2. Don't set any offsets against the first token of the node.\n         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\n         */\n        const offsetListeners = {};\n\n        for (const [selector, listener] of Object.entries(baseOffsetListeners)) {\n\n            /*\n             * Offset listener calls are deferred until traversal is finished, and are called as\n             * part of the final `Program:exit` listener. This is necessary because a node might\n             * be matched by multiple selectors.\n             *\n             * Example: Suppose there is an offset listener for `Identifier`, and the user has\n             * specified in configuration that `MemberExpression > Identifier` should be ignored.\n             * Due to selector specificity rules, the `Identifier` listener will get called first. However,\n             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\n             * should not have been called at all. Without doing extra selector matching, we don't know\n             * whether the Identifier matches the `MemberExpression > Identifier` selector until the\n             * `MemberExpression > Identifier` listener is called.\n             *\n             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\n             * ignored nodes are known.\n             */\n            offsetListeners[selector] = node => listenerCallQueue.push({ listener, node });\n        }\n\n        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n        const ignoredNodes = new Set();\n\n        /**\n         * Ignores a node\n         * @param {ASTNode} node The node to ignore\n         * @returns {void}\n         */\n        function addToIgnoredNodes(node) {\n            ignoredNodes.add(node);\n            ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n        }\n\n        const ignoredNodeListeners = options.ignoredNodes.reduce(\n            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),\n            {}\n        );\n\n        /*\n         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\n         * at the end.\n         *\n         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\n         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\n         * so those listeners wouldn't be called anyway.\n         */\n        return Object.assign(\n            offsetListeners,\n            ignoredNodeListeners,\n            {\n                \"*:exit\"(node) {\n\n                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n                    if (!KNOWN_NODES.has(node.type)) {\n                        addToIgnoredNodes(node);\n                    }\n                },\n                \"Program:exit\"() {\n\n                    // If ignoreComments option is enabled, ignore all comment tokens.\n                    if (options.ignoreComments) {\n                        sourceCode.getAllComments()\n                            .forEach(comment => offsets.ignoreToken(comment));\n                    }\n\n                    // Invoke the queued offset listeners for the nodes that aren't ignored.\n                    for (let i = 0; i < listenerCallQueue.length; i++) {\n                        const nodeInfo = listenerCallQueue[i];\n\n                        if (!ignoredNodes.has(nodeInfo.node)) {\n                            nodeInfo.listener(nodeInfo.node);\n                        }\n                    }\n\n                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n                    ignoredNodes.forEach(ignoreNode);\n\n                    addParensIndent(sourceCode.ast.tokens);\n\n                    /*\n                     * Create a Map from (tokenOrComment) => (precedingToken).\n                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n                     */\n                    const precedingTokens = new WeakMap();\n\n                    for (let i = 0; i < sourceCode.ast.comments.length; i++) {\n                        const comment = sourceCode.ast.comments[i];\n\n                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n                        const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;\n\n                        precedingTokens.set(comment, hasToken);\n                    }\n\n                    for (let i = 1; i < sourceCode.lines.length + 1; i++) {\n\n                        if (!tokenInfo.firstTokensByLineNumber.has(i)) {\n\n                            // Don't check indentation on blank lines\n                            continue;\n                        }\n\n                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i);\n\n                        if (firstTokenOfLine.loc.start.line !== i) {\n\n                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n                            continue;\n                        }\n\n                        if (astUtils.isCommentToken(firstTokenOfLine)) {\n                            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n                            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n                            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n\n                            /*\n                             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.\n                             *\n                             * let foo\n                             * // comment\n                             * ;(async () => {})()\n                             */\n                            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\n                                offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\n                            }\n\n                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n                            if (\n                                mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||\n                                mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))\n                            ) {\n                                continue;\n                            }\n                        }\n\n                        // If the token matches the expected indentation, don't report it.\n                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n                            continue;\n                        }\n\n                        // Otherwise, report the token/comment.\n                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n                    }\n                }\n            }\n        );\n    }\n};\n"
        }
    ]
}