{
    "sourceFile": "node_modules/eslint/lib/rules/no-extra-boolean-cast.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892225551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"@eslint-community/eslint-utils\");\n\nconst precedence = astUtils.getPrecedence;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{}],\n\n        docs: {\n            description: \"Disallow unnecessary boolean casts\",\n            recommended: true,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-boolean-cast\"\n        },\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        enforceForInnerExpressions: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n\n                // deprecated\n                {\n                    type: \"object\",\n                    properties: {\n                        enforceForLogicalOperands: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedCall: \"Redundant Boolean call.\",\n            unexpectedNegation: \"Redundant double negation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const [{ enforceForLogicalOperands, enforceForInnerExpressions }] = context.options;\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = new Set([\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ]);\n\n        /**\n         * Check if a node is a Boolean function or constructor.\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is Boolean function or constructor\n         */\n        function isBooleanFunctionOrConstructorCall(node) {\n\n            // Boolean(<bool>) and new Boolean(<bool>)\n            return (node.type === \"CallExpression\" || node.type === \"NewExpression\") &&\n                    node.callee.type === \"Identifier\" &&\n                        node.callee.name === \"Boolean\";\n        }\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         * @param {ASTNode} node The node\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node) {\n            return (\n                (isBooleanFunctionOrConstructorCall(node.parent) &&\n                node === node.parent.arguments[0]) ||\n\n                (BOOLEAN_NODE_TYPES.has(node.parent.type) &&\n                    node === node.parent.test) ||\n\n                // !<bool>\n                (node.parent.type === \"UnaryExpression\" &&\n                    node.parent.operator === \"!\")\n            );\n        }\n\n        /**\n         * Checks whether the node is a context that should report an error\n         * Acts recursively if it is in a logical context\n         * @param {ASTNode} node the node\n         * @returns {boolean} If the node is in one of the flagged contexts\n         */\n        function isInFlaggedContext(node) {\n            if (node.parent.type === \"ChainExpression\") {\n                return isInFlaggedContext(node.parent);\n            }\n\n            /*\n             * legacy behavior - enforceForLogicalOperands will only recurse on\n             * logical expressions, not on other contexts.\n             * enforceForInnerExpressions will recurse on logical expressions\n             * as well as the other recursive syntaxes.\n             */\n\n            if (enforceForLogicalOperands || enforceForInnerExpressions) {\n                if (node.parent.type === \"LogicalExpression\") {\n                    if (node.parent.operator === \"||\" || node.parent.operator === \"&&\") {\n                        return isInFlaggedContext(node.parent);\n                    }\n\n                    // Check the right hand side of a `??` operator.\n                    if (enforceForInnerExpressions &&\n                        node.parent.operator === \"??\" &&\n                        node.parent.right === node\n                    ) {\n                        return isInFlaggedContext(node.parent);\n                    }\n                }\n            }\n\n            if (enforceForInnerExpressions) {\n                if (\n                    node.parent.type === \"ConditionalExpression\" &&\n                    (node.parent.consequent === node || node.parent.alternate === node)\n                ) {\n                    return isInFlaggedContext(node.parent);\n                }\n\n                /*\n                 * Check last expression only in a sequence, i.e. if ((1, 2, Boolean(3))) {}, since\n                 * the others don't affect the result of the expression.\n                 */\n                if (\n                    node.parent.type === \"SequenceExpression\" &&\n                    node.parent.expressions.at(-1) === node\n                ) {\n                    return isInFlaggedContext(node.parent);\n                }\n\n            }\n\n            return isInBooleanContext(node);\n        }\n\n\n        /**\n         * Check if a node has comments inside.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if it has comments inside.\n         */\n        function hasCommentsInside(node) {\n            return Boolean(sourceCode.getCommentsInside(node).length);\n        }\n\n        /**\n         * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is parenthesized.\n         * @private\n         */\n        function isParenthesized(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Determines whether the given node needs to be parenthesized when replacing the previous node.\n         * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\n         * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\n         * @param {ASTNode} previousNode Previous node.\n         * @param {ASTNode} node The node to check.\n         * @throws {Error} (Unreachable.)\n         * @returns {boolean} `true` if the node needs to be parenthesized.\n         */\n        function needsParens(previousNode, node) {\n            if (previousNode.parent.type === \"ChainExpression\") {\n                return needsParens(previousNode.parent, node);\n            }\n\n            if (isParenthesized(previousNode)) {\n\n                // parentheses around the previous node will stay, so there is no need for an additional pair\n                return false;\n            }\n\n            // parent of the previous node will become parent of the replacement node\n            const parent = previousNode.parent;\n\n            switch (parent.type) {\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.type === \"SequenceExpression\";\n                case \"IfStatement\":\n                case \"DoWhileStatement\":\n                case \"WhileStatement\":\n                case \"ForStatement\":\n                case \"SequenceExpression\":\n                    return false;\n                case \"ConditionalExpression\":\n                    if (previousNode === parent.test) {\n                        return precedence(node) <= precedence(parent);\n                    }\n                    if (previousNode === parent.consequent || previousNode === parent.alternate) {\n                        return precedence(node) < precedence({ type: \"AssignmentExpression\" });\n                    }\n\n                    /* c8 ignore next */\n                    throw new Error(\"Ternary child must be test, consequent, or alternate.\");\n                case \"UnaryExpression\":\n                    return precedence(node) < precedence(parent);\n                case \"LogicalExpression\":\n                    if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n                        return true;\n                    }\n                    if (previousNode === parent.left) {\n                        return precedence(node) < precedence(parent);\n                    }\n                    return precedence(node) <= precedence(parent);\n\n                /* c8 ignore next */\n                default:\n                    throw new Error(`Unexpected parent type: ${parent.type}`);\n            }\n        }\n\n        return {\n            UnaryExpression(node) {\n                const parent = node.parent;\n\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                          parent.type !== \"UnaryExpression\" ||\n                          parent.operator !== \"!\") {\n                    return;\n                }\n\n\n                if (isInFlaggedContext(parent)) {\n                    context.report({\n                        node: parent,\n                        messageId: \"unexpectedNegation\",\n                        fix(fixer) {\n                            if (hasCommentsInside(parent)) {\n                                return null;\n                            }\n\n                            if (needsParens(parent, node.argument)) {\n                                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n                            }\n\n                            let prefix = \"\";\n                            const tokenBefore = sourceCode.getTokenBefore(parent);\n                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === parent.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n                        }\n                    });\n                }\n            },\n\n            CallExpression(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInFlaggedContext(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedCall\",\n                        fix(fixer) {\n                            const parent = node.parent;\n\n                            if (node.arguments.length === 0) {\n                                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n\n                                    /*\n                                     * !Boolean() -> true\n                                     */\n\n                                    if (hasCommentsInside(parent)) {\n                                        return null;\n                                    }\n\n                                    const replacement = \"true\";\n                                    let prefix = \"\";\n                                    const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                                    if (\n                                        tokenBefore &&\n                                        tokenBefore.range[1] === parent.range[0] &&\n                                        !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                                    ) {\n                                        prefix = \" \";\n                                    }\n\n                                    return fixer.replaceText(parent, prefix + replacement);\n                                }\n\n                                /*\n                                 * Boolean() -> false\n                                 */\n\n                                if (hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, \"false\");\n                            }\n\n                            if (node.arguments.length === 1) {\n                                const argument = node.arguments[0];\n\n                                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                                    return null;\n                                }\n\n                                /*\n                                 * Boolean(expression) -> expression\n                                 */\n\n                                if (needsParens(node, argument)) {\n                                    return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                                }\n\n                                return fixer.replaceText(node, sourceCode.getText(argument));\n                            }\n\n                            // two or more arguments\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}