{
    "sourceFile": "node_modules/eslint/lib/rules/id-match.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892216666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"^.+$\", {\n            classFields: false,\n            ignoreDestructuring: false,\n            onlyDeclarations: false,\n            properties: false\n        }],\n\n        docs: {\n            description: \"Require identifiers to match a specified regular expression\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/id-match\"\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\"\n                    },\n                    classFields: {\n                        type: \"boolean\"\n                    },\n                    onlyDeclarations: {\n                        type: \"boolean\"\n                    },\n                    ignoreDestructuring: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\",\n            notMatchPrivate: \"Identifier '#{{name}}' does not match the pattern '{{pattern}}'.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Options\n        //--------------------------------------------------------------------------\n        const [pattern, {\n            classFields: checkClassFields,\n            ignoreDestructuring,\n            onlyDeclarations,\n            properties: checkProperties\n        }] = context.options;\n        const regexp = new RegExp(pattern, \"u\");\n\n        const sourceCode = context.sourceCode;\n        let globalScope;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reportedNodes = new Set();\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n        const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n        const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Checks if a parent of a node is an ObjectPattern.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} if the node is inside an ObjectPattern\n         * @private\n         */\n        function isInsideObjectPattern(node) {\n            let { parent } = node;\n\n            while (parent) {\n                if (parent.type === \"ObjectPattern\") {\n                    return true;\n                }\n\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) &&\n                !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n\n            /*\n             * We used the range instead of the node because it's possible\n             * for the same identifier to be represented by two different\n             * nodes, with the most clear example being shorthand properties:\n             * { foo }\n             * In this case, \"foo\" is represented by one node for the name\n             * and one for the value. The only way to know they are the same\n             * is to look at the range.\n             */\n            if (!reportedNodes.has(node.range.toString())) {\n\n                const messageId = (node.type === \"PrivateIdentifier\")\n                    ? \"notMatchPrivate\" : \"notMatch\";\n\n                context.report({\n                    node,\n                    messageId,\n                    data: {\n                        name: node.name,\n                        pattern\n                    }\n                });\n                reportedNodes.add(node.range.toString());\n            }\n        }\n\n        return {\n\n            Program(node) {\n                globalScope = sourceCode.getScope(node);\n            },\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (isReferenceToGlobalVariable(node) || astUtils.isImportAttributeKey(node)) {\n                    return;\n                }\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!checkProperties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions left side's assigned variable id\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                // For https://github.com/eslint/eslint/issues/15123\n                } else if (\n                    parent.type === \"Property\" &&\n                    parent.parent.type === \"ObjectExpression\" &&\n                    parent.key === node &&\n                    !parent.computed\n                ) {\n                    if (checkProperties && isInvalid(name)) {\n                        report(node);\n                    }\n\n                /*\n                 * Properties have their own rules, and\n                 * AssignmentPattern nodes can be treated like Properties:\n                 * e.g.: const { no_camelcased = false } = bar;\n                 */\n                } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n\n                    if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n                        if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name)) {\n                            report(node);\n                        }\n\n                        const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\n\n                        // prevent checking righthand side of destructured object\n                        if (!assignmentKeyEqualsValue && parent.key === node) {\n                            return;\n                        }\n\n                        const valueIsInvalid = parent.value.name && isInvalid(name);\n\n                        // ignore destructuring if the option is set, unless a new identifier is created\n                        if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n                            report(node);\n                        }\n                    }\n\n                    // never check properties or always ignore destructuring\n                    if ((!checkProperties && !parent.computed) || (ignoreDestructuring && isInsideObjectPattern(node))) {\n                        return;\n                    }\n\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n                    if (parent.right !== node && shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if (IMPORT_TYPES.has(parent.type)) {\n\n                    // Report only if the local imported identifier is invalid\n                    if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n                        report(node);\n                    }\n\n                } else if (parent.type === \"PropertyDefinition\") {\n\n                    if (checkClassFields && isInvalid(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is invalid that isn't a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            },\n\n            \"PrivateIdentifier\"(node) {\n\n                const isClassField = node.parent.type === \"PropertyDefinition\";\n\n                if (isClassField && !checkClassFields) {\n                    return;\n                }\n\n                if (isInvalid(node.name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"
        }
    ]
}