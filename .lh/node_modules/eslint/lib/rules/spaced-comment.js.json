{
    "sourceFile": "node_modules/eslint/lib/rules/spaced-comment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    return `(?:${escapeRegExp(s)})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n\n    // `*` is a marker for JSDoc comments.\n    if (!markers.includes(\"*\")) {\n        return markers.concat(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n * @param {string[]} markers A marker list.\n * @param {string[]} exceptions An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern, \"u\");\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n * @param {string[]} markers A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern, \"u\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"spaced-comment\",\n                        url: \"https://eslint.style/rules/js/spaced-comment\"\n                    }\n                }\n            ]\n        },\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce consistent spacing after the `//` or `/*` in a comment\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/spaced-comment\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\",\n                                default: false\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n            expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n            unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n            unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n            expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n            expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n                hasExceptions: exceptions.length > 0,\n                captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n                markers: new Set(markers)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {Array} match An array of match results for markers.\n         * @param {string} refChar Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, messageId, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                messageId,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node A comment node to check.\n         * @param {string} messageId An error message to report.\n         * @param {string} match An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, messageId, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n                    }\n                    const end = node.range[1] - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                messageId\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments and comments that consist only of a marker.\n            if (node.value.length === 0 || rule.markers.has(node.value)) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.captureMarker.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"expectedSpaceBefore\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n                }\n            }\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n            }\n        };\n    }\n};\n"
        }
    ]
}