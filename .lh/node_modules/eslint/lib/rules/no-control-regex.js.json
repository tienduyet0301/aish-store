{
    "sourceFile": "node_modules/eslint/lib/rules/no-control-regex.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892221577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to forbid control characters from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst RegExpValidator = require(\"@eslint-community/regexpp\").RegExpValidator;\nconst collector = new (class {\n    constructor() {\n        this._source = \"\";\n        this._controlChars = [];\n        this._validator = new RegExpValidator(this);\n    }\n\n    onPatternEnter() {\n\n        /*\n         * `RegExpValidator` may parse the pattern twice in one `validatePattern`.\n         * So `this._controlChars` should be cleared here as well.\n         *\n         * For example, the `/(?<a>\\x1f)/` regex will parse the pattern twice.\n         * This is based on the content described in Annex B.\n         * If the regex contains a `GroupName` and the `u` flag is not used, `ParseText` will be called twice.\n         * See https://tc39.es/ecma262/2023/multipage/additional-ecmascript-features-for-web-browsers.html#sec-parsepattern-annexb\n         */\n        this._controlChars = [];\n    }\n\n    onCharacter(start, end, cp) {\n        if (cp >= 0x00 &&\n            cp <= 0x1F &&\n            (\n                this._source.codePointAt(start) === cp ||\n                this._source.slice(start, end).startsWith(\"\\\\x\") ||\n                this._source.slice(start, end).startsWith(\"\\\\u\")\n            )\n        ) {\n            this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n        }\n    }\n\n    collectControlChars(regexpStr, flags) {\n        const uFlag = typeof flags === \"string\" && flags.includes(\"u\");\n        const vFlag = typeof flags === \"string\" && flags.includes(\"v\");\n\n        this._controlChars = [];\n        this._source = regexpStr;\n\n        try {\n            this._validator.validatePattern(regexpStr, void 0, void 0, { unicode: uFlag, unicodeSets: vFlag }); // Call onCharacter hook\n        } catch {\n\n            // Ignore syntax errors in RegExp.\n        }\n        return this._controlChars;\n    }\n})();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow control characters in regular expressions\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-control-regex\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node `Literal` node to evaluate\n         * @returns {{ pattern: string, flags: string | null } | null} Regex if found (the given node is either a regex literal\n         * or a string literal that is the pattern argument of a RegExp constructor call). Otherwise `null`. If flags cannot be determined,\n         * the `flags` property will be `null`.\n         * @private\n         */\n        function getRegExp(node) {\n            if (node.regex) {\n                return node.regex;\n            }\n            if (typeof node.value === \"string\" &&\n                (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") &&\n                node.parent.callee.type === \"Identifier\" &&\n                node.parent.callee.name === \"RegExp\" &&\n                node.parent.arguments[0] === node\n            ) {\n                const pattern = node.value;\n                const flags =\n                    node.parent.arguments.length > 1 &&\n                    node.parent.arguments[1].type === \"Literal\" &&\n                    typeof node.parent.arguments[1].value === \"string\"\n                        ? node.parent.arguments[1].value\n                        : null;\n\n                return { pattern, flags };\n            }\n\n            return null;\n        }\n\n        return {\n            Literal(node) {\n                const regExp = getRegExp(node);\n\n                if (regExp) {\n                    const { pattern, flags } = regExp;\n                    const controlCharacters = collector.collectControlChars(pattern, flags);\n\n                    if (controlCharacters.length > 0) {\n                        context.report({\n                            node,\n                            messageId: \"unexpected\",\n                            data: {\n                                controlChars: controlCharacters.join(\", \")\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}