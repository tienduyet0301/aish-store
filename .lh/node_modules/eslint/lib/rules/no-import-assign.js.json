{
    "sourceFile": "node_modules/eslint/lib/rules/no-import-assign.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag updates of imported bindings.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst WellKnownMutationFunctions = {\n    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n\n/**\n * Check if a given node is LHS of an assignment node.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is LHS.\n */\nfunction isAssignmentLeft(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // Destructuring assignments\n        parent.type === \"ArrayPattern\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is the operand of mutation unary operator.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\n */\nfunction isOperandOfMutationUnaryOperator(node) {\n    const argumentNode = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n    const { parent } = argumentNode;\n\n    return (\n        (\n            parent.type === \"UpdateExpression\" &&\n            parent.argument === argumentNode\n        ) ||\n        (\n            parent.type === \"UnaryExpression\" &&\n            parent.operator === \"delete\" &&\n            parent.argument === argumentNode\n        )\n    );\n}\n\n/**\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is the iteration variable.\n */\nfunction isIterationVariable(node) {\n    const { parent } = node;\n\n    return (\n        (\n            parent.type === \"ForInStatement\" &&\n            parent.left === node\n        ) ||\n        (\n            parent.type === \"ForOfStatement\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Check if a given node is at the first argument of a well-known mutation function.\n * - `Object.assign`\n * - `Object.defineProperty`\n * - `Object.defineProperties`\n * - `Object.freeze`\n * - `Object.setPrototypeOf`\n * - `Reflect.defineProperty`\n * - `Reflect.deleteProperty`\n * - `Reflect.set`\n * - `Reflect.setPrototypeOf`\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\n */\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n    const { parent } = node;\n\n    if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n        return false;\n    }\n    const callee = astUtils.skipChainExpression(parent.callee);\n\n    if (\n        !astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) &&\n        !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)\n    ) {\n        return false;\n    }\n    const variable = findVariable(scope, callee.object);\n\n    return variable !== null && variable.scope.type === \"global\";\n}\n\n/**\n * Check if the identifier node is placed at to update members.\n * @param {ASTNode} id The Identifier node to check.\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\n * @returns {boolean} `true` if the member of `id` was updated.\n */\nfunction isMemberWrite(id, scope) {\n    const { parent } = id;\n\n    return (\n        (\n            parent.type === \"MemberExpression\" &&\n            parent.object === id &&\n            (\n                isAssignmentLeft(parent) ||\n                isOperandOfMutationUnaryOperator(parent) ||\n                isIterationVariable(parent)\n            )\n        ) ||\n        isArgumentOfWellKnownMutationFunction(id, scope)\n    );\n}\n\n/**\n * Get the mutation node.\n * @param {ASTNode} id The Identifier node to get.\n * @returns {ASTNode} The mutation node.\n */\nfunction getWriteNode(id) {\n    let node = id.parent;\n\n    while (\n        node &&\n        node.type !== \"AssignmentExpression\" &&\n        node.type !== \"UpdateExpression\" &&\n        node.type !== \"UnaryExpression\" &&\n        node.type !== \"CallExpression\" &&\n        node.type !== \"ForInStatement\" &&\n        node.type !== \"ForOfStatement\"\n    ) {\n        node = node.parent;\n    }\n\n    return node || id;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow assigning to imported bindings\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-import-assign\"\n        },\n\n        schema: [],\n\n        messages: {\n            readonly: \"'{{name}}' is read-only.\",\n            readonlyMember: \"The members of '{{name}}' are read-only.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        return {\n            ImportDeclaration(node) {\n                const scope = sourceCode.getScope(node);\n\n                for (const variable of sourceCode.getDeclaredVariables(node)) {\n                    const shouldCheckMembers = variable.defs.some(\n                        d => d.node.type === \"ImportNamespaceSpecifier\"\n                    );\n                    let prevIdNode = null;\n\n                    for (const reference of variable.references) {\n                        const idNode = reference.identifier;\n\n                        /*\n                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\n                         * references for the same identifier. This should skip\n                         * the one of the two in order to prevent redundant reports.\n                         */\n                        if (idNode === prevIdNode) {\n                            continue;\n                        }\n                        prevIdNode = idNode;\n\n                        if (reference.isWrite()) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonly\",\n                                data: { name: idNode.name }\n                            });\n                        } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n                            context.report({\n                                node: getWriteNode(idNode),\n                                messageId: \"readonlyMember\",\n                                data: { name: idNode.name }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}