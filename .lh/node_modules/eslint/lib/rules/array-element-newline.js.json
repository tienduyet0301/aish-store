{
    "sourceFile": "node_modules/eslint/lib/rules/array-element-newline.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213720,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce line breaks after each array element\n * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"array-element-newline\",\n                        url: \"https://eslint.style/rules/js/array-element-newline\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce line breaks after each array element\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/array-element-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: {\n            definitions: {\n                basicConfig: {\n                    oneOf: [\n                        {\n                            enum: [\"always\", \"never\", \"consistent\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                multiline: {\n                                    type: \"boolean\"\n                                },\n                                minItems: {\n                                    type: [\"integer\", \"null\"],\n                                    minimum: 0\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/basicConfig\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ArrayExpression: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                },\n                                ArrayPattern: {\n                                    $ref: \"#/definitions/basicConfig\"\n                                }\n                            },\n                            additionalProperties: false,\n                            minProperties: 1\n                        }\n                    ]\n                }\n            ]\n        },\n\n        messages: {\n            unexpectedLineBreak: \"There should be no linebreak here.\",\n            missingLineBreak: \"There should be a linebreak after this element.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} providedOption An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(providedOption) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            const option = providedOption || \"always\";\n\n            if (!option || option === \"always\" || option.minItems === 0) {\n                minItems = 0;\n            } else if (option === \"never\") {\n                minItems = Number.POSITIVE_INFINITY;\n            } else if (option === \"consistent\") {\n                consistent = true;\n                minItems = Number.POSITIVE_INFINITY;\n            } else {\n                multiline = Boolean(option.multiline);\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            if (options && (options.ArrayExpression || options.ArrayPattern)) {\n                let expressionOptions, patternOptions;\n\n                if (options.ArrayExpression) {\n                    expressionOptions = normalizeOptionValue(options.ArrayExpression);\n                }\n\n                if (options.ArrayPattern) {\n                    patternOptions = normalizeOptionValue(options.ArrayPattern);\n                }\n\n                return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions };\n            }\n\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    /*\n                     * This will check if the comma is on the same line as the next element\n                     * Following array:\n                     * [\n                     *     1\n                     *     , 2\n                     *     , 3\n                     * ]\n                     *\n                     * will be fixed to:\n                     * [\n                     *     1, 2, 3\n                     * ]\n                     */\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a line break after the first token\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"missingLineBreak\",\n                fix(fixer) {\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n\n            if (!options) {\n                return;\n            }\n\n            let elementBreak = false;\n\n            /*\n             * MULTILINE: true\n             * loop through every element and check\n             * if at least one element has linebreaks inside\n             * this ensures that following is not valid (due to elements are on the same line):\n             *\n             * [\n             *      1,\n             *      2,\n             *      3\n             * ]\n             */\n            if (options.multiline) {\n                elementBreak = elements\n                    .filter(element => element !== null)\n                    .some(element => element.loc.start.line !== element.loc.end.line);\n            }\n\n            let linebreaksCount = 0;\n\n            for (let i = 0; i < node.elements.length; i++) {\n                const element = node.elements[i];\n\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    continue;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                    linebreaksCount++;\n                }\n            }\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elementBreak\n                ) ||\n                (\n                    options.consistent &&\n                    linebreaksCount > 0 &&\n                    linebreaksCount < node.elements.length\n                )\n            );\n\n            elements.forEach((element, i) => {\n                const previousElement = elements[i - 1];\n\n                if (i === 0 || element === null || previousElement === null) {\n                    return;\n                }\n\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n                if (needsLinebreaks) {\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\n                    }\n                } else {\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n                        reportNoLineBreak(firstTokenOfCurrentElement);\n                    }\n                }\n            });\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"
        }
    ]
}