{
    "sourceFile": "node_modules/eslint/lib/rules/no-useless-assignment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to disallow unnecessary assignments`.\n * @author Yosuke Ota\n */\n\n\"use strict\";\n\nconst { findVariable } = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"estree\").Node} ASTNode */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").Identifier} Identifier */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclarator */\n/** @typedef {import(\"estree\").AssignmentExpression} AssignmentExpression */\n/** @typedef {import(\"estree\").UpdateExpression} UpdateExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"eslint-scope\").Scope} Scope */\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n/** @typedef {import(\"../linter/code-path-analysis/code-path\")} CodePath */\n/** @typedef {import(\"../linter/code-path-analysis/code-path-segment\")} CodePathSegment */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Extract identifier from the given pattern node used on the left-hand side of the assignment.\n * @param {Pattern} pattern The pattern node to extract identifier\n * @returns {Iterable<Identifier>} The extracted identifier\n */\nfunction *extractIdentifiersFromPattern(pattern) {\n    switch (pattern.type) {\n        case \"Identifier\":\n            yield pattern;\n            return;\n        case \"ObjectPattern\":\n            for (const property of pattern.properties) {\n                yield* extractIdentifiersFromPattern(property.type === \"Property\" ? property.value : property);\n            }\n            return;\n        case \"ArrayPattern\":\n            for (const element of pattern.elements) {\n                if (!element) {\n                    continue;\n                }\n                yield* extractIdentifiersFromPattern(element);\n            }\n            return;\n        case \"RestElement\":\n            yield* extractIdentifiersFromPattern(pattern.argument);\n            return;\n        case \"AssignmentPattern\":\n            yield* extractIdentifiersFromPattern(pattern.left);\n\n        // no default\n    }\n}\n\n\n/**\n * Checks whether the given identifier node is evaluated after the assignment identifier.\n * @param {AssignmentInfo} assignment The assignment info.\n * @param {Identifier} identifier The identifier to check.\n * @returns {boolean} `true` if the given identifier node is evaluated after the assignment identifier.\n */\nfunction isIdentifierEvaluatedAfterAssignment(assignment, identifier) {\n    if (identifier.range[0] < assignment.identifier.range[1]) {\n        return false;\n    }\n    if (\n        assignment.expression &&\n        assignment.expression.range[0] <= identifier.range[0] &&\n        identifier.range[1] <= assignment.expression.range[1]\n    ) {\n\n        /*\n         * The identifier node is in an expression that is evaluated before the assignment.\n         * e.g. x = id;\n         *          ^^ identifier to check\n         *      ^      assignment identifier\n         */\n        return false;\n    }\n\n    /*\n     * e.g.\n     *      x = 42; id;\n     *              ^^ identifier to check\n     *      ^          assignment identifier\n     *      let { x, y = id } = obj;\n     *                   ^^  identifier to check\n     *            ^          assignment identifier\n     */\n    return true;\n}\n\n/**\n * Checks whether the given identifier node is used between the assigned identifier and the equal sign.\n *\n * e.g. let { x, y = x } = obj;\n *                   ^   identifier to check\n *            ^          assigned identifier\n * @param {AssignmentInfo} assignment The assignment info.\n * @param {Identifier} identifier The identifier to check.\n * @returns {boolean} `true` if the given identifier node is used between the assigned identifier and the equal sign.\n */\nfunction isIdentifierUsedBetweenAssignedAndEqualSign(assignment, identifier) {\n    if (!assignment.expression) {\n        return false;\n    }\n    return (\n        assignment.identifier.range[1] <= identifier.range[0] &&\n        identifier.range[1] <= assignment.expression.range[0]\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow variable assignments when the value is not used\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-assignment\"\n        },\n\n        schema: [],\n\n        messages: {\n            unnecessaryAssignment: \"This assigned value is not used in subsequent statements.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * @typedef {Object} ScopeStack\n         * @property {CodePath} codePath The code path of this scope stack.\n         * @property {Scope} scope The scope of this scope stack.\n         * @property {ScopeStack} upper The upper scope stack.\n         * @property {Record<string, ScopeStackSegmentInfo>} segments The map of ScopeStackSegmentInfo.\n         * @property {Set<CodePathSegment>} currentSegments The current CodePathSegments.\n         * @property {Map<Variable, AssignmentInfo[]>} assignments The map of list of AssignmentInfo for each variable.\n         */\n        /**\n         * @typedef {Object} ScopeStackSegmentInfo\n         * @property {CodePathSegment} segment The code path segment.\n         * @property {Identifier|null} first The first identifier that appears within the segment.\n         * @property {Identifier|null} last The last identifier that appears within the segment.\n         * `first` and `last` are used to determine whether an identifier exists within the segment position range.\n         * Since it is used as a range of segments, we should originally hold all nodes, not just identifiers,\n         * but since the only nodes to be judged are identifiers, it is sufficient to have a range of identifiers.\n         */\n        /**\n         * @typedef {Object} AssignmentInfo\n         * @property {Variable} variable The variable that is assigned.\n         * @property {Identifier} identifier The identifier that is assigned.\n         * @property {VariableDeclarator|AssignmentExpression|UpdateExpression} node The node where the variable was updated.\n         * @property {Expression|null} expression The expression that is evaluated before the assignment.\n         * @property {CodePathSegment[]} segments The code path segments where the assignment was made.\n         */\n\n        /** @type {ScopeStack} */\n        let scopeStack = null;\n\n        /** @type {Set<Scope>} */\n        const codePathStartScopes = new Set();\n\n        /**\n         * Gets the scope of code path start from given scope\n         * @param {Scope} scope The initial scope\n         * @returns {Scope} The scope of code path start\n         * @throws {Error} Unexpected error\n         */\n        function getCodePathStartScope(scope) {\n            let target = scope;\n\n            while (target) {\n                if (codePathStartScopes.has(target)) {\n                    return target;\n                }\n                target = target.upper;\n            }\n\n            // Should be unreachable\n            return null;\n        }\n\n        /**\n         * Verify the given scope stack.\n         * @param {ScopeStack} target The scope stack to verify.\n         * @returns {void}\n         */\n        function verify(target) {\n\n            /**\n             * Checks whether the given identifier is used in the segment.\n             * @param {CodePathSegment} segment The code path segment.\n             * @param {Identifier} identifier The identifier to check.\n             * @returns {boolean} `true` if the identifier is used in the segment.\n             */\n            function isIdentifierUsedInSegment(segment, identifier) {\n                const segmentInfo = target.segments[segment.id];\n\n                return (\n                    segmentInfo.first &&\n                    segmentInfo.last &&\n                    segmentInfo.first.range[0] <= identifier.range[0] &&\n                    identifier.range[1] <= segmentInfo.last.range[1]\n                );\n            }\n\n            /**\n             * Verifies whether the given assignment info is an used assignment.\n             * Report if it is an unused assignment.\n             * @param {AssignmentInfo} targetAssignment The assignment info to verify.\n             * @param {AssignmentInfo[]} allAssignments The list of all assignment info for variables.\n             * @returns {void}\n             */\n            function verifyAssignmentIsUsed(targetAssignment, allAssignments) {\n\n                /**\n                 * @typedef {Object} SubsequentSegmentData\n                 * @property {CodePathSegment} segment The code path segment\n                 * @property {AssignmentInfo} [assignment] The first occurrence of the assignment within the segment.\n                 * There is no need to check if the variable is used after this assignment,\n                 * as the value it was assigned will be used.\n                 */\n\n                /**\n                 * Information used in `getSubsequentSegments()`.\n                 * To avoid unnecessary iterations, cache information that has already been iterated over,\n                 * and if additional iterations are needed, start iterating from the retained position.\n                 */\n                const subsequentSegmentData = {\n\n                    /**\n                     * Cache of subsequent segment information list that have already been iterated.\n                     * @type {SubsequentSegmentData[]}\n                     */\n                    results: [],\n\n                    /**\n                     * Subsequent segments that have already been iterated on. Used to avoid infinite loops.\n                     * @type {Set<CodePathSegment>}\n                     */\n                    subsequentSegments: new Set(),\n\n                    /**\n                     * Unexplored code path segment.\n                     * If additional iterations are needed, consume this information and iterate.\n                     * @type {CodePathSegment[]}\n                     */\n                    queueSegments: targetAssignment.segments.flatMap(segment => segment.nextSegments)\n                };\n\n\n                /**\n                 * Gets the subsequent segments from the segment of\n                 * the assignment currently being validated (targetAssignment).\n                 * @returns {Iterable<SubsequentSegmentData>} the subsequent segments\n                 */\n                function *getSubsequentSegments() {\n                    yield* subsequentSegmentData.results;\n\n                    while (subsequentSegmentData.queueSegments.length > 0) {\n                        const nextSegment = subsequentSegmentData.queueSegments.shift();\n\n                        if (subsequentSegmentData.subsequentSegments.has(nextSegment)) {\n                            continue;\n                        }\n                        subsequentSegmentData.subsequentSegments.add(nextSegment);\n\n                        const assignmentInSegment = allAssignments\n                            .find(otherAssignment => (\n                                otherAssignment.segments.includes(nextSegment) &&\n                                !isIdentifierUsedBetweenAssignedAndEqualSign(otherAssignment, targetAssignment.identifier)\n                            ));\n\n                        if (!assignmentInSegment) {\n\n                            /*\n                             * Stores the next segment to explore.\n                             * If `assignmentInSegment` exists,\n                             * we are guarding it because we don't need to explore the next segment.\n                             */\n                            subsequentSegmentData.queueSegments.push(...nextSegment.nextSegments);\n                        }\n\n                        /** @type {SubsequentSegmentData} */\n                        const result = {\n                            segment: nextSegment,\n                            assignment: assignmentInSegment\n                        };\n\n                        subsequentSegmentData.results.push(result);\n                        yield result;\n                    }\n                }\n\n\n                if (targetAssignment.variable.references.some(ref => ref.identifier.type !== \"Identifier\")) {\n\n                    /**\n                     * Skip checking for a variable that has at least one non-identifier reference.\n                     * It's generated by plugins and cannot be handled reliably in the core rule.\n                     */\n                    return;\n                }\n\n                const readReferences = targetAssignment.variable.references.filter(reference => reference.isRead());\n\n                if (!readReferences.length) {\n\n                    /*\n                     * It is not just an unnecessary assignment, but an unnecessary (unused) variable\n                     * and thus should not be reported by this rule because it is reported by `no-unused-vars`.\n                     */\n                    return;\n                }\n\n                /**\n                 * Other assignment on the current segment and after current assignment.\n                 */\n                const otherAssignmentAfterTargetAssignment = allAssignments\n                    .find(assignment => {\n                        if (\n                            assignment === targetAssignment ||\n                            assignment.segments.length && assignment.segments.every(segment => !targetAssignment.segments.includes(segment))\n                        ) {\n                            return false;\n                        }\n                        if (isIdentifierEvaluatedAfterAssignment(targetAssignment, assignment.identifier)) {\n                            return true;\n                        }\n                        if (\n                            assignment.expression &&\n                            assignment.expression.range[0] <= targetAssignment.identifier.range[0] &&\n                            targetAssignment.identifier.range[1] <= assignment.expression.range[1]\n                        ) {\n\n                            /*\n                             * The target assignment is in an expression that is evaluated before the assignment.\n                             * e.g. x=(x=1);\n                             *         ^^^ targetAssignment\n                             *      ^^^^^^^ assignment\n                             */\n                            return true;\n                        }\n\n                        return false;\n                    });\n\n                for (const reference of readReferences) {\n\n                    /*\n                     * If the scope of the reference is outside the current code path scope,\n                     * we cannot track whether this assignment is not used.\n                     * For example, it can also be called asynchronously.\n                     */\n                    if (target.scope !== getCodePathStartScope(reference.from)) {\n                        return;\n                    }\n\n                    // Checks if it is used in the same segment as the target assignment.\n                    if (\n                        isIdentifierEvaluatedAfterAssignment(targetAssignment, reference.identifier) &&\n                        (\n                            isIdentifierUsedBetweenAssignedAndEqualSign(targetAssignment, reference.identifier) ||\n                            targetAssignment.segments.some(segment => isIdentifierUsedInSegment(segment, reference.identifier))\n                        )\n                    ) {\n\n                        if (\n                            otherAssignmentAfterTargetAssignment &&\n                            isIdentifierEvaluatedAfterAssignment(otherAssignmentAfterTargetAssignment, reference.identifier)\n                        ) {\n\n                            // There was another assignment before the reference. Therefore, it has not been used yet.\n                            continue;\n                        }\n\n                        // Uses in statements after the written identifier.\n                        return;\n                    }\n\n                    if (otherAssignmentAfterTargetAssignment) {\n\n                        /*\n                         * The assignment was followed by another assignment in the same segment.\n                         * Therefore, there is no need to check the next segment.\n                         */\n                        continue;\n                    }\n\n                    // Check subsequent segments.\n                    for (const subsequentSegment of getSubsequentSegments()) {\n                        if (isIdentifierUsedInSegment(subsequentSegment.segment, reference.identifier)) {\n                            if (\n                                subsequentSegment.assignment &&\n                                isIdentifierEvaluatedAfterAssignment(subsequentSegment.assignment, reference.identifier)\n                            ) {\n\n                                // There was another assignment before the reference. Therefore, it has not been used yet.\n                                continue;\n                            }\n\n                            // It is used\n                            return;\n                        }\n                    }\n                }\n                context.report({\n                    node: targetAssignment.identifier,\n                    messageId: \"unnecessaryAssignment\"\n                });\n            }\n\n            // Verify that each assignment in the code path is used.\n            for (const assignments of target.assignments.values()) {\n                assignments.sort((a, b) => a.identifier.range[0] - b.identifier.range[0]);\n                for (const assignment of assignments) {\n                    verifyAssignmentIsUsed(assignment, assignments);\n                }\n            }\n        }\n\n        return {\n            onCodePathStart(codePath, node) {\n                const scope = sourceCode.getScope(node);\n\n                scopeStack = {\n                    upper: scopeStack,\n                    codePath,\n                    scope,\n                    segments: Object.create(null),\n                    currentSegments: new Set(),\n                    assignments: new Map()\n                };\n                codePathStartScopes.add(scopeStack.scope);\n            },\n            onCodePathEnd() {\n                verify(scopeStack);\n\n                scopeStack = scopeStack.upper;\n            },\n            onCodePathSegmentStart(segment) {\n                const segmentInfo = { segment, first: null, last: null };\n\n                scopeStack.segments[segment.id] = segmentInfo;\n                scopeStack.currentSegments.add(segment);\n            },\n            onCodePathSegmentEnd(segment) {\n                scopeStack.currentSegments.delete(segment);\n            },\n            Identifier(node) {\n                for (const segment of scopeStack.currentSegments) {\n                    const segmentInfo = scopeStack.segments[segment.id];\n\n                    if (!segmentInfo.first) {\n                        segmentInfo.first = node;\n                    }\n                    segmentInfo.last = node;\n                }\n            },\n            \":matches(VariableDeclarator[init!=null], AssignmentExpression, UpdateExpression):exit\"(node) {\n                if (scopeStack.currentSegments.size === 0) {\n\n                    // Ignore unreachable segments\n                    return;\n                }\n\n                const assignments = scopeStack.assignments;\n\n                let pattern;\n                let expression = null;\n\n                if (node.type === \"VariableDeclarator\") {\n                    pattern = node.id;\n                    expression = node.init;\n                } else if (node.type === \"AssignmentExpression\") {\n                    pattern = node.left;\n                    expression = node.right;\n                } else { // UpdateExpression\n                    pattern = node.argument;\n                }\n\n                for (const identifier of extractIdentifiersFromPattern(pattern)) {\n                    const scope = sourceCode.getScope(identifier);\n\n                    /** @type {Variable} */\n                    const variable = findVariable(scope, identifier);\n\n                    if (!variable) {\n                        continue;\n                    }\n\n                    // We don't know where global variables are used.\n                    if (variable.scope.type === \"global\" && variable.defs.length === 0) {\n                        continue;\n                    }\n\n                    /*\n                     * If the scope of the variable is outside the current code path scope,\n                     * we cannot track whether this assignment is not used.\n                     */\n                    if (scopeStack.scope !== getCodePathStartScope(variable.scope)) {\n                        continue;\n                    }\n\n                    // Variables marked by `markVariableAsUsed()` or\n                    // exported by \"exported\" block comment.\n                    if (variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // Variables exported by ESM export syntax\n                    if (variable.scope.type === \"module\") {\n                        if (\n                            variable.defs\n                                .some(def => (\n                                    (def.type === \"Variable\" && def.parent.parent.type === \"ExportNamedDeclaration\") ||\n                                    (\n                                        def.type === \"FunctionName\" &&\n                                        (\n                                            def.node.parent.type === \"ExportNamedDeclaration\" ||\n                                            def.node.parent.type === \"ExportDefaultDeclaration\"\n                                        )\n                                    ) ||\n                                    (\n                                        def.type === \"ClassName\" &&\n                                        (\n                                            def.node.parent.type === \"ExportNamedDeclaration\" ||\n                                            def.node.parent.type === \"ExportDefaultDeclaration\"\n                                        )\n                                    )\n                                ))\n                        ) {\n                            continue;\n                        }\n                        if (variable.references.some(reference => reference.identifier.parent.type === \"ExportSpecifier\")) {\n\n                            // It have `export { ... }` reference.\n                            continue;\n                        }\n                    }\n\n                    let list = assignments.get(variable);\n\n                    if (!list) {\n                        list = [];\n                        assignments.set(variable, list);\n                    }\n                    list.push({\n                        variable,\n                        identifier,\n                        node,\n                        expression,\n                        segments: [...scopeStack.currentSegments]\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}