{
    "sourceFile": "node_modules/eslint/lib/rules/no-lone-blocks.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary nested blocks\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-lone-blocks\"\n        },\n\n        schema: [],\n\n        messages: {\n            redundantBlock: \"Block is redundant.\",\n            redundantNestedBlock: \"Nested block is redundant.\"\n        }\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node The node to be reported.\n         * @returns {void}\n         */\n        function report(node) {\n            const messageId = node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\"\n                ? \"redundantNestedBlock\"\n                : \"redundantBlock\";\n\n            context.report({\n                node,\n                messageId\n            });\n        }\n\n        /**\n         * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n         */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"StaticBlock\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @param {ASTNode} node The current node to check.\n         * @returns {void}\n         */\n        function markLoneBlock(node) {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = node.parent;\n\n            if (loneBlocks.at(-1) === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings, or that's only child of another block\n        if (context.languageOptions.ecmaVersion >= 2015) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks.at(-1) === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    } else if (\n                        (\n                            node.parent.type === \"BlockStatement\" ||\n                            node.parent.type === \"StaticBlock\"\n                        ) &&\n                        node.parent.body.length === 1\n                    ) {\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind !== \"var\") {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function(node) {\n                if (sourceCode.getScope(node).isStrict) {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n"
        }
    ]
}