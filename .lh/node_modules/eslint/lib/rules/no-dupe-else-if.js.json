{
    "sourceFile": "node_modules/eslint/lib/rules/no-dupe-else-if.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892222115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n    return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\nfunction splitByLogicalOperator(operator, node) {\n    if (node.type === \"LogicalExpression\" && node.operator === operator) {\n        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n    }\n    return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow duplicate conditions in if-else-if chains\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-dupe-else-if\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n         * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n         * @param {ASTNode} a First node.\n         * @param {ASTNode} b Second node.\n         * @returns {boolean} `true` if the nodes are considered to be equal.\n         */\n        function equal(a, b) {\n            if (a.type !== b.type) {\n                return false;\n            }\n\n            if (\n                a.type === \"LogicalExpression\" &&\n                (a.operator === \"||\" || a.operator === \"&&\") &&\n                a.operator === b.operator\n            ) {\n                return equal(a.left, b.left) && equal(a.right, b.right) ||\n                    equal(a.left, b.right) && equal(a.right, b.left);\n            }\n\n            return astUtils.equalTokens(a, b, sourceCode);\n        }\n\n        const isSubset = isSubsetByComparator.bind(null, equal);\n\n        return {\n            IfStatement(node) {\n                const test = node.test,\n                    conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\"\n                        ? [test, ...splitByAnd(test)]\n                        : [test];\n                let current = node,\n                    listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n                while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n                    current = current.parent;\n\n                    const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n\n                    listToCheck = listToCheck.map(orOperands => orOperands.filter(\n                        orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))\n                    ));\n\n                    if (listToCheck.some(orOperands => orOperands.length === 0)) {\n                        context.report({ node: test, messageId: \"unexpected\" });\n                        break;\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}