{
    "sourceFile": "node_modules/eslint/lib/rules/no-unsafe-negation.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is `in` or `instanceof`\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\n */\nfunction isInOrInstanceOfOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given operator is an ordering relational operator or not.\n * @param {string} op The operator type to check.\n * @returns {boolean} `true` if the operator is an ordering relational operator.\n */\nfunction isOrderingRelationalOperator(op) {\n    return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            enforceForOrderingRelations: false\n        }],\n\n        docs: {\n            description: \"Disallow negating the left operand of relational operators\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unsafe-negation\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForOrderingRelations: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: null,\n\n        messages: {\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n            suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n            suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const [{ enforceForOrderingRelations }] = context.options;\n\n        return {\n            BinaryExpression(node) {\n                const operator = node.operator;\n                const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n                if (\n                    (isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        messageId: \"unexpected\",\n                        data: { operator },\n                        suggest: [\n                            {\n                                messageId: \"suggestNegatedExpression\",\n                                data: { operator },\n                                fix(fixer) {\n                                    const negationToken = sourceCode.getFirstToken(node.left);\n                                    const fixRange = [negationToken.range[1], node.range[1]];\n                                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                                    return fixer.replaceTextRange(fixRange, `(${text})`);\n                                }\n                            },\n                            {\n                                messageId: \"suggestParenthesisedNegation\",\n                                fix(fixer) {\n                                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n                                }\n                            }\n                        ]\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}