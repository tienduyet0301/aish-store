{
    "sourceFile": "node_modules/eslint/lib/rules/no-restricted-modules.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892230568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n * @deprecated in ESLint v7.0.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: { type: \"string\" },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Node.js rules were moved out of ESLint core.\",\n            url: \"https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules\",\n            deprecatedSince: \"7.0.0\",\n            availableUntil: null,\n            replacedBy: [\n                {\n                    message: \"eslint-plugin-n now maintains deprecated Node.js-related rules.\",\n                    plugin: {\n                        name: \"eslint-plugin-n\",\n                        url: \"https://github.com/eslint-community/eslint-plugin-n\"\n                    },\n                    rule: {\n                        name: \"no-restricted-require\",\n                        url: \"https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-restricted-require.md\"\n                    }\n                }\n            ]\n        },\n\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified modules when loaded by `require`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-restricted-modules\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: {\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    },\n                    additionalItems: false\n                }\n            ]\n        },\n\n        messages: {\n            defaultMessage: \"'{{name}}' module is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\n            patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.hasOwn(options[0], \"paths\") || Object.hasOwn(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n            if (typeof importName === \"string\") {\n                memo[importName] = null;\n            } else {\n                memo[importName.name] = importName.message;\n            }\n            return memo;\n        }, {});\n\n        // if no imports are restricted we don't need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        // relative paths are supported for this rule\n        const ig = ignore({ allowRelativePaths: true }).add(restrictedPatterns);\n\n\n        /**\n         * Function to check if a node is a string literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string literal.\n         */\n        function isStringLiteral(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Function to check if a node is a require call.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a require call.\n         */\n        function isRequireCall(node) {\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n        }\n\n        /**\n         * Extract string from Literal or TemplateLiteral node\n         * @param {ASTNode} node The node to extract from\n         * @returns {string|null} Extracted string or null if node doesn't represent a string\n         */\n        function getFirstArgumentString(node) {\n            if (isStringLiteral(node)) {\n                return node.value.trim();\n            }\n\n            if (astUtils.isStaticTemplateLiteral(node)) {\n                return node.quasis[0].value.cooked.trim();\n            }\n\n            return null;\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {node} node representing the restricted path reference\n         * @param {string} name restricted path\n         * @returns {void}\n         * @private\n         */\n        function reportPath(node, name) {\n            const customMessage = restrictedPathMessages[name];\n            const messageId = customMessage\n                ? \"customMessage\"\n                : \"defaultMessage\";\n\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    customMessage\n                }\n            });\n        }\n\n        /**\n         * Check if the given name is a restricted path name\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted path or not\n         * @private\n         */\n        function isRestrictedPath(name) {\n            return Object.hasOwn(restrictedPathMessages, name);\n        }\n\n        return {\n            CallExpression(node) {\n                if (isRequireCall(node)) {\n\n                    // node has arguments\n                    if (node.arguments.length) {\n                        const name = getFirstArgumentString(node.arguments[0]);\n\n                        // if first argument is a string literal or a static string template literal\n                        if (name) {\n\n                            // check if argument value is in restricted modules array\n                            if (isRestrictedPath(name)) {\n                                reportPath(node, name);\n                            }\n\n                            if (restrictedPatterns.length > 0 && ig.ignores(name)) {\n                                context.report({\n                                    node,\n                                    messageId: \"patternMessage\",\n                                    data: { name }\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}