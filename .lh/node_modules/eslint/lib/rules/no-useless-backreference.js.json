{
    "sourceFile": "node_modules/eslint/lib/rules/no-useless-backreference.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow useless backreferences in regular expressions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"@eslint-community/eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new RegExpParser();\n\n/**\n * Finds the path from the given `regexpp` AST node to the root node.\n * @param {regexpp.Node} node Node.\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\n */\nfunction getPathToRoot(node) {\n    const path = [];\n    let current = node;\n\n    do {\n        path.push(current);\n        current = current.parent;\n    } while (current);\n\n    return path;\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a lookaround node.\n */\nfunction isLookaround(node) {\n    return node.type === \"Assertion\" &&\n        (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n\n/**\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\n * @param {regexpp.Node} node Node.\n * @returns {boolean} `true` if it is a negative lookaround node.\n */\nfunction isNegativeLookaround(node) {\n    return isLookaround(node) && node.negate;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow useless backreferences in regular expressions\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-backreference\"\n        },\n\n        schema: [],\n\n        messages: {\n            nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} from within that group.\",\n            forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which appears later in the pattern.\",\n            backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which appears before in the same lookbehind.\",\n            disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which is in another alternative.\",\n            intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which is in a negative lookaround.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks and reports useless backreferences in the given regular expression.\n         * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\n         * @param {string} pattern Regular expression pattern.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         */\n        function checkRegex(node, pattern, flags) {\n            let regExpAST;\n\n            try {\n                regExpAST = parser.parsePattern(pattern, 0, pattern.length, { unicode: flags.includes(\"u\"), unicodeSets: flags.includes(\"v\") });\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            visitRegExpAST(regExpAST, {\n                onBackreferenceEnter(bref) {\n                    const groups = [bref.resolved].flat(),\n                        brefPath = getPathToRoot(bref);\n\n                    const problems = groups.map(group => {\n                        const groupPath = getPathToRoot(group);\n\n                        if (brefPath.includes(group)) {\n\n                            // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n                            return {\n                                messageId: \"nested\",\n                                group\n                            };\n                        }\n\n\n                        // Start from the root to find the lowest common ancestor.\n                        let i = brefPath.length - 1,\n                            j = groupPath.length - 1;\n\n                        do {\n                            i--;\n                            j--;\n                        } while (brefPath[i] === groupPath[j]);\n\n                        const indexOfLowestCommonAncestor = j + 1,\n                            groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                            commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                            lowestCommonLookaround = commonPath.find(isLookaround),\n                            isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n                        if (groupCut.at(-1).type === \"Alternative\") {\n\n                            // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n                            return {\n                                messageId: \"disjunctive\",\n                                group\n                            };\n                        }\n                        if (!isMatchingBackward && bref.end <= group.start) {\n\n                            // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n                            return {\n                                messageId: \"forward\",\n                                group\n                            };\n                        }\n                        if (isMatchingBackward && group.end <= bref.start) {\n\n                            // the opposite of the previous when the regex is matching backward in a lookbehind context.\n                            return {\n                                messageId: \"backward\",\n                                group\n                            };\n                        }\n                        if (groupCut.some(isNegativeLookaround)) {\n\n                            // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n                            return {\n                                messageId: \"intoNegativeLookaround\",\n                                group\n                            };\n                        }\n\n                        return null;\n                    });\n\n                    if (problems.length === 0 || problems.some(problem => !problem)) {\n\n                        // If there are no problems or no problems with any group then do not report it.\n                        return;\n                    }\n\n                    let problemsToReport;\n\n                    // Gets problems that appear in the same disjunction.\n                    const problemsInSameDisjunction = problems.filter(problem => problem.messageId !== \"disjunctive\");\n\n                    if (problemsInSameDisjunction.length) {\n\n                        // Only report problems that appear in the same disjunction.\n                        problemsToReport = problemsInSameDisjunction;\n                    } else {\n\n                        // If all groups appear in different disjunctions, report it.\n                        problemsToReport = problems;\n                    }\n\n                    const [{ messageId, group }, ...other] = problemsToReport;\n                    let otherGroups = \"\";\n\n                    if (other.length === 1) {\n                        otherGroups = \" and another group\";\n                    } else if (other.length > 1) {\n                        otherGroups = ` and other ${other.length} groups`;\n                    }\n                    context.report({\n                        node,\n                        messageId,\n                        data: {\n                            bref: bref.raw,\n                            group: group.raw,\n                            otherGroups\n                        }\n                    });\n                }\n            });\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                const { pattern, flags } = node.regex;\n\n                checkRegex(node, pattern, flags);\n            },\n            Program(node) {\n                const scope = sourceCode.getScope(node),\n                    tracker = new ReferenceTracker(scope),\n                    traceMap = {\n                        RegExp: {\n                            [CALL]: true,\n                            [CONSTRUCT]: true\n                        }\n                    };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {\n                    const [patternNode, flagsNode] = refNode.arguments,\n                        pattern = getStringIfConstant(patternNode, scope),\n                        flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        checkRegex(refNode, pattern, flags || \"\");\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}