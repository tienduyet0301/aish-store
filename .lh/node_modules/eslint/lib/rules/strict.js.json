{
    "sourceFile": "node_modules/eslint/lib/rules/strict.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892240050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n * @param {ASTNode} node A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n * @param {ASTNode[]} params A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n    return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"safe\"],\n\n        docs: {\n            description: \"Require or disallow strict mode directives\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/strict\"\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            function: \"Use the function form of 'use strict'.\",\n            global: \"Use the global form of 'use strict'.\",\n            multiple: \"Multiple 'use strict' directives.\",\n            never: \"Strict mode is not permitted.\",\n            unnecessary: \"Unnecessary 'use strict' directive.\",\n            module: \"'use strict' is unnecessary inside of modules.\",\n            implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n            unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n            nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n            wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n        }\n    },\n\n    create(context) {\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n            scopes = [],\n            classScopes = [];\n        let [mode] = context.options;\n\n        if (ecmaFeatures.impliedStrict) {\n            mode = \"implied\";\n        } else if (mode === \"safe\") {\n            mode = ecmaFeatures.globalReturn || context.languageOptions.sourceType === \"commonjs\" ? \"global\" : \"function\";\n        }\n\n        /**\n         * Determines whether a reported error should be fixed, depending on the error type.\n         * @param {string} errorType The type of error\n         * @returns {boolean} `true` if the reported error should be fixed\n         */\n        function shouldFix(errorType) {\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n        }\n\n        /**\n         * Gets a fixer function to remove a given 'use strict' directive.\n         * @param {ASTNode} node The directive that should be removed\n         * @returns {Function} A fixer function\n         */\n        function getFixFunction(node) {\n            return fixer => fixer.remove(node);\n        }\n\n        /**\n         * Report a slice of an array of nodes with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} start Index to start from.\n         * @param {string} end Index to end before.\n         * @param {string} messageId Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportSlice(nodes, start, end, messageId, fix) {\n            nodes.slice(start, end).forEach(node => {\n                context.report({ node, messageId, fix: fix ? getFixFunction(node) : null });\n            });\n        }\n\n        /**\n         * Report all nodes in an array with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAll(nodes, messageId, fix) {\n            reportSlice(nodes, 0, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Report all nodes in an array, except the first, with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} messageId Message id to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAllExceptFirst(nodes, messageId, fix) {\n            reportSlice(nodes, 1, nodes.length, messageId, fix);\n        }\n\n        /**\n         * Entering a function in 'function' mode pushes a new nested scope onto the\n         * stack. The new scope is true if the nested function is strict mode code.\n         * @param {ASTNode} node The function declaration or expression.\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n         * @returns {void}\n         */\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\n            const isInClass = classScopes.length > 0,\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n                isParentStrict = scopes.length > 0 && scopes.at(-1),\n                isStrict = useStrictDirectives.length > 0;\n\n            if (isStrict) {\n                if (!isSimpleParameterList(node.params)) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                } else if (isParentStrict) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessary\", fix: getFixFunction(useStrictDirectives[0]) });\n                } else if (isInClass) {\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessaryInClasses\", fix: getFixFunction(useStrictDirectives[0]) });\n                }\n\n                reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n            } else if (isParentGlobal) {\n                if (isSimpleParameterList(node.params)) {\n                    context.report({ node, messageId: \"function\" });\n                } else {\n                    context.report({\n                        node,\n                        messageId: \"wrap\",\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\n                    });\n                }\n            }\n\n            scopes.push(isParentStrict || isStrict);\n        }\n\n        /**\n         * Exiting a function in 'function' mode pops its scope off the stack.\n         * @returns {void}\n         */\n        function exitFunctionInFunctionMode() {\n            scopes.pop();\n        }\n\n        /**\n         * Enter a function and either:\n         * - Push a new nested scope onto the stack (in 'function' mode).\n         * - Report all the Use Strict Directives (in the other modes).\n         * @param {ASTNode} node The function declaration or expression.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const isBlock = node.body.type === \"BlockStatement\",\n                useStrictDirectives = isBlock\n                    ? getUseStrictDirectives(node.body.body) : [];\n\n            if (mode === \"function\") {\n                enterFunctionInFunctionMode(node, useStrictDirectives);\n            } else if (useStrictDirectives.length > 0) {\n                if (isSimpleParameterList(node.params)) {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                } else {\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                }\n            }\n        }\n\n        const rule = {\n            Program(node) {\n                const useStrictDirectives = getUseStrictDirectives(node.body);\n\n                if (node.sourceType === \"module\") {\n                    mode = \"module\";\n                }\n\n                if (mode === \"global\") {\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\n                        context.report({ node, messageId: \"global\" });\n                    }\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n                } else {\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\n                }\n            },\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction\n        };\n\n        if (mode === \"function\") {\n            Object.assign(rule, {\n\n                // Inside of class bodies are always strict mode.\n                ClassBody() {\n                    classScopes.push(true);\n                },\n                \"ClassBody:exit\"() {\n                    classScopes.pop();\n                },\n\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n            });\n        }\n\n        return rule;\n    }\n};\n"
        }
    ]
}