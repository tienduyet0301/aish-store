{
    "sourceFile": "node_modules/eslint/lib/rules/operator-linebreak.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892234277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author BenoÃ®t Zugmeyer\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"operator-linebreak\",\n                        url: \"https://eslint.style/rules/js/operator-linebreak\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent linebreak style for operators\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/operator-linebreak\"\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n            operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n            badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n            noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n        }\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a fixer function to fix rule issues\n         * @param {Token} operatorToken The operator token of an expression\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n         * @returns {Function} A fixer function\n         */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} rightSide The node that comes after the operator in `node`\n         * @param {string} operator The operator\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, rightSide, operator) {\n\n            /*\n             * Find the operator token by searching from the right side, because between the left side and the operator\n             * there could be additional tokens from type annotations. Search specifically for the token which\n             * value equals the operator, in order to skip possible opening parentheses before the right side node.\n             */\n            const operatorToken = sourceCode.getTokenBefore(rightSide, token => token.value === operator);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"badLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtBeginning\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtEnd\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"noLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.right, node.operator);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.init, \"=\");\n                }\n            },\n            PropertyDefinition(node) {\n                if (node.value) {\n                    validateNode(node, node.value, \"=\");\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.consequent, \"?\");\n                validateNode(node, node.alternate, \":\");\n            }\n        };\n    }\n};\n"
        }
    ]
}