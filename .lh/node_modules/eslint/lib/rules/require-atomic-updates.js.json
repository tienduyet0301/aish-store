{
    "sourceFile": "node_modules/eslint/lib/rules/require-atomic-updates.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892238835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\n * @author Teddy Katz\n * @author Toru Nagashima\n */\n\"use strict\";\n\n/**\n * Make the map from identifiers to each reference.\n * @param {escope.Scope} scope The scope to get references.\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\n */\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\n    for (const reference of scope.references) {\n        if (reference.resolved === null) {\n            continue;\n        }\n\n        outReferenceMap.set(reference.identifier, reference);\n    }\n    for (const childScope of scope.childScopes) {\n        if (childScope.type !== \"function\") {\n            createReferenceMap(childScope, outReferenceMap);\n        }\n    }\n\n    return outReferenceMap;\n}\n\n/**\n * Get `reference.writeExpr` of a given reference.\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\n * @param {escope.Reference} reference The reference to get.\n * @returns {Expression|null} The `reference.writeExpr`.\n */\nfunction getWriteExpr(reference) {\n    if (reference.writeExpr) {\n        return reference.writeExpr;\n    }\n    let node = reference.identifier;\n\n    while (node) {\n        const t = node.parent.type;\n\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\n            return node.parent.right;\n        }\n        if (t === \"MemberExpression\" && node.parent.object === node) {\n            node = node.parent;\n            continue;\n        }\n\n        break;\n    }\n\n    return null;\n}\n\n/**\n * Checks if an expression is a variable that can only be observed within the given function.\n * @param {Variable|null} variable The variable to check\n * @param {boolean} isMemberAccess If `true` then this is a member access.\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\n */\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n    if (!variable) {\n        return false; // A global variable which was not defined.\n    }\n\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n        return false;\n    }\n\n    const functionScope = variable.scope.variableScope;\n\n    return variable.references.every(reference =>\n        reference.from.variableScope === functionScope);\n}\n\n/**\n * Represents segment information.\n */\nclass SegmentInfo {\n    constructor() {\n        this.info = new WeakMap();\n    }\n\n    /**\n     * Initialize the segment information.\n     * @param {PathSegment} segment The segment to initialize.\n     * @returns {void}\n     */\n    initialize(segment) {\n        const outdatedReadVariables = new Set();\n        const freshReadVariables = new Set();\n\n        for (const prevSegment of segment.prevSegments) {\n            const info = this.info.get(prevSegment);\n\n            if (info) {\n                info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n                info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n            }\n        }\n\n        this.info.set(segment, { outdatedReadVariables, freshReadVariables });\n    }\n\n    /**\n     * Mark a given variable as read on given segments.\n     * @param {PathSegment[]} segments The segments that it read the variable on.\n     * @param {Variable} variable The variable to be read.\n     * @returns {void}\n     */\n    markAsRead(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.add(variable);\n\n                // If a variable is freshly read again, then it's no more out-dated.\n                info.outdatedReadVariables.delete(variable);\n            }\n        }\n    }\n\n    /**\n     * Move `freshReadVariables` to `outdatedReadVariables`.\n     * @param {PathSegment[]} segments The segments to process.\n     * @returns {void}\n     */\n    makeOutdated(segments) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info) {\n                info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n                info.freshReadVariables.clear();\n            }\n        }\n    }\n\n    /**\n     * Check if a given variable is outdated on the current segments.\n     * @param {PathSegment[]} segments The current segments.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is outdated on the segments.\n     */\n    isOutdated(segments, variable) {\n        for (const segment of segments) {\n            const info = this.info.get(segment);\n\n            if (info && info.outdatedReadVariables.has(variable)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            allowProperties: false\n        }],\n\n        docs: {\n            description: \"Disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/require-atomic-updates\"\n        },\n\n        fixable: null,\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowProperties: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\",\n            nonAtomicObjectUpdate: \"Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`.\"\n        }\n    },\n\n    create(context) {\n        const [{ allowProperties }] = context.options;\n\n        const sourceCode = context.sourceCode;\n        const assignmentReferences = new Map();\n        const segmentInfo = new SegmentInfo();\n        let stack = null;\n\n        return {\n            onCodePathStart(codePath, node) {\n                const scope = sourceCode.getScope(node);\n                const shouldVerify =\n                    scope.type === \"function\" &&\n                    (scope.block.async || scope.block.generator);\n\n                stack = {\n                    upper: stack,\n                    codePath,\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null,\n                    currentSegments: new Set()\n                };\n            },\n            onCodePathEnd() {\n                stack = stack.upper;\n            },\n\n            // Initialize the segment information.\n            onCodePathSegmentStart(segment) {\n                segmentInfo.initialize(segment);\n                stack.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                stack.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                stack.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                stack.currentSegments.delete(segment);\n            },\n\n\n            // Handle references to prepare verification.\n            Identifier(node) {\n                const { referenceMap } = stack;\n                const reference = referenceMap && referenceMap.get(node);\n\n                // Ignore if this is not a valid variable reference.\n                if (!reference) {\n                    return;\n                }\n                const variable = reference.resolved;\n                const writeExpr = getWriteExpr(reference);\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\n\n                // Add a fresh read variable.\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n                    segmentInfo.markAsRead(stack.currentSegments, variable);\n                }\n\n                /*\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\n                 * if this reference is an assignment to a variable which is referred from other closure.\n                 */\n                if (writeExpr &&\n                    writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\n                ) {\n                    let refs = assignmentReferences.get(writeExpr);\n\n                    if (!refs) {\n                        refs = [];\n                        assignmentReferences.set(writeExpr, refs);\n                    }\n\n                    refs.push(reference);\n                }\n            },\n\n            /*\n             * Verify assignments.\n             * If the reference exists in `outdatedReadVariables` list, report it.\n             */\n            \":expression:exit\"(node) {\n\n                // referenceMap exists if this is in a resumable function scope.\n                if (!stack.referenceMap) {\n                    return;\n                }\n\n                // Mark the read variables on this code path as outdated.\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n                    segmentInfo.makeOutdated(stack.currentSegments);\n                }\n\n                // Verify.\n                const references = assignmentReferences.get(node);\n\n                if (references) {\n                    assignmentReferences.delete(node);\n\n                    for (const reference of references) {\n                        const variable = reference.resolved;\n\n                        if (segmentInfo.isOutdated(stack.currentSegments, variable)) {\n                            if (node.parent.left === reference.identifier) {\n                                context.report({\n                                    node: node.parent,\n                                    messageId: \"nonAtomicUpdate\",\n                                    data: {\n                                        value: variable.name\n                                    }\n                                });\n                            } else if (!allowProperties) {\n                                context.report({\n                                    node: node.parent,\n                                    messageId: \"nonAtomicObjectUpdate\",\n                                    data: {\n                                        value: sourceCode.getText(node.parent.left),\n                                        object: variable.name\n                                    }\n                                });\n                            }\n\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}