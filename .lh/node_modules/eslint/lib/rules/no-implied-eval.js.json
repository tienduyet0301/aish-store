{
    "sourceFile": "node_modules/eslint/lib/rules/no-implied-eval.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { getStaticValue } = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow the use of `eval()`-like methods\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-implied-eval\"\n        },\n\n        schema: [],\n\n        messages: {\n            impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n        }\n    },\n\n    create(context) {\n        const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks whether a node is evaluated as a string or not.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is evaluated as a string.\n         */\n        function isEvaluatedString(node) {\n            if (\n                (node.type === \"Literal\" && typeof node.value === \"string\") ||\n                node.type === \"TemplateLiteral\"\n            ) {\n                return true;\n            }\n            if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n                return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n            }\n            return false;\n        }\n\n        /**\n         * Reports if the `CallExpression` node has evaluated argument.\n         * @param {ASTNode} node A CallExpression to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalCallExpression(node) {\n            const [firstArgument] = node.arguments;\n\n            if (firstArgument) {\n\n                const staticValue = getStaticValue(firstArgument, sourceCode.getScope(node));\n                const isStaticString = staticValue && typeof staticValue.value === \"string\";\n                const isString = isStaticString || isEvaluatedString(firstArgument);\n\n                if (isString) {\n                    context.report({\n                        node,\n                        messageId: \"impliedEval\"\n                    });\n                }\n            }\n\n        }\n\n        /**\n         * Reports calls of `implied eval` via the global references.\n         * @param {Variable} globalVar A global variable to check.\n         * @returns {void}\n         */\n        function reportImpliedEvalViaGlobal(globalVar) {\n            const { references, name } = globalVar;\n\n            references.forEach(ref => {\n                const identifier = ref.identifier;\n                let node = identifier.parent;\n\n                while (astUtils.isSpecificMemberAccess(node, null, name)) {\n                    node = node.parent;\n                }\n\n                if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n                    const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n                    const parent = calleeNode.parent;\n\n                    if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n                        reportImpliedEvalCallExpression(parent);\n                    }\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n                    reportImpliedEvalCallExpression(node);\n                }\n            },\n            \"Program:exit\"(node) {\n                const globalScope = sourceCode.getScope(node);\n\n                GLOBAL_CANDIDATES\n                    .map(candidate => astUtils.getVariableByName(globalScope, candidate))\n                    .filter(globalVar => !!globalVar && globalVar.defs.length === 0)\n                    .forEach(reportImpliedEvalViaGlobal);\n            }\n        };\n\n    }\n};\n"
        }
    ]
}