{
    "sourceFile": "node_modules/eslint/lib/rules/arrow-body-style.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"as-needed\"],\n\n        docs: {\n            description: \"Require braces around arrow function bodies\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/arrow-body-style\"\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\",\n\n        messages: {\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.sourceCode;\n        let funcInfo = null;\n\n        /**\n         * Checks whether the given node has ASI problem or not.\n         * @param {Token} token The token to check.\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\n         */\n        function hasASIProblem(token) {\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n        }\n\n        /**\n         * Gets the closing parenthesis by the given node.\n         * @param {ASTNode} node first node after an opening parenthesis.\n         * @returns {Token} The found closing parenthesis token.\n         */\n        function findClosingParen(node) {\n            let nodeToCheck = node;\n\n            while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n                nodeToCheck = nodeToCheck.parent;\n            }\n            return sourceCode.getTokenAfter(nodeToCheck);\n        }\n\n        /**\n         * Check whether the node is inside of a for loop's init\n         * @param {ASTNode} node node is inside for loop\n         * @returns {boolean} `true` if the node is inside of a for loop, else `false`\n         */\n        function isInsideForLoopInitializer(node) {\n            if (node && node.parent) {\n                if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n                    return true;\n                }\n                return isInsideForLoopInitializer(node.parent);\n            }\n            return false;\n        }\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    let messageId;\n\n                    if (blockBody.length === 0) {\n                        messageId = \"unexpectedEmptyBlock\";\n                    } else if (blockBody.length > 1 || blockBody[0].type !== \"ReturnStatement\") {\n                        messageId = \"unexpectedOtherBlock\";\n                    } else if (blockBody[0].argument === null) {\n                        messageId = \"unexpectedSingleBlock\";\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\n                        messageId = \"unexpectedObjectBlock\";\n                    } else {\n                        messageId = \"unexpectedSingleBlock\";\n                    }\n\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId,\n                        fix(fixer) {\n                            const fixes = [];\n\n                            if (blockBody.length !== 1 ||\n                                blockBody[0].type !== \"ReturnStatement\" ||\n                                !blockBody[0].argument ||\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\n                            ) {\n                                return fixes;\n                            }\n\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n                            const commentsExist =\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n\n                            /*\n                             * Remove tokens around the return value.\n                             * If comments don't exist, remove extra spaces as well.\n                             */\n                            if (commentsExist) {\n                                fixes.push(\n                                    fixer.remove(openingBrace),\n                                    fixer.remove(closingBrace),\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                                );\n                            } else {\n                                fixes.push(\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\n                                );\n                            }\n\n                            /*\n                             * If the first token of the return value is `{` or the return value is a sequence expression,\n                             * enclose the return value by parentheses to avoid syntax error.\n                             */\n                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || (funcInfo.hasInOperator && isInsideForLoopInitializer(node))) {\n                                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                                    fixes.push(\n                                        fixer.insertTextBefore(firstValueToken, \"(\"),\n                                        fixer.insertTextAfter(lastValueToken, \")\")\n                                    );\n                                }\n                            }\n\n                            /*\n                             * If the last token of the return statement is semicolon, remove it.\n                             * Non-block arrow body is an expression, not a statement.\n                             */\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n                                fixes.push(fixer.remove(lastValueToken));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc,\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const fixes = [];\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n                            const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });\n                            const lastToken = sourceCode.getLastToken(node);\n\n                            let parenthesisedObjectLiteral = null;\n\n                            if (\n                                astUtils.isOpeningParenToken(firstTokenAfterArrow) &&\n                                astUtils.isOpeningBraceToken(secondTokenAfterArrow)\n                            ) {\n                                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n\n                                if (braceNode.type === \"ObjectExpression\") {\n                                    parenthesisedObjectLiteral = braceNode;\n                                }\n                            }\n\n                            // If the value is object literal, remove parentheses which were forced by syntax.\n                            if (parenthesisedObjectLiteral) {\n                                const openingParenToken = firstTokenAfterArrow;\n                                const openingBraceToken = secondTokenAfterArrow;\n\n                                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                                    fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                                } else {\n\n                                    // Avoid ASI\n                                    fixes.push(\n                                        fixer.replaceText(openingParenToken, \"{\"),\n                                        fixer.insertTextBefore(openingBraceToken, \"return \")\n                                    );\n                                }\n\n                                // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n                                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n\n                            } else {\n                                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n                            }\n\n                            return fixes;\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            \"BinaryExpression[operator='in']\"() {\n                let info = funcInfo;\n\n                while (info) {\n                    info.hasInOperator = true;\n                    info = info.upper;\n                }\n            },\n            ArrowFunctionExpression() {\n                funcInfo = {\n                    upper: funcInfo,\n                    hasInOperator: false\n                };\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                validate(node);\n                funcInfo = funcInfo.upper;\n            }\n        };\n    }\n};\n"
        }
    ]
}