{
    "sourceFile": "node_modules/eslint/lib/rules/array-callback-return.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213665,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;\n\n/**\n * Checks a given node is a member access which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a member access which has\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\n */\nfunction isTargetMethod(node) {\n    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Returns a human-legible description of an array method\n * @param {string} arrayMethodName A method name to fully qualify\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\n *      or else `Array.prototype.` if it is an instance method.\n */\nfunction fullMethodName(arrayMethodName) {\n    if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n        return \"Array.\".concat(arrayMethodName);\n    }\n    return \"Array.prototype.\".concat(arrayMethodName);\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method, returning the method name.\n * @param {ASTNode} node A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {string} The method name if the node is a callback method,\n *      null otherwise.\n */\nfunction getArrayMethodName(node) {\n    let currentNode = node;\n\n    while (currentNode) {\n        const parent = currentNode.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n            case \"ChainExpression\":\n                currentNode = parent;\n                break;\n\n            /*\n             * If the upper function is IIFE, checks the destination of the return value.\n             * e.g.\n             *   foo.every((function() {\n             *     // setup...\n             *     return function callback() { ... };\n             *   })());\n             */\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return null;\n                }\n                currentNode = func.parent;\n                break;\n            }\n\n            /*\n             * e.g.\n             *   Array.from([], function() {});\n             *   list.every(function() {});\n             */\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === currentNode\n                    ) {\n                        return \"from\";\n                    }\n                }\n                if (isTargetMethod(parent.callee)) {\n                    if (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === currentNode\n                    ) {\n                        return astUtils.getStaticPropertyName(parent.callee);\n                    }\n                }\n                return null;\n\n            // Otherwise this node is not target.\n            default:\n                return null;\n        }\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Checks if the given node is a void expression.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} - `true` if the node is a void expression\n */\nfunction isExpressionVoid(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Fixes the linting error by prepending \"void \" to the given node\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction voidPrependFixer(sourceCode, node, fixer) {\n\n    const requiresParens =\n\n        // prepending `void ` will fail if the node has a lower precedence than void\n        astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\", operator: \"void\" }) &&\n\n        // check if there are parentheses around the node to avoid redundant parentheses\n        !astUtils.isParenthesised(sourceCode, node);\n\n    // avoid parentheses issues\n    const returnOrArrowToken = sourceCode.getTokenBefore(\n        node,\n        node.parent.type === \"ArrowFunctionExpression\"\n            ? astUtils.isArrowToken\n\n            // isReturnToken\n            : token => token.type === \"Keyword\" && token.value === \"return\"\n    );\n\n    const firstToken = sourceCode.getTokenAfter(returnOrArrowToken);\n\n    const prependSpace =\n\n        // is return token, as => allows void to be adjacent\n        returnOrArrowToken.value === \"return\" &&\n\n        // If two tokens (return and \"(\") are adjacent\n        returnOrArrowToken.range[1] === firstToken.range[0];\n\n    return [\n        fixer.insertTextBefore(firstToken, `${prependSpace ? \" \" : \"\"}void ${requiresParens ? \"(\" : \"\"}`),\n        fixer.insertTextAfter(node, requiresParens ? \")\" : \"\")\n    ];\n}\n\n/**\n * Fixes the linting error by `wrapping {}` around the given node's body.\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction curlyWrapFixer(sourceCode, node, fixer) {\n    const arrowToken = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n    const firstToken = sourceCode.getTokenAfter(arrowToken);\n    const lastToken = sourceCode.getLastToken(node);\n\n    return [\n        fixer.insertTextBefore(firstToken, \"{\"),\n        fixer.insertTextAfter(lastToken, \"}\")\n    ];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            allowImplicit: false,\n            checkForEach: false,\n            allowVoid: false\n        }],\n\n        docs: {\n            description: \"Enforce `return` statements in callbacks of array methods\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/array-callback-return\"\n        },\n\n        // eslint-disable-next-line eslint-plugin/require-meta-has-suggestions -- false positive\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowImplicit: {\n                        type: \"boolean\"\n                    },\n                    checkForEach: {\n                        type: \"boolean\"\n                    },\n                    allowVoid: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n            expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n            expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\",\n            wrapBraces: \"Wrap the expression in `{}`.\",\n            prependVoid: \"Prepend `void` to the expression.\"\n        }\n    },\n\n    create(context) {\n        const [options] = context.options;\n        const sourceCode = context.sourceCode;\n\n        let funcInfo = {\n            arrayMethodName: null,\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n\n            if (!funcInfo.shouldCheck) {\n                return;\n            }\n\n            const messageAndSuggestions = { messageId: \"\", suggest: [] };\n\n            if (funcInfo.arrayMethodName === \"forEach\") {\n                if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n\n                    if (options.allowVoid) {\n                        if (isExpressionVoid(node.body)) {\n                            return;\n                        }\n\n                        messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                        messageAndSuggestions.suggest = [\n                            {\n                                messageId: \"wrapBraces\",\n                                fix(fixer) {\n                                    return curlyWrapFixer(sourceCode, node, fixer);\n                                }\n                            },\n                            {\n                                messageId: \"prependVoid\",\n                                fix(fixer) {\n                                    return voidPrependFixer(sourceCode, node.body, fixer);\n                                }\n                            }\n                        ];\n                    } else {\n                        messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                        messageAndSuggestions.suggest = [{\n                            messageId: \"wrapBraces\",\n                            fix(fixer) {\n                                return curlyWrapFixer(sourceCode, node, fixer);\n                            }\n                        }];\n                    }\n                }\n            } else {\n                if (node.body.type === \"BlockStatement\" && isAnySegmentReachable(funcInfo.currentSegments)) {\n                    messageAndSuggestions.messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n                }\n            }\n\n            if (messageAndSuggestions.messageId) {\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    messageId: messageAndSuggestions.messageId,\n                    data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) },\n                    suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n\n                let methodName = null;\n\n                if (TARGET_NODE_TYPE.test(node.type)) {\n                    methodName = getArrayMethodName(node);\n                }\n\n                funcInfo = {\n                    arrayMethodName: methodName,\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        methodName &&\n                        !node.async &&\n                        !node.generator,\n                    node,\n                    currentSegments: new Set()\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n\n                if (!funcInfo.shouldCheck) {\n                    return;\n                }\n\n                funcInfo.hasReturn = true;\n\n                const messageAndSuggestions = { messageId: \"\", suggest: [] };\n\n                if (funcInfo.arrayMethodName === \"forEach\") {\n\n                    // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n                    if (options.checkForEach && node.argument) {\n\n                        if (options.allowVoid) {\n                            if (isExpressionVoid(node.argument)) {\n                                return;\n                            }\n\n                            messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                            messageAndSuggestions.suggest = [{\n                                messageId: \"prependVoid\",\n                                fix(fixer) {\n                                    return voidPrependFixer(sourceCode, node.argument, fixer);\n                                }\n                            }];\n                        } else {\n                            messageAndSuggestions.messageId = \"expectedNoReturnValue\";\n                        }\n                    }\n                } else {\n\n                    // if allowImplicit: false, should also check node.argument\n                    if (!options.allowImplicit && !node.argument) {\n                        messageAndSuggestions.messageId = \"expectedReturnValue\";\n                    }\n                }\n\n                if (messageAndSuggestions.messageId) {\n                    context.report({\n                        node,\n                        messageId: messageAndSuggestions.messageId,\n                        data: {\n                            name: astUtils.getFunctionNameWithKind(funcInfo.node),\n                            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n                        },\n                        suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null\n                    });\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"
        }
    ]
}