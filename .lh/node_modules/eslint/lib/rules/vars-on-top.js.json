{
    "sourceFile": "node_modules/eslint/lib/rules/vars-on-top.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892241229,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require `var` declarations be placed at the top of their containing scope\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/vars-on-top\"\n        },\n\n        schema: [],\n        messages: {\n            top: \"All 'var' declarations must be at the top of the function scope.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Has AST suggesting a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         * @param {ASTNode} node any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode[]} statements collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // Skip over directives and imports. Static blocks don't have either.\n            if (node.parent.type !== \"StaticBlock\") {\n                for (; i < l; ++i) {\n                    if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                        break;\n                    }\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} parent Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node The node to check\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node) {\n            const { parent } = node;\n\n            if (\n                parent.type === \"BlockStatement\" &&\n                /Function/u.test(parent.parent.type) &&\n                isVarOnTop(node, parent.body)\n            ) {\n                return;\n            }\n\n            if (\n                parent.type === \"StaticBlock\" &&\n                isVarOnTop(node, parent.body)\n            ) {\n                return;\n            }\n\n            context.report({ node, messageId: \"top\" });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration[kind='var']\"(node) {\n                if (node.parent.type === \"ExportNamedDeclaration\") {\n                    globalVarCheck(node.parent, node.parent.parent);\n                } else if (node.parent.type === \"Program\") {\n                    globalVarCheck(node, node.parent);\n                } else {\n                    blockScopeVarCheck(node);\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}