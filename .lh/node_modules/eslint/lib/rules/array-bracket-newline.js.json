{
    "sourceFile": "node_modules/eslint/lib/rules/array-bracket-newline.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce linebreaks after open and before close array brackets\n * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"array-bracket-newline\",\n                        url: \"https://eslint.style/rules/js/array-bracket-newline\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce linebreaks after opening and before closing array brackets\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/array-bracket-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consistent\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            multiline: {\n                                type: \"boolean\"\n                            },\n                            minItems: {\n                                type: [\"integer\", \"null\"],\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedOpeningLinebreak: \"There should be no linebreak after '['.\",\n            unexpectedClosingLinebreak: \"There should be no linebreak before ']'.\",\n            missingOpeningLinebreak: \"A linebreak is required after '['.\",\n            missingClosingLinebreak: \"A linebreak is required before ']'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} option An option value to parse.\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\n         */\n        function normalizeOptionValue(option) {\n            let consistent = false;\n            let multiline = false;\n            let minItems;\n\n            if (option) {\n                if (option === \"consistent\") {\n                    consistent = true;\n                    minItems = Number.POSITIVE_INFINITY;\n                } else if (option === \"always\" || option.minItems === 0) {\n                    minItems = 0;\n                } else if (option === \"never\") {\n                    minItems = Number.POSITIVE_INFINITY;\n                } else {\n                    multiline = Boolean(option.multiline);\n                    minItems = option.minItems || Number.POSITIVE_INFINITY;\n                }\n            } else {\n                consistent = false;\n                multiline = true;\n                minItems = Number.POSITIVE_INFINITY;\n            }\n\n            return { consistent, multiline, minItems };\n        }\n\n        /**\n         * Normalizes a given option value.\n         * @param {string|Object|undefined} options An option value to parse.\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\n         */\n        function normalizeOptions(options) {\n            const value = normalizeOptionValue(options);\n\n            return { ArrayExpression: value, ArrayPattern: value };\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedOpeningLinebreak\",\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(nextToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"unexpectedClosingLinebreak\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n                    if (astUtils.isCommentToken(previousToken)) {\n                        return null;\n                    }\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingOpeningLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a linebreak before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingLinebreak(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                messageId: \"missingClosingLinebreak\",\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \"\\n\");\n                }\n            });\n        }\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ArrayExpression node or an ArrayPattern node.\n         * @returns {void}\n         */\n        function check(node) {\n            const elements = node.elements;\n            const normalizedOptions = normalizeOptions(context.options[0]);\n            const options = normalizedOptions[node.type];\n            const openBracket = sourceCode.getFirstToken(node);\n            const closeBracket = sourceCode.getLastToken(node);\n            const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });\n            const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });\n            const first = sourceCode.getTokenAfter(openBracket);\n            const last = sourceCode.getTokenBefore(closeBracket);\n\n            const needsLinebreaks = (\n                elements.length >= options.minItems ||\n                (\n                    options.multiline &&\n                    elements.length > 0 &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line\n                ) ||\n                (\n                    elements.length === 0 &&\n                    firstIncComment.type === \"Block\" &&\n                    firstIncComment.loc.start.line !== lastIncComment.loc.end.line &&\n                    firstIncComment === lastIncComment\n                ) ||\n                (\n                    options.consistent &&\n                    openBracket.loc.end.line !== first.loc.start.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether linebreaks are needed.\n             * This allows:\n             *     var arr = [ // eslint-disable-line foo\n             *         'a'\n             *     ]\n             */\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportRequiredBeginningLinebreak(node, openBracket);\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportRequiredEndingLinebreak(node, closeBracket);\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBracket, first)) {\n                    reportNoBeginningLinebreak(node, openBracket);\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBracket)) {\n                    reportNoEndingLinebreak(node, closeBracket);\n                }\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            ArrayPattern: check,\n            ArrayExpression: check\n        };\n    }\n};\n"
        }
    ]
}