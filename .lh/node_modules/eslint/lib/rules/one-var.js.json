{
    "sourceFile": "node_modules/eslint/lib/rules/one-var.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892234090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is in a statement list.\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if the given node is in a statement list\n */\nfunction isInStatementList(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce variables to be declared either together or separately in functions\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/one-var\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\", \"consecutive\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            separateRequires: {\n                                type: \"boolean\"\n                            },\n                            var: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\", \"consecutive\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n            combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n            splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n            splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n            splitRequires: \"Split requires to be separated into a single block.\",\n            combine: \"Combine this with the previous '{{type}}' statement.\",\n            split: \"Split '{{type}}' declarations into multiple statements.\"\n        }\n    },\n\n    create(context) {\n        const MODE_ALWAYS = \"always\";\n        const MODE_NEVER = \"never\";\n        const MODE_CONSECUTIVE = \"consecutive\";\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {};\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            options.separateRequires = !!mode.separateRequires;\n            options.var = { uninitialized: mode.var, initialized: mode.var };\n            options.let = { uninitialized: mode.let, initialized: mode.let };\n            options.const = { uninitialized: mode.const, initialized: mode.const };\n            if (Object.hasOwn(mode, \"uninitialized\")) {\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (Object.hasOwn(mode, \"initialized\")) {\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        const sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Check if a variable declaration is a require.\n         * @param {ASTNode} decl variable declaration Node\n         * @returns {bool} if decl is a require, return true; else return false.\n         * @private\n         */\n        function isRequire(decl) {\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n        }\n\n        /**\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        if (options.separateRequires && isRequire(declarations[i])) {\n                            currentScope.required = true;\n                        } else {\n                            currentScope.initialized = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack.at(-1);\n            } else if (statementType === \"let\") {\n                currentScope = blockStack.at(-1).let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack.at(-1).const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n            const hasRequires = declarations.some(isRequire);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    if (!hasRequires) {\n                        return false;\n                    }\n                }\n            }\n            if (currentScope.required && hasRequires) {\n                return false;\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n        /**\n         * Fixer to join VariableDeclaration's into a single declaration\n         * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\n         * @returns {Function} The fixer function\n         */\n        function joinDeclarations(declarations) {\n            const declaration = declarations[0];\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n            const previousNode = body[currentIndex - 1];\n\n            return fixer => {\n                const type = sourceCode.getTokenBefore(declaration);\n                const prevSemi = sourceCode.getTokenBefore(type);\n                const res = [];\n\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n                    if (prevSemi.value === \";\") {\n                        res.push(fixer.replaceText(prevSemi, \",\"));\n                    } else {\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\n                    }\n                    res.push(fixer.replaceText(type, \"\"));\n                }\n\n                return res;\n            };\n        }\n\n        /**\n         * Fixer to split a VariableDeclaration into individual declarations\n         * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\n         * @returns {Function|null} The fixer function\n         */\n        function splitDeclarations(declaration) {\n            const { parent } = declaration;\n\n            // don't autofix code such as: if (foo) var x, y;\n            if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n                return null;\n            }\n\n            return fixer => declaration.declarations.map(declarator => {\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n                if (tokenAfterDeclarator === null) {\n                    return null;\n                }\n\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\n\n                if (tokenAfterDeclarator.value !== \",\") {\n                    return null;\n                }\n\n                const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n\n                /*\n                 * `var x,y`\n                 * tokenAfterDeclarator ^^ afterComma\n                 */\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n                }\n\n                /*\n                 * `var x,\n                 * tokenAfterDeclarator ^\n                 *      y`\n                 *      ^ afterComma\n                 */\n                if (\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\n                    afterComma.type === \"Line\" ||\n                    afterComma.type === \"Block\"\n                ) {\n                    let lastComment = afterComma;\n\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\n                    }\n\n                    return fixer.replaceTextRange(\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `\n                    );\n                }\n\n                return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n            }).filter(x => x);\n        }\n\n        /**\n         * Checks a given VariableDeclaration node for errors.\n         * @param {ASTNode} node The VariableDeclaration node to check\n         * @returns {void}\n         * @private\n         */\n        function checkVariableDeclaration(node) {\n            const parent = node.parent;\n            const type = node.kind;\n\n            if (!options[type]) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            const declarationCounts = countDeclarations(declarations);\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n            if (options[type].initialized === MODE_ALWAYS) {\n                if (options.separateRequires && mixedRequires) {\n                    context.report({\n                        node,\n                        messageId: \"splitRequires\"\n                    });\n                }\n            }\n\n            // consecutive\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\n\n            if (nodeIndex > 0) {\n                const previousNode = parent.body[nodeIndex - 1];\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n                if (\n                    isPreviousNodeDeclaration &&\n                    previousNode.kind === type &&\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\n                ) {\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n                        context.report({\n                            node,\n                            messageId: \"combine\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\n                            declarationCounts.uninitialized > 0 &&\n                            previousDeclCounts.uninitialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // always\n            if (!hasOnlyOneStatement(type, declarations)) {\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                    context.report({\n                        node,\n                        messageId: \"combine\",\n                        data: {\n                            type\n                        },\n                        fix: joinDeclarations(declarations)\n                    });\n                } else {\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n                        context.report({\n                            node,\n                            messageId: \"combineInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                            return;\n                        }\n                        context.report({\n                            node,\n                            messageId: \"combineUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: joinDeclarations(declarations)\n                        });\n                    }\n                }\n            }\n\n            // never\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                if (totalDeclarations > 1) {\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                        // both initialized and uninitialized\n                        context.report({\n                            node,\n                            messageId: \"split\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                        // initialized\n                        context.report({\n                            node,\n                            messageId: \"splitInitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                        // uninitialized\n                        context.report({\n                            node,\n                            messageId: \"splitUninitialized\",\n                            data: {\n                                type\n                            },\n                            fix: splitDeclarations(node)\n                        });\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            StaticBlock: startFunction, // StaticBlock creates a new scope for `var` variables\n\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n            VariableDeclaration: checkVariableDeclaration,\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n            \"StaticBlock:exit\": endFunction\n        };\n\n    }\n};\n"
        }
    ]
}