{
    "sourceFile": "node_modules/eslint/lib/rules/comma-style.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892214761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"comma-style\",\n                        url: \"https://eslint.style/rules/js/comma-style\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent comma style\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/comma-style\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n            expectedCommaFirst: \"',' should be placed first.\",\n            expectedCommaLast: \"',' should be placed last.\"\n        }\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.sourceCode;\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true,\n            NewExpression: true\n        };\n\n        if (context.options.length === 2 && Object.hasOwn(context.options[1], \"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\n                    ? style\n                    : \"between\";\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaFirst\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: commaToken.loc,\n                    messageId: \"expectedCommaLast\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken;\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\n                            : sourceCode.ast.tokens.at(-1);\n                    } else {\n                        previousItemToken = currentItemToken;\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n        if (!exceptions.NewExpression) {\n            nodes.NewExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n\n        return nodes;\n    }\n};\n"
        }
    ]
}