{
    "sourceFile": "node_modules/eslint/lib/rules/sort-vars.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            ignoreCase: false\n        }],\n\n        docs: {\n            description: \"Require variables within the same declaration block to be sorted\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/sort-vars\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\n        }\n    },\n\n    create(context) {\n        const [{ ignoreCase }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n                const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n                const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n                let fixed = false;\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    const lastVariableName = getSortableName(memo),\n                        currentVariableName = getSortableName(decl);\n\n                    if (currentVariableName < lastVariableName) {\n                        context.report({\n                            node: decl,\n                            messageId: \"sortVars\",\n                            fix(fixer) {\n                                if (unfixable || fixed) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange(\n                                    [idDeclarations[0].range[0], idDeclarations.at(-1).range[1]],\n                                    idDeclarations\n\n                                        // Clone the idDeclarations array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((declA, declB) => {\n                                            const aName = getSortableName(declA);\n                                            const bName = getSortableName(declB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of identifier declarations and the text between the originals\n                                        .reduce((sourceText, identifier, index) => {\n                                            const textAfterIdentifier = index === idDeclarations.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                                        }, \"\")\n\n                                );\n                            }\n                        });\n                        fixed = true;\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n"
        }
    ]
}