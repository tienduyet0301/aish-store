{
    "sourceFile": "node_modules/eslint/lib/rules/max-lines.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892217879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview enforce a maximum file length\n * @author Alberto RodrÃ­guez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates an array of numbers from `start` up to, but not including, `end`\n * @param {number} start The start of the range\n * @param {number} end The end of the range\n * @returns {number[]} The range of numbers\n */\nfunction range(start, end) {\n    return [...Array(end - start).keys()].map(x => x + start);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce a maximum number of lines per file\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/max-lines\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n        messages: {\n            exceed:\n                \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n        }\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (\n            typeof option === \"object\" &&\n            Object.hasOwn(option, \"max\")\n        ) {\n            max = option.max;\n        } else if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {number[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, {\n                    includeComments: true\n                });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, {\n                    includeComments: true\n                });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return range(start, end + 1);\n            }\n            return [];\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({\n                    lineNumber: i + 1,\n                    text\n                }));\n\n                /*\n                 * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.\n                 * That isn't a real line, so we shouldn't count it.\n                 */\n                if (lines.length > 1 && lines.at(-1).text === \"\") {\n                    lines.pop();\n                }\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = new Set(comments.flatMap(getLinesWithoutCode));\n\n                    lines = lines.filter(\n                        l => !commentLines.has(l.lineNumber)\n                    );\n                }\n\n                if (lines.length > max) {\n                    const loc = {\n                        start: {\n                            line: lines[max].lineNumber,\n                            column: 0\n                        },\n                        end: {\n                            line: sourceCode.lines.length,\n                            column: sourceCode.lines.at(-1).length\n                        }\n                    };\n\n                    context.report({\n                        loc,\n                        messageId: \"exceed\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}