{
    "sourceFile": "node_modules/eslint/lib/rules/no-eval.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892225085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\",\n    \"globalThis\"\n]);\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n * @param {ASTNode} node A node to check.\n * @param {string} name A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return astUtils.isSpecificMemberAccess(node, null, name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allowIndirect: false\n        }],\n\n        docs: {\n            description: \"Disallow the use of `eval()`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-eval\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"eval can be harmful.\"\n        }\n    },\n\n    create(context) {\n        const [{ allowIndirect }] = context.options;\n        const sourceCode = context.sourceCode;\n        let funcInfo = null;\n\n        /**\n         * Pushes a `this` scope (non-arrow function, class static block, or class field initializer) information to the stack.\n         * Top-level scopes are handled separately.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         * @param {ASTNode} node A node of the scope.\n         *      For functions, this is one of FunctionDeclaration, FunctionExpression.\n         *      For class static blocks, this is StaticBlock.\n         *      For class field initializers, this can be any node that is PropertyDefinition#value.\n         * @returns {void}\n         */\n        function enterThisScope(node) {\n            const strict = sourceCode.getScope(node).isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                isTopLevelOfScript: false,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         * @returns {void}\n         */\n        function exitThisScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         * @param {ASTNode} node A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const parent = node.parent;\n            const locationNode = node.type === \"MemberExpression\"\n                ? node.property\n                : node;\n\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\n                ? parent\n                : node;\n\n            context.report({\n                node: reportNode,\n                loc: locationNode.loc,\n                messageId: \"unexpected\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         * @param {eslint-scope.Scope} globalScope The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    /*\n                     * Optional call (`eval?.(\"code\")`) is not direct eval.\n                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\n                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\n                     */\n                    if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (astUtils.isSpecificId(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = sourceCode.getScope(node),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict),\n                    isTopLevelOfScript = node.sourceType !== \"module\" && !features.globalReturn;\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    isTopLevelOfScript,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"(node) {\n                const globalScope = sourceCode.getScope(node);\n\n                exitThisScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterThisScope,\n            \"FunctionDeclaration:exit\": exitThisScope,\n            FunctionExpression: enterThisScope,\n            \"FunctionExpression:exit\": exitThisScope,\n            \"PropertyDefinition > *.value\": enterThisScope,\n            \"PropertyDefinition > *.value:exit\": exitThisScope,\n            StaticBlock: enterThisScope,\n            \"StaticBlock:exit\": exitThisScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                // `this` at the top level of scripts always refers to the global object\n                if (funcInfo.isTopLevelOfScript || (!funcInfo.strict && funcInfo.defaultThis)) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}