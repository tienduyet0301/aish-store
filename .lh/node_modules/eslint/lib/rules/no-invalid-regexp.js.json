{
    "sourceFile": "node_modules/eslint/lib/rules/no-invalid-regexp.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"@eslint-community/regexpp\").RegExpValidator;\nconst validator = new RegExpValidator();\nconst validFlags = \"dgimsuvy\";\nconst undefined1 = void 0;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{}],\n\n        docs: {\n            description: \"Disallow invalid regular expression strings in `RegExp` constructors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-invalid-regexp\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            regexMessage: \"{{message}}.\"\n        }\n    },\n\n    create(context) {\n        const [{ allowConstructorFlags }] = context.options;\n        let allowedFlags = [];\n\n        if (allowConstructorFlags) {\n            const temp = allowConstructorFlags.join(\"\").replace(new RegExp(`[${validFlags}]`, \"gu\"), \"\");\n\n            if (temp) {\n                allowedFlags = [...new Set(temp)];\n            }\n        }\n\n        /**\n         * Reports error with the provided message.\n         * @param {ASTNode} node The node holding the invalid RegExp\n         * @param {string} message The message to report.\n         * @returns {void}\n         */\n        function report(node, message) {\n            context.report({\n                node,\n                messageId: \"regexMessage\",\n                data: { message }\n            });\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\n         * Examples:\n         *     new RegExp(\".\")         // => \"\"\n         *     new RegExp(\".\", \"gu\")   // => \"gu\"\n         *     new RegExp(\".\", flags)  // => null\n         * @param {ASTNode} node `CallExpression` or `NewExpression` node\n         * @returns {string|null} flags if they can be determined, `null` otherwise\n         * @private\n         */\n        function getFlags(node) {\n            if (node.arguments.length < 2) {\n                return \"\";\n            }\n\n            if (isString(node.arguments[1])) {\n                return node.arguments[1].value;\n            }\n\n            return null;\n        }\n\n        /**\n         * Check syntax error in a given pattern.\n         * @param {string} pattern The RegExp pattern to validate.\n         * @param {Object} flags The RegExp flags to validate.\n         * @param {boolean} [flags.unicode] The Unicode flag.\n         * @param {boolean} [flags.unicodeSets] The UnicodeSets flag.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpPattern(pattern, flags) {\n            try {\n                validator.validatePattern(pattern, undefined1, undefined1, flags);\n                return null;\n            } catch (err) {\n                return err.message;\n            }\n        }\n\n        /**\n         * Check syntax error in a given flags.\n         * @param {string|null} flags The RegExp flags to validate.\n         * @param {string|null} flagsToCheck The RegExp invalid flags.\n         * @param {string} allFlags all valid and allowed flags.\n         * @returns {string|null} The syntax error.\n         */\n        function validateRegExpFlags(flags, flagsToCheck, allFlags) {\n            const duplicateFlags = [];\n\n            if (typeof flagsToCheck === \"string\") {\n                for (const flag of flagsToCheck) {\n                    if (allFlags.includes(flag)) {\n                        duplicateFlags.push(flag);\n                    }\n                }\n            }\n\n            /*\n             * `regexpp` checks the combination of `u` and `v` flags when parsing `Pattern` according to `ecma262`,\n             * but this rule may check only the flag when the pattern is unidentifiable, so check it here.\n             * https://tc39.es/ecma262/multipage/text-processing.html#sec-parsepattern\n             */\n            if (flags && flags.includes(\"u\") && flags.includes(\"v\")) {\n                return \"Regex 'u' and 'v' flags cannot be used together\";\n            }\n\n            if (duplicateFlags.length > 0) {\n                return `Duplicate flags ('${duplicateFlags.join(\"\")}') supplied to RegExp constructor`;\n            }\n\n            if (!flagsToCheck) {\n                return null;\n            }\n\n            return `Invalid flags supplied to RegExp constructor '${flagsToCheck}'`;\n        }\n\n        return {\n            \"CallExpression, NewExpression\"(node) {\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\") {\n                    return;\n                }\n\n                const flags = getFlags(node);\n                let flagsToCheck = flags;\n                const allFlags = allowedFlags.length > 0 ? validFlags.split(\"\").concat(allowedFlags) : validFlags.split(\"\");\n\n                if (flags) {\n                    allFlags.forEach(flag => {\n                        flagsToCheck = flagsToCheck.replace(flag, \"\");\n                    });\n                }\n\n                let message = validateRegExpFlags(flags, flagsToCheck, allFlags);\n\n                if (message) {\n                    report(node, message);\n                    return;\n                }\n\n                if (!isString(node.arguments[0])) {\n                    return;\n                }\n\n                const pattern = node.arguments[0].value;\n\n                message = (\n\n                    // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n                    flags === null\n                        ? (\n                            validateRegExpPattern(pattern, { unicode: true, unicodeSets: false }) &&\n                            validateRegExpPattern(pattern, { unicode: false, unicodeSets: true }) &&\n                            validateRegExpPattern(pattern, { unicode: false, unicodeSets: false })\n                        )\n                        : validateRegExpPattern(pattern, { unicode: flags.includes(\"u\"), unicodeSets: flags.includes(\"v\") })\n                );\n\n                if (message) {\n                    report(node, message);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}