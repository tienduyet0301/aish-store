{
    "sourceFile": "node_modules/eslint/lib/rules/no-promise-executor-return.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892229868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow returning values from Promise executor functions\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { findVariable } = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst functionTypesToCheck = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\n\n/**\n * Determines whether the given identifier node is a reference to a global variable.\n * @param {ASTNode} node `Identifier` node to check.\n * @param {Scope} scope Scope to which the node belongs.\n * @returns {boolean} True if the identifier is a reference to a global variable.\n */\nfunction isGlobalReference(node, scope) {\n    const variable = findVariable(scope, node);\n\n    return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n}\n\n/**\n * Finds function's outer scope.\n * @param {Scope} scope Function's own scope.\n * @returns {Scope} Function's outer scope.\n */\nfunction getOuterScope(scope) {\n    const upper = scope.upper;\n\n    if (upper.type === \"function-expression-name\") {\n        return upper.upper;\n    }\n    return upper;\n}\n\n/**\n * Determines whether the given function node is used as a Promise executor.\n * @param {ASTNode} node The node to check.\n * @param {Scope} scope Function's own scope.\n * @returns {boolean} `true` if the node is a Promise executor.\n */\nfunction isPromiseExecutor(node, scope) {\n    const parent = node.parent;\n\n    return parent.type === \"NewExpression\" &&\n        parent.arguments[0] === node &&\n        parent.callee.type === \"Identifier\" &&\n        parent.callee.name === \"Promise\" &&\n        isGlobalReference(parent.callee, getOuterScope(scope));\n}\n\n/**\n * Checks if the given node is a void expression.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} - `true` if the node is a void expression\n */\nfunction expressionIsVoid(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n\n/**\n * Fixes the linting error by prepending \"void \" to the given node\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction voidPrependFixer(sourceCode, node, fixer) {\n\n    const requiresParens =\n\n        // prepending `void ` will fail if the node has a lower precedence than void\n        astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\", operator: \"void\" }) &&\n\n        // check if there are parentheses around the node to avoid redundant parentheses\n        !astUtils.isParenthesised(sourceCode, node);\n\n    // avoid parentheses issues\n    const returnOrArrowToken = sourceCode.getTokenBefore(\n        node,\n        node.parent.type === \"ArrowFunctionExpression\"\n            ? astUtils.isArrowToken\n\n            // isReturnToken\n            : token => token.type === \"Keyword\" && token.value === \"return\"\n    );\n\n    const firstToken = sourceCode.getTokenAfter(returnOrArrowToken);\n\n    const prependSpace =\n\n        // is return token, as => allows void to be adjacent\n        returnOrArrowToken.value === \"return\" &&\n\n        // If two tokens (return and \"(\") are adjacent\n        returnOrArrowToken.range[1] === firstToken.range[0];\n\n    return [\n        fixer.insertTextBefore(firstToken, `${prependSpace ? \" \" : \"\"}void ${requiresParens ? \"(\" : \"\"}`),\n        fixer.insertTextAfter(node, requiresParens ? \")\" : \"\")\n    ];\n}\n\n/**\n * Fixes the linting error by `wrapping {}` around the given node's body.\n * @param {Object} sourceCode context given by context.sourceCode\n * @param {ASTNode} node The node to fix.\n * @param {Object} fixer The fixer object provided by ESLint.\n * @returns {Array<Object>} - An array of fix objects to apply to the node.\n */\nfunction curlyWrapFixer(sourceCode, node, fixer) {\n\n    // https://github.com/eslint/eslint/pull/17282#issuecomment-1592795923\n    const arrowToken = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n    const firstToken = sourceCode.getTokenAfter(arrowToken);\n    const lastToken = sourceCode.getLastToken(node);\n\n    return [\n        fixer.insertTextBefore(firstToken, \"{\"),\n        fixer.insertTextAfter(lastToken, \"}\")\n    ];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            allowVoid: false\n        }],\n\n        docs: {\n            description: \"Disallow returning values from Promise executor functions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-promise-executor-return\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowVoid: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            returnsValue: \"Return values from promise executor functions cannot be read.\",\n\n            // arrow and function suggestions\n            prependVoid: \"Prepend `void` to the expression.\",\n\n            // only arrow suggestions\n            wrapBraces: \"Wrap the expression in `{}`.\"\n        }\n    },\n\n    create(context) {\n        let funcInfo = null;\n        const sourceCode = context.sourceCode;\n        const [{ allowVoid }] = context.options;\n\n        return {\n\n            onCodePathStart(_, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    shouldCheck:\n                        functionTypesToCheck.has(node.type) &&\n                        isPromiseExecutor(node, sourceCode.getScope(node))\n                };\n\n                if (// Is a Promise executor\n                    funcInfo.shouldCheck &&\n                    node.type === \"ArrowFunctionExpression\" &&\n                    node.expression &&\n\n                    // Except void\n                    !(allowVoid && expressionIsVoid(node.body))\n                ) {\n                    const suggest = [];\n\n                    // prevent useless refactors\n                    if (allowVoid) {\n                        suggest.push({\n                            messageId: \"prependVoid\",\n                            fix(fixer) {\n                                return voidPrependFixer(sourceCode, node.body, fixer);\n                            }\n                        });\n                    }\n\n                    // Do not suggest wrapping an unnamed FunctionExpression in braces as that would be invalid syntax.\n                    if (!(node.body.type === \"FunctionExpression\" && !node.body.id)) {\n                        suggest.push({\n                            messageId: \"wrapBraces\",\n                            fix(fixer) {\n                                return curlyWrapFixer(sourceCode, node, fixer);\n                            }\n                        });\n                    }\n\n                    context.report({\n                        node: node.body,\n                        messageId: \"returnsValue\",\n                        suggest\n                    });\n                }\n            },\n\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            ReturnStatement(node) {\n                if (!(funcInfo.shouldCheck && node.argument)) {\n                    return;\n                }\n\n                // node is `return <expression>`\n                if (!allowVoid) {\n                    context.report({ node, messageId: \"returnsValue\" });\n                    return;\n                }\n\n                if (expressionIsVoid(node.argument)) {\n                    return;\n                }\n\n                // allowVoid && !expressionIsVoid\n                context.report({\n                    node,\n                    messageId: \"returnsValue\",\n                    suggest: [{\n                        messageId: \"prependVoid\",\n                        fix(fixer) {\n                            return voidPrependFixer(sourceCode, node.argument, fixer);\n                        }\n                    }]\n                });\n            }\n        };\n    }\n};\n"
        }
    ]
}