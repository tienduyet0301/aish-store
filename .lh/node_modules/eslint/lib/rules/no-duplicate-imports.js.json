{
    "sourceFile": "node_modules/eslint/lib/rules/no-duplicate-imports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892223240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\n    \"ImportNamespaceSpecifier\",\n    \"ExportNamespaceSpecifier\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\n * @param {string} importExportType An import/export type to check.\n * @param {string} type Can be \"named\" or \"namespace\"\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\n */\nfunction isImportExportSpecifier(importExportType, type) {\n    const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n\n    return arrayToCheck.includes(importExportType);\n}\n\n/**\n * Return the type of (import|export).\n * @param {ASTNode} node A node to get.\n * @returns {string} The type of the (import|export).\n */\nfunction getImportExportType(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n        const nodeSpecifiers = node.specifiers;\n        const index = nodeSpecifiers.findIndex(\n            ({ type }) =>\n                isImportExportSpecifier(type, \"named\") ||\n                isImportExportSpecifier(type, \"namespace\")\n        );\n        const i = index > -1 ? index : 0;\n\n        return nodeSpecifiers[i].type;\n    }\n    if (node.type === \"ExportAllDeclaration\") {\n        if (node.exported) {\n            return \"ExportNamespaceSpecifier\";\n        }\n        return \"ExportAll\";\n    }\n    return \"SideEffectImport\";\n}\n\n/**\n * Returns a boolean indicates if two (import|export) can be merged\n * @param {ASTNode} node1 A node to check.\n * @param {ASTNode} node2 A node to check.\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\n */\nfunction isImportExportCanBeMerged(node1, node2) {\n    const importExportType1 = getImportExportType(node1);\n    const importExportType2 = getImportExportType(node2);\n\n    if (\n        (importExportType1 === \"ExportAll\" &&\n            importExportType2 !== \"ExportAll\" &&\n            importExportType2 !== \"SideEffectImport\") ||\n        (importExportType1 !== \"ExportAll\" &&\n            importExportType1 !== \"SideEffectImport\" &&\n            importExportType2 === \"ExportAll\")\n    ) {\n        return false;\n    }\n    if (\n        (isImportExportSpecifier(importExportType1, \"namespace\") &&\n            isImportExportSpecifier(importExportType2, \"named\")) ||\n        (isImportExportSpecifier(importExportType2, \"namespace\") &&\n            isImportExportSpecifier(importExportType1, \"named\"))\n    ) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Returns a boolean if we should report (import|export).\n * @param {ASTNode} node A node to be reported or not.\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\n * @returns {boolean} True if the (import|export) should be reported.\n */\nfunction shouldReportImportExport(node, previousNodes) {\n    let i = 0;\n\n    while (i < previousNodes.length) {\n        if (isImportExportCanBeMerged(node, previousNodes[i])) {\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\n/**\n * Returns array contains only nodes with declarations types equal to type.\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\n * @param {string} type Declaration type.\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\n */\nfunction getNodesByDeclarationType(nodes, type) {\n    return nodes\n        .filter(({ declarationType }) => declarationType === type)\n        .map(({ node }) => node);\n}\n\n/**\n * Returns the name of the module imported or re-exported.\n * @param {ASTNode} node A node to get.\n * @returns {string} The name of the module, or empty string if no name.\n */\nfunction getModule(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n    return \"\";\n}\n\n/**\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\n * @param {RuleContext} context The ESLint rule context object.\n * @param {ASTNode} node A node to get.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {void} No return value.\n */\nfunction checkAndReport(\n    context,\n    node,\n    modules,\n    declarationType,\n    includeExports\n) {\n    const module = getModule(node);\n\n    if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        const messagesIds = [];\n        const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n        let exportNodes;\n\n        if (includeExports) {\n            exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n        }\n        if (declarationType === \"import\") {\n            if (shouldReportImportExport(node, importNodes)) {\n                messagesIds.push(\"import\");\n            }\n            if (includeExports) {\n                if (shouldReportImportExport(node, exportNodes)) {\n                    messagesIds.push(\"importAs\");\n                }\n            }\n        } else if (declarationType === \"export\") {\n            if (shouldReportImportExport(node, exportNodes)) {\n                messagesIds.push(\"export\");\n            }\n            if (shouldReportImportExport(node, importNodes)) {\n                messagesIds.push(\"exportAs\");\n            }\n        }\n        messagesIds.forEach(messageId =>\n            context.report({\n                node,\n                messageId,\n                data: {\n                    module\n                }\n            }));\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node A node to handle.\n */\n\n/**\n * Returns a function handling the (imports|exports) of a given file\n * @param {RuleContext} context The ESLint rule context object.\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\n * @param {string} declarationType A declaration type can be an import or export.\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImportsExports(\n    context,\n    modules,\n    declarationType,\n    includeExports\n) {\n    return function(node) {\n        const module = getModule(node);\n\n        if (module) {\n            checkAndReport(\n                context,\n                node,\n                modules,\n                declarationType,\n                includeExports\n            );\n            const currentNode = { node, declarationType };\n            let nodes = [currentNode];\n\n            if (modules.has(module)) {\n                const previousNodes = modules.get(module);\n\n                nodes = [...previousNodes, currentNode];\n            }\n            modules.set(module, nodes);\n        }\n    };\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            includeExports: false\n        }],\n\n        docs: {\n            description: \"Disallow duplicate module imports\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-duplicate-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    includeExports: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            import: \"'{{module}}' import is duplicated.\",\n            importAs: \"'{{module}}' import is duplicated as export.\",\n            export: \"'{{module}}' export is duplicated.\",\n            exportAs: \"'{{module}}' export is duplicated as import.\"\n        }\n    },\n\n    create(context) {\n        const [{ includeExports }] = context.options;\n        const modules = new Map();\n        const handlers = {\n            ImportDeclaration: handleImportsExports(\n                context,\n                modules,\n                \"import\",\n                includeExports\n            )\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleImportsExports(\n                context,\n                modules,\n                \"export\",\n                includeExports\n            );\n            handlers.ExportAllDeclaration = handleImportsExports(\n                context,\n                modules,\n                \"export\",\n                includeExports\n            );\n        }\n        return handlers;\n    }\n};\n"
        }
    ]
}