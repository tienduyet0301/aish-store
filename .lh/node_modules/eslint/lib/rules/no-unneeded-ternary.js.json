{
    "sourceFile": "node_modules/eslint/lib/rules/no-unneeded-ternary.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({ type: \"LogicalExpression\", operator: \"||\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{ defaultAssignment: true }],\n\n        docs: {\n            description: \"Disallow ternary operators when simpler alternatives exist\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unneeded-ternary\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n            unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n        }\n    },\n\n    create(context) {\n        const [{ defaultAssignment }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.hasOwn(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n                const text = sourceCode.getText();\n\n                return text.slice(node.range[0],\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalExpression\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryConditionalAssignment\",\n                        fix(fixer) {\n                            const shouldParenthesizeAlternate =\n                                (\n                                    astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE ||\n                                    astUtils.isCoalesceExpression(node.alternate)\n                                ) &&\n                                !astUtils.isParenthesised(sourceCode, node.alternate);\n                            const alternateText = shouldParenthesizeAlternate\n                                ? `(${sourceCode.getText(node.alternate)})`\n                                : astUtils.getParenthesisedText(sourceCode, node.alternate);\n                            const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n\n                            return fixer.replaceText(node, `${testText} || ${alternateText}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}