{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-object-spread.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892236909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead\n * @author Sharmila Jesupaul\n */\n\n\"use strict\";\n\nconst { CALL, ReferenceTracker } = require(\"@eslint-community/eslint-utils\");\nconst {\n    isCommaToken,\n    isOpeningParenToken,\n    isClosingParenToken,\n    isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n\n/**\n * Helper that checks if the Object.assign call has array spread\n * @param {ASTNode} node The node that the rule warns on\n * @returns {boolean} - Returns true if the Object.assign call has array spread\n */\nfunction hasArraySpread(node) {\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n\n/**\n * Determines whether the given node is an accessor property (getter/setter).\n * @param {ASTNode} node Node to check.\n * @returns {boolean} `true` if the node is a getter or a setter.\n */\nfunction isAccessorProperty(node) {\n    return node.type === \"Property\" &&\n        (node.kind === \"get\" || node.kind === \"set\");\n}\n\n/**\n * Determines whether the given object expression node has accessor properties (getters/setters).\n * @param {ASTNode} node `ObjectExpression` node to check.\n * @returns {boolean} `true` if the node has at least one getter/setter.\n */\nfunction hasAccessors(node) {\n    return node.properties.some(isAccessorProperty);\n}\n\n/**\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\n * @param {ASTNode} node `CallExpression` node to check.\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\n */\nfunction hasArgumentsWithAccessors(node) {\n    return node.arguments\n        .filter(arg => arg.type === \"ObjectExpression\")\n        .some(hasAccessors);\n}\n\n/**\n * Helper that checks if the node needs parentheses to be valid JS.\n * The default is to wrap the node in parentheses to avoid parsing errors.\n * @param {ASTNode} node The node that the rule warns on\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} - Returns true if the node needs parentheses\n */\nfunction needsParens(node, sourceCode) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"VariableDeclarator\":\n        case \"ArrayExpression\":\n        case \"ReturnStatement\":\n        case \"CallExpression\":\n        case \"Property\":\n            return false;\n        case \"AssignmentExpression\":\n            return parent.left === node && !isParenthesised(sourceCode, node);\n        default:\n            return !isParenthesised(sourceCode, node);\n    }\n}\n\n/**\n * Determines if an argument needs parentheses. The default is to not add parens.\n * @param {ASTNode} node The node to be checked.\n * @param {Object} sourceCode in context sourcecode object\n * @returns {boolean} True if the node needs parentheses\n */\nfunction argNeedsParens(node, sourceCode) {\n    switch (node.type) {\n        case \"AssignmentExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ConditionalExpression\":\n            return !isParenthesised(sourceCode, node);\n        default:\n            return false;\n    }\n}\n\n/**\n * Get the parenthesis tokens of a given ObjectExpression node.\n * This includes the braces of the object literal and enclosing parentheses.\n * @param {ASTNode} node The node to get.\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\n */\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n    let leftNext = sourceCode.getTokenBefore(node);\n    let rightNext = sourceCode.getTokenAfter(node);\n\n    // Note: don't include the parens of the argument list.\n    while (\n        leftNext &&\n        rightNext &&\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\n        isOpeningParenToken(leftNext) &&\n        isClosingParenToken(rightNext)\n    ) {\n        parens.push(leftNext, rightNext);\n        leftNext = sourceCode.getTokenBefore(leftNext);\n        rightNext = sourceCode.getTokenAfter(rightNext);\n    }\n\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The end of the range of the token and around whitespaces.\n */\nfunction getStartWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let start = token.range[0];\n\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\n    {\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\n\n        if (prevToken && prevToken.type === \"Line\") {\n            return start;\n        }\n    }\n\n    // Detect spaces before the token.\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\n        start -= 1;\n    }\n\n    return start;\n}\n\n/**\n * Get the range of a given token and around whitespaces.\n * @param {Token} token The token to get range.\n * @param {SourceCode} sourceCode The source code object to get tokens.\n * @returns {number} The start of the range of the token and around whitespaces.\n */\nfunction getEndWithSpaces(token, sourceCode) {\n    const text = sourceCode.text;\n    let end = token.range[1];\n\n    // Detect spaces after the token.\n    while (ANY_SPACE.test(text[end] || \"\")) {\n        end += 1;\n    }\n\n    return end;\n}\n\n/**\n * Autofixes the Object.assign call to use an object spread instead.\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\n * @param {string} sourceCode sourceCode of the Object.assign call\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\n */\nfunction defineFixer(node, sourceCode) {\n    return function *(fixer) {\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n        const rightParen = sourceCode.getLastToken(node);\n\n        // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n        yield fixer.removeRange([node.range[0], leftParen.range[0]]);\n\n        // Replace the parens of argument list to braces.\n        if (needsParens(node, sourceCode)) {\n            yield fixer.replaceText(leftParen, \"({\");\n            yield fixer.replaceText(rightParen, \"})\");\n        } else {\n            yield fixer.replaceText(leftParen, \"{\");\n            yield fixer.replaceText(rightParen, \"}\");\n        }\n\n        // Process arguments.\n        for (const argNode of node.arguments) {\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n            const left = innerParens.shift();\n            const right = innerParens.pop();\n\n            if (argNode.type === \"ObjectExpression\") {\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\n\n                /*\n                 * Make bare this object literal.\n                 * And remove spaces inside of the braces for better formatting.\n                 */\n                for (const innerParen of innerParens) {\n                    yield fixer.remove(innerParen);\n                }\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n                const rightRange = [\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n                    right.range[1]\n                ];\n\n                yield fixer.removeRange(leftRange);\n                yield fixer.removeRange(rightRange);\n\n                // Remove the comma of this argument if it's duplication.\n                if (\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\n                    isCommaToken(maybeArgumentComma)\n                ) {\n                    yield fixer.remove(maybeArgumentComma);\n                }\n            } else {\n\n                // Make spread.\n                if (argNeedsParens(argNode, sourceCode)) {\n                    yield fixer.insertTextBefore(left, \"...(\");\n                    yield fixer.insertTextAfter(right, \")\");\n                } else {\n                    yield fixer.insertTextBefore(left, \"...\");\n                }\n            }\n        }\n    };\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description:\n                \"Disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/prefer-object-spread\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        return {\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Object: {\n                        assign: { [CALL]: true }\n                    }\n                };\n\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n                for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {\n                    if (\n                        refNode.arguments.length >= 1 &&\n                        refNode.arguments[0].type === \"ObjectExpression\" &&\n                        !hasArraySpread(refNode) &&\n                        !(\n                            refNode.arguments.length > 1 &&\n                            hasArgumentsWithAccessors(refNode)\n                        )\n                    ) {\n                        const messageId = refNode.arguments.length === 1\n                            ? \"useLiteralMessage\"\n                            : \"useSpreadMessage\";\n                        const fix = defineFixer(refNode, sourceCode);\n\n                        context.report({ node: refNode, messageId, fix });\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}