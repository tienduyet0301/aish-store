{
    "sourceFile": "node_modules/eslint/lib/rules/space-unary-ops.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"space-unary-ops\",\n                        url: \"https://eslint.style/rules/js/space-unary-ops\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent spacing before or after unary operators\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/space-unary-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\",\n                        default: true\n                    },\n                    nonwords: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n         * @param {ASTnode} node AST node\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n         */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n         * Checks if an override exists for a given operator.\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override has been provided for the operator\n         */\n        function overrideExistsForOperator(operator) {\n            return options.overrides && Object.hasOwn(options.overrides, operator);\n        }\n\n        /**\n         * Gets the value that the override was set to for this operator\n         * @param {string} operator Operator\n         * @returns {boolean} Whether or not an override enforces a space with this operator\n         */\n        function overrideEnforcesSpaces(operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n         * Verify Unary Word Operator has spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    messageId: \"wordOperator\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Verify Unary Word Operator doesn't have spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfterWord\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check Unary Word Operators for spaces after the word operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken first token from the AST node\n         * @param {Object} secondToken second token from the AST node\n         * @param {string} word The word to be used for reporting\n         * @returns {void}\n         */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            if (overrideExistsForOperator(word)) {\n                if (overrideEnforcesSpaces(word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n         * Verifies YieldExpressions satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n         * Verifies AwaitExpressions satisfy spacing requirements\n         * @param {ASTNode} node AwaitExpression AST node\n         * @returns {void}\n         */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"operator\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        messageId: \"beforeUnaryExpressions\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n         * @param {ASTnode} node AST node\n         * @param {Object} firstToken First token in the expression\n         * @param {Object} secondToken Second token in the expression\n         * @returns {void}\n         */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedAfter\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedBefore\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n         * @param {ASTnode} node AST node\n         * @returns {void}\n         */\n        function checkForSpaces(node) {\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\n                ? sourceCode.getLastTokens(node, 2)\n                : sourceCode.getFirstTokens(node, 2);\n            const firstToken = tokens[0];\n            const secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(operator)) {\n                if (overrideEnforcesSpaces(operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n"
        }
    ]
}