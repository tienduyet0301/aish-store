{
    "sourceFile": "node_modules/eslint/lib/rules/no-shadow.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892231313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FUNC_EXPR_NODE_TYPES = new Set([\"ArrowFunctionExpression\", \"FunctionExpression\"]);\nconst CALL_EXPR_NODE_TYPE = new Set([\"CallExpression\"]);\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allow: [],\n            builtinGlobals: false,\n            hoist: \"functions\",\n            ignoreOnInitialization: false\n        }],\n\n        docs: {\n            description: \"Disallow variable declarations from shadowing variables declared in the outer scope\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-shadow\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\" },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"] },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    ignoreOnInitialization: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n            noShadowGlobal: \"'{{name}}' is already a global variable.\"\n        }\n    },\n\n    create(context) {\n        const [{\n            builtinGlobals,\n            hoist,\n            allow,\n            ignoreOnInitialization\n        }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks whether or not a given location is inside of the range of a given node.\n         * @param {ASTNode} node An node to check.\n         * @param {number} location A location to check.\n         * @returns {boolean} `true` if the location is inside of the range of the node.\n         */\n        function isInRange(node, location) {\n            return node && node.range[0] <= location && location <= node.range[1];\n        }\n\n        /**\n         * Searches from the current node through its ancestry to find a matching node.\n         * @param {ASTNode} node a node to get.\n         * @param {(node: ASTNode) => boolean} match a callback that checks whether or not the node verifies its condition or not.\n         * @returns {ASTNode|null} the matching node.\n         */\n        function findSelfOrAncestor(node, match) {\n            let currentNode = node;\n\n            while (currentNode && !match(currentNode)) {\n                currentNode = currentNode.parent;\n            }\n            return currentNode;\n        }\n\n        /**\n         * Finds function's outer scope.\n         * @param {Scope} scope Function's own scope.\n         * @returns {Scope} Function's outer scope.\n         */\n        function getOuterScope(scope) {\n            const upper = scope.upper;\n\n            if (upper.type === \"function-expression-name\") {\n                return upper.upper;\n            }\n            return upper;\n        }\n\n        /**\n         * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\n         * @param {Object} variable a variable to check.\n         * @param {Object} shadowedVariable a shadowedVariable to check.\n         * @returns {boolean} Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\n         */\n        function isInitPatternNode(variable, shadowedVariable) {\n            const outerDef = shadowedVariable.defs[0];\n\n            if (!outerDef) {\n                return false;\n            }\n\n            const { variableScope } = variable.scope;\n\n\n            if (!(FUNC_EXPR_NODE_TYPES.has(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {\n                return false;\n            }\n\n            const fun = variableScope.block;\n            const { parent } = fun;\n\n            const callExpression = findSelfOrAncestor(\n                parent,\n                node => CALL_EXPR_NODE_TYPE.has(node.type)\n            );\n\n            if (!callExpression) {\n                return false;\n            }\n\n            let node = outerDef.name;\n            const location = callExpression.range[1];\n\n            while (node) {\n                if (node.type === \"VariableDeclarator\") {\n                    if (isInRange(node.init, location)) {\n                        return true;\n                    }\n                    if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                        isInRange(node.parent.parent.right, location)\n                    ) {\n                        return true;\n                    }\n                    break;\n                } else if (node.type === \"AssignmentPattern\") {\n                    if (isInRange(node.right, location)) {\n                        return true;\n                    }\n                } else if (SENTINEL_TYPE.test(node.type)) {\n                    break;\n                }\n\n                node = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check if variable name is allowed.\n         * @param {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return allow.includes(variable.name);\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                 inner &&\n                 outer[0] < inner[0] &&\n                 inner[1] < outer[1] &&\n                 ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                 outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Get declared line and column of a variable.\n         * @param {eslint-scope.Variable} variable The variable to get.\n         * @returns {Object} The declared line and column of the variable.\n         */\n        function getDeclaredLocation(variable) {\n            const identifier = variable.identifiers[0];\n            let obj;\n\n            if (identifier) {\n                obj = {\n                    global: false,\n                    line: identifier.loc.start.line,\n                    column: identifier.loc.start.column + 1\n                };\n            } else {\n                obj = {\n                    global: true\n                };\n            }\n            return obj;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                 outer &&\n                 inner[1] < outer[0] &&\n\n                 // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                 (hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                     isDuplicatedClassNameVariable(variable) ||\n                     isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                      (shadowed.identifiers.length > 0 || (builtinGlobals && \"writeable\" in shadowed)) &&\n                      !isOnInitializer(variable, shadowed) &&\n                      !(ignoreOnInitialization && isInitPatternNode(variable, shadowed)) &&\n                      !(hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    const location = getDeclaredLocation(shadowed);\n                    const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\n                    const data = { name: variable.name };\n\n                    if (!location.global) {\n                        data.shadowedLine = location.line;\n                        data.shadowedColumn = location.column;\n                    }\n                    context.report({\n                        node: variable.identifiers[0],\n                        messageId,\n                        data\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"(node) {\n                const globalScope = sourceCode.getScope(node);\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push(...scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}