{
    "sourceFile": "node_modules/eslint/lib/rules/use-isnan.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892240507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given node is a NaN `Identifier` node.\n * @param {ASTNode|null} node The node to check.\n * @returns {boolean} `true` if the node is 'NaN' identifier.\n */\nfunction isNaNIdentifier(node) {\n    if (!node) {\n        return false;\n    }\n\n    const nodeToCheck = node.type === \"SequenceExpression\"\n        ? node.expressions.at(-1)\n        : node;\n\n    return (\n        astUtils.isSpecificId(nodeToCheck, \"NaN\") ||\n        astUtils.isSpecificMemberAccess(nodeToCheck, \"Number\", \"NaN\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        hasSuggestions: true,\n        type: \"problem\",\n\n        docs: {\n            description: \"Require calls to `isNaN()` when checking for `NaN`\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/use-isnan\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    enforceForSwitchCase: {\n                        type: \"boolean\"\n                    },\n                    enforceForIndexOf: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        defaultOptions: [{\n            enforceForIndexOf: false,\n            enforceForSwitchCase: true\n        }],\n\n        messages: {\n            comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n            switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n            caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n            indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\",\n            replaceWithIsNaN: \"Replace with Number.isNaN.\",\n            replaceWithCastingAndIsNaN: \"Replace with Number.isNaN and cast to a Number.\",\n            replaceWithFindIndex: \"Replace with Array.prototype.{{ methodName }}.\"\n        }\n    },\n\n    create(context) {\n\n        const [{ enforceForIndexOf, enforceForSwitchCase }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        const fixableOperators = new Set([\"==\", \"===\", \"!=\", \"!==\"]);\n        const castableOperators = new Set([\"==\", \"!=\"]);\n\n        /**\n         * Get a fixer for a binary expression that compares to NaN.\n         * @param  {ASTNode} node The node to fix.\n         * @param {function(string): string} wrapValue A function that wraps the compared value with a fix.\n         * @returns {function(Fixer): Fix} The fixer function.\n         */\n        function getBinaryExpressionFixer(node, wrapValue) {\n            return fixer => {\n                const comparedValue = isNaNIdentifier(node.left) ? node.right : node.left;\n                const shouldWrap = comparedValue.type === \"SequenceExpression\";\n                const shouldNegate = node.operator[0] === \"!\";\n\n                const negation = shouldNegate ? \"!\" : \"\";\n                let comparedValueText = sourceCode.getText(comparedValue);\n\n                if (shouldWrap) {\n                    comparedValueText = `(${comparedValueText})`;\n                }\n\n                const fixedValue = wrapValue(comparedValueText);\n\n                return fixer.replaceText(node, `${negation}${fixedValue}`);\n            };\n        }\n\n        /**\n         * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkBinaryExpression(node) {\n            if (\n                /^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&\n                (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))\n            ) {\n                const suggestedFixes = [];\n                const NaNNode = isNaNIdentifier(node.left) ? node.left : node.right;\n\n                const isSequenceExpression = NaNNode.type === \"SequenceExpression\";\n                const isSuggestable = fixableOperators.has(node.operator) && !isSequenceExpression;\n                const isCastable = castableOperators.has(node.operator);\n\n                if (isSuggestable) {\n                    suggestedFixes.push({\n                        messageId: \"replaceWithIsNaN\",\n                        fix: getBinaryExpressionFixer(node, value => `Number.isNaN(${value})`)\n                    });\n\n                    if (isCastable) {\n                        suggestedFixes.push({\n                            messageId: \"replaceWithCastingAndIsNaN\",\n                            fix: getBinaryExpressionFixer(node, value => `Number.isNaN(Number(${value}))`)\n                        });\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"comparisonWithNaN\",\n                    suggest: suggestedFixes\n                });\n            }\n        }\n\n        /**\n         * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkSwitchStatement(node) {\n            if (isNaNIdentifier(node.discriminant)) {\n                context.report({ node, messageId: \"switchNaN\" });\n            }\n\n            for (const switchCase of node.cases) {\n                if (isNaNIdentifier(switchCase.test)) {\n                    context.report({ node: switchCase, messageId: \"caseNaN\" });\n                }\n            }\n        }\n\n        /**\n         * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkCallExpression(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"MemberExpression\") {\n                const methodName = astUtils.getStaticPropertyName(callee);\n\n                if (\n                    (methodName === \"indexOf\" || methodName === \"lastIndexOf\") &&\n                    node.arguments.length <= 2 &&\n                    isNaNIdentifier(node.arguments[0])\n                ) {\n\n                    /*\n                     * To retain side effects, it's essential to address `NaN` beforehand, which\n                     * is not possible with fixes like `arr.findIndex(Number.isNaN)`.\n                     */\n                    const isSuggestable = node.arguments[0].type !== \"SequenceExpression\" && !node.arguments[1];\n                    const suggestedFixes = [];\n\n                    if (isSuggestable) {\n                        const shouldWrap = callee.computed;\n                        const findIndexMethod = methodName === \"indexOf\" ? \"findIndex\" : \"findLastIndex\";\n                        const propertyName = shouldWrap ? `\"${findIndexMethod}\"` : findIndexMethod;\n\n                        suggestedFixes.push({\n                            messageId: \"replaceWithFindIndex\",\n                            data: { methodName: findIndexMethod },\n                            fix: fixer => [\n                                fixer.replaceText(callee.property, propertyName),\n                                fixer.replaceText(node.arguments[0], \"Number.isNaN\")\n                            ]\n                        });\n                    }\n\n                    context.report({\n                        node,\n                        messageId: \"indexOfNaN\",\n                        data: { methodName },\n                        suggest: suggestedFixes\n                    });\n                }\n            }\n        }\n\n        const listeners = {\n            BinaryExpression: checkBinaryExpression\n        };\n\n        if (enforceForSwitchCase) {\n            listeners.SwitchStatement = checkSwitchStatement;\n        }\n\n        if (enforceForIndexOf) {\n            listeners.CallExpression = checkCallExpression;\n        }\n\n        return listeners;\n    }\n};\n"
        }
    ]
}