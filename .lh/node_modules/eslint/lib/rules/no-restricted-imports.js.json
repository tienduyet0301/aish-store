{
    "sourceFile": "node_modules/eslint/lib/rules/no-restricted-imports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892230446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowImportNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"],\n                not: { required: [\"importNames\", \"allowImportNames\"] }\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjectPatterns = {\n    anyOf: [\n        {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    allowImportNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    group: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    regex: {\n                        type: \"string\"\n                    },\n                    importNamePattern: {\n                        type: \"string\"\n                    },\n                    allowImportNamePattern: {\n                        type: \"string\"\n                    },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    caseSensitive: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false,\n                not: {\n                    anyOf: [\n                        { required: [\"importNames\", \"allowImportNames\"] },\n                        { required: [\"importNamePattern\", \"allowImportNamePattern\"] },\n                        { required: [\"importNames\", \"allowImportNamePattern\"] },\n                        { required: [\"importNamePattern\", \"allowImportNames\"] },\n                        { required: [\"allowImportNames\", \"allowImportNamePattern\"] }\n                    ]\n                },\n                oneOf: [\n                    { required: [\"group\"] },\n                    { required: [\"regex\"] }\n                ]\n            },\n            uniqueItems: true\n        }\n    ]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified modules when loaded by `import`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n\n            patternAndImportName: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndImportNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n\n            patternAndEverything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.\",\n\n            patternAndEverythingWithRegexImportName: \"* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndEverythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndEverythingWithRegexImportNameAndCustomMessage: \"* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used. {{customMessage}}\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            allowedImportName: \"'{{importName}}' import from '{{importSource}}' is restricted because only '{{allowedImportNames}}' import(s) is/are allowed.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            allowedImportNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted because only '{{allowedImportNames}}' import(s) is/are allowed. {{customMessage}}\",\n\n            everythingWithAllowImportNames: \"* import is invalid because only '{{allowedImportNames}}' from '{{importSource}}' is/are allowed.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            everythingWithAllowImportNamesAndCustomMessage: \"* import is invalid because only '{{allowedImportNames}}' from '{{importSource}}' is/are allowed. {{customMessage}}\",\n\n            allowedImportNamePattern: \"'{{importName}}' import from '{{importSource}}' is restricted because only imports that match the pattern '{{allowedImportNamePattern}}' are allowed from '{{importSource}}'.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            allowedImportNamePatternWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted because only imports that match the pattern '{{allowedImportNamePattern}}' are allowed from '{{importSource}}'. {{customMessage}}\",\n\n            everythingWithAllowedImportNamePattern: \"* import is invalid because only imports that match the pattern '{{allowedImportNamePattern}}' from '{{importSource}}' are allowed.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            everythingWithAllowedImportNamePatternWithCustomMessage: \"* import is invalid because only imports that match the pattern '{{allowedImportNamePattern}}' from '{{importSource}}' are allowed. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStringsOrObjectPatterns\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.hasOwn(options[0], \"paths\") || Object.hasOwn(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const groupedRestrictedPaths = restrictedPaths.reduce((memo, importSource) => {\n            const path = typeof importSource === \"string\"\n                ? importSource\n                : importSource.name;\n\n            if (!memo[path]) {\n                memo[path] = [];\n            }\n\n            if (typeof importSource === \"string\") {\n                memo[path].push({});\n            } else {\n                memo[path].push({\n                    message: importSource.message,\n                    importNames: importSource.importNames,\n                    allowImportNames: importSource.allowImportNames\n                });\n            }\n            return memo;\n        }, Object.create(null));\n\n        // Handle patterns too, either as strings or groups\n        let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        // standardize to array of objects if we have an array of strings\n        if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\n            restrictedPatterns = [{ group: restrictedPatterns }];\n        }\n\n        // relative paths are supported for this rule\n        const restrictedPatternGroups = restrictedPatterns.map(\n            ({ group, regex, message, caseSensitive, importNames, importNamePattern, allowImportNames, allowImportNamePattern }) => (\n                {\n                    ...(group ? { matcher: ignore({ allowRelativePaths: true, ignorecase: !caseSensitive }).add(group) } : {}),\n                    ...(typeof regex === \"string\" ? { regexMatcher: new RegExp(regex, caseSensitive ? \"u\" : \"iu\") } : {}),\n                    customMessage: message,\n                    importNames,\n                    importNamePattern,\n                    allowImportNames,\n                    allowImportNamePattern\n                }\n            )\n        );\n\n        // if no imports are restricted we don't need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n            return {};\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\n            if (!Object.hasOwn(groupedRestrictedPaths, importSource)) {\n                return;\n            }\n\n            groupedRestrictedPaths[importSource].forEach(restrictedPathEntry => {\n                const customMessage = restrictedPathEntry.message;\n                const restrictedImportNames = restrictedPathEntry.importNames;\n                const allowedImportNames = restrictedPathEntry.allowImportNames;\n\n                if (!restrictedImportNames && !allowedImportNames) {\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                        data: {\n                            importSource,\n                            customMessage\n                        }\n                    });\n\n                    return;\n                }\n\n                importNames.forEach((specifiers, importName) => {\n                    if (importName === \"*\") {\n                        const [specifier] = specifiers;\n\n                        if (restrictedImportNames) {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    importNames: restrictedImportNames,\n                                    customMessage\n                                }\n                            });\n                        } else if (allowedImportNames) {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"everythingWithAllowImportNamesAndCustomMessage\" : \"everythingWithAllowImportNames\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    allowedImportNames,\n                                    customMessage\n                                }\n                            });\n                        }\n\n                        return;\n                    }\n\n                    if (restrictedImportNames && restrictedImportNames.includes(importName)) {\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName\n                                }\n                            });\n                        });\n                    }\n\n                    if (allowedImportNames && !allowedImportNames.includes(importName)) {\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                loc: specifier.loc,\n                                messageId: customMessage ? \"allowedImportNameWithCustomMessage\" : \"allowedImportName\",\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName,\n                                    allowedImportNames\n                                }\n                            });\n                        });\n                    }\n                });\n            });\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @param {Object} group contains an Ignore instance for paths, the customMessage to show on failure,\n         * and any restricted import names that have been specified in the config\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node, group, importNames) {\n            const importSource = node.source.value.trim();\n\n            const customMessage = group.customMessage;\n            const restrictedImportNames = group.importNames;\n            const restrictedImportNamePattern = group.importNamePattern ? new RegExp(group.importNamePattern, \"u\") : null;\n            const allowedImportNames = group.allowImportNames;\n            const allowedImportNamePattern = group.allowImportNamePattern ? new RegExp(group.allowImportNamePattern, \"u\") : null;\n\n            /**\n             * If we are not restricting to any specific import names and just the pattern itself,\n             * report the error and move on\n             */\n            if (!restrictedImportNames && !allowedImportNames && !restrictedImportNamePattern && !allowedImportNamePattern) {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n                return;\n            }\n\n            importNames.forEach((specifiers, importName) => {\n                if (importName === \"*\") {\n                    const [specifier] = specifiers;\n\n                    if (restrictedImportNames) {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"patternAndEverythingWithCustomMessage\" : \"patternAndEverything\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                importNames: restrictedImportNames,\n                                customMessage\n                            }\n                        });\n                    } else if (allowedImportNames) {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"everythingWithAllowImportNamesAndCustomMessage\" : \"everythingWithAllowImportNames\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                allowedImportNames,\n                                customMessage\n                            }\n                        });\n                    } else if (allowedImportNamePattern) {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"everythingWithAllowedImportNamePatternWithCustomMessage\" : \"everythingWithAllowedImportNamePattern\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                allowedImportNamePattern,\n                                customMessage\n                            }\n                        });\n                    } else {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"patternAndEverythingWithRegexImportNameAndCustomMessage\" : \"patternAndEverythingWithRegexImportName\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                importNames: restrictedImportNamePattern,\n                                customMessage\n                            }\n                        });\n                    }\n\n                    return;\n                }\n\n                if (\n                    (restrictedImportNames && restrictedImportNames.includes(importName)) ||\n                    (restrictedImportNamePattern && restrictedImportNamePattern.test(importName))\n                ) {\n                    specifiers.forEach(specifier => {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"patternAndImportNameWithCustomMessage\" : \"patternAndImportName\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                customMessage,\n                                importName\n                            }\n                        });\n                    });\n                }\n\n                if (allowedImportNames && !allowedImportNames.includes(importName)) {\n                    specifiers.forEach(specifier => {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"allowedImportNameWithCustomMessage\" : \"allowedImportName\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                customMessage,\n                                importName,\n                                allowedImportNames\n                            }\n                        });\n                    });\n                } else if (allowedImportNamePattern && !allowedImportNamePattern.test(importName)) {\n                    specifiers.forEach(specifier => {\n                        context.report({\n                            node,\n                            messageId: customMessage ? \"allowedImportNamePatternWithCustomMessage\" : \"allowedImportNamePattern\",\n                            loc: specifier.loc,\n                            data: {\n                                importSource,\n                                customMessage,\n                                importName,\n                                allowedImportNamePattern\n                            }\n                        });\n                    });\n                }\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource, group) {\n            return group.regexMatcher ? group.regexMatcher.test(importSource) : group.matcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = new Map();\n\n            if (node.type === \"ExportAllDeclaration\") {\n                const starToken = sourceCode.getFirstToken(node, 1);\n\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\n            } else if (node.specifiers) {\n                for (const specifier of node.specifiers) {\n                    let name;\n                    const specifierData = { loc: specifier.loc };\n\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        name = \"default\";\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        name = \"*\";\n                    } else if (specifier.imported) {\n                        name = astUtils.getModuleExportName(specifier.imported);\n                    } else if (specifier.local) {\n                        name = astUtils.getModuleExportName(specifier.local);\n                    }\n\n                    if (typeof name === \"string\") {\n                        if (importNames.has(name)) {\n                            importNames.get(name).push(specifierData);\n                        } else {\n                            importNames.set(name, [specifierData]);\n                        }\n                    }\n                }\n            }\n\n            checkRestrictedPathAndReport(importSource, importNames, node);\n            restrictedPatternGroups.forEach(group => {\n                if (isRestrictedPattern(importSource, group)) {\n                    reportPathForPatterns(node, group, importNames);\n                }\n            });\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n"
        }
    ]
}