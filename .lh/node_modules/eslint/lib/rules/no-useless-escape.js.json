{
    "sourceFile": "node_modules/eslint/lib/rules/no-useless-escape.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892233210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"@eslint-community/regexpp\");\n\n/**\n * @typedef {import('@eslint-community/regexpp').AST.CharacterClass} CharacterClass\n * @typedef {import('@eslint-community/regexpp').AST.ExpressionCharacterClass} ExpressionCharacterClass\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the union of two sets.\n * @param {Set} setA The first set\n * @param {Set} setB The second set\n * @returns {Set} The union of the two sets\n */\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n\n/*\n * Set of characters that require escaping in character classes in `unicodeSets` mode.\n * ( ) [ ] { } / - \\ | are ClassSetSyntaxCharacter\n */\nconst REGEX_CLASSSET_CHARACTER_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"q/[{}|()-\"));\n\n/*\n * A single character set of ClassSetReservedDoublePunctuator.\n * && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~ are ClassSetReservedDoublePunctuator\n */\nconst REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR = new Set(\"!#$%&*+,.:;<=>?@^`~\");\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary escape characters\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-escape\"\n        },\n\n        hasSuggestions: true,\n\n        messages: {\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n            removeEscapeDoNotKeepSemantics: \"Remove the `\\\\` if it was inserted by mistake.\",\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const parser = new RegExpParser();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @param {boolean} [disableEscapeBackslashSuggest] `true` if escapeBackslash suggestion should be turned off.\n         * @returns {void}\n         */\n        function report(node, startOffset, character, disableEscapeBackslashSuggest) {\n            const rangeStart = node.range[0] + startOffset;\n            const range = [rangeStart, rangeStart + 1];\n            const start = sourceCode.getLocFromIndex(rangeStart);\n\n            context.report({\n                node,\n                loc: {\n                    start,\n                    end: { line: start.line, column: start.column + 1 }\n                },\n                messageId: \"unnecessaryEscape\",\n                data: { character },\n                suggest: [\n                    {\n\n                        // Removing unnecessary `\\` characters in a directive is not guaranteed to maintain functionality.\n                        messageId: astUtils.isDirective(node.parent)\n                            ? \"removeEscapeDoNotKeepSemantics\" : \"removeEscape\",\n                        fix(fixer) {\n                            return fixer.removeRange(range);\n                        }\n                    },\n                    ...disableEscapeBackslashSuggest\n                        ? []\n                        : [\n                            {\n                                messageId: \"escapeBackslash\",\n                                fix(fixer) {\n                                    return fixer.insertTextBeforeRange(range, \"\\\\\");\n                                }\n                            }\n                        ]\n                ]\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @param {string} match string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /*\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if the escape character in given regexp is unnecessary.\n         * @private\n         * @param {ASTNode} node node to validate.\n         * @returns {void}\n         */\n        function validateRegExp(node) {\n            const { pattern, flags } = node.regex;\n            let patternNode;\n            const unicode = flags.includes(\"u\");\n            const unicodeSets = flags.includes(\"v\");\n\n            try {\n                patternNode = parser.parsePattern(pattern, 0, pattern.length, { unicode, unicodeSets });\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            /** @type {(CharacterClass | ExpressionCharacterClass)[]} */\n            const characterClassStack = [];\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),\n                onCharacterClassLeave: () => characterClassStack.shift(),\n                onExpressionCharacterClassEnter: characterClassNode => characterClassStack.unshift(characterClassNode),\n                onExpressionCharacterClassLeave: () => characterClassStack.shift(),\n                onCharacterEnter(characterNode) {\n                    if (!characterNode.raw.startsWith(\"\\\\\")) {\n\n                        // It's not an escaped character.\n                        return;\n                    }\n\n                    const escapedChar = characterNode.raw.slice(1);\n\n                    if (escapedChar !== String.fromCodePoint(characterNode.value)) {\n\n                        // It's a valid escape.\n                        return;\n                    }\n                    let allowedEscapes;\n\n                    if (characterClassStack.length) {\n                        allowedEscapes = unicodeSets ? REGEX_CLASSSET_CHARACTER_ESCAPES : REGEX_GENERAL_ESCAPES;\n                    } else {\n                        allowedEscapes = REGEX_NON_CHARCLASS_ESCAPES;\n                    }\n                    if (allowedEscapes.has(escapedChar)) {\n                        return;\n                    }\n\n                    const reportedIndex = characterNode.start + 1;\n                    let disableEscapeBackslashSuggest = false;\n\n                    if (characterClassStack.length) {\n                        const characterClassNode = characterClassStack[0];\n\n                        if (escapedChar === \"^\") {\n\n                            /*\n                             * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                             * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                             * account for this, consider it to be a valid escape character outside of character classes, and filter\n                             * out '^' characters that appear at the start of a character class.\n                             */\n                            if (characterClassNode.start + 1 === characterNode.start) {\n\n                                return;\n                            }\n                        }\n                        if (!unicodeSets) {\n                            if (escapedChar === \"-\") {\n\n                                /*\n                                 * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                                 * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                                 * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                                 * character class.\n                                 */\n                                if (characterClassNode.start + 1 !== characterNode.start && characterNode.end !== characterClassNode.end - 1) {\n\n                                    return;\n                                }\n                            }\n                        } else { // unicodeSets mode\n                            if (REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR.has(escapedChar)) {\n\n                                // Escaping is valid if it is a ClassSetReservedDoublePunctuator.\n                                if (pattern[characterNode.end] === escapedChar) {\n                                    return;\n                                }\n                                if (pattern[characterNode.start - 1] === escapedChar) {\n                                    if (escapedChar !== \"^\") {\n                                        return;\n                                    }\n\n                                    // If the previous character is a `negate` caret(`^`), escape to caret is unnecessary.\n\n                                    if (!characterClassNode.negate) {\n                                        return;\n                                    }\n                                    const negateCaretIndex = characterClassNode.start + 1;\n\n                                    if (negateCaretIndex < characterNode.start - 1) {\n                                        return;\n                                    }\n                                }\n                            }\n\n                            if (characterNode.parent.type === \"ClassIntersection\" || characterNode.parent.type === \"ClassSubtraction\") {\n                                disableEscapeBackslashSuggest = true;\n                            }\n                        }\n                    }\n\n                    report(\n                        node,\n                        reportedIndex,\n                        escapedChar,\n                        disableEscapeBackslashSuggest\n                    );\n                }\n            });\n        }\n\n        /**\n         * Checks if a node has an escape.\n         * @param {ASTNode} node node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n                const pattern = /\\\\[^\\d]/gu;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                validateRegExp(node);\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n"
        }
    ]
}