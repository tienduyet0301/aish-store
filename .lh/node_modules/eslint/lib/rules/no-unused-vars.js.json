{
    "sourceFile": "node_modules/eslint/lib/rules/no-unused-vars.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * A simple name for the types of variables that this rule supports\n * @typedef {'array-destructure'|'catch-clause'|'parameter'|'variable'} VariableType\n */\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n/**\n * Bag of data used for formatting the `usedIgnoredVar` lint message.\n * @typedef {Object} UsedIgnoredVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unused variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-vars\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            destructuredArrayIgnorePattern: {\n                                type: \"string\"\n                            },\n                            ignoreClassWithStaticInitBlock: {\n                                type: \"boolean\"\n                            },\n                            reportUsedIgnorePattern: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\",\n            usedIgnoredVar: \"'{{varName}}' is marked as ignored but is used{{additional}}.\",\n            removeVar: \"Remove unused variable '{{varName}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"all\",\n            ignoreClassWithStaticInitBlock: false,\n            reportUsedIgnorePattern: false\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n                config.ignoreClassWithStaticInitBlock = firstOption.ignoreClassWithStaticInitBlock || config.ignoreClassWithStaticInitBlock;\n                config.reportUsedIgnorePattern = firstOption.reportUsedIgnorePattern || config.reportUsedIgnorePattern;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.destructuredArrayIgnorePattern) {\n                    config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Determines what variable type a def is.\n         * @param  {Object} def the declaration to check\n         * @returns {VariableType} a simple name for the types of variables that this rule supports\n         */\n        function defToVariableType(def) {\n\n            /*\n             * This `destructuredArrayIgnorePattern` error report works differently from the catch\n             * clause and parameter error reports. _Both_ the `varsIgnorePattern` and the\n             * `destructuredArrayIgnorePattern` will be checked for array destructuring. However,\n             * for the purposes of the report, the currently defined behavior is to only inform the\n             * user of the `destructuredArrayIgnorePattern` if it's present (regardless of the fact\n             * that the `varsIgnorePattern` would also apply). If it's not present, the user will be\n             * informed of the `varsIgnorePattern`, assuming that's present.\n             */\n            if (config.destructuredArrayIgnorePattern && def.name.parent.type === \"ArrayPattern\") {\n                return \"array-destructure\";\n            }\n\n            switch (def.type) {\n                case \"CatchClause\":\n                    return \"catch-clause\";\n                case \"Parameter\":\n                    return \"parameter\";\n\n                default:\n                    return \"variable\";\n            }\n        }\n\n        /**\n         * Gets a given variable's description and configured ignore pattern\n         * based on the provided variableType\n         * @param {VariableType} variableType a simple name for the types of variables that this rule supports\n         * @throws {Error} (Unreachable)\n         * @returns {[string | undefined, string | undefined]} the given variable's description and\n         * ignore pattern\n         */\n        function getVariableDescription(variableType) {\n            let pattern;\n            let variableDescription;\n\n            switch (variableType) {\n                case \"array-destructure\":\n                    pattern = config.destructuredArrayIgnorePattern;\n                    variableDescription = \"elements of array destructuring\";\n                    break;\n\n                case \"catch-clause\":\n                    pattern = config.caughtErrorsIgnorePattern;\n                    variableDescription = \"caught errors\";\n                    break;\n\n                case \"parameter\":\n                    pattern = config.argsIgnorePattern;\n                    variableDescription = \"args\";\n                    break;\n\n                case \"variable\":\n                    pattern = config.varsIgnorePattern;\n                    variableDescription = \"vars\";\n                    break;\n\n                default:\n                    throw new Error(`Unexpected variable type: ${variableType}`);\n            }\n\n            if (pattern) {\n                pattern = pattern.toString();\n            }\n\n            return [variableDescription, pattern];\n        }\n\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const def = unusedVar.defs && unusedVar.defs[0];\n            let additionalMessageData = \"\";\n\n            if (def) {\n                const [variableDescription, pattern] = getVariableDescription(defToVariableType(def));\n\n                if (pattern && variableDescription) {\n                    additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern}`;\n                }\n            }\n\n            return {\n                varName: unusedVar.name,\n                action: \"defined\",\n                additional: additionalMessageData\n            };\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const def = unusedVar.defs && unusedVar.defs[0];\n            let additionalMessageData = \"\";\n\n            if (def) {\n                const [variableDescription, pattern] = getVariableDescription(defToVariableType(def));\n\n                if (pattern && variableDescription) {\n                    additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern}`;\n                }\n            }\n\n            return {\n                varName: unusedVar.name,\n                action: \"assigned a value\",\n                additional: additionalMessageData\n            };\n        }\n\n        /**\n         * Generate the warning message about a variable being used even though\n         * it is marked as being ignored.\n         * @param {Variable} variable eslint-scope variable object\n         * @param {VariableType} variableType a simple name for the types of variables that this rule supports\n         * @returns {UsedIgnoredVarMessageData} The message data to be used with\n         * this used ignored variable.\n         */\n        function getUsedIgnoredMessageData(variable, variableType) {\n            const [variableDescription, pattern] = getVariableDescription(variableType);\n\n            let additionalMessageData = \"\";\n\n            if (pattern && variableDescription) {\n                additionalMessageData = `. Used ${variableDescription} must not match ${pattern}`;\n            }\n\n            return {\n                varName: variable.name,\n                additional: additionalMessageData\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Checks whether a node is a sibling of the rest property or not.\n         * @param {ASTNode} node a node to check\n         * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n         */\n        function hasRestSibling(node) {\n            return node.type === \"Property\" &&\n                node.parent.type === \"ObjectPattern\" &&\n                REST_PROPERTY_TYPE.test(node.parent.properties.at(-1).type);\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable has a sibling rest property, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n                const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n\n                return hasRestSiblingDefinition || hasRestSiblingReference;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.includes(scope.block)) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * Checks whether a given node is unused expression or not.\n         * @param {ASTNode} node The node itself\n         * @returns {boolean} The node is an unused expression.\n         * @private\n         */\n        function isUnusedExpression(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"ExpressionStatement\") {\n                return true;\n            }\n\n            if (parent.type === \"SequenceExpression\") {\n                const isLastExpression = parent.expressions.at(-1) === node;\n\n                if (!isLastExpression) {\n                    return true;\n                }\n                return isUnusedExpression(parent);\n            }\n\n            return false;\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                isUnusedExpression(parent) &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions.at(-1) !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    (\n                        parent.type === \"AssignmentExpression\" &&\n                        parent.left === id &&\n                        isUnusedExpression(parent) &&\n                        !astUtils.isLogicalAssignmentOperator(parent.operator)\n                    ) ||\n                    (\n                        parent.type === \"UpdateExpression\" &&\n                        isUnusedExpression(parent)\n                    )\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in or for-of loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInOfRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\" && target.type !== \"ForOfStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            if (variable.eslintUsed) {\n                return true;\n            }\n\n            const functionNodes = getFunctionDefinitions(variable);\n            const isFunctionDefinition = functionNodes.length > 0;\n\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInOfRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = sourceCode.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names\n                    if (scope.functionExpressionScope) {\n                        continue;\n                    }\n\n                    // skip variables marked with markVariableAsUsed()\n                    if (!config.reportUsedIgnorePattern && variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n                        const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\");\n\n                        // skip elements of array destructuring patterns\n                        if (\n                            (\n                                def.name.parent.type === \"ArrayPattern\" ||\n                                refUsedInArrayPatterns\n                            ) &&\n                            config.destructuredArrayIgnorePattern &&\n                            config.destructuredArrayIgnorePattern.test(def.name.name)\n                        ) {\n                            if (config.reportUsedIgnorePattern && isUsedVariable(variable)) {\n                                context.report({\n                                    node: def.name,\n                                    messageId: \"usedIgnoredVar\",\n                                    data: getUsedIgnoredMessageData(variable, \"array-destructure\")\n                                });\n                            }\n\n                            continue;\n                        }\n\n                        if (type === \"ClassName\") {\n                            const hasStaticBlock = def.node.body.body.some(node => node.type === \"StaticBlock\");\n\n                            if (config.ignoreClassWithStaticInitBlock && hasStaticBlock) {\n                                continue;\n                            }\n                        }\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                if (config.reportUsedIgnorePattern && isUsedVariable(variable)) {\n                                    context.report({\n                                        node: def.name,\n                                        messageId: \"usedIgnoredVar\",\n                                        data: getUsedIgnoredMessageData(variable, \"catch-clause\")\n                                    });\n                                }\n\n                                continue;\n                            }\n                        } else if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                if (config.reportUsedIgnorePattern && isUsedVariable(variable)) {\n                                    context.report({\n                                        node: def.name,\n                                        messageId: \"usedIgnoredVar\",\n                                        data: getUsedIgnoredMessageData(variable, \"parameter\")\n                                    });\n                                }\n\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                if (config.reportUsedIgnorePattern && isUsedVariable(variable)) {\n                                    context.report({\n                                        node: def.name,\n                                        messageId: \"usedIgnoredVar\",\n                                        data: getUsedIgnoredMessageData(variable, \"variable\")\n                                    });\n                                }\n\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        /**\n         * fixes unused variables\n         * @param {Object} fixer fixer object\n         * @param {Object} unusedVar unused variable to fix\n         * @returns {Object} fixer object\n         */\n        function handleFixes(fixer, unusedVar) {\n            const id = unusedVar.identifiers[0];\n            const parent = id.parent;\n            const parentType = parent.type;\n            const tokenBefore = sourceCode.getTokenBefore(id);\n            const tokenAfter = sourceCode.getTokenAfter(id);\n            const isFunction = astUtils.isFunction;\n            const isLoop = astUtils.isLoop;\n            const allWriteReferences = unusedVar.references.filter(ref => ref.isWrite());\n\n            /**\n             * get range from token before of a given node\n             * @param {ASTNode} node node of identifier\n             * @param {number} skips number of token to skip\n             * @returns {number} start range of token before the identifier\n             */\n            function getPreviousTokenStart(node, skips) {\n                return sourceCode.getTokenBefore(node, skips).range[0];\n            }\n\n            /**\n             * get range to token after of a given node\n             * @param {ASTNode} node node of identifier\n             * @param {number} skips number of token to skip\n             * @returns {number} end range of token after the identifier\n             */\n            function getNextTokenEnd(node, skips) {\n                return sourceCode.getTokenAfter(node, skips).range[1];\n            }\n\n            /**\n             * get the value of token before of a given node\n             * @param {ASTNode} node node of identifier\n             * @returns {string} value of token before the identifier\n             */\n            function getTokenBeforeValue(node) {\n                return sourceCode.getTokenBefore(node).value;\n            }\n\n            /**\n             * get the value of token after of a given node\n             * @param {ASTNode} node node of identifier\n             * @returns {string} value of token after the identifier\n             */\n            function getTokenAfterValue(node) {\n                return sourceCode.getTokenAfter(node).value;\n            }\n\n            /**\n             * Check if an array has a single element with null as other element.\n             * @param {ASTNode} node ArrayPattern node\n             * @returns {boolean} true if array has single element with other null elements\n             */\n            function hasSingleElement(node) {\n                return node.elements.filter(e => e !== null).length === 1;\n            }\n\n            /**\n             * check whether import specifier has an import of particular type\n             * @param {ASTNode} node ImportDeclaration node\n             * @param {string} type type of import to check\n             * @returns {boolean} true if import specifier has import of specified type\n             */\n            function hasImportOfCertainType(node, type) {\n                return node.specifiers.some(e => e.type === type);\n            }\n\n            /**\n             * Check whether declaration is safe to remove or not\n             * @param {ASTNode} nextToken next token of unused variable\n             * @param {ASTNode} prevToken previous token of unused variable\n             * @returns {boolean} true if declaration is not safe to remove\n             */\n            function isDeclarationNotSafeToRemove(nextToken, prevToken) {\n                return (\n                    (nextToken.type === \"String\") ||\n                    (\n                        prevToken &&\n                        !astUtils.isSemicolonToken(prevToken) &&\n                        !astUtils.isOpeningBraceToken(prevToken)\n                    )\n                );\n            }\n\n            /**\n             * give fixes for unused variables in function parameters\n             * @param {ASTNode} node node to check\n             * @returns {Object} fixer object\n             */\n            function fixFunctionParameters(node) {\n                const parentNode = node.parent;\n\n                if (isFunction(parentNode)) {\n\n                    // remove unused function parameter if there is only a single parameter\n                    if (parentNode.params.length === 1) {\n                        return fixer.removeRange(node.range);\n                    }\n\n                    // remove first unused function parameter when there are multiple parameters\n                    if (getTokenBeforeValue(node) === \"(\" && getTokenAfterValue(node) === \",\") {\n                        return fixer.removeRange([node.range[0], getNextTokenEnd(node)]);\n                    }\n\n                    // remove unused function parameters except first one when there are multiple parameters\n                    return fixer.removeRange([getPreviousTokenStart(node), node.range[1]]);\n                }\n\n                return null;\n            }\n\n            /**\n             * fix unused variable declarations and function parameters\n             * @param {ASTNode} node parent node to identifier\n             * @returns {Object} fixer object\n             */\n            function fixVariables(node) {\n                const parentNode = node.parent;\n\n                // remove unused declared variables such as var a = b; or var a = b, c;\n                if (parentNode.type === \"VariableDeclarator\") {\n\n                    // skip variable in for (const [ foo ] of bar);\n                    if (isLoop(parentNode.parent.parent)) {\n                        return null;\n                    }\n\n                    /*\n                     * remove unused declared variable with single declaration such as 'var a = b;'\n                     * remove complete declaration when there is an unused variable in 'const { a } = foo;', same for arrays.\n                     */\n                    if (parentNode.parent.declarations.length === 1) {\n\n                        // if next token is a string it could become a directive if node is removed -> no suggestion.\n                        const nextToken = sourceCode.getTokenAfter(parentNode.parent);\n\n                        // if previous token exists and is not \";\" or \"{\" not sure about ASI rules -> no suggestion.\n                        const prevToken = sourceCode.getTokenBefore(parentNode.parent);\n\n                        if (nextToken && isDeclarationNotSafeToRemove(nextToken, prevToken)) {\n                            return null;\n                        }\n\n                        return fixer.removeRange(parentNode.parent.range);\n                    }\n\n                    /*\n                     * remove unused declared variable with multiple declaration except first one such as 'var a = b, c = d;'\n                     * fix 'let bar = \"hello\", { a } = foo;' to 'let bar = \"hello\";' if 'a' is unused, same for arrays.\n                     */\n                    if (getTokenBeforeValue(parentNode) === \",\") {\n                        return fixer.removeRange([getPreviousTokenStart(parentNode), parentNode.range[1]]);\n                    }\n\n                    /*\n                     * remove first unused declared variable when there are multiple declarations\n                     * fix 'let { a } = foo, bar = \"hello\";' to 'let  bar = \"hello\";' if 'a' is unused, same for arrays.\n                     */\n                    return fixer.removeRange([parentNode.range[0], getNextTokenEnd(parentNode)]);\n                }\n\n                // fixes [{a: {k}}], [{a: [k]}]\n                if (getTokenBeforeValue(node) === \":\") {\n                    if (parentNode.parent.type === \"ObjectPattern\") {\n                        // eslint-disable-next-line no-use-before-define -- due to interdependency of functions\n                        return fixObjectWithValueSeparator(node);\n                    }\n                }\n\n                // fix unused function parameters\n                return fixFunctionParameters(node);\n            }\n\n            /**\n             * fix nested object like { a: { b } }\n             * @param {ASTNode} node parent node to check\n             * @returns {Object} fixer object\n             */\n            function fixNestedObjectVariable(node) {\n                const parentNode = node.parent;\n\n                // fix for { a: { b: { c: { d } } } }\n                if (\n                    parentNode.parent.parent.parent.type === \"ObjectPattern\" &&\n                        parentNode.parent.properties.length === 1\n                ) {\n                    return fixNestedObjectVariable(parentNode.parent);\n                }\n\n                // fix for { a: { b } }\n                if (parentNode.parent.type === \"ObjectPattern\") {\n\n                    // fix for unused variables in dectructured object with single property in variable decalartion and function parameter\n                    if (parentNode.parent.properties.length === 1) {\n                        return fixVariables(parentNode.parent);\n                    }\n\n                    // fix for first unused property when there are multiple properties such as '{ a: { b }, c }'\n                    if (getTokenBeforeValue(parentNode) === \"{\") {\n                        return fixer.removeRange(\n                            [parentNode.range[0], getNextTokenEnd(parentNode)]\n                        );\n                    }\n\n                    // fix for unused property except first one when there are multiple properties such as '{ k, a: { b } }'\n                    return fixer.removeRange([getPreviousTokenStart(parentNode), parentNode.range[1]]);\n                }\n\n                return null;\n            }\n\n            /**\n             * fix unused variables in array and nested array\n             * @param {ASTNode} node parent node to check\n             * @returns {Object} fixer object\n             */\n            function fixNestedArrayVariable(node) {\n                const parentNode = node.parent;\n\n                // fix for nested arrays [[ a ]]\n                if (parentNode.parent.type === \"ArrayPattern\" && hasSingleElement(parentNode)) {\n                    return fixNestedArrayVariable(parentNode);\n                }\n\n                if (hasSingleElement(parentNode)) {\n\n                    // fixes { a: [{ b }] } or { a: [[ b ]] }\n                    if (getTokenBeforeValue(parentNode) === \":\") {\n                        return fixVariables(parentNode);\n                    }\n\n                    // fixes [a, ...[[ b ]]] or [a, ...[{ b }]]\n                    if (parentNode.parent.type === \"RestElement\") {\n                        // eslint-disable-next-line no-use-before-define -- due to interdependency of functions\n                        return fixRestInPattern(parentNode.parent);\n                    }\n\n                    // fix unused variables in destructured array in variable declaration or function parameter\n                    return fixVariables(parentNode);\n                }\n\n                // remove last unused array element\n                if (\n                    getTokenBeforeValue(node) === \",\" &&\n                        getTokenAfterValue(node) === \"]\"\n                ) {\n                    return fixer.removeRange([getPreviousTokenStart(node), node.range[1]]);\n                }\n\n                // remove unused array element\n                return fixer.removeRange(node.range);\n            }\n\n            /**\n             * fix cases like {a: {k}} or {a: [k]}\n             * @param {ASTNode} node parent node to check\n             * @returns {Object} fixer object\n             */\n            function fixObjectWithValueSeparator(node) {\n                const parentNode = node.parent.parent;\n\n                // fix cases like [{a : { b }}] or [{a : [ b ]}]\n                if (\n                    parentNode.parent.type === \"ArrayPattern\" &&\n                        parentNode.properties.length === 1\n                ) {\n                    return fixNestedArrayVariable(parentNode);\n                }\n\n                // fix cases like {a: {k}} or {a: [k]}\n                return fixNestedObjectVariable(node);\n            }\n\n            /**\n             * fix ...[[a]] or ...[{a}] like patterns\n             * @param {ASTNode} node parent node to check\n             * @returns {Object} fixer object\n             */\n            function fixRestInPattern(node) {\n                const parentNode = node.parent;\n\n                // fix ...[[a]] or ...[{a}] in function parameters\n                if (isFunction(parentNode)) {\n                    if (parentNode.params.length === 1) {\n                        return fixer.removeRange(node.range);\n                    }\n\n                    return fixer.removeRange([getPreviousTokenStart(node), node.range[1]]);\n                }\n\n                // fix rest in nested array pattern like [[a, ...[b]]]\n                if (parentNode.type === \"ArrayPattern\") {\n\n                    // fix [[...[b]]]\n                    if (hasSingleElement(parentNode)) {\n                        if (parentNode.parent.type === \"ArrayPattern\") {\n                            return fixNestedArrayVariable(parentNode);\n                        }\n\n                        // fix 'const [...[b]] = foo; and function foo([...[b]]) {}\n                        return fixVariables(parentNode);\n                    }\n\n                    // fix [[a, ...[b]]]\n                    return fixer.removeRange([getPreviousTokenStart(node), node.range[1]]);\n                }\n\n                return null;\n            }\n\n            // skip fix when variable has references that would be left behind\n            if (allWriteReferences.some(ref => ref.identifier.range[0] !== id.range[0])) {\n                return null;\n            }\n\n            // remove declared variables such as var a; or var a, b;\n            if (parentType === \"VariableDeclarator\") {\n                if (parent.parent.declarations.length === 1) {\n\n                    // prevent fix of variable in forOf and forIn loops.\n                    if (isLoop(parent.parent.parent) && parent.parent.parent.body !== parent.parent) {\n                        return null;\n                    }\n\n                    // removes only variable not semicolon in 'if (foo()) var bar;' or in 'loops' or in 'with' statement.\n                    if (\n                        parent.parent.parent.type === \"IfStatement\" ||\n                        isLoop(parent.parent.parent) ||\n                        (parent.parent.parent.type === \"WithStatement\" && parent.parent.parent.body === parent.parent)\n                    ) {\n                        return fixer.replaceText(parent.parent, \";\");\n                    }\n\n                    // if next token is a string it could become a directive if node is removed -> no suggestion.\n                    const nextToken = sourceCode.getTokenAfter(parent.parent);\n\n                    // if previous token exists and is not \";\" or \"{\" not sure about ASI rules -> no suggestion.\n                    const prevToken = sourceCode.getTokenBefore(parent.parent);\n\n                    if (nextToken && isDeclarationNotSafeToRemove(nextToken, prevToken)) {\n                        return null;\n                    }\n\n                    // remove unused declared variable with single declaration like 'var a = b;'\n                    return fixer.removeRange(parent.parent.range);\n                }\n\n                // remove unused declared variable with multiple declaration except first one like 'var a = b, c = d;'\n                if (tokenBefore.value === \",\") {\n                    return fixer.removeRange([tokenBefore.range[0], parent.range[1]]);\n                }\n\n                // remove first unused declared variable when there are multiple declarations\n                return fixer.removeRange([parent.range[0], getNextTokenEnd(parent)]);\n            }\n\n            // remove variables in object patterns\n            if (parent.parent.type === \"ObjectPattern\") {\n                if (parent.parent.properties.length === 1) {\n\n                    // fix [a, ...{b}]\n                    if (parent.parent.parent.type === \"RestElement\") {\n                        return fixRestInPattern(parent.parent.parent);\n                    }\n\n                    // fix [{ a }]\n                    if (parent.parent.parent.type === \"ArrayPattern\") {\n                        return fixNestedArrayVariable(parent.parent);\n                    }\n\n                    /*\n                     * var {a} = foo;\n                     * function a({a}) {}\n                     * fix const { a: { b } } = foo;\n                     */\n                    return fixVariables(parent.parent);\n                }\n\n                // fix const { a:b } = foo;\n                if (tokenBefore.value === \":\") {\n\n                    // remove first unused variable in const { a:b } = foo;\n                    if (getTokenBeforeValue(parent) === \"{\" && getTokenAfterValue(parent) === \",\") {\n                        return fixer.removeRange([parent.range[0], getNextTokenEnd(parent)]);\n                    }\n\n                    // remove unused variables in const { a: b, c: d } = foo; except first one\n                    return fixer.removeRange([getPreviousTokenStart(parent), id.range[1]]);\n                }\n            }\n\n            // remove unused variables inside an array\n            if (parentType === \"ArrayPattern\") {\n                if (hasSingleElement(parent)) {\n\n                    // fix [a, ...[b]]\n                    if (parent.parent.type === \"RestElement\") {\n                        return fixRestInPattern(parent.parent);\n                    }\n\n                    // fix [ [a] ]\n                    if (parent.parent.type === \"ArrayPattern\") {\n                        return fixNestedArrayVariable(parent);\n                    }\n\n                    /*\n                     * fix var [a] = foo;\n                     * fix function foo([a]) {}\n                     * fix const { a: [b] } = foo;\n                     */\n                    return fixVariables(parent);\n                }\n\n                // if \"a\" is unused in [a, b ,c] fixes to [, b, c]\n                if (tokenBefore.value === \",\" && tokenAfter.value === \",\") {\n                    return fixer.removeRange(id.range);\n                }\n            }\n\n            // remove unused rest elements\n            if (parentType === \"RestElement\") {\n\n                // fix [a, ...rest]\n                if (parent.parent.type === \"ArrayPattern\") {\n                    if (hasSingleElement(parent.parent)) {\n\n                        // fix [[...rest]] when there is only rest element\n                        if (\n                            parent.parent.parent.type === \"ArrayPattern\"\n                        ) {\n                            return fixNestedArrayVariable(parent.parent);\n                        }\n\n                        // fix 'const [...rest] = foo;' and 'function foo([...rest]) {}'\n                        return fixVariables(parent.parent);\n                    }\n\n                    // fix [a, ...rest]\n                    return fixer.removeRange([getPreviousTokenStart(id, 1), id.range[1]]);\n                }\n\n                // fix { a, ...rest}\n                if (parent.parent.type === \"ObjectPattern\") {\n\n                    // fix 'const {...rest} = foo;' and 'function foo({...rest}) {}'\n                    if (parent.parent.properties.length === 1) {\n                        return fixVariables(parent.parent);\n                    }\n\n                    // fix { a, ...rest} when there are multiple properties\n                    return fixer.removeRange([getPreviousTokenStart(id, 1), id.range[1]]);\n                }\n\n                // fix function foo(...rest) {}\n                if (isFunction(parent.parent)) {\n\n                    // remove unused rest in function parameter if there is only single parameter\n                    if (parent.parent.params.length === 1) {\n                        return fixer.removeRange(parent.range);\n                    }\n\n                    // remove unused rest in function parameter if there multiple parameter\n                    return fixer.removeRange([getPreviousTokenStart(parent), parent.range[1]]);\n                }\n            }\n\n            if (parentType === \"AssignmentPattern\") {\n\n                // fix [a = aDefault]\n                if (parent.parent.type === \"ArrayPattern\") {\n                    return fixNestedArrayVariable(parent);\n                }\n\n                // fix {a = aDefault}\n                if (parent.parent.parent.type === \"ObjectPattern\") {\n                    if (parent.parent.parent.properties.length === 1) {\n\n                        // fixes [{a = aDefault}]\n                        if (parent.parent.parent.parent.type === \"ArrayPattern\") {\n                            return fixNestedArrayVariable(parent.parent.parent);\n                        }\n\n                        // fix 'const {a = aDefault} = foo;' and 'function foo({a = aDefault}) {}'\n                        return fixVariables(parent.parent.parent);\n                    }\n\n                    // fix unused 'a' in {a = aDefault} if it is the first property\n                    if (\n                        getTokenBeforeValue(parent.parent) === \"{\" &&\n                            getTokenAfterValue(parent.parent) === \",\"\n                    ) {\n                        return fixer.removeRange([parent.parent.range[0], getNextTokenEnd(parent.parent)]);\n                    }\n\n                    // fix unused 'b' in {a, b = aDefault} if it is not the first property\n                    return fixer.removeRange([getPreviousTokenStart(parent.parent), parent.parent.range[1]]);\n                }\n\n                // fix unused assignment patterns in function parameters\n                if (isFunction(parent.parent)) {\n                    return fixFunctionParameters(parent);\n                }\n            }\n\n            // remove unused functions\n            if (parentType === \"FunctionDeclaration\" && parent.id === id) {\n                return fixer.removeRange(parent.range);\n            }\n\n            // remove unused default import\n            if (parentType === \"ImportDefaultSpecifier\") {\n\n                // remove unused default import when there are not other imports\n                if (\n                    !hasImportOfCertainType(parent.parent, \"ImportSpecifier\") &&\n                    !hasImportOfCertainType(parent.parent, \"ImportNamespaceSpecifier\")\n                ) {\n                    return fixer.removeRange([parent.range[0], parent.parent.source.range[0]]);\n                }\n\n                // remove unused default import when there are other imports also\n                return fixer.removeRange([id.range[0], tokenAfter.range[1]]);\n            }\n\n            if (parentType === \"ImportSpecifier\") {\n\n                // remove unused imports when there is a single import\n                if (parent.parent.specifiers.filter(e => e.type === \"ImportSpecifier\").length === 1) {\n\n                    // remove unused import when there is no default import\n                    if (!hasImportOfCertainType(parent.parent, \"ImportDefaultSpecifier\")) {\n                        return fixer.removeRange(parent.parent.range);\n                    }\n\n                    // fixes \"import foo from 'module';\" to \"import 'module';\"\n                    return fixer.removeRange([getPreviousTokenStart(parent, 1), tokenAfter.range[1]]);\n                }\n\n                if (getTokenBeforeValue(parent) === \"{\") {\n                    return fixer.removeRange([parent.range[0], getNextTokenEnd(parent)]);\n                }\n\n                return fixer.removeRange([getPreviousTokenStart(parent), parent.range[1]]);\n            }\n\n            if (parentType === \"ImportNamespaceSpecifier\") {\n                if (hasImportOfCertainType(parent.parent, \"ImportDefaultSpecifier\")) {\n                    return fixer.removeRange([getPreviousTokenStart(parent), parent.range[1]]);\n                }\n\n                // fixes \"import * as foo from 'module';\" to \"import 'module';\"\n                return fixer.removeRange([parent.range[0], parent.parent.source.range[0]]);\n            }\n\n            // skip error in catch(error) variable\n            if (parentType === \"CatchClause\") {\n                return null;\n            }\n\n            // remove unused declared classes\n            if (parentType === \"ClassDeclaration\") {\n                return fixer.removeRange(parent.range);\n            }\n\n            // remove unused varible that is in a sequence [a,b] fixes to [a]\n            if (tokenBefore?.value === \",\") {\n                return fixer.removeRange([tokenBefore.range[0], id.range[1]]);\n            }\n\n            // remove unused varible that is in a sequence inside function arguments and object pattern\n            if (tokenAfter.value === \",\") {\n\n                // fix function foo(a, b) {}\n                if (tokenBefore.value === \"(\") {\n                    return fixer.removeRange([id.range[0], tokenAfter.range[1]]);\n                }\n\n                // fix const {a, b} = foo;\n                if (tokenBefore.value === \"{\") {\n                    return fixer.removeRange([id.range[0], tokenAfter.range[1]]);\n                }\n            }\n\n            if (parentType === \"ArrowFunctionExpression\" && parent.params.length === 1 && tokenAfter?.value !== \")\") {\n                return fixer.replaceText(id, \"()\");\n            }\n\n            return fixer.removeRange(id.range);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(sourceCode.getScope(programNode), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n\n                        // report last write reference, https://github.com/eslint/eslint/issues/14324\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n\n                        let referenceToReport;\n\n                        if (writeReferences.length > 0) {\n                            referenceToReport = writeReferences.at(-1);\n                        }\n\n                        context.report({\n                            node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n                            messageId: \"unusedVar\",\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar),\n                            suggest: [\n                                {\n                                    messageId: \"removeVar\",\n                                    data: {\n                                        varName: unusedVar.name\n                                    },\n                                    fix(fixer) {\n                                        return handleFixes(fixer, unusedVar);\n                                    }\n                                }\n                            ]\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            messageId: \"unusedVar\",\n                            data: getDefinedMessageData(unusedVar)\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}