{
    "sourceFile": "node_modules/eslint/lib/rules/no-misleading-character-class.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStaticValue,\n    getStringIfConstant\n} = require(\"@eslint-community/eslint-utils\");\nconst { RegExpParser, visitRegExpAST } = require(\"@eslint-community/regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\nconst astUtils = require(\"./utils/ast-utils.js\");\nconst { isValidWithUnicodeFlag } = require(\"./utils/regular-expressions\");\nconst { parseStringLiteral, parseTemplateToken } = require(\"./utils/char-source\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @typedef {import('@eslint-community/regexpp').AST.Character} Character\n * @typedef {import('@eslint-community/regexpp').AST.CharacterClassElement} CharacterClassElement\n */\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<Character[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n\n    /** @type {Character[]} */\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min);\n                yield seq;\n                seq = [node.max];\n                break;\n\n            case \"CharacterSet\":\n            case \"CharacterClass\": // [[]] nesting character class\n            case \"ClassStringDisjunction\": // \\q{...}\n            case \"ExpressionCharacterClass\": // [A--B]\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\n/**\n * Checks whether the given character node is a Unicode code point escape or not.\n * @param {Character} char the character node to check.\n * @returns {boolean} `true` if the character node is a Unicode code point escape.\n */\nfunction isUnicodeCodePointEscape(char) {\n    return /^\\\\u\\{[\\da-f]+\\}$/iu.test(char.raw);\n}\n\n/**\n * Each function returns matched characters if it detects that kind of problem.\n * @type {Record<string, (chars: Character[]) => IterableIterator<Character[]>>}\n */\nconst findCharacterSequences = {\n    *surrogatePairWithoutUFlag(chars) {\n        for (const [index, char] of chars.entries()) {\n            const previous = chars[index - 1];\n\n            if (\n                previous && char &&\n                isSurrogatePair(previous.value, char.value) &&\n                !isUnicodeCodePointEscape(previous) &&\n                !isUnicodeCodePointEscape(char)\n            ) {\n                yield [previous, char];\n            }\n        }\n    },\n\n    *surrogatePair(chars) {\n        for (const [index, char] of chars.entries()) {\n            const previous = chars[index - 1];\n\n            if (\n                previous && char &&\n                isSurrogatePair(previous.value, char.value) &&\n                (\n                    isUnicodeCodePointEscape(previous) ||\n                    isUnicodeCodePointEscape(char)\n                )\n            ) {\n                yield [previous, char];\n            }\n        }\n    },\n\n    *combiningClass(chars, unfilteredChars) {\n\n        /*\n         * When `allowEscape` is `true`, a combined character should only be allowed if the combining mark appears as an escape sequence.\n         * This means that the base character should be considered even if it's escaped.\n         */\n        for (const [index, char] of chars.entries()) {\n            const previous = unfilteredChars[index - 1];\n\n            if (\n                previous && char &&\n                isCombiningCharacter(char.value) &&\n                !isCombiningCharacter(previous.value)\n            ) {\n                yield [previous, char];\n            }\n        }\n    },\n\n    *emojiModifier(chars) {\n        for (const [index, char] of chars.entries()) {\n            const previous = chars[index - 1];\n\n            if (\n                previous && char &&\n                isEmojiModifier(char.value) &&\n                !isEmojiModifier(previous.value)\n            ) {\n                yield [previous, char];\n            }\n        }\n    },\n\n    *regionalIndicatorSymbol(chars) {\n        for (const [index, char] of chars.entries()) {\n            const previous = chars[index - 1];\n\n            if (\n                previous && char &&\n                isRegionalIndicatorSymbol(char.value) &&\n                isRegionalIndicatorSymbol(previous.value)\n            ) {\n                yield [previous, char];\n            }\n        }\n    },\n\n    *zwj(chars) {\n        let sequence = null;\n\n        for (const [index, char] of chars.entries()) {\n            const previous = chars[index - 1];\n            const next = chars[index + 1];\n\n            if (\n                previous && char && next &&\n                char.value === 0x200d &&\n                previous.value !== 0x200d &&\n                next.value !== 0x200d\n            ) {\n                if (sequence) {\n                    if (sequence.at(-1) === previous) {\n                        sequence.push(char, next); // append to the sequence\n                    } else {\n                        yield sequence;\n                        sequence = chars.slice(index - 1, index + 2);\n                    }\n                } else {\n                    sequence = chars.slice(index - 1, index + 2);\n                }\n            }\n        }\n\n        if (sequence) {\n            yield sequence;\n        }\n    }\n};\n\nconst kinds = Object.keys(findCharacterSequences);\n\n/**\n * Gets the value of the given node if it's a static value other than a regular expression object,\n * or the node's `regex` property.\n * The purpose of this method is to provide a replacement for `getStaticValue` in environments where certain regular expressions cannot be evaluated.\n * A known example is Node.js 18 which does not support the `v` flag.\n * Calling `getStaticValue` on a regular expression node with the `v` flag on Node.js 18 always returns `null`.\n * A limitation of this method is that it can only detect a regular expression if the specified node is itself a regular expression literal node.\n * @param {ASTNode | undefined} node The node to be inspected.\n * @param {Scope} initialScope Scope to start finding variables. This function tries to resolve identifier references which are in the given scope.\n * @returns {{ value: any } | { regex: { pattern: string, flags: string } } | null} The static value of the node, or `null`.\n */\nfunction getStaticValueOrRegex(node, initialScope) {\n    if (!node) {\n        return null;\n    }\n    if (node.type === \"Literal\" && node.regex) {\n        return { regex: node.regex };\n    }\n\n    const staticValue = getStaticValue(node, initialScope);\n\n    if (staticValue?.value instanceof RegExp) {\n        return null;\n    }\n    return staticValue;\n}\n\n/**\n * Checks whether a specified regexpp character is represented as an acceptable escape sequence.\n * This function requires the source text of the character to be known.\n * @param {Character} char Character to check.\n * @param {string} charSource Source text of the character to check.\n * @returns {boolean} Whether the specified regexpp character is represented as an acceptable escape sequence.\n */\nfunction checkForAcceptableEscape(char, charSource) {\n    if (!charSource.startsWith(\"\\\\\")) {\n        return false;\n    }\n    const match = /(?<=^\\\\+).$/su.exec(charSource);\n\n    return match?.[0] !== String.fromCodePoint(char.value);\n}\n\n/**\n * Checks whether a specified regexpp character is represented as an acceptable escape sequence.\n * This function works with characters that are produced by a string or template literal.\n * It requires the source text and the CodeUnit list of the literal to be known.\n * @param {Character} char Character to check.\n * @param {string} nodeSource Source text of the string or template literal that produces the character.\n * @param {CodeUnit[]} codeUnits List of CodeUnit objects of the literal that produces the character.\n * @returns {boolean} Whether the specified regexpp character is represented as an acceptable escape sequence.\n */\nfunction checkForAcceptableEscapeInString(char, nodeSource, codeUnits) {\n    const firstIndex = char.start;\n    const lastIndex = char.end - 1;\n    const start = codeUnits[firstIndex].start;\n    const end = codeUnits[lastIndex].end;\n    const charSource = nodeSource.slice(start, end);\n\n    return checkForAcceptableEscape(char, charSource);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow characters which are made with multiple code points in character class syntax\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-misleading-character-class\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEscape: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            surrogatePair: \"Unexpected surrogate pair in character class.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\",\n            suggestUnicodeFlag: \"Add unicode 'u' flag to regex.\"\n        }\n    },\n    create(context) {\n        const allowEscape = context.options[0]?.allowEscape;\n        const sourceCode = context.sourceCode;\n        const parser = new RegExpParser();\n        const checkedPatternNodes = new Set();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @param {Function} unicodeFixer Fixer for missing \"u\" flag.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags, unicodeFixer) {\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    {\n                        unicode: flags.includes(\"u\"),\n                        unicodeSets: flags.includes(\"v\")\n                    }\n                );\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            let codeUnits = null;\n\n            /**\n             * Checks whether a specified regexpp character is represented as an acceptable escape sequence.\n             * For the purposes of this rule, an escape sequence is considered acceptable if it consists of one or more backslashes followed by the character being escaped.\n             * @param {Character} char Character to check.\n             * @returns {boolean} Whether the specified regexpp character is represented as an acceptable escape sequence.\n             */\n            function isAcceptableEscapeSequence(char) {\n                if (node.type === \"Literal\" && node.regex) {\n                    return checkForAcceptableEscape(char, char.raw);\n                }\n                if (node.type === \"Literal\" && typeof node.value === \"string\") {\n                    const nodeSource = node.raw;\n\n                    codeUnits ??= parseStringLiteral(nodeSource);\n\n                    return checkForAcceptableEscapeInString(char, nodeSource, codeUnits);\n                }\n                if (astUtils.isStaticTemplateLiteral(node)) {\n                    const nodeSource = sourceCode.getText(node);\n\n                    codeUnits ??= parseTemplateToken(nodeSource);\n\n                    return checkForAcceptableEscapeInString(char, nodeSource, codeUnits);\n                }\n                return false;\n            }\n\n            const foundKindMatches = new Map();\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const unfilteredChars of iterateCharacterSequence(ccNode.elements)) {\n                        let chars;\n\n                        if (allowEscape) {\n\n                            // Replace escape sequences with null to avoid having them flagged.\n                            chars = unfilteredChars.map(char => (isAcceptableEscapeSequence(char) ? null : char));\n                        } else {\n                            chars = unfilteredChars;\n                        }\n                        for (const kind of kinds) {\n                            const matches = findCharacterSequences[kind](chars, unfilteredChars);\n\n                            if (foundKindMatches.has(kind)) {\n                                foundKindMatches.get(kind).push(...matches);\n                            } else {\n                                foundKindMatches.set(kind, [...matches]);\n                            }\n                        }\n                    }\n                }\n            });\n\n            /**\n             * Finds the report loc(s) for a range of matches.\n             * Only literals and expression-less templates generate granular errors.\n             * @param {Character[][]} matches Lists of individual characters being reported on.\n             * @returns {Location[]} locs for context.report.\n             * @see https://github.com/eslint/eslint/pull/17515\n             */\n            function getNodeReportLocations(matches) {\n                if (!astUtils.isStaticTemplateLiteral(node) && node.type !== \"Literal\") {\n                    return matches.length ? [node.loc] : [];\n                }\n                return matches.map(chars => {\n                    const firstIndex = chars[0].start;\n                    const lastIndex = chars.at(-1).end - 1;\n                    let start;\n                    let end;\n\n                    if (node.type === \"TemplateLiteral\") {\n                        const source = sourceCode.getText(node);\n                        const offset = node.range[0];\n\n                        codeUnits ??= parseTemplateToken(source);\n                        start = offset + codeUnits[firstIndex].start;\n                        end = offset + codeUnits[lastIndex].end;\n                    } else if (typeof node.value === \"string\") { // String Literal\n                        const source = node.raw;\n                        const offset = node.range[0];\n\n                        codeUnits ??= parseStringLiteral(source);\n                        start = offset + codeUnits[firstIndex].start;\n                        end = offset + codeUnits[lastIndex].end;\n                    } else { // RegExp Literal\n                        const offset = node.range[0] + 1; // Add 1 to skip the leading slash.\n\n                        start = offset + firstIndex;\n                        end = offset + lastIndex + 1;\n                    }\n\n                    return {\n                        start: sourceCode.getLocFromIndex(start),\n                        end: sourceCode.getLocFromIndex(end)\n                    };\n                });\n            }\n\n            for (const [kind, matches] of foundKindMatches) {\n                let suggest;\n\n                if (kind === \"surrogatePairWithoutUFlag\") {\n                    suggest = [{\n                        messageId: \"suggestUnicodeFlag\",\n                        fix: unicodeFixer\n                    }];\n                }\n\n                const locs = getNodeReportLocations(matches);\n\n                for (const loc of locs) {\n                    context.report({\n                        node,\n                        loc,\n                        messageId: kind,\n                        suggest\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                if (checkedPatternNodes.has(node)) {\n                    return;\n                }\n                verify(node, node.regex.pattern, node.regex.flags, fixer => {\n                    if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, node.regex.pattern)) {\n                        return null;\n                    }\n\n                    return fixer.insertTextAfter(node, \"u\");\n                });\n            },\n            \"Program\"(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node: refNode } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    let pattern, flags;\n                    const [patternNode, flagsNode] = refNode.arguments;\n                    const evaluatedPattern = getStaticValueOrRegex(patternNode, scope);\n\n                    if (!evaluatedPattern) {\n                        continue;\n                    }\n                    if (flagsNode) {\n                        if (evaluatedPattern.regex) {\n                            pattern = evaluatedPattern.regex.pattern;\n                            checkedPatternNodes.add(patternNode);\n                        } else {\n                            pattern = String(evaluatedPattern.value);\n                        }\n                        flags = getStringIfConstant(flagsNode, scope);\n                    } else {\n                        if (evaluatedPattern.regex) {\n                            continue;\n                        }\n                        pattern = String(evaluatedPattern.value);\n                        flags = \"\";\n                    }\n\n                    if (typeof flags === \"string\") {\n                        verify(patternNode, pattern, flags, fixer => {\n\n                            if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, pattern)) {\n                                return null;\n                            }\n\n                            if (refNode.arguments.length === 1) {\n                                const penultimateToken = sourceCode.getLastToken(refNode, { skip: 1 }); // skip closing parenthesis\n\n                                return fixer.insertTextAfter(\n                                    penultimateToken,\n                                    astUtils.isCommaToken(penultimateToken)\n                                        ? ' \"u\",'\n                                        : ', \"u\"'\n                                );\n                            }\n\n                            if ((flagsNode.type === \"Literal\" && typeof flagsNode.value === \"string\") || flagsNode.type === \"TemplateLiteral\") {\n                                const range = [flagsNode.range[0], flagsNode.range[1] - 1];\n\n                                return fixer.insertTextAfterRange(range, \"u\");\n                            }\n\n                            return null;\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}