{
    "sourceFile": "node_modules/eslint/lib/rules/consistent-this.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892214970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce consistent naming when capturing the current execution context\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/consistent-this\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        },\n\n        defaultOptions: [\"that\"],\n\n        messages: {\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n        }\n    },\n\n    create(context) {\n        const aliases = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node The assigning node.\n         * @param {string} name the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, name) {\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node The assigning node.\n         * @param {Identifier} name The name of the variable assigned to.\n         * @param {Expression} value The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.includes(name)) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            /*\n             * The alias has been declared and not assigned: check it was\n             * assigned later in the same scope.\n             */\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assigned to the correct value.\n         * @param {ASTNode} node The node that represents the scope to check.\n         * @returns {void}\n         */\n        function ensureWasAssigned(node) {\n            const scope = sourceCode.getScope(node);\n\n            // if this is program scope we also need to check module scope\n            const extraScope = node.type === \"Program\" && node.sourceType === \"module\"\n                ? scope.childScopes[0]\n                : null;\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n\n                if (extraScope) {\n                    checkWasAssigned(alias, extraScope);\n                }\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}