{
    "sourceFile": "node_modules/eslint/lib/rules/no-constant-binary-expression.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892220970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit\n * @author Jordan Eldredge <https://jordaneldredge.com>\n */\n\n\"use strict\";\n\nconst { isNullLiteral, isConstant, isReferenceToGlobalVariable, isLogicalAssignmentOperator, ECMASCRIPT_GLOBALS } = require(\"./utils/ast-utils\");\n\nconst NUMERIC_OR_STRING_BINARY_OPERATORS = new Set([\"+\", \"-\", \"*\", \"/\", \"%\", \"|\", \"^\", \"&\", \"**\", \"<<\", \">>\", \">>>\"]);\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is `null` or `undefined`. Similar to the one\n * found in ast-utils.js, but this one correctly handles the edge case that\n * `undefined` has been redefined.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(scope, node) {\n    return (\n        isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node)) ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Test if an AST node has a statically knowable constant nullishness. Meaning,\n * it will always resolve to a constant value of either: `null`, `undefined`\n * or not `null` _or_ `undefined`. An expression that can vary between those\n * three states at runtime would return `false`.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The AST node being tested.\n * @param {boolean} nonNullish if `true` then nullish values are not considered constant.\n * @returns {boolean} Does `node` have constant nullishness?\n */\nfunction hasConstantNullishness(scope, node, nonNullish) {\n    if (nonNullish && isNullOrUndefined(scope, node)) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ObjectExpression\": // Objects are never nullish\n        case \"ArrayExpression\": // Arrays are never nullish\n        case \"ArrowFunctionExpression\": // Functions never nullish\n        case \"FunctionExpression\": // Functions are never nullish\n        case \"ClassExpression\": // Classes are never nullish\n        case \"NewExpression\": // Objects are never nullish\n        case \"Literal\": // Nullish, or non-nullish, literals never change\n        case \"TemplateLiteral\": // A string is never nullish\n        case \"UpdateExpression\": // Numbers are never nullish\n        case \"BinaryExpression\": // Numbers, strings, or booleans are never nullish\n            return true;\n        case \"CallExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n            const functionName = node.callee.name;\n\n            return (functionName === \"Boolean\" || functionName === \"String\" || functionName === \"Number\") &&\n                isReferenceToGlobalVariable(scope, node.callee);\n        }\n        case \"LogicalExpression\": {\n            return node.operator === \"??\" && hasConstantNullishness(scope, node.right, true);\n        }\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantNullishness(scope, node.right, nonNullish);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...) /\n             */\n            if (isLogicalAssignmentOperator(node.operator)) {\n                return false;\n            }\n\n            /*\n             * The remaining assignment expressions all result in a numeric or\n             * string (non-nullish) value:\n             *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n             */\n\n            return true;\n        case \"UnaryExpression\":\n\n            /*\n             * \"void\" Always returns `undefined`\n             * \"typeof\" All types are strings, and thus non-nullish\n             * \"!\" Boolean is never nullish\n             * \"delete\" Returns a boolean, which is never nullish\n             * Math operators always return numbers or strings, neither of which\n             * are non-nullish \"+\", \"-\", \"~\"\n             */\n\n            return true;\n        case \"SequenceExpression\": {\n            const last = node.expressions.at(-1);\n\n            return hasConstantNullishness(scope, last, nonNullish);\n        }\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Test if an AST node is a boolean value that never changes. Specifically we\n * test for:\n * 1. Literal booleans (`true` or `false`)\n * 2. Unary `!` expressions with a constant value\n * 3. Constant booleans created via the `Boolean` global function\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Is `node` guaranteed to be a boolean?\n */\nfunction isStaticBoolean(scope, node) {\n    switch (node.type) {\n        case \"Literal\":\n            return typeof node.value === \"boolean\";\n        case \"CallExpression\":\n            return node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" &&\n              isReferenceToGlobalVariable(scope, node.callee) &&\n              (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n        case \"UnaryExpression\":\n            return node.operator === \"!\" && isConstant(scope, node.argument, true);\n        default:\n            return false;\n    }\n}\n\n\n/**\n * Test if an AST node will always give the same result when compared to a\n * boolean value. Note that comparison to boolean values is different than\n * truthiness.\n * https://262.ecma-international.org/5.1/#sec-11.9.3\n *\n * JavaScript `==` operator works by converting the boolean to `1` (true) or\n * `+0` (false) and then checks the values `==` equality to that number.\n * @param {Scope} scope The scope in which node was found.\n * @param {ASTNode} node The node to test.\n * @returns {boolean} Will `node` always coerce to the same boolean value?\n */\nfunction hasConstantLooseBooleanComparison(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ClassExpression\":\n\n            /**\n             * In theory objects like:\n             *\n             * `{toString: () => a}`\n             * `{valueOf: () => a}`\n             *\n             * Or a classes like:\n             *\n             * `class { static toString() { return a } }`\n             * `class { static valueOf() { return a } }`\n             *\n             * Are not constant verifiably when `inBooleanPosition` is\n             * false, but it's an edge case we've opted not to handle.\n             */\n            return true;\n        case \"ArrayExpression\": {\n            const nonSpreadElements = node.elements.filter(e =>\n\n                // Elements can be `null` in sparse arrays: `[,,]`;\n                e !== null && e.type !== \"SpreadElement\");\n\n\n            /*\n             * Possible future direction if needed: We could check if the\n             * single value would result in variable boolean comparison.\n             * For now we will err on the side of caution since `[x]` could\n             * evaluate to `[0]` or `[1]`.\n             */\n            return node.elements.length === 0 || nonSpreadElements.length > 1;\n        }\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n            return true;\n        case \"UnaryExpression\":\n            if (node.operator === \"void\" || // Always returns `undefined`\n                node.operator === \"typeof\" // All `typeof` strings, when coerced to number, are not 0 or 1.\n            ) {\n                return true;\n            }\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            /*\n             * We won't try to reason about +, -, ~, or delete\n             * In theory, for the mathematical operators, we could look at the\n             * argument and try to determine if it coerces to a constant numeric\n             * value.\n             */\n            return false;\n        case \"NewExpression\": // Objects might have custom `.valueOf` or `.toString`.\n            return false;\n        case \"CallExpression\": {\n            if (node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Boolean\" &&\n                isReferenceToGlobalVariable(scope, node.callee)\n            ) {\n                return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n            }\n            return false;\n        }\n        case \"Literal\": // True or false, literals never change\n            return true;\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"TemplateLiteral\":\n\n            /*\n             * In theory we could try to check if the quasi are sufficient to\n             * prove that the expression will always be true, but it would be\n             * tricky to get right. For example: `000.${foo}000`\n             */\n            return node.expressions.length === 0;\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantLooseBooleanComparison(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...)\n             *\n             * The remaining assignment expressions all result in a numeric or\n             * string (non-nullish) values which could be truthy or falsy:\n             *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n             */\n            return false;\n        case \"SequenceExpression\": {\n            const last = node.expressions.at(-1);\n\n            return hasConstantLooseBooleanComparison(scope, last);\n        }\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n\n/**\n * Test if an AST node will always give the same result when _strictly_ compared\n * to a boolean value. This can happen if the expression can never be boolean, or\n * if it is always the same boolean value.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always give the same result when compared to a\n * static boolean value?\n */\nfunction hasConstantStrictBooleanComparison(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\": // Objects are not booleans\n        case \"ArrayExpression\": // Arrays are not booleans\n        case \"ArrowFunctionExpression\": // Functions are not booleans\n        case \"FunctionExpression\":\n        case \"ClassExpression\": // Classes are not booleans\n        case \"NewExpression\": // Objects are not booleans\n        case \"TemplateLiteral\": // Strings are not booleans\n        case \"Literal\": // True, false, or not boolean, literals never change.\n        case \"UpdateExpression\": // Numbers are not booleans\n            return true;\n        case \"BinaryExpression\":\n            return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);\n        case \"UnaryExpression\": {\n            if (node.operator === \"delete\") {\n                return false;\n            }\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            /*\n             * The remaining operators return either strings or numbers, neither\n             * of which are boolean.\n             */\n            return true;\n        }\n        case \"SequenceExpression\": {\n            const last = node.expressions.at(-1);\n\n            return hasConstantStrictBooleanComparison(scope, last);\n        }\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantStrictBooleanComparison(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...)\n             */\n            if (isLogicalAssignmentOperator(node.operator)) {\n                return false;\n            }\n\n            /*\n             * The remaining assignment expressions all result in either a number\n             * or a string, neither of which can ever be boolean.\n             */\n            return true;\n        case \"CallExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n            const functionName = node.callee.name;\n\n            if (\n                (functionName === \"String\" || functionName === \"Number\") &&\n                isReferenceToGlobalVariable(scope, node.callee)\n            ) {\n                return true;\n            }\n            if (functionName === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n                return (\n                    node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n            }\n            return false;\n        }\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Test if an AST node will always result in a newly constructed object\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always be new?\n */\nfunction isAlwaysNew(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n        case \"ClassExpression\":\n            return true;\n        case \"NewExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n\n            /*\n             * All the built-in constructors are always new, but\n             * user-defined constructors could return a sentinel\n             * object.\n             *\n             * Catching these is especially useful for primitive constructors\n             * which return boxed values, a surprising gotcha' in JavaScript.\n             */\n            return Object.hasOwn(ECMASCRIPT_GLOBALS, node.callee.name) &&\n              isReferenceToGlobalVariable(scope, node.callee);\n        }\n        case \"Literal\":\n\n            // Regular expressions are objects, and thus always new\n            return typeof node.regex === \"object\";\n        case \"SequenceExpression\": {\n            const last = node.expressions.at(-1);\n\n            return isAlwaysNew(scope, last);\n        }\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return isAlwaysNew(scope, node.right);\n            }\n            return false;\n        case \"ConditionalExpression\":\n            return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks if one operand will cause the result to be constant.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} a One side of the expression\n * @param {ASTNode} b The other side of the expression\n * @param {string} operator The binary expression operator\n * @returns {ASTNode | null} The node which will cause the expression to have a constant result.\n */\nfunction findBinaryExpressionConstantOperand(scope, a, b, operator) {\n    if (operator === \"==\" || operator === \"!=\") {\n        if (\n            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false)) ||\n            (isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b))\n        ) {\n            return b;\n        }\n    } else if (operator === \"===\" || operator === \"!==\") {\n        if (\n            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false)) ||\n            (isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b))\n        ) {\n            return b;\n        }\n    }\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n        docs: {\n            description: \"Disallow expressions where the operation doesn't affect the value\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-constant-binary-expression\"\n        },\n        schema: [],\n        messages: {\n            constantBinaryOperand: \"Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.\",\n            constantShortCircuit: \"Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.\",\n            alwaysNew: \"Unexpected comparison to newly constructed object. These two values can never be equal.\",\n            bothAlwaysNew: \"Unexpected comparison of two newly constructed objects. These two values can never be equal.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        return {\n            LogicalExpression(node) {\n                const { operator, left } = node;\n                const scope = sourceCode.getScope(node);\n\n                if ((operator === \"&&\" || operator === \"||\") && isConstant(scope, left, true)) {\n                    context.report({ node: left, messageId: \"constantShortCircuit\", data: { property: \"truthiness\", operator } });\n                } else if (operator === \"??\" && hasConstantNullishness(scope, left, false)) {\n                    context.report({ node: left, messageId: \"constantShortCircuit\", data: { property: \"nullishness\", operator } });\n                }\n            },\n            BinaryExpression(node) {\n                const scope = sourceCode.getScope(node);\n                const { right, left, operator } = node;\n                const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);\n                const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);\n\n                if (rightConstantOperand) {\n                    context.report({ node: rightConstantOperand, messageId: \"constantBinaryOperand\", data: { operator, otherSide: \"left\" } });\n                } else if (leftConstantOperand) {\n                    context.report({ node: leftConstantOperand, messageId: \"constantBinaryOperand\", data: { operator, otherSide: \"right\" } });\n                } else if (operator === \"===\" || operator === \"!==\") {\n                    if (isAlwaysNew(scope, left)) {\n                        context.report({ node: left, messageId: \"alwaysNew\" });\n                    } else if (isAlwaysNew(scope, right)) {\n                        context.report({ node: right, messageId: \"alwaysNew\" });\n                    }\n                } else if (operator === \"==\" || operator === \"!=\") {\n\n                    /*\n                     * If both sides are \"new\", then both sides are objects and\n                     * therefore they will be compared by reference even with `==`\n                     * equality.\n                     */\n                    if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {\n                        context.report({ node: left, messageId: \"bothAlwaysNew\" });\n                    }\n                }\n\n            }\n\n            /*\n             * In theory we could handle short-circuiting assignment operators,\n             * for some constant values, but that would require walking the\n             * scope to find the value of the variable being assigned. This is\n             * dependant on https://github.com/eslint/eslint/issues/13776\n             *\n             * AssignmentExpression() {},\n             */\n        };\n    }\n};\n"
        }
    ]
}