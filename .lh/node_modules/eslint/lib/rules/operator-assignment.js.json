{
    "sourceFile": "node_modules/eslint/lib/rules/operator-assignment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892234155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param {string} operator Operator to check.\n * @returns {boolean} True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].includes(operator);\n}\n\n/**\n * Checks whether an operator is not commutative and has an operator assignment\n * shorthand form.\n * @param {string} operator Operator to check.\n * @returns {boolean} True if the operator is not commutative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].includes(operator);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n * toString calls regardless of whether assignment shorthand is used)\n * @param {ASTNode} node The node on the left side of the expression\n * @returns {boolean} `true` if the node can be fixed\n */\nfunction canBeFixed(node) {\n    return (\n        node.type === \"Identifier\" ||\n        (\n            node.type === \"MemberExpression\" &&\n            (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") &&\n            (!node.computed || node.property.type === \"Literal\")\n        )\n    );\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"always\"],\n\n        docs: {\n            description: \"Require or disallow assignment operator shorthand where possible\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/operator-assignment\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            replaced: \"Assignment (=) can be replaced with operator assignment ({{operator}}).\",\n            unexpected: \"Unexpected operator assignment ({{operator}}) shorthand.\"\n        }\n    },\n\n    create(context) {\n        const never = context.options[0] === \"never\";\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Returns the operator token of an AssignmentExpression or BinaryExpression\n         * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n         * @returns {Token} The operator token in the node\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                const replacementOperator = `${operator}=`;\n\n                if (astUtils.isSameReference(left, expr.left, true)) {\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        data: { operator: replacementOperator },\n                        fix(fixer) {\n                            if (canBeFixed(left) && canBeFixed(expr.left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                // Check for comments that would be removed.\n                                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                                    return null;\n                                }\n\n                                return fixer.replaceText(node, `${leftText}${replacementOperator}${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        messageId: \"replaced\",\n                        data: { operator: replacementOperator }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: { operator: node.operator },\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const firstToken = sourceCode.getFirstToken(node);\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // Check for comments that would be duplicated.\n                            if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                                return null;\n                            }\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, { includeComments: true });\n                                let rightTextPrefix = \"\";\n\n                                if (\n                                    operatorToken.range[1] === tokenAfterOperator.range[0] &&\n                                    !astUtils.canTokensBeAdjacent({ type: \"Punctuator\", value: newOperator }, tokenAfterOperator)\n                                ) {\n                                    rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                                }\n\n                                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: !never ? verify : prohibit\n        };\n\n    }\n};\n"
        }
    ]
}