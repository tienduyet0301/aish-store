{
    "sourceFile": "node_modules/eslint/lib/rules/constructor-super.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892215019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"ChainExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            if ([\"=\", \"&&=\"].includes(node.operator)) {\n                return isPossibleConstructor(node.right);\n            }\n\n            if ([\"||=\", \"??=\"].includes(node.operator)) {\n                return (\n                    isPossibleConstructor(node.left) ||\n                    isPossibleConstructor(node.right)\n                );\n            }\n\n            /**\n             * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\n             * An assignment expression with a mathematical operator can either evaluate to a primitive value,\n             * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\n             */\n            return false;\n\n        case \"LogicalExpression\":\n\n            /*\n             * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\n             * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\n             * possible constructor. A future improvement could verify that the left side could be truthy by\n             * excluding falsy literals.\n             */\n            if (node.operator === \"&&\") {\n                return isPossibleConstructor(node.right);\n            }\n\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions.at(-1);\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n/**\n * A class to store information about a code path segment.\n */\nclass SegmentInfo {\n\n    /**\n     * Indicates if super() is called in all code paths.\n     * @type {boolean}\n     */\n    calledInEveryPaths = false;\n\n    /**\n     * Indicates if super() is called in any code paths.\n     * @type {boolean}\n     */\n    calledInSomePaths = false;\n\n    /**\n     * The nodes which have been validated and don't need to be reconsidered.\n     * @type {ASTNode[]}\n     */\n    validNodes = [];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Require `super()` calls in constructors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/constructor-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\n            missingAll: \"Expected to call 'super()'.\",\n\n            duplicate: \"Unexpected duplicate 'super()'.\",\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /**\n         * @type {Record<string, SegmentInfo>}\n         */\n        const segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Determines if a segment has been seen in the traversal.\n         * @param {CodePathSegment} segment A code path segment to check.\n         * @returns {boolean} `true` if the segment has been seen.\n         */\n        function hasSegmentBeenSeen(segment) {\n            return !!segInfoMap[segment.id];\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath,\n                        currentSegments: new Set()\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath,\n                        currentSegments: new Set()\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath A code path which was ended.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const returnedSegments = codePath.returnedSegments;\n                const calledInEveryPaths = returnedSegments.every(isCalledInEveryPath);\n                const calledInSomePaths = returnedSegments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        messageId: calledInSomePaths\n                            ? \"missingSome\"\n                            : \"missingAll\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @param {CodePathSegment} node Node that starts the segment.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment, node) {\n\n                funcInfo.currentSegments.add(segment);\n\n                if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = new SegmentInfo();\n\n                const seenPrevSegments = segment.prevSegments.filter(hasSegmentBeenSeen);\n\n                // When there are previous segments, aggregates these.\n                if (seenPrevSegments.length > 0) {\n                    info.calledInSomePaths = seenPrevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = seenPrevSegments.every(isCalledInEveryPath);\n                }\n\n                /*\n                 * ForStatement > *.update segments are a special case as they are created in advance,\n                 * without seen previous segments. Since they logically don't affect `calledInEveryPaths`\n                 * calculations, and they can never be a lone previous segment of another one, we'll set\n                 * their `calledInEveryPaths` to `true` to effectively ignore them in those calculations.\n                 * .\n                 */\n                if (node.parent && node.parent.type === \"ForStatement\" && node.parent.update === node) {\n                    info.calledInEveryPaths = true;\n                }\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id];\n\n                        // skip segments after the loop\n                        if (!info) {\n                            controller.skip();\n                            return;\n                        }\n\n                        const seenPrevSegments = segment.prevSegments.filter(hasSegmentBeenSeen);\n                        const calledInSomePreviousPaths = seenPrevSegments.some(isCalledInSomePath);\n                        const calledInEveryPreviousPaths = seenPrevSegments.every(isCalledInEveryPath);\n\n                        info.calledInSomePaths ||= calledInSomePreviousPaths;\n                        info.calledInEveryPaths ||= calledInEveryPreviousPaths;\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (calledInSomePreviousPaths) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    messageId: \"duplicate\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                const segments = funcInfo.currentSegments;\n                let duplicate = false;\n                let info = null;\n\n                for (const segment of segments) {\n\n                    if (segment.reachable) {\n                        info = segInfoMap[segment.id];\n\n                        duplicate = duplicate || info.calledInSomePaths;\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n\n                if (info) {\n                    if (duplicate) {\n                        context.report({\n                            messageId: \"duplicate\",\n                            node\n                        });\n                    } else if (!funcInfo.superIsConstructor) {\n                        context.report({\n                            messageId: \"badSuper\",\n                            node\n                        });\n                    } else {\n                        info.validNodes.push(node);\n                    }\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.currentSegments;\n\n                for (const segment of segments) {\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}