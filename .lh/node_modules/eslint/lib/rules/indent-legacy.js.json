{
    "sourceFile": "node_modules/eslint/lib/rules/indent-legacy.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892216901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n * @deprecated in ESLint v4.0.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n// this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway.\n/* c8 ignore next */\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent indentation\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/indent-legacy\"\n        },\n\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"4.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"indent\",\n                        url: \"https://eslint.style/rules/js/indent\"\n                    }\n                }\n            ]\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n        }\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.sourceCode;\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* c8 ignore start */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }/* c8 ignore stop */\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                /*\n                 * Abbreviate the message if the expected indentation is also spaces.\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                 */\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n            return {\n                expected: expectedStatement,\n                actual: foundStatement\n            };\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object} [loc] Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                messageId: \"expected\",\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         * `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            /*\n             * in case if return statement ends with ');' we have traverse back to ')'\n             * otherwise we'll measure indent for ';' and replace ')'\n             */\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                stmt.type === \"ExpressionStatement\" ||\n                stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            /*\n             * function body indent should be indent + indent size, unless this\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n             */\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] &&\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.includes(node)) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements.at(-1).loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent +\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                node.parent.type === \"FunctionExpression\" ||\n                node.parent.type === \"FunctionDeclaration\" ||\n                node.parent.type === \"ArrowFunctionExpression\")\n            ) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck;\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.includes(node.parent.type) && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection.at(-1);\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements.at(-1);\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [providedSwitchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, providedSwitchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\n                ? getNodeIndent(switchNode).goodChar\n                : providedSwitchIndent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks whether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\"\n            );\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations.at(-1).loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                /*\n                 * The typical layout of variable declarations and assignments\n                 * alter the expectation of correct indentation. Skip them.\n                 * TODO: Add appropriate configuration options for variable\n                 * declarations and assignments.\n                 */\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = sourceCode.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n"
        }
    ]
}