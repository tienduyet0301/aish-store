{
    "sourceFile": "node_modules/eslint/lib/rules/no-fallthrough.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { directivesPattern } = require(\"../shared/directives\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.\n * @param {string} comment The comment string to check.\n * @param {RegExp} fallthroughCommentPattern The regular expression used for checking for fallthrough comments.\n * @returns {boolean} `true` if the comment string is truly a fallthrough comment.\n */\nfunction isFallThroughComment(comment, fallthroughCommentPattern) {\n    return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());\n}\n\n/**\n * Checks whether or not a given case has a fallthrough comment.\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\n * @param {RuleContext} context A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\n * @returns {null | object} the comment if the case has a valid fallthrough comment, otherwise null\n */\nfunction getFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n    const sourceCode = context.sourceCode;\n\n    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n        if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {\n            return commentInBlock;\n        }\n    }\n\n    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n\n    if (comment && isFallThroughComment(comment.value, fallthroughCommentPattern)) {\n        return comment;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node The node to check\n * @param {Token} token The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            allowEmptyCase: false,\n            reportUnusedFallthroughComment: false\n        }],\n\n        docs: {\n            description: \"Disallow fallthrough of `case` statements\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-fallthrough\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\"\n                    },\n                    allowEmptyCase: {\n                        type: \"boolean\"\n                    },\n                    reportUnusedFallthroughComment: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            unusedFallthroughComment: \"Found a comment that would permit fallthrough, but case cannot fall through.\",\n            case: \"Expected a 'break' statement before 'case'.\",\n            default: \"Expected a 'break' statement before 'default'.\"\n        }\n    },\n\n    create(context) {\n        const codePathSegments = [];\n        let currentCodePathSegments = new Set();\n        const sourceCode = context.sourceCode;\n        const [{ allowEmptyCase, commentPattern, reportUnusedFallthroughComment }] = context.options;\n        const fallthroughCommentPattern = commentPattern\n            ? new RegExp(commentPattern, \"u\")\n            : DEFAULT_FALLTHROUGH_COMMENT;\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let previousCase = null;\n\n        return {\n\n            onCodePathStart() {\n                codePathSegments.push(currentCodePathSegments);\n                currentCodePathSegments = new Set();\n            },\n\n            onCodePathEnd() {\n                currentCodePathSegments = codePathSegments.pop();\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n\n                if (previousCase && previousCase.node.parent === node.parent) {\n                    const previousCaseFallthroughComment = getFallthroughComment(previousCase.node, node, context, fallthroughCommentPattern);\n\n                    if (previousCase.isFallthrough && !(previousCaseFallthroughComment)) {\n                        context.report({\n                            messageId: node.test ? \"case\" : \"default\",\n                            node\n                        });\n                    } else if (reportUnusedFallthroughComment && !previousCase.isSwitchExitReachable && previousCaseFallthroughComment) {\n                        context.report({\n                            messageId: \"unusedFallthroughComment\",\n                            node: previousCaseFallthroughComment\n                        });\n                    }\n\n                }\n                previousCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                const isSwitchExitReachable = isAnySegmentReachable(currentCodePathSegments);\n                const isFallthrough = isSwitchExitReachable && (node.consequent.length > 0 || (!allowEmptyCase && hasBlankLinesBetween(node, nextToken))) &&\n                    node.parent.cases.at(-1) !== node;\n\n                previousCase = {\n                    node,\n                    isSwitchExitReachable,\n                    isFallthrough\n                };\n\n            }\n        };\n    }\n};\n"
        }
    ]
}