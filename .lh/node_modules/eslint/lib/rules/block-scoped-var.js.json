{
    "sourceFile": "node_modules/eslint/lib/rules/block-scoped-var.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce the use of variables within the scope they are defined\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/block-scoped-var\"\n        },\n\n        schema: [],\n\n        messages: {\n            outOfScope: \"'{{name}}' declared on line {{definitionLine}} column {{definitionColumn}} is used outside of binding context.\"\n        }\n    },\n\n    create(context) {\n        let stack = [];\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {eslint-scope.Reference} reference A reference to report.\n         * @param {eslint-scope.Definition} definition A definition for which to report reference.\n         * @returns {void}\n         */\n        function report(reference, definition) {\n            const identifier = reference.identifier;\n            const definitionPosition = definition.name.loc.start;\n\n            context.report({\n                node: identifier,\n                messageId: \"outOfScope\",\n                data: {\n                    name: identifier.name,\n                    definitionLine: definitionPosition.line,\n                    definitionColumn: definitionPosition.column + 1\n                }\n            });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack.at(-1);\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = sourceCode.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(ref => report(ref, variables[i].defs.find(def => def.parent === node)));\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n            StaticBlock: enterScope,\n            \"StaticBlock:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n"
        }
    ]
}