{
    "sourceFile": "node_modules/eslint/lib/rules/no-extra-semi.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"no-extra-semi\",\n                        url: \"https://eslint.style/rules/js/no-extra-semi\"\n                    }\n                }\n            ]\n        },\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary semicolons\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-semi\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unexpected: \"Unnecessary semicolon.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks if a node or token is fixable.\n         * A node is fixable if it can be removed without turning a subsequent statement into a directive after fixing other nodes.\n         * @param {Token} nodeOrToken The node or token to check.\n         * @returns {boolean} Whether or not the node is fixable.\n         */\n        function isFixable(nodeOrToken) {\n            const nextToken = sourceCode.getTokenAfter(nodeOrToken);\n\n            if (!nextToken || nextToken.type !== \"String\") {\n                return true;\n            }\n            const stringNode = sourceCode.getNodeByRangeIndex(nextToken.range[0]);\n\n            return !astUtils.isTopLevelExpressionStatement(stringNode.parent);\n        }\n\n        /**\n         * Reports an unnecessary semicolon error.\n         * @param {Node|Token} nodeOrToken A node or a token to be reported.\n         * @returns {void}\n         */\n        function report(nodeOrToken) {\n            context.report({\n                node: nodeOrToken,\n                messageId: \"unexpected\",\n                fix: isFixable(nodeOrToken)\n                    ? fixer =>\n\n                        /*\n                         * Expand the replacement range to include the surrounding\n                         * tokens to avoid conflicting with semi.\n                         * https://github.com/eslint/eslint/issues/7928\n                         */\n                        new FixTracker(fixer, context.sourceCode)\n                            .retainSurroundingTokens(nodeOrToken)\n                            .remove(nodeOrToken)\n                    : null\n            });\n        }\n\n        /**\n         * Checks for a part of a class body.\n         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n         * @param {Token} firstToken The first token to check.\n         * @returns {void}\n         */\n        function checkForPartOfClassBody(firstToken) {\n            for (let token = firstToken;\n                token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token);\n                token = sourceCode.getTokenAfter(token)\n            ) {\n                if (astUtils.isSemicolonToken(token)) {\n                    report(token);\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Reports this empty statement, except if the parent node is a loop.\n             * @param {Node} node A EmptyStatement node to be reported.\n             * @returns {void}\n             */\n            EmptyStatement(node) {\n                const parent = node.parent,\n                    allowedParentTypes = [\n                        \"ForStatement\",\n                        \"ForInStatement\",\n                        \"ForOfStatement\",\n                        \"WhileStatement\",\n                        \"DoWhileStatement\",\n                        \"IfStatement\",\n                        \"LabeledStatement\",\n                        \"WithStatement\"\n                    ];\n\n                if (!allowedParentTypes.includes(parent.type)) {\n                    report(node);\n                }\n            },\n\n            /**\n             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n             * @param {Node} node A ClassBody node to check.\n             * @returns {void}\n             */\n            ClassBody(node) {\n                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n            },\n\n            /**\n             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n             * @param {Node} node A MethodDefinition node of the start point.\n             * @returns {void}\n             */\n            \"MethodDefinition, PropertyDefinition, StaticBlock\"(node) {\n                checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n            }\n        };\n\n    }\n};\n"
        }
    ]
}