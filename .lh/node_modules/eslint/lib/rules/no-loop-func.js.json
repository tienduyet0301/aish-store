{
    "sourceFile": "node_modules/eslint/lib/rules/no-loop-func.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\n/**\n * Identifies is a node is a FunctionExpression which is part of an IIFE\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if it's an IIFE\n */\nfunction isIIFE(node) {\n    return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow function declarations that contain unsafe references inside loop statements\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-loop-func\"\n        },\n\n        schema: [],\n\n        messages: {\n            unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n        }\n    },\n\n    create(context) {\n\n        const SKIPPED_IIFE_NODES = new Set();\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Gets the containing loop node of a specified node.\n         *\n         * We don't need to check nested functions, so this ignores those, with the exception of IIFE.\n         * `Scope.through` contains references of nested functions.\n         * @param {ASTNode} node An AST node to get.\n         * @returns {ASTNode|null} The containing loop node of the specified node, or\n         *      `null`.\n         */\n        function getContainingLoopNode(node) {\n            for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n                const parent = currentNode.parent;\n\n                switch (parent.type) {\n                    case \"WhileStatement\":\n                    case \"DoWhileStatement\":\n                        return parent;\n\n                    case \"ForStatement\":\n\n                        // `init` is outside of the loop.\n                        if (parent.init !== currentNode) {\n                            return parent;\n                        }\n                        break;\n\n                    case \"ForInStatement\":\n                    case \"ForOfStatement\":\n\n                        // `right` is outside of the loop.\n                        if (parent.right !== currentNode) {\n                            return parent;\n                        }\n                        break;\n\n                    case \"ArrowFunctionExpression\":\n                    case \"FunctionExpression\":\n                    case \"FunctionDeclaration\":\n\n                        // We need to check nested functions only in case of IIFE.\n                        if (SKIPPED_IIFE_NODES.has(parent)) {\n                            break;\n                        }\n\n                        return null;\n                    default:\n                        break;\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Gets the containing loop node of a given node.\n         * If the loop was nested, this returns the most outer loop.\n         * @param {ASTNode} node A node to get. This is a loop node.\n         * @param {ASTNode|null} excludedNode A node that the result node should not\n         *      include.\n         * @returns {ASTNode} The most outer loop node.\n         */\n        function getTopLoopNode(node, excludedNode) {\n            const border = excludedNode ? excludedNode.range[1] : 0;\n            let retv = node;\n            let containingLoopNode = node;\n\n            while (containingLoopNode && containingLoopNode.range[0] >= border) {\n                retv = containingLoopNode;\n                containingLoopNode = getContainingLoopNode(containingLoopNode);\n            }\n\n            return retv;\n        }\n\n        /**\n         * Checks whether a given reference which refers to an upper scope's variable is\n         * safe or not.\n         * @param {ASTNode} loopNode A containing loop node.\n         * @param {eslint-scope.Reference} reference A reference to check.\n         * @returns {boolean} `true` if the reference is safe or not.\n         */\n        function isSafe(loopNode, reference) {\n            const variable = reference.resolved;\n            const definition = variable && variable.defs[0];\n            const declaration = definition && definition.parent;\n            const kind = (declaration && declaration.type === \"VariableDeclaration\")\n                ? declaration.kind\n                : \"\";\n\n            // Variables which are declared by `const` is safe.\n            if (kind === \"const\") {\n                return true;\n            }\n\n            /*\n             * Variables which are declared by `let` in the loop is safe.\n             * It's a different instance from the next loop step's.\n             */\n            if (kind === \"let\" &&\n                declaration.range[0] > loopNode.range[0] &&\n                declaration.range[1] < loopNode.range[1]\n            ) {\n                return true;\n            }\n\n            /*\n             * WriteReferences which exist after this border are unsafe because those\n             * can modify the variable.\n             */\n            const border = getTopLoopNode(\n                loopNode,\n                (kind === \"let\") ? declaration : null\n            ).range[0];\n\n            /**\n             * Checks whether a given reference is safe or not.\n             * The reference is every reference of the upper scope's variable we are\n             * looking now.\n             *\n             * It's safe if the reference matches one of the following condition.\n             * - is readonly.\n             * - doesn't exist inside a local function and after the border.\n             * @param {eslint-scope.Reference} upperRef A reference to check.\n             * @returns {boolean} `true` if the reference is safe.\n             */\n            function isSafeReference(upperRef) {\n                const id = upperRef.identifier;\n\n                return (\n                    !upperRef.isWrite() ||\n                    variable.scope.variableScope === upperRef.from.variableScope &&\n                    id.range[0] < border\n                );\n            }\n\n            return Boolean(variable) && variable.references.every(isSafeReference);\n        }\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = sourceCode.getScope(node).through;\n\n            // Check if the function is not asynchronous or a generator function\n            if (!(node.async || node.generator)) {\n                if (isIIFE(node)) {\n\n                    const isFunctionExpression = node.type === \"FunctionExpression\";\n\n                    // Check if the function is referenced elsewhere in the code\n                    const isFunctionReferenced = isFunctionExpression && node.id ? references.some(r => r.identifier.name === node.id.name) : false;\n\n                    if (!isFunctionReferenced) {\n                        SKIPPED_IIFE_NODES.add(node);\n                        return;\n                    }\n                }\n            }\n\n            const unsafeRefs = references.filter(r => r.resolved && !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n            if (unsafeRefs.length > 0) {\n                context.report({\n                    node,\n                    messageId: \"unsafeRefs\",\n                    data: { varNames: `'${unsafeRefs.join(\"', '\")}'` }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n"
        }
    ]
}