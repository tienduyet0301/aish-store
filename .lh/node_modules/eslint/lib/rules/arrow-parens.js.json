{
    "sourceFile": "node_modules/eslint/lib/rules/arrow-parens.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213839,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if the given arrow function has block body.\n * @param {ASTNode} node `ArrowFunctionExpression` node.\n * @returns {boolean} `true` if the function has block body.\n */\nfunction hasBlockBody(node) {\n    return node.body.type === \"BlockStatement\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"arrow-parens\",\n                        url: \"https://eslint.style/rules/js/arrow-parens\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require parentheses around arrow function arguments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/arrow-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\n            expectedParens: \"Expected parentheses around arrow function argument.\",\n\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n        }\n    },\n\n    create(context) {\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Finds opening paren of parameters for the given arrow function, if it exists.\n         * It is assumed that the given arrow function has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\n         */\n        function findOpeningParenOfParams(node) {\n            const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n            if (\n                tokenBeforeParams &&\n                astUtils.isOpeningParenToken(tokenBeforeParams) &&\n                node.range[0] <= tokenBeforeParams.range[0]\n            ) {\n                return tokenBeforeParams;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds closing paren of parameters for the given arrow function.\n         * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @returns {Token} the closing paren of parameters.\n         */\n        function getClosingParenOfParams(node) {\n            return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n        }\n\n        /**\n         * Determines whether the given arrow function has comments inside parens of parameters.\n         * It is assumed that the given arrow function has parens of parameters.\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\n         */\n        function hasCommentsInParensOfParams(node, openingParen) {\n            return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n        }\n\n        /**\n         * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\n         * in which case it will be assumed that the existing parens of parameters are necessary.\n         * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\n         * Example: <T>(a) => b\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\n         * @param {Token} openingParen Opening paren of parameters.\n         * @returns {boolean} `true` if the function has at least one unexpected token.\n         */\n        function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n            const expectedCount = node.async ? 1 : 0;\n\n            return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;\n        }\n\n        return {\n            \"ArrowFunctionExpression[params.length=1]\"(node) {\n                const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n                const openingParen = findOpeningParenOfParams(node);\n                const hasParens = openingParen !== null;\n                const [param] = node.params;\n\n                if (shouldHaveParens && !hasParens) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            yield fixer.insertTextBefore(param, \"(\");\n                            yield fixer.insertTextAfter(param, \")\");\n                        }\n                    });\n                }\n\n                if (\n                    !shouldHaveParens &&\n                    hasParens &&\n                    param.type === \"Identifier\" &&\n                    !param.typeAnnotation &&\n                    !node.returnType &&\n                    !hasCommentsInParensOfParams(node, openingParen) &&\n                    !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)\n                ) {\n                    context.report({\n                        node,\n                        messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n                        loc: param.loc,\n                        *fix(fixer) {\n                            const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n                            const closingParen = getClosingParenOfParams(node);\n\n                            if (\n                                tokenBeforeOpeningParen &&\n                                tokenBeforeOpeningParen.range[1] === openingParen.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))\n                            ) {\n                                yield fixer.insertTextBefore(openingParen, \" \");\n                            }\n\n                            // remove parens, whitespace inside parens, and possible trailing comma\n                            yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n                            yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}