{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-arrow-callback.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892234945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node A MetaProperty node to check.\n * @param {string} metaName The name of `MetaProperty.meta`.\n * @param {string} propertyName The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {eslint-scope.Scope} scope A scope to get.\n * @returns {eslint-scope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* c8 ignore next */\n    return null;\n}\n\n/**\n * Checks whether or not a given node is a callback.\n * @param {ASTNode} node A node to check.\n * @throws {Error} (Unreachable.)\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let currentNode = node;\n    let parent = node.parent;\n    let bound = false;\n\n    while (currentNode) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ChainExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (\n                    parent.object === currentNode &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\"\n                ) {\n                    const maybeCallee = parent.parent.type === \"ChainExpression\"\n                        ? parent.parent\n                        : parent;\n\n                    if (astUtils.isCallee(maybeCallee)) {\n                        if (!bound) {\n                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n                            retv.isLexicalThis = (\n                                maybeCallee.parent.arguments.length === 1 &&\n                                maybeCallee.parent.arguments[0].type === \"ThisExpression\"\n                            );\n                        }\n                        parent = maybeCallee.parent;\n                    } else {\n                        return retv;\n                    }\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== currentNode) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        currentNode = parent;\n        parent = parent.parent;\n    }\n\n    /* c8 ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\n * @param {ASTNode[]} paramsList The list of parameters for a function\n * @returns {boolean} `true` if the list of parameters contains any duplicates\n */\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{ allowNamedFunctions: false, allowUnboundThis: true }],\n\n        docs: {\n            description: \"Require using arrow functions for callbacks\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/prefer-arrow-callback\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\"\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            preferArrowCallback: \"Unexpected function expression.\"\n        }\n    },\n\n    create(context) {\n        const [{ allowNamedFunctions, allowUnboundThis }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack.at(-1);\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack.at(-1);\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack.at(-1);\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = sourceCode.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(sourceCode.getScope(node));\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"preferArrowCallback\",\n                        *fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                /*\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                 */\n                                return;\n                            }\n\n                            // Remove `.bind(this)` if exists.\n                            if (callbackInfo.isLexicalThis) {\n                                const memberNode = node.parent;\n\n                                /*\n                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\n                                 * E.g. `(foo || function(){}).bind(this)`\n                                 */\n                                if (memberNode.type !== \"MemberExpression\") {\n                                    return;\n                                }\n\n                                const callNode = memberNode.parent;\n                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n\n                                /*\n                                 * If the member expression is parenthesized, don't remove the right paren.\n                                 * E.g. `(function(){}.bind)(this)`\n                                 *                    ^^^^^^^^^^^^\n                                 */\n                                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                                    return;\n                                }\n\n                                // If comments exist in the `.bind(this)`, don't remove those.\n                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                                    return;\n                                }\n\n                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n                            }\n\n                            // Convert the function expression to an arrow function.\n                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n                            const tokenBeforeBody = sourceCode.getTokenBefore(node.body);\n\n                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n\n                                // Remove only extra tokens to keep comments.\n                                yield fixer.remove(functionToken);\n                                if (node.id) {\n                                    yield fixer.remove(node.id);\n                                }\n                            } else {\n\n                                // Remove extra tokens and spaces.\n                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n                            }\n                            yield fixer.insertTextAfter(tokenBeforeBody, \" =>\");\n\n                            // Get the node that will become the new arrow function.\n                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n                            if (replacedNode.type === \"ChainExpression\") {\n                                replacedNode = replacedNode.parent;\n                            }\n\n                            /*\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\n                             * though `foo || function() {}` is valid.\n                             */\n                            if (\n                                replacedNode.parent.type !== \"CallExpression\" &&\n                                replacedNode.parent.type !== \"ConditionalExpression\" &&\n                                !astUtils.isParenthesised(sourceCode, replacedNode) &&\n                                !astUtils.isParenthesised(sourceCode, node)\n                            ) {\n                                yield fixer.insertTextBefore(replacedNode, \"(\");\n                                yield fixer.insertTextAfter(replacedNode, \")\");\n                            }\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}