{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-promise-reject-errors.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892237030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview restrict values that can be used as Promise rejection reasons\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allowEmptyReject: false\n        }],\n\n        docs: {\n            description: \"Require using Error objects as Promise rejection reasons\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-promise-reject-errors\"\n        },\n\n        fixable: null,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyReject: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            rejectAnError: \"Expected the Promise rejection reason to be an Error.\"\n        }\n    },\n\n    create(context) {\n\n        const [{ allowEmptyReject }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error\n         * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise\n         * @returns {void}\n         */\n        function checkRejectCall(callExpression) {\n            if (!callExpression.arguments.length && allowEmptyReject) {\n                return;\n            }\n            if (\n                !callExpression.arguments.length ||\n                !astUtils.couldBeError(callExpression.arguments[0]) ||\n                callExpression.arguments[0].type === \"Identifier\" && callExpression.arguments[0].name === \"undefined\"\n            ) {\n                context.report({\n                    node: callExpression,\n                    messageId: \"rejectAnError\"\n                });\n            }\n        }\n\n        /**\n         * Determines whether a function call is a Promise.reject() call\n         * @param {ASTNode} node A CallExpression node\n         * @returns {boolean} `true` if the call is a Promise.reject() call\n         */\n        function isPromiseRejectCall(node) {\n            return astUtils.isSpecificMemberAccess(node.callee, \"Promise\", \"reject\");\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Check `Promise.reject(value)` calls.\n            CallExpression(node) {\n                if (isPromiseRejectCall(node)) {\n                    checkRejectCall(node);\n                }\n            },\n\n            /*\n             * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.\n             * This function is run on \"NewExpression:exit\" instead of \"NewExpression\" to ensure that\n             * the nodes in the expression already have the `parent` property.\n             */\n            \"NewExpression:exit\"(node) {\n                if (\n                    node.callee.type === \"Identifier\" && node.callee.name === \"Promise\" &&\n                    node.arguments.length && astUtils.isFunction(node.arguments[0]) &&\n                    node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === \"Identifier\"\n                ) {\n                    sourceCode.getDeclaredVariables(node.arguments[0])\n\n                        /*\n                         * Find the first variable that matches the second parameter's name.\n                         * If the first parameter has the same name as the second parameter, then the variable will actually\n                         * be \"declared\" when the first parameter is evaluated, but then it will be immediately overwritten\n                         * by the second parameter. It's not possible for an expression with the variable to be evaluated before\n                         * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or\n                         * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for\n                         * this case.\n                         */\n                        .find(variable => variable.name === node.arguments[0].params[1].name)\n\n                        // Get the references to that variable.\n                        .references\n\n                        // Only check the references that read the parameter's value.\n                        .filter(ref => ref.isRead())\n\n                        // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.\n                        .filter(ref => ref.identifier.parent.type === \"CallExpression\" && ref.identifier === ref.identifier.parent.callee)\n\n                        // Check the argument of the function call to determine whether it's an Error.\n                        .forEach(ref => checkRejectCall(ref.identifier.parent));\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}