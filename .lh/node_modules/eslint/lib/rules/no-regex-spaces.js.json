{
    "sourceFile": "node_modules/eslint/lib/rules/no-regex-spaces.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892230169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst regexpp = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst regExpParser = new regexpp.RegExpParser();\nconst DOUBLE_SPACE = / {2}/u;\n\n/**\n * Check if node is a string\n * @param {ASTNode} node node to evaluate\n * @returns {boolean} True if its a string\n * @private\n */\nfunction isString(node) {\n    return node && node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow multiple spaces in regular expressions\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-regex-spaces\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Validate regular expression\n         * @param {ASTNode} nodeToReport Node to report.\n         * @param {string} pattern Regular expression pattern to validate.\n         * @param {string} rawPattern Raw representation of the pattern in the source code.\n         * @param {number} rawPatternStartRange Start range of the pattern in the source code.\n         * @param {string} flags Regular expression flags.\n         * @returns {void}\n         * @private\n         */\n        function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\n\n            // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \\ ').\n            if (!DOUBLE_SPACE.test(rawPattern)) {\n                return;\n            }\n\n            const characterClassNodes = [];\n            let regExpAST;\n\n            try {\n                regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, { unicode: flags.includes(\"u\"), unicodeSets: flags.includes(\"v\") });\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(regExpAST, {\n                onCharacterClassEnter(ccNode) {\n                    characterClassNodes.push(ccNode);\n                }\n            });\n\n            const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;\n            let match;\n\n            while ((match = spacesPattern.exec(pattern))) {\n                const { 1: { length }, index } = match;\n\n                // Report only consecutive spaces that are not in character classes.\n                if (\n                    characterClassNodes.every(({ start, end }) => index < start || end <= index)\n                ) {\n                    context.report({\n                        node: nodeToReport,\n                        messageId: \"multipleSpaces\",\n                        data: { length },\n                        fix(fixer) {\n                            if (pattern !== rawPattern) {\n                                return null;\n                            }\n                            return fixer.replaceTextRange(\n                                [rawPatternStartRange + index, rawPatternStartRange + index + length],\n                                ` {${length}}`\n                            );\n                        }\n                    });\n\n                    // Report only the first occurrence of consecutive spaces\n                    return;\n                }\n            }\n        }\n\n        /**\n         * Validate regular expression literals\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkLiteral(node) {\n            if (node.regex) {\n                const pattern = node.regex.pattern;\n                const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\n                const rawPatternStartRange = node.range[0] + 1;\n                const flags = node.regex.flags;\n\n                checkRegex(\n                    node,\n                    pattern,\n                    rawPattern,\n                    rawPatternStartRange,\n                    flags\n                );\n            }\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const scope = sourceCode.getScope(node);\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\n            const patternNode = node.arguments[0];\n\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\n                const pattern = patternNode.value;\n                const rawPattern = patternNode.raw.slice(1, -1);\n                const rawPatternStartRange = patternNode.range[0] + 1;\n                let flags;\n\n                if (node.arguments.length < 2) {\n\n                    // It has no flags.\n                    flags = \"\";\n                } else {\n                    const flagsNode = node.arguments[1];\n\n                    if (isString(flagsNode)) {\n                        flags = flagsNode.value;\n                    } else {\n\n                        // The flags cannot be determined.\n                        return;\n                    }\n                }\n\n                checkRegex(\n                    node,\n                    pattern,\n                    rawPattern,\n                    rawPatternStartRange,\n                    flags\n                );\n            }\n        }\n\n        return {\n            Literal: checkLiteral,\n            CallExpression: checkFunction,\n            NewExpression: checkFunction\n        };\n    }\n};\n"
        }
    ]
}