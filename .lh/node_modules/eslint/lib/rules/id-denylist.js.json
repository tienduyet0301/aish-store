{
    "sourceFile": "node_modules/eslint/lib/rules/id-denylist.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892216455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule that warns when identifier names that are\n * specified in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is assignment target.\n */\nfunction isAssignmentTarget(node) {\n    const parent = node.parent;\n\n    return (\n\n        // normal assignment\n        (\n            parent.type === \"AssignmentExpression\" &&\n            parent.left === node\n        ) ||\n\n        // destructuring\n        parent.type === \"ArrayPattern\" ||\n        parent.type === \"RestElement\" ||\n        (\n            parent.type === \"Property\" &&\n            parent.value === node &&\n            parent.parent.type === \"ObjectPattern\"\n        ) ||\n        (\n            parent.type === \"AssignmentPattern\" &&\n            parent.left === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\n *\n * Examples:\n * import { a as b } from 'mod'; // node `a` is renamed import\n * export { a as b } from 'mod'; // node `a` is renamed import\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is a renamed import.\n */\nfunction isRenamedImport(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            parent.type === \"ImportSpecifier\" &&\n            parent.imported !== parent.local &&\n            parent.imported === node\n        ) ||\n        (\n            parent.type === \"ExportSpecifier\" &&\n            parent.parent.source && // re-export\n            parent.local !== parent.exported &&\n            parent.local === node\n        )\n    );\n}\n\n/**\n * Checks whether the given node is an ObjectPattern destructuring.\n *\n * Examples:\n * const { a : b } = foo;\n * @param {ASTNode} node `Identifier` node to check.\n * @returns {boolean} `true` if the node is in an ObjectPattern destructuring.\n */\nfunction isPropertyNameInDestructuring(node) {\n    const parent = node.parent;\n\n    return (\n        (\n            !parent.computed &&\n            parent.type === \"Property\" &&\n            parent.parent.type === \"ObjectPattern\" &&\n            parent.key === node\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [],\n\n        docs: {\n            description: \"Disallow specified identifiers\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/id-denylist\"\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        messages: {\n            restricted: \"Identifier '{{name}}' is restricted.\",\n            restrictedPrivate: \"Identifier '#{{name}}' is restricted.\"\n        }\n    },\n\n    create(context) {\n        const denyList = new Set(context.options);\n        const reportedNodes = new Set();\n        const sourceCode = context.sourceCode;\n\n        let globalScope;\n\n        /**\n         * Checks whether the given name is restricted.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is restricted.\n         * @private\n         */\n        function isRestricted(name) {\n            return denyList.has(name);\n        }\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether the given node should be checked.\n         * @param {ASTNode} node `Identifier` node.\n         * @returns {boolean} `true` if the node should be checked.\n         */\n        function shouldCheck(node) {\n\n            // Import attributes are defined by environments, so naming conventions shouldn't apply to them\n            if (astUtils.isImportAttributeKey(node)) {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            /*\n             * Member access has special rules for checking property names.\n             * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\n             * Write access isn't allowed, because it potentially creates a new property with a restricted name.\n             */\n            if (\n                parent.type === \"MemberExpression\" &&\n                parent.property === node &&\n                !parent.computed\n            ) {\n                return isAssignmentTarget(parent);\n            }\n\n            return (\n                parent.type !== \"CallExpression\" &&\n                parent.type !== \"NewExpression\" &&\n                !isRenamedImport(node) &&\n                !isPropertyNameInDestructuring(node) &&\n                !isReferenceToGlobalVariable(node)\n            );\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n\n            /*\n             * We used the range instead of the node because it's possible\n             * for the same identifier to be represented by two different\n             * nodes, with the most clear example being shorthand properties:\n             * { foo }\n             * In this case, \"foo\" is represented by one node for the name\n             * and one for the value. The only way to know they are the same\n             * is to look at the range.\n             */\n            if (!reportedNodes.has(node.range.toString())) {\n                const isPrivate = node.type === \"PrivateIdentifier\";\n\n                context.report({\n                    node,\n                    messageId: isPrivate ? \"restrictedPrivate\" : \"restricted\",\n                    data: {\n                        name: node.name\n                    }\n                });\n                reportedNodes.add(node.range.toString());\n            }\n        }\n\n        return {\n\n            Program(node) {\n                globalScope = sourceCode.getScope(node);\n            },\n\n            [[\n                \"Identifier\",\n                \"PrivateIdentifier\"\n            ]](node) {\n                if (isRestricted(node.name) && shouldCheck(node)) {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}