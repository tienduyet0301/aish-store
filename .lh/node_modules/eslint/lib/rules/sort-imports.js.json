{
    "sourceFile": "node_modules/eslint/lib/rules/sort-imports.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce sorted `import` declarations within modules\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allowSeparatedGroups: false,\n            ignoreCase: false,\n            ignoreDeclarationSort: false,\n            ignoreMemberSort: false,\n            memberSyntaxSortOrder: [\"none\", \"all\", \"multiple\", \"single\"]\n        }],\n\n        docs: {\n            description: \"Enforce sorted `import` declarations within modules\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/sort-imports\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\"\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreDeclarationSort: {\n                        type: \"boolean\"\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\"\n                    },\n                    allowSeparatedGroups: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n            sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n            unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n        }\n    },\n\n    create(context) {\n        const [{\n            ignoreCase,\n            ignoreDeclarationSort,\n            ignoreMemberSort,\n            memberSyntaxSortOrder,\n            allowSeparatedGroups\n        }] = context.options;\n        const sourceCode = context.sourceCode;\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            }\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            }\n            if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        /**\n         * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\n         * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\n         * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\n         * on two consecutive lines.\n         * @param {ASTNode} left node that appears before the given `right` node.\n         * @param {ASTNode} right node that appears after the given `left` node.\n         * @returns {number} number of lines between nodes.\n         */\n        function getNumberOfLinesBetween(left, right) {\n            return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (!ignoreDeclarationSort) {\n                    if (\n                        previousDeclaration &&\n                        allowSeparatedGroups &&\n                        getNumberOfLinesBetween(previousDeclaration, node) > 0\n                    ) {\n\n                        // reset declaration sort\n                        previousDeclaration = null;\n                    }\n\n                    if (previousDeclaration) {\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                        if (ignoreCase) {\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                        }\n\n                        /*\n                         * When the current declaration uses a different member syntax,\n                         * then check if the ordering is correct.\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                         */\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                                context.report({\n                                    node,\n                                    messageId: \"unexpectedSyntaxOrder\",\n                                    data: {\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                    }\n                                });\n                            }\n                        } else {\n                            if (previousLocalMemberName &&\n                                currentLocalMemberName &&\n                                currentLocalMemberName < previousLocalMemberName\n                            ) {\n                                context.report({\n                                    node,\n                                    messageId: \"sortImportsAlphabetically\"\n                                });\n                            }\n                        }\n                    }\n\n                    previousDeclaration = node;\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            messageId: \"sortMembersAlphabetically\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier =>\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers.at(-1).range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}