{
    "sourceFile": "node_modules/eslint/lib/rules/no-prototype-builtins.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892230044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow use of Object.prototype builtins on objects\n * @author Andrew Levine\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Returns true if the node or any of the objects\n * to the left of it in the member/call chain is optional.\n *\n * e.g. `a?.b`, `a?.b.c`, `a?.()`, `a()?.()`\n * @param {ASTNode} node The expression to check\n * @returns {boolean} `true` if there is a short-circuiting optional `?.`\n * in the same option chain to the left of this call or member expression,\n * or the node itself is an optional call or member `?.`.\n */\nfunction isAfterOptional(node) {\n    let leftNode;\n\n    if (node.type === \"MemberExpression\") {\n        leftNode = node.object;\n    } else if (node.type === \"CallExpression\") {\n        leftNode = node.callee;\n    } else {\n        return false;\n    }\n    if (node.optional) {\n        return true;\n    }\n    return isAfterOptional(leftNode);\n}\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow calling some `Object.prototype` methods directly on objects\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-prototype-builtins\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            prototypeBuildIn: \"Do not access Object.prototype method '{{prop}}' from target object.\",\n            callObjectPrototype: \"Call Object.prototype.{{prop}} explicitly.\"\n        }\n    },\n\n    create(context) {\n        const DISALLOWED_PROPS = new Set([\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\"\n        ]);\n\n        /**\n         * Reports if a disallowed property is used in a CallExpression\n         * @param {ASTNode} node The CallExpression node.\n         * @returns {void}\n         */\n        function disallowBuiltIns(node) {\n\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type !== \"MemberExpression\") {\n                return;\n            }\n\n            const propName = astUtils.getStaticPropertyName(callee);\n\n            if (propName !== null && DISALLOWED_PROPS.has(propName)) {\n                context.report({\n                    messageId: \"prototypeBuildIn\",\n                    loc: callee.property.loc,\n                    data: { prop: propName },\n                    node,\n                    suggest: [\n                        {\n                            messageId: \"callObjectPrototype\",\n                            data: { prop: propName },\n                            fix(fixer) {\n                                const sourceCode = context.sourceCode;\n\n                                /*\n                                 * A call after an optional chain (e.g. a?.b.hasOwnProperty(c))\n                                 * must be fixed manually because the call can be short-circuited\n                                 */\n                                if (isAfterOptional(node)) {\n                                    return null;\n                                }\n\n                                /*\n                                 * A call on a ChainExpression (e.g. (a?.hasOwnProperty)(c)) will trigger\n                                 * no-unsafe-optional-chaining which should be fixed before this suggestion\n                                 */\n                                if (node.callee.type === \"ChainExpression\") {\n                                    return null;\n                                }\n\n                                const objectVariable = astUtils.getVariableByName(sourceCode.getScope(node), \"Object\");\n\n                                /*\n                                 * We can't use Object if the global Object was shadowed,\n                                 * or Object does not exist in the global scope for some reason\n                                 */\n                                if (!objectVariable || objectVariable.scope.type !== \"global\" || objectVariable.defs.length > 0) {\n                                    return null;\n                                }\n\n                                let objectText = sourceCode.getText(callee.object);\n\n                                if (astUtils.getPrecedence(callee.object) <= astUtils.getPrecedence({ type: \"SequenceExpression\" })) {\n                                    objectText = `(${objectText})`;\n                                }\n\n                                const openParenToken = sourceCode.getTokenAfter(\n                                    node.callee,\n                                    astUtils.isOpeningParenToken\n                                );\n                                const isEmptyParameters = node.arguments.length === 0;\n                                const delim = isEmptyParameters ? \"\" : \", \";\n                                const fixes = [\n                                    fixer.replaceText(callee, `Object.prototype.${propName}.call`),\n                                    fixer.insertTextAfter(openParenToken, objectText + delim)\n                                ];\n\n                                return fixes;\n                            }\n                        }\n                    ]\n                });\n            }\n        }\n\n        return {\n            CallExpression: disallowBuiltIns\n        };\n    }\n};\n"
        }
    ]
}