{
    "sourceFile": "node_modules/eslint/lib/rules/for-direction.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892215479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview enforce `for` loop update clause moving the counter in the right direction.(for-direction)\n * @author Aladdin-ADD<hh_2013@foxmail.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst { getStaticValue } = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Enforce `for` loop update clause moving the counter in the right direction\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/for-direction\"\n        },\n\n        fixable: null,\n        schema: [],\n\n        messages: {\n            incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n        }\n    },\n\n    create(context) {\n        const { sourceCode } = context;\n\n        /**\n         * report an error.\n         * @param {ASTNode} node the node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"incorrectDirection\"\n            });\n        }\n\n        /**\n         * check the right side of the assignment\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {int} dir expected direction that could either be turned around or invalidated\n         * @returns {int} return dir, the negated dir, or zero if the counter does not change or the direction is not clear\n         */\n        function getRightDirection(update, dir) {\n            const staticValue = getStaticValue(update.right, sourceCode.getScope(update));\n\n            if (staticValue && [\"bigint\", \"boolean\", \"number\"].includes(typeof staticValue.value)) {\n                const sign = Math.sign(Number(staticValue.value)) || 0; // convert NaN to 0\n\n                return dir * sign;\n            }\n            return 0;\n        }\n\n        /**\n         * check UpdateExpression add/sub the counter\n         * @param {ASTNode} update UpdateExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getUpdateDirection(update, counter) {\n            if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n                if (update.operator === \"++\") {\n                    return 1;\n                }\n                if (update.operator === \"--\") {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n\n        /**\n         * check AssignmentExpression add/sub the counter\n         * @param {ASTNode} update AssignmentExpression to check\n         * @param {string} counter variable name to check\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\n         */\n        function getAssignmentDirection(update, counter) {\n            if (update.left.name === counter) {\n                if (update.operator === \"+=\") {\n                    return getRightDirection(update, 1);\n                }\n                if (update.operator === \"-=\") {\n                    return getRightDirection(update, -1);\n                }\n            }\n            return 0;\n        }\n\n        return {\n            ForStatement(node) {\n\n                if (node.test && node.test.type === \"BinaryExpression\" && node.update) {\n                    for (const counterPosition of [\"left\", \"right\"]) {\n                        if (node.test[counterPosition].type !== \"Identifier\") {\n                            continue;\n                        }\n\n                        const counter = node.test[counterPosition].name;\n                        const operator = node.test.operator;\n                        const update = node.update;\n\n                        let wrongDirection;\n\n                        if (operator === \"<\" || operator === \"<=\") {\n                            wrongDirection = counterPosition === \"left\" ? -1 : 1;\n                        } else if (operator === \">\" || operator === \">=\") {\n                            wrongDirection = counterPosition === \"left\" ? 1 : -1;\n                        } else {\n                            return;\n                        }\n\n                        if (update.type === \"UpdateExpression\") {\n                            if (getUpdateDirection(update, counter) === wrongDirection) {\n                                report(node);\n                            }\n                        } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n                            report(node);\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}