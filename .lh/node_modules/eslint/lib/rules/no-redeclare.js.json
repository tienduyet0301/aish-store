{
    "sourceFile": "node_modules/eslint/lib/rules/no-redeclare.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892230106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag when the same variable is declared more then once.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{ builtinGlobals: true }],\n\n        docs: {\n            description: \"Disallow variable redeclaration\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-redeclare\"\n        },\n\n        messages: {\n            redeclared: \"'{{id}}' is already defined.\",\n            redeclaredAsBuiltin: \"'{{id}}' is already defined as a built-in global variable.\",\n            redeclaredBySyntax: \"'{{id}}' is already defined by a variable declaration.\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const [{ builtinGlobals }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Iterate declarations of a given variable.\n         * @param {escope.variable} variable The variable object to iterate declarations.\n         * @returns {IterableIterator<{type:string,node:ASTNode,loc:SourceLocation}>} The declarations.\n         */\n        function *iterateDeclarations(variable) {\n            if (builtinGlobals && (\n                variable.eslintImplicitGlobalSetting === \"readonly\" ||\n                variable.eslintImplicitGlobalSetting === \"writable\"\n            )) {\n                yield { type: \"builtin\" };\n            }\n\n            for (const id of variable.identifiers) {\n                yield { type: \"syntax\", node: id, loc: id.loc };\n            }\n\n            if (variable.eslintExplicitGlobalComments) {\n                for (const comment of variable.eslintExplicitGlobalComments) {\n                    yield {\n                        type: \"comment\",\n                        node: comment,\n                        loc: astUtils.getNameLocationInGlobalDirectiveComment(\n                            sourceCode,\n                            comment,\n                            variable.name\n                        )\n                    };\n                }\n            }\n        }\n\n        /**\n         * Find variables in a given scope and flag redeclared ones.\n         * @param {Scope} scope An eslint-scope scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            for (const variable of scope.variables) {\n                const [\n                    declaration,\n                    ...extraDeclarations\n                ] = iterateDeclarations(variable);\n\n                if (extraDeclarations.length === 0) {\n                    continue;\n                }\n\n                /*\n                 * If the type of a declaration is different from the type of\n                 * the first declaration, it shows the location of the first\n                 * declaration.\n                 */\n                const detailMessageId = declaration.type === \"builtin\"\n                    ? \"redeclaredAsBuiltin\"\n                    : \"redeclaredBySyntax\";\n                const data = { id: variable.name };\n\n                // Report extra declarations.\n                for (const { type, node, loc } of extraDeclarations) {\n                    const messageId = type === declaration.type\n                        ? \"redeclared\"\n                        : detailMessageId;\n\n                    context.report({ node, loc, messageId, data });\n                }\n            }\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @param {ASTNode} node The node of the current scope.\n         * @returns {void}\n         * @private\n         */\n        function checkForBlock(node) {\n            const scope = sourceCode.getScope(node);\n\n            /*\n             * In ES5, some node type such as `BlockStatement` doesn't have that scope.\n             * `scope.block` is a different node in such a case.\n             */\n            if (scope.block === node) {\n                findVariablesInScope(scope);\n            }\n        }\n\n        return {\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n\n                findVariablesInScope(scope);\n\n                // Node.js or ES modules has a special scope.\n                if (\n                    scope.type === \"global\" &&\n                    scope.childScopes[0] &&\n\n                    // The special scope's block is the Program node.\n                    scope.block === scope.childScopes[0].block\n                ) {\n                    findVariablesInScope(scope.childScopes[0]);\n                }\n            },\n\n            FunctionDeclaration: checkForBlock,\n            FunctionExpression: checkForBlock,\n            ArrowFunctionExpression: checkForBlock,\n\n            StaticBlock: checkForBlock,\n\n            BlockStatement: checkForBlock,\n            ForStatement: checkForBlock,\n            ForInStatement: checkForBlock,\n            ForOfStatement: checkForBlock,\n            SwitchStatement: checkForBlock\n        };\n    }\n};\n"
        }
    ]
}