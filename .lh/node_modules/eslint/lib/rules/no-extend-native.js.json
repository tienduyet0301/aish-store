{
    "sourceFile": "node_modules/eslint/lib/rules/no-extend-native.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892225330,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{ exceptions: [] }],\n\n        docs: {\n            description: \"Disallow extending native types\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-extend-native\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const exceptions = new Set(context.options[0].exceptions);\n        const modifiedBuiltins = new Set(\n            Object.keys(astUtils.ECMASCRIPT_GLOBALS)\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\n                .filter(builtin => !exceptions.has(builtin))\n        );\n\n        /**\n         * Reports a lint error for the given node.\n         * @param {ASTNode} node The node to report.\n         * @param {string} builtin The name of the native builtin being extended.\n         * @returns {void}\n         */\n        function reportNode(node, builtin) {\n            context.report({\n                node,\n                messageId: \"unexpected\",\n                data: {\n                    builtin\n                }\n            });\n        }\n\n        /**\n         * Check to see if the `prototype` property of the given object\n         * identifier node is being accessed.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * to check.\n         * @returns {boolean} True if the identifier is the object of a\n         * MemberExpression and its `prototype` property is being accessed,\n         * false otherwise.\n         */\n        function isPrototypePropertyAccessed(identifierNode) {\n            return Boolean(\n                identifierNode &&\n                identifierNode.parent &&\n                identifierNode.parent.type === \"MemberExpression\" &&\n                identifierNode.parent.object === identifierNode &&\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\n            );\n        }\n\n        /**\n         * Check if it's an assignment to the property of the given node.\n         * Example: `*.prop = 0` // the `*` is the given node.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if an assignment to the property of the node.\n         */\n        function isAssigningToPropertyOf(node) {\n            return (\n                node.parent.type === \"MemberExpression\" &&\n                node.parent.object === node &&\n                node.parent.parent.type === \"AssignmentExpression\" &&\n                node.parent.parent.left === node.parent\n            );\n        }\n\n        /**\n         * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\n         */\n        function isInDefinePropertyCall(node) {\n            return (\n                node.parent.type === \"CallExpression\" &&\n                node.parent.arguments[0] === node &&\n                astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u)\n            );\n        }\n\n        /**\n         * Check to see if object prototype access is part of a prototype\n         * extension. There are three ways a prototype can be extended:\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\n         * If prototype extension is detected, report the AssignmentExpression\n         * or CallExpression node.\n         * @param {ASTNode} identifierNode The Identifier representing the object\n         * which prototype is being accessed and possibly extended.\n         * @returns {void}\n         */\n        function checkAndReportPrototypeExtension(identifierNode) {\n            if (!isPrototypePropertyAccessed(identifierNode)) {\n                return; // This is not `*.prototype` access.\n            }\n\n            /*\n             * `identifierNode.parent` is a MemberExpression `*.prototype`.\n             * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\n             */\n            const prototypeNode =\n                identifierNode.parent.parent.type === \"ChainExpression\"\n                    ? identifierNode.parent.parent\n                    : identifierNode.parent;\n\n            if (isAssigningToPropertyOf(prototypeNode)) {\n\n                // `*.prototype` -> MemberExpression -> AssignmentExpression\n                reportNode(prototypeNode.parent.parent, identifierNode.name);\n            } else if (isInDefinePropertyCall(prototypeNode)) {\n\n                // `*.prototype` -> CallExpression\n                reportNode(prototypeNode.parent, identifierNode.name);\n            }\n        }\n\n        return {\n\n            \"Program:exit\"(node) {\n                const globalScope = sourceCode.getScope(node);\n\n                modifiedBuiltins.forEach(builtin => {\n                    const builtinVar = globalScope.set.get(builtin);\n\n                    if (builtinVar && builtinVar.references) {\n                        builtinVar.references\n                            .map(ref => ref.identifier)\n                            .forEach(checkAndReportPrototypeExtension);\n                    }\n                });\n            }\n        };\n\n    }\n};\n"
        }
    ]
}