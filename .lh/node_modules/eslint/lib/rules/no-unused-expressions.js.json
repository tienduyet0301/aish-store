{
    "sourceFile": "node_modules/eslint/lib/rules/no-unused-expressions.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns `true`.\n * @returns {boolean} `true`.\n */\nfunction alwaysTrue() {\n    return true;\n}\n\n/**\n * Returns `false`.\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n    return false;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unused expressions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-expressions\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\"\n                    },\n                    allowTernary: {\n                        type: \"boolean\"\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\"\n                    },\n                    enforceForJSX: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        defaultOptions: [{\n            allowShortCircuit: false,\n            allowTernary: false,\n            allowTaggedTemplates: false,\n            enforceForJSX: false\n        }],\n\n        messages: {\n            unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n        }\n    },\n\n    create(context) {\n        const [{\n            allowShortCircuit,\n            allowTernary,\n            allowTaggedTemplates,\n            enforceForJSX\n        }] = context.options;\n\n        /**\n         * Has AST suggesting a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Gets the leading sequence of members in a list that pass the predicate.\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        /**\n         * Gets leading directives nodes in a Node body.\n         * @param {ASTNode} node a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * Detect if a Node is a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node) {\n\n            /**\n             * https://tc39.es/ecma262/#directive-prologue\n             *\n             * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\n             * Class static blocks do not have directive prologue.\n             */\n            return astUtils.isTopLevelExpressionStatement(node) && directives(node.parent).includes(node);\n        }\n\n        /**\n         * The member functions return `true` if the type has no side-effects.\n         * Unknown nodes are handled as `false`, then this rule ignores those.\n         */\n        const Checker = Object.assign(Object.create(null), {\n            isDisallowed(node) {\n                return (Checker[node.type] || alwaysFalse)(node);\n            },\n\n            ArrayExpression: alwaysTrue,\n            ArrowFunctionExpression: alwaysTrue,\n            BinaryExpression: alwaysTrue,\n            ChainExpression(node) {\n                return Checker.isDisallowed(node.expression);\n            },\n            ClassExpression: alwaysTrue,\n            ConditionalExpression(node) {\n                if (allowTernary) {\n                    return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n                }\n                return true;\n            },\n            FunctionExpression: alwaysTrue,\n            Identifier: alwaysTrue,\n            JSXElement() {\n                return enforceForJSX;\n            },\n            JSXFragment() {\n                return enforceForJSX;\n            },\n            Literal: alwaysTrue,\n            LogicalExpression(node) {\n                if (allowShortCircuit) {\n                    return Checker.isDisallowed(node.right);\n                }\n                return true;\n            },\n            MemberExpression: alwaysTrue,\n            MetaProperty: alwaysTrue,\n            ObjectExpression: alwaysTrue,\n            SequenceExpression: alwaysTrue,\n            TaggedTemplateExpression() {\n                return !allowTaggedTemplates;\n            },\n            TemplateLiteral: alwaysTrue,\n            ThisExpression: alwaysTrue,\n            UnaryExpression(node) {\n                return node.operator !== \"void\" && node.operator !== \"delete\";\n            }\n        });\n\n        return {\n            ExpressionStatement(node) {\n                if (Checker.isDisallowed(node.expression) && !isDirective(node)) {\n                    context.report({ node, messageId: \"unusedExpression\" });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}