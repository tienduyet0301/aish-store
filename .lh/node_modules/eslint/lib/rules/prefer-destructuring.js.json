{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-destructuring.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892235952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: \"AssignmentExpression\" });\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require destructuring from arrays and/or objects\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/prefer-destructuring\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n\n                /*\n                 * old support {array: Boolean, object: Boolean}\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\n                 */\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            VariableDeclarator: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            },\n                            AssignmentExpression: {\n                                type: \"object\",\n                                properties: {\n                                    array: {\n                                        type: \"boolean\"\n                                    },\n                                    object: {\n                                        type: \"boolean\"\n                                    }\n                                },\n                                additionalProperties: false\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            array: {\n                                type: \"boolean\"\n                            },\n                            object: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            preferDestructuring: \"Use {{type}} destructuring.\"\n        }\n    },\n    create(context) {\n\n        const enabledTypes = context.options[0];\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n        let normalizedOptions = {\n            VariableDeclarator: { array: true, object: true },\n            AssignmentExpression: { array: true, object: true }\n        };\n\n        if (enabledTypes) {\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\n                : enabledTypes;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks if destructuring type should be checked.\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\n         * @param {string} destructuringType \"array\" or \"object\"\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\n         */\n        function shouldCheck(nodeType, destructuringType) {\n            return normalizedOptions &&\n                normalizedOptions[nodeType] &&\n                normalizedOptions[nodeType][destructuringType];\n        }\n\n        /**\n         * Determines if the given node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @param {Function|null} fix the fix function or null to pass to context.report\n         * @returns {void}\n         */\n        function report(reportNode, type, fix) {\n            context.report({\n                node: reportNode,\n                messageId: \"preferDestructuring\",\n                data: { type },\n                fix\n            });\n        }\n\n        /**\n         * Determines if a node should be fixed into object destructuring\n         *\n         * The fixer only fixes the simplest case of object destructuring,\n         * like: `let x = a.x`;\n         *\n         * Assignment expression is not fixed.\n         * Array destructuring is not fixed.\n         * Renamed property is not fixed.\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node should be fixed\n         */\n        function shouldFix(node) {\n            return node.type === \"VariableDeclarator\" &&\n                node.id.type === \"Identifier\" &&\n                node.init.type === \"MemberExpression\" &&\n                !node.init.computed &&\n                node.init.property.type === \"Identifier\" &&\n                node.id.name === node.init.property.name;\n        }\n\n        /**\n         * Fix a node into object destructuring.\n         * This function only handles the simplest case of object destructuring,\n         * see {@link shouldFix}.\n         * @param {SourceCodeFixer} fixer the fixer object\n         * @param {ASTNode} node the node to be fixed.\n         * @returns {Object} a fix for the node\n         */\n        function fixIntoObjectDestructuring(fixer, node) {\n            const rightNode = node.init;\n            const sourceCode = context.sourceCode;\n\n            // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n                return null;\n            }\n\n            let objectText = sourceCode.getText(rightNode.object);\n\n            if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                objectText = `(${objectText})`;\n            }\n\n            return fixer.replaceText(\n                node,\n                `{${rightNode.property.name}} = ${objectText}`\n            );\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (\n                rightNode.type !== \"MemberExpression\" ||\n                rightNode.object.type === \"Super\" ||\n                rightNode.property.type === \"PrivateIdentifier\"\n            ) {\n                return;\n            }\n\n            if (isArrayIndexAccess(rightNode)) {\n                if (shouldCheck(reportNode.type, \"array\")) {\n                    report(reportNode, \"array\", null);\n                }\n                return;\n            }\n\n            const fix = shouldFix(reportNode)\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\n                : null;\n\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n                report(reportNode, \"object\", fix);\n                return;\n            }\n\n            if (shouldCheck(reportNode.type, \"object\")) {\n                const property = rightNode.property;\n\n                if (\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\n                ) {\n                    report(reportNode, \"object\", fix);\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssignmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssignmentExpression\n        };\n    }\n};\n"
        }
    ]
}