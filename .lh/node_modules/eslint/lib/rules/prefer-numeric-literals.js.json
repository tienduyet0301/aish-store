{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-numeric-literals.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892236746,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst radixMap = new Map([\n    [2, { system: \"binary\", literalPrefix: \"0b\" }],\n    [8, { system: \"octal\", literalPrefix: \"0o\" }],\n    [16, { system: \"hexadecimal\", literalPrefix: \"0x\" }]\n]);\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    return (\n        astUtils.isSpecificId(calleeNode, \"parseInt\") ||\n        astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/prefer-numeric-literals\"\n        },\n\n        schema: [],\n\n        messages: {\n            useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            \"CallExpression[arguments.length=2]\"(node) {\n                const [strNode, radixNode] = node.arguments,\n                    str = astUtils.getStaticStringValue(strNode),\n                    radix = radixNode.value;\n\n                if (\n                    str !== null &&\n                    astUtils.isStringLiteral(strNode) &&\n                    radixNode.type === \"Literal\" &&\n                    typeof radix === \"number\" &&\n                    radixMap.has(radix) &&\n                    isParseInt(node.callee)\n                ) {\n\n                    const { system, literalPrefix } = radixMap.get(radix);\n\n                    context.report({\n                        node,\n                        messageId: \"useLiteral\",\n                        data: {\n                            system,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            if (sourceCode.getCommentsInside(node).length) {\n                                return null;\n                            }\n\n                            const replacement = `${literalPrefix}${str}`;\n\n                            if (+replacement !== parseInt(str, radix)) {\n\n                                /*\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                 *\n                                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\n                                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\n                                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\n                                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\n                                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\n                                 * so the autofix would be invalid:\n                                 *\n                                 *   parseInt(\"1_1\", 2) // === 1\n                                 *   0b1_1 // === 3\n                                 */\n                                return null;\n                            }\n\n                            const tokenBefore = sourceCode.getTokenBefore(node),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n                            let prefix = \"\",\n                                suffix = \"\";\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(replacement, tokenAfter)\n                            ) {\n                                suffix = \" \";\n                            }\n\n                            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}