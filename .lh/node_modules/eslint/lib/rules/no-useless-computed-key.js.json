{
    "sourceFile": "node_modules/eslint/lib/rules/no-useless-computed-key.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892233041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the computed key syntax is unnecessarily used for the given node.\n * In particular, it determines whether removing the square brackets and using the content between them\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\n * Valid non-computed keys are only: identifiers, number literals and string literals.\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\n * Property\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\n *     { \"__proto__\": foo } defines object's prototype\n * PropertyDefinition\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\n *     class C { \"constructor\"; } produces a parsing error\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\n *     class C { static \"constructor\"; } produces a parsing error\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\n * MethodDefinition\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\n *     class C { \"constructor\"() {} } defines the constructor\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\n * @throws {Error} (Unreachable.)\n * @returns {void} `true` if the node has useless computed key.\n */\nfunction hasUselessComputedKey(node) {\n    if (!node.computed) {\n        return false;\n    }\n\n    const { key } = node;\n\n    if (key.type !== \"Literal\") {\n        return false;\n    }\n\n    const { value } = key;\n\n    if (typeof value !== \"number\" && typeof value !== \"string\") {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"Property\":\n            if (node.parent.type === \"ObjectExpression\") {\n                return value !== \"__proto__\";\n            }\n            return true;\n\n        case \"PropertyDefinition\":\n            if (node.static) {\n                return value !== \"constructor\" && value !== \"prototype\";\n            }\n\n            return value !== \"constructor\";\n\n        case \"MethodDefinition\":\n            if (node.static) {\n                return value !== \"prototype\";\n            }\n\n            return value !== \"constructor\";\n\n        /* c8 ignore next */\n        default:\n            throw new Error(`Unexpected node type: ${node.type}`);\n    }\n\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            enforceForClassMembers: true\n        }],\n\n        docs: {\n            description: \"Disallow unnecessary computed property keys in objects and classes\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const [{ enforceForClassMembers }] = context.options;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (hasUselessComputedKey(node)) {\n                const { key } = node;\n\n                context.report({\n                    node,\n                    messageId: \"unnecessarilyComputedProperty\",\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n                        // If there are comments between the brackets and the property name, don't do a fix.\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : noop,\n            PropertyDefinition: enforceForClassMembers ? check : noop\n        };\n    }\n};\n"
        }
    ]
}