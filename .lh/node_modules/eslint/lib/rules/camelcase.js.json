{
    "sourceFile": "node_modules/eslint/lib/rules/camelcase.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892214336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allow: [],\n            ignoreDestructuring: false,\n            ignoreGlobals: false,\n            ignoreImports: false,\n            properties: \"always\"\n        }],\n\n        docs: {\n            description: \"Enforce camelcase naming convention\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\"\n                    },\n                    ignoreImports: {\n                        type: \"boolean\"\n                    },\n                    ignoreGlobals: {\n                        type: \"boolean\"\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\n            notCamelCasePrivate: \"#{{name}} is not in camel case.\"\n        }\n    },\n\n    create(context) {\n        const [{\n            allow,\n            ignoreDestructuring,\n            ignoreGlobals,\n            ignoreImports,\n            properties\n        }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = new Set();\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n            const nameBody = name.replace(/^_+|_+$/gu, \"\");\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.some(\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\n            );\n        }\n\n        /**\n         * Checks if a given name is good or not.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is good.\n         * @private\n         */\n        function isGoodName(name) {\n            return !isUnderscored(name) || isAllowed(name);\n        }\n\n        /**\n         * Checks if a given identifier reference or member expression is an assignment\n         * target.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is an assignment target.\n         */\n        function isAssignmentTarget(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    return parent.left === node;\n\n                case \"Property\":\n                    return (\n                        parent.parent.type === \"ObjectPattern\" &&\n                        parent.value === node\n                    );\n                case \"ArrayPattern\":\n                case \"RestElement\":\n                    return true;\n\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Checks if a given binding identifier uses the original name as-is.\n         * - If it's in object destructuring or object expression, the original name is its property name.\n         * - If it's in import declaration, the original name is its exported name.\n         * @param {ASTNode} node The `Identifier` node to check.\n         * @returns {boolean} `true` if the identifier uses the original name as-is.\n         */\n        function equalsToOriginalName(node) {\n            const localName = node.name;\n            const valueNode = node.parent.type === \"AssignmentPattern\"\n                ? node.parent\n                : node;\n            const parent = valueNode.parent;\n\n            switch (parent.type) {\n                case \"Property\":\n                    return (\n                        (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") &&\n                        parent.value === valueNode &&\n                        !parent.computed &&\n                        parent.key.type === \"Identifier\" &&\n                        parent.key.name === localName\n                    );\n\n                case \"ImportSpecifier\":\n                    return (\n                        parent.local === node &&\n                        astUtils.getModuleExportName(parent.imported) === localName\n                    );\n\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.has(node.range[0])) {\n                return;\n            }\n            reported.add(node.range[0]);\n\n            // Report it.\n            context.report({\n                node,\n                messageId: node.type === \"PrivateIdentifier\"\n                    ? \"notCamelCasePrivate\"\n                    : \"notCamelCase\",\n                data: { name: node.name }\n            });\n        }\n\n        /**\n         * Reports an identifier reference or a binding identifier.\n         * @param {ASTNode} node The `Identifier` node to report.\n         * @returns {void}\n         */\n        function reportReferenceId(node) {\n\n            /*\n             * For backward compatibility, if it's in callings then ignore it.\n             * Not sure why it is.\n             */\n            if (\n                node.parent.type === \"CallExpression\" ||\n                node.parent.type === \"NewExpression\"\n            ) {\n                return;\n            }\n\n            /*\n             * For backward compatibility, if it's a default value of\n             * destructuring/parameters then ignore it.\n             * Not sure why it is.\n             */\n            if (\n                node.parent.type === \"AssignmentPattern\" &&\n                node.parent.right === node\n            ) {\n                return;\n            }\n\n            /*\n             * The `ignoreDestructuring` flag skips the identifiers that uses\n             * the property name as-is.\n             */\n            if (ignoreDestructuring && equalsToOriginalName(node)) {\n                return;\n            }\n\n            /*\n             * Import attribute keys are always ignored\n             */\n            if (astUtils.isImportAttributeKey(node)) {\n                return;\n            }\n\n            report(node);\n        }\n\n        return {\n\n            // Report camelcase of global variable references ------------------\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n\n                if (!ignoreGlobals) {\n\n                    // Defined globals in config files or directive comments.\n                    for (const variable of scope.variables) {\n                        if (\n                            variable.identifiers.length > 0 ||\n                            isGoodName(variable.name)\n                        ) {\n                            continue;\n                        }\n                        for (const reference of variable.references) {\n\n                            /*\n                             * For backward compatibility, this rule reports read-only\n                             * references as well.\n                             */\n                            reportReferenceId(reference.identifier);\n                        }\n                    }\n                }\n\n                // Undefined globals.\n                for (const reference of scope.through) {\n                    const id = reference.identifier;\n\n                    if (isGoodName(id.name) || astUtils.isImportAttributeKey(id)) {\n                        continue;\n                    }\n\n                    /*\n                     * For backward compatibility, this rule reports read-only\n                     * references as well.\n                     */\n                    reportReferenceId(id);\n                }\n            },\n\n            // Report camelcase of declared variables --------------------------\n            [[\n                \"VariableDeclaration\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ArrowFunctionExpression\",\n                \"ClassDeclaration\",\n                \"ClassExpression\",\n                \"CatchClause\"\n            ]](node) {\n                for (const variable of sourceCode.getDeclaredVariables(node)) {\n                    if (isGoodName(variable.name)) {\n                        continue;\n                    }\n                    const id = variable.identifiers[0];\n\n                    // Report declaration.\n                    if (!(ignoreDestructuring && equalsToOriginalName(id))) {\n                        report(id);\n                    }\n\n                    /*\n                     * For backward compatibility, report references as well.\n                     * It looks unnecessary because declarations are reported.\n                     */\n                    for (const reference of variable.references) {\n                        if (reference.init) {\n                            continue; // Skip the write references of initializers.\n                        }\n                        reportReferenceId(reference.identifier);\n                    }\n                }\n            },\n\n            // Report camelcase in properties ----------------------------------\n            [[\n                \"ObjectExpression > Property[computed!=true] > Identifier.key\",\n                \"MethodDefinition[computed!=true] > Identifier.key\",\n                \"PropertyDefinition[computed!=true] > Identifier.key\",\n                \"MethodDefinition > PrivateIdentifier.key\",\n                \"PropertyDefinition > PrivateIdentifier.key\"\n            ]](node) {\n                if (properties === \"never\" || astUtils.isImportAttributeKey(node) || isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            },\n            \"MemberExpression[computed!=true] > Identifier.property\"(node) {\n                if (\n                    properties === \"never\" ||\n                    !isAssignmentTarget(node.parent) || // ← ignore read-only references.\n                    isGoodName(node.name)\n                ) {\n                    return;\n                }\n                report(node);\n            },\n\n            // Report camelcase in import --------------------------------------\n            ImportDeclaration(node) {\n                for (const variable of sourceCode.getDeclaredVariables(node)) {\n                    if (isGoodName(variable.name)) {\n                        continue;\n                    }\n                    const id = variable.identifiers[0];\n\n                    // Report declaration.\n                    if (!(ignoreImports && equalsToOriginalName(id))) {\n                        report(id);\n                    }\n\n                    /*\n                     * For backward compatibility, report references as well.\n                     * It looks unnecessary because declarations are reported.\n                     */\n                    for (const reference of variable.references) {\n                        reportReferenceId(reference.identifier);\n                    }\n                }\n            },\n\n            // Report camelcase in re-export -----------------------------------\n            [[\n                \"ExportAllDeclaration > Identifier.exported\",\n                \"ExportSpecifier > Identifier.exported\"\n            ]](node) {\n                if (isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            },\n\n            // Report camelcase in labels --------------------------------------\n            [[\n                \"LabeledStatement > Identifier.label\",\n\n                /*\n                 * For backward compatibility, report references as well.\n                 * It looks unnecessary because declarations are reported.\n                 */\n                \"BreakStatement > Identifier.label\",\n                \"ContinueStatement > Identifier.label\"\n            ]](node) {\n                if (isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            }\n        };\n    }\n};\n"
        }
    ]
}