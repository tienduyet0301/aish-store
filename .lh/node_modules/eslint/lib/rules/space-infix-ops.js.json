{
    "sourceFile": "node_modules/eslint/lib/rules/space-infix-ops.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\nconst { isEqToken } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"space-infix-ops\",\n                        url: \"https://eslint.style/rules/js/space-infix-ops\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require spacing around infix operators\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/space-infix-ops\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            missingSpace: \"Operator '{{operator}}' must be spaced.\"\n        }\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left The left node of the main node\n         * @param {ASTNode} right The right node of the main node\n         * @param {string} op The operator of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right, op) {\n            const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n            const prev = sourceCode.getTokenBefore(operator);\n            const next = sourceCode.getTokenAfter(operator);\n\n            if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n                return operator;\n            }\n\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode The node to report\n         * @param {Object} culpritToken The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc,\n                messageId: \"missingSpace\",\n                data: {\n                    operator: culpritToken.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\n            const rightNode = node.right;\n\n            // search for = in AssignmentPattern nodes\n            const operator = node.operator || \"=\";\n\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n            if (nonSpacedConsequentNode) {\n                report(node, nonSpacedConsequentNode);\n            }\n\n            if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\n            const rightNode = node.init;\n\n            if (rightNode) {\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar,\n\n            PropertyDefinition(node) {\n                if (!node.value) {\n                    return;\n                }\n\n                /*\n                 * Because of computed properties and type annotations, some\n                 * tokens may exist between `node.key` and `=`.\n                 * Therefore, find the `=` from the right.\n                 */\n                const operatorToken = sourceCode.getTokenBefore(node.value, isEqToken);\n                const leftToken = sourceCode.getTokenBefore(operatorToken);\n                const rightToken = sourceCode.getTokenAfter(operatorToken);\n\n                if (\n                    !sourceCode.isSpaceBetweenTokens(leftToken, operatorToken) ||\n                    !sourceCode.isSpaceBetweenTokens(operatorToken, rightToken)\n                ) {\n                    report(node, operatorToken);\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}