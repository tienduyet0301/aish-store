{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-const.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892235783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.some(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            destructuring: \"any\",\n            ignoreReadBeforeAssign: false\n        }],\n\n        docs: {\n            description: \"Require `const` declarations for variables that are never reassigned after declared\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"] },\n                    ignoreReadBeforeAssign: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const [{ destructuring, ignoreReadBeforeAssign }] = context.options;\n        const shouldMatchAnyDestructuredVariable = destructuring !== \"all\";\n        const sourceCode = context.sourceCode;\n        const variables = [];\n        let reportCount = 0;\n        let checkedId = null;\n        let checkedName = \"\";\n\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         * @param {(eslint-scope.Reference|null)[]} nodes\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name and id from the first identifier, if the names are different\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== checkedName) {\n                                checkedName = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== checkedName) {\n                                    checkedName = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n\n                            if (firstDecParent.id !== checkedId) {\n                                checkedId = firstDecParent.id;\n                                reportCount = 0;\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        let totalDeclarationsCount = 0;\n\n                        varDeclParent.declarations.forEach(declaration => {\n                            if (declaration.id.type === \"ObjectPattern\") {\n                                totalDeclarationsCount += declaration.id.properties.length;\n                            } else if (declaration.id.type === \"ArrayPattern\") {\n                                totalDeclarationsCount += declaration.id.elements.length;\n                            } else {\n                                totalDeclarationsCount += 1;\n                            }\n                        });\n\n                        shouldFix = shouldFix && (reportCount === totalDeclarationsCount);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix\n                            ? fixer => {\n                                const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n\n                                /**\n                                 * Extend the replacement range to the whole declaration,\n                                 * in order to prevent other fixes in the same pass\n                                 * https://github.com/eslint/eslint/issues/13899\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainRange(varDeclParent.range)\n                                    .replaceTextRange(letKeywordToken.range, \"const\");\n                            }\n                            : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...sourceCode.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}