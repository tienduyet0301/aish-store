{
    "sourceFile": "node_modules/eslint/lib/rules/valid-typeof.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892241166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            requireStringLiterals: false\n        }],\n\n        docs: {\n            description: \"Enforce comparing `typeof` expressions against valid strings\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/valid-typeof\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            invalidValue: \"Invalid typeof comparison value.\",\n            notString: \"Typeof comparisons should be to string literals.\",\n            suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\n        }\n    },\n\n    create(context) {\n        const VALID_TYPES = new Set([\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"]),\n            OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\"]);\n        const sourceCode = context.sourceCode;\n        const [{ requireStringLiterals }] = context.options;\n\n        let globalScope;\n\n        /**\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} `true` if the node is a reference to a global variable.\n         */\n        function isReferenceToGlobalVariable(node) {\n            const variable = globalScope.set.get(node.name);\n\n            return variable && variable.defs.length === 0 &&\n                variable.references.some(ref => ref.identifier === node);\n        }\n\n        /**\n         * Determines whether a node is a typeof expression.\n         * @param {ASTNode} node The node\n         * @returns {boolean} `true` if the node is a typeof expression\n         */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program(node) {\n                globalScope = sourceCode.getScope(node);\n            },\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const { parent } = node;\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.has(parent.operator)) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || astUtils.isStaticTemplateLiteral(sibling)) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (!VALID_TYPES.has(value)) {\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\n                            }\n                        } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\n                            context.report({\n                                node: sibling,\n                                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\n                                suggest: [\n                                    {\n                                        messageId: \"suggestString\",\n                                        data: { type: \"undefined\" },\n                                        fix(fixer) {\n                                            return fixer.replaceText(sibling, '\"undefined\"');\n                                        }\n                                    }\n                                ]\n                            });\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, messageId: \"notString\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"
        }
    ]
}