{
    "sourceFile": "node_modules/eslint/lib/rules/no-shadow-restricted-names.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892231258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)\n * @author Michael Ficarra\n */\n\"use strict\";\n\n/**\n * Determines if a variable safely shadows undefined.\n * This is the case when a variable named `undefined` is never assigned to a value (i.e. it always shares the same value\n * as the global).\n * @param {eslintScope.Variable} variable The variable to check\n * @returns {boolean} true if this variable safely shadows `undefined`\n */\nfunction safelyShadowsUndefined(variable) {\n    return variable.name === \"undefined\" &&\n        variable.references.every(ref => !ref.isWrite()) &&\n        variable.defs.every(def => def.node.type === \"VariableDeclarator\" && def.node.init === null);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow identifiers from shadowing restricted names\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-shadow-restricted-names\"\n        },\n\n        schema: [],\n\n        messages: {\n            shadowingRestrictedName: \"Shadowing of global property '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n\n\n        const RESTRICTED = new Set([\"undefined\", \"NaN\", \"Infinity\", \"arguments\", \"eval\"]);\n        const sourceCode = context.sourceCode;\n\n        // Track reported nodes to avoid duplicate reports. For example, on class declarations.\n        const reportedNodes = new Set();\n\n        return {\n            \"VariableDeclaration, :function, CatchClause, ImportDeclaration, ClassDeclaration, ClassExpression\"(node) {\n                for (const variable of sourceCode.getDeclaredVariables(node)) {\n                    if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {\n                        for (const def of variable.defs) {\n                            const nodeToReport = def.name;\n\n                            if (!reportedNodes.has(nodeToReport)) {\n                                reportedNodes.add(nodeToReport);\n                                context.report({\n                                    node: nodeToReport,\n                                    messageId: \"shadowingRestrictedName\",\n                                    data: {\n                                        name: variable.name\n                                    }\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}