{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-template.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892237624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    let currentNode = node;\n\n    while (isConcatenation(currentNode.parent)) {\n        currentNode = currentNode.parent;\n    }\n    return currentNode;\n}\n\n/**\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\n * @param {ASTNode} node A node to check\n * @returns {boolean} `true` if at least one string literal within the node contains\n * an octal or non-octal decimal escape sequence\n */\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n    if (isConcatenation(node)) {\n        return (\n            hasOctalOrNonOctalDecimalEscapeSequence(node.left) ||\n            hasOctalOrNonOctalDecimalEscapeSequence(node.right)\n        );\n    }\n\n    // No need to check TemplateLiterals â€“ would throw parsing error\n    if (node.type === \"Literal\" && typeof node.value === \"string\") {\n        return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given binary expression has string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has string literals.\n */\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will start with a template curly.\n */\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n * @param {ASTNode} node The node that will be fixed to a template literal\n * @returns {boolean} `true` if the node will end with a template curly.\n */\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis.at(-1).range[0] === node.quasis.at(-1).range[1];\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require template literals instead of string concatenation\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/prefer-template\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        let done = Object.create(null);\n\n        /**\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n         * @param {ASTNode} node1 The first node\n         * @param {ASTNode} node2 The second node\n         * @returns {string} The text between the nodes, excluding other tokens\n         */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n         * Returns a template literal form of the given node.\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\n         * @param {string} textBeforeNode Text that should appear before the node\n         * @param {string} textAfterNode Text that should appear after the node\n         * @returns {string} A string form of this node, represented as a template literal\n         */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                /*\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                 * an actual backslash character to appear before the dollar sign).\n                 */\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                /*\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                 * the text between them.\n                 */\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Returns a fixer object that converts a non-string binary expression to a template literal\n         * @param {SourceCodeFixer} fixer The fixer object\n         * @param {ASTNode} node A node that should be converted to a template literal\n         * @returns {Object} A fix for this binary expression\n         */\n        function fixNonStringBinaryExpression(fixer, node) {\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n                return null;\n            }\n\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    messageId: \"unexpectedStringConcatenation\",\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n"
        }
    ]
}