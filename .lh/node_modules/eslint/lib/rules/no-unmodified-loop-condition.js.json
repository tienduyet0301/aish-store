{
    "sourceFile": "node_modules/eslint/lib/rules/no-unmodified-loop-condition.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Traverser = require(\"../shared/traverser\"),\n    astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;\n\n/**\n * @typedef {Object} LoopConditionInfo\n * @property {eslint-scope.Reference} reference - The reference.\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\n *      that the reference is belonging to.\n * @property {Function} isInLoop - The predicate which checks a given reference\n *      is in this loop.\n * @property {boolean} modified - The flag that the reference is modified in\n *      this loop.\n */\n\n/**\n * Checks whether or not a given reference is a write reference.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is a write reference.\n */\nfunction isWriteReference(reference) {\n    if (reference.init) {\n        const def = reference.resolved && reference.resolved.defs[0];\n\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n            return false;\n        }\n    }\n    return reference.isWrite();\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag.\n * @param {LoopConditionInfo} condition A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodified(condition) {\n    return !condition.modified;\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag and does not have the group this condition belongs to.\n * @param {LoopConditionInfo} condition A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n    return !(condition.modified || condition.group);\n}\n\n/**\n * Checks whether or not a given reference is inside of a given node.\n * @param {ASTNode} node A node to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the node.\n */\nfunction isInRange(node, reference) {\n    const or = node.range;\n    const ir = reference.identifier.range;\n\n    return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of a loop node's condition.\n * @param {ASTNode} node A node to check.\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is inside of the loop node's\n *      condition.\n */\nconst isInLoop = {\n    WhileStatement: isInRange,\n    DoWhileStatement: isInRange,\n    ForStatement(node, reference) {\n        return (\n            isInRange(node, reference) &&\n            !(node.init && isInRange(node.init, reference))\n        );\n    }\n};\n\n/**\n * Gets the function which encloses a given reference.\n * This supports only FunctionDeclaration.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} The function node or null.\n */\nfunction getEncloseFunctionDeclaration(reference) {\n    let node = reference.identifier;\n\n    while (node) {\n        if (node.type === \"FunctionDeclaration\") {\n            return node.id ? node : null;\n        }\n\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\n * @param {LoopConditionInfo[]} conditions The loop conditions to be updated.\n * @param {eslint-scope.Reference[]} modifiers The references to update.\n * @returns {void}\n */\nfunction updateModifiedFlag(conditions, modifiers) {\n\n    for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n            const modifier = modifiers[j];\n            let funcNode, funcVar;\n\n            /*\n             * Besides checking for the condition being in the loop, we want to\n             * check the function that this modifier is belonging to is called\n             * in the loop.\n             * FIXME: This should probably be extracted to a function.\n             */\n            const inLoop = condition.isInLoop(modifier) || Boolean(\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\n                funcVar.references.some(condition.isInLoop)\n            );\n\n            condition.modified = inLoop;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unmodified loop conditions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-unmodified-loop-condition\"\n        },\n\n        schema: [],\n\n        messages: {\n            loopConditionNotModified: \"'{{name}}' is not modified in this loop.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        let groupMap = null;\n\n        /**\n         * Reports a given condition info.\n         * @param {LoopConditionInfo} condition A loop condition info to report.\n         * @returns {void}\n         */\n        function report(condition) {\n            const node = condition.reference.identifier;\n\n            context.report({\n                node,\n                messageId: \"loopConditionNotModified\",\n                data: node\n            });\n        }\n\n        /**\n         * Registers given conditions to the group the condition belongs to.\n         * @param {LoopConditionInfo[]} conditions A loop condition info to\n         *      register.\n         * @returns {void}\n         */\n        function registerConditionsToGroup(conditions) {\n            for (let i = 0; i < conditions.length; ++i) {\n                const condition = conditions[i];\n\n                if (condition.group) {\n                    let group = groupMap.get(condition.group);\n\n                    if (!group) {\n                        group = [];\n                        groupMap.set(condition.group, group);\n                    }\n                    group.push(condition);\n                }\n            }\n        }\n\n        /**\n         * Reports references which are inside of unmodified groups.\n         * @param {LoopConditionInfo[]} conditions A loop condition info to report.\n         * @returns {void}\n         */\n        function checkConditionsInGroup(conditions) {\n            if (conditions.every(isUnmodified)) {\n                conditions.forEach(report);\n            }\n        }\n\n        /**\n         * Checks whether or not a given group node has any dynamic elements.\n         * @param {ASTNode} root A node to check.\n         *      This node is one of BinaryExpression or ConditionalExpression.\n         * @returns {boolean} `true` if the node is dynamic.\n         */\n        function hasDynamicExpressions(root) {\n            let retv = false;\n\n            Traverser.traverse(root, {\n                visitorKeys: sourceCode.visitorKeys,\n                enter(node) {\n                    if (DYNAMIC_PATTERN.test(node.type)) {\n                        retv = true;\n                        this.break();\n                    } else if (SKIP_PATTERN.test(node.type)) {\n                        this.skip();\n                    }\n                }\n            });\n\n            return retv;\n        }\n\n        /**\n         * Creates the loop condition information from a given reference.\n         * @param {eslint-scope.Reference} reference A reference to create.\n         * @returns {LoopConditionInfo|null} Created loop condition info, or null.\n         */\n        function toLoopCondition(reference) {\n            if (reference.init) {\n                return null;\n            }\n\n            let group = null;\n            let child = reference.identifier;\n            let node = child.parent;\n\n            while (node) {\n                if (SENTINEL_PATTERN.test(node.type)) {\n                    if (LOOP_PATTERN.test(node.type) && node.test === child) {\n\n                        // This reference is inside of a loop condition.\n                        return {\n                            reference,\n                            group,\n                            isInLoop: isInLoop[node.type].bind(null, node),\n                            modified: false\n                        };\n                    }\n\n                    // This reference is outside of a loop condition.\n                    break;\n                }\n\n                /*\n                 * If it's inside of a group, OK if either operand is modified.\n                 * So stores the group this reference belongs to.\n                 */\n                if (GROUP_PATTERN.test(node.type)) {\n\n                    // If this expression is dynamic, no need to check.\n                    if (hasDynamicExpressions(node)) {\n                        break;\n                    } else {\n                        group = node;\n                    }\n                }\n\n                child = node;\n                node = node.parent;\n            }\n\n            return null;\n        }\n\n        /**\n         * Finds unmodified references which are inside of a loop condition.\n         * Then reports the references which are outside of groups.\n         * @param {eslint-scope.Variable} variable A variable to report.\n         * @returns {void}\n         */\n        function checkReferences(variable) {\n\n            // Gets references that exist in loop conditions.\n            const conditions = variable\n                .references\n                .map(toLoopCondition)\n                .filter(Boolean);\n\n            if (conditions.length === 0) {\n                return;\n            }\n\n            // Registers the conditions to belonging groups.\n            registerConditionsToGroup(conditions);\n\n            // Check the conditions are modified.\n            const modifiers = variable.references.filter(isWriteReference);\n\n            if (modifiers.length > 0) {\n                updateModifiedFlag(conditions, modifiers);\n            }\n\n            /*\n             * Reports the conditions which are not belonging to groups.\n             * Others will be reported after all variables are done.\n             */\n            conditions\n                .filter(isUnmodifiedAndNotBelongToGroup)\n                .forEach(report);\n        }\n\n        return {\n            \"Program:exit\"(node) {\n                const queue = [sourceCode.getScope(node)];\n\n                groupMap = new Map();\n\n                let scope;\n\n                while ((scope = queue.pop())) {\n                    queue.push(...scope.childScopes);\n                    scope.variables.forEach(checkReferences);\n                }\n\n                groupMap.forEach(checkConditionsInGroup);\n                groupMap = null;\n            }\n        };\n    }\n};\n"
        }
    ]
}