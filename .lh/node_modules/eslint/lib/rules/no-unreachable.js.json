{
    "sourceFile": "node_modules/eslint/lib/rules/no-unreachable.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * @typedef {Object} ConstructorInfo\n * @property {ConstructorInfo | null} upper Info about the constructor that encloses this constructor.\n * @property {boolean} hasSuperCall The flag about having `super()` expressions.\n */\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks all segments in a set and returns true if all are unreachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if all segments are unreachable; false otherwise.\n */\nfunction areAllSegmentsUnreachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unreachable\"\n        },\n\n        schema: [],\n\n        messages: {\n            unreachableCode: \"Unreachable code.\"\n        }\n    },\n\n    create(context) {\n\n        /** @type {ConstructorInfo | null} */\n        let constructorInfo = null;\n\n        /** @type {ConsecutiveRange} */\n        const range = new ConsecutiveRange(context.sourceCode);\n\n        /** @type {Array<Set<CodePathSegment>>} */\n        const codePathSegments = [];\n\n        /** @type {Set<CodePathSegment>} */\n        let currentCodePathSegments = new Set();\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && (node.type === \"PropertyDefinition\" || areAllSegmentsUnreachable(currentCodePathSegments))) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            /*\n             * Report the current range since this statement is reachable or is\n             * not consecutive to the current range.\n             */\n            if (!range.isEmpty) {\n                context.report({\n                    messageId: \"unreachableCode\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart() {\n                codePathSegments.push(currentCodePathSegments);\n                currentCodePathSegments = new Set();\n            },\n\n            onCodePathEnd() {\n                currentCodePathSegments = codePathSegments.pop();\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            },\n\n            /*\n             * Instance fields defined in a subclass are never created if the constructor of the subclass\n             * doesn't call `super()`, so their definitions are unreachable code.\n             */\n            \"MethodDefinition[kind='constructor']\"() {\n                constructorInfo = {\n                    upper: constructorInfo,\n                    hasSuperCall: false\n                };\n            },\n            \"MethodDefinition[kind='constructor']:exit\"(node) {\n                const { hasSuperCall } = constructorInfo;\n\n                constructorInfo = constructorInfo.upper;\n\n                // skip typescript constructors without the body\n                if (!node.value.body) {\n                    return;\n                }\n\n                const classDefinition = node.parent.parent;\n\n                if (classDefinition.superClass && !hasSuperCall) {\n                    for (const element of classDefinition.body.body) {\n                        if (element.type === \"PropertyDefinition\" && !element.static) {\n                            reportIfUnreachable(element);\n                        }\n                    }\n                }\n            },\n            \"CallExpression > Super.callee\"() {\n                if (constructorInfo) {\n                    constructorInfo.hasSuperCall = true;\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}