{
    "sourceFile": "node_modules/eslint/lib/rules/no-unused-private-class-members.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232709,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag declared but unused private class members\n * @author Tim van der Lippe\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unused private class members\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unused-private-class-members\"\n        },\n\n        schema: [],\n\n        messages: {\n            unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const trackedClasses = [];\n\n        /**\n         * Check whether the current node is in a write only assignment.\n         * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\n         * @returns {boolean} Whether the node is in a write only assignment\n         * @private\n         */\n        function isWriteOnlyAssignment(privateIdentifierNode) {\n            const parentStatement = privateIdentifierNode.parent.parent;\n            const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\n\n            if (!isAssignmentExpression &&\n                parentStatement.type !== \"ForInStatement\" &&\n                parentStatement.type !== \"ForOfStatement\" &&\n                parentStatement.type !== \"AssignmentPattern\") {\n                return false;\n            }\n\n            // It is a write-only usage, since we still allow usages on the right for reads\n            if (parentStatement.left !== privateIdentifierNode.parent) {\n                return false;\n            }\n\n            // For any other operator (such as '+=') we still consider it a read operation\n            if (isAssignmentExpression && parentStatement.operator !== \"=\") {\n\n                /*\n                 * However, if the read operation is \"discarded\" in an empty statement, then\n                 * we consider it write only.\n                 */\n                return parentStatement.parent.type === \"ExpressionStatement\";\n            }\n\n            return true;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // Collect all declared members up front and assume they are all unused\n            ClassBody(classBodyNode) {\n                const privateMembers = new Map();\n\n                trackedClasses.unshift(privateMembers);\n                for (const bodyMember of classBodyNode.body) {\n                    if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\n                        if (bodyMember.key.type === \"PrivateIdentifier\") {\n                            privateMembers.set(bodyMember.key.name, {\n                                declaredNode: bodyMember,\n                                isAccessor: bodyMember.type === \"MethodDefinition\" &&\n                                    (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\n                            });\n                        }\n                    }\n                }\n            },\n\n            /*\n             * Process all usages of the private identifier and remove a member from\n             * `declaredAndUnusedPrivateMembers` if we deem it used.\n             */\n            PrivateIdentifier(privateIdentifierNode) {\n                const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name));\n\n                // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\n                if (!classBody) {\n                    return;\n                }\n\n                // In case any other usage was already detected, we can short circuit the logic here.\n                const memberDefinition = classBody.get(privateIdentifierNode.name);\n\n                if (memberDefinition.isUsed) {\n                    return;\n                }\n\n                // The definition of the class member itself\n                if (privateIdentifierNode.parent.type === \"PropertyDefinition\" ||\n                    privateIdentifierNode.parent.type === \"MethodDefinition\") {\n                    return;\n                }\n\n                /*\n                 * Any usage of an accessor is considered a read, as the getter/setter can have\n                 * side-effects in its definition.\n                 */\n                if (memberDefinition.isAccessor) {\n                    memberDefinition.isUsed = true;\n                    return;\n                }\n\n                // Any assignments to this member, except for assignments that also read\n                if (isWriteOnlyAssignment(privateIdentifierNode)) {\n                    return;\n                }\n\n                const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\n                const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;\n\n                // A statement which only increments (`this.#x++;`)\n                if (wrappingExpressionType === \"UpdateExpression\" &&\n                    parentOfWrappingExpressionType === \"ExpressionStatement\") {\n                    return;\n                }\n\n                /*\n                 * ({ x: this.#usedInDestructuring } = bar);\n                 *\n                 * But should treat the following as a read:\n                 * ({ [this.#x]: a } = foo);\n                 */\n                if (wrappingExpressionType === \"Property\" &&\n                    parentOfWrappingExpressionType === \"ObjectPattern\" &&\n                    privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\n                    return;\n                }\n\n                // [...this.#unusedInRestPattern] = bar;\n                if (wrappingExpressionType === \"RestElement\") {\n                    return;\n                }\n\n                // [this.#unusedInAssignmentPattern] = bar;\n                if (wrappingExpressionType === \"ArrayPattern\") {\n                    return;\n                }\n\n                /*\n                 * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\n                 * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\n                 * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\n                 * as used, which is incorrect.\n                 */\n                memberDefinition.isUsed = true;\n            },\n\n            /*\n             * Post-process the class members and report any remaining members.\n             * Since private members can only be accessed in the current class context,\n             * we can safely assume that all usages are within the current class body.\n             */\n            \"ClassBody:exit\"() {\n                const unusedPrivateMembers = trackedClasses.shift();\n\n                for (const [classMemberName, { declaredNode, isUsed }] of unusedPrivateMembers.entries()) {\n                    if (isUsed) {\n                        continue;\n                    }\n                    context.report({\n                        node: declaredNode,\n                        loc: declaredNode.key.loc,\n                        messageId: \"unusedPrivateClassMember\",\n                        data: {\n                            classMemberName: `#${classMemberName}`\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}