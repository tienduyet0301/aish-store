{
    "sourceFile": "node_modules/eslint/lib/rules/no-irregular-whitespace.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            skipComments: false,\n            skipJSXText: false,\n            skipRegExps: false,\n            skipStrings: true,\n            skipTemplates: false\n        }],\n\n        docs: {\n            description: \"Disallow irregular whitespace\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-irregular-whitespace\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\"\n                    },\n                    skipStrings: {\n                        type: \"boolean\"\n                    },\n                    skipTemplates: {\n                        type: \"boolean\"\n                    },\n                    skipRegExps: {\n                        type: \"boolean\"\n                    },\n                    skipJSXText: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            noIrregularWhitespace: \"Irregular whitespace not allowed.\"\n        }\n    },\n\n    create(context) {\n        const [{\n            skipComments,\n            skipStrings,\n            skipRegExps,\n            skipTemplates,\n            skipJSXText\n        }] = context.options;\n\n        const sourceCode = context.sourceCode;\n        const commentNodes = sourceCode.getAllComments();\n\n        // Module store of errors that we have found\n        let errors = [];\n\n        /**\n         * Removes errors that occur inside the given node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(({ loc: { start: errorLocStart } }) => (\n                errorLocStart.line < locStart.line ||\n                errorLocStart.line === locStart.line && errorLocStart.column < locStart.column ||\n                errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column ||\n                errorLocStart.line > locEnd.line\n            ));\n        }\n\n        /**\n         * Checks literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInLiteral(node) {\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks JSX nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInJSXText(node) {\n            if (ALL_IRREGULARS.test(node.raw)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            const sourceLines = sourceCode.lines;\n\n            sourceLines.forEach((sourceLine, lineIndex) => {\n                const lineNumber = lineIndex + 1;\n                let match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    errors.push({\n                        node,\n                        messageId: \"noIrregularWhitespace\",\n                        loc: {\n                            start: {\n                                line: lineNumber,\n                                column: match.index\n                            },\n                            end: {\n                                line: lineNumber,\n                                column: match.index + match[0].length\n                            }\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            const source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK);\n            let lastLineIndex = -1,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n\n                errors.push({\n                    node,\n                    messageId: \"noIrregularWhitespace\",\n                    loc: {\n                        start: {\n                            line: lineIndex + 1,\n                            column: sourceLines[lineIndex].length\n                        },\n                        end: {\n                            line: lineIndex + 2,\n                            column: 0\n                        }\n                    }\n                });\n\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() { }\n\n        const nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Literal = removeInvalidNodeErrorsInLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes.JSXText = skipJSXText ? removeInvalidNodeErrorsInJSXText : noop;\n            nodes[\"Program:exit\"] = function() {\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(error => context.report(error));\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n"
        }
    ]
}