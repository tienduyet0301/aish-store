{
    "sourceFile": "node_modules/eslint/lib/rules/no-extra-bind.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892225420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence DÃ¡nyi <bence@danyi.me>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary calls to `.bind()`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-bind\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"The function binding is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        let scopeInfo = null;\n\n        /**\n         * Checks if a node is free of side effects.\n         *\n         * This check is stricter than it needs to be, in order to keep the implementation simple.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\n         */\n        function isSideEffectFree(node) {\n            return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n        }\n\n        /**\n         * Reports a given function node.\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function report(node) {\n            const memberNode = node.parent;\n            const callNode = memberNode.parent.type === \"ChainExpression\"\n                ? memberNode.parent.parent\n                : memberNode.parent;\n\n            context.report({\n                node: callNode,\n                messageId: \"unexpected\",\n                loc: memberNode.property.loc,\n\n                fix(fixer) {\n                    if (!isSideEffectFree(callNode.arguments[0])) {\n                        return null;\n                    }\n\n                    /*\n                     * The list of the first/last token pair of a removal range.\n                     * This is two parts because closing parentheses may exist between the method name and arguments.\n                     * E.g. `(function(){}.bind ) (obj)`\n                     *                    ^^^^^   ^^^^^ < removal ranges\n                     * E.g. `(function(){}?.['bind'] ) ?.(obj)`\n                     *                    ^^^^^^^^^^   ^^^^^^^ < removal ranges\n                     */\n                    const tokenPairs = [\n                        [\n\n                            // `.`, `?.`, or `[` token.\n                            sourceCode.getTokenAfter(\n                                memberNode.object,\n                                astUtils.isNotClosingParenToken\n                            ),\n\n                            // property name or `]` token.\n                            sourceCode.getLastToken(memberNode)\n                        ],\n                        [\n\n                            // `?.` or `(` token of arguments.\n                            sourceCode.getTokenAfter(\n                                memberNode,\n                                astUtils.isNotClosingParenToken\n                            ),\n\n                            // `)` token of arguments.\n                            sourceCode.getLastToken(callNode)\n                        ]\n                    ];\n                    const firstTokenToRemove = tokenPairs[0][0];\n                    const lastTokenToRemove = tokenPairs[1][1];\n\n                    if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                        return null;\n                    }\n\n                    return tokenPairs.map(([start, end]) =>\n                        fixer.removeRange([start.range[0], end.range[1]]));\n                }\n            });\n        }\n\n        /**\n         * Checks whether or not a given function node is the callee of `.bind()`\n         * method.\n         *\n         * e.g. `(function() {}.bind(foo))`\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n         */\n        function isCalleeOfBindMethod(node) {\n            if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\n                return false;\n            }\n\n            // The node of `*.bind` member access.\n            const bindNode = node.parent.parent.type === \"ChainExpression\"\n                ? node.parent.parent\n                : node.parent;\n\n            return (\n                bindNode.parent.type === \"CallExpression\" &&\n                bindNode.parent.callee === bindNode &&\n                bindNode.parent.arguments.length === 1 &&\n                bindNode.parent.arguments[0].type !== \"SpreadElement\"\n            );\n        }\n\n        /**\n         * Adds a scope information object to the stack.\n         * @param {ASTNode} node A node to add. This node is a FunctionExpression\n         *      or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            scopeInfo = {\n                isBound: isCalleeOfBindMethod(node),\n                thisFound: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the scope information object from the top of the stack.\n         * At the same time, this reports the function node if the function has\n         * `.bind()` and the `this` keywords found.\n         * @param {ASTNode} node A node to remove. This node is a\n         *      FunctionExpression or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\n                report(node);\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Reports a given arrow function if the function is callee of `.bind()`\n         * method.\n         * @param {ASTNode} node A node to report. This node is an\n         *      ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function exitArrowFunction(node) {\n            if (isCalleeOfBindMethod(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Set the mark as the `this` keyword was found in this scope.\n         * @returns {void}\n         */\n        function markAsThisFound() {\n            if (scopeInfo) {\n                scopeInfo.thisFound = true;\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markAsThisFound\n        };\n    }\n};\n"
        }
    ]
}