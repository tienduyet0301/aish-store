{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-exponentiation-operator.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892236509,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, ReferenceTracker } = require(\"@eslint-community/eslint-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({ type: \"BinaryExpression\", operator: \"**\" });\n\n/**\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\n * @param {ASTNode} base The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesBaseNeedParens(base) {\n    return (\n\n        // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n        astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\n\n        // An unary operator cannot be used immediately before an exponentiation expression\n        base.type === \"AwaitExpression\" ||\n        base.type === \"UnaryExpression\"\n    );\n}\n\n/**\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\n * @param {ASTNode} exponent The node to check.\n * @returns {boolean} `true` if the node needs to be parenthesised.\n */\nfunction doesExponentNeedParens(exponent) {\n\n    // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n    return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n\n/**\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\n * @param {SourceCode} sourceCode A SourceCode object.\n * @returns {boolean} `true` if the expression needs to be parenthesised.\n */\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n    const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n\n    const parentPrecedence = astUtils.getPrecedence(parent);\n    const needsParens = (\n        parent.type === \"ClassDeclaration\" ||\n        (\n            parent.type.endsWith(\"Expression\") &&\n            (parentPrecedence === -1 || parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) &&\n            !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) &&\n            !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) &&\n            !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) &&\n            !(parent.type === \"ArrayExpression\")\n        )\n    );\n\n    return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Optionally parenthesizes given text.\n * @param {string} text The text to parenthesize.\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\n * @returns {string} parenthesised or unchanged text.\n */\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n    return shouldParenthesize ? `(${text})` : text;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow the use of `Math.pow` in favor of the `**` operator\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/prefer-exponentiation-operator\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports the given node.\n         * @param {ASTNode} node 'Math.pow()' node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"useExponentiation\",\n                fix(fixer) {\n                    if (\n                        node.arguments.length !== 2 ||\n                        node.arguments.some(arg => arg.type === \"SpreadElement\") ||\n                        sourceCode.getCommentsInside(node).length > 0\n                    ) {\n                        return null;\n                    }\n\n                    const base = node.arguments[0],\n                        exponent = node.arguments[1],\n                        baseText = sourceCode.getText(base),\n                        exponentText = sourceCode.getText(exponent),\n                        shouldParenthesizeBase = doesBaseNeedParens(base),\n                        shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n                        shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n\n                    let prefix = \"\",\n                        suffix = \"\";\n\n                    if (!shouldParenthesizeAll) {\n                        if (!shouldParenthesizeBase) {\n                            const firstReplacementToken = sourceCode.getFirstToken(base),\n                                tokenBefore = sourceCode.getTokenBefore(node);\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\n                            ) {\n                                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n                            }\n                        }\n                        if (!shouldParenthesizeExponent) {\n                            const lastReplacementToken = sourceCode.getLastToken(exponent),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)\n                            ) {\n                                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n                            }\n                        }\n                    }\n\n                    const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n                        exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n                        replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n\n                    return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                }\n            });\n        }\n\n        return {\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    Math: {\n                        pow: { [CALL]: true }\n                    }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {\n                    report(refNode);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}