{
    "sourceFile": "node_modules/eslint/lib/rules/no-object-constructor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892229148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow calls to the `Object` constructor without an argument\n * @author Francesco Trotta\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    getVariableByName,\n    isArrowToken,\n    isStartOfExpressionStatement,\n    needsPrecedingSemicolon\n} = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow calls to the `Object` constructor without an argument\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-object-constructor\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            preferLiteral: \"The object literal notation {} is preferable.\",\n            useLiteral: \"Replace with '{{replacement}}'.\",\n            useLiteralAfterSemicolon: \"Replace with '{{replacement}}', add preceding semicolon.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether or not an object literal that replaces a specified node needs to be enclosed in parentheses.\n         * @param {ASTNode} node The node to be replaced.\n         * @returns {boolean} Whether or not parentheses around the object literal are required.\n         */\n        function needsParentheses(node) {\n            if (isStartOfExpressionStatement(node)) {\n                return true;\n            }\n\n            const prevToken = sourceCode.getTokenBefore(node);\n\n            if (prevToken && isArrowToken(prevToken)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports on nodes where the `Object` constructor is called without arguments.\n         * @param {ASTNode} node The node to evaluate.\n         * @returns {void}\n         */\n        function check(node) {\n            if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Object\" || node.arguments.length) {\n                return;\n            }\n\n            const variable = getVariableByName(sourceCode.getScope(node), \"Object\");\n\n            if (variable && variable.identifiers.length === 0) {\n                let replacement;\n                let fixText;\n                let messageId = \"useLiteral\";\n\n                if (needsParentheses(node)) {\n                    replacement = \"({})\";\n                    if (needsPrecedingSemicolon(sourceCode, node)) {\n                        fixText = \";({})\";\n                        messageId = \"useLiteralAfterSemicolon\";\n                    } else {\n                        fixText = \"({})\";\n                    }\n                } else {\n                    replacement = fixText = \"{}\";\n                }\n\n                context.report({\n                    node,\n                    messageId: \"preferLiteral\",\n                    suggest: [\n                        {\n                            messageId,\n                            data: { replacement },\n                            fix: fixer => fixer.replaceText(node, fixText)\n                        }\n                    ]\n                });\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n"
        }
    ]
}