{
    "sourceFile": "node_modules/eslint/lib/rules/no-useless-return.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892233304,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Removes the given element from the array.\n * @param {Array} array The source array to remove.\n * @param {any} element The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is removable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n * @param {ASTNode} node The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    for (\n        let currentNode = node;\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\n        currentNode = currentNode.parent\n    ) {\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow redundant return statements\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-return\"\n        },\n\n        fixable: \"code\",\n        schema: [],\n\n        messages: {\n            unnecessaryReturn: \"Unnecessary return statement.\"\n        }\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const sourceCode = context.sourceCode;\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         * @param {CodePathSegment} segment The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {ASTNode[]} uselessReturns The collected return statements.\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n            const traversedSegments = providedTraversedSegments || new WeakSet();\n\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                if (segmentInfoMap.has(segment)) {\n                    uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n                }\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         * @param {CodePathSegment} segment The segment to get return statements.\n         * @param {Set<CodePathSegment>} usedUnreachableSegments A set of segments that have already been traversed in this call.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment, usedUnreachableSegments) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(prevSegment => markReturnStatementsOnSegmentAsUsed(prevSegment, usedUnreachableSegments));\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            if (!info) {\n                return;\n            }\n\n            info.uselessReturns = info.uselessReturns.filter(node => {\n                if (scopeInfo.traversedTryBlockStatements && scopeInfo.traversedTryBlockStatements.length > 0) {\n                    const returnInitialRange = node.range[0];\n                    const returnFinalRange = node.range[1];\n\n                    const areBlocksInRange = scopeInfo.traversedTryBlockStatements.some(tryBlockStatement => {\n                        const blockInitialRange = tryBlockStatement.range[0];\n                        const blockFinalRange = tryBlockStatement.range[1];\n\n                        return (\n                            returnInitialRange >= blockInitialRange &&\n                            returnFinalRange <= blockFinalRange\n                        );\n                    });\n\n                    if (areBlocksInRange) {\n                        return true;\n                    }\n                }\n\n                remove(scopeInfo.uselessReturns, node);\n                return false;\n            });\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .currentSegments\n                .forEach(segment => markReturnStatementsOnSegmentAsUsed(segment, new Set()));\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushes a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    traversedTryBlockStatements: [],\n                    codePath,\n                    currentSegments: new Set()\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        messageId: \"unnecessaryReturn\",\n                        fix(fixer) {\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n\n                                /*\n                                 * Extend the replacement range to include the\n                                 * entire function to avoid conflicting with\n                                 * no-else-return.\n                                 * https://github.com/eslint/eslint/issues/8026\n                                 */\n                                return new FixTracker(fixer, sourceCode)\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            /*\n             * Initializes segments.\n             * NOTE: This event is notified for only reachable segments.\n             */\n            onCodePathSegmentStart(segment) {\n                scopeInfo.currentSegments.add(segment);\n\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                scopeInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                scopeInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                scopeInfo.currentSegments.delete(segment);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (\n                    node.argument ||\n                    astUtils.isInLoop(node) ||\n                    isInFinally(node) ||\n\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n                    !isAnySegmentReachable(scopeInfo.currentSegments)\n                ) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            \"TryStatement > BlockStatement.block:exit\"(node) {\n                scopeInfo.traversedTryBlockStatements.push(node);\n            },\n\n            \"TryStatement:exit\"() {\n                scopeInfo.traversedTryBlockStatements.pop();\n            },\n\n            /*\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n             * Removes return statements of the current segments from the useless return statement list.\n             */\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n"
        }
    ]
}