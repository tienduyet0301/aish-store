{
    "sourceFile": "node_modules/eslint/lib/rules/radix.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892238514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\nconst validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && !validRadixValues.has(radix.value)) ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [MODE_ALWAYS],\n\n        docs: {\n            description: \"Enforce the consistent use of the radix argument when using `parseInt()`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/radix\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ],\n\n        messages: {\n            missingParameters: \"Missing parameters.\",\n            redundantRadix: \"Redundant radix parameter.\",\n            missingRadix: \"Missing radix parameter.\",\n            invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n            addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n        }\n    },\n\n    create(context) {\n        const [mode] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        messageId: \"missingParameters\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            messageId: \"missingRadix\",\n                            suggest: [\n                                {\n                                    messageId: \"addRadixParameter10\",\n                                    fix(fixer) {\n                                        const tokens = sourceCode.getTokens(node);\n                                        const lastToken = tokens.at(-1); // Parenthesis.\n                                        const secondToLastToken = tokens.at(-2); // May or may not be a comma.\n                                        const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n\n                                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                                    }\n                                }\n                            ]\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"redundantRadix\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"invalidRadix\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"(node) {\n                const scope = sourceCode.getScope(node);\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const idNode = reference.identifier;\n\n                        if (astUtils.isCallee(idNode)) {\n                            checkArguments(idNode.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const parentNode = reference.identifier.parent;\n                        const maybeCallee = parentNode.parent.type === \"ChainExpression\"\n                            ? parentNode.parent\n                            : parentNode;\n\n                        if (isParseIntMethod(parentNode) && astUtils.isCallee(maybeCallee)) {\n                            checkArguments(maybeCallee.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}