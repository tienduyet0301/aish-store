{
    "sourceFile": "node_modules/eslint/lib/rules/no-unreachable-loop.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n\n/**\n * Checks all segments in a set and returns true if any are reachable.\n * @param {Set<CodePathSegment>} segments The segments to check.\n * @returns {boolean} True if any segment is reachable; false otherwise.\n */\nfunction isAnySegmentReachable(segments) {\n\n    for (const segment of segments) {\n        if (segment.reachable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Determines whether the given node is the first node in the code path to which a loop statement\n * 'loops' for the next iteration.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} `true` if the node is a looping target.\n */\nfunction isLoopingTarget(node) {\n    const parent = node.parent;\n\n    if (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n                return node === parent.test;\n            case \"DoWhileStatement\":\n                return node === parent.body;\n            case \"ForStatement\":\n                return node === (parent.update || parent.test || parent.body);\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                return node === parent.left;\n\n            // no default\n        }\n    }\n\n    return false;\n}\n\n/**\n * Creates an array with elements from the first given array that are not included in the second given array.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {Array} a new array that represents `arrA \\ arrB`.\n */\nfunction getDifference(arrA, arrB) {\n    return arrA.filter(a => !arrB.includes(a));\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{ ignore: [] }],\n\n        docs: {\n            description: \"Disallow loops with a body that allows only one iteration\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-unreachable-loop\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        enum: allLoopTypes\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            invalid: \"Invalid loop. Its body allows only one iteration.\"\n        }\n    },\n\n    create(context) {\n        const [{ ignore: ignoredLoopTypes }] = context.options;\n        const loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n            loopSelector = loopTypesToCheck.join(\",\"),\n            loopsByTargetSegments = new Map(),\n            loopsToReport = new Set();\n\n        const codePathSegments = [];\n        let currentCodePathSegments = new Set();\n\n        return {\n\n            onCodePathStart() {\n                codePathSegments.push(currentCodePathSegments);\n                currentCodePathSegments = new Set();\n            },\n\n            onCodePathEnd() {\n                currentCodePathSegments = codePathSegments.pop();\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                currentCodePathSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                currentCodePathSegments.delete(segment);\n            },\n\n            onCodePathSegmentStart(segment, node) {\n\n                currentCodePathSegments.add(segment);\n\n                if (isLoopingTarget(node)) {\n                    const loop = node.parent;\n\n                    loopsByTargetSegments.set(segment, loop);\n                }\n            },\n\n            onCodePathSegmentLoop(_, toSegment, node) {\n                const loop = loopsByTargetSegments.get(toSegment);\n\n                /**\n                 * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\n                 * only if there is at least one loop event with the appropriate target (which has been already\n                 * determined in the `loopsByTargetSegments` map), raised from either:\n                 *\n                 * - the end of the loop's body (in which case `node === loop`)\n                 * - a `continue` statement\n                 *\n                 * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\n                 */\n                if (node === loop || node.type === \"ContinueStatement\") {\n\n                    // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n                    loopsToReport.delete(loop);\n                }\n            },\n\n            [loopSelector](node) {\n\n                /**\n                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\n                 * For unreachable segments, the code path analysis does not raise events required for this implementation.\n                 */\n                if (isAnySegmentReachable(currentCodePathSegments)) {\n                    loopsToReport.add(node);\n                }\n            },\n\n\n            \"Program:exit\"() {\n                loopsToReport.forEach(\n                    node => context.report({ node, messageId: \"invalid\" })\n                );\n            }\n        };\n    }\n};\n"
        }
    ]
}