{
    "sourceFile": "node_modules/eslint/lib/rules/no-return-await.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892230920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n * @deprecated in ESLint v8.46.0\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        hasSuggestions: true,\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary `return await`\",\n\n            recommended: false,\n\n            url: \"https://eslint.org/docs/latest/rules/no-return-await\"\n        },\n\n        fixable: null,\n\n        deprecated: {\n            message: \"The original assumption of the rule no longer holds true because of engine optimization.\",\n            url: \"https://eslint.org/docs/latest/rules/no-return-await\",\n            deprecatedSince: \"8.46.0\",\n            availableUntil: null,\n            replacedBy: []\n        },\n\n        schema: [\n        ],\n\n        messages: {\n            removeAwait: \"Remove redundant `await`.\",\n            redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Reports a found unnecessary `await` expression.\n         * @param {ASTNode} node The node representing the `await` expression to report\n         * @returns {void}\n         */\n        function reportUnnecessaryAwait(node) {\n            context.report({\n                node: context.sourceCode.getFirstToken(node),\n                loc: node.loc,\n                messageId: \"redundantUseOfAwait\",\n                suggest: [\n                    {\n                        messageId: \"removeAwait\",\n                        fix(fixer) {\n                            const sourceCode = context.sourceCode;\n                            const [awaitToken, tokenAfterAwait] = sourceCode.getFirstTokens(node, 2);\n\n                            const areAwaitAndAwaitedExpressionOnTheSameLine = awaitToken.loc.start.line === tokenAfterAwait.loc.start.line;\n\n                            if (!areAwaitAndAwaitedExpressionOnTheSameLine) {\n                                return null;\n                            }\n\n                            const [startOfAwait, endOfAwait] = awaitToken.range;\n\n                            const characterAfterAwait = sourceCode.text[endOfAwait];\n                            const trimLength = characterAfterAwait === \" \" ? 1 : 0;\n\n                            const range = [startOfAwait, endOfAwait + trimLength];\n\n                            return fixer.removeRange(range);\n                        }\n                    }\n                ]\n\n            });\n        }\n\n        /**\n         * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n         * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n         * a `catch` block will only have an error handler if there is also a `finally` block.\n         * @param {ASTNode} node A node representing a location where an could be thrown\n         * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n         */\n        function hasErrorHandler(node) {\n            let ancestor = node;\n\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n         * @param {ASTNode} node A node representing the `await` expression to check\n         * @returns {boolean} The checking result\n         */\n        function isInTailCallPosition(node) {\n            if (node.parent.type === \"ArrowFunctionExpression\") {\n                return true;\n            }\n            if (node.parent.type === \"ReturnStatement\") {\n                return !hasErrorHandler(node.parent);\n            }\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions.at(-1)) {\n                return isInTailCallPosition(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            AwaitExpression(node) {\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n                    reportUnnecessaryAwait(node);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}