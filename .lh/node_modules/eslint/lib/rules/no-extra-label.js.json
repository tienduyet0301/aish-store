{
    "sourceFile": "node_modules/eslint/lib/rules/no-extra-label.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892225649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary labels\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-label\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"This label '{{name}}' is unnecessary.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        let scopeInfo = null;\n\n        /**\n         * Creates a new scope with a breakable statement.\n         * @param {ASTNode} node A node to create. This is a BreakableStatement.\n         * @returns {void}\n         */\n        function enterBreakableStatement(node) {\n            scopeInfo = {\n                label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n                breakable: true,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         * @returns {void}\n         */\n        function exitBreakableStatement() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Creates a new scope with a labeled statement.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `enterBreakableStatement` function.\n         * @param {ASTNode} node A node to create. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = {\n                    label: node.label,\n                    breakable: false,\n                    upper: scopeInfo\n                };\n            }\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `exitBreakableStatement` function.\n         * @param {ASTNode} node A node. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = scopeInfo.upper;\n            }\n        }\n\n        /**\n         * Reports a given control node if it's unnecessary.\n         * @param {ASTNode} node A node. This is a BreakStatement or a\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function reportIfUnnecessary(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const labelNode = node.label;\n\n            for (let info = scopeInfo; info !== null; info = info.upper) {\n                if (info.breakable || info.label && info.label.name === labelNode.name) {\n                    if (info.breakable && info.label && info.label.name === labelNode.name) {\n                        context.report({\n                            node: labelNode,\n                            messageId: \"unexpected\",\n                            data: labelNode,\n                            fix(fixer) {\n                                const breakOrContinueToken = sourceCode.getFirstToken(node);\n\n                                if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {\n                                    return null;\n                                }\n\n                                return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);\n                            }\n                        });\n                    }\n                    return;\n                }\n            }\n        }\n\n        return {\n            WhileStatement: enterBreakableStatement,\n            \"WhileStatement:exit\": exitBreakableStatement,\n            DoWhileStatement: enterBreakableStatement,\n            \"DoWhileStatement:exit\": exitBreakableStatement,\n            ForStatement: enterBreakableStatement,\n            \"ForStatement:exit\": exitBreakableStatement,\n            ForInStatement: enterBreakableStatement,\n            \"ForInStatement:exit\": exitBreakableStatement,\n            ForOfStatement: enterBreakableStatement,\n            \"ForOfStatement:exit\": exitBreakableStatement,\n            SwitchStatement: enterBreakableStatement,\n            \"SwitchStatement:exit\": exitBreakableStatement,\n            LabeledStatement: enterLabeledStatement,\n            \"LabeledStatement:exit\": exitLabeledStatement,\n            BreakStatement: reportIfUnnecessary,\n            ContinueStatement: reportIfUnnecessary\n        };\n    }\n};\n"
        }
    ]
}