{
    "sourceFile": "node_modules/eslint/lib/rules/func-names.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892215635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"always\", {}],\n\n        docs: {\n            description: \"Require or disallow named `function` expressions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/func-names\"\n        },\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always\",\n                        \"as-needed\",\n                        \"never\"\n                    ]\n                }\n            },\n            items: [\n                {\n                    $ref: \"#/definitions/value\"\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        generators: {\n                            $ref: \"#/definitions/value\"\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        },\n\n        messages: {\n            unnamed: \"Unexpected unnamed {{name}}.\",\n            named: \"Unexpected named {{name}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Returns the config option for the given node.\n         * @param {ASTNode} node A node to get the config for.\n         * @returns {string} The config option.\n         */\n        function getConfigForNode(node) {\n            if (\n                node.generator &&\n                context.options[1].generators\n            ) {\n                return context.options[1].generators;\n            }\n\n            return context.options[0];\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"PropertyDefinition\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node);\n        }\n\n        /**\n         * Reports that an unnamed function should be named\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedUnnamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"unnamed\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * Reports that a named function should be unnamed\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @returns {void}\n         */\n        function reportUnexpectedNamedFunction(node) {\n            context.report({\n                node,\n                messageId: \"named\",\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                data: { name: astUtils.getFunctionNameWithKind(node) }\n            });\n        }\n\n        /**\n         * The listener for function nodes.\n         * @param {ASTNode} node function node\n         * @returns {void}\n         */\n        function handleFunction(node) {\n\n            // Skip recursive functions.\n            const nameVar = sourceCode.getDeclaredVariables(node)[0];\n\n            if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                return;\n            }\n\n            const hasName = Boolean(node.id && node.id.name);\n            const config = getConfigForNode(node);\n\n            if (config === \"never\") {\n                if (hasName && node.type !== \"FunctionDeclaration\") {\n                    reportUnexpectedNamedFunction(node);\n                }\n            } else if (config === \"as-needed\") {\n                if (!hasName && !hasInferredName(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            } else {\n                if (!hasName && !isObjectOrClassMethod(node)) {\n                    reportUnexpectedUnnamedFunction(node);\n                }\n            }\n        }\n\n        return {\n            \"FunctionExpression:exit\": handleFunction,\n            \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n        };\n    }\n};\n"
        }
    ]
}