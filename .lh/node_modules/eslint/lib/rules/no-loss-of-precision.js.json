{
    "sourceFile": "node_modules/eslint/lib/rules/no-loss-of-precision.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\n * @author Jacob Moore\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow literal numbers that lose precision\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-loss-of-precision\"\n        },\n        schema: [],\n        messages: {\n            noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\n         * @param {Node} node the number `Literal` node\n         * @returns {string} raw source code of the literal, without numeric separators\n         */\n        function getRaw(node) {\n            return node.raw.replace(/_/gu, \"\");\n        }\n\n        /**\n         * Checks whether the number is  base ten\n         * @param {ASTNode} node the node being evaluated\n         * @returns {boolean} true if the node is in base ten\n         */\n        function isBaseTen(node) {\n            const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n\n            return prefixes.every(prefix => !node.raw.startsWith(prefix)) &&\n            !/^0[0-7]+$/u.test(node.raw);\n        }\n\n        /**\n         * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function notBaseTenLosesPrecision(node) {\n            const rawString = getRaw(node).toUpperCase();\n            let base;\n\n            if (rawString.startsWith(\"0B\")) {\n                base = 2;\n            } else if (rawString.startsWith(\"0X\")) {\n                base = 16;\n            } else {\n                base = 8;\n            }\n\n            return !rawString.endsWith(node.value.toString(base).toUpperCase());\n        }\n\n        /**\n         * Adds a decimal point to the numeric string at index 1\n         * @param {string} stringNumber the numeric string without any decimal point\n         * @returns {string} the numeric string with a decimal point in the proper place\n         */\n        function addDecimalPointToNumber(stringNumber) {\n            return `${stringNumber[0]}.${stringNumber.slice(1)}`;\n        }\n\n        /**\n         * Returns the number stripped of leading zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeLeadingZeros(numberAsString) {\n            for (let i = 0; i < numberAsString.length; i++) {\n                if (numberAsString[i] !== \"0\") {\n                    return numberAsString.slice(i);\n                }\n            }\n            return numberAsString;\n        }\n\n        /**\n         * Returns the number stripped of trailing zeros\n         * @param {string} numberAsString the string representation of the number\n         * @returns {string} the stripped string\n         */\n        function removeTrailingZeros(numberAsString) {\n            for (let i = numberAsString.length - 1; i >= 0; i--) {\n                if (numberAsString[i] !== \"0\") {\n                    return numberAsString.slice(0, i + 1);\n                }\n            }\n            return numberAsString;\n        }\n\n        /**\n         * Converts an integer to an object containing the integer's coefficient and order of magnitude\n         * @param {string} stringInteger the string representation of the integer being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeInteger(stringInteger) {\n            const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n\n            return {\n                magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n                coefficient: addDecimalPointToNumber(significantDigits)\n            };\n        }\n\n        /**\n         *\n         * Converts a float to an object containing the floats's coefficient and order of magnitude\n         * @param {string} stringFloat the string representation of the float being converted\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\n         */\n        function normalizeFloat(stringFloat) {\n            const trimmedFloat = removeLeadingZeros(stringFloat);\n\n            if (trimmedFloat.startsWith(\".\")) {\n                const decimalDigits = trimmedFloat.slice(1);\n                const significantDigits = removeLeadingZeros(decimalDigits);\n\n                return {\n                    magnitude: significantDigits.length - decimalDigits.length - 1,\n                    coefficient: addDecimalPointToNumber(significantDigits)\n                };\n\n            }\n            return {\n                magnitude: trimmedFloat.indexOf(\".\") - 1,\n                coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n\n            };\n        }\n\n        /**\n         * Converts a base ten number to proper scientific notation\n         * @param {string} stringNumber the string representation of the base ten number to be converted\n         * @returns {string} the number converted to scientific notation\n         */\n        function convertNumberToScientificNotation(stringNumber) {\n            const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n            const originalCoefficient = splitNumber[0];\n            const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient)\n                : normalizeInteger(originalCoefficient);\n            const normalizedCoefficient = normalizedNumber.coefficient;\n            const magnitude = splitNumber.length > 1 ? (parseInt(splitNumber[1], 10) + normalizedNumber.magnitude)\n                : normalizedNumber.magnitude;\n\n            return `${normalizedCoefficient}e${magnitude}`;\n        }\n\n        /**\n         * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function baseTenLosesPrecision(node) {\n            const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n            const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n            if (requestedPrecision > 100) {\n                return true;\n            }\n            const storedNumber = node.value.toPrecision(requestedPrecision);\n            const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n\n            return normalizedRawNumber !== normalizedStoredNumber;\n        }\n\n\n        /**\n         * Checks that the user-intended number equals the actual number after is has been converted to the Number type\n         * @param {Node} node the node being evaluated\n         * @returns {boolean} true if they do not match\n         */\n        function losesPrecision(node) {\n            return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n        }\n\n\n        return {\n            Literal(node) {\n                if (node.value && isNumber(node) && losesPrecision(node)) {\n                    context.report({\n                        messageId: \"noLossOfPrecision\",\n                        node\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}