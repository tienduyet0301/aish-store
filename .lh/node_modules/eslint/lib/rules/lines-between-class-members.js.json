{
    "sourceFile": "node_modules/eslint/lib/rules/lines-between-class-members.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892217565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Types of class members.\n * Those have `test` method to check it matches to the given class member.\n * @private\n */\nconst ClassMemberTypes = {\n    \"*\": { test: () => true },\n    field: { test: node => node.type === \"PropertyDefinition\" },\n    method: { test: node => node.type === \"MethodDefinition\" }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"lines-between-class-members\",\n                        url: \"https://eslint.style/rules/js/lines-between-class-members\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow an empty line between class members\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                anyOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            enforce: {\n                                type: \"array\",\n                                items: {\n                                    type: \"object\",\n                                    properties: {\n                                        blankLine: { enum: [\"always\", \"never\"] },\n                                        prev: { enum: [\"method\", \"field\", \"*\"] },\n                                        next: { enum: [\"method\", \"field\", \"*\"] }\n                                    },\n                                    additionalProperties: false,\n                                    required: [\"blankLine\", \"prev\", \"next\"]\n                                },\n                                minItems: 1\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"enforce\"]\n                    },\n                    {\n                        enum: [\"always\", \"never\"]\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const configureList = typeof options[0] === \"object\" ? options[0].enforce : [{ blankLine: options[0], prev: \"*\", next: \"*\" }];\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Gets a pair of tokens that should be used to check lines between two class member nodes.\n         *\n         * In most cases, this returns the very last token of the current node and\n         * the very first token of the next node.\n         * For example:\n         *\n         *     class C {\n         *         x = 1;   // curLast: `;` nextFirst: `in`\n         *         in = 2\n         *     }\n         *\n         * There is only one exception. If the given node ends with a semicolon, and it looks like\n         * a semicolon-less style's semicolon - one that is not on the same line as the preceding\n         * token, but is on the line where the next class member starts - this returns the preceding\n         * token and the semicolon as boundary tokens.\n         * For example:\n         *\n         *     class C {\n         *         x = 1    // curLast: `1` nextFirst: `;`\n         *         ;in = 2\n         *     }\n         * When determining the desired layout of the code, we should treat this semicolon as\n         * a part of the next class member node instead of the one it technically belongs to.\n         * @param {ASTNode} curNode Current class member node.\n         * @param {ASTNode} nextNode Next class member node.\n         * @returns {Token} The actual last token of `node`.\n         * @private\n         */\n        function getBoundaryTokens(curNode, nextNode) {\n            const lastToken = sourceCode.getLastToken(curNode);\n            const prevToken = sourceCode.getTokenBefore(lastToken);\n            const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\n\n            const isSemicolonLessStyle = (\n                astUtils.isSemicolonToken(lastToken) &&\n                !astUtils.isTokenOnSameLine(prevToken, lastToken) &&\n                astUtils.isTokenOnSameLine(lastToken, nextToken)\n            );\n\n            return isSemicolonLessStyle\n                ? { curLast: prevToken, nextFirst: lastToken }\n                : { curLast: lastToken, nextFirst: nextToken };\n        }\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        /**\n         * Checks whether the given node matches the given type.\n         * @param {ASTNode} node The class member node to check.\n         * @param {string} type The class member type to check.\n         * @returns {boolean} `true` if the class member node matched the type.\n         * @private\n         */\n        function match(node, type) {\n            return ClassMemberTypes[type].test(node);\n        }\n\n        /**\n         * Finds the last matched configuration from the configureList.\n         * @param {ASTNode} prevNode The previous node to match.\n         * @param {ASTNode} nextNode The current node to match.\n         * @returns {string|null} Padding type or `null` if no matches were found.\n         * @private\n         */\n        function getPaddingType(prevNode, nextNode) {\n            for (let i = configureList.length - 1; i >= 0; --i) {\n                const configure = configureList[i];\n                const matched =\n                    match(prevNode, configure.prev) &&\n                    match(nextNode, configure.next);\n\n                if (matched) {\n                    return configure.blankLine;\n                }\n            }\n            return null;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const { curLast, nextFirst } = getBoundaryTokens(body[i], body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n                    const paddingType = getPaddingType(body[i], body[i + 1]);\n\n                    if (paddingType === \"never\" && isPadded) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: \"never\",\n\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\");\n                            }\n                        });\n                    } else if (paddingType === \"always\" && !skip && !isPadded) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: \"always\",\n\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}