{
    "sourceFile": "node_modules/eslint/lib/rules/no-useless-constructor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892233163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag the use of redundant constructors in classes.\n * @author Alberto Rodr√≠guez\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given array of statements is a single call of `super`.\n * @param {ASTNode[]} body An array of statements to check.\n * @returns {boolean} `true` if the body is a single call of `super`.\n */\nfunction isSingleSuperCall(body) {\n    return (\n        body.length === 1 &&\n        body[0].type === \"ExpressionStatement\" &&\n        body[0].expression.type === \"CallExpression\" &&\n        body[0].expression.callee.type === \"Super\"\n    );\n}\n\n/**\n * Checks whether a given node is a pattern which doesn't have any side effects.\n * Default parameters and Destructuring parameters can have side effects.\n * @param {ASTNode} node A pattern node.\n * @returns {boolean} `true` if the node doesn't have any side effects.\n */\nfunction isSimple(node) {\n    return node.type === \"Identifier\" || node.type === \"RestElement\";\n}\n\n/**\n * Checks whether a given array of expressions is `...arguments` or not.\n * `super(...arguments)` passes all arguments through.\n * @param {ASTNode[]} superArgs An array of expressions to check.\n * @returns {boolean} `true` if the superArgs is `...arguments`.\n */\nfunction isSpreadArguments(superArgs) {\n    return (\n        superArgs.length === 1 &&\n        superArgs[0].type === \"SpreadElement\" &&\n        superArgs[0].argument.type === \"Identifier\" &&\n        superArgs[0].argument.name === \"arguments\"\n    );\n}\n\n/**\n * Checks whether given 2 nodes are identifiers which have the same name or not.\n * @param {ASTNode} ctorParam A node to check.\n * @param {ASTNode} superArg A node to check.\n * @returns {boolean} `true` if the nodes are identifiers which have the same\n *      name.\n */\nfunction isValidIdentifierPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"Identifier\" &&\n        superArg.type === \"Identifier\" &&\n        ctorParam.name === superArg.name\n    );\n}\n\n/**\n * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n * @param {ASTNode} ctorParam A node to check.\n * @param {ASTNode} superArg A node to check.\n * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n *      same values.\n */\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"RestElement\" &&\n        superArg.type === \"SpreadElement\" &&\n        isValidIdentifierPair(ctorParam.argument, superArg.argument)\n    );\n}\n\n/**\n * Checks whether given 2 nodes have the same value or not.\n * @param {ASTNode} ctorParam A node to check.\n * @param {ASTNode} superArg A node to check.\n * @returns {boolean} `true` if the nodes have the same value or not.\n */\nfunction isValidPair(ctorParam, superArg) {\n    return (\n        isValidIdentifierPair(ctorParam, superArg) ||\n        isValidRestSpreadPair(ctorParam, superArg)\n    );\n}\n\n/**\n * Checks whether the parameters of a constructor and the arguments of `super()`\n * have the same values or not.\n * @param {ASTNode} ctorParams The parameters of a constructor to check.\n * @param {ASTNode} superArgs The arguments of `super()` to check.\n * @returns {boolean} `true` if those have the same values.\n */\nfunction isPassingThrough(ctorParams, superArgs) {\n    if (ctorParams.length !== superArgs.length) {\n        return false;\n    }\n\n    for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether the constructor body is a redundant super call.\n * @param {Array} body constructor body content.\n * @param {Array} ctorParams The params to check against super call.\n * @returns {boolean} true if the constructor body is redundant\n */\nfunction isRedundantSuperCall(body, ctorParams) {\n    return (\n        isSingleSuperCall(body) &&\n        ctorParams.every(isSimple) &&\n        (\n            isSpreadArguments(body[0].expression.arguments) ||\n            isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary constructors\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-useless-constructor\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            noUselessConstructor: \"Useless constructor.\",\n            removeConstructor: \"Remove the constructor.\"\n        }\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether a node is a redundant constructor\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkForConstructor(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n\n            /*\n             * Prevent crashing on parsers which do not require class constructor\n             * to have a body, e.g. typescript and flow\n             */\n            if (!node.value.body) {\n                return;\n            }\n\n            const body = node.value.body.body;\n            const ctorParams = node.value.params;\n            const superClass = node.parent.parent.superClass;\n\n            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {\n                context.report({\n                    node,\n                    messageId: \"noUselessConstructor\",\n                    suggest: [\n                        {\n                            messageId: \"removeConstructor\",\n                            *fix(fixer) {\n                                const nextToken = context.sourceCode.getTokenAfter(node);\n                                const addSemiColon = nextToken.type === \"Punctuator\" && nextToken.value === \"[\" && astUtils.needsPrecedingSemicolon(context.sourceCode, node);\n\n                                yield fixer.replaceText(node, addSemiColon ? \";\" : \"\");\n                            }\n                        }\n                    ]\n                });\n            }\n        }\n\n        return {\n            MethodDefinition: checkForConstructor\n        };\n    }\n};\n"
        }
    ]
}