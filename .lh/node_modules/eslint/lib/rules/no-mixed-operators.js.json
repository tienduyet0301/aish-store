{
    "sourceFile": "node_modules/eslint/lib/rules/no-mixed-operators.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS,\n    TERNARY_OPERATOR,\n    COALESCE_OPERATOR\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n\n/**\n * Normalizes options.\n * @param {Object|undefined} options A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options = {}) {\n    const hasGroups = options.groups && options.groups.length > 0;\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n * @param {Array<string[]>} groups A list of groups to check.\n * @param {string} left An operator.\n * @param {string} right Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.includes(left) && group.includes(right));\n}\n\n/**\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\n * This parent node can be BinaryExpression, LogicalExpression\n *      , or a ConditionalExpression node\n * @returns {ASTNode} node the appropriate node(left or test).\n */\nfunction getChildNode(node) {\n    return node.type === \"ConditionalExpression\" ? node.test : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"no-mixed-operators\",\n                        url: \"https://eslint.style/rules/js/no-mixed-operators\"\n                    }\n                }\n            ]\n        },\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow mixed binary operators\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-mixed-operators\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\",\n                        default: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (getChildNode(parent) === node) ? node : parent;\n            const right = (getChildNode(parent) !== node) ? node : parent;\n            const data = {\n                leftOperator: left.operator || \"?:\",\n                rightOperator: right.operator || \"?:\"\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc,\n                messageId: \"unexpectedMixedOperator\",\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         * @param {ASTNode} node A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (\n                TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n"
        }
    ]
}