{
    "sourceFile": "node_modules/eslint/lib/rules/no-else-return.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892224339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst FixTracker = require(\"./utils/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{ allowElseIf: true }],\n\n        docs: {\n            description: \"Disallow `else` blocks after `return` statements in `if` statements\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-else-return\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowElseIf: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }],\n\n        fixable: \"code\",\n\n        messages: {\n            unexpected: \"Unnecessary 'else' after 'return'.\"\n        }\n    },\n\n    create(context) {\n        const [{ allowElseIf }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether the given names can be safely used to declare block-scoped variables\n         * in the given scope. Name collisions can produce redeclaration syntax errors,\n         * or silently change references and modify behavior of the original code.\n         *\n         * This is not a generic function. In particular, it is assumed that the scope is a function scope or\n         * a function's inner scope, and that the names can be valid identifiers in the given scope.\n         * @param {string[]} names Array of variable names.\n         * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\n         * @returns {boolean} True if all names can be safely declared, false otherwise.\n         */\n        function isSafeToDeclare(names, scope) {\n\n            if (names.length === 0) {\n                return true;\n            }\n\n            const functionScope = scope.variableScope;\n\n            /*\n             * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\n             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\n             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\n             *\n             * Redeclaring any of these would cause a syntax error, except for the implicit variables.\n             */\n            const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);\n\n            if (declaredVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            // Redeclaring a catch variable would also cause a syntax error.\n            if (scope !== functionScope && scope.upper.type === \"catch\") {\n                if (scope.upper.variables.some(({ name }) => names.includes(name))) {\n                    return false;\n                }\n            }\n\n            /*\n             * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\n             * However, if the variable was used, declaring a new one with the same name would change references\n             * and modify behavior.\n             */\n            const usedImplicitVariables = scope.variables.filter(({ defs, references }) =>\n                defs.length === 0 && references.length > 0);\n\n            if (usedImplicitVariables.some(({ name }) => names.includes(name))) {\n                return false;\n            }\n\n            /*\n             * Declaring a variable with a name that was already used to reference a variable from an upper scope\n             * would change references and modify behavior.\n             */\n            if (scope.through.some(t => names.includes(t.identifier.name))) {\n                return false;\n            }\n\n            /*\n             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\n             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\n             *\n             * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\n             * function foo() { if (bar) { let a; if (baz) { var a; } } }\n             */\n            if (scope !== functionScope) {\n                const scopeNodeRange = scope.block.range;\n                const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));\n\n                if (variablesToCheck.some(v => v.defs.some(({ node: { range } }) =>\n                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n\n        /**\n         * Checks whether the removal of `else` and its braces is safe from variable name collisions.\n         * @param {Node} node The 'else' node.\n         * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\n         * @returns {boolean} True if it is safe, false otherwise.\n         */\n        function isSafeFromNameCollisions(node, scope) {\n\n            if (node.type === \"FunctionDeclaration\") {\n\n                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n                return false;\n            }\n\n            if (node.type !== \"BlockStatement\") {\n                return true;\n            }\n\n            const elseBlockScope = scope.childScopes.find(({ block }) => block === node);\n\n            if (!elseBlockScope) {\n\n                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n                return true;\n            }\n\n            /*\n             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\n             * only block-scoped variables (such as let and const variables or class and function declarations)\n             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\n             */\n            const namesToCheck = elseBlockScope.variables.map(({ name }) => name);\n\n            return isSafeToDeclare(namesToCheck, scope);\n        }\n\n        /**\n         * Display the context report if rule is violated\n         * @param {Node} elseNode The 'else' node\n         * @returns {void}\n         */\n        function displayReport(elseNode) {\n            const currentScope = sourceCode.getScope(elseNode.parent);\n\n            context.report({\n                node: elseNode,\n                messageId: \"unexpected\",\n                fix(fixer) {\n\n                    if (!isSafeFromNameCollisions(elseNode, currentScope)) {\n                        return null;\n                    }\n\n                    const startToken = sourceCode.getFirstToken(elseNode);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(elseNode);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    /*\n                     * If the if block does not have curly braces and does not end in a semicolon\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\n                     * safe to remove the else keyword, because ASI will not add a semicolon\n                     * after the if block\n                     */\n                    const ifBlockMaybeUnsafe = elseNode.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(elseNode);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        /*\n                         * If the else block contents does not end in a semicolon,\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\n                         * safe to remove the else block, because ASI will not add a semicolon\n                         * after the remaining else block contents\n                         */\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    /*\n                     * Extend the replacement range to include the entire\n                     * function to avoid conflicting with no-useless-return.\n                     * https://github.com/eslint/eslint/issues/8026\n                     *\n                     * Also, to avoid name collisions between two else blocks.\n                     */\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(elseNode)\n                        .replaceTextRange([elseToken.range[0], elseNode.range[1]], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body.at(-1);\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else.\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent;\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         * @param {Node} node The consequent or body node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n\n        /**\n         * Check the if statement, but don't catch else-if blocks.\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithoutElse(node) {\n            const parent = node.parent;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const consequents = [];\n            let alternate;\n\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n                if (!currentNode.alternate) {\n                    return;\n                }\n                consequents.push(currentNode.consequent);\n                alternate = currentNode.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function checkIfWithElse(node) {\n            const parent = node.parent;\n\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            const alternate = node.alternate;\n\n            if (alternate && alwaysReturns(node.consequent)) {\n                displayReport(alternate);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n\n        };\n\n    }\n};\n"
        }
    ]
}