{
    "sourceFile": "node_modules/eslint/lib/rules/no-warning-comments.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892233450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            location: \"start\",\n            terms: [\"todo\", \"fixme\", \"xxx\"]\n        }],\n\n        docs: {\n            description: \"Disallow specified warning terms in comments\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-warning-comments\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    },\n                    decoration: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\",\n                            pattern: \"^\\\\S$\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const [{ decoration, location, terms: warningTerms }] = context.options;\n        const escapedDecoration = escapeRegExp(decoration ? decoration.join(\"\") : \"\");\n        const selfConfigRegEx = /\\bno-warning-comments\\b/u;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = escapeRegExp(term);\n\n            /*\n             * When matching at the start, ignore leading whitespace, and\n             * there's no need to worry about word boundaries.\n             *\n             * These expressions for the prefix and suffix are designed as follows:\n             * ^   handles any terms at the beginning of a comment.\n             *     e.g. terms [\"TODO\"] matches `//TODO something`\n             * $   handles any terms at the end of a comment\n             *     e.g. terms [\"TODO\"] matches `// something TODO`\n             * \\b  handles terms preceded/followed by word boundary\n             *     e.g. terms: [\"!FIX\", \"FIX!\"] matches `// FIX!something` or `// something!FIX`\n             *          terms: [\"FIX\"] matches `// FIX!` or `// !FIX`, but not `// fixed or affix`\n             *\n             * For location start:\n             * [\\s]* handles optional leading spaces\n             *     e.g. terms [\"TODO\"] matches `//    TODO something`\n             * [\\s\\*]* (where \"\\*\" is the escaped string of decoration)\n             *     handles optional leading spaces or decoration characters (for \"start\" location only)\n             *     e.g. terms [\"TODO\"] matches `/**** TODO something ... `\n             */\n            const wordBoundary = \"\\\\b\";\n\n            let prefix = \"\";\n\n            if (location === \"start\") {\n                prefix = `^[\\\\s${escapedDecoration}]*`;\n            } else if (/^\\w/u.test(term)) {\n                prefix = wordBoundary;\n            }\n\n            const suffix = /\\w$/u.test(term) ? wordBoundary : \"\";\n            const flags = \"iu\"; // Case-insensitive with Unicode case folding.\n\n            /*\n             * For location \"start\", the typical regex is:\n             *   /^[\\s]*ESCAPED_TERM\\b/iu.\n             * Or if decoration characters are specified (e.g. \"*\"), then any of\n             * those characters may appear in any order at the start:\n             *   /^[\\s\\*]*ESCAPED_TERM\\b/iu.\n             *\n             * For location \"anywhere\" the typical regex is\n             *   /\\bESCAPED_TERM\\b/iu\n             *\n             * If it starts or ends with non-word character, the prefix and suffix are empty, respectively.\n             */\n            return new RegExp(`${prefix}${escaped}${suffix}`, flags);\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            const comment = node.value;\n\n            if (\n                astUtils.isDirectiveComment(node) &&\n                selfConfigRegEx.test(comment)\n            ) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(comment);\n\n            matches.forEach(matchedTerm => {\n                let commentToDisplay = \"\";\n                let truncated = false;\n\n                for (const c of comment.trim().split(/\\s+/u)) {\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n                    if (tmp.length <= CHAR_LIMIT) {\n                        commentToDisplay = tmp;\n                    } else {\n                        truncated = true;\n                        break;\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: \"unexpectedComment\",\n                    data: {\n                        matchedTerm,\n                        comment: `${commentToDisplay}${\n                            truncated ? \"...\" : \"\"\n                        }`\n                    }\n                });\n            });\n        }\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments\n                    .filter(token => token.type !== \"Shebang\")\n                    .forEach(checkComment);\n            }\n        };\n    }\n};\n"
        }
    ]
}