{
    "sourceFile": "node_modules/eslint/lib/rules/max-lines-per-function.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892217772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to set the maximum number of line of code in a function.\n * @author Pete Ward <peteward44@gmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { upperCaseFirst } = require(\"../shared/string-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        max: {\n            type: \"integer\",\n            minimum: 0\n        },\n        skipComments: {\n            type: \"boolean\"\n        },\n        skipBlankLines: {\n            type: \"boolean\"\n        },\n        IIFEs: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    oneOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 1\n        }\n    ]\n};\n\n/**\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\n * @param {Array} comments An array of comment nodes.\n * @returns {Map<string, Node>} A map with numeric keys (source code line numbers) and comment token values.\n */\nfunction getCommentLineNumbers(comments) {\n    const map = new Map();\n\n    comments.forEach(comment => {\n        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n            map.set(i, comment);\n        }\n    });\n    return map;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce a maximum number of lines of code in a function\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/max-lines-per-function\"\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA\n        ],\n        messages: {\n            exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const lines = sourceCode.lines;\n\n        const option = context.options[0];\n        let maxLines = 50;\n        let skipComments = false;\n        let skipBlankLines = false;\n        let IIFEs = false;\n\n        if (typeof option === \"object\") {\n            maxLines = typeof option.max === \"number\" ? option.max : 50;\n            skipComments = !!option.skipComments;\n            skipBlankLines = !!option.skipBlankLines;\n            IIFEs = !!option.IIFEs;\n        } else if (typeof option === \"number\") {\n            maxLines = option;\n        }\n\n        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n                isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || isFirstTokenOnLine) &&\n                (end.line > lineNumber || isLastTokenOnLine);\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is part of an IIFE\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's an IIFE\n         */\n        function isIIFE(node) {\n            return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n        }\n\n        /**\n         * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\n         * @param {ASTNode} node Node to test\n         * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\n         */\n        function isEmbedded(node) {\n            if (!node.parent) {\n                return false;\n            }\n            if (node !== node.parent.value) {\n                return false;\n            }\n            if (node.parent.type === \"MethodDefinition\") {\n                return true;\n            }\n            if (node.parent.type === \"Property\") {\n                return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n            }\n            return false;\n        }\n\n        /**\n         * Count the lines in the function\n         * @param {ASTNode} funcNode Function AST node\n         * @returns {void}\n         * @private\n         */\n        function processFunction(funcNode) {\n            const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n\n            if (!IIFEs && isIIFE(node)) {\n                return;\n            }\n            let lineCount = 0;\n\n            for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n                const line = lines[i];\n\n                if (skipComments) {\n                    if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n                        continue;\n                    }\n                }\n\n                if (skipBlankLines) {\n                    if (line.match(/^\\s*$/u)) {\n                        continue;\n                    }\n                }\n\n                lineCount++;\n            }\n\n            if (lineCount > maxLines) {\n                const name = upperCaseFirst(astUtils.getFunctionNameWithKind(funcNode));\n\n                context.report({\n                    node,\n                    messageId: \"exceed\",\n                    data: { name, lineCount, maxLines }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: processFunction,\n            FunctionExpression: processFunction,\n            ArrowFunctionExpression: processFunction\n        };\n    }\n};\n"
        }
    ]
}