{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-named-capture-group.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892236666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce requiring named capture groups in regular expression.\n * @author Pig Fang <https://github.com/g-plane>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"@eslint-community/eslint-utils\");\nconst regexpp = require(\"@eslint-community/regexpp\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst parser = new regexpp.RegExpParser();\n\n/**\n * Creates fixer suggestions for the regex, if statically determinable.\n * @param {number} groupStart Starting index of the regex group.\n * @param {string} pattern The regular expression pattern to be checked.\n * @param {string} rawText Source text of the regexNode.\n * @param {ASTNode} regexNode AST node which contains the regular expression.\n * @returns {Array<SuggestionResult>} Fixer suggestions for the regex, if statically determinable.\n */\nfunction suggestIfPossible(groupStart, pattern, rawText, regexNode) {\n    switch (regexNode.type) {\n        case \"Literal\":\n            if (typeof regexNode.value === \"string\" && rawText.includes(\"\\\\\")) {\n                return null;\n            }\n            break;\n        case \"TemplateLiteral\":\n            if (regexNode.expressions.length || rawText.slice(1, -1) !== pattern) {\n                return null;\n            }\n            break;\n        default:\n            return null;\n    }\n\n    const start = regexNode.range[0] + groupStart + 2;\n\n    return [\n        {\n            fix(fixer) {\n                const existingTemps = pattern.match(/temp\\d+/gu) || [];\n                const highestTempCount = existingTemps.reduce(\n                    (previous, next) =>\n                        Math.max(previous, Number(next.slice(\"temp\".length))),\n                    0\n                );\n\n                return fixer.insertTextBeforeRange(\n                    [start, start],\n                    `?<temp${highestTempCount + 1}>`\n                );\n            },\n            messageId: \"addGroupName\"\n        },\n        {\n            fix(fixer) {\n                return fixer.insertTextBeforeRange(\n                    [start, start],\n                    \"?:\"\n                );\n            },\n            messageId: \"addNonCapture\"\n        }\n    ];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce using named capture group in regular expression\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-named-capture-group\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            addGroupName: \"Add name to capture group.\",\n            addNonCapture: \"Convert group to non-capturing.\",\n            required: \"Capture group '{{group}}' should be converted to a named or non-capturing group.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Function to check regular expression.\n         * @param {string} pattern The regular expression pattern to be checked.\n         * @param {ASTNode} node AST node which contains the regular expression or a call/new expression.\n         * @param {ASTNode} regexNode AST node which contains the regular expression.\n         * @param {string|null} flags The regular expression flags to be checked.\n         * @returns {void}\n         */\n        function checkRegex(pattern, node, regexNode, flags) {\n            let ast;\n\n            try {\n                ast = parser.parsePattern(pattern, 0, pattern.length, {\n                    unicode: Boolean(flags && flags.includes(\"u\")),\n                    unicodeSets: Boolean(flags && flags.includes(\"v\"))\n                });\n            } catch {\n\n                // ignore regex syntax errors\n                return;\n            }\n\n            regexpp.visitRegExpAST(ast, {\n                onCapturingGroupEnter(group) {\n                    if (!group.name) {\n                        const rawText = sourceCode.getText(regexNode);\n                        const suggest = suggestIfPossible(group.start, pattern, rawText, regexNode);\n\n                        context.report({\n                            node,\n                            messageId: \"required\",\n                            data: {\n                                group: group.raw\n                            },\n                            suggest\n                        });\n                    }\n                }\n            });\n        }\n\n        return {\n            Literal(node) {\n                if (node.regex) {\n                    checkRegex(node.regex.pattern, node, node, node.regex.flags);\n                }\n            },\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {\n                    const regex = getStringIfConstant(refNode.arguments[0]);\n                    const flags = getStringIfConstant(refNode.arguments[1]);\n\n                    if (regex) {\n                        checkRegex(regex, refNode, refNode.arguments[0], flags);\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}