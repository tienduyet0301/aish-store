{
    "sourceFile": "node_modules/eslint/lib/rules/lines-around-directive.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892217510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n * @deprecated in ESLint v4.0.0\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow newlines around directives\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/lines-around-directive\"\n        },\n\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n\n        fixable: \"whitespace\",\n        messages: {\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n        },\n        deprecated: {\n            message: \"The rule was replaced with a more general rule.\",\n            url: \"https://eslint.org/blog/2017/06/eslint-v4.0.0-released/\",\n            deprecatedSince: \"4.0.0\",\n            availableUntil: null,\n            replacedBy: [\n                {\n                    message: \"The new rule moved to a plugin.\",\n                    url: \"https://eslint.org/docs/latest/rules/padding-line-between-statements#examples\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"padding-line-between-statements\",\n                        url: \"https://eslint.style/rules/js/padding-line-between-statements\"\n                    }\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n         * Gets the last token of a node that is on the same line as the rest of the node.\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n         * semicolon on a different line.\n         * @param {ASTNode} node A directive node\n         * @returns {Token} The last token of the node on the line\n         */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                messageId: expected ? \"expected\" : \"unexpected\",\n                data: {\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n\n            /*\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n             * the file if there are no comments as well as for compatibility with padded-blocks.\n             */\n            if (leadingComments.length) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !leadingComments.length &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives.at(-1);\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            /*\n             * Do not check after the last directive if the body only\n             * contains a directive prologue and isn't followed by a comment to ensure\n             * this rule behaves well with padded-blocks.\n             */\n            if (lastDirective === statements.at(-1) && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n"
        }
    ]
}