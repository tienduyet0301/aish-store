{
    "sourceFile": "node_modules/eslint/lib/rules/utils/fix-tracker.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892240704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n\n    /**\n     * Create a new FixTracker.\n     * @param {ruleFixer} fixer A ruleFixer instance.\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\n     */\n    constructor(fixer, sourceCode) {\n        this.fixer = fixer;\n        this.sourceCode = sourceCode;\n        this.retainedRange = null;\n    }\n\n    /**\n     * Mark the given range as \"retained\", meaning that other fixes may not\n     * may not modify this region in the same pass.\n     * @param {int[]} range The range to retain.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainRange(range) {\n        this.retainedRange = range;\n        return this;\n    }\n\n    /**\n     * Given a node, find the function containing it (or the entire program) and\n     * mark it as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that modify control\n     * flow.\n     * @param {ASTNode} node The node to use as a starting point.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainEnclosingFunction(node) {\n        const functionNode = astUtils.getUpperFunction(node);\n\n        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n    }\n\n    /**\n     * Given a node or token, find the token before and afterward, and mark that\n     * range as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that make a small\n     * change to the code where the AST should not be changed.\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n     *      point. The token to the left and right are use in the range.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainSurroundingTokens(nodeOrToken) {\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n    }\n\n    /**\n     * Create a fix command that replaces the given range with the given text,\n     * accounting for any retained ranges.\n     * @param {int[]} range The range to remove in the fix.\n     * @param {string} text The text to insert in place of the range.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        let actualRange;\n\n        if (this.retainedRange) {\n            actualRange = [\n                Math.min(this.retainedRange[0], range[0]),\n                Math.max(this.retainedRange[1], range[1])\n            ];\n        } else {\n            actualRange = range;\n        }\n\n        return this.fixer.replaceTextRange(\n            actualRange,\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\n                text +\n                this.sourceCode.text.slice(range[1], actualRange[1])\n        );\n    }\n\n    /**\n     * Create a fix command that removes the given node or token, accounting for\n     * any retained ranges.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.replaceTextRange(nodeOrToken.range, \"\");\n    }\n}\n\nmodule.exports = FixTracker;\n"
        }
    ]
}