{
    "sourceFile": "node_modules/eslint/lib/rules/utils/char-source.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892240649,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Utility functions to locate the source text of each code unit in the value of a string literal or template token.\n * @author Francesco Trotta\n */\n\n\"use strict\";\n\n/**\n * Represents a code unit produced by the evaluation of a JavaScript common token like a string\n * literal or template token.\n */\nclass CodeUnit {\n    constructor(start, source) {\n        this.start = start;\n        this.source = source;\n    }\n\n    get end() {\n        return this.start + this.length;\n    }\n\n    get length() {\n        return this.source.length;\n    }\n}\n\n/**\n * An object used to keep track of the position in a source text where the next characters will be read.\n */\nclass TextReader {\n    constructor(source) {\n        this.source = source;\n        this.pos = 0;\n    }\n\n    /**\n     * Advances the reading position of the specified number of characters.\n     * @param {number} length Number of characters to advance.\n     * @returns {void}\n     */\n    advance(length) {\n        this.pos += length;\n    }\n\n    /**\n     * Reads characters from the source.\n     * @param {number} [offset=0] The offset where reading starts, relative to the current position.\n     * @param {number} [length=1] Number of characters to read.\n     * @returns {string} A substring of source characters.\n     */\n    read(offset = 0, length = 1) {\n        const start = offset + this.pos;\n\n        return this.source.slice(start, start + length);\n    }\n}\n\nconst SIMPLE_ESCAPE_SEQUENCES =\n{ __proto__: null, b: \"\\b\", f: \"\\f\", n: \"\\n\", r: \"\\r\", t: \"\\t\", v: \"\\v\" };\n\n/**\n * Reads a hex escape sequence.\n * @param {TextReader} reader The reader should be positioned on the first hexadecimal digit.\n * @param {number} length The number of hexadecimal digits.\n * @returns {string} A code unit.\n */\nfunction readHexSequence(reader, length) {\n    const str = reader.read(0, length);\n    const charCode = parseInt(str, 16);\n\n    reader.advance(length);\n    return String.fromCharCode(charCode);\n}\n\n/**\n * Reads a Unicode escape sequence.\n * @param {TextReader} reader The reader should be positioned after the \"u\".\n * @returns {string} A code unit.\n */\nfunction readUnicodeSequence(reader) {\n    const regExp = /\\{(?<hexDigits>[\\dA-Fa-f]+)\\}/uy;\n\n    regExp.lastIndex = reader.pos;\n    const match = regExp.exec(reader.source);\n\n    if (match) {\n        const codePoint = parseInt(match.groups.hexDigits, 16);\n\n        reader.pos = regExp.lastIndex;\n        return String.fromCodePoint(codePoint);\n    }\n    return readHexSequence(reader, 4);\n}\n\n/**\n * Reads an octal escape sequence.\n * @param {TextReader} reader The reader should be positioned after the first octal digit.\n * @param {number} maxLength The maximum number of octal digits.\n * @returns {string} A code unit.\n */\nfunction readOctalSequence(reader, maxLength) {\n    const [octalStr] = reader.read(-1, maxLength).match(/^[0-7]+/u);\n\n    reader.advance(octalStr.length - 1);\n    const octal = parseInt(octalStr, 8);\n\n    return String.fromCharCode(octal);\n}\n\n/**\n * Reads an escape sequence or line continuation.\n * @param {TextReader} reader The reader should be positioned on the backslash.\n * @returns {string} A string of zero, one or two code units.\n */\nfunction readEscapeSequenceOrLineContinuation(reader) {\n    const char = reader.read(1);\n\n    reader.advance(2);\n    const unitChar = SIMPLE_ESCAPE_SEQUENCES[char];\n\n    if (unitChar) {\n        return unitChar;\n    }\n    switch (char) {\n        case \"x\":\n            return readHexSequence(reader, 2);\n        case \"u\":\n            return readUnicodeSequence(reader);\n        case \"\\r\":\n            if (reader.read() === \"\\n\") {\n                reader.advance(1);\n            }\n\n            // fallthrough\n        case \"\\n\":\n        case \"\\u2028\":\n        case \"\\u2029\":\n            return \"\";\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n            return readOctalSequence(reader, 3);\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n            return readOctalSequence(reader, 2);\n        default:\n            return char;\n    }\n}\n\n/**\n * Reads an escape sequence or line continuation and generates the respective `CodeUnit` elements.\n * @param {TextReader} reader The reader should be positioned on the backslash.\n * @returns {Generator<CodeUnit>} Zero, one or two `CodeUnit` elements.\n */\nfunction *mapEscapeSequenceOrLineContinuation(reader) {\n    const start = reader.pos;\n    const str = readEscapeSequenceOrLineContinuation(reader);\n    const end = reader.pos;\n    const source = reader.source.slice(start, end);\n\n    switch (str.length) {\n        case 0:\n            break;\n        case 1:\n            yield new CodeUnit(start, source);\n            break;\n        default:\n            yield new CodeUnit(start, source);\n            yield new CodeUnit(start, source);\n            break;\n    }\n}\n\n/**\n * Parses a string literal.\n * @param {string} source The string literal to parse, including the delimiting quotes.\n * @returns {CodeUnit[]} A list of code units produced by the string literal.\n */\nfunction parseStringLiteral(source) {\n    const reader = new TextReader(source);\n    const quote = reader.read();\n\n    reader.advance(1);\n    const codeUnits = [];\n\n    for (;;) {\n        const char = reader.read();\n\n        if (char === quote) {\n            break;\n        }\n        if (char === \"\\\\\") {\n            codeUnits.push(...mapEscapeSequenceOrLineContinuation(reader));\n        } else {\n            codeUnits.push(new CodeUnit(reader.pos, char));\n            reader.advance(1);\n        }\n    }\n    return codeUnits;\n}\n\n/**\n * Parses a template token.\n * @param {string} source The template token to parse, including the delimiting sequences `` ` ``, `${` and `}`.\n * @returns {CodeUnit[]} A list of code units produced by the template token.\n */\nfunction parseTemplateToken(source) {\n    const reader = new TextReader(source);\n\n    reader.advance(1);\n    const codeUnits = [];\n\n    for (;;) {\n        const char = reader.read();\n\n        if (char === \"`\" || char === \"$\" && reader.read(1) === \"{\") {\n            break;\n        }\n        if (char === \"\\\\\") {\n            codeUnits.push(...mapEscapeSequenceOrLineContinuation(reader));\n        } else {\n            let unitSource;\n\n            if (char === \"\\r\" && reader.read(1) === \"\\n\") {\n                unitSource = \"\\r\\n\";\n            } else {\n                unitSource = char;\n            }\n            codeUnits.push(new CodeUnit(reader.pos, unitSource));\n            reader.advance(unitSource.length);\n        }\n    }\n    return codeUnits;\n}\n\nmodule.exports = { parseStringLiteral, parseTemplateToken };\n"
        }
    ]
}