{
    "sourceFile": "node_modules/eslint/lib/rules/utils/lazy-loading-rule-map.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892240793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview `Map` to load rules lazily.\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst debug = require(\"debug\")(\"eslint:rules\");\n\n/** @typedef {import(\"../../shared/types\").Rule} Rule */\n\n/**\n * The `Map` object that loads each rule when it's accessed.\n * @example\n * const rules = new LazyLoadingRuleMap([\n *     [\"eqeqeq\", () => require(\"eqeqeq\")],\n *     [\"semi\", () => require(\"semi\")],\n *     [\"no-unused-vars\", () => require(\"no-unused-vars\")]\n * ]);\n *\n * rules.get(\"semi\"); // call `() => require(\"semi\")` here.\n *\n * @extends {Map<string, () => Rule>}\n */\nclass LazyLoadingRuleMap extends Map {\n\n    /**\n     * Initialize this map.\n     * @param {Array<[string, function(): Rule]>} loaders The rule loaders.\n     */\n    constructor(loaders) {\n        let remaining = loaders.length;\n\n        super(\n            debug.enabled\n                ? loaders.map(([ruleId, load]) => {\n                    let cache = null;\n\n                    return [\n                        ruleId,\n                        () => {\n                            if (!cache) {\n                                debug(\"Loading rule %o (remaining=%d)\", ruleId, --remaining);\n                                cache = load();\n                            }\n                            return cache;\n                        }\n                    ];\n                })\n                : loaders\n        );\n\n        // `super(...iterable)` uses `this.set()`, so disable it here.\n        Object.defineProperty(LazyLoadingRuleMap.prototype, \"set\", {\n            configurable: true,\n            value: void 0\n        });\n    }\n\n    /**\n     * Get a rule.\n     * Each rule will be loaded on the first access.\n     * @param {string} ruleId The rule ID to get.\n     * @returns {Rule|undefined} The rule.\n     */\n    get(ruleId) {\n        const load = super.get(ruleId);\n\n        return load && load();\n    }\n\n    /**\n     * Iterate rules.\n     * @returns {IterableIterator<Rule>} Rules.\n     */\n    *values() {\n        for (const load of super.values()) {\n            yield load();\n        }\n    }\n\n    /**\n     * Iterate rules.\n     * @returns {IterableIterator<[string, Rule]>} Rules.\n     */\n    *entries() {\n        for (const [ruleId, load] of super.entries()) {\n            yield [ruleId, load()];\n        }\n    }\n\n    /**\n     * Call a function with each rule.\n     * @param {Function} callbackFn The callback function.\n     * @param {any} [thisArg] The object to pass to `this` of the callback function.\n     * @returns {void}\n     */\n    forEach(callbackFn, thisArg) {\n        for (const [ruleId, load] of super.entries()) {\n            callbackFn.call(thisArg, load(), ruleId, this);\n        }\n    }\n}\n\n// Forbid mutation.\nObject.defineProperties(LazyLoadingRuleMap.prototype, {\n    clear: { configurable: true, value: void 0 },\n    delete: { configurable: true, value: void 0 },\n    [Symbol.iterator]: {\n        configurable: true,\n        writable: true,\n        value: LazyLoadingRuleMap.prototype.entries\n    }\n});\n\nmodule.exports = { LazyLoadingRuleMap };\n"
        }
    ]
}