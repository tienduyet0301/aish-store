{
    "sourceFile": "node_modules/eslint/lib/rules/no-self-assign.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892231024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/gu;\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props The flag to check member expressions as well.\n * @param {Function} report A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const leftElement = left.elements[i];\n            const rightElement = right.elements[i];\n\n            // Avoid cases such as [...a] = [...a, 1]\n            if (\n                leftElement &&\n                leftElement.type === \"RestElement\" &&\n                i < right.elements.length - 1\n            ) {\n                break;\n            }\n\n            eachSelfAssignment(leftElement, rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        /*\n         * Gets the index of the last spread property.\n         * It's possible to overwrite properties followed by it.\n         */\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            const propType = right.properties[i].type;\n\n            if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        right.kind === \"init\" &&\n        !right.method\n    ) {\n        const leftName = astUtils.getStaticPropertyName(left);\n\n        if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n            eachSelfAssignment(left.value, right.value, props, report);\n        }\n    } else if (\n        props &&\n        astUtils.skipChainExpression(left).type === \"MemberExpression\" &&\n        astUtils.skipChainExpression(right).type === \"MemberExpression\" &&\n        astUtils.isSameReference(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{ props: true }],\n\n        docs: {\n            description: \"Disallow assignments where both sides are exactly the same\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-self-assign\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            selfAssignment: \"'{{name}}' is assigned to itself.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const [{ props }] = context.options;\n\n        /**\n         * Reports a given node as self assignments.\n         * @param {ASTNode} node A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                messageId: \"selfAssignment\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if ([\"=\", \"&&=\", \"||=\", \"??=\"].includes(node.operator)) {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}