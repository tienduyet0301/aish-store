{
    "sourceFile": "node_modules/eslint/lib/rules/no-extra-parens.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892225804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n * @deprecated in ESLint v8.53.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst { isParenthesized: isParenthesizedRaw } = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"no-extra-parens\",\n                        url: \"https://eslint.style/rules/js/no-extra-parens\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Disallow unnecessary parentheses\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-extra-parens\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                ternaryOperandBinaryExpressions: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\n                                enforceForArrowConditionals: { type: \"boolean\" },\n                                enforceForSequenceExpressions: { type: \"boolean\" },\n                                enforceForNewInMemberExpressions: { type: \"boolean\" },\n                                enforceForFunctionPrototypeMethods: { type: \"boolean\" },\n                                allowParensAfterCommentPattern: { type: \"string\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        messages: {\n            unexpected: \"Unnecessary parentheses around expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n\n        const tokensToIgnore = new WeakSet();\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const EXCEPT_COND_TERNARY = ALL_NODES && context.options[1] && context.options[1].ternaryOperandBinaryExpressions === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForArrowConditionals === false;\n        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForSequenceExpressions === false;\n        const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForNewInMemberExpressions === false;\n        const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] &&\n            context.options[1].enforceForFunctionPrototypeMethods === false;\n        const ALLOW_PARENS_AFTER_COMMENT_PATTERN = ALL_NODES && context.options[1] && context.options[1].allowParensAfterCommentPattern;\n\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        let reportsBuffer;\n\n        /**\n         * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.\n         * Example: function(){}.call()\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is an immediate `call` or `apply` method call.\n         * @private\n         */\n        function isImmediateFunctionPrototypeMethodCall(node) {\n            const callNode = astUtils.skipChainExpression(node);\n\n            if (callNode.type !== \"CallExpression\") {\n                return false;\n            }\n            const callee = astUtils.skipChainExpression(callNode.callee);\n\n            return (\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee))\n            );\n        }\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n                return false;\n            }\n\n            if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\n                return false;\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is parenthesised.\n         * @private\n         */\n        function isParenthesised(node) {\n            return isParenthesizedRaw(1, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            return isParenthesizedRaw(2, node, sourceCode);\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses with considering precedence level of the node.\n         * If the preference level of the node is not higher or equal to precedence lower limit, it also checks\n         * whether the node is surrounded by parentheses twice or not.\n         * @param {ASTNode} node The node to be checked.\n         * @param {number} precedenceLowerLimit The lower limit of precedence.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\n            if (ruleApplies(node) && isParenthesised(node)) {\n                if (\n                    precedence(node) >= precedenceLowerLimit ||\n                    isParenthesisedTwice(node)\n                ) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n                if (\n                    currentNode.type === \"ReturnStatement\" ||\n                    (currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\")\n                ) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 ||\n                (\n\n                    // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n                    astUtils.isOpeningParenToken(penultimateToken) &&\n                    astUtils.isClosingParenToken(lastToken) &&\n                    newExpression.callee.range[1] < newExpression.range[1]\n                );\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            }\n            if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            }\n            if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            }\n            if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, { includeComments: true });\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, { includeComments: true });\n\n            return tokenBeforeLeftParen &&\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\n                leftParenToken.range[1] === tokenAfterLeftParen.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\n        }\n\n        /**\n         * Determines whether a node should be followed by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted after the node\n         * @private\n         */\n        function requiresTrailingSpace(node) {\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\n            const rightParenToken = nextTwoTokens[0];\n            const tokenAfterRightParen = nextTwoTokens[1];\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\n\n            return rightParenToken && tokenAfterRightParen &&\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n        }\n\n        /**\n         * Determines if a given expression node is an IIFE\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the given node is an IIFE\n         */\n        function isIIFE(node) {\n            const maybeCallNode = astUtils.skipChainExpression(node);\n\n            return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\n        }\n\n        /**\n         * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.\n         * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,\n         * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.\n         * @param {ASTNode} [node] The node to check\n         * @returns {boolean} `true` if the given node can be a valid assignment target\n         */\n        function canBeAssignmentTarget(node) {\n            return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\n        }\n\n        /**\n         * Checks if a node is fixable.\n         * A node is fixable if removing a single pair of surrounding parentheses does not turn it\n         * into a directive after fixing other nodes.\n         * Almost all nodes are fixable, except if all of the following conditions are met:\n         * The node is a string Literal\n         * It has a single pair of parentheses\n         * It is the only child of an ExpressionStatement\n         * @param {ASTNode} node The node to evaluate.\n         * @returns {boolean} Whether or not the node is fixable.\n         * @private\n         */\n        function isFixable(node) {\n\n            // if it's not a string literal it can be autofixed\n            if (node.type !== \"Literal\" || typeof node.value !== \"string\") {\n                return true;\n            }\n            if (isParenthesisedTwice(node)) {\n                return true;\n            }\n            return !astUtils.isTopLevelExpressionStatement(node.parent);\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (!isParenthesisedTwice(node)) {\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n                    return;\n                }\n\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\n                    return;\n                }\n\n                if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {\n                    const commentsBeforeLeftParenToken = sourceCode.getCommentsBefore(leftParenToken);\n                    const totalCommentsBeforeLeftParenTokenCount = commentsBeforeLeftParenToken.length;\n                    const ignorePattern = new RegExp(ALLOW_PARENS_AFTER_COMMENT_PATTERN, \"u\");\n\n                    if (\n                        totalCommentsBeforeLeftParenTokenCount > 0 &&\n                        ignorePattern.test(commentsBeforeLeftParenToken[totalCommentsBeforeLeftParenTokenCount - 1].value)\n                    ) {\n                        return;\n                    }\n                }\n            }\n\n            /**\n             * Finishes reporting\n             * @returns {void}\n             * @private\n             */\n            function finishReport() {\n                context.report({\n                    node,\n                    loc: leftParenToken.loc,\n                    messageId: \"unexpected\",\n                    fix: isFixable(node)\n                        ? fixer => {\n                            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                            return fixer.replaceTextRange([\n                                leftParenToken.range[0],\n                                rightParenToken.range[1]\n                            ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n                        }\n                        : null\n                });\n            }\n\n            if (reportsBuffer) {\n                reportsBuffer.reports.push({ node, finishReport });\n                return;\n            }\n\n            finishReport();\n        }\n\n        /**\n         * Evaluate a argument of the node.\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkArgumentWithPrecedence(node) {\n            if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Check if a member expression contains a call expression\n         * @param {ASTNode} node MemberExpression node to evaluate\n         * @returns {boolean} true if found, false if not\n         */\n        function doesMemberExpressionContainCallExpression(node) {\n            let currentNode = node.object;\n            let currentNodeType = node.object.type;\n\n            while (currentNodeType === \"MemberExpression\") {\n                currentNode = currentNode.object;\n                currentNodeType = currentNode.type;\n            }\n\n            return currentNodeType === \"CallExpression\";\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            const callee = node.callee;\n\n            if (hasExcessParensWithPrecedence(callee, precedence(node))) {\n                if (\n                    hasDoubleExcessParens(callee) ||\n                    !(\n                        isIIFE(node) ||\n\n                        // (new A)(); new (new A)();\n                        (\n                            callee.type === \"NewExpression\" &&\n                            !isNewExpressionWithParens(callee) &&\n                            !(\n                                node.type === \"NewExpression\" &&\n                                !isNewExpressionWithParens(node)\n                            )\n                        ) ||\n\n                        // new (a().b)(); new (a.b().c);\n                        (\n                            node.type === \"NewExpression\" &&\n                            callee.type === \"MemberExpression\" &&\n                            doesMemberExpressionContainCallExpression(callee)\n                        ) ||\n\n                        // (a?.b)(); (a?.())();\n                        (\n                            !node.optional &&\n                            callee.type === \"ChainExpression\"\n                        )\n                    )\n                ) {\n                    report(node.callee);\n                }\n            }\n            node.arguments\n                .filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                .forEach(report);\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left)) {\n                if (\n                    !([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) &&\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) &&\n                    (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation)) ||\n                    isParenthesisedTwice(node.left)\n                ) {\n                    report(node.left);\n                }\n            }\n\n            if (!shouldSkipRight && hasExcessParens(node.right)) {\n                if (\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) &&\n                    (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation)) ||\n                    isParenthesisedTwice(node.right)\n                ) {\n                    report(node.right);\n                }\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            /*\n             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n             * Otherwise, parentheses are needed.\n             */\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" &&\n                            tokenAfterClosingParens &&\n                            (\n                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||\n                                tokenAfterClosingParens.type === \"Identifier\"\n                            )\n                    ) ||\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\"\n                ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR)\n                : hasExcessParens(node);\n\n            if (hasExtraParens) {\n                report(node);\n            }\n        }\n\n        /**\n         * Finds the path from the given node to the specified ancestor.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} ancestor Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified ancestor.\n         */\n        function pathToAncestor(node, ancestor) {\n            const path = [node];\n            let currentNode = node;\n\n            while (currentNode !== ancestor) {\n\n                currentNode = currentNode.parent;\n\n                /* c8 ignore start */\n                if (currentNode === null) {\n                    throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n                }/* c8 ignore stop */\n\n                path.push(currentNode);\n            }\n\n            return path;\n        }\n\n        /**\n         * Finds the path from the given node to the specified descendant.\n         * @param {ASTNode} node First node in the path.\n         * @param {ASTNode} descendant Last node in the path.\n         * @returns {ASTNode[]} Path, including both nodes.\n         * @throws {Error} If the given node does not have the specified descendant.\n         */\n        function pathToDescendant(node, descendant) {\n            return pathToAncestor(descendant, node).reverse();\n        }\n\n        /**\n         * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\n         * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\n         * @param {ASTNode} node Ancestor of an 'in' expression.\n         * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\n         * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\n         */\n        function isSafelyEnclosingInExpression(node, child) {\n            switch (node.type) {\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                case \"BlockStatement\":\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                case \"TemplateLiteral\":\n                    return true;\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                    return node.params.includes(child);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return node.arguments.includes(child);\n                case \"MemberExpression\":\n                    return node.computed && node.property === child;\n                case \"ConditionalExpression\":\n                    return node.consequent === child;\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\n         * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\n         * @returns {void}\n         */\n        function startNewReportsBuffering() {\n            reportsBuffer = {\n                upper: reportsBuffer,\n                inExpressionNodes: [],\n                reports: []\n            };\n        }\n\n        /**\n         * Ends the current reports buffering.\n         * @returns {void}\n         */\n        function endCurrentReportsBuffering() {\n            const { upper, inExpressionNodes, reports } = reportsBuffer;\n\n            if (upper) {\n                upper.inExpressionNodes.push(...inExpressionNodes);\n                upper.reports.push(...reports);\n            } else {\n\n                // flush remaining reports\n                reports.forEach(({ finishReport }) => finishReport());\n            }\n\n            reportsBuffer = upper;\n        }\n\n        /**\n         * Checks whether the given node is in the current reports buffer.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is in the current buffer, false otherwise.\n         */\n        function isInCurrentReportsBuffer(node) {\n            return reportsBuffer.reports.some(r => r.node === node);\n        }\n\n        /**\n         * Removes the given node from the current reports buffer.\n         * @param {ASTNode} node Node to remove.\n         * @returns {void}\n         */\n        function removeFromCurrentReportsBuffer(node) {\n            reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n        }\n\n        /**\n         * Checks whether a node is a MemberExpression at NewExpression's callee.\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.\n         */\n        function isMemberExpInNewCallee(node) {\n            if (node.type === \"MemberExpression\") {\n                return node.parent.type === \"NewExpression\" && node.parent.callee === node\n                    ? true\n                    : node.parent.object === node && isMemberExpInNewCallee(node.parent);\n            }\n            return false;\n        }\n\n        /**\n         * Checks if the left-hand side of an assignment is an identifier, the operator is one of\n         * `=`, `&&=`, `||=` or `??=` and the right-hand side is an anonymous class or function.\n         *\n         * As per https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation, an\n         * assignment involving one of the operators `=`, `&&=`, `||=` or `??=` where the right-hand\n         * side is an anonymous class or function and the left-hand side is an *unparenthesized*\n         * identifier has different semantics than other assignments.\n         * Specifically, when an expression like `foo = function () {}` is evaluated, `foo.name`\n         * will be set to the string \"foo\", i.e. the identifier name. The same thing does not happen\n         * when evaluating `(foo) = function () {}`.\n         * Since the parenthesizing of the identifier in the left-hand side is significant in this\n         * special case, the parentheses, if present, should not be flagged as unnecessary.\n         * @param {ASTNode} node an AssignmentExpression node.\n         * @returns {boolean} `true` if the left-hand side of the assignment is an identifier, the\n         * operator is one of `=`, `&&=`, `||=` or `??=` and the right-hand side is an anonymous\n         * class or function; otherwise, `false`.\n         */\n        function isAnonymousFunctionAssignmentException({ left, operator, right }) {\n            if (left.type === \"Identifier\" && [\"=\", \"&&=\", \"||=\", \"??=\"].includes(operator)) {\n                const rhsType = right.type;\n\n                if (rhsType === \"ArrowFunctionExpression\") {\n                    return true;\n                }\n                if ((rhsType === \"FunctionExpression\" || rhsType === \"ClassExpression\") && !right.id) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        return {\n            ArrayExpression(node) {\n                node.elements\n                    .filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(report);\n            },\n\n            ArrayPattern(node) {\n                node.elements\n                    .filter(e => canBeAssignmentTarget(e) && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type === \"ConditionalExpression\" &&\n                    IGNORE_ARROW_CONDITIONALS\n                ) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left) &&\n                    (!isAnonymousFunctionAssignmentException(node) || isParenthesisedTwice(node.left))) {\n                    report(node.left);\n                }\n\n                if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression(node) {\n                if (reportsBuffer && node.operator === \"in\") {\n                    reportsBuffer.inExpressionNodes.push(node);\n                }\n\n                checkBinaryLogical(node);\n            },\n\n            CallExpression: checkCallNew,\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                const availableTypes = new Set([\"BinaryExpression\", \"LogicalExpression\"]);\n\n                if (\n                    !(EXCEPT_COND_TERNARY && availableTypes.has(node.test.type)) &&\n                    !isCondAssignException(node) &&\n                    hasExcessParensWithPrecedence(node.test, precedence({ type: \"LogicalExpression\", operator: \"||\" }))\n                ) {\n                    report(node.test);\n                }\n\n                if (\n                    !(EXCEPT_COND_TERNARY && availableTypes.has(node.consequent.type)) &&\n                    hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.consequent);\n                }\n\n                if (\n                    !(EXCEPT_COND_TERNARY && availableTypes.has(node.alternate.type)) &&\n                    hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            ForInStatement(node) {\n                if (node.left.type !== \"VariableDeclaration\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (\n                        firstLeftToken.value === \"let\" &&\n                        astUtils.isOpeningBracketToken(\n                            sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\n                        )\n                    ) {\n\n                        // ForInStatement#left expression cannot start with `let[`.\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForOfStatement(node) {\n                if (node.left.type !== \"VariableDeclaration\") {\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n                    if (firstLeftToken.value === \"let\") {\n\n                        // ForOfStatement#left expression cannot start with `let`.\n                        tokensToIgnore.add(firstLeftToken);\n                    }\n                }\n\n                if (hasExcessParens(node.left)) {\n                    report(node.left);\n                }\n\n                if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.right);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n\n                if (node.init) {\n\n                    if (node.init.type !== \"VariableDeclaration\") {\n                        const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\n\n                        if (\n                            firstToken.value === \"let\" &&\n                            astUtils.isOpeningBracketToken(\n                                sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken)\n                            )\n                        ) {\n\n                            // ForStatement#init expression cannot start with `let[`.\n                            tokensToIgnore.add(firstToken);\n                        }\n                    }\n\n                    startNewReportsBuffering();\n\n                    if (hasExcessParens(node.init)) {\n                        report(node.init);\n                    }\n                }\n            },\n\n            \"ForStatement > *.init:exit\"(node) {\n\n                /*\n                 * Removing parentheses around `in` expressions might change semantics and cause errors.\n                 *\n                 * For example, this valid for loop:\n                 *      for (let a = (b in c); ;);\n                 * after removing parentheses would be treated as an invalid for-in loop:\n                 *      for (let a = b in c; ;);\n                 */\n\n                if (reportsBuffer.reports.length) {\n                    reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n                        const path = pathToDescendant(node, inExpressionNode);\n                        let nodeToExclude;\n\n                        for (let i = 0; i < path.length; i++) {\n                            const pathNode = path[i];\n\n                            if (i < path.length - 1) {\n                                const nextPathNode = path[i + 1];\n\n                                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n\n                                    // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                                    return;\n                                }\n                            }\n\n                            if (isParenthesised(pathNode)) {\n                                if (isInCurrentReportsBuffer(pathNode)) {\n\n                                    // This node was supposed to be reported, but parentheses might be necessary.\n\n                                    if (isParenthesisedTwice(pathNode)) {\n\n                                        /*\n                                         * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\n                                         * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\n                                         * The remaining pair is safely enclosing the 'in' expression.\n                                         */\n                                        return;\n                                    }\n\n                                    // Exclude the outermost node only.\n                                    if (!nodeToExclude) {\n                                        nodeToExclude = pathNode;\n                                    }\n\n                                    // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n\n                                } else {\n\n                                    // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                                    return;\n                                }\n                            }\n                        }\n\n                        // Exclude the node from the list (i.e. treat parentheses as necessary)\n                        removeFromCurrentReportsBuffer(nodeToExclude);\n                    });\n                }\n\n                endCurrentReportsBuffering();\n            },\n\n            IfStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ImportExpression(node) {\n                const { source } = node;\n\n                if (source.type === \"SequenceExpression\") {\n                    if (hasDoubleExcessParens(source)) {\n                        report(source);\n                    }\n                } else if (hasExcessParens(source)) {\n                    report(source);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                const shouldAllowWrapOnce = isMemberExpInNewCallee(node) &&\n                  doesMemberExpressionContainCallExpression(node);\n                const nodeObjHasExcessParens = shouldAllowWrapOnce\n                    ? hasDoubleExcessParens(node.object)\n                    : hasExcessParens(node.object) &&\n                    !(\n                        isImmediateFunctionPrototypeMethodCall(node.parent) &&\n                        node.parent.callee === node &&\n                        IGNORE_FUNCTION_PROTOTYPE_METHODS\n                    );\n\n                if (\n                    nodeObjHasExcessParens &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  node.object.type === \"CallExpression\"\n                ) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                  !IGNORE_NEW_IN_MEMBER_EXPR &&\n                  node.object.type === \"NewExpression\" &&\n                  isNewExpressionWithParens(node.object)) {\n                    report(node.object);\n                }\n\n                if (nodeObjHasExcessParens &&\n                    node.optional &&\n                    node.object.type === \"ChainExpression\"\n                ) {\n                    report(node.object);\n                }\n\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            \"MethodDefinition[computed=true]\"(node) {\n                if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.key);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                node.properties\n                    .filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR))\n                    .forEach(property => report(property.value));\n            },\n\n            ObjectPattern(node) {\n                node.properties\n                    .filter(property => {\n                        const value = property.value;\n\n                        return canBeAssignmentTarget(value) && hasExcessParens(value);\n                    }).forEach(property => report(property.value));\n            },\n\n            Property(node) {\n                if (node.computed) {\n                    const { key } = node;\n\n                    if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                        report(key);\n                    }\n                }\n            },\n\n            PropertyDefinition(node) {\n                if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.key);\n                }\n\n                if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(node.value);\n                }\n            },\n\n            RestElement(node) {\n                const argument = node.argument;\n\n                if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\n                    report(argument);\n                }\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                const precedenceOfNode = precedence(node);\n\n                node.expressions\n                    .filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode))\n                    .forEach(report);\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkArgumentWithPrecedence,\n            UpdateExpression(node) {\n                if (node.prefix) {\n                    checkArgumentWithPrecedence(node);\n                } else {\n                    const { argument } = node;\n                    const operatorToken = sourceCode.getLastToken(node);\n\n                    if (argument.loc.end.line === operatorToken.loc.start.line) {\n                        checkArgumentWithPrecedence(node);\n                    } else {\n                        if (hasDoubleExcessParens(argument)) {\n                            report(argument);\n                        }\n                    }\n                }\n            },\n            AwaitExpression: checkArgumentWithPrecedence,\n\n            VariableDeclarator(node) {\n                if (\n                    node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) &&\n\n                    // RegExp literal is allowed to have parens (#1589)\n                    !(node.init.type === \"Literal\" && node.init.regex)\n                ) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator,\n\n            TemplateLiteral(node) {\n                node.expressions\n                    .filter(e => e && hasExcessParens(e))\n                    .forEach(report);\n            },\n\n            AssignmentPattern(node) {\n                const { left, right } = node;\n\n                if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\n                    report(left);\n                }\n\n                if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n                    report(right);\n                }\n            }\n        };\n\n    }\n};\n"
        }
    ]
}