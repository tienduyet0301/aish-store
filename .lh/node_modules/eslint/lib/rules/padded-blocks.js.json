{
    "sourceFile": "node_modules/eslint/lib/rules/padded-blocks.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892234656,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"padded-blocks\",\n                        url: \"https://eslint.style/rules/js/padded-blocks\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow padding within blocks\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/padded-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLineBlocks: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            alwaysPadBlock: \"Block must be padded by blank lines.\",\n            neverPadBlock: \"Block must not be padded by blank lines.\"\n        }\n    },\n\n    create(context) {\n        const options = {};\n        const typeOptions = context.options[0] || \"always\";\n        const exceptOptions = context.options[1] || {};\n\n        if (typeof typeOptions === \"string\") {\n            const shouldHavePadding = typeOptions === \"always\";\n\n            options.blocks = shouldHavePadding;\n            options.switches = shouldHavePadding;\n            options.classes = shouldHavePadding;\n        } else {\n            if (Object.hasOwn(typeOptions, \"blocks\")) {\n                options.blocks = typeOptions.blocks === \"always\";\n            }\n            if (Object.hasOwn(typeOptions, \"switches\")) {\n                options.switches = typeOptions.switches === \"always\";\n            }\n            if (Object.hasOwn(typeOptions, \"classes\")) {\n                options.classes = typeOptions.classes === \"always\";\n            }\n        }\n\n        if (Object.hasOwn(exceptOptions, \"allowSingleLineBlocks\")) {\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n        }\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n\n            if (node.type === \"StaticBlock\") {\n                return sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\n            }\n\n            // `BlockStatement` or `ClassBody`\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @throws {Error} (Unreachable)\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                case \"StaticBlock\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* c8 ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n                return;\n            }\n\n            if (requirePaddingFor(node)) {\n\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        messageId: \"alwaysPadBlock\"\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            start: tokenBeforeFirst.loc.start,\n                            end: firstBlockToken.loc.start\n                        },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        messageId: \"neverPadBlock\"\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: {\n                            end: tokenAfterLast.loc.start,\n                            start: lastBlockToken.loc.end\n                        },\n                        messageId: \"neverPadBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (Object.hasOwn(options, \"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (Object.hasOwn(options, \"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n            rule.StaticBlock = rule.BlockStatement;\n        }\n\n        if (Object.hasOwn(options, \"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n"
        }
    ]
}