{
    "sourceFile": "node_modules/eslint/lib/rules/func-name-matching.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892215586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 2015) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        considerPropertyDescriptor: {\n            type: \"boolean\"\n        },\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require function names to match the name of the variable or property to which they are assigned\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/func-name-matching\"\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        },\n\n        messages: {\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.languageOptions.ecmaVersion;\n\n        /**\n         * Check whether node is a certain CallExpression.\n         * @param {string} objName object name\n         * @param {string} funcName function name\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if node matches CallExpression\n         */\n        function isPropertyCall(objName, funcName, node) {\n            if (!node) {\n                return false;\n            }\n            return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n        }\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let messageId;\n\n            if (nameMatches === \"always\" && isProp) {\n                messageId = \"matchProperty\";\n            } else if (nameMatches === \"always\") {\n                messageId = \"matchVariable\";\n            } else if (isProp) {\n                messageId = \"notMatchProperty\";\n            } else {\n                messageId = \"notMatchVariable\";\n            }\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && name && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            \"Property, PropertyDefinition[value]\"(node) {\n                if (!(node.value.type === \"FunctionExpression\" && node.value.id)) {\n                    return;\n                }\n\n                if (node.key.type === \"Identifier\" && !node.computed) {\n                    const functionName = node.value.id.name;\n                    let propertyName = node.key.name;\n\n                    if (\n                        considerPropertyDescriptor &&\n                        propertyName === \"value\" &&\n                        node.parent.type === \"ObjectExpression\"\n                    ) {\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n                            const property = node.parent.parent.arguments[1];\n\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                                report(node, property.value, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (shouldWarn(propertyName, functionName)) {\n                            report(node, propertyName, functionName, true);\n                        }\n                    } else if (shouldWarn(propertyName, functionName)) {\n                        report(node, propertyName, functionName, true);\n                    }\n                    return;\n                }\n\n                if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}