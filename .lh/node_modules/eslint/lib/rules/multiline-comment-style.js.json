{
    "sourceFile": "node_modules/eslint/lib/rules/multiline-comment-style.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892218106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview enforce a particular style for multiline comments\n * @author Teddy Katz\n * @deprecated in ESLint v9.3.0\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"9.3.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"multiline-comment-style\",\n                        url: \"https://eslint.style/rules/js/multiline-comment-style\"\n                    }\n                }\n            ]\n        },\n        type: \"suggestion\",\n        docs: {\n            description: \"Enforce a particular style for multiline comments\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/multiline-comment-style\"\n        },\n\n        fixable: \"whitespace\",\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"starred-block\", \"bare-block\"]\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"separate-lines\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                checkJSDoc: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n        messages: {\n            expectedBlock: \"Expected a block comment instead of consecutive line comments.\",\n            expectedBareBlock: \"Expected a block comment without padding stars.\",\n            startNewline: \"Expected a linebreak after '/*'.\",\n            endNewline: \"Expected a linebreak before '*/'.\",\n            missingStar: \"Expected a '*' at the start of this line.\",\n            alignment: \"Expected this line to be aligned with the start of the comment.\",\n            expectedLines: \"Expected multiple line comments instead of a block comment.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const option = context.options[0] || \"starred-block\";\n        const params = context.options[1] || {};\n        const checkJSDoc = !!params.checkJSDoc;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks if a comment line is starred.\n         * @param {string} line A string representing a comment line.\n         * @returns {boolean} Whether or not the comment line is starred.\n         */\n        function isStarredCommentLine(line) {\n            return /^\\s*\\*/u.test(line);\n        }\n\n        /**\n         * Checks if a comment group is in starred-block form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in starred block form.\n         */\n        function isStarredBlockComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            // The first and last lines can only contain whitespace.\n            return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\\s*$/u : /^\\s*\\*/u).test(line));\n        }\n\n        /**\n         * Checks if a comment group is in JSDoc form.\n         * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment.\n         * @returns {boolean} Whether or not the comment group is in JSDoc form.\n         */\n        function isJSDocComment([firstComment]) {\n            if (firstComment.type !== \"Block\") {\n                return false;\n            }\n\n            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n\n            return /^\\*\\s*$/u.test(lines[0]) &&\n                lines.slice(1, -1).every(line => /^\\s* /u.test(line)) &&\n                /^\\s*$/u.test(lines.at(-1));\n        }\n\n        /**\n         * Processes a comment group that is currently in separate-line form, calculating the offset for each line.\n         * @param {Token[]} commentGroup A group of comments containing multiple line comments.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processSeparateLineComments(commentGroup) {\n            const allLinesHaveLeadingSpace = commentGroup\n                .map(({ value }) => value)\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return commentGroup.map(({ value }) => (allLinesHaveLeadingSpace ? value.replace(/^ /u, \"\") : value));\n        }\n\n        /**\n         * Processes a comment group that is currently in starred-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in starred-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processStarredBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER)\n                .filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1))\n                .map(line => line.replace(/^\\s*$/u, \"\"));\n            const allLinesHaveLeadingSpace = lines\n                .map(line => line.replace(/\\s*\\*/u, \"\"))\n                .filter(line => line.trim().length)\n                .every(line => line.startsWith(\" \"));\n\n            return lines.map(line => line.replace(allLinesHaveLeadingSpace ? /\\s*\\* ?/u : /\\s*\\*/u, \"\"));\n        }\n\n        /**\n         * Processes a comment group that is currently in bare-block form, calculating the offset for each line.\n         * @param {Token} comment A single block comment token in bare-block form.\n         * @returns {string[]} An array of the processed lines.\n         */\n        function processBareBlockComment(comment) {\n            const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\\s*$/u, \"\"));\n            const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;\n            let offset = \"\";\n\n            /*\n             * Calculate the offset of the least indented line and use that as the basis for offsetting all the lines.\n             * The first line should not be checked because it is inline with the opening block comment delimiter.\n             */\n            for (const [i, line] of lines.entries()) {\n                if (!line.trim().length || i === 0) {\n                    continue;\n                }\n\n                const [, lineOffset] = line.match(/^(\\s*\\*?\\s*)/u);\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);\n\n                    if (newOffset.length > offset.length) {\n                        offset = newOffset;\n                    }\n                }\n            }\n\n            return lines.map(line => {\n                const match = line.match(/^(\\s*\\*?\\s*)(.*)/u);\n                const [, lineOffset, lineContents] = match;\n\n                if (lineOffset.length > leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;\n                }\n\n                if (lineOffset.length < leadingWhitespace.length) {\n                    return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;\n                }\n\n                return lineContents;\n            });\n        }\n\n        /**\n         * Gets a list of comment lines in a group, formatting leading whitespace as necessary.\n         * @param {Token[]} commentGroup A group of comments containing either multiple line comments or a single block comment.\n         * @returns {string[]} A list of comment lines.\n         */\n        function getCommentLines(commentGroup) {\n            const [firstComment] = commentGroup;\n\n            if (firstComment.type === \"Line\") {\n                return processSeparateLineComments(commentGroup);\n            }\n\n            if (isStarredBlockComment(commentGroup)) {\n                return processStarredBlockComment(firstComment);\n            }\n\n            return processBareBlockComment(firstComment);\n        }\n\n        /**\n         * Gets the initial offset (whitespace) from the beginning of a line to a given comment token.\n         * @param {Token} comment The token to check.\n         * @returns {string} The offset from the beginning of a line to the token.\n         */\n        function getInitialOffset(comment) {\n            return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);\n        }\n\n        /**\n         * Converts a comment into starred-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers\n         */\n        function convertToStarredBlock(firstComment, commentLinesList) {\n            const initialOffset = getInitialOffset(firstComment);\n\n            return `/*\\n${commentLinesList.map(line => `${initialOffset} * ${line}`).join(\"\\n\")}\\n${initialOffset} */`;\n        }\n\n        /**\n         * Converts a comment into separate-line form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in separate-line form\n         */\n        function convertToSeparateLines(firstComment, commentLinesList) {\n            return commentLinesList.map(line => `// ${line}`).join(`\\n${getInitialOffset(firstComment)}`);\n        }\n\n        /**\n         * Converts a comment into bare-block form\n         * @param {Token} firstComment The first comment of the group being converted\n         * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment\n         * @returns {string} A representation of the comment value in bare-block form\n         */\n        function convertToBlock(firstComment, commentLinesList) {\n            return `/* ${commentLinesList.join(`\\n${getInitialOffset(firstComment)}   `)} */`;\n        }\n\n        /**\n         * Each method checks a group of comments to see if it's valid according to the given option.\n         * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single\n         * block comment or multiple line comments.\n         * @returns {void}\n         */\n        const commentGroupCheckers = {\n            \"starred-block\"(commentGroup) {\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                if (commentLines.some(value => value.includes(\"*/\"))) {\n                    return;\n                }\n\n                if (commentGroup.length > 1) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup.at(-1).loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            const range = [firstComment.range[0], commentGroup.at(-1).range[1]];\n\n                            return commentLines.some(value => value.startsWith(\"/\"))\n                                ? null\n                                : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));\n                        }\n                    });\n                } else {\n                    const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);\n                    const expectedLeadingWhitespace = getInitialOffset(firstComment);\n                    const expectedLinePrefix = `${expectedLeadingWhitespace} *`;\n\n                    if (!/^\\*?\\s*$/u.test(lines[0])) {\n                        const start = firstComment.value.startsWith(\"*\") ? firstComment.range[0] + 1 : firstComment.range[0];\n\n                        context.report({\n                            loc: {\n                                start: firstComment.loc.start,\n                                end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                            },\n                            messageId: \"startNewline\",\n                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\\n${expectedLinePrefix}`)\n                        });\n                    }\n\n                    if (!/^\\s*$/u.test(lines.at(-1))) {\n                        context.report({\n                            loc: {\n                                start: { line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2 },\n                                end: firstComment.loc.end\n                            },\n                            messageId: \"endNewline\",\n                            fix: fixer => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `\\n${expectedLinePrefix}/`)\n                        });\n                    }\n\n                    for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {\n                        const lineText = sourceCode.lines[lineNumber - 1];\n                        const errorType = isStarredCommentLine(lineText)\n                            ? \"alignment\"\n                            : \"missingStar\";\n\n                        if (!lineText.startsWith(expectedLinePrefix)) {\n                            context.report({\n                                loc: {\n                                    start: { line: lineNumber, column: 0 },\n                                    end: { line: lineNumber, column: lineText.length }\n                                },\n                                messageId: errorType,\n                                fix(fixer) {\n                                    const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });\n\n                                    if (errorType === \"alignment\") {\n                                        const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*\\*)/u) || [];\n                                        const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n\n                                        return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], expectedLinePrefix);\n                                    }\n\n                                    const [, commentTextPrefix = \"\"] = lineText.match(/^(\\s*)/u) || [];\n                                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;\n                                    let offset;\n\n                                    for (const [idx, line] of lines.entries()) {\n                                        if (!/\\S+/u.test(line)) {\n                                            continue;\n                                        }\n\n                                        const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];\n                                        const [, prefix = \"\", initialOffset = \"\"] = lineTextToAlignWith.match(/^(\\s*(?:\\/?\\*)?(\\s*))/u) || [];\n\n                                        offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;\n\n                                        if (/^\\s*\\//u.test(lineText) && offset.length === 0) {\n                                            offset += \" \";\n                                        }\n                                        break;\n                                    }\n\n                                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n            \"separate-lines\"(commentGroup) {\n                const [firstComment] = commentGroup;\n\n                const isJSDoc = isJSDocComment(commentGroup);\n\n                if (firstComment.type !== \"Block\" || (!checkJSDoc && isJSDoc)) {\n                    return;\n                }\n\n                let commentLines = getCommentLines(commentGroup);\n\n                if (isJSDoc) {\n                    commentLines = commentLines.slice(1, commentLines.length - 1);\n                }\n\n                const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });\n\n                if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {\n                    return;\n                }\n\n                context.report({\n                    loc: {\n                        start: firstComment.loc.start,\n                        end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                    },\n                    messageId: \"expectedLines\",\n                    fix(fixer) {\n                        return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));\n                    }\n                });\n            },\n            \"bare-block\"(commentGroup) {\n                if (isJSDocComment(commentGroup)) {\n                    return;\n                }\n\n                const [firstComment] = commentGroup;\n                const commentLines = getCommentLines(commentGroup);\n\n                // Disallows consecutive line comments in favor of using a block comment.\n                if (firstComment.type === \"Line\" && commentLines.length > 1 &&\n                    !commentLines.some(value => value.includes(\"*/\"))) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: commentGroup.at(-1).loc.end\n                        },\n                        messageId: \"expectedBlock\",\n                        fix(fixer) {\n                            return fixer.replaceTextRange(\n                                [firstComment.range[0], commentGroup.at(-1).range[1]],\n                                convertToBlock(firstComment, commentLines)\n                            );\n                        }\n                    });\n                }\n\n                // Prohibits block comments from having a * at the beginning of each line.\n                if (isStarredBlockComment(commentGroup)) {\n                    context.report({\n                        loc: {\n                            start: firstComment.loc.start,\n                            end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }\n                        },\n                        messageId: \"expectedBareBlock\",\n                        fix(fixer) {\n                            return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));\n                        }\n                    });\n                }\n            }\n        };\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                return sourceCode.getAllComments()\n                    .filter(comment => comment.type !== \"Shebang\")\n                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))\n                    .filter(comment => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;\n                    })\n                    .reduce((commentGroups, comment, index, commentList) => {\n                        const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n                        if (\n                            comment.type === \"Line\" &&\n                            index && commentList[index - 1].type === \"Line\" &&\n                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&\n                            tokenBefore === commentList[index - 1]\n                        ) {\n                            commentGroups.at(-1).push(comment);\n                        } else {\n                            commentGroups.push([comment]);\n                        }\n\n                        return commentGroups;\n                    }, [])\n                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))\n                    .forEach(commentGroupCheckers[option]);\n            }\n        };\n    }\n};\n"
        }
    ]
}