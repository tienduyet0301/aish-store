{
    "sourceFile": "node_modules/eslint/lib/rules/object-curly-newline.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892233801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Checks if a value is an object.\n * @param {any} value The value to check\n * @returns {boolean} `true` if the value is an object, otherwise `false`\n */\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if an option is a node-specific option\n * @param {any} option The option to check\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\n */\nfunction isNodeSpecificOption(option) {\n    return isObject(option) || typeof option === \"string\";\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"object-curly-newline\",\n                        url: \"https://eslint.style/rules/js/object-curly-newline\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent line breaks after opening and before closing braces\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n            unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n            expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n            expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.sourceCode;\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        messageId: \"expectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        messageId: \"expectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};\n"
        }
    ]
}