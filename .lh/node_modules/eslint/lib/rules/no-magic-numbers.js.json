{
    "sourceFile": "node_modules/eslint/lib/rules/no-magic-numbers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892227726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n// Maximum array length by the ECMAScript Specification.\nconst MAX_ARRAY_LENGTH = 2 ** 32 - 1;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Convert the value to bigint if it's a string. Otherwise return the value as-is.\n * @param {bigint|number|string} x The value to normalize.\n * @returns {bigint|number} The normalized value.\n */\nfunction normalizeIgnoreValue(x) {\n    if (typeof x === \"string\") {\n        return BigInt(x.slice(0, -1));\n    }\n    return x;\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow magic numbers\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-magic-numbers\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\",\n                    default: false\n                },\n                enforceConst: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        anyOf: [\n                            { type: \"number\" },\n                            { type: \"string\", pattern: \"^[+-]?(?:0|[1-9][0-9]*)n$\" }\n                        ]\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreDefaultValues: {\n                    type: \"boolean\",\n                    default: false\n                },\n                ignoreClassFieldInitialValues: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n\n        messages: {\n            useConst: \"Number constants declarations must use 'const'.\",\n            noMagic: \"No magic number: {{raw}}.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = new Set((config.ignore || []).map(normalizeIgnoreValue)),\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes,\n            ignoreDefaultValues = !!config.ignoreDefaultValues,\n            ignoreClassFieldInitialValues = !!config.ignoreClassFieldInitialValues;\n\n        const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n        /**\n         * Returns whether the rule is configured to ignore the given value\n         * @param {bigint|number} value The value to check\n         * @returns {boolean} true if the value is ignored\n         */\n        function isIgnoredValue(value) {\n            return ignore.has(value);\n        }\n\n        /**\n         * Returns whether the number is a default value assignment.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is a default value\n         */\n        function isDefaultValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"AssignmentPattern\" && parent.right === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the number is the initial value of a class field.\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the number is the initial value of a class field.\n         */\n        function isClassFieldInitialValue(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"PropertyDefinition\" && parent.value === fullNumberNode;\n        }\n\n        /**\n         * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is radix\n         */\n        function isParseIntRadix(fullNumberNode) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"CallExpression\" && fullNumberNode === parent.arguments[1] &&\n                (\n                    astUtils.isSpecificId(parent.callee, \"parseInt\") ||\n                    astUtils.isSpecificMemberAccess(parent.callee, \"Number\", \"parseInt\")\n                );\n        }\n\n        /**\n         * Returns whether the given node is a direct child of a JSX node.\n         * In particular, it aims to detect numbers used as prop values in JSX tags.\n         * Example: <input maxLength={10} />\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @returns {boolean} true if the node is a JSX number\n         */\n        function isJSXNumber(fullNumberNode) {\n            return fullNumberNode.parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the given node is used as an array index.\n         * Value must coerce to a valid array index name: \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * All other values, like \"-1\", \"2.5\", or \"4294967295\", are just \"normal\" object properties,\n         * which can be created and accessed on an array in addition to the array index properties,\n         * but they don't affect array's length and are not considered by methods such as .map(), .forEach() etc.\n         *\n         * The maximum array length by the specification is 2 ** 32 - 1 = 4294967295,\n         * thus the maximum valid index is 2 ** 32 - 2 = 4294967294.\n         *\n         * All notations are allowed, as long as the value coerces to one of \"0\", \"1\", \"2\" ... \"4294967294\".\n         *\n         * Valid examples:\n         * a[0], a[1], a[1.2e1], a[0xAB], a[0n], a[1n]\n         * a[-0] (same as a[0] because -0 coerces to \"0\")\n         * a[-0n] (-0n evaluates to 0n)\n         *\n         * Invalid examples:\n         * a[-1], a[-0xAB], a[-1n], a[2.5], a[1.23e1], a[12e-1]\n         * a[4294967295] (above the max index, it's an access to a regular property a[\"4294967295\"])\n         * a[999999999999999999999] (even if it wasn't above the max index, it would be a[\"1e+21\"])\n         * a[1e310] (same as a[\"Infinity\"])\n         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node\n         * @param {bigint|number} value Value expressed by the fullNumberNode\n         * @returns {boolean} true if the node is a valid array index\n         */\n        function isArrayIndex(fullNumberNode, value) {\n            const parent = fullNumberNode.parent;\n\n            return parent.type === \"MemberExpression\" && parent.property === fullNumberNode &&\n                (Number.isInteger(value) || typeof value === \"bigint\") &&\n                value >= 0 && value < MAX_ARRAY_LENGTH;\n        }\n\n        return {\n            Literal(node) {\n                if (!astUtils.isNumericLiteral(node)) {\n                    return;\n                }\n\n                let fullNumberNode;\n                let value;\n                let raw;\n\n                // Treat unary minus as a part of the number\n                if (node.parent.type === \"UnaryExpression\" && node.parent.operator === \"-\") {\n                    fullNumberNode = node.parent;\n                    value = -node.value;\n                    raw = `-${node.raw}`;\n                } else {\n                    fullNumberNode = node;\n                    value = node.value;\n                    raw = node.raw;\n                }\n\n                const parent = fullNumberNode.parent;\n\n                // Always allow radix arguments and JSX props\n                if (\n                    isIgnoredValue(value) ||\n                    (ignoreDefaultValues && isDefaultValue(fullNumberNode)) ||\n                    (ignoreClassFieldInitialValues && isClassFieldInitialValue(fullNumberNode)) ||\n                    isParseIntRadix(fullNumberNode) ||\n                    isJSXNumber(fullNumberNode) ||\n                    (ignoreArrayIndexes && isArrayIndex(fullNumberNode, value))\n                ) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node: fullNumberNode,\n                            messageId: \"useConst\"\n                        });\n                    }\n                } else if (\n                    !okTypes.includes(parent.type) ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node: fullNumberNode,\n                        messageId: \"noMagic\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}