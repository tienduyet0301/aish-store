{
    "sourceFile": "node_modules/eslint/lib/rules/no-implicit-coercion.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892226487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"- -\", \"-\", \"*\"];\n\n/**\n * Checks whether or not a node is a double logical negating.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical negating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    if (node.operator !== \"~\") {\n        return false;\n    }\n    const callNode = astUtils.skipChainExpression(node.argument);\n\n    return (\n        callNode.type === \"CallExpression\" &&\n        astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the given node logically represents multiplication by a fraction of `1`.\n * For example, `a * 1` in `a * 1 / b` is technically multiplication by `1`, but the\n * whole expression can be logically interpreted as `a * (1 / b)` rather than `(a * 1) / b`.\n * @param {BinaryExpression} node A BinaryExpression node to check.\n * @param {SourceCode} sourceCode The source code object.\n * @returns {boolean} Whether or not the node is a multiplying by a fraction of `1`.\n */\nfunction isMultiplyByFractionOfOne(node, sourceCode) {\n    return node.type === \"BinaryExpression\" &&\n        node.operator === \"*\" &&\n        (node.right.type === \"Literal\" && node.right.value === 1) &&\n        node.parent.type === \"BinaryExpression\" &&\n        node.parent.operator === \"/\" &&\n        node.parent.left === node &&\n        !astUtils.isParenthesised(sourceCode, node);\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether an expression evaluates to a string.\n * @param {ASTNode} node node that represents the expression to check.\n * @returns {boolean} Whether or not the expression evaluates to a string.\n */\nfunction isStringType(node) {\n    return astUtils.isStringLiteral(node) ||\n        (\n            node.type === \"CallExpression\" &&\n            node.callee.type === \"Identifier\" &&\n            node.callee.name === \"String\"\n        );\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !isStringType(node.right)) ||\n        (isEmptyString(node.right) && !isStringType(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        hasSuggestions: true,\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow shorthand type conversions\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-implicit-coercion\"\n        },\n\n        fixable: \"code\",\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\"\n                },\n                number: {\n                    type: \"boolean\"\n                },\n                string: {\n                    type: \"boolean\"\n                },\n                disallowTemplateShorthand: {\n                    type: \"boolean\"\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }],\n\n        defaultOptions: [{\n            allow: [],\n            boolean: true,\n            disallowTemplateShorthand: false,\n            number: true,\n            string: true\n        }],\n\n        messages: {\n            implicitCoercion: \"Unexpected implicit coercion encountered. Use `{{recommendation}}` instead.\",\n            useRecommendation: \"Use `{{recommendation}}` instead.\"\n        }\n    },\n\n    create(context) {\n        const [options] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Reports an error and autofixes the node\n         * @param {ASTNode} node An ast node to report the error on.\n         * @param {string} recommendation The recommended code for the issue\n         * @param {bool} shouldSuggest Whether this report should offer a suggestion\n         * @param {bool} shouldFix Whether this report should fix the node\n         * @returns {void}\n         */\n        function report(node, recommendation, shouldSuggest, shouldFix) {\n\n            /**\n             * Fix function\n             * @param {RuleFixer} fixer The fixer to fix.\n             * @returns {Fix} The fix object.\n             */\n            function fix(fixer) {\n                const tokenBefore = sourceCode.getTokenBefore(node);\n\n                if (\n                    tokenBefore?.range[1] === node.range[0] &&\n                    !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\n                ) {\n                    return fixer.replaceText(node, ` ${recommendation}`);\n                }\n\n                return fixer.replaceText(node, recommendation);\n            }\n\n            context.report({\n                node,\n                messageId: \"implicitCoercion\",\n                data: { recommendation },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    return fix(fixer);\n                },\n                suggest: [\n                    {\n                        messageId: \"useRecommendation\",\n                        data: { recommendation },\n                        fix(fixer) {\n                            if (shouldFix || !shouldSuggest) {\n                                return null;\n                            }\n\n                            return fix(fixer);\n                        }\n                    }\n                ]\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.includes(\"!!\");\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n                    const variable = astUtils.getVariableByName(sourceCode.getScope(node), \"Boolean\");\n                    const booleanExists = variable?.identifiers.length === 0;\n\n                    report(node, recommendation, true, booleanExists);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.includes(\"~\");\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n\n                    // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n                    const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n                    const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n\n                    report(node, recommendation, false, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.includes(\"+\");\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation, true, false);\n                }\n\n                // -(-foo)\n                operatorAllowed = options.allow.includes(\"- -\");\n                if (!operatorAllowed && options.number && node.operator === \"-\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"-\" && !isNumeric(node.argument.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation, true, false);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.includes(\"*\");\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && !isMultiplyByFractionOfOne(node, sourceCode) &&\n                    getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation, true, false);\n                }\n\n                // foo - 0\n                operatorAllowed = options.allow.includes(\"-\");\n                if (!operatorAllowed && options.number && node.operator === \"-\" && node.right.type === \"Literal\" && node.right.value === 0 && !isNumeric(node.left)) {\n                    const recommendation = `Number(${sourceCode.getText(node.left)})`;\n\n                    report(node, recommendation, true, false);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.includes(\"+\");\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation, true, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.includes(\"+\");\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation, true, false);\n                }\n            },\n\n            TemplateLiteral(node) {\n                if (!options.disallowTemplateShorthand) {\n                    return;\n                }\n\n                // tag`${foo}`\n                if (node.parent.type === \"TaggedTemplateExpression\") {\n                    return;\n                }\n\n                // `` or `${foo}${bar}`\n                if (node.expressions.length !== 1) {\n                    return;\n                }\n\n\n                //  `prefix${foo}`\n                if (node.quasis[0].value.cooked !== \"\") {\n                    return;\n                }\n\n                //  `${foo}postfix`\n                if (node.quasis[1].value.cooked !== \"\") {\n                    return;\n                }\n\n                // if the expression is already a string, then this isn't a coercion\n                if (isStringType(node.expressions[0])) {\n                    return;\n                }\n\n                const code = sourceCode.getText(node.expressions[0]);\n                const recommendation = `String(${code})`;\n\n                report(node, recommendation, true, false);\n            }\n        };\n    }\n};\n"
        }
    ]
}