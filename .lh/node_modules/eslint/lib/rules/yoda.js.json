{
    "sourceFile": "node_modules/eslint/lib/rules/yoda.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892241534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return /^(==|===)$/u.test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].includes(operator);\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction isNegativeNumericLiteral(node) {\n    return (\n        node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        astUtils.isNumericLiteral(node.argument)\n    );\n}\n\n/**\n * Determines whether a non-Literal node should be treated as a single Literal node.\n * @param {ASTNode} node Node to test\n * @returns {boolean} True if the node should be treated as a single Literal node.\n */\nfunction looksLikeLiteral(node) {\n    return isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node);\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. A normalized Literal node with the string as the value if the node is\n *     a Template Literal without expression.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (isNegativeNumericLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (astUtils.isStaticTemplateLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: node.quasis[0].value.cooked,\n            raw: node.quasis[0].value.raw\n        };\n    }\n\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"never\", {\n            exceptRange: false,\n            onlyEquality: false\n        }],\n\n        docs: {\n            description: 'Require or disallow \"Yoda\" conditions',\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/yoda\"\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\"\n                    },\n                    onlyEquality: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            expected:\n                \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n        }\n    },\n\n    create(context) {\n        const [when, { exceptRange, onlyEquality }] = context.options;\n        const always = when === \"always\";\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n                    const leftLiteral = getNormalizedLiteral(left.left);\n                    const rightLiteral = getNormalizedLiteral(right.right);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n                    const leftLiteral = getNormalizedLiteral(left.right);\n                    const rightLiteral = getNormalizedLiteral(right.left);\n\n                    if (leftLiteral === null && rightLiteral === null) {\n                        return false;\n                    }\n\n                    if (rightLiteral === null || leftLiteral === null) {\n                        return true;\n                    }\n\n                    if (leftLiteral.value <= rightLiteral.value) {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (\n                node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped()\n            );\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n         * @param {ASTNode} node The BinaryExpression node\n         * @returns {string} A string representation of the node with the sides and operator flipped\n         */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(\n                node.left,\n                node.right,\n                token => token.value === node.operator\n            );\n            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n\n            const source = sourceCode.getText();\n\n            const leftText = source.slice(\n                node.range[0],\n                lastLeftToken.range[1]\n            );\n            const textBeforeOperator = source.slice(\n                lastLeftToken.range[1],\n                operatorToken.range[0]\n            );\n            const textAfterOperator = source.slice(\n                operatorToken.range[1],\n                firstRightToken.range[0]\n            );\n            const rightText = source.slice(\n                firstRightToken.range[0],\n                node.range[1]\n            );\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n            let prefix = \"\";\n            let suffix = \"\";\n\n            if (\n                tokenBefore &&\n                tokenBefore.range[1] === node.range[0] &&\n                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)\n            ) {\n                prefix = \" \";\n            }\n\n            if (\n                tokenAfter &&\n                node.range[1] === tokenAfter.range[0] &&\n                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)\n            ) {\n                suffix = \" \";\n            }\n\n            return (\n                prefix +\n                rightText +\n                textBeforeOperator +\n                OPERATOR_FLIP_MAP[operatorToken.value] +\n                textAfterOperator +\n                leftText +\n                suffix\n            );\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedNonLiteral)) &&\n                    !(\n                        expectedLiteral.type === \"Literal\" ||\n                        looksLikeLiteral(expectedLiteral)\n                    ) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(node.parent))\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"expected\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer =>\n                            fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}