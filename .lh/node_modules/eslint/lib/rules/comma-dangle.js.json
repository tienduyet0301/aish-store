{
    "sourceFile": "node_modules/eslint/lib/rules/comma-dangle.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892214654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n * @deprecated in ESLint v8.53.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"never\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n * @param {ASTNode} lastItem The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\n * @param {number} ecmaVersion The normalized ECMAScript version.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue, ecmaVersion) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n            functions: ecmaVersion < 2017 ? \"ignore\" : optionValue\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        deprecated: {\n            message: \"Formatting rules are being moved out of ESLint core.\",\n            url: \"https://eslint.org/blog/2023/10/deprecating-formatting-rules/\",\n            deprecatedSince: \"8.53.0\",\n            availableUntil: \"10.0.0\",\n            replacedBy: [\n                {\n                    message: \"ESLint Stylistic now maintains deprecated stylistic core rules.\",\n                    url: \"https://eslint.style/guide/migration\",\n                    plugin: {\n                        name: \"@stylistic/eslint-plugin-js\",\n                        url: \"https://eslint.style/packages/js\"\n                    },\n                    rule: {\n                        name: \"comma-dangle\",\n                        url: \"https://eslint.style/rules/js/comma-dangle\"\n                    }\n                }\n            ]\n        },\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow trailing commas\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/comma-dangle\"\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            definitions: {\n                value: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                },\n                valueWithIgnore: {\n                    enum: [\n                        \"always-multiline\",\n                        \"always\",\n                        \"ignore\",\n                        \"never\",\n                        \"only-multiline\"\n                    ]\n                }\n            },\n            type: \"array\",\n            items: [\n                {\n                    oneOf: [\n                        {\n                            $ref: \"#/definitions/value\"\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ]\n                }\n            ],\n            additionalItems: false\n        },\n\n        messages: {\n            unexpected: \"Unexpected trailing comma.\",\n            missing: \"Missing trailing comma.\"\n        }\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0], context.languageOptions.ecmaVersion);\n\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n\n            /**\n             * Returns the last element of an array\n             * @param {any[]} array The input array\n             * @returns {any} The last element\n             */\n            function last(array) {\n                return array.at(-1);\n            }\n\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         * @param {ASTNode} node The node to get.\n         * @param {ASTNode} lastItem The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         * @param {ASTNode} node A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc,\n                    messageId: \"unexpected\",\n                    *fix(fixer) {\n                        yield fixer.remove(trailingToken);\n\n                        /*\n                         * Extend the range of the fix to include surrounding tokens to ensure\n                         * that the element after which the comma is removed stays _last_.\n                         * This intentionally makes conflicts in fix ranges with rules that may be\n                         * adding or removing elements in the same autofix pass.\n                         * https://github.com/eslint/eslint/issues/15660\n                         */\n                        yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), \"\");\n                        yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: {\n                        start: trailingToken.loc.end,\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n                    },\n                    messageId: \"missing\",\n                    *fix(fixer) {\n                        yield fixer.insertTextAfter(trailingToken, \",\");\n\n                        /*\n                         * Extend the range of the fix to include surrounding tokens to ensure\n                         * that the element after which the comma is inserted stays _last_.\n                         * This intentionally makes conflicts in fix ranges with rules that may be\n                         * adding or removing elements in the same autofix pass.\n                         * https://github.com/eslint/eslint/issues/15660\n                         */\n                        yield fixer.insertTextBefore(trailingToken, \"\");\n                        yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         * @param {ASTNode} node A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore() {}\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n"
        }
    ]
}