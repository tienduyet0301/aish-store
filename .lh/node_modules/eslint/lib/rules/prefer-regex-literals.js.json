{
    "sourceFile": "node_modules/eslint/lib/rules/prefer-regex-literals.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892237306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"@eslint-community/eslint-utils\");\nconst { RegExpValidator, visitRegExpAST, RegExpParser } = require(\"@eslint-community/regexpp\");\nconst { canTokensBeAdjacent } = require(\"./utils/ast-utils\");\nconst { REGEXPP_LATEST_ECMA_VERSION } = require(\"./utils/regular-expressions\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the given node is a string literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a string literal.\n */\nfunction isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n\n/**\n * Determines whether the given node is a regex literal.\n * @param {ASTNode} node Node to check.\n * @returns {boolean} True if the node is a regex literal.\n */\nfunction isRegexLiteral(node) {\n    return node.type === \"Literal\" && Object.hasOwn(node, \"regex\");\n}\n\nconst validPrecedingTokens = new Set([\n    \"(\",\n    \";\",\n    \"[\",\n    \",\",\n    \"=\",\n    \"+\",\n    \"*\",\n    \"-\",\n    \"?\",\n    \"~\",\n    \"%\",\n    \"**\",\n    \"!\",\n    \"typeof\",\n    \"instanceof\",\n    \"&&\",\n    \"||\",\n    \"??\",\n    \"return\",\n    \"...\",\n    \"delete\",\n    \"void\",\n    \"in\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"<<\",\n    \">>\",\n    \">>>\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \":\",\n    \"{\",\n    \"=>\",\n    \"*=\",\n    \"<<=\",\n    \">>=\",\n    \">>>=\",\n    \"^=\",\n    \"|=\",\n    \"&=\",\n    \"??=\",\n    \"||=\",\n    \"&&=\",\n    \"**=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"%=\",\n    \"/\",\n    \"do\",\n    \"break\",\n    \"continue\",\n    \"debugger\",\n    \"case\",\n    \"throw\"\n]);\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            disallowRedundantWrapping: false\n        }],\n\n        docs: {\n            description: \"Disallow use of the `RegExp` constructor in favor of regular expression literals\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/prefer-regex-literals\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    disallowRedundantWrapping: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n            replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\n            replaceWithLiteralAndFlags: \"Replace with an equivalent regular expression literal with flags '{{ flags }}'.\",\n            replaceWithIntendedLiteralAndFlags: \"Replace with a regular expression literal with flags '{{ flags }}'.\",\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowRedundantWrapping }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether the given identifier node is a reference to a global variable.\n         * @param {ASTNode} node `Identifier` node to check.\n         * @returns {boolean} True if the identifier is a reference to a global variable.\n         */\n        function isGlobalReference(node) {\n            const scope = sourceCode.getScope(node);\n            const variable = findVariable(scope, node);\n\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n        }\n\n        /**\n         * Determines whether the given node is a String.raw`` tagged template expression\n         * with a static template literal.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is String.raw`` with a static template.\n         */\n        function isStringRawTaggedStaticTemplateLiteral(node) {\n            return node.type === \"TaggedTemplateExpression\" &&\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\n                astUtils.isStaticTemplateLiteral(node.quasi);\n        }\n\n        /**\n         * Gets the value of a string\n         * @param {ASTNode} node The node to get the string of.\n         * @returns {string|null} The value of the node.\n         */\n        function getStringValue(node) {\n            if (isStringLiteral(node)) {\n                return node.value;\n            }\n\n            if (astUtils.isStaticTemplateLiteral(node)) {\n                return node.quasis[0].value.cooked;\n            }\n\n            if (isStringRawTaggedStaticTemplateLiteral(node)) {\n                return node.quasi.quasis[0].value.raw;\n            }\n\n            return null;\n        }\n\n        /**\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node is a static string.\n         */\n        function isStaticString(node) {\n            return isStringLiteral(node) ||\n                astUtils.isStaticTemplateLiteral(node) ||\n                isStringRawTaggedStaticTemplateLiteral(node);\n        }\n\n        /**\n         * Determines whether the relevant arguments of the given are all static string literals.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if all arguments are static strings.\n         */\n        function hasOnlyStaticStringArguments(node) {\n            const args = node.arguments;\n\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} True if the node already contains a regex literal argument.\n         */\n        function isUnnecessarilyWrappedRegexLiteral(node) {\n            const args = node.arguments;\n\n            if (args.length === 1 && isRegexLiteral(args[0])) {\n                return true;\n            }\n\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns a ecmaVersion compatible for regexpp.\n         * @param {number} ecmaVersion The ecmaVersion to convert.\n         * @returns {import(\"@eslint-community/regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\n         */\n        function getRegexppEcmaVersion(ecmaVersion) {\n            if (ecmaVersion <= 5) {\n                return 5;\n            }\n            return Math.min(ecmaVersion, REGEXPP_LATEST_ECMA_VERSION);\n        }\n\n        const regexppEcmaVersion = getRegexppEcmaVersion(context.languageOptions.ecmaVersion);\n\n        /**\n         * Makes a character escaped or else returns null.\n         * @param {string} character The character to escape.\n         * @returns {string} The resulting escaped character.\n         */\n        function resolveEscapes(character) {\n            switch (character) {\n                case \"\\n\":\n                case \"\\\\\\n\":\n                    return \"\\\\n\";\n\n                case \"\\r\":\n                case \"\\\\\\r\":\n                    return \"\\\\r\";\n\n                case \"\\t\":\n                case \"\\\\\\t\":\n                    return \"\\\\t\";\n\n                case \"\\v\":\n                case \"\\\\\\v\":\n                    return \"\\\\v\";\n\n                case \"\\f\":\n                case \"\\\\\\f\":\n                    return \"\\\\f\";\n\n                case \"/\":\n                    return \"\\\\/\";\n\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Checks whether the given regex and flags are valid for the ecma version or not.\n         * @param {string} pattern The regex pattern to check.\n         * @param {string | undefined} flags The regex flags to check.\n         * @returns {boolean} True if the given regex pattern and flags are valid for the ecma version.\n         */\n        function isValidRegexForEcmaVersion(pattern, flags) {\n            const validator = new RegExpValidator({ ecmaVersion: regexppEcmaVersion });\n\n            try {\n                validator.validatePattern(pattern, 0, pattern.length, {\n                    unicode: flags ? flags.includes(\"u\") : false,\n                    unicodeSets: flags ? flags.includes(\"v\") : false\n                });\n                if (flags) {\n                    validator.validateFlags(flags);\n                }\n                return true;\n            } catch {\n                return false;\n            }\n        }\n\n        /**\n         * Checks whether two given regex flags contain the same flags or not.\n         * @param {string} flagsA The regex flags.\n         * @param {string} flagsB The regex flags.\n         * @returns {boolean} True if two regex flags contain same flags.\n         */\n        function areFlagsEqual(flagsA, flagsB) {\n            return [...flagsA].sort().join(\"\") === [...flagsB].sort().join(\"\");\n        }\n\n\n        /**\n         * Merges two regex flags.\n         * @param {string} flagsA The regex flags.\n         * @param {string} flagsB The regex flags.\n         * @returns {string} The merged regex flags.\n         */\n        function mergeRegexFlags(flagsA, flagsB) {\n            const flagsSet = new Set([\n                ...flagsA,\n                ...flagsB\n            ]);\n\n            return [...flagsSet].join(\"\");\n        }\n\n        /**\n         * Checks whether a give node can be fixed to the given regex pattern and flags.\n         * @param {ASTNode} node The node to check.\n         * @param {string} pattern The regex pattern to check.\n         * @param {string} flags The regex flags\n         * @returns {boolean} True if a node can be fixed to the given regex pattern and flags.\n         */\n        function canFixTo(node, pattern, flags) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return sourceCode.getCommentsInside(node).length === 0 &&\n                (!tokenBefore || validPrecedingTokens.has(tokenBefore.value)) &&\n                isValidRegexForEcmaVersion(pattern, flags);\n        }\n\n        /**\n         * Returns a safe output code considering the before and after tokens.\n         * @param {ASTNode} node The regex node.\n         * @param {string} newRegExpValue The new regex expression value.\n         * @returns {string} The output code.\n         */\n        function getSafeOutput(node, newRegExpValue) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            const tokenAfter = sourceCode.getTokenAfter(node);\n\n            return (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") +\n                newRegExpValue +\n            (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\");\n\n        }\n\n        return {\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const traceMap = {\n                    RegExp: {\n                        [CALL]: true,\n                        [CONSTRUCT]: true\n                    }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(refNode)) {\n                        const regexNode = refNode.arguments[0];\n\n                        if (refNode.arguments.length === 2) {\n                            const suggests = [];\n\n                            const argFlags = getStringValue(refNode.arguments[1]) || \"\";\n\n                            if (canFixTo(refNode, regexNode.regex.pattern, argFlags)) {\n                                suggests.push({\n                                    messageId: \"replaceWithLiteralAndFlags\",\n                                    pattern: regexNode.regex.pattern,\n                                    flags: argFlags\n                                });\n                            }\n\n                            const literalFlags = regexNode.regex.flags || \"\";\n                            const mergedFlags = mergeRegexFlags(literalFlags, argFlags);\n\n                            if (\n                                !areFlagsEqual(mergedFlags, argFlags) &&\n                                canFixTo(refNode, regexNode.regex.pattern, mergedFlags)\n                            ) {\n                                suggests.push({\n                                    messageId: \"replaceWithIntendedLiteralAndFlags\",\n                                    pattern: regexNode.regex.pattern,\n                                    flags: mergedFlags\n                                });\n                            }\n\n                            context.report({\n                                node: refNode,\n                                messageId: \"unexpectedRedundantRegExpWithFlags\",\n                                suggest: suggests.map(({ flags, pattern, messageId }) => ({\n                                    messageId,\n                                    data: {\n                                        flags\n                                    },\n                                    fix(fixer) {\n                                        return fixer.replaceText(refNode, getSafeOutput(refNode, `/${pattern}/${flags}`));\n                                    }\n                                }))\n                            });\n                        } else {\n                            const outputs = [];\n\n                            if (canFixTo(refNode, regexNode.regex.pattern, regexNode.regex.flags)) {\n                                outputs.push(sourceCode.getText(regexNode));\n                            }\n\n\n                            context.report({\n                                node: refNode,\n                                messageId: \"unexpectedRedundantRegExp\",\n                                suggest: outputs.map(output => ({\n                                    messageId: \"replaceWithLiteral\",\n                                    fix(fixer) {\n                                        return fixer.replaceText(\n                                            refNode,\n                                            getSafeOutput(refNode, output)\n                                        );\n                                    }\n                                }))\n                            });\n                        }\n                    } else if (hasOnlyStaticStringArguments(refNode)) {\n                        let regexContent = getStringValue(refNode.arguments[0]);\n                        let noFix = false;\n                        let flags;\n\n                        if (refNode.arguments[1]) {\n                            flags = getStringValue(refNode.arguments[1]);\n                        }\n\n                        if (!canFixTo(refNode, regexContent, flags)) {\n                            noFix = true;\n                        }\n\n                        if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\n                            noFix = true;\n                        }\n\n                        if (regexContent && !noFix) {\n                            let charIncrease = 0;\n\n                            const ast = new RegExpParser({ ecmaVersion: regexppEcmaVersion }).parsePattern(regexContent, 0, regexContent.length, {\n                                unicode: flags ? flags.includes(\"u\") : false,\n                                unicodeSets: flags ? flags.includes(\"v\") : false\n                            });\n\n                            visitRegExpAST(ast, {\n                                onCharacterEnter(characterNode) {\n                                    const escaped = resolveEscapes(characterNode.raw);\n\n                                    if (escaped) {\n                                        regexContent =\n                                            regexContent.slice(0, characterNode.start + charIncrease) +\n                                            escaped +\n                                            regexContent.slice(characterNode.end + charIncrease);\n\n                                        if (characterNode.raw.length === 1) {\n                                            charIncrease += 1;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n\n                        const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\n\n                        context.report({\n                            node: refNode,\n                            messageId: \"unexpectedRegExp\",\n                            suggest: noFix ? [] : [{\n                                messageId: \"replaceWithLiteral\",\n                                fix(fixer) {\n                                    return fixer.replaceText(refNode, getSafeOutput(refNode, newRegExpValue));\n                                }\n                            }]\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}