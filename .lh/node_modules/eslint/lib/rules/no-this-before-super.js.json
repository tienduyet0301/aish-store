{
    "sourceFile": "node_modules/eslint/lib/rules/no-this-before-super.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892231670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/*\n * Information for each code path segment.\n * - superCalled:  The flag which shows `super()` called in all code paths.\n * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n */\n/**\n *\n */\nclass SegmentInfo {\n\n    /**\n     * Indicates whether `super()` is called in all code paths.\n     * @type {boolean}\n     */\n    superCalled = false;\n\n    /**\n     * The array of invalid ThisExpression and Super nodes.\n     * @type {ASTNode[]}\n     */\n    invalidNodes = [];\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow `this`/`super` before calling `super()` in constructors\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-this-before-super\"\n        },\n\n        schema: [],\n\n        messages: {\n            noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\n        }\n    },\n\n    create(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        let funcInfo = null;\n\n        /** @type {Record<string, SegmentInfo>} */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id]?.superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Determines if every segment in a set has been called.\n         * @param {Set<CodePathSegment>} segments The segments to search.\n         * @returns {boolean} True if every segment has been called; false otherwise.\n         */\n        function isEverySegmentCalled(segments) {\n            for (const segment of segments) {\n                if (!isCalled(segment)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass() &&\n                !isEverySegmentCalled(funcInfo.currentSegments)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            const segments = funcInfo.currentSegments;\n\n            for (const segment of segments) {\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            const segments = funcInfo.currentSegments;\n\n            for (const segment of segments) {\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath A code path which was started.\n             * @param {ASTNode} node The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath,\n                        currentSegments: new Set()\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath,\n                        currentSegments: new Set()\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this traverses all segments of this code path then reports every\n             * invalid node.\n             * @param {CodePath} codePath A code path which was ended.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath) {\n                const isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                /**\n                 * A collection of nodes to avoid duplicate reports.\n                 * @type {Set<ASTNode>}\n                 */\n                const reported = new Set();\n\n                codePath.traverseSegments((segment, controller) => {\n                    const info = segInfoMap[segment.id];\n                    const invalidNodes = info.invalidNodes\n                        .filter(\n\n                            /*\n                             * Avoid duplicate reports.\n                             * When there is a `finally`, invalidNodes may contain already reported node.\n                             */\n                            node => !reported.has(node)\n                        );\n\n                    for (const invalidNode of invalidNodes) {\n                        reported.add(invalidNode);\n\n                        context.report({\n                            messageId: \"noBeforeSuper\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            onUnreachableCodePathSegmentStart(segment) {\n                funcInfo.currentSegments.add(segment);\n            },\n\n            onUnreachableCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            onCodePathSegmentEnd(segment) {\n                funcInfo.currentSegments.delete(segment);\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass()) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id] ?? new SegmentInfo();\n\n                        if (info.superCalled) {\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                        }\n\n                        segInfoMap[segment.id] = info;\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            ThisExpression(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            Super(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"
        }
    ]
}