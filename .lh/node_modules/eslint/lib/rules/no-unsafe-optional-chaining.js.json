{
    "sourceFile": "node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to disallow unsafe optional chaining\n * @author Yeon JuAn\n */\n\n\"use strict\";\n\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\n\n/**\n * Checks whether a node is a destructuring pattern or not\n * @param {ASTNode} node node to check\n * @returns {boolean} `true` if a node is a destructuring pattern, otherwise `false`\n */\nfunction isDestructuringPattern(node) {\n    return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        defaultOptions: [{\n            disallowArithmeticOperators: false\n        }],\n\n        docs: {\n            description: \"Disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\n            recommended: true,\n            url: \"https://eslint.org/docs/latest/rules/no-unsafe-optional-chaining\"\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                disallowArithmeticOperators: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: null,\n        messages: {\n            unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\n            unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\n        }\n    },\n\n    create(context) {\n        const [{ disallowArithmeticOperators }] = context.options;\n\n        /**\n         * Reports unsafe usage of optional chaining\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function reportUnsafeUsage(node) {\n            context.report({\n                messageId: \"unsafeOptionalChain\",\n                node\n            });\n        }\n\n        /**\n         * Reports unsafe arithmetic operation on optional chaining\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function reportUnsafeArithmetic(node) {\n            context.report({\n                messageId: \"unsafeArithmetic\",\n                node\n            });\n        }\n\n        /**\n         * Checks and reports if a node can short-circuit with `undefined` by optional chaining.\n         * @param {ASTNode} [node] node to check\n         * @param {Function} reportFunc report function\n         * @returns {void}\n         */\n        function checkUndefinedShortCircuit(node, reportFunc) {\n            if (!node) {\n                return;\n            }\n            switch (node.type) {\n                case \"LogicalExpression\":\n                    if (node.operator === \"||\" || node.operator === \"??\") {\n                        checkUndefinedShortCircuit(node.right, reportFunc);\n                    } else if (node.operator === \"&&\") {\n                        checkUndefinedShortCircuit(node.left, reportFunc);\n                        checkUndefinedShortCircuit(node.right, reportFunc);\n                    }\n                    break;\n                case \"SequenceExpression\":\n                    checkUndefinedShortCircuit(\n                        node.expressions.at(-1),\n                        reportFunc\n                    );\n                    break;\n                case \"ConditionalExpression\":\n                    checkUndefinedShortCircuit(node.consequent, reportFunc);\n                    checkUndefinedShortCircuit(node.alternate, reportFunc);\n                    break;\n                case \"AwaitExpression\":\n                    checkUndefinedShortCircuit(node.argument, reportFunc);\n                    break;\n                case \"ChainExpression\":\n                    reportFunc(node);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /**\n         * Checks unsafe usage of optional chaining\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkUnsafeUsage(node) {\n            checkUndefinedShortCircuit(node, reportUnsafeUsage);\n        }\n\n        /**\n         * Checks unsafe arithmetic operations on optional chaining\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkUnsafeArithmetic(node) {\n            checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\n        }\n\n        return {\n            \"AssignmentExpression, AssignmentPattern\"(node) {\n                if (isDestructuringPattern(node.left)) {\n                    checkUnsafeUsage(node.right);\n                }\n            },\n            \"ClassDeclaration, ClassExpression\"(node) {\n                checkUnsafeUsage(node.superClass);\n            },\n            CallExpression(node) {\n                if (!node.optional) {\n                    checkUnsafeUsage(node.callee);\n                }\n            },\n            NewExpression(node) {\n                checkUnsafeUsage(node.callee);\n            },\n            VariableDeclarator(node) {\n                if (isDestructuringPattern(node.id)) {\n                    checkUnsafeUsage(node.init);\n                }\n            },\n            MemberExpression(node) {\n                if (!node.optional) {\n                    checkUnsafeUsage(node.object);\n                }\n            },\n            TaggedTemplateExpression(node) {\n                checkUnsafeUsage(node.tag);\n            },\n            ForOfStatement(node) {\n                checkUnsafeUsage(node.right);\n            },\n            SpreadElement(node) {\n                if (node.parent && node.parent.type !== \"ObjectExpression\") {\n                    checkUnsafeUsage(node.argument);\n                }\n            },\n            BinaryExpression(node) {\n                if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\n                    checkUnsafeUsage(node.right);\n                }\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.right);\n                    checkUnsafeArithmetic(node.left);\n                }\n            },\n            WithStatement(node) {\n                checkUnsafeUsage(node.object);\n            },\n            UnaryExpression(node) {\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.argument);\n                }\n            },\n            AssignmentExpression(node) {\n                if (\n                    disallowArithmeticOperators &&\n                    UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)\n                ) {\n                    checkUnsafeArithmetic(node.right);\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}