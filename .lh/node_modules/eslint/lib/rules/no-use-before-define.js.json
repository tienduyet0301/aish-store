{
    "sourceFile": "node_modules/eslint/lib/rules/no-use-before-define.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    if (typeof options === \"object\" && options !== null) {\n        return options;\n    }\n\n    const functions =\n        typeof options === \"string\"\n            ? options !== \"nofunc\"\n            : true;\n\n    return { functions, classes: true, variables: true, allowNamedExports: false };\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {ASTNode} node `ClassBody` node to check static initializers.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of a class static initializer.\n */\nfunction isInClassStaticInitializerRange(node, location) {\n    return node.body.some(classMember => (\n        (\n            classMember.type === \"StaticBlock\" &&\n            isInRange(classMember, location)\n        ) ||\n        (\n            classMember.type === \"PropertyDefinition\" &&\n            classMember.static &&\n            classMember.value &&\n            isInRange(classMember.value, location)\n        )\n    ));\n}\n\n/**\n * Checks whether a given scope is the scope of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {eslint-scope.Scope} scope A scope to check.\n * @returns {boolean} `true` if the scope is a class static initializer scope.\n */\nfunction isClassStaticInitializerScope(scope) {\n    if (scope.type === \"class-static-block\") {\n        return true;\n    }\n\n    if (scope.type === \"class-field-initializer\") {\n\n        // `scope.block` is PropertyDefinition#value node\n        const propertyDefinition = scope.block.parent;\n\n        return propertyDefinition.static;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether a given reference is evaluated in an execution context\n * that isn't the one where the variable it refers to is defined.\n * Execution contexts are:\n * - top-level\n * - functions\n * - class field initializers (implicit functions)\n * - class static blocks (implicit functions)\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\n * and therefore we'll consider them as a part of the parent execution context.\n * Example:\n *\n *   const x = 1;\n *\n *   x; // returns `false`\n *   () => x; // returns `true`\n *\n *   class C {\n *       field = x; // returns `true`\n *       static field = x; // returns `false`\n *\n *       method() {\n *           x; // returns `true`\n *       }\n *\n *       static method() {\n *           x; // returns `true`\n *       }\n *\n *       static {\n *           x; // returns `false`\n *       }\n *   }\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is from a separate execution context.\n */\nfunction isFromSeparateExecutionContext(reference) {\n    const variable = reference.resolved;\n    let scope = reference.from;\n\n    // Scope#variableScope represents execution context\n    while (variable.scope.variableScope !== scope.variableScope) {\n        if (isClassStaticInitializerScope(scope.variableScope)) {\n            scope = scope.variableScope.upper;\n        } else {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *     var C = class { [C]; };\n *     var C = class { static foo = C; };\n *     var C = class { static { foo = C; } };\n *     class C extends C {}\n *     class C extends (class { static foo = C; }) {}\n *     class C { [C]; }\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\n */\nfunction isEvaluatedDuringInitialization(reference) {\n    if (isFromSeparateExecutionContext(reference)) {\n\n        /*\n         * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\n         * For example, `const x = () => x;` is valid.\n         */\n        return false;\n    }\n\n    const location = reference.identifier.range[1];\n    const definition = reference.resolved.defs[0];\n\n    if (definition.type === \"ClassName\") {\n\n        // `ClassDeclaration` or `ClassExpression`\n        const classDefinition = definition.node;\n\n        return (\n            isInRange(classDefinition, location) &&\n\n            /*\n             * Class binding is initialized before running static initializers.\n             * For example, `class C { static foo = C; static { bar = C; } }` is valid.\n             */\n            !isInClassStaticInitializerRange(classDefinition.body, location)\n        );\n    }\n\n    let node = definition.name.parent;\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow the use of variables before they are defined\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" },\n                            allowNamedExports: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        defaultOptions: [{\n            classes: true,\n            functions: true,\n            variables: true,\n            allowNamedExports: false\n        }],\n\n        messages: {\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Determines whether a given reference should be checked.\n         *\n         * Returns `false` if the reference is:\n         * - initialization's (e.g., `let a = 1`).\n         * - referring to an undefined variable (i.e., if it's an unresolved reference).\n         * - referring to a variable that is defined, but not in the given source code\n         *   (e.g., global environment variable or `arguments` in functions).\n         * - allowed by options.\n         * @param {eslint-scope.Reference} reference The reference\n         * @returns {boolean} `true` if the reference should be checked\n         */\n        function shouldCheck(reference) {\n            if (reference.init) {\n                return false;\n            }\n\n            const { identifier } = reference;\n\n            if (\n                options.allowNamedExports &&\n                identifier.parent.type === \"ExportSpecifier\" &&\n                identifier.parent.local === identifier\n            ) {\n                return false;\n            }\n\n            const variable = reference.resolved;\n\n            if (!variable || variable.defs.length === 0) {\n                return false;\n            }\n\n            const definitionType = variable.defs[0].type;\n\n            if (!options.functions && definitionType === \"FunctionName\") {\n                return false;\n            }\n\n            if (\n                (\n                    !options.variables && definitionType === \"Variable\" ||\n                    !options.classes && definitionType === \"ClassName\"\n                ) &&\n\n                // don't skip checking the reference if it's in the same execution context, because of TDZ\n                isFromSeparateExecutionContext(reference)\n            ) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Finds and validates all references in a given scope and its child scopes.\n         * @param {eslint-scope.Scope} scope The scope object.\n         * @returns {void}\n         */\n        function checkReferencesInScope(scope) {\n            scope.references.filter(shouldCheck).forEach(reference => {\n                const variable = reference.resolved;\n                const definitionIdentifier = variable.defs[0].name;\n\n                if (\n                    reference.identifier.range[1] < definitionIdentifier.range[1] ||\n                    isEvaluatedDuringInitialization(reference)\n                ) {\n                    context.report({\n                        node: reference.identifier,\n                        messageId: \"usedBeforeDefined\",\n                        data: reference.identifier\n                    });\n                }\n            });\n\n            scope.childScopes.forEach(checkReferencesInScope);\n        }\n\n        return {\n            Program(node) {\n                checkReferencesInScope(sourceCode.getScope(node));\n            }\n        };\n    }\n};\n"
        }
    ]
}