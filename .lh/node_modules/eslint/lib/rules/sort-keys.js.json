{
    "sourceFile": "node_modules/eslint/lib/rules/sort-keys.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n    naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n * @param {ASTNode} node The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n    const staticName = astUtils.getStaticPropertyName(node);\n\n    if (staticName !== null) {\n        return staticName;\n    }\n\n    return node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natural.\n * @private\n */\nconst isValidOrders = {\n    asc(a, b) {\n        return a <= b;\n    },\n    ascI(a, b) {\n        return a.toLowerCase() <= b.toLowerCase();\n    },\n    ascN(a, b) {\n        return naturalCompare(a, b) <= 0;\n    },\n    ascIN(a, b) {\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n    },\n    desc(a, b) {\n        return isValidOrders.asc(b, a);\n    },\n    descI(a, b) {\n        return isValidOrders.ascI(b, a);\n    },\n    descN(a, b) {\n        return isValidOrders.ascN(b, a);\n    },\n    descIN(a, b) {\n        return isValidOrders.ascIN(b, a);\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [\"asc\", {\n            allowLineSeparatedGroups: false,\n            caseSensitive: true,\n            ignoreComputedKeys: false,\n            minKeys: 2,\n            natural: false\n        }],\n\n        docs: {\n            description: \"Require object keys to be sorted\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/sort-keys\"\n        },\n\n        schema: [\n            {\n                enum: [\"asc\", \"desc\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    caseSensitive: {\n                        type: \"boolean\"\n                    },\n                    natural: {\n                        type: \"boolean\"\n                    },\n                    minKeys: {\n                        type: \"integer\",\n                        minimum: 2\n                    },\n                    allowLineSeparatedGroups: {\n                        type: \"boolean\"\n                    },\n                    ignoreComputedKeys: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\n        }\n    },\n\n    create(context) {\n        const [order, { caseSensitive, natural, minKeys, allowLineSeparatedGroups, ignoreComputedKeys }] = context.options;\n        const insensitive = !caseSensitive;\n        const isValidOrder = isValidOrders[\n            order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")\n        ];\n\n        // The stack to save the previous property's name for each object literals.\n        let stack = null;\n        const sourceCode = context.sourceCode;\n\n        return {\n            ObjectExpression(node) {\n                stack = {\n                    upper: stack,\n                    prevNode: null,\n                    prevBlankLine: false,\n                    prevName: null,\n                    numKeys: node.properties.length\n                };\n            },\n\n            \"ObjectExpression:exit\"() {\n                stack = stack.upper;\n            },\n\n            SpreadElement(node) {\n                if (node.parent.type === \"ObjectExpression\") {\n                    stack.prevName = null;\n                }\n            },\n\n            Property(node) {\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                if (ignoreComputedKeys && node.computed) {\n                    stack.prevName = null; // reset sort\n                    return;\n                }\n\n                const prevName = stack.prevName;\n                const numKeys = stack.numKeys;\n                const thisName = getPropertyName(node);\n\n                // Get tokens between current node and previous node\n                const tokens = stack.prevNode && sourceCode\n                    .getTokensBetween(stack.prevNode, node, { includeComments: true });\n\n                let isBlankLineBetweenNodes = stack.prevBlankLine;\n\n                if (tokens) {\n\n                    // check blank line between tokens\n                    tokens.forEach((token, index) => {\n                        const previousToken = tokens[index - 1];\n\n                        if (previousToken && (token.loc.start.line - previousToken.loc.end.line > 1)) {\n                            isBlankLineBetweenNodes = true;\n                        }\n                    });\n\n                    // check blank line between the current node and the last token\n                    if (!isBlankLineBetweenNodes && (node.loc.start.line - tokens.at(-1).loc.end.line > 1)) {\n                        isBlankLineBetweenNodes = true;\n                    }\n\n                    // check blank line between the first token and the previous node\n                    if (!isBlankLineBetweenNodes && (tokens[0].loc.start.line - stack.prevNode.loc.end.line > 1)) {\n                        isBlankLineBetweenNodes = true;\n                    }\n                }\n\n                stack.prevNode = node;\n\n                if (thisName !== null) {\n                    stack.prevName = thisName;\n                }\n\n                if (allowLineSeparatedGroups && isBlankLineBetweenNodes) {\n                    stack.prevBlankLine = thisName === null;\n                    return;\n                }\n\n                if (prevName === null || thisName === null || numKeys < minKeys) {\n                    return;\n                }\n\n                if (!isValidOrder(prevName, thisName)) {\n                    context.report({\n                        node,\n                        loc: node.key.loc,\n                        messageId: \"sortKeys\",\n                        data: {\n                            thisName,\n                            prevName,\n                            order,\n                            insensitive: insensitive ? \"insensitive \" : \"\",\n                            natural: natural ? \"natural \" : \"\"\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}