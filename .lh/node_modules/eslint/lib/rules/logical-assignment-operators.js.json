{
    "sourceFile": "node_modules/eslint/lib/rules/logical-assignment-operators.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892217620,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to replace assignment expressions with logical operator assignment\n * @author Daniel Martens\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst baseTypes = new Set([\"Identifier\", \"Super\", \"ThisExpression\"]);\n\n/**\n * Returns true iff either \"undefined\" or a void expression (eg. \"void 0\")\n * @param {ASTNode} expression Expression to check\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff \"undefined\" or \"void ...\"\n */\nfunction isUndefined(expression, scope) {\n    if (expression.type === \"Identifier\" && expression.name === \"undefined\") {\n        return astUtils.isReferenceToGlobalVariable(scope, expression);\n    }\n\n    return expression.type === \"UnaryExpression\" &&\n           expression.operator === \"void\" &&\n           expression.argument.type === \"Literal\" &&\n           expression.argument.value === 0;\n}\n\n/**\n * Returns true iff the reference is either an identifier or member expression\n * @param {ASTNode} expression Expression to check\n * @returns {boolean} True for identifiers and member expressions\n */\nfunction isReference(expression) {\n    return (expression.type === \"Identifier\" && expression.name !== \"undefined\") ||\n           expression.type === \"MemberExpression\";\n}\n\n/**\n * Returns true iff the expression checks for nullish with loose equals.\n * Examples: value == null, value == void 0\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff implicit nullish comparison\n */\nfunction isImplicitNullishComparison(expression, scope) {\n    if (expression.type !== \"BinaryExpression\" || expression.operator !== \"==\") {\n        return false;\n    }\n\n    const reference = isReference(expression.left) ? \"left\" : \"right\";\n    const nullish = reference === \"left\" ? \"right\" : \"left\";\n\n    return isReference(expression[reference]) &&\n           (astUtils.isNullLiteral(expression[nullish]) || isUndefined(expression[nullish], scope));\n}\n\n/**\n * Condition with two equal comparisons.\n * @param {ASTNode} expression Condition\n * @returns {boolean} True iff matches ? === ? || ? === ?\n */\nfunction isDoubleComparison(expression) {\n    return expression.type === \"LogicalExpression\" &&\n           expression.operator === \"||\" &&\n           expression.left.type === \"BinaryExpression\" &&\n           expression.left.operator === \"===\" &&\n           expression.right.type === \"BinaryExpression\" &&\n           expression.right.operator === \"===\";\n}\n\n/**\n * Returns true iff the expression checks for undefined and null.\n * Example: value === null || value === undefined\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} True iff explicit nullish comparison\n */\nfunction isExplicitNullishComparison(expression, scope) {\n    if (!isDoubleComparison(expression)) {\n        return false;\n    }\n    const leftReference = isReference(expression.left.left) ? \"left\" : \"right\";\n    const leftNullish = leftReference === \"left\" ? \"right\" : \"left\";\n    const rightReference = isReference(expression.right.left) ? \"left\" : \"right\";\n    const rightNullish = rightReference === \"left\" ? \"right\" : \"left\";\n\n    return astUtils.isSameReference(expression.left[leftReference], expression.right[rightReference]) &&\n           ((astUtils.isNullLiteral(expression.left[leftNullish]) && isUndefined(expression.right[rightNullish], scope)) ||\n           (isUndefined(expression.left[leftNullish], scope) && astUtils.isNullLiteral(expression.right[rightNullish])));\n}\n\n/**\n * Returns true for Boolean(arg) calls\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {boolean} Whether the expression is a boolean cast\n */\nfunction isBooleanCast(expression, scope) {\n    return expression.type === \"CallExpression\" &&\n           expression.callee.name === \"Boolean\" &&\n           expression.arguments.length === 1 &&\n           astUtils.isReferenceToGlobalVariable(scope, expression.callee);\n}\n\n/**\n * Returns true for:\n * truthiness checks:  value, Boolean(value), !!value\n * falsiness checks:   !value, !Boolean(value)\n * nullish checks:     value == null, value === undefined || value === null\n * @param {ASTNode} expression Test condition\n * @param {import('eslint-scope').Scope} scope Scope of the expression\n * @returns {?{ reference: ASTNode, operator: '??'|'||'|'&&'}} Null if not a known existence\n */\nfunction getExistence(expression, scope) {\n    const isNegated = expression.type === \"UnaryExpression\" && expression.operator === \"!\";\n    const base = isNegated ? expression.argument : expression;\n\n    switch (true) {\n        case isReference(base):\n            return { reference: base, operator: isNegated ? \"||\" : \"&&\" };\n        case base.type === \"UnaryExpression\" && base.operator === \"!\" && isReference(base.argument):\n            return { reference: base.argument, operator: \"&&\" };\n        case isBooleanCast(base, scope) && isReference(base.arguments[0]):\n            return { reference: base.arguments[0], operator: isNegated ? \"||\" : \"&&\" };\n        case isImplicitNullishComparison(expression, scope):\n            return { reference: isReference(expression.left) ? expression.left : expression.right, operator: \"??\" };\n        case isExplicitNullishComparison(expression, scope):\n            return { reference: isReference(expression.left.left) ? expression.left.left : expression.left.right, operator: \"??\" };\n        default: return null;\n    }\n}\n\n/**\n * Returns true iff the node is inside a with block\n * @param {ASTNode} node Node to check\n * @returns {boolean} True iff passed node is inside a with block\n */\nfunction isInsideWithBlock(node) {\n    if (node.type === \"Program\") {\n        return false;\n    }\n\n    return node.parent.type === \"WithStatement\" && node.parent.body === node ? true : isInsideWithBlock(node.parent);\n}\n\n/**\n * Gets the leftmost operand of a consecutive logical expression.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {LogicalExpression} node LogicalExpression\n * @returns {Expression} Leftmost operand\n */\nfunction getLeftmostOperand(sourceCode, node) {\n    let left = node.left;\n\n    while (left.type === \"LogicalExpression\" && left.operator === node.operator) {\n\n        if (astUtils.isParenthesised(sourceCode, left)) {\n\n            /*\n             * It should have associativity,\n             * but ignore it if use parentheses to make the evaluation order clear.\n             */\n            return left;\n        }\n        left = left.left;\n    }\n    return left;\n\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require or disallow logical assignment operator shorthand\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/logical-assignment-operators\"\n        },\n\n        schema: {\n            type: \"array\",\n            oneOf: [{\n                items: [\n                    { const: \"always\" },\n                    {\n                        type: \"object\",\n                        properties: {\n                            enforceForIfStatements: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ],\n                minItems: 0, // 0 for allowing passing no options\n                maxItems: 2\n            }, {\n                items: [{ const: \"never\" }],\n                minItems: 1,\n                maxItems: 1\n            }]\n        },\n        fixable: \"code\",\n        hasSuggestions: true,\n        messages: {\n            assignment: \"Assignment (=) can be replaced with operator assignment ({{operator}}).\",\n            useLogicalOperator: \"Convert this assignment to use the operator {{ operator }}.\",\n            logical: \"Logical expression can be replaced with an assignment ({{ operator }}).\",\n            convertLogical: \"Replace this logical expression with an assignment with the operator {{ operator }}.\",\n            if: \"'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.\",\n            convertIf: \"Replace this 'if' statement with a logical assignment with operator {{ operator }}.\",\n            unexpected: \"Unexpected logical operator assignment ({{operator}}) shorthand.\",\n            separate: \"Separate the logical assignment into an assignment with a logical operator.\"\n        }\n    },\n\n    create(context) {\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n        const checkIf = mode === \"always\" && context.options.length > 1 && context.options[1].enforceForIfStatements;\n        const sourceCode = context.sourceCode;\n        const isStrict = sourceCode.getScope(sourceCode.ast).isStrict;\n\n        /**\n         * Returns false if the access could be a getter\n         * @param {ASTNode} node Assignment expression\n         * @returns {boolean} True iff the fix is safe\n         */\n        function cannotBeGetter(node) {\n            return node.type === \"Identifier\" &&\n                   (isStrict || !isInsideWithBlock(node));\n        }\n\n        /**\n         * Check whether only a single property is accessed\n         * @param {ASTNode} node reference\n         * @returns {boolean} True iff a single property is accessed\n         */\n        function accessesSingleProperty(node) {\n            if (!isStrict && isInsideWithBlock(node)) {\n                return node.type === \"Identifier\";\n            }\n\n            return node.type === \"MemberExpression\" &&\n                   baseTypes.has(node.object.type) &&\n                   (!node.computed || (node.property.type !== \"MemberExpression\" && node.property.type !== \"ChainExpression\"));\n        }\n\n        /**\n         * Adds a fixer or suggestion whether on the fix is safe.\n         * @param {{ messageId: string, node: ASTNode }} descriptor Report descriptor without fix or suggest\n         * @param {{ messageId: string, fix: Function }} suggestion Adds the fix or the whole suggestion as only element in \"suggest\" to suggestion\n         * @param {boolean} shouldBeFixed Fix iff the condition is true\n         * @returns {Object} Descriptor with either an added fix or suggestion\n         */\n        function createConditionalFixer(descriptor, suggestion, shouldBeFixed) {\n            if (shouldBeFixed) {\n                return {\n                    ...descriptor,\n                    fix: suggestion.fix\n                };\n            }\n\n            return {\n                ...descriptor,\n                suggest: [suggestion]\n            };\n        }\n\n\n        /**\n         * Returns the operator token for assignments and binary expressions\n         * @param {ASTNode} node AssignmentExpression or BinaryExpression\n         * @returns {import('eslint').AST.Token} Operator token between the left and right expression\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        if (mode === \"never\") {\n            return {\n\n                // foo ||= bar\n                \"AssignmentExpression\"(assignment) {\n                    if (!astUtils.isLogicalAssignmentOperator(assignment.operator)) {\n                        return;\n                    }\n\n                    const descriptor = {\n                        messageId: \"unexpected\",\n                        node: assignment,\n                        data: { operator: assignment.operator }\n                    };\n                    const suggestion = {\n                        messageId: \"separate\",\n                        *fix(ruleFixer) {\n                            if (sourceCode.getCommentsInside(assignment).length > 0) {\n                                return;\n                            }\n\n                            const operatorToken = getOperatorToken(assignment);\n\n                            // -> foo = bar\n                            yield ruleFixer.replaceText(operatorToken, \"=\");\n\n                            const assignmentText = sourceCode.getText(assignment.left);\n                            const operator = assignment.operator.slice(0, -1);\n\n                            // -> foo = foo || bar\n                            yield ruleFixer.insertTextAfter(operatorToken, ` ${assignmentText} ${operator}`);\n\n                            const precedence = astUtils.getPrecedence(assignment.right) <= astUtils.getPrecedence({ type: \"LogicalExpression\", operator });\n\n                            // ?? and || / && cannot be mixed but have same precedence\n                            const mixed = assignment.operator === \"??=\" && astUtils.isLogicalExpression(assignment.right);\n\n                            if (!astUtils.isParenthesised(sourceCode, assignment.right) && (precedence || mixed)) {\n\n                                // -> foo = foo || (bar)\n                                yield ruleFixer.insertTextBefore(assignment.right, \"(\");\n                                yield ruleFixer.insertTextAfter(assignment.right, \")\");\n                            }\n                        }\n                    };\n\n                    context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));\n                }\n            };\n        }\n\n        return {\n\n            // foo = foo || bar\n            \"AssignmentExpression[operator='='][right.type='LogicalExpression']\"(assignment) {\n                const leftOperand = getLeftmostOperand(sourceCode, assignment.right);\n\n                if (!astUtils.isSameReference(assignment.left, leftOperand)\n                ) {\n                    return;\n                }\n\n                const descriptor = {\n                    messageId: \"assignment\",\n                    node: assignment,\n                    data: { operator: `${assignment.right.operator}=` }\n                };\n                const suggestion = {\n                    messageId: \"useLogicalOperator\",\n                    data: { operator: `${assignment.right.operator}=` },\n                    *fix(ruleFixer) {\n                        if (sourceCode.getCommentsInside(assignment).length > 0) {\n                            return;\n                        }\n\n                        // No need for parenthesis around the assignment based on precedence as the precedence stays the same even with changed operator\n                        const assignmentOperatorToken = getOperatorToken(assignment);\n\n                        // -> foo ||= foo || bar\n                        yield ruleFixer.insertTextBefore(assignmentOperatorToken, assignment.right.operator);\n\n                        // -> foo ||= bar\n                        const logicalOperatorToken = getOperatorToken(leftOperand.parent);\n                        const firstRightOperandToken = sourceCode.getTokenAfter(logicalOperatorToken);\n\n                        yield ruleFixer.removeRange([leftOperand.parent.range[0], firstRightOperandToken.range[0]]);\n                    }\n                };\n\n                context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));\n            },\n\n            // foo || (foo = bar)\n            'LogicalExpression[right.type=\"AssignmentExpression\"][right.operator=\"=\"]'(logical) {\n\n                // Right side has to be parenthesized, otherwise would be parsed as (foo || foo) = bar which is illegal\n                if (isReference(logical.left) && astUtils.isSameReference(logical.left, logical.right.left)) {\n                    const descriptor = {\n                        messageId: \"logical\",\n                        node: logical,\n                        data: { operator: `${logical.operator}=` }\n                    };\n                    const suggestion = {\n                        messageId: \"convertLogical\",\n                        data: { operator: `${logical.operator}=` },\n                        *fix(ruleFixer) {\n                            if (sourceCode.getCommentsInside(logical).length > 0) {\n                                return;\n                            }\n\n                            const parentPrecedence = astUtils.getPrecedence(logical.parent);\n                            const requiresOuterParenthesis = logical.parent.type !== \"ExpressionStatement\" && (\n                                parentPrecedence === -1 ||\n                                astUtils.getPrecedence({ type: \"AssignmentExpression\" }) < parentPrecedence\n                            );\n\n                            if (!astUtils.isParenthesised(sourceCode, logical) && requiresOuterParenthesis) {\n                                yield ruleFixer.insertTextBefore(logical, \"(\");\n                                yield ruleFixer.insertTextAfter(logical, \")\");\n                            }\n\n                            // Also removes all opening parenthesis\n                            yield ruleFixer.removeRange([logical.range[0], logical.right.range[0]]); // -> foo = bar)\n\n                            // Also removes all ending parenthesis\n                            yield ruleFixer.removeRange([logical.right.range[1], logical.range[1]]); // -> foo = bar\n\n                            const operatorToken = getOperatorToken(logical.right);\n\n                            yield ruleFixer.insertTextBefore(operatorToken, logical.operator); // -> foo ||= bar\n                        }\n                    };\n                    const fix = cannotBeGetter(logical.left) || accessesSingleProperty(logical.left);\n\n                    context.report(createConditionalFixer(descriptor, suggestion, fix));\n                }\n            },\n\n            // if (foo) foo = bar\n            \"IfStatement[alternate=null]\"(ifNode) {\n                if (!checkIf) {\n                    return;\n                }\n\n                const hasBody = ifNode.consequent.type === \"BlockStatement\";\n\n                if (hasBody && ifNode.consequent.body.length !== 1) {\n                    return;\n                }\n\n                const body = hasBody ? ifNode.consequent.body[0] : ifNode.consequent;\n                const scope = sourceCode.getScope(ifNode);\n                const existence = getExistence(ifNode.test, scope);\n\n                if (\n                    body.type === \"ExpressionStatement\" &&\n                    body.expression.type === \"AssignmentExpression\" &&\n                    body.expression.operator === \"=\" &&\n                    existence !== null &&\n                    astUtils.isSameReference(existence.reference, body.expression.left)\n                ) {\n                    const descriptor = {\n                        messageId: \"if\",\n                        node: ifNode,\n                        data: { operator: `${existence.operator}=` }\n                    };\n                    const suggestion = {\n                        messageId: \"convertIf\",\n                        data: { operator: `${existence.operator}=` },\n                        *fix(ruleFixer) {\n                            if (sourceCode.getCommentsInside(ifNode).length > 0) {\n                                return;\n                            }\n\n                            const firstBodyToken = sourceCode.getFirstToken(body);\n                            const prevToken = sourceCode.getTokenBefore(ifNode);\n\n                            if (\n                                prevToken !== null &&\n                                prevToken.value !== \";\" &&\n                                prevToken.value !== \"{\" &&\n                                firstBodyToken.type !== \"Identifier\" &&\n                                firstBodyToken.type !== \"Keyword\"\n                            ) {\n\n                                // Do not fix if the fixed statement could be part of the previous statement (eg. fn() if (a == null) (a) = b --> fn()(a) ??= b)\n                                return;\n                            }\n\n\n                            const operatorToken = getOperatorToken(body.expression);\n\n                            yield ruleFixer.insertTextBefore(operatorToken, existence.operator); // -> if (foo) foo ||= bar\n\n                            yield ruleFixer.removeRange([ifNode.range[0], body.range[0]]); // -> foo ||= bar\n\n                            yield ruleFixer.removeRange([body.range[1], ifNode.range[1]]); // -> foo ||= bar, only present if \"if\" had a body\n\n                            const nextToken = sourceCode.getTokenAfter(body.expression);\n\n                            if (hasBody && (nextToken !== null && nextToken.value !== \";\")) {\n                                yield ruleFixer.insertTextAfter(ifNode, \";\");\n                            }\n                        }\n                    };\n                    const shouldBeFixed = cannotBeGetter(existence.reference) ||\n                                          (ifNode.test.type !== \"LogicalExpression\" && accessesSingleProperty(existence.reference));\n\n                    context.report(createConditionalFixer(descriptor, suggestion, shouldBeFixed));\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}