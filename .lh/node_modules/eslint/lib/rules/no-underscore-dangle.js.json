{
    "sourceFile": "node_modules/eslint/lib/rules/no-underscore-dangle.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892232045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to flag dangling underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        defaultOptions: [{\n            allow: [],\n            allowAfterSuper: false,\n            allowAfterThis: false,\n            allowAfterThisConstructor: false,\n            allowFunctionParams: true,\n            allowInArrayDestructuring: true,\n            allowInObjectDestructuring: true,\n            enforceInClassFields: false,\n            enforceInMethodNames: false\n        }],\n\n        docs: {\n            description: \"Disallow dangling underscores in identifiers\",\n            recommended: false,\n            frozen: true,\n            url: \"https://eslint.org/docs/latest/rules/no-underscore-dangle\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowAfterThis: {\n                        type: \"boolean\"\n                    },\n                    allowAfterSuper: {\n                        type: \"boolean\"\n                    },\n                    allowAfterThisConstructor: {\n                        type: \"boolean\"\n                    },\n                    enforceInMethodNames: {\n                        type: \"boolean\"\n                    },\n                    allowFunctionParams: {\n                        type: \"boolean\"\n                    },\n                    enforceInClassFields: {\n                        type: \"boolean\"\n                    },\n                    allowInArrayDestructuring: {\n                        type: \"boolean\"\n                    },\n                    allowInObjectDestructuring: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\n        }\n    },\n\n    create(context) {\n        const [{\n            allow,\n            allowAfterSuper,\n            allowAfterThis,\n            allowAfterThisConstructor,\n            allowFunctionParams,\n            allowInArrayDestructuring,\n            allowInObjectDestructuring,\n            enforceInClassFields,\n            enforceInMethodNames\n        }] = context.options;\n        const sourceCode = context.sourceCode;\n\n        //-------------------------------------------------------------------------\n        // Helpers\n        //-------------------------------------------------------------------------\n\n        /**\n         * Check if identifier is present inside the allowed option\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function isAllowed(identifier) {\n            return allow.includes(identifier);\n        }\n\n        /**\n         * Check if identifier has a dangling underscore\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function hasDanglingUnderscore(identifier) {\n            const len = identifier.length;\n\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n        }\n\n        /**\n         * Check if identifier is a special case member expression\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\n            return identifier === \"__proto__\";\n        }\n\n        /**\n         * Check if identifier is a special case variable expression\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\n\n            // Checks for the underscore library usage here\n            return identifier === \"_\";\n        }\n\n        /**\n         * Check if a node is a member reference of this.constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} true if it is a reference on this.constructor\n         * @private\n         */\n        function isThisConstructorReference(node) {\n            return node.object.type === \"MemberExpression\" &&\n                node.object.property.name === \"constructor\" &&\n                node.object.object.type === \"ThisExpression\";\n        }\n\n        /**\n         * Check if function parameter has a dangling underscore.\n         * @param {ASTNode} node function node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInFunctionParameters(node) {\n            if (!allowFunctionParams) {\n                node.params.forEach(param => {\n                    const { type } = param;\n                    let nodeToCheck;\n\n                    if (type === \"RestElement\") {\n                        nodeToCheck = param.argument;\n                    } else if (type === \"AssignmentPattern\") {\n                        nodeToCheck = param.left;\n                    } else {\n                        nodeToCheck = param;\n                    }\n\n                    if (nodeToCheck.type === \"Identifier\") {\n                        const identifier = nodeToCheck.name;\n\n                        if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                            context.report({\n                                node: param,\n                                messageId: \"unexpectedUnderscore\",\n                                data: {\n                                    identifier\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if function has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInFunction(node) {\n            if (node.type === \"FunctionDeclaration\" && node.id) {\n                const identifier = node.id.name;\n\n                if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedUnderscore\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            }\n            checkForDanglingUnderscoreInFunctionParameters(node);\n        }\n\n\n        /**\n         * Check if variable expression has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInVariableExpression(node) {\n            sourceCode.getDeclaredVariables(node).forEach(variable => {\n                const definition = variable.defs.find(def => def.node === node);\n                const identifierNode = definition.name;\n                const identifier = identifierNode.name;\n                let parent = identifierNode.parent;\n\n                while (![\"VariableDeclarator\", \"ArrayPattern\", \"ObjectPattern\"].includes(parent.type)) {\n                    parent = parent.parent;\n                }\n\n                if (\n                    hasDanglingUnderscore(identifier) &&\n                    !isSpecialCaseIdentifierInVariableExpression(identifier) &&\n                    !isAllowed(identifier) &&\n                    !(allowInArrayDestructuring && parent.type === \"ArrayPattern\") &&\n                    !(allowInObjectDestructuring && parent.type === \"ObjectPattern\")\n                ) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedUnderscore\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Check if member expression has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInMemberExpression(node) {\n            const identifier = node.property.name,\n                isMemberOfThis = node.object.type === \"ThisExpression\",\n                isMemberOfSuper = node.object.type === \"Super\",\n                isMemberOfThisConstructor = isThisConstructorReference(node);\n\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\n                !(isMemberOfThis && allowAfterThis) &&\n                !(isMemberOfSuper && allowAfterSuper) &&\n                !(isMemberOfThisConstructor && allowAfterThisConstructor) &&\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if method declaration or method property has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInMethod(node) {\n            const identifier = node.key.name;\n            const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n            if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier: node.key.type === \"PrivateIdentifier\"\n                            ? `#${identifier}`\n                            : identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if a class field has a dangling underscore\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForDanglingUnderscoreInClassField(node) {\n            const identifier = node.key.name;\n\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\n                enforceInClassFields &&\n                !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    messageId: \"unexpectedUnderscore\",\n                    data: {\n                        identifier: node.key.type === \"PrivateIdentifier\"\n                            ? `#${identifier}`\n                            : identifier\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkForDanglingUnderscoreInFunction,\n            VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,\n            MemberExpression: checkForDanglingUnderscoreInMemberExpression,\n            MethodDefinition: checkForDanglingUnderscoreInMethod,\n            PropertyDefinition: checkForDanglingUnderscoreInClassField,\n            Property: checkForDanglingUnderscoreInMethod,\n            FunctionExpression: checkForDanglingUnderscoreInFunction,\n            ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\n        };\n\n    }\n};\n"
        }
    ]
}