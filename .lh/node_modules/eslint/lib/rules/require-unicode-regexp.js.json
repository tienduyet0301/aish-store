{
    "sourceFile": "node_modules/eslint/lib/rules/require-unicode-regexp.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892239054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Rule to enforce the use of `u` or `v` flag on regular expressions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n    CALL,\n    CONSTRUCT,\n    ReferenceTracker,\n    getStringIfConstant\n} = require(\"@eslint-community/eslint-utils\");\nconst astUtils = require(\"./utils/ast-utils.js\");\nconst { isValidWithUnicodeFlag } = require(\"./utils/regular-expressions\");\n\n/**\n * Checks whether the flag configuration should be treated as a missing flag.\n * @param {\"u\"|\"v\"|undefined} requireFlag A particular flag to require\n * @param {string} flags The regex flags\n * @returns {boolean} Whether the flag configuration results in a missing flag.\n */\nfunction checkFlags(requireFlag, flags) {\n    let missingFlag;\n\n    if (requireFlag === \"v\") {\n        missingFlag = !flags.includes(\"v\");\n    } else if (requireFlag === \"u\") {\n        missingFlag = !flags.includes(\"u\");\n    } else {\n        missingFlag = !flags.includes(\"u\") && !flags.includes(\"v\");\n    }\n\n    return missingFlag;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce the use of `u` or `v` flag on regular expressions\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/require-unicode-regexp\"\n        },\n\n        hasSuggestions: true,\n\n        messages: {\n            addUFlag: \"Add the 'u' flag.\",\n            addVFlag: \"Add the 'v' flag.\",\n            requireUFlag: \"Use the 'u' flag.\",\n            requireVFlag: \"Use the 'v' flag.\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireFlag: {\n                        enum: [\"u\", \"v\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.sourceCode;\n\n        const {\n            requireFlag\n        } = context.options[0] ?? {};\n\n        return {\n            \"Literal[regex]\"(node) {\n                const flags = node.regex.flags || \"\";\n\n                const missingFlag = checkFlags(requireFlag, flags);\n\n                if (missingFlag) {\n                    context.report({\n                        messageId: requireFlag === \"v\" ? \"requireVFlag\" : \"requireUFlag\",\n                        node,\n                        suggest: isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, node.regex.pattern, requireFlag)\n                            ? [\n                                {\n                                    fix(fixer) {\n                                        const replaceFlag = requireFlag ?? \"u\";\n                                        const regex = sourceCode.getText(node);\n                                        const slashPos = regex.lastIndexOf(\"/\");\n\n                                        if (requireFlag) {\n                                            const flag = requireFlag === \"u\" ? \"v\" : \"u\";\n\n                                            if (regex.includes(flag, slashPos)) {\n                                                return fixer.replaceText(\n                                                    node,\n                                                    regex.slice(0, slashPos) +\n                                                    regex.slice(slashPos).replace(flag, requireFlag)\n                                                );\n                                            }\n                                        }\n\n                                        return fixer.insertTextAfter(node, replaceFlag);\n                                    },\n                                    messageId: requireFlag === \"v\" ? \"addVFlag\" : \"addUFlag\"\n                                }\n                            ]\n                            : null\n                    });\n                }\n            },\n\n            Program(node) {\n                const scope = sourceCode.getScope(node);\n                const tracker = new ReferenceTracker(scope);\n                const trackMap = {\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                };\n\n                for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {\n                    const [patternNode, flagsNode] = refNode.arguments;\n\n                    if (patternNode && patternNode.type === \"SpreadElement\") {\n                        continue;\n                    }\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    let missingFlag = !flagsNode;\n\n                    if (typeof flags === \"string\") {\n                        missingFlag = checkFlags(requireFlag, flags);\n                    }\n\n                    if (missingFlag) {\n                        context.report({\n                            messageId: requireFlag === \"v\" ? \"requireVFlag\" : \"requireUFlag\",\n                            node: refNode,\n                            suggest: typeof pattern === \"string\" && isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, pattern, requireFlag)\n                                ? [\n                                    {\n                                        fix(fixer) {\n                                            const replaceFlag = requireFlag ?? \"u\";\n\n                                            if (flagsNode) {\n                                                if ((flagsNode.type === \"Literal\" && typeof flagsNode.value === \"string\") || flagsNode.type === \"TemplateLiteral\") {\n                                                    const flagsNodeText = sourceCode.getText(flagsNode);\n                                                    const flag = requireFlag === \"u\" ? \"v\" : \"u\";\n\n                                                    if (flags.includes(flag)) {\n\n                                                        // Avoid replacing \"u\" in escapes like `\\uXXXX`\n                                                        if (flagsNode.type === \"Literal\" && flagsNode.raw.includes(\"\\\\\")) {\n                                                            return null;\n                                                        }\n\n                                                        // Avoid replacing \"u\" in expressions like \"`${regularFlags}g`\"\n                                                        if (flagsNode.type === \"TemplateLiteral\" && (\n                                                            flagsNode.expressions.length ||\n                                                            flagsNode.quasis.some(({ value: { raw } }) => raw.includes(\"\\\\\"))\n                                                        )) {\n                                                            return null;\n                                                        }\n\n                                                        return fixer.replaceText(flagsNode, flagsNodeText.replace(flag, replaceFlag));\n                                                    }\n\n                                                    return fixer.replaceText(flagsNode, [\n                                                        flagsNodeText.slice(0, flagsNodeText.length - 1),\n                                                        flagsNodeText.slice(flagsNodeText.length - 1)\n                                                    ].join(replaceFlag));\n                                                }\n\n                                                // We intentionally don't suggest concatenating + \"u\" to non-literals\n                                                return null;\n                                            }\n\n                                            const penultimateToken = sourceCode.getLastToken(refNode, { skip: 1 }); // skip closing parenthesis\n\n                                            return fixer.insertTextAfter(\n                                                penultimateToken,\n                                                astUtils.isCommaToken(penultimateToken)\n                                                    ? ` \"${replaceFlag}\",`\n                                                    : `, \"${replaceFlag}\"`\n                                            );\n                                        },\n                                        messageId: requireFlag === \"v\" ? \"addVFlag\" : \"addUFlag\"\n                                    }\n                                ]\n                                : null\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"
        }
    ]
}