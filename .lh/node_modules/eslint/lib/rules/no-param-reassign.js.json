{
    "sourceFile": "node_modules/eslint/lib/rules/no-param-reassign.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892229297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Disallow reassigning function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow reassigning function parameters\",\n            recommended: false,\n            url: \"https://eslint.org/docs/latest/rules/no-param-reassign\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            },\n                            ignorePropertyModificationsForRegex: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n            assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n        }\n    },\n\n    create(context) {\n        const props = context.options[0] && context.options[0].props;\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n        const sourceCode = context.sourceCode;\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && (!stopNodePattern.test(parent.type) ||\n                    parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // e.g. for (foo.a in b) {}\n                    case \"ForInStatement\":\n                    case \"ForOfStatement\":\n                        if (parent.left === node) {\n                            return true;\n                        }\n\n                        // this is a stop node for parent.right and parent.body\n                        return false;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\n                    case \"ConditionalExpression\":\n                        if (parent.test === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Tests that an identifier name matches any of the ignored property assignments.\n         * First we test strings in ignoredPropertyAssignmentsFor.\n         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\n         * @param {string} identifierName A string that describes the name of an identifier to\n         * ignore property assignments for.\n         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\n         */\n        function isIgnoredPropertyAssignment(identifierName) {\n            return ignoredPropertyAssignmentsFor.includes(identifierName) ||\n                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference A reference to check.\n         * @param {int} index The index of the reference in the references.\n         * @param {Reference[]} references The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                /*\n                 * Destructuring assignments can have multiple default value,\n                 * so possibly there are multiple writeable references for the same identifier.\n                 */\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParam\",\n                        data: { name: identifier.name }\n                    });\n                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n                    context.report({\n                        node: identifier,\n                        messageId: \"assignmentToFunctionParamProp\",\n                        data: { name: identifier.name }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            sourceCode.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n"
        }
    ]
}