{
    "sourceFile": "node_modules/eslint/lib/linter/apply-disable-directives.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892211637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"@eslint/core\").Language} Language */\n/** @typedef {import(\"@eslint/core\").Position} Position */\n/** @typedef {import(\"@eslint/core\").RulesConfig} RulesConfig */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\nconst escapeRegExp = require(\"escape-string-regexp\");\nconst {\n    Legacy: {\n        ConfigOps\n    }\n} = require(\"@eslint/eslintrc/universal\");\n\n/**\n * Compares the locations of two objects in a source file\n * @param {Position} itemA The first object\n * @param {Position} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\nfunction compareLocations(itemA, itemB) {\n    return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\n/**\n * Groups a set of directives into sub-arrays by their parent comment.\n * @param {Iterable<Directive>} directives Unused directives to be removed.\n * @returns {Directive[][]} Directives grouped by their parent comment.\n */\nfunction groupByParentDirective(directives) {\n    const groups = new Map();\n\n    for (const directive of directives) {\n        const { unprocessedDirective: { parentDirective } } = directive;\n\n        if (groups.has(parentDirective)) {\n            groups.get(parentDirective).push(directive);\n        } else {\n            groups.set(parentDirective, [directive]);\n        }\n    }\n\n    return [...groups.values()];\n}\n\n/**\n * Creates removal details for a set of directives within the same comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {{node: Token, value: string}} parentDirective Data about the backing directive.\n * @param {SourceCode} sourceCode The source code object for the file being linted.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction createIndividualDirectivesRemoval(directives, parentDirective, sourceCode) {\n\n    /*\n     * Get the list of the rules text without any surrounding whitespace. In order to preserve the original\n     * formatting, we don't want to change that whitespace.\n     *\n     *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n     *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     */\n    const listText = parentDirective.value.trim();\n\n    // Calculate where it starts in the source code text\n    const listStart = sourceCode.text.indexOf(listText, sourceCode.getRange(parentDirective.node)[0]);\n\n    /*\n     * We can assume that `listText` contains multiple elements.\n     * Otherwise, this function wouldn't be called - if there is\n     * only one rule in the list, then the whole comment must be removed.\n     */\n\n    return directives.map(directive => {\n        const { ruleId } = directive;\n\n        const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)(?<quote>['\"]?)${escapeRegExp(ruleId)}\\k<quote>(?:\\s*,\\s*|$)`, \"u\");\n        const match = regex.exec(listText);\n        const matchedText = match[0];\n        const matchStart = listStart + match.index;\n        const matchEnd = matchStart + matchedText.length;\n\n        const firstIndexOfComma = matchedText.indexOf(\",\");\n        const lastIndexOfComma = matchedText.lastIndexOf(\",\");\n\n        let removalStart, removalEnd;\n\n        if (firstIndexOfComma !== lastIndexOfComma) {\n\n            /*\n             * Since there are two commas, this must one of the elements in the middle of the list.\n             * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                    ^^^^^^^^^^^^^^\n             *\n             * We want to remove only the content between the two commas, and also one of the commas.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                     ^^^^^^^^^^^\n             */\n            removalStart = matchStart + firstIndexOfComma;\n            removalEnd = matchStart + lastIndexOfComma;\n\n        } else {\n\n            /*\n             * This is either the first element or the last element.\n             *\n             * If this is the first element, matched range starts where the first rule name starts\n             * and ends where the second rule name starts. This is exactly the range we want\n             * to remove so that the second rule name will start where the first one was starting\n             * and thus preserve the original formatting.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                            ^^^^^^^^^^^\n             *\n             * Similarly, if this is the last element, we've already matched the range we want to\n             * remove. The previous rule name will end where the last one was ending, relative\n             * to the content on the right side.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                               ^^^^^^^^^^^^^\n             */\n            removalStart = matchStart;\n            removalEnd = matchEnd;\n        }\n\n        return {\n            description: `'${ruleId}'`,\n            fix: {\n                range: [\n                    removalStart,\n                    removalEnd\n                ],\n                text: \"\"\n            },\n            unprocessedDirective: directive.unprocessedDirective\n        };\n    });\n}\n\n/**\n * Creates a description of deleting an entire unused disable directive.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} node The backing Comment token.\n * @param {SourceCode} sourceCode The source code object for the file being linted.\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output problem.\n */\nfunction createDirectiveRemoval(directives, node, sourceCode) {\n    const range = sourceCode.getRange(node);\n    const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\n\n    return {\n        description: ruleIds.length <= 2\n            ? ruleIds.join(\" or \")\n            : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds.at(-1)}`,\n        fix: {\n            range,\n            text: \" \"\n        },\n        unprocessedDirective: directives[0].unprocessedDirective\n    };\n}\n\n/**\n * Parses details from directives to create output Problems.\n * @param {Iterable<Directive>} allDirectives Unused directives to be removed.\n * @param {SourceCode} sourceCode The source code object for the file being linted.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction processUnusedDirectives(allDirectives, sourceCode) {\n    const directiveGroups = groupByParentDirective(allDirectives);\n\n    return directiveGroups.flatMap(\n        directives => {\n            const { parentDirective } = directives[0].unprocessedDirective;\n            const remainingRuleIds = new Set(parentDirective.ruleIds);\n\n            for (const directive of directives) {\n                remainingRuleIds.delete(directive.ruleId);\n            }\n\n            return remainingRuleIds.size\n                ? createIndividualDirectivesRemoval(directives, parentDirective, sourceCode)\n                : [createDirectiveRemoval(directives, parentDirective.node, sourceCode)];\n        }\n    );\n}\n\n/**\n * Collect eslint-enable comments that are removing suppressions by eslint-disable comments.\n * @param {Directive[]} directives The directives to check.\n * @returns {Set<Directive>} The used eslint-enable comments\n */\nfunction collectUsedEnableDirectives(directives) {\n\n    /**\n     * A Map of `eslint-enable` keyed by ruleIds that may be marked as used.\n     * If `eslint-enable` does not have a ruleId, the key will be `null`.\n     * @type {Map<string|null, Directive>}\n     */\n    const enabledRules = new Map();\n\n    /**\n     * A Set of `eslint-enable` marked as used.\n     * It is also the return value of `collectUsedEnableDirectives` function.\n     * @type {Set<Directive>}\n     */\n    const usedEnableDirectives = new Set();\n\n    /*\n     * Checks the directives backwards to see if the encountered `eslint-enable` is used by the previous `eslint-disable`,\n     * and if so, stores the `eslint-enable` in `usedEnableDirectives`.\n     */\n    for (let index = directives.length - 1; index >= 0; index--) {\n        const directive = directives[index];\n\n        if (directive.type === \"disable\") {\n            if (enabledRules.size === 0) {\n                continue;\n            }\n            if (directive.ruleId === null) {\n\n                // If encounter `eslint-disable` without ruleId,\n                // mark all `eslint-enable` currently held in enabledRules as used.\n                // e.g.\n                //    /* eslint-disable */ <- current directive\n                //    /* eslint-enable rule-id1 */ <- used\n                //    /* eslint-enable rule-id2 */ <- used\n                //    /* eslint-enable */ <- used\n                for (const enableDirective of enabledRules.values()) {\n                    usedEnableDirectives.add(enableDirective);\n                }\n                enabledRules.clear();\n            } else {\n                const enableDirective = enabledRules.get(directive.ruleId);\n\n                if (enableDirective) {\n\n                    // If encounter `eslint-disable` with ruleId, and there is an `eslint-enable` with the same ruleId in enabledRules,\n                    // mark `eslint-enable` with ruleId as used.\n                    // e.g.\n                    //    /* eslint-disable rule-id */ <- current directive\n                    //    /* eslint-enable rule-id */ <- used\n                    usedEnableDirectives.add(enableDirective);\n                } else {\n                    const enabledDirectiveWithoutRuleId = enabledRules.get(null);\n\n                    if (enabledDirectiveWithoutRuleId) {\n\n                        // If encounter `eslint-disable` with ruleId, and there is no `eslint-enable` with the same ruleId in enabledRules,\n                        // mark `eslint-enable` without ruleId as used.\n                        // e.g.\n                        //    /* eslint-disable rule-id */ <- current directive\n                        //    /* eslint-enable */ <- used\n                        usedEnableDirectives.add(enabledDirectiveWithoutRuleId);\n                    }\n                }\n            }\n        } else if (directive.type === \"enable\") {\n            if (directive.ruleId === null) {\n\n                // If encounter `eslint-enable` without ruleId, the `eslint-enable` that follows it are unused.\n                // So clear enabledRules.\n                // e.g.\n                //    /* eslint-enable */ <- current directive\n                //    /* eslint-enable rule-id *// <- unused\n                //    /* eslint-enable */ <- unused\n                enabledRules.clear();\n                enabledRules.set(null, directive);\n            } else {\n                enabledRules.set(directive.ruleId, directive);\n            }\n        }\n    }\n    return usedEnableDirectives;\n}\n\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: LintMessage[], unusedDirectives: LintMessage[]}} An object with a list\n * of problems (including suppressed ones) and unused eslint-disable directives\n */\nfunction applyDirectives(options) {\n    const problems = [];\n    const usedDisableDirectives = new Set();\n    const { sourceCode } = options;\n\n    for (const problem of options.problems) {\n        let disableDirectivesForProblem = [];\n        let nextDirectiveIndex = 0;\n\n        while (\n            nextDirectiveIndex < options.directives.length &&\n            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0\n        ) {\n            const directive = options.directives[nextDirectiveIndex++];\n\n            if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\n                switch (directive.type) {\n                    case \"disable\":\n                        disableDirectivesForProblem.push(directive);\n                        break;\n\n                    case \"enable\":\n                        disableDirectivesForProblem = [];\n                        break;\n\n                    // no default\n                }\n            }\n        }\n\n        if (disableDirectivesForProblem.length > 0) {\n            const suppressions = disableDirectivesForProblem.map(directive => ({\n                kind: \"directive\",\n                justification: directive.unprocessedDirective.justification\n            }));\n\n            if (problem.suppressions) {\n                problem.suppressions = problem.suppressions.concat(suppressions);\n            } else {\n                problem.suppressions = suppressions;\n                usedDisableDirectives.add(disableDirectivesForProblem.at(-1));\n            }\n        }\n\n        problems.push(problem);\n    }\n\n    const unusedDisableDirectivesToReport = options.directives\n        .filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive) && !options.rulesToIgnore.has(directive.ruleId));\n\n\n    const unusedEnableDirectivesToReport = new Set(\n        options.directives.filter(directive => directive.unprocessedDirective.type === \"enable\" && !options.rulesToIgnore.has(directive.ruleId))\n    );\n\n    /*\n     * If directives has the eslint-enable directive,\n     * check whether the eslint-enable comment is used.\n     */\n    if (unusedEnableDirectivesToReport.size > 0) {\n        for (const directive of collectUsedEnableDirectives(options.directives)) {\n            unusedEnableDirectivesToReport.delete(directive);\n        }\n    }\n\n    const processed = processUnusedDirectives(unusedDisableDirectivesToReport, sourceCode)\n        .concat(processUnusedDirectives(unusedEnableDirectivesToReport, sourceCode));\n    const columnOffset = options.language.columnStart === 1 ? 0 : 1;\n    const lineOffset = options.language.lineStart === 1 ? 0 : 1;\n\n    const unusedDirectives = processed\n        .map(({ description, fix, unprocessedDirective }) => {\n            const { parentDirective, type, line, column } = unprocessedDirective;\n\n            let message;\n\n            if (type === \"enable\") {\n                message = description\n                    ? `Unused eslint-enable directive (no matching eslint-disable directives were found for ${description}).`\n                    : \"Unused eslint-enable directive (no matching eslint-disable directives were found).\";\n            } else {\n                message = description\n                    ? `Unused eslint-disable directive (no problems were reported from ${description}).`\n                    : \"Unused eslint-disable directive (no problems were reported).\";\n            }\n\n            const loc = sourceCode.getLoc(parentDirective.node);\n\n            return {\n                ruleId: null,\n                message,\n                line: type === \"disable-next-line\" ? loc.start.line + lineOffset : line,\n                column: type === \"disable-next-line\" ? loc.start.column + columnOffset : column,\n                severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n                nodeType: null,\n                ...options.disableFixes ? {} : { fix }\n            };\n        });\n\n    return { problems, unusedDirectives };\n}\n\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, adds the suppression information to the problems.\n * @param {Object} options Information about directives and problems\n * @param {Language} options.language The language being linted.\n * @param {SourceCode} options.sourceCode The source code object for the file being linted.\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number,\n *      justification: string\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\n * @param {RulesConfig} options.configuredRules The rules configuration.\n * @param {Function} options.ruleFilter A predicate function to filter which rules should be executed.\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\n */\nmodule.exports = ({ language, sourceCode, directives, disableFixes, problems, configuredRules, ruleFilter, reportUnusedDisableDirectives = \"off\" }) => {\n    const blockDirectives = directives\n        .filter(directive => directive.type === \"disable\" || directive.type === \"enable\")\n        .map(directive => Object.assign({}, directive, { unprocessedDirective: directive }))\n        .sort(compareLocations);\n\n    const lineDirectives = directives.flatMap(directive => {\n        switch (directive.type) {\n            case \"disable\":\n            case \"enable\":\n                return [];\n\n            case \"disable-line\":\n                return [\n                    { type: \"disable\", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            case \"disable-next-line\":\n                return [\n                    { type: \"disable\", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            default:\n                throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n        }\n    }).sort(compareLocations);\n\n    // This determines a list of rules that are not being run by the given ruleFilter, if present.\n    const rulesToIgnore = configuredRules && ruleFilter\n        ? new Set(Object.keys(configuredRules).filter(ruleId => {\n            const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n            // Ignore for disabled rules.\n            if (severity === 0) {\n                return false;\n            }\n\n            return !ruleFilter({ severity, ruleId });\n        }))\n        : new Set();\n\n    // If no ruleId is supplied that means this directive is applied to all rules, so we can't determine if it's unused if any rules are filtered out.\n    if (rulesToIgnore.size > 0) {\n        rulesToIgnore.add(null);\n    }\n\n    const blockDirectivesResult = applyDirectives({\n        language,\n        sourceCode,\n        problems,\n        directives: blockDirectives,\n        disableFixes,\n        reportUnusedDisableDirectives,\n        rulesToIgnore\n    });\n    const lineDirectivesResult = applyDirectives({\n        language,\n        sourceCode,\n        problems: blockDirectivesResult.problems,\n        directives: lineDirectives,\n        disableFixes,\n        reportUnusedDisableDirectives,\n        rulesToIgnore\n    });\n\n    return reportUnusedDisableDirectives !== \"off\"\n        ? lineDirectivesResult.problems\n            .concat(blockDirectivesResult.unusedDirectives)\n            .concat(lineDirectivesResult.unusedDirectives)\n            .sort(compareLocations)\n        : lineDirectivesResult.problems;\n};\n"
        }
    ]
}