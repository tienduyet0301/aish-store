{
    "sourceFile": "node_modules/eslint/lib/linter/linter.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892212637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    path = require(\"node:path\"),\n    eslintScope = require(\"eslint-scope\"),\n    evk = require(\"eslint-visitor-keys\"),\n    espree = require(\"espree\"),\n    merge = require(\"lodash.merge\"),\n    pkg = require(\"../../package.json\"),\n    {\n        Legacy: {\n            ConfigOps,\n            ConfigValidator,\n            environments: BuiltInEnvironments\n        }\n    } = require(\"@eslint/eslintrc/universal\"),\n    Traverser = require(\"../shared/traverser\"),\n    { SourceCode } = require(\"../languages/js/source-code\"),\n    applyDisableDirectives = require(\"./apply-disable-directives\"),\n    { ConfigCommentParser } = require(\"@eslint/plugin-kit\"),\n    NodeEventGenerator = require(\"./node-event-generator\"),\n    createReportTranslator = require(\"./report-translator\"),\n    Rules = require(\"./rules\"),\n    createEmitter = require(\"./safe-emitter\"),\n    SourceCodeFixer = require(\"./source-code-fixer\"),\n    timing = require(\"./timing\"),\n    ruleReplacements = require(\"../../conf/replacements.json\");\nconst { getRuleFromConfig } = require(\"../config/flat-config-helpers\");\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\nconst { startTime, endTime } = require(\"../shared/stats\");\nconst { RuleValidator } = require(\"../config/rule-validator\");\nconst { assertIsRuleSeverity } = require(\"../config/flat-config-schema\");\nconst { normalizeSeverityToString, normalizeSeverityToNumber } = require(\"../shared/severity\");\nconst { deepMergeArrays } = require(\"../shared/deep-merge-arrays\");\nconst jslang = require(\"../languages/js\");\nconst { activeFlags, inactiveFlags, getInactivityReasonMessage } = require(\"../shared/flags\");\nconst debug = require(\"debug\")(\"eslint:linter\");\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\nconst { LATEST_ECMA_VERSION } = require(\"../../conf/ecma-version\");\nconst { VFile } = require(\"./vfile\");\nconst { ParserService } = require(\"../services/parser-service\");\nconst { FileContext } = require(\"./file-context\");\nconst { ProcessorService } = require(\"../services/processor-service\");\nconst { containsDifferentProperty } = require(\"../shared/option-utils\");\nconst STEP_KIND_VISIT = 1;\nconst STEP_KIND_CALL = 2;\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {import(\"../shared/types\").Times} Times */\n/** @typedef {import(\"@eslint/core\").Language} Language */\n/** @typedef {import(\"@eslint/core\").RuleSeverity} RuleSeverity */\n/** @typedef {import(\"@eslint/core\").RuleConfig} RuleConfig */\n/** @typedef {import(\"../types\").Linter.StringSeverity} StringSeverity */\n\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type Type of directive\n * @property {number} line The line number\n * @property {number} column The column number\n * @property {(string|null)} ruleId The rule ID\n * @property {string} justification The justification of directive\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {SuppressedLintMessage[]} lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Times} times The times spent on applying a rule to a file (see `stats` option).\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n * @property {Function} [ruleFilter] A predicate function that determines whether a given rule should run.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor.postprocess} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor.preprocess} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {StringSeverity} reportUnusedDisableDirectives Severity to report unused disable directives, if not \"off\" (boolean values were normalized).\n * @property {StringSeverity} reportUnusedInlineConfigs Severity to report unused inline configs, if not \"off\".\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if a given object is Espree.\n * @param {Object} parser The parser to check.\n * @returns {boolean} True if the parser is Espree or false if not.\n */\nfunction isEspree(parser) {\n    return !!(parser === espree || parser[parserSymbol] === espree);\n}\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\nfunction addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {\n\n    // Define configured global variables.\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n\n        /*\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n        const value = commentValue || configValue;\n        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n        if (value === \"off\") {\n            continue;\n        }\n\n        let variable = globalScope.set.get(id);\n\n        if (!variable) {\n            variable = new eslintScope.Variable(id, globalScope);\n\n            globalScope.variables.push(variable);\n            globalScope.set.set(id, variable);\n        }\n\n        variable.eslintImplicitGlobalSetting = configValue;\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\n        variable.eslintExplicitGlobalComments = sourceComments;\n        variable.writeable = (value === \"writable\");\n    }\n\n    // mark all exported variables as such\n    Object.keys(exportedVariables).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n            variable.eslintExported = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\nfunction createMissingRuleMessage(ruleId) {\n    return Object.hasOwn(ruleReplacements.rules, ruleId)\n        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}`\n        : `Definition for rule '${ruleId}' was not found.`;\n}\n\n/**\n * Updates a given location based on the language offsets. This allows us to\n * change 0-based locations to 1-based locations. We always want ESLint\n * reporting lines and columns starting from 1.\n * @param {Object} location The location to update.\n * @param {number} location.line The starting line number.\n * @param {number} location.column The starting column number.\n * @param {number} [location.endLine] The ending line number.\n * @param {number} [location.endColumn] The ending column number.\n * @param {Language} language The language to use to adjust the location information.\n * @returns {Object} The updated location.\n */\nfunction updateLocationInformation({ line, column, endLine, endColumn }, language) {\n\n    const columnOffset = language.columnStart === 1 ? 0 : 1;\n    const lineOffset = language.lineStart === 1 ? 0 : 1;\n\n    // calculate separately to account for undefined\n    const finalEndLine = endLine === void 0 ? endLine : endLine + lineOffset;\n    const finalEndColumn = endColumn === void 0 ? endColumn : endColumn + columnOffset;\n\n    return {\n        line: line + lineOffset,\n        column: column + columnOffset,\n        endLine: finalEndLine,\n        endColumn: finalEndColumn\n    };\n}\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {RuleSeverity} [options.severity] the error message to report\n * @param {Language} [options.language] the language to use to adjust the location information\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\nfunction createLintingProblem(options) {\n    const {\n        ruleId = null,\n        loc = DEFAULT_ERROR_LOC,\n        message = createMissingRuleMessage(options.ruleId),\n        severity = 2,\n\n        // fallback for eslintrc mode\n        language = {\n            columnStart: 0,\n            lineStart: 1\n        }\n    } = options;\n\n    return {\n        ruleId,\n        message,\n        ...updateLocationInformation({\n            line: loc.start.line,\n            column: loc.start.column,\n            endLine: loc.end.line,\n            endColumn: loc.end.column\n        }, language),\n        severity,\n        nodeType: null\n    };\n}\n\n/**\n * Wraps the value in an Array if it isn't already one.\n * @template T\n * @param {T|T[]} value Value to be wrapped.\n * @returns {Array} The value as an array.\n */\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Pushes a problem to inlineConfigProblems if ruleOptions are redundant.\n * @param {ConfigData} config Provided config.\n * @param {Object} loc A line/column location\n * @param {Array} problems Problems that may be added to.\n * @param {string} ruleId The rule ID.\n * @param {Array} ruleOptions The rule options, merged with the config's.\n * @param {Array} ruleOptionsInline The rule options from the comment.\n * @param {\"error\"|\"warn\"} severity The severity to report.\n * @returns {void}\n */\nfunction addProblemIfSameSeverityAndOptions(config, loc, problems, ruleId, ruleOptions, ruleOptionsInline, severity) {\n    const existingConfigRaw = config.rules?.[ruleId];\n    const existingConfig = existingConfigRaw ? asArray(existingConfigRaw) : [\"off\"];\n    const existingSeverity = normalizeSeverityToString(existingConfig[0]);\n    const inlineSeverity = normalizeSeverityToString(ruleOptions[0]);\n    const sameSeverity = existingSeverity === inlineSeverity;\n\n    if (!sameSeverity) {\n        return;\n    }\n\n    const alreadyConfigured = existingConfigRaw\n        ? `is already configured to '${existingSeverity}'`\n        : \"is not enabled so can't be turned off\";\n    let message;\n\n    if ((existingConfig.length === 1 && ruleOptions.length === 1) || existingSeverity === \"off\") {\n        message = `Unused inline config ('${ruleId}' ${alreadyConfigured}).`;\n    } else if (!containsDifferentProperty(ruleOptions.slice(1), existingConfig.slice(1))) {\n        message = ruleOptionsInline.length === 1\n            ? `Unused inline config ('${ruleId}' ${alreadyConfigured}).`\n            : `Unused inline config ('${ruleId}' ${alreadyConfigured} with the same options).`;\n    }\n\n    if (message) {\n        problems.push(createLintingProblem({\n            ruleId: null,\n            message,\n            loc,\n            language: config.language,\n            severity: normalizeSeverityToNumber(severity)\n        }));\n    }\n}\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {string} options.justification The justification of the directive\n * @param {ASTNode|token} options.node The Comment node/token.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {Language} language The language to use to adjust the location information.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @returns {Object} Directives and problems from the comment\n */\nfunction createDisableDirectives({ type, value, justification, node }, ruleMapper, language, sourceCode) {\n    const ruleIds = Object.keys(commentParser.parseListConfig(value));\n    const directiveRules = ruleIds.length ? ruleIds : [null];\n    const result = {\n        directives: [], // valid disable directives\n        directiveProblems: [] // problems in directives\n    };\n    const parentDirective = { node, value, ruleIds };\n\n    for (const ruleId of directiveRules) {\n\n        const loc = sourceCode.getLoc(node);\n\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n        if (ruleId === null || !!ruleMapper(ruleId)) {\n\n\n            if (type === \"disable-next-line\") {\n                const { line, column } = updateLocationInformation(\n                    loc.end,\n                    language\n                );\n\n                result.directives.push({\n                    parentDirective,\n                    type,\n                    line,\n                    column,\n                    ruleId,\n                    justification\n                });\n            } else {\n                const { line, column } = updateLocationInformation(\n                    loc.start,\n                    language\n                );\n\n                result.directives.push({\n                    parentDirective,\n                    type,\n                    line,\n                    column,\n                    ruleId,\n                    justification\n                });\n            }\n        } else {\n            result.directiveProblems.push(createLintingProblem({ ruleId, loc, language }));\n        }\n    }\n    return result;\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @param {ConfigData} config Provided config.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveComments(sourceCode, ruleMapper, warnInlineConfig, config) {\n    const configuredRules = {};\n    const enabledGlobals = Object.create(null);\n    const exportedVariables = {};\n    const problems = [];\n    const disableDirectives = [];\n    const validator = new ConfigValidator({\n        builtInRules: Rules\n    });\n\n    sourceCode.getInlineConfigNodes().filter(token => token.type !== \"Shebang\").forEach(comment => {\n\n        const directive = commentParser.parseDirective(comment.value);\n\n        if (!directive) {\n            return;\n        }\n\n        const {\n            label,\n            value,\n            justification: justificationPart\n        } = directive;\n\n        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(label);\n\n        if (comment.type === \"Line\" && !lineCommentSupported) {\n            return;\n        }\n\n        const loc = sourceCode.getLoc(comment);\n\n        if (warnInlineConfig) {\n            const kind = comment.type === \"Block\" ? `/*${label}*/` : `//${label}`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n                loc,\n                severity: 1\n            }));\n            return;\n        }\n\n        if (label === \"eslint-disable-line\" && loc.start.line !== loc.end.line) {\n            const message = `${label} comment should not span multiple lines.`;\n\n            problems.push(createLintingProblem({\n                ruleId: null,\n                message,\n                loc\n            }));\n            return;\n        }\n\n        switch (label) {\n            case \"eslint-disable\":\n            case \"eslint-enable\":\n            case \"eslint-disable-next-line\":\n            case \"eslint-disable-line\": {\n                const directiveType = label.slice(\"eslint-\".length);\n                const { directives, directiveProblems } = createDisableDirectives({\n                    type: directiveType,\n                    value,\n                    justification: justificationPart,\n                    node: comment\n                }, ruleMapper, jslang, sourceCode);\n\n                disableDirectives.push(...directives);\n                problems.push(...directiveProblems);\n                break;\n            }\n\n            case \"exported\":\n                Object.assign(exportedVariables, commentParser.parseListConfig(value));\n                break;\n\n            case \"globals\":\n            case \"global\":\n                for (const [id, idSetting] of Object.entries(commentParser.parseStringConfig(value))) {\n                    let normalizedValue;\n\n                    try {\n                        normalizedValue = ConfigOps.normalizeConfigGlobal(idSetting);\n                    } catch (err) {\n                        problems.push(createLintingProblem({\n                            ruleId: null,\n                            loc,\n                            message: err.message\n                        }));\n                        continue;\n                    }\n\n                    if (enabledGlobals[id]) {\n                        enabledGlobals[id].comments.push(comment);\n                        enabledGlobals[id].value = normalizedValue;\n                    } else {\n                        enabledGlobals[id] = {\n                            comments: [comment],\n                            value: normalizedValue\n                        };\n                    }\n                }\n                break;\n\n            case \"eslint\": {\n                const parseResult = commentParser.parseJSONLikeConfig(value);\n\n                if (parseResult.ok) {\n                    Object.keys(parseResult.config).forEach(name => {\n                        const rule = ruleMapper(name);\n                        const ruleValue = parseResult.config[name];\n\n                        if (!rule) {\n                            problems.push(createLintingProblem({ ruleId: name, loc }));\n                            return;\n                        }\n\n                        if (Object.hasOwn(configuredRules, name)) {\n                            problems.push(createLintingProblem({\n                                message: `Rule \"${name}\" is already configured by another configuration comment in the preceding code. This configuration is ignored.`,\n                                loc\n                            }));\n                            return;\n                        }\n\n                        let ruleOptions = asArray(ruleValue);\n\n                        /*\n                         * If the rule was already configured, inline rule configuration that\n                         * only has severity should retain options from the config and just override the severity.\n                         *\n                         * Example:\n                         *\n                         *   {\n                         *       rules: {\n                         *           curly: [\"error\", \"multi\"]\n                         *       }\n                         *   }\n                         *\n                         *   /* eslint curly: [\"warn\"] * /\n                         *\n                         *   Results in:\n                         *\n                         *   curly: [\"warn\", \"multi\"]\n                         */\n                        if (\n\n                            /*\n                             * If inline config for the rule has only severity\n                             */\n                            ruleOptions.length === 1 &&\n\n                            /*\n                             * And the rule was already configured\n                             */\n                            config.rules && Object.hasOwn(config.rules, name)\n                        ) {\n\n                            /*\n                             * Then use severity from the inline config and options from the provided config\n                             */\n                            ruleOptions = [\n                                ruleOptions[0], // severity from the inline config\n                                ...asArray(config.rules[name]).slice(1) // options from the provided config\n                            ];\n                        }\n\n                        try {\n                            validator.validateRuleOptions(rule, name, ruleOptions);\n                        } catch (err) {\n\n                            /*\n                             * If the rule has invalid `meta.schema`, throw the error because\n                             * this is not an invalid inline configuration but an invalid rule.\n                             */\n                            if (err.code === \"ESLINT_INVALID_RULE_OPTIONS_SCHEMA\") {\n                                throw err;\n                            }\n\n                            problems.push(createLintingProblem({\n                                ruleId: name,\n                                message: err.message,\n                                loc\n                            }));\n\n                            // do not apply the config, if found invalid options.\n                            return;\n                        }\n\n                        configuredRules[name] = ruleOptions;\n                    });\n                } else {\n                    const problem = createLintingProblem({\n                        ruleId: null,\n                        loc,\n                        message: parseResult.error.message\n                    });\n\n                    problem.fatal = true;\n                    problems.push(problem);\n                }\n\n                break;\n            }\n\n            // no default\n        }\n    });\n\n    return {\n        configuredRules,\n        enabledGlobals,\n        exportedVariables,\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Parses comments in file to extract disable directives.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {Language} language The language to use to adjust the location information\n * @returns {{problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\nfunction getDirectiveCommentsForFlatConfig(sourceCode, ruleMapper, language) {\n    const disableDirectives = [];\n    const problems = [];\n\n    if (sourceCode.getDisableDirectives) {\n        const {\n            directives: directivesSources,\n            problems: directivesProblems\n        } = sourceCode.getDisableDirectives();\n\n        problems.push(...directivesProblems.map(directiveProblem => createLintingProblem({\n            ...directiveProblem,\n            language\n        })));\n\n        directivesSources.forEach(directive => {\n            const { directives, directiveProblems } = createDisableDirectives(directive, ruleMapper, language, sourceCode);\n\n            disableDirectives.push(...directives);\n            problems.push(...directiveProblems);\n        });\n    }\n\n    return {\n        problems,\n        disableDirectives\n    };\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param {Parser} parser The parser which uses this options.\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n\n    if (isEspree(parser)) {\n        if (ecmaVersion === \"latest\") {\n            return espree.latestEcmaVersion;\n        }\n    }\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n\n/**\n * Normalize ECMAScript version from the initial config into languageOptions (year)\n * format.\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersionForLanguageOptions(ecmaVersion) {\n\n    switch (ecmaVersion) {\n        case 3:\n            return 3;\n\n        // void 0 = no ecmaVersion specified so use the default\n        case 5:\n        case void 0:\n            return 5;\n\n        default:\n            if (typeof ecmaVersion === \"number\") {\n                return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;\n            }\n    }\n\n    /*\n     * We default to the latest supported ecmaVersion for everything else.\n     * Remember, this is for languageOptions.ecmaVersion, which sets the version\n     * that is used for a number of processes inside of ESLint. It's normally\n     * safe to assume people want the latest unless otherwise specified.\n     */\n    return LATEST_ECMA_VERSION;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)(?:\\*\\/|$)/gsu;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text)) !== null) {\n        if (match[0].endsWith(\"*/\")) {\n            retv = Object.assign(\n                retv || {},\n                commentParser.parseListConfig(commentParser.parseDirective(match[0].slice(2, -2)).value)\n            );\n        }\n    }\n\n    return retv;\n}\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#filename` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\nfunction normalizeFilename(filename) {\n    const parts = filename.split(path.sep);\n    const index = parts.lastIndexOf(\"<text>\");\n\n    return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\nfunction normalizeVerifyOptions(providedOptions, config) {\n\n    const linterOptions = config.linterOptions || config;\n\n    // .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat\n    const disableInlineConfig = linterOptions.noInlineConfig === true;\n    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig\n        ? ` (${config.configNameOfNoInlineConfig})`\n        : \"\";\n\n    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n    if (typeof reportUnusedDisableDirectives === \"boolean\") {\n        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n    }\n    if (typeof reportUnusedDisableDirectives !== \"string\") {\n        if (typeof linterOptions.reportUnusedDisableDirectives === \"boolean\") {\n            reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n        } else {\n            reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives === void 0 ? \"off\" : normalizeSeverityToString(linterOptions.reportUnusedDisableDirectives);\n        }\n    }\n\n    const reportUnusedInlineConfigs = linterOptions.reportUnusedInlineConfigs === void 0 ? \"off\" : normalizeSeverityToString(linterOptions.reportUnusedInlineConfigs);\n\n    let ruleFilter = providedOptions.ruleFilter;\n\n    if (typeof ruleFilter !== \"function\") {\n        ruleFilter = () => true;\n    }\n\n    return {\n        filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n        allowInlineConfig: !ignoreInlineConfig,\n        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig\n            ? `your config${configNameOfNoInlineConfig}`\n            : null,\n        reportUnusedDisableDirectives,\n        reportUnusedInlineConfigs,\n        disableFixes: Boolean(providedOptions.disableFixes),\n        stats: providedOptions.stats,\n        ruleFilter\n    };\n}\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {Parser} parser The parser which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n\n    const parserOptionsFromEnv = enabledEnvironments\n        .filter(env => env.parserOptions)\n        .reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\n    const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\n    const isModule = mergedParserOptions.sourceType === \"module\";\n\n    if (isModule) {\n\n        /*\n         * can't have global return inside of modules\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n         */\n        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });\n    }\n\n    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n\n    return mergedParserOptions;\n}\n\n/**\n * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.\n * @param {ConfigData} config Config object.\n * @param {Object} config.globals Global variable definitions.\n * @param {Parser} config.parser The parser to use.\n * @param {ParserOptions} config.parserOptions The parserOptions to use.\n * @returns {LanguageOptions} The languageOptions equivalent.\n */\nfunction createLanguageOptions({ globals: configuredGlobals, parser, parserOptions }) {\n\n    const {\n        ecmaVersion,\n        sourceType\n    } = parserOptions;\n\n    return {\n        globals: configuredGlobals,\n        ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),\n        sourceType,\n        parser,\n        parserOptions\n    };\n}\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n    return Object.assign(\n        Object.create(null),\n        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),\n        providedGlobals\n    );\n}\n\n/**\n * Store time measurements in map\n * @param {number} time Time measurement\n * @param {Object} timeOpts Options relating which time was measured\n * @param {WeakMap<Linter, LinterInternalSlots>} slots Linter internal slots map\n * @returns {void}\n */\nfunction storeTime(time, timeOpts, slots) {\n    const { type, key } = timeOpts;\n\n    if (!slots.times) {\n        slots.times = { passes: [{}] };\n    }\n\n    const passIndex = slots.fixPasses;\n\n    if (passIndex > slots.times.passes.length - 1) {\n        slots.times.passes.push({});\n    }\n\n    if (key) {\n        slots.times.passes[passIndex][type] ??= {};\n        slots.times.passes[passIndex][type][key] ??= { total: 0 };\n        slots.times.passes[passIndex][type][key].total += time;\n    } else {\n        slots.times.passes[passIndex][type] ??= { total: 0 };\n        slots.times.passes[passIndex][type].total += time;\n    }\n}\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {RuleConfig} ruleConfig rule configuration\n * @param {Object|undefined} defaultOptions rule.meta.defaultOptions\n * @returns {Array} of rule options, empty Array if none\n */\nfunction getRuleOptions(ruleConfig, defaultOptions) {\n    if (Array.isArray(ruleConfig)) {\n        return deepMergeArrays(defaultOptions, ruleConfig.slice(1));\n    }\n    return defaultOptions ?? [];\n}\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {LanguageOptions} languageOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\nfunction analyzeScope(ast, languageOptions, visitorKeys) {\n    const parserOptions = languageOptions.parserOptions;\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\n    const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n\n    return eslintScope.analyze(ast, {\n        ignoreEval: true,\n        nodejsScope: ecmaFeatures.globalReturn,\n        impliedStrict: ecmaFeatures.impliedStrict,\n        ecmaVersion: typeof ecmaVersion === \"number\" ? ecmaVersion : 6,\n        sourceType: languageOptions.sourceType || \"script\",\n        childVisitorKeys: visitorKeys || evk.KEYS,\n        fallback: Traverser.getKeys\n    });\n}\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A rule object\n * @param {Context} ruleContext The context that should be passed to the rule\n * @throws {TypeError} If `rule` is not an object with a `create` method\n * @throws {any} Any error during the rule's `create`\n * @returns {Object} A map of selector listeners provided by the rule\n */\nfunction createRuleListeners(rule, ruleContext) {\n\n    if (!rule || typeof rule !== \"object\" || typeof rule.create !== \"function\") {\n        throw new TypeError(`Error while loading rule '${ruleContext.id}': Rule must be an object with a \\`create\\` method`);\n    }\n\n    try {\n        return rule.create(ruleContext);\n    } catch (ex) {\n        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n        throw ex;\n    }\n}\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {string | undefined} parserName The name of the parser in the config\n * @param {Language} language The language object used for parsing.\n * @param {LanguageOptions} languageOptions The options for parsing the code.\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} applyDefaultOptions If true, apply rules' meta.defaultOptions in computing their config options.\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @param {string} physicalFilename The full path of the file on disk without any code block information\n * @param {Function} ruleFilter A predicate function to filter which rules should be executed.\n * @param {boolean} stats If true, stats are collected appended to the result\n * @param {WeakMap<Linter, LinterInternalSlots>} slots InternalSlotsMap of linter\n * @returns {LintMessage[]} An array of reported problems\n * @throws {Error} If traversal into a node fails.\n */\nfunction runRules(\n    sourceCode,\n    configuredRules,\n    ruleMapper,\n    parserName,\n    language,\n    languageOptions,\n    settings,\n    filename,\n    applyDefaultOptions,\n    disableFixes,\n    cwd,\n    physicalFilename,\n    ruleFilter,\n    stats,\n    slots\n) {\n    const emitter = createEmitter();\n\n    // must happen first to assign all node.parent properties\n    const eventQueue = sourceCode.traverse();\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n    const sharedTraversalContext = new FileContext({\n        cwd,\n        filename,\n        physicalFilename: physicalFilename || filename,\n        sourceCode,\n        parserOptions: {\n            ...languageOptions.parserOptions\n        },\n        parserPath: parserName,\n        languageOptions,\n        settings\n    });\n\n    const lintingProblems = [];\n\n    Object.keys(configuredRules).forEach(ruleId => {\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\n\n        // not load disabled rules\n        if (severity === 0) {\n            return;\n        }\n\n        if (ruleFilter && !ruleFilter({ ruleId, severity })) {\n            return;\n        }\n\n        const rule = ruleMapper(ruleId);\n\n        if (!rule) {\n            lintingProblems.push(createLintingProblem({ ruleId, language }));\n            return;\n        }\n\n        const messageIds = rule.meta && rule.meta.messages;\n        let reportTranslator = null;\n        const ruleContext = Object.freeze(\n            Object.assign(\n                Object.create(sharedTraversalContext),\n                {\n                    id: ruleId,\n                    options: getRuleOptions(configuredRules[ruleId], applyDefaultOptions ? rule.meta?.defaultOptions : void 0),\n                    report(...args) {\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n                        if (reportTranslator === null) {\n                            reportTranslator = createReportTranslator({\n                                ruleId,\n                                severity,\n                                sourceCode,\n                                messageIds,\n                                disableFixes,\n                                language\n                            });\n                        }\n                        const problem = reportTranslator(...args);\n\n                        if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n                            throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n                        }\n                        if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {\n                            if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== \"undefined\") {\n\n                                // Encourage migration from the former property name.\n                                throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.\");\n                            }\n                            throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`.\");\n                        }\n                        lintingProblems.push(problem);\n                    }\n                }\n            )\n        );\n\n        const ruleListenersReturn = (timing.enabled || stats)\n            ? timing.time(ruleId, createRuleListeners, stats)(rule, ruleContext) : createRuleListeners(rule, ruleContext);\n\n        const ruleListeners = stats ? ruleListenersReturn.result : ruleListenersReturn;\n\n        if (stats) {\n            storeTime(ruleListenersReturn.tdiff, { type: \"rules\", key: ruleId }, slots);\n        }\n\n        /**\n         * Include `ruleId` in error logs\n         * @param {Function} ruleListener A rule method that listens for a node.\n         * @returns {Function} ruleListener wrapped in error handler\n         */\n        function addRuleErrorHandler(ruleListener) {\n            return function ruleErrorHandler(...listenerArgs) {\n                try {\n                    const ruleListenerReturn = ruleListener(...listenerArgs);\n\n                    const ruleListenerResult = stats ? ruleListenerReturn.result : ruleListenerReturn;\n\n                    if (stats) {\n                        storeTime(ruleListenerReturn.tdiff, { type: \"rules\", key: ruleId }, slots);\n                    }\n\n                    return ruleListenerResult;\n                } catch (e) {\n                    e.ruleId = ruleId;\n                    throw e;\n                }\n            };\n        }\n\n        if (typeof ruleListeners === \"undefined\" || ruleListeners === null) {\n            throw new Error(`The create() function for rule '${ruleId}' did not return an object.`);\n        }\n\n        // add all the selectors from the rule as listeners\n        Object.keys(ruleListeners).forEach(selector => {\n            const ruleListener = (timing.enabled || stats)\n                ? timing.time(ruleId, ruleListeners[selector], stats) : ruleListeners[selector];\n\n            emitter.on(\n                selector,\n                addRuleErrorHandler(ruleListener)\n            );\n        });\n    });\n\n    const eventGenerator = new NodeEventGenerator(emitter, {\n        visitorKeys: sourceCode.visitorKeys ?? language.visitorKeys,\n        fallback: Traverser.getKeys,\n        matchClass: language.matchesSelectorClass ?? (() => false),\n        nodeTypeKey: language.nodeTypeKey\n    });\n\n    for (const step of eventQueue) {\n        switch (step.kind) {\n            case STEP_KIND_VISIT: {\n                try {\n                    if (step.phase === 1) {\n                        eventGenerator.enterNode(step.target);\n                    } else {\n                        eventGenerator.leaveNode(step.target);\n                    }\n                } catch (err) {\n                    err.currentNode = step.target;\n                    throw err;\n                }\n                break;\n            }\n\n            case STEP_KIND_CALL: {\n                emitter.emit(step.target, ...step.args);\n                break;\n            }\n\n            default:\n                throw new Error(`Invalid traversal step found: \"${step.type}\".`);\n        }\n\n    }\n\n    return lintingProblems;\n}\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\nfunction ensureText(textOrSourceCode) {\n    if (typeof textOrSourceCode === \"object\") {\n        const { hasBOM, text } = textOrSourceCode;\n        const bom = hasBOM ? \"\\uFEFF\" : \"\";\n\n        return bom + text;\n    }\n\n    return String(textOrSourceCode);\n}\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\nfunction getEnv(slots, envId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId)) ||\n        BuiltInEnvironments.get(envId) ||\n        null\n    );\n}\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\nfunction getRule(slots, ruleId) {\n    return (\n        (slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId)) ||\n        slots.ruleMap.get(ruleId)\n    );\n}\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\nfunction normalizeCwd(cwd) {\n    if (cwd) {\n        return cwd;\n    }\n    if (typeof process === \"object\") {\n        return process.cwd();\n    }\n\n    // It's more explicit to assign the undefined\n    // eslint-disable-next-line no-undefined -- Consistently returning a value\n    return undefined;\n}\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\nconst internalSlotsMap = new WeakMap();\n\n/**\n * Throws an error when the given linter is in flat config mode.\n * @param {Linter} linter The linter to check.\n * @returns {void}\n * @throws {Error} If the linter is in flat config mode.\n */\nfunction assertEslintrcConfig(linter) {\n    const { configType } = internalSlotsMap.get(linter);\n\n    if (configType === \"flat\") {\n        throw new Error(\"This method cannot be used with flat config. Add your entries directly into the config array.\");\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name Linter\n */\nclass Linter {\n\n    /**\n     * Initialize the Linter.\n     * @param {Object} [config] the config object\n     * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.\n     * @param {Array<string>} [config.flags] the feature flags to enable.\n     * @param {\"flat\"|\"eslintrc\"} [config.configType=\"flat\"] the type of config used.\n     */\n    constructor({ cwd, configType = \"flat\", flags = [] } = {}) {\n\n        const processedFlags = [];\n\n        flags.forEach(flag => {\n            if (inactiveFlags.has(flag)) {\n                const inactiveFlagData = inactiveFlags.get(flag);\n                const inactivityReason = getInactivityReasonMessage(inactiveFlagData);\n\n                if (typeof inactiveFlagData.replacedBy === \"undefined\") {\n                    throw new Error(`The flag '${flag}' is inactive: ${inactivityReason}`);\n                }\n\n                // if there's a replacement, enable it instead of original\n                if (typeof inactiveFlagData.replacedBy === \"string\") {\n                    processedFlags.push(inactiveFlagData.replacedBy);\n                }\n\n                globalThis.process?.emitWarning?.(\n                    `The flag '${flag}' is inactive: ${inactivityReason}`,\n                    `ESLintInactiveFlag_${flag}`\n                );\n\n                return;\n            }\n\n            if (!activeFlags.has(flag)) {\n                throw new Error(`Unknown flag '${flag}'.`);\n            }\n\n            processedFlags.push(flag);\n        });\n\n        internalSlotsMap.set(this, {\n            cwd: normalizeCwd(cwd),\n            flags: processedFlags,\n            lastConfigArray: null,\n            lastSourceCode: null,\n            lastSuppressedMessages: [],\n            configType, // TODO: Remove after flat config conversion\n            parserMap: new Map([[\"espree\", espree]]),\n            ruleMap: new Rules()\n        });\n\n        this.version = pkg.version;\n    }\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n    static get version() {\n        return pkg.version;\n    }\n\n    /**\n     * Indicates if the given feature flag is enabled for this instance.\n     * @param {string} flag The feature flag to check.\n     * @returns {boolean} `true` if the feature flag is enabled, `false` if not.\n     */\n    hasFlag(flag) {\n        return internalSlotsMap.get(this).flags.includes(flag);\n    }\n\n    /**\n     * Lint using eslintrc and without processors.\n     * @param {VFile} file The file to lint.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n    #eslintrcVerifyWithoutProcessors(file, providedConfig, providedOptions) {\n\n        const slots = internalSlotsMap.get(this);\n        const config = providedConfig || {};\n        const options = normalizeVerifyOptions(providedOptions, config);\n\n        // Resolve parser.\n        let parserName = DEFAULT_PARSER_NAME;\n        let parser = espree;\n\n        if (typeof config.parser === \"object\" && config.parser !== null) {\n            parserName = config.parser.filePath;\n            parser = config.parser.definition;\n        } else if (typeof config.parser === \"string\") {\n            if (!slots.parserMap.has(config.parser)) {\n                return [{\n                    ruleId: null,\n                    fatal: true,\n                    severity: 2,\n                    message: `Configured parser '${config.parser}' was not found.`,\n                    line: 0,\n                    column: 0,\n                    nodeType: null\n                }];\n            }\n            parserName = config.parser;\n            parser = slots.parserMap.get(config.parser);\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = options.allowInlineConfig && !options.warnInlineConfig\n            ? findEslintEnv(file.body)\n            : {};\n        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);\n        const enabledEnvs = Object.keys(resolvedEnvConfig)\n            .filter(envName => resolvedEnvConfig[envName])\n            .map(envName => getEnv(slots, envName))\n            .filter(env => env);\n\n        const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n        const settings = config.settings || {};\n        const languageOptions = createLanguageOptions({\n            globals: config.globals,\n            parser,\n            parserOptions\n        });\n\n        if (!slots.lastSourceCode) {\n            let t;\n\n            if (options.stats) {\n                t = startTime();\n            }\n\n            const parserService = new ParserService();\n            const parseResult = parserService.parseSync(\n                file,\n                {\n                    language: jslang,\n                    languageOptions\n                }\n            );\n\n            if (options.stats) {\n                const time = endTime(t);\n                const timeOpts = { type: \"parse\" };\n\n                storeTime(time, timeOpts, slots);\n            }\n\n            if (!parseResult.ok) {\n                return parseResult.errors;\n            }\n\n            slots.lastSourceCode = parseResult.sourceCode;\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n            if (!slots.lastSourceCode.scopeManager) {\n                slots.lastSourceCode = new SourceCode({\n                    text: slots.lastSourceCode.text,\n                    ast: slots.lastSourceCode.ast,\n                    hasBOM: slots.lastSourceCode.hasBOM,\n                    parserServices: slots.lastSourceCode.parserServices,\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n                });\n            }\n        }\n\n        const sourceCode = slots.lastSourceCode;\n        const commentDirectives = options.allowInlineConfig\n            ? getDirectiveComments(sourceCode, ruleId => getRule(slots, ruleId), options.warnInlineConfig, config)\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\n\n        addDeclaredGlobals(\n            sourceCode.scopeManager.scopes[0],\n            configuredGlobals,\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\n        );\n\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n\n        let lintingProblems;\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => getRule(slots, ruleId),\n                parserName,\n                jslang,\n                languageOptions,\n                settings,\n                options.filename,\n                true,\n                options.disableFixes,\n                slots.cwd,\n                providedOptions.physicalFilename,\n                null,\n                options.stats,\n                slots\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = sourceCode.getLoc(err.currentNode).start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", parserOptions);\n            debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n\n            if (err.ruleId) {\n                err.message += `\\nRule: \"${err.ruleId}\"`;\n            }\n\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            language: jslang,\n            sourceCode,\n            directives: commentDirectives.disableDirectives,\n            disableFixes: options.disableFixes,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n        });\n\n    }\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n        const slots = internalSlotsMap.get(this);\n        const filename = normalizeFilename(providedOptions.filename || \"<input>\");\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            slots.lastSourceCode = null;\n            text = textOrSourceCode;\n        } else {\n            slots.lastSourceCode = textOrSourceCode;\n            text = textOrSourceCode.text;\n        }\n\n        const file = new VFile(filename, text, {\n            physicalPath: providedOptions.physicalFilename\n        });\n\n        return this.#eslintrcVerifyWithoutProcessors(file, providedConfig, providedOptions);\n    }\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n    verify(textOrSourceCode, config, filenameOrOptions) {\n        debug(\"Verify\");\n\n        const { configType, cwd } = internalSlotsMap.get(this);\n\n        const options = typeof filenameOrOptions === \"string\"\n            ? { filename: filenameOrOptions }\n            : filenameOrOptions || {};\n\n        const configToUse = config ?? {};\n\n        if (configType !== \"eslintrc\") {\n\n            /*\n             * Because of how Webpack packages up the files, we can't\n             * compare directly to `FlatConfigArray` using `instanceof`\n             * because it's not the same `FlatConfigArray` as in the tests.\n             * So, we work around it by assuming an array is, in fact, a\n             * `FlatConfigArray` if it has a `getConfig()` method.\n             */\n            let configArray = configToUse;\n\n            if (!Array.isArray(configToUse) || typeof configToUse.getConfig !== \"function\") {\n                configArray = new FlatConfigArray(configToUse, { basePath: cwd });\n                configArray.normalizeSync();\n            }\n\n            return this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(textOrSourceCode, configArray, options, true));\n        }\n\n        if (typeof configToUse.extractConfig === \"function\") {\n            return this._distinguishSuppressedMessages(this._verifyWithConfigArray(textOrSourceCode, configToUse, options));\n        }\n\n        /*\n         * If we get to here, it means `config` is just an object rather\n         * than a config array so we can go right into linting.\n         */\n\n        /*\n         * `Linter` doesn't support `overrides` property in configuration.\n         * So we cannot apply multiple processors.\n         */\n        if (options.preprocess || options.postprocess) {\n            return this._distinguishSuppressedMessages(this._verifyWithProcessor(textOrSourceCode, configToUse, options));\n        }\n        return this._distinguishSuppressedMessages(this._verifyWithoutProcessors(textOrSourceCode, configToUse, options));\n    }\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {FlatConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options, configForRecursive) {\n        const slots = internalSlotsMap.get(this);\n        const filename = options.filename || \"<input>\";\n        const filenameToExpose = normalizeFilename(filename);\n        const physicalFilename = options.physicalFilename || filenameToExpose;\n        const text = ensureText(textOrSourceCode);\n        const file = new VFile(filenameToExpose, text, {\n            physicalPath: physicalFilename\n        });\n\n        const preprocess = options.preprocess || (rawText => [rawText]);\n        const postprocess = options.postprocess || (messagesList => messagesList.flat());\n\n        const processorService = new ProcessorService();\n        const preprocessResult = processorService.preprocessSync(file, {\n            processor: {\n                preprocess,\n                postprocess\n            }\n        });\n\n        if (!preprocessResult.ok) {\n            return preprocessResult.errors;\n        }\n\n        const filterCodeBlock =\n            options.filterCodeBlock ||\n            (blockFilename => blockFilename.endsWith(\".js\"));\n        const originalExtname = path.extname(filename);\n        const { files } = preprocessResult;\n\n        const messageLists = files.map(block => {\n            debug(\"A code block was found: %o\", block.path || \"(unnamed)\");\n\n            // Keep the legacy behavior.\n            if (typeof block === \"string\") {\n                return this._verifyWithFlatConfigArrayAndWithoutProcessors(block, config, options);\n            }\n\n            // Skip this block if filtered.\n            if (!filterCodeBlock(block.path, block.body)) {\n                debug(\"This code block was skipped.\");\n                return [];\n            }\n\n            // Resolve configuration again if the file content or extension was changed.\n            if (configForRecursive && (text !== block.rawBody || path.extname(block.path) !== originalExtname)) {\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\n                return this._verifyWithFlatConfigArray(\n                    block.rawBody,\n                    configForRecursive,\n                    { ...options, filename: block.path, physicalFilename: block.physicalPath }\n                );\n            }\n\n            slots.lastSourceCode = null;\n\n            // Does lint.\n            return this.#flatVerifyWithoutProcessors(\n                block,\n                config,\n                { ...options, filename: block.path, physicalFilename: block.physicalPath }\n            );\n        });\n\n        return processorService.postprocessSync(file, messageLists, {\n            processor: {\n                preprocess,\n                postprocess\n            }\n        });\n    }\n\n    /**\n     * Verify using flat config and without any processors.\n     * @param {VFile} file The file to lint.\n     * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n    #flatVerifyWithoutProcessors(file, providedConfig, providedOptions) {\n\n        const slots = internalSlotsMap.get(this);\n        const config = providedConfig || {};\n        const { settings = {}, languageOptions } = config;\n        const options = normalizeVerifyOptions(providedOptions, config);\n\n        if (!slots.lastSourceCode) {\n            let t;\n\n            if (options.stats) {\n                t = startTime();\n            }\n\n            const parserService = new ParserService();\n            const parseResult = parserService.parseSync(\n                file,\n                config\n            );\n\n            if (options.stats) {\n                const time = endTime(t);\n\n                storeTime(time, { type: \"parse\" }, slots);\n            }\n\n            if (!parseResult.ok) {\n                return parseResult.errors;\n            }\n\n            slots.lastSourceCode = parseResult.sourceCode;\n        } else {\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             *\n             * We check explicitly for `null` to ensure that this is a JS-flavored language.\n             * For non-JS languages we don't want to do this.\n             *\n             * TODO: Remove this check when we stop exporting the `SourceCode` object.\n             */\n            if (slots.lastSourceCode.scopeManager === null) {\n                slots.lastSourceCode = new SourceCode({\n                    text: slots.lastSourceCode.text,\n                    ast: slots.lastSourceCode.ast,\n                    hasBOM: slots.lastSourceCode.hasBOM,\n                    parserServices: slots.lastSourceCode.parserServices,\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n                });\n            }\n        }\n\n        const sourceCode = slots.lastSourceCode;\n\n        /*\n         * Make adjustments based on the language options. For JavaScript,\n         * this is primarily about adding variables into the global scope\n         * to account for ecmaVersion and configured globals.\n         */\n        sourceCode.applyLanguageOptions?.(languageOptions);\n\n        const mergedInlineConfig = {\n            rules: {}\n        };\n        const inlineConfigProblems = [];\n\n        /*\n         * Inline config can be either enabled or disabled. If disabled, it's possible\n         * to detect the inline config and emit a warning (though this is not required).\n         * So we first check to see if inline config is allowed at all, and if so, we\n         * need to check if it's a warning or not.\n         */\n        if (options.allowInlineConfig) {\n\n            // if inline config should warn then add the warnings\n            if (options.warnInlineConfig) {\n                if (sourceCode.getInlineConfigNodes) {\n                    sourceCode.getInlineConfigNodes().forEach(node => {\n\n                        const loc = sourceCode.getLoc(node);\n                        const range = sourceCode.getRange(node);\n\n                        inlineConfigProblems.push(createLintingProblem({\n                            ruleId: null,\n                            message: `'${sourceCode.text.slice(range[0], range[1])}' has no effect because you have 'noInlineConfig' setting in ${options.warnInlineConfig}.`,\n                            loc,\n                            severity: 1,\n                            language: config.language\n                        }));\n\n                    });\n                }\n            } else {\n                const inlineConfigResult = sourceCode.applyInlineConfig?.();\n\n                if (inlineConfigResult) {\n                    inlineConfigProblems.push(\n                        ...inlineConfigResult.problems\n                            .map(problem => createLintingProblem({ ...problem, language: config.language }))\n                            .map(problem => {\n                                problem.fatal = true;\n                                return problem;\n                            })\n                    );\n\n                    // next we need to verify information about the specified rules\n                    const ruleValidator = new RuleValidator();\n\n                    for (const { config: inlineConfig, loc } of inlineConfigResult.configs) {\n\n                        Object.keys(inlineConfig.rules).forEach(ruleId => {\n                            const rule = getRuleFromConfig(ruleId, config);\n                            const ruleValue = inlineConfig.rules[ruleId];\n\n                            if (!rule) {\n                                inlineConfigProblems.push(createLintingProblem({\n                                    ruleId,\n                                    loc,\n                                    language: config.language\n                                }));\n                                return;\n                            }\n\n                            if (Object.hasOwn(mergedInlineConfig.rules, ruleId)) {\n                                inlineConfigProblems.push(createLintingProblem({\n                                    message: `Rule \"${ruleId}\" is already configured by another configuration comment in the preceding code. This configuration is ignored.`,\n                                    loc,\n                                    language: config.language\n                                }));\n                                return;\n                            }\n\n                            try {\n\n                                const ruleOptionsInline = asArray(ruleValue);\n                                let ruleOptions = ruleOptionsInline;\n\n                                assertIsRuleSeverity(ruleId, ruleOptions[0]);\n\n                                /*\n                                 * If the rule was already configured, inline rule configuration that\n                                 * only has severity should retain options from the config and just override the severity.\n                                 *\n                                 * Example:\n                                 *\n                                 *   {\n                                 *       rules: {\n                                 *           curly: [\"error\", \"multi\"]\n                                 *       }\n                                 *   }\n                                 *\n                                 *   /* eslint curly: [\"warn\"] * /\n                                 *\n                                 *   Results in:\n                                 *\n                                 *   curly: [\"warn\", \"multi\"]\n                                 */\n\n                                let shouldValidateOptions = true;\n\n                                if (\n\n                                    /*\n                                     * If inline config for the rule has only severity\n                                     */\n                                    ruleOptions.length === 1 &&\n\n                                    /*\n                                     * And the rule was already configured\n                                     */\n                                    config.rules && Object.hasOwn(config.rules, ruleId)\n                                ) {\n\n                                    /*\n                                     * Then use severity from the inline config and options from the provided config\n                                     */\n                                    ruleOptions = [\n                                        ruleOptions[0], // severity from the inline config\n                                        ...config.rules[ruleId].slice(1) // options from the provided config\n                                    ];\n\n                                    // if the rule was enabled, the options have already been validated\n                                    if (config.rules[ruleId][0] > 0) {\n                                        shouldValidateOptions = false;\n                                    }\n                                } else {\n\n                                    /**\n                                     * Since we know the user provided options, apply defaults on top of them\n                                     */\n                                    const slicedOptions = ruleOptions.slice(1);\n                                    const mergedOptions = deepMergeArrays(rule.meta?.defaultOptions, slicedOptions);\n\n                                    if (mergedOptions.length) {\n                                        ruleOptions = [ruleOptions[0], ...mergedOptions];\n                                    }\n                                }\n\n                                if (options.reportUnusedInlineConfigs !== \"off\") {\n                                    addProblemIfSameSeverityAndOptions(\n                                        config, loc, inlineConfigProblems, ruleId, ruleOptions, ruleOptionsInline, options.reportUnusedInlineConfigs\n                                    );\n                                }\n\n                                if (shouldValidateOptions) {\n                                    ruleValidator.validate({\n                                        plugins: config.plugins,\n                                        rules: {\n                                            [ruleId]: ruleOptions\n                                        }\n                                    });\n                                }\n\n                                mergedInlineConfig.rules[ruleId] = ruleOptions;\n                            } catch (err) {\n\n                                /*\n                                 * If the rule has invalid `meta.schema`, throw the error because\n                                 * this is not an invalid inline configuration but an invalid rule.\n                                 */\n                                if (err.code === \"ESLINT_INVALID_RULE_OPTIONS_SCHEMA\") {\n                                    throw err;\n                                }\n\n                                let baseMessage = err.message.slice(\n                                    err.message.startsWith(\"Key \\\"rules\\\":\")\n                                        ? err.message.indexOf(\":\", 12) + 1\n                                        : err.message.indexOf(\":\") + 1\n                                ).trim();\n\n                                if (err.messageTemplate) {\n                                    baseMessage += ` You passed \"${ruleValue}\".`;\n                                }\n\n                                inlineConfigProblems.push(createLintingProblem({\n                                    ruleId,\n                                    message: `Inline configuration for rule \"${ruleId}\" is invalid:\\n\\t${baseMessage}\\n`,\n                                    loc,\n                                    language: config.language\n                                }));\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        const commentDirectives = options.allowInlineConfig && !options.warnInlineConfig\n            ? getDirectiveCommentsForFlatConfig(\n                sourceCode,\n                ruleId => getRuleFromConfig(ruleId, config),\n                config.language\n            )\n            : { problems: [], disableDirectives: [] };\n\n        const configuredRules = Object.assign({}, config.rules, mergedInlineConfig.rules);\n\n        let lintingProblems;\n\n        sourceCode.finalize?.();\n\n        try {\n            lintingProblems = runRules(\n                sourceCode,\n                configuredRules,\n                ruleId => getRuleFromConfig(ruleId, config),\n                void 0,\n                config.language,\n                languageOptions,\n                settings,\n                options.filename,\n                false,\n                options.disableFixes,\n                slots.cwd,\n                providedOptions.physicalFilename,\n                options.ruleFilter,\n                options.stats,\n                slots\n            );\n        } catch (err) {\n            err.message += `\\nOccurred while linting ${options.filename}`;\n            debug(\"An error occurred while traversing\");\n            debug(\"Filename:\", options.filename);\n            if (err.currentNode) {\n                const { line } = sourceCode.getLoc(err.currentNode).start;\n\n                debug(\"Line:\", line);\n                err.message += `:${line}`;\n            }\n            debug(\"Parser Options:\", languageOptions.parserOptions);\n\n            // debug(\"Parser Path:\", parserName);\n            debug(\"Settings:\", settings);\n\n            if (err.ruleId) {\n                err.message += `\\nRule: \"${err.ruleId}\"`;\n            }\n\n            throw err;\n        }\n\n        return applyDisableDirectives({\n            language: config.language,\n            sourceCode,\n            directives: commentDirectives.disableDirectives,\n            disableFixes: options.disableFixes,\n            problems: lintingProblems\n                .concat(commentDirectives.problems)\n                .concat(inlineConfigProblems)\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives,\n            ruleFilter: options.ruleFilter,\n            configuredRules\n        });\n\n\n    }\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n    _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n        const slots = internalSlotsMap.get(this);\n        const filename = normalizeFilename(providedOptions.filename || \"<input>\");\n        let text;\n\n        // evaluate arguments\n        if (typeof textOrSourceCode === \"string\") {\n            slots.lastSourceCode = null;\n            text = textOrSourceCode;\n        } else {\n            slots.lastSourceCode = textOrSourceCode;\n            text = textOrSourceCode.text;\n        }\n\n        const file = new VFile(filename, text, {\n            physicalPath: providedOptions.physicalFilename\n        });\n\n        return this.#flatVerifyWithoutProcessors(file, providedConfig, providedOptions);\n    }\n\n    /**\n     * Verify a given code with `ConfigArray`.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n        debug(\"With ConfigArray: %s\", options.filename);\n\n        // Store the config array in order to get plugin envs and rules later.\n        internalSlotsMap.get(this).lastConfigArray = configArray;\n\n        // Extract the final config for this file.\n        const config = configArray.extractConfig(options.filename);\n        const processor =\n            config.processor &&\n            configArray.pluginProcessors.get(config.processor);\n\n        // Verify.\n        if (processor) {\n            debug(\"Apply the processor: %o\", config.processor);\n            const { preprocess, postprocess, supportsAutofix } = processor;\n            const disableFixes = options.disableFixes || !supportsAutofix;\n\n            return this._verifyWithProcessor(\n                textOrSourceCode,\n                config,\n                { ...options, disableFixes, postprocess, preprocess },\n                configArray\n            );\n        }\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify a given code with a flat config.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {FlatConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {boolean} [firstCall=false] Indicates if this is being called directly\n     *      from verify(). (TODO: Remove once eslintrc is removed.)\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithFlatConfigArray(textOrSourceCode, configArray, options, firstCall = false) {\n        debug(\"With flat config: %s\", options.filename);\n\n        // we need a filename to match configs against\n        const filename = options.filename || \"__placeholder__.js\";\n\n        // Store the config array in order to get plugin envs and rules later.\n        internalSlotsMap.get(this).lastConfigArray = configArray;\n        const config = configArray.getConfig(filename);\n\n        if (!config) {\n            return [\n                {\n                    ruleId: null,\n                    severity: 1,\n                    message: `No matching configuration found for ${filename}.`,\n                    line: 0,\n                    column: 0,\n                    nodeType: null\n                }\n            ];\n        }\n\n        // Verify.\n        if (config.processor) {\n            debug(\"Apply the processor: %o\", config.processor);\n            const { preprocess, postprocess, supportsAutofix } = config.processor;\n            const disableFixes = options.disableFixes || !supportsAutofix;\n\n            return this._verifyWithFlatConfigArrayAndProcessor(\n                textOrSourceCode,\n                config,\n                { ...options, filename, disableFixes, postprocess, preprocess },\n                configArray\n            );\n        }\n\n        // check for options-based processing\n        if (firstCall && (options.preprocess || options.postprocess)) {\n            return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options);\n        }\n\n        return this._verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, config, options);\n    }\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigData|ExtractedConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n        const slots = internalSlotsMap.get(this);\n        const filename = options.filename || \"<input>\";\n        const filenameToExpose = normalizeFilename(filename);\n        const physicalFilename = options.physicalFilename || filenameToExpose;\n        const text = ensureText(textOrSourceCode);\n        const file = new VFile(filenameToExpose, text, {\n            physicalPath: physicalFilename\n        });\n\n        const preprocess = options.preprocess || (rawText => [rawText]);\n        const postprocess = options.postprocess || (messagesList => messagesList.flat());\n\n        const processorService = new ProcessorService();\n        const preprocessResult = processorService.preprocessSync(file, {\n            processor: {\n                preprocess,\n                postprocess\n            }\n        });\n\n        if (!preprocessResult.ok) {\n            return preprocessResult.errors;\n        }\n\n        const filterCodeBlock =\n            options.filterCodeBlock ||\n            (blockFilePath => blockFilePath.endsWith(\".js\"));\n        const originalExtname = path.extname(filename);\n\n        const { files } = preprocessResult;\n\n        const messageLists = files.map(block => {\n            debug(\"A code block was found: %o\", block.path ?? \"(unnamed)\");\n\n            // Keep the legacy behavior.\n            if (typeof block === \"string\") {\n                return this._verifyWithoutProcessors(block, config, options);\n            }\n\n            // Skip this block if filtered.\n            if (!filterCodeBlock(block.path, block.body)) {\n                debug(\"This code block was skipped.\");\n                return [];\n            }\n\n            // Resolve configuration again if the file content or extension was changed.\n            if (configForRecursive && (text !== block.rawBody || path.extname(block.path) !== originalExtname)) {\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\n                return this._verifyWithConfigArray(\n                    block.rawBody,\n                    configForRecursive,\n                    { ...options, filename: block.path, physicalFilename: block.physicalPath }\n                );\n            }\n\n            slots.lastSourceCode = null;\n\n            // Does lint.\n            return this.#eslintrcVerifyWithoutProcessors(\n                block,\n                config,\n                { ...options, filename: block.path, physicalFilename: block.physicalPath }\n            );\n        });\n\n        return processorService.postprocessSync(file, messageLists, {\n            processor: {\n                preprocess,\n                postprocess\n            }\n        });\n\n    }\n\n    /**\n     * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.\n     * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.\n     * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.\n     * @returns {LintMessage[]} A list of LintMessage.\n     */\n    _distinguishSuppressedMessages(problems) {\n        const messages = [];\n        const suppressedMessages = [];\n        const slots = internalSlotsMap.get(this);\n\n        for (const problem of problems) {\n            if (problem.suppressions) {\n                suppressedMessages.push(problem);\n            } else {\n                messages.push(problem);\n            }\n        }\n\n        slots.lastSuppressedMessages = suppressedMessages;\n\n        return messages;\n    }\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    getSourceCode() {\n        return internalSlotsMap.get(this).lastSourceCode;\n    }\n\n    /**\n     * Gets the times spent on (parsing, fixing, linting) a file.\n     * @returns {LintTimes} The times.\n     */\n    getTimes() {\n        return internalSlotsMap.get(this).times ?? { passes: [] };\n    }\n\n    /**\n     * Gets the number of autofix passes that were made in the last run.\n     * @returns {number} The number of autofix passes.\n     */\n    getFixPassCount() {\n        return internalSlotsMap.get(this).fixPasses ?? 0;\n    }\n\n    /**\n     * Gets the list of SuppressedLintMessage produced in the last running.\n     * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage\n     */\n    getSuppressedMessages() {\n        return internalSlotsMap.get(this).lastSuppressedMessages;\n    }\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Rule} rule A rule object\n     * @returns {void}\n     */\n    defineRule(ruleId, rule) {\n        assertEslintrcConfig(this);\n        internalSlotsMap.get(this).ruleMap.define(ruleId, rule);\n    }\n\n    /**\n     * Defines many new linting rules.\n     * @param {Record<string, Rule>} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    defineRules(rulesToDefine) {\n        assertEslintrcConfig(this);\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            this.defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    }\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map<string, Rule>} All loaded rules\n     */\n    getRules() {\n        assertEslintrcConfig(this);\n        const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);\n\n        return new Map(function *() {\n            yield* ruleMap;\n\n            if (lastConfigArray) {\n                yield* lastConfigArray.pluginRules;\n            }\n        }());\n    }\n\n    /**\n     * Define a new parser module\n     * @param {string} parserId Name of the parser\n     * @param {Parser} parserModule The parser object\n     * @returns {void}\n     */\n    defineParser(parserId, parserModule) {\n        assertEslintrcConfig(this);\n        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n    }\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n    verifyAndFix(text, config, options) {\n        let messages,\n            fixedResult,\n            fixed = false,\n            passNumber = 0,\n            currentText = text;\n        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n        const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n        const stats = options?.stats;\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n        const slots = internalSlotsMap.get(this);\n\n        // Remove lint times from the last run.\n        if (stats) {\n            delete slots.times;\n            slots.fixPasses = 0;\n        }\n\n        do {\n            passNumber++;\n            let tTotal;\n\n            if (stats) {\n                tTotal = startTime();\n            }\n\n            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n            messages = this.verify(currentText, config, options);\n\n            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n            let t;\n\n            if (stats) {\n                t = startTime();\n            }\n\n            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n\n            if (stats) {\n\n                if (fixedResult.fixed) {\n                    const time = endTime(t);\n\n                    storeTime(time, { type: \"fix\" }, slots);\n                    slots.fixPasses++;\n                } else {\n                    storeTime(0, { type: \"fix\" }, slots);\n                }\n            }\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n            if (messages.length === 1 && messages[0].fatal) {\n                break;\n            }\n\n            // keep track if any fixes were ever applied - important for return value\n            fixed = fixed || fixedResult.fixed;\n\n            // update to use the fixed output instead of the original text\n            currentText = fixedResult.output;\n\n            if (stats) {\n                tTotal = endTime(tTotal);\n                const passIndex = slots.times.passes.length - 1;\n\n                slots.times.passes[passIndex].total = tTotal;\n            }\n\n        } while (\n            fixedResult.fixed &&\n            passNumber < MAX_AUTOFIX_PASSES\n        );\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n        if (fixedResult.fixed) {\n            let tTotal;\n\n            if (stats) {\n                tTotal = startTime();\n            }\n\n            fixedResult.messages = this.verify(currentText, config, options);\n\n            if (stats) {\n                storeTime(0, { type: \"fix\" }, slots);\n                slots.times.passes.at(-1).total = endTime(tTotal);\n            }\n        }\n\n        // ensure the last result properly reflects if fixes were done\n        fixedResult.fixed = fixed;\n        fixedResult.output = currentText;\n\n        return fixedResult;\n    }\n}\n\nmodule.exports = {\n    Linter,\n\n    /**\n     * Get the internal slots of a given Linter instance for tests.\n     * @param {Linter} instance The Linter instance to get.\n     * @returns {LinterInternalSlots} The internal slots.\n     */\n    getLinterInternalSlots(instance) {\n        return internalSlotsMap.get(instance);\n    }\n};\n"
        }
    ]
}