{
    "sourceFile": "node_modules/eslint/lib/linter/code-path-analysis/fork-context.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892212267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"../../shared/assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether or not a given segment is reachable.\n * @param {CodePathSegment} segment The segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates a new segment for each fork in the given context and appends it\n * to the end of the specified range of segments. Ultimately, this ends up calling\n * `new CodePathSegment()` for each of the forks using the `create` argument\n * as a wrapper around special behavior.\n *\n * The `startIndex` and `endIndex` arguments specify a range of segments in\n * `context` that should become `allPrevSegments` for the newly created\n * `CodePathSegment` objects.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates two new segments, `[g, h]`. This `g` is appended to\n * the end of the path from `a`, `c`, and `e`. This `h` is appended to the end of\n * `b`, `d`, and `f`.\n * @param {ForkContext} context An instance from which the previous segments\n *      will be obtained.\n * @param {number} startIndex The index of the first segment in the context\n *      that should be specified as previous segments for the newly created segments.\n * @param {number} endIndex The index of the last segment in the context\n *      that should be specified as previous segments for the newly created segments.\n * @param {Function} create A function that creates new `CodePathSegment`\n *      instances in a particular way. See the `CodePathSegment.new*` methods.\n * @returns {Array<CodePathSegment>} An array of the newly-created segments.\n */\nfunction createSegments(context, startIndex, endIndex, create) {\n\n    /** @type {Array<Array<CodePathSegment>>} */\n    const list = context.segmentsList;\n\n    /*\n     * Both `startIndex` and `endIndex` work the same way: if the number is zero\n     * or more, then the number is used as-is. If the number is negative,\n     * then that number is added to the length of the segments list to\n     * determine the index to use. That means -1 for either argument\n     * is the last element, -2 is the second to last, and so on.\n     *\n     * So if `startIndex` is 0, `endIndex` is -1, and `list.length` is 3, the\n     * effective `startIndex` is 0 and the effective `endIndex` is 2, so this function\n     * will include items at indices 0, 1, and 2.\n     *\n     * Therefore, if `startIndex` is -1 and `endIndex` is -1, that means we'll only\n     * be using the last segment in `list`.\n     */\n    const normalizedBegin = startIndex >= 0 ? startIndex : list.length + startIndex;\n    const normalizedEnd = endIndex >= 0 ? endIndex : list.length + endIndex;\n\n    /** @type {Array<CodePathSegment>} */\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n\n        // this is passed into `new CodePathSegment` to add to code path.\n        const allPrevSegments = [];\n\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        // note: `create` is just a wrapper that augments `new CodePathSegment`.\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * Inside of a `finally` block we end up with two parallel paths. If the code path\n * exits by a control statement (such as `break` or `continue`) from the `finally`\n * block, then we need to merge the remaining parallel paths back into one.\n * @param {ForkContext} context The fork context to work on.\n * @param {Array<CodePathSegment>} segments Segments to merge.\n * @returns {Array<CodePathSegment>} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    let currentSegments = segments;\n\n    /*\n     * We need to ensure that the array returned from this function contains no more\n     * than the number of segments that the context allows. `context.count` indicates\n     * how many items should be in the returned array to ensure that the new segment\n     * entries will line up with the already existing segment entries.\n     */\n    while (currentSegments.length > context.count) {\n        const merged = [];\n\n        /*\n         * Because `context.count` is a factor of 2 inside of a `finally` block,\n         * we can divide the segment count by 2 to merge the paths together.\n         * This loops through each segment in the list and creates a new `CodePathSegment`\n         * that has the segment and the segment two slots away as previous segments.\n         *\n         * If `currentSegments` is [a,b,c,d], this will create new segments e and f, such\n         * that:\n         *\n         * When `i` is 0:\n         * a->e\n         * c->e\n         *\n         * When `i` is 1:\n         * b->f\n         * d->f\n         */\n        for (let i = 0, length = Math.floor(currentSegments.length / 2); i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [currentSegments[i], currentSegments[i + length]]\n            ));\n        }\n\n        /*\n         * Go through the loop condition one more time to see if we have the\n         * number of segments for the context. If not, we'll keep merging paths\n         * of the merged segments until we get there.\n         */\n        currentSegments = merged;\n    }\n\n    return currentSegments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Manages the forking of code paths.\n */\nclass ForkContext {\n\n    /**\n     * Creates a new instance.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @param {ForkContext|null} upper The preceding fork context.\n     * @param {number} count The number of parallel segments in each element\n     *      of `segmentsList`.\n     */\n    constructor(idGenerator, upper, count) {\n\n        /**\n         * The ID generator that will generate segment IDs for any new\n         * segments that are created.\n         * @type {IdGenerator}\n         */\n        this.idGenerator = idGenerator;\n\n        /**\n         * The preceding fork context.\n         * @type {ForkContext|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The number of elements in each element of `segmentsList`. In most\n         * cases, this is 1 but can be 2 when there is a `finally` present,\n         * which forks the code path outside of normal flow. In the case of nested\n         * `finally` blocks, this can be a multiple of 2.\n         * @type {number}\n         */\n        this.count = count;\n\n        /**\n         * The segments within this context. Each element in this array has\n         * `count` elements that represent one step in each fork. For example,\n         * when `segmentsList` is `[[a, b], [c, d], [e, f]]`, there is one path\n         * a->c->e and one path b->d->f, and `count` is 2 because each element\n         * is an array with two elements.\n         * @type {Array<Array<CodePathSegment>>}\n         */\n        this.segmentsList = [];\n    }\n\n    /**\n     * The segments that begin this fork context.\n     * @type {Array<CodePathSegment>}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list.at(-1);\n    }\n\n    /**\n     * Indicates if the context contains no segments.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * Indicates if there are any segments that are reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments in this context and appends them to the end of the\n     * already existing `CodePathSegment`s specified by `startIndex` and\n     * `endIndex`.\n     * @param {number} startIndex The index of the first segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @param {number} endIndex The index of the last segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @returns {Array<CodePathSegment>} An array of the newly created segments.\n     */\n    makeNext(startIndex, endIndex) {\n        return createSegments(this, startIndex, endIndex, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new unreachable segments in this context and appends them to the end of the\n     * already existing `CodePathSegment`s specified by `startIndex` and\n     * `endIndex`.\n     * @param {number} startIndex The index of the first segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @param {number} endIndex The index of the last segment in the context\n     *      that should be specified as previous segments for the newly created segments.\n     * @returns {Array<CodePathSegment>} An array of the newly created segments.\n     */\n    makeUnreachable(startIndex, endIndex) {\n        return createSegments(this, startIndex, endIndex, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments in this context and does not append them to the end\n     *  of the already existing `CodePathSegment`s specified by `startIndex` and\n     * `endIndex`. The `startIndex` and `endIndex` are only used to determine if\n     * the new segments should be reachable. If any of the segments in this range\n     * are reachable then the new segments are also reachable; otherwise, the new\n     * segments are unreachable.\n     * @param {number} startIndex The index of the first segment in the context\n     *      that should be considered for reachability.\n     * @param {number} endIndex The index of the last segment in the context\n     *      that should be considered for reachability.\n     * @returns {Array<CodePathSegment>} An array of the newly created segments.\n     */\n    makeDisconnected(startIndex, endIndex) {\n        return createSegments(this, startIndex, endIndex, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments to the head of this context.\n     * @param {Array<CodePathSegment>} segments The segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with the given segments.\n     * The current head segments are removed.\n     * @param {Array<CodePathSegment>} replacementHeadSegments The new head segments.\n     * @returns {void}\n     */\n    replaceHead(replacementHeadSegments) {\n        assert(\n            replacementHeadSegments.length >= this.count,\n            `${replacementHeadSegments.length} >= ${this.count}`\n        );\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, replacementHeadSegments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     * @param {ForkContext} otherForkContext The fork context to add from.\n     * @returns {void}\n     */\n    addAll(otherForkContext) {\n        assert(otherForkContext.count === this.count);\n        this.segmentsList.push(...otherForkContext.segmentsList);\n    }\n\n    /**\n     * Clears all segments in this context.\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates a new root context, meaning that there are no parent\n     * fork contexts.\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     * @param {ForkContext} parentContext The parent fork context.\n     * @param {boolean} shouldForkLeavingPath Indicates that we are inside of\n     *      a `finally` block and should therefore fork the path that leaves\n     *      `finally`.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, shouldForkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (shouldForkLeavingPath ? 2 : 1) * parentContext.count\n        );\n    }\n}\n\nmodule.exports = ForkContext;\n"
        }
    ]
}