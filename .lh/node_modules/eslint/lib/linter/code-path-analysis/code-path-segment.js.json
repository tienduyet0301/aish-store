{
    "sourceFile": "node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892211829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview The CodePathSegment class.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n *\n * Each segment is arranged in a series of linked lists (implemented by arrays)\n * that keep track of the previous and next segments in a code path. In this way,\n * you can navigate between all segments in any code path so long as you have a\n * reference to any segment in that code path.\n *\n * When first created, the segment is in a detached state, meaning that it knows the\n * segments that came before it but those segments don't know that this new segment\n * follows it. Only when `CodePathSegment#markUsed()` is called on a segment does it\n * officially become part of the code path by updating the previous segments to know\n * that this new segment follows.\n */\nclass CodePathSegment {\n\n    /**\n     * Creates a new instance.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of all next segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of all previous segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n\n                // determines if the segment has been attached to the code path\n                used: false,\n\n                // array of previous segments coming from the end of a loop\n                loopedPrevSegments: []\n            }\n        });\n\n        /* c8 ignore start */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }/* c8 ignore stop */\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.includes(segment);\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a new segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments\n     *      to append to.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be removed.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Marks a given segment as used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n\n            /*\n             * If the segment is reachable, then it's officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is reachable,\n             * it's added to both `nextSegments` and `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n\n            /*\n             * If the segment is not reachable, then it's not officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is not reachable,\n             * it's added only to `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Creates a new array based on an array of segments. If any segment in the\n     * array is unused, then it is replaced by all of its previous segments.\n     * All used segments are returned as-is without replacement.\n     * @param {CodePathSegment[]} segments The array of segments to flatten.\n     * @returns {CodePathSegment[]} The flattened array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = new Set();\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done.has(segment)) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done.has(prevSegment)) {\n                        done.add(prevSegment);\n                    }\n                }\n            } else {\n                done.add(segment);\n            }\n        }\n\n        return [...done];\n    }\n}\n\nmodule.exports = CodePathSegment;\n"
        }
    ]
}