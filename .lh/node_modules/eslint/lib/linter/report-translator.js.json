{
    "sourceFile": "node_modules/eslint/lib/linter/report-translator.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892212754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"../shared/assert\");\nconst { RuleFixer } = require(\"./rule-fixer\");\nconst { interpolate } = require(\"./interpolate\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} args A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall(...args) {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (args.length === 1) {\n\n        // Shallow clone the object to avoid surprises if reusing the descriptor\n        return Object.assign({}, args[0]);\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof args[1] === \"string\") {\n        return {\n            node: args[0],\n            message: args[1],\n            data: args[2],\n            fix: args[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: args[0],\n        loc: args[1],\n        message: args[2],\n        data: args[3],\n        fix: args[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc.start) {\n        return descriptor.loc;\n    }\n    return { start: descriptor.loc, end: null };\n}\n\n/**\n * Clones the given fix object.\n * @param {Fix|null} fix The fix to clone.\n * @returns {Fix|null} Deep cloned fix object or `null` if `null` or `undefined` was passed in.\n */\nfunction cloneFix(fix) {\n    if (!fix) {\n        return null;\n    }\n\n    return {\n        range: [fix.range[0], fix.range[1]],\n        text: fix.text\n    };\n}\n\n/**\n * Check that a fix has a valid range.\n * @param {Fix|null} fix The fix to validate.\n * @returns {void}\n */\nfunction assertValidFix(fix) {\n    if (fix) {\n        assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n    }\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: number[]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    for (const fix of fixes) {\n        assertValidFix(fix);\n    }\n\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return cloneFix(fixes[0]);\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes.at(-1).range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    const ruleFixer = new RuleFixer({ sourceCode });\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n\n    assertValidFix(fix);\n    return cloneFix(fix);\n}\n\n/**\n * Gets an array of suggestion objects from the given descriptor.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\n */\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n        return [];\n    }\n\n    return descriptor.suggest\n        .map(suggestInfo => {\n            const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n\n            return {\n                ...suggestInfo,\n                desc: interpolate(computedDesc, suggestInfo.data),\n                fix: normalizeFixes(suggestInfo, sourceCode)\n            };\n        })\n\n        // Remove suggestions that didn't provide a fix\n        .filter(({ fix }) => fix);\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {Object} options Information about the problem\n * @param {string} options.ruleId Rule ID\n * @param {(0|1|2)} options.severity Rule severity\n * @param {(ASTNode|null)} options.node Node\n * @param {string} options.message Error message\n * @param {string} [options.messageId] The error message ID.\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\n * @param {Language} [options.language] The language to use to adjust line and column offsets.\n * @returns {LintMessage} Information about the report\n */\nfunction createProblem(options) {\n    const { language } = options;\n\n    // calculate offsets based on the language in use\n    const columnOffset = language.columnStart === 1 ? 0 : 1;\n    const lineOffset = language.lineStart === 1 ? 0 : 1;\n\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line + lineOffset,\n        column: options.loc.start.column + columnOffset,\n        nodeType: options.node && options.node.type || null\n    };\n\n    /*\n     * If this isnâ€™t in the conditional, some of the tests fail\n     * because `messageId` is present in the problem object\n     */\n    if (options.messageId) {\n        problem.messageId = options.messageId;\n    }\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line + lineOffset;\n        problem.endColumn = options.loc.end.column + columnOffset;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    if (options.suggestions && options.suggestions.length > 0) {\n        problem.suggestions = options.suggestions;\n    }\n\n    return problem;\n}\n\n/**\n * Validates that suggestions are properly defined. Throws if an error is detected.\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\n * @param {Object} messages Object of meta messages for the rule.\n * @returns {void}\n */\nfunction validateSuggestions(suggest, messages) {\n    if (suggest && Array.isArray(suggest)) {\n        suggest.forEach(suggestion => {\n            if (suggestion.messageId) {\n                const { messageId } = suggestion;\n\n                if (!messages) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n                }\n\n                if (!messages[messageId]) {\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n                }\n\n                if (suggestion.desc) {\n                    throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n                }\n            } else if (!suggestion.desc) {\n                throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n            }\n\n            if (typeof suggestion.fix !== \"function\") {\n                throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n            }\n        });\n    }\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean, language:Language}} metadata Metadata for the reported problem\n * @returns {function(...args): LintMessage} Function that returns information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return (...args) => {\n        const descriptor = normalizeMultiArgReportCall(...args);\n        const messages = metadata.messageIds;\n        const { sourceCode } = metadata;\n\n        assertValidNodeInfo(descriptor);\n\n        let computedMessage;\n\n        if (descriptor.messageId) {\n            if (!messages) {\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n            }\n            const id = descriptor.messageId;\n\n            if (descriptor.message) {\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n            }\n            if (!messages || !Object.hasOwn(messages, id)) {\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n            }\n            computedMessage = messages[id];\n        } else if (descriptor.message) {\n            computedMessage = descriptor.message;\n        } else {\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n        }\n\n        validateSuggestions(descriptor.suggest, messages);\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: interpolate(computedMessage, descriptor.data),\n            messageId: descriptor.messageId,\n            loc: descriptor.loc ? normalizeReportLoc(descriptor) : sourceCode.getLoc(descriptor.node),\n            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, sourceCode),\n            suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, sourceCode, messages),\n            language: metadata.language\n        });\n    };\n};\n"
        }
    ]
}