{
    "sourceFile": "node_modules/eslint/lib/rule-tester/rule-tester.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892213447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Mocha/Jest test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* globals describe, it -- Mocha globals */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    assert = require(\"node:assert\"),\n    util = require(\"node:util\"),\n    path = require(\"node:path\"),\n    equal = require(\"fast-deep-equal\"),\n    Traverser = require(\"../shared/traverser\"),\n    { getRuleOptionsSchema } = require(\"../config/flat-config-helpers\"),\n    { Linter, SourceCodeFixer } = require(\"../linter\"),\n    { interpolate, getPlaceholderMatcher } = require(\"../linter/interpolate\"),\n    stringify = require(\"json-stable-stringify-without-jsonify\");\n\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\nconst { defaultConfig } = require(\"../config/default-config\");\n\nconst ajv = require(\"../shared/ajv\")({ strictDefaults: true });\n\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\nconst { ConfigArraySymbol } = require(\"@eslint/config-array\");\nconst { isSerializable } = require(\"../shared/serialization\");\n\nconst jslang = require(\"../languages/js\");\nconst { SourceCode } = require(\"../languages/js/source-code\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n\n/**\n * A test case that is expected to pass lint.\n * @typedef {Object} ValidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {any[]} [options] Options for the test case.\n * @property {Function} [before] Function to execute before testing the case.\n * @property {Function} [after] Function to execute after testing the case regardless of its result.\n * @property {LanguageOptions} [languageOptions] The language options to use in the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A test case that is expected to fail lint.\n * @typedef {Object} InvalidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\n * @property {any[]} [options] Options for the test case.\n * @property {Function} [before] Function to execute before testing the case.\n * @property {Function} [after] Function to execute after testing the case regardless of its result.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {LanguageOptions} [languageOptions] The language options to use in the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A description of a reported error used in a rule tester test.\n * @typedef {Object} TestCaseError\n * @property {string | RegExp} [message] Message.\n * @property {string} [messageId] Message ID.\n * @property {string} [type] The type of the reported AST node.\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\n * @property {number} [line] The 1-based line number of the reported start location.\n * @property {number} [column] The 1-based column number of the reported start location.\n * @property {number} [endLine] The 1-based line number of the reported end location.\n * @property {number} [endColumn] The 1-based column number of the reported end location.\n */\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\n\n/*\n * RuleTester uses this config as its default. This can be overwritten via\n * setDefaultConfig().\n */\nlet sharedDefaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"name\",\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"before\",\n    \"after\",\n    \"errors\",\n    \"output\",\n    \"only\"\n];\n\n/*\n * All allowed property names in error objects.\n */\nconst errorObjectParameters = new Set([\n    \"message\",\n    \"messageId\",\n    \"data\",\n    \"type\",\n    \"line\",\n    \"column\",\n    \"endLine\",\n    \"endColumn\",\n    \"suggestions\"\n]);\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\n/*\n * All allowed property names in suggestion objects.\n */\nconst suggestionObjectParameters = new Set([\n    \"desc\",\n    \"messageId\",\n    \"data\",\n    \"output\"\n]);\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\n/*\n * Ignored test case properties when checking for test case duplicates.\n */\nconst duplicationIgnoredParameters = new Set([\n    \"name\",\n    \"errors\",\n    \"output\"\n]);\n\nconst forbiddenMethods = [\n    \"applyInlineConfig\",\n    \"applyLanguageOptions\",\n    \"finalize\"\n];\n\n/** @type {Map<string,WeakSet>} */\nconst forbiddenMethodCalls = new Map(forbiddenMethods.map(methodName => ([methodName, new WeakSet()])));\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\nfunction sanitize(text) {\n    if (typeof text !== \"string\") {\n        return \"\";\n    }\n    return text.replace(\n        /[\\u0000-\\u0009\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls\n        c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`\n    );\n}\n\n/**\n * Define `start`/`end` properties as throwing error.\n * @param {string} objName Object name used for error messages.\n * @param {ASTNode} node The node to define.\n * @returns {void}\n */\nfunction defineStartEndAsError(objName, node) {\n    Object.defineProperties(node, {\n        start: {\n            get() {\n                throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\n            },\n            configurable: true,\n            enumerable: false\n        },\n        end: {\n            get() {\n                throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\n            },\n            configurable: true,\n            enumerable: false\n        }\n    });\n}\n\n\n/**\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\n * @returns {void}\n */\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\n    Traverser.traverse(ast, { visitorKeys, enter: defineStartEndAsError.bind(null, \"node\") });\n    ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\n    ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\n}\n\n/**\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\n * @param {Parser} parser Parser object.\n * @returns {Parser} Wrapped parser object.\n */\nfunction wrapParser(parser) {\n\n    if (typeof parser.parseForESLint === \"function\") {\n        return {\n            [parserSymbol]: parser,\n            parseForESLint(...args) {\n                const ret = parser.parseForESLint(...args);\n\n                defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\n                return ret;\n            }\n        };\n    }\n\n    return {\n        [parserSymbol]: parser,\n        parse(...args) {\n            const ast = parser.parse(...args);\n\n            defineStartEndAsErrorInTree(ast);\n            return ast;\n        }\n    };\n}\n\n/**\n * Function to replace forbidden `SourceCode` methods. Allows just one call per method.\n * @param {string} methodName The name of the method to forbid.\n * @param {Function} prototype The prototype with the original method to call.\n * @returns {Function} The function that throws the error.\n */\nfunction throwForbiddenMethodError(methodName, prototype) {\n\n    const original = prototype[methodName];\n\n    return function(...args) {\n\n        const called = forbiddenMethodCalls.get(methodName);\n\n        /* eslint-disable no-invalid-this -- needed to operate as a method. */\n        if (!called.has(this)) {\n            called.add(this);\n\n            return original.apply(this, args);\n        }\n        /* eslint-enable no-invalid-this -- not needed past this point */\n\n        throw new Error(\n            `\\`SourceCode#${methodName}()\\` cannot be called inside a rule.`\n        );\n    };\n}\n\n/**\n * Extracts names of {{ placeholders }} from the reported message.\n * @param   {string} message Reported message\n * @returns {string[]} Array of placeholder names\n */\nfunction getMessagePlaceholders(message) {\n    const matcher = getPlaceholderMatcher();\n\n    return Array.from(message.matchAll(matcher), ([, name]) => name.trim());\n}\n\n/**\n * Returns the placeholders in the reported messages but\n * only includes the placeholders available in the raw message and not in the provided data.\n * @param {string} message The reported message\n * @param {string} raw The raw message specified in the rule meta.messages\n * @param {undefined|Record<unknown, unknown>} data The passed\n * @returns {string[]} Missing placeholder names\n */\nfunction getUnsubstitutedMessagePlaceholders(message, raw, data = {}) {\n    const unsubstituted = getMessagePlaceholders(message);\n\n    if (unsubstituted.length === 0) {\n        return [];\n    }\n\n    // Remove false positives by only counting placeholders in the raw message, which were not provided in the data matcher or added with a data property\n    const known = getMessagePlaceholders(raw);\n    const provided = Object.keys(data);\n\n    return unsubstituted.filter(name => known.includes(name) && !provided.includes(name));\n}\n\nconst metaSchemaDescription = `\n\\t- If the rule has options, set \\`meta.schema\\` to an array or non-empty object to enable options validation.\n\\t- If the rule doesn't have options, omit \\`meta.schema\\` to enforce that no options can be passed to the rule.\n\\t- You can also set \\`meta.schema\\` to \\`false\\` to opt-out of options validation (not recommended).\n\n\\thttps://eslint.org/docs/latest/extend/custom-rules#options-schemas\n`;\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\nconst IT_ONLY = Symbol(\"itOnly\");\n\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @throws {Error} Any error upon execution of `method`.\n * @returns {any} Returned value of `method`.\n */\nfunction itDefaultHandler(text, method) {\n    try {\n        return method.call(this);\n    } catch (err) {\n        if (err instanceof assert.AssertionError) {\n            err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n        }\n        throw err;\n    }\n}\n\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction describeDefaultHandler(text, method) {\n    return method.call(this);\n}\n\n/**\n * Mocha test wrapper.\n */\nclass RuleTester {\n\n    /**\n     * Creates a new instance of RuleTester.\n     * @param {Object} [testerConfig] Optional, extra configuration for the tester\n     */\n    constructor(testerConfig = {}) {\n\n        /**\n         * The configuration to use for this tester. Combination of the tester\n         * configuration and the default configuration.\n         * @type {Object}\n         */\n        this.testerConfig = [\n            sharedDefaultConfig,\n            testerConfig,\n            { rules: { \"rule-tester/validate-ast\": \"error\" } }\n        ];\n\n        this.linter = new Linter({ configType: \"flat\" });\n    }\n\n    /**\n     * Set the configuration to use for all future tests\n     * @param {Object} config the configuration to use.\n     * @throws {TypeError} If non-object config.\n     * @returns {void}\n     */\n    static setDefaultConfig(config) {\n        if (typeof config !== \"object\" || config === null) {\n            throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n        }\n        sharedDefaultConfig = config;\n\n        // Make sure the rules object exists since it is assumed to exist later\n        sharedDefaultConfig.rules = sharedDefaultConfig.rules || {};\n    }\n\n    /**\n     * Get the current configuration used for all tests\n     * @returns {Object} the current configuration\n     */\n    static getDefaultConfig() {\n        return sharedDefaultConfig;\n    }\n\n    /**\n     * Reset the configuration to the initial configuration of the tester removing\n     * any changes made until now.\n     * @returns {void}\n     */\n    static resetDefaultConfig() {\n        sharedDefaultConfig = {\n            rules: {\n                ...testerDefaultConfig.rules\n            }\n        };\n    }\n\n\n    /*\n     * If people use `mocha test.js --watch` command, `describe` and `it` function\n     * instances are different for each execution. So `describe` and `it` should get fresh instance\n     * always.\n     */\n    static get describe() {\n        return (\n            this[DESCRIBE] ||\n            (typeof describe === \"function\" ? describe : describeDefaultHandler)\n        );\n    }\n\n    static set describe(value) {\n        this[DESCRIBE] = value;\n    }\n\n    static get it() {\n        return (\n            this[IT] ||\n            (typeof it === \"function\" ? it : itDefaultHandler)\n        );\n    }\n\n    static set it(value) {\n        this[IT] = value;\n    }\n\n    /**\n     * Adds the `only` property to a test to run it in isolation.\n     * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\n     * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\n     */\n    static only(item) {\n        if (typeof item === \"string\") {\n            return { code: item, only: true };\n        }\n\n        return { ...item, only: true };\n    }\n\n    static get itOnly() {\n        if (typeof this[IT_ONLY] === \"function\") {\n            return this[IT_ONLY];\n        }\n        if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\n            return Function.bind.call(this[IT].only, this[IT]);\n        }\n        if (typeof it === \"function\" && typeof it.only === \"function\") {\n            return Function.bind.call(it.only, it);\n        }\n\n        if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\n            throw new Error(\n                \"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" +\n                \"See https://eslint.org/docs/latest/integrate/nodejs-api#customizing-ruletester for more.\"\n            );\n        }\n        if (typeof it === \"function\") {\n            throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\n        }\n        throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\n    }\n\n    static set itOnly(value) {\n        this[IT_ONLY] = value;\n    }\n\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Rule} rule The rule to test.\n     * @param {{\n     *   valid: (ValidTestCase | string)[],\n     *   invalid: InvalidTestCase[]\n     * }} test The collection of tests to run.\n     * @throws {TypeError|Error} If `rule` is not an object with a `create` method,\n     * or if non-object `test`, or if a required scenario of the given type is missing.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            linter = this.linter,\n            ruleId = `rule-to-test/${ruleName}`;\n\n        const seenValidTestCases = new Set();\n        const seenInvalidTestCases = new Set();\n\n        if (!rule || typeof rule !== \"object\" || typeof rule.create !== \"function\") {\n            throw new TypeError(\"Rule must be an object with a `create` method\");\n        }\n\n        if (!test || typeof test !== \"object\") {\n            throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (!test[scenarioType]) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n        const baseConfig = [\n            { files: [\"**\"] }, // Make sure the default config matches for all files\n            {\n                plugins: {\n\n                    // copy root plugin over\n                    \"@\": {\n\n                        /*\n                         * Parsers are wrapped to detect more errors, so this needs\n                         * to be a new object for each call to run(), otherwise the\n                         * parsers will be wrapped multiple times.\n                         */\n                        parsers: {\n                            ...defaultConfig[0].plugins[\"@\"].parsers\n                        },\n\n                        /*\n                         * The rules key on the default plugin is a proxy to lazy-load\n                         * just the rules that are needed. So, don't create a new object\n                         * here, just use the default one to keep that performance\n                         * enhancement.\n                         */\n                        rules: defaultConfig[0].plugins[\"@\"].rules,\n                        languages: defaultConfig[0].plugins[\"@\"].languages\n                    },\n                    \"rule-to-test\": {\n                        rules: {\n                            [ruleName]: Object.assign({}, rule, {\n\n                                // Create a wrapper rule that freezes the `context` properties.\n                                create(context) {\n                                    freezeDeeply(context.options);\n                                    freezeDeeply(context.settings);\n                                    freezeDeeply(context.parserOptions);\n\n                                    // freezeDeeply(context.languageOptions);\n\n                                    return rule.create(context);\n                                }\n                            })\n                        }\n                    }\n                },\n                language: defaultConfig[0].language\n            },\n            ...defaultConfig.slice(1)\n        ];\n\n        /**\n         * Runs a hook on the given item when it's assigned to the given property\n         * @param {string|Object} item Item to run the hook on\n         * @param {string} prop The property having the hook assigned to\n         * @throws {Error} If the property is not a function or that function throws an error\n         * @returns {void}\n         * @private\n         */\n        function runHook(item, prop) {\n            if (typeof item === \"object\" && hasOwnProperty(item, prop)) {\n                assert.strictEqual(typeof item[prop], \"function\", `Optional test case property '${prop}' must be a function`);\n                item[prop]();\n            }\n        }\n\n        /**\n         * Run the rule for the given item\n         * @param {string|Object} item Item to run the rule against\n         * @throws {Error} If an invalid schema.\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(item) {\n            const flatConfigArrayOptions = {\n                baseConfig\n            };\n\n            if (item.filename) {\n                flatConfigArrayOptions.basePath = path.parse(item.filename).root || void 0;\n            }\n\n            const configs = new FlatConfigArray(testerConfig, flatConfigArrayOptions);\n\n            /*\n             * Modify the returned config so that the parser is wrapped to catch\n             * access of the start/end properties. This method is called just\n             * once per code snippet being tested, so each test case gets a clean\n             * parser.\n             */\n            configs[ConfigArraySymbol.finalizeConfig] = function(...args) {\n\n                // can't do super here :(\n                const proto = Object.getPrototypeOf(this);\n                const calculatedConfig = proto[ConfigArraySymbol.finalizeConfig].apply(this, args);\n\n                // wrap the parser to catch start/end property access\n                if (calculatedConfig.language === jslang) {\n                    calculatedConfig.languageOptions.parser = wrapParser(calculatedConfig.languageOptions.parser);\n                }\n\n                return calculatedConfig;\n            };\n\n            let code, filename, output, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                /*\n                 * Assumes everything on the item is a config except for the\n                 * parameters used by this tester\n                 */\n                const itemConfig = { ...item };\n\n                for (const parameter of RuleTesterParameters) {\n                    delete itemConfig[parameter];\n                }\n\n                /*\n                 * Create the config object from the tester config and this item\n                 * specific configurations.\n                 */\n                configs.push(itemConfig);\n            }\n\n            if (hasOwnProperty(item, \"only\")) {\n                assert.ok(typeof item.only === \"boolean\", \"Optional test case property 'only' must be a boolean\");\n            }\n            if (hasOwnProperty(item, \"filename\")) {\n                assert.ok(typeof item.filename === \"string\", \"Optional test case property 'filename' must be a string\");\n                filename = item.filename;\n            }\n\n            let ruleConfig = 1;\n\n            if (hasOwnProperty(item, \"options\")) {\n                assert(Array.isArray(item.options), \"options must be an array\");\n                ruleConfig = [1, ...item.options];\n            }\n\n            configs.push({\n                rules: {\n                    [ruleId]: ruleConfig\n                }\n            });\n\n            let schema;\n\n            try {\n                schema = getRuleOptionsSchema(rule);\n            } catch (err) {\n                err.message += metaSchemaDescription;\n                throw err;\n            }\n\n            /*\n             * Check and throw an error if the schema is an empty object (`schema:{}`), because such schema\n             * doesn't validate or enforce anything and is therefore considered a possible error. If the intent\n             * was to skip options validation, `schema:false` should be set instead (explicit opt-out).\n             *\n             * For this purpose, a schema object is considered empty if it doesn't have any own enumerable string-keyed\n             * properties. While `ajv.compile()` does use enumerable properties from the prototype chain as well,\n             * it caches compiled schemas by serializing only own enumerable properties, so it's generally not a good idea\n             * to use inherited properties in schemas because schemas that differ only in inherited properties would end up\n             * having the same cache entry that would be correct for only one of them.\n             *\n             * At this point, `schema` can only be an object or `null`.\n             */\n            if (schema && Object.keys(schema).length === 0) {\n                throw new Error(`\\`schema: {}\\` is a no-op${metaSchemaDescription}`);\n            }\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            configs.push({\n                plugins: {\n                    \"rule-tester\": {\n                        rules: {\n                            \"validate-ast\": {\n                                create() {\n                                    return {\n                                        Program(node) {\n                                            beforeAST = cloneDeeplyExcludesParent(node);\n                                        },\n                                        \"Program:exit\"(node) {\n                                            afterAST = node;\n                                        }\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            });\n\n            if (schema) {\n                ajv.validateSchema(schema);\n\n                if (ajv.errors) {\n                    const errors = ajv.errors.map(error => {\n                        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n                        return `\\t${field}: ${error.message}`;\n                    }).join(\"\\n\");\n\n                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n                }\n\n                /*\n                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n                 * the schema is compiled here separately from checking for `validateSchema` errors.\n                 */\n                try {\n                    ajv.compile(schema);\n                } catch (err) {\n                    throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n                }\n            }\n\n            // check for validation errors\n            try {\n                configs.normalizeSync();\n                configs.getConfig(\"test.js\");\n            } catch (error) {\n                error.message = `ESLint configuration in rule-tester is invalid: ${error.message}`;\n                throw error;\n            }\n\n            // Verify the code.\n            const { applyLanguageOptions, applyInlineConfig, finalize } = SourceCode.prototype;\n            let messages;\n\n            try {\n                forbiddenMethods.forEach(methodName => {\n                    SourceCode.prototype[methodName] = throwForbiddenMethodError(methodName, SourceCode.prototype);\n                });\n\n                messages = linter.verify(code, configs, filename);\n            } finally {\n                SourceCode.prototype.applyInlineConfig = applyInlineConfig;\n                SourceCode.prototype.applyLanguageOptions = applyLanguageOptions;\n                SourceCode.prototype.finalize = finalize;\n            }\n\n\n            const fatalErrorMessage = messages.find(m => m.fatal);\n\n            assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);\n\n            // Verify if autofix makes a syntax error or not.\n            if (messages.some(m => m.fix)) {\n                output = SourceCodeFixer.applyFixes(code, messages).output;\n                const errorMessageInFix = linter.verify(output, configs, filename).find(m => m.fatal);\n\n                assert(!errorMessageInFix, [\n                    \"A fatal parsing error occurred in autofix.\",\n                    `Error: ${errorMessageInFix && errorMessageInFix.message}`,\n                    \"Autofix output:\",\n                    output\n                ].join(\"\\n\"));\n            } else {\n                output = code;\n            }\n\n            return {\n                messages,\n                output,\n                beforeAST,\n                afterAST: cloneDeeplyExcludesParent(afterAST),\n                configs,\n                filename\n            };\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!equal(beforeAST, afterAST)) {\n                assert.fail(\"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if this test case is a duplicate of one we have seen before.\n         * @param {string|Object} item test case object\n         * @param {Set<string>} seenTestCases set of serialized test cases we have seen so far (managed by this function)\n         * @returns {void}\n         * @private\n         */\n        function checkDuplicateTestCase(item, seenTestCases) {\n            if (!isSerializable(item)) {\n\n                /*\n                 * If we can't serialize a test case (because it contains a function, RegExp, etc), skip the check.\n                 * This might happen with properties like: options, plugins, settings, languageOptions.parser, languageOptions.parserOptions.\n                 */\n                return;\n            }\n\n            const normalizedItem = typeof item === \"string\" ? { code: item } : item;\n            const serializedTestCase = stringify(normalizedItem, {\n                replacer(key, value) {\n\n                    // \"this\" is the currently stringified object --> only ignore top-level properties\n                    return (normalizedItem !== this || !duplicationIgnoredParameters.has(key)) ? value : void 0;\n                }\n            });\n\n            assert(\n                !seenTestCases.has(serializedTestCase),\n                \"detected duplicate test case\"\n            );\n            seenTestCases.add(serializedTestCase);\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(item) {\n            const code = typeof item === \"object\" ? item.code : item;\n\n            assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\n            if (item.name) {\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n            }\n\n            checkDuplicateTestCase(item, seenValidTestCases);\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                messages.length,\n                util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.strictEqual(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(item) {\n            assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\n            if (item.name) {\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n            }\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            if (Array.isArray(item.errors) && item.errors.length === 0) {\n                assert.fail(\"Invalid cases must have at least one error\");\n            }\n\n            checkDuplicateTestCase(item, seenInvalidTestCases);\n\n            const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\n            const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            for (const message of messages) {\n                if (hasOwnProperty(message, \"suggestions\")) {\n\n                    /** @type {Map<string, number>} */\n                    const seenMessageIndices = new Map();\n\n                    for (let i = 0; i < message.suggestions.length; i += 1) {\n                        const suggestionMessage = message.suggestions[i].desc;\n                        const previous = seenMessageIndices.get(suggestionMessage);\n\n                        assert.ok(!seenMessageIndices.has(suggestionMessage), `Suggestion message '${suggestionMessage}' reported from suggestion ${i} was previously reported by suggestion ${previous}. Suggestion messages should be unique within an error.`);\n                        seenMessageIndices.set(suggestionMessage, i);\n                    }\n                }\n            }\n\n            if (typeof item.errors === \"number\") {\n\n                if (item.errors === 0) {\n                    assert.fail(\"Invalid cases must have 'error' value greater than 0\");\n                }\n\n                assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors,\n                    item.errors === 1 ? \"\" : \"s\",\n                    messages.length,\n                    util.inspect(messages)));\n            } else {\n                assert.strictEqual(\n                    messages.length, item.errors.length, util.format(\n                        \"Should have %d error%s but had %d: %s\",\n                        item.errors.length,\n                        item.errors.length === 1 ? \"\" : \"s\",\n                        messages.length,\n                        util.inspect(messages)\n                    )\n                );\n\n                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleId);\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    const error = item.errors[i];\n                    const message = messages[i];\n\n                    assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof error === \"string\" || error instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(message.message, error);\n                        assert.ok(message.suggestions === void 0, `Error at index ${i} has suggestions. Please convert the test error into an object and specify 'suggestions' property on it to test suggestions.`);\n                    } else if (typeof error === \"object\" && error !== null) {\n\n                        /*\n                         * Error object.\n                         * This may have a message, messageId, data, node type, line, and/or\n                         * column.\n                         */\n\n                        Object.keys(error).forEach(propertyName => {\n                            assert.ok(\n                                errorObjectParameters.has(propertyName),\n                                `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`\n                            );\n                        });\n\n                        if (hasOwnProperty(error, \"message\")) {\n                            assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n                            assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n                            assertMessageMatches(message.message, error.message);\n                        } else if (hasOwnProperty(error, \"messageId\")) {\n                            assert.ok(\n                                ruleHasMetaMessages,\n                                \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\"\n                            );\n                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n                            }\n                            assert.strictEqual(\n                                message.messageId,\n                                error.messageId,\n                                `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`\n                            );\n\n                            const unsubstitutedPlaceholders = getUnsubstitutedMessagePlaceholders(\n                                message.message,\n                                rule.meta.messages[message.messageId],\n                                error.data\n                            );\n\n                            assert.ok(\n                                unsubstitutedPlaceholders.length === 0,\n                                `The reported message has ${unsubstitutedPlaceholders.length > 1 ? `unsubstituted placeholders: ${unsubstitutedPlaceholders.map(name => `'${name}'`).join(\", \")}` : `an unsubstituted placeholder '${unsubstitutedPlaceholders[0]}'`}. Please provide the missing ${unsubstitutedPlaceholders.length > 1 ? \"values\" : \"value\"} via the 'data' property in the context.report() call.`\n                            );\n\n                            if (hasOwnProperty(error, \"data\")) {\n\n                                /*\n                                 *  if data was provided, then directly compare the returned message to a synthetic\n                                 *  interpolated message using the same message ID and data provided in the test.\n                                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                                 */\n                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n\n                                assert.strictEqual(\n                                    message.message,\n                                    rehydratedMessage,\n                                    `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`\n                                );\n                            }\n                        } else {\n                            assert.fail(\"Test error must specify either a 'messageId' or 'message'.\");\n                        }\n\n                        if (error.type) {\n                            assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n                        }\n\n                        if (hasOwnProperty(error, \"line\")) {\n                            assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n                        }\n\n                        if (hasOwnProperty(error, \"column\")) {\n                            assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endLine\")) {\n                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endColumn\")) {\n                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n                        }\n\n                        assert.ok(!message.suggestions || hasOwnProperty(error, \"suggestions\"), `Error at index ${i} has suggestions. Please specify 'suggestions' property on the test error object.`);\n                        if (hasOwnProperty(error, \"suggestions\")) {\n\n                            // Support asserting there are no suggestions\n                            const expectsSuggestions = Array.isArray(error.suggestions) ? error.suggestions.length > 0 : Boolean(error.suggestions);\n                            const hasSuggestions = message.suggestions !== void 0;\n\n                            if (!hasSuggestions && expectsSuggestions) {\n                                assert.ok(!error.suggestions, `Error should have suggestions on error with message: \"${message.message}\"`);\n                            } else if (hasSuggestions) {\n                                assert.ok(expectsSuggestions, `Error should have no suggestions on error with message: \"${message.message}\"`);\n                                if (typeof error.suggestions === \"number\") {\n                                    assert.strictEqual(message.suggestions.length, error.suggestions, `Error should have ${error.suggestions} suggestions. Instead found ${message.suggestions.length} suggestions`);\n                                } else if (Array.isArray(error.suggestions)) {\n                                    assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n\n                                    error.suggestions.forEach((expectedSuggestion, index) => {\n                                        assert.ok(\n                                            typeof expectedSuggestion === \"object\" && expectedSuggestion !== null,\n                                            \"Test suggestion in 'suggestions' array must be an object.\"\n                                        );\n                                        Object.keys(expectedSuggestion).forEach(propertyName => {\n                                            assert.ok(\n                                                suggestionObjectParameters.has(propertyName),\n                                                `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`\n                                            );\n                                        });\n\n                                        const actualSuggestion = message.suggestions[index];\n                                        const suggestionPrefix = `Error Suggestion at index ${index}:`;\n\n                                        if (hasOwnProperty(expectedSuggestion, \"desc\")) {\n                                            assert.ok(\n                                                !hasOwnProperty(expectedSuggestion, \"data\"),\n                                                `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`\n                                            );\n                                            assert.ok(\n                                                !hasOwnProperty(expectedSuggestion, \"messageId\"),\n                                                `${suggestionPrefix} Test should not specify both 'desc' and 'messageId'.`\n                                            );\n                                            assert.strictEqual(\n                                                actualSuggestion.desc,\n                                                expectedSuggestion.desc,\n                                                `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`\n                                            );\n                                        } else if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\n                                            assert.ok(\n                                                ruleHasMetaMessages,\n                                                `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`\n                                            );\n                                            assert.ok(\n                                                hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId),\n                                                `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`\n                                            );\n                                            assert.strictEqual(\n                                                actualSuggestion.messageId,\n                                                expectedSuggestion.messageId,\n                                                `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`\n                                            );\n\n                                            const unsubstitutedPlaceholders = getUnsubstitutedMessagePlaceholders(\n                                                actualSuggestion.desc,\n                                                rule.meta.messages[expectedSuggestion.messageId],\n                                                expectedSuggestion.data\n                                            );\n\n                                            assert.ok(\n                                                unsubstitutedPlaceholders.length === 0,\n                                                `The message of the suggestion has ${unsubstitutedPlaceholders.length > 1 ? `unsubstituted placeholders: ${unsubstitutedPlaceholders.map(name => `'${name}'`).join(\", \")}` : `an unsubstituted placeholder '${unsubstitutedPlaceholders[0]}'`}. Please provide the missing ${unsubstitutedPlaceholders.length > 1 ? \"values\" : \"value\"} via the 'data' property for the suggestion in the context.report() call.`\n                                            );\n\n                                            if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                                                const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\n                                                const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\n\n                                                assert.strictEqual(\n                                                    actualSuggestion.desc,\n                                                    rehydratedDesc,\n                                                    `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`\n                                                );\n                                            }\n                                        } else if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                                            assert.fail(\n                                                `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`\n                                            );\n                                        } else {\n                                            assert.fail(\n                                                `${suggestionPrefix} Test must specify either 'messageId' or 'desc'.`\n                                            );\n                                        }\n\n                                        assert.ok(hasOwnProperty(expectedSuggestion, \"output\"), `${suggestionPrefix} The \"output\" property is required.`);\n                                        const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n\n                                        // Verify if suggestion fix makes a syntax error or not.\n                                        const errorMessageInSuggestion =\n                                                linter.verify(codeWithAppliedSuggestion, result.configs, result.filename).find(m => m.fatal);\n\n                                        assert(!errorMessageInSuggestion, [\n                                            \"A fatal parsing error occurred in suggestion fix.\",\n                                            `Error: ${errorMessageInSuggestion && errorMessageInSuggestion.message}`,\n                                            \"Suggestion output:\",\n                                            codeWithAppliedSuggestion\n                                        ].join(\"\\n\"));\n\n                                        assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                                        assert.notStrictEqual(expectedSuggestion.output, item.code, `The output of a suggestion should differ from the original source code for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                                    });\n                                } else {\n                                    assert.fail(\"Test error object property 'suggestions' should be an array or a number\");\n                                }\n                            }\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n                    }\n                }\n            }\n\n            if (hasOwnProperty(item, \"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        result.output,\n                        item.code,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n                    assert.notStrictEqual(item.code, item.output, \"Test property 'output' matches 'code'. If no autofix is expected, then omit the 'output' property or set it to null.\");\n                }\n            } else {\n                assert.strictEqual(\n                    result.output,\n                    item.code,\n                    \"The rule fixed the code. Please add 'output' property.\"\n                );\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         * The test suites for valid/invalid are created conditionally as\n         * test runners (eg. vitest) fail for empty test suites.\n         */\n        this.constructor.describe(ruleName, () => {\n            if (test.valid.length > 0) {\n                this.constructor.describe(\"valid\", () => {\n                    test.valid.forEach(valid => {\n                        this.constructor[valid.only ? \"itOnly\" : \"it\"](\n                            sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid),\n                            () => {\n                                try {\n                                    runHook(valid, \"before\");\n                                    testValidTemplate(valid);\n                                } finally {\n                                    runHook(valid, \"after\");\n                                }\n                            }\n                        );\n                    });\n                });\n            }\n\n            if (test.invalid.length > 0) {\n                this.constructor.describe(\"invalid\", () => {\n                    test.invalid.forEach(invalid => {\n                        this.constructor[invalid.only ? \"itOnly\" : \"it\"](\n                            sanitize(invalid.name || invalid.code),\n                            () => {\n                                try {\n                                    runHook(invalid, \"before\");\n                                    testInvalidTemplate(invalid);\n                                } finally {\n                                    runHook(invalid, \"after\");\n                                }\n                            }\n                        );\n                    });\n                });\n            }\n        });\n    }\n}\n\nRuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = null;\n\nmodule.exports = RuleTester;\n"
        }
    ]
}