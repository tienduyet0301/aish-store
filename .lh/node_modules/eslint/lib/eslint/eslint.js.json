{
    "sourceFile": "node_modules/eslint/lib/eslint/eslint.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Main class using flat config\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"node:fs/promises\");\nconst { existsSync } = require(\"node:fs\");\nconst path = require(\"node:path\");\nconst { version } = require(\"../../package.json\");\nconst { Linter } = require(\"../linter\");\nconst { getRuleFromConfig } = require(\"../config/flat-config-helpers\");\nconst { defaultConfig } = require(\"../config/default-config\");\nconst {\n    Legacy: {\n        ConfigOps: {\n            getRuleSeverity\n        },\n        ModuleResolver,\n        naming\n    }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n    findFiles,\n    getCacheFile,\n\n    isNonEmptyString,\n    isArrayOfNonEmptyString,\n\n    createIgnoreResult,\n    isErrorMessage,\n\n    processOptions\n} = require(\"./eslint-helpers\");\nconst { pathToFileURL } = require(\"node:url\");\nconst LintResultCache = require(\"../cli-engine/lint-result-cache\");\nconst { Retrier } = require(\"@humanwhocodes/retry\");\nconst { ConfigLoader, LegacyConfigLoader } = require(\"../config/config-loader\");\n\n/*\n * This is necessary to allow overwriting writeFile for testing purposes.\n * We can just use fs/promises once we drop Node.js 12 support.\n */\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../cli-engine/cli-engine\").ConfigArray} ConfigArray */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").LintResult} LintResult */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").ResultsMeta} ResultsMeta */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n/** @typedef {import('../cli-engine/cli-engine').CLIEngine} CLIEngine */\n/** @typedef {import('./legacy-eslint').CLIEngineLintReport} CLIEngineLintReport */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} ESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData|Array<ConfigData>} [baseConfig] Base config, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {string[]} [flags] Array of feature flags to enable.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables all ignore patterns except for the default ones.\n * @property {string[]} [ignorePatterns] Ignore file patterns to use in addition to config ignores. These patterns are relative to `cwd`.\n * @property {ConfigData|Array<ConfigData>} [overrideConfig] Override config, overrides all configs used with this instance\n * @property {boolean|string} [overrideConfigFile] Searches for default config file when falsy;\n *      doesn't do any config file lookup when `true`; considered to be a config filename\n *      when a string.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {boolean} [stats] True enables added statistics on lint results.\n * @property {boolean} [warnIgnored] Show warnings when the file list includes ignored files\n * @property {boolean} [passOnNoPatterns=false] When set to true, missing patterns cause\n *      the linting operation to short circuit and not report any failures.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:eslint\");\nconst privateMembers = new WeakMap();\nconst removedFormatters = new Set([\n    \"checkstyle\",\n    \"codeframe\",\n    \"compact\",\n    \"jslint-xml\",\n    \"junit\",\n    \"table\",\n    \"tap\",\n    \"unix\",\n    \"visualstudio\"\n]);\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    const stat = {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n\n    for (let i = 0; i < messages.length; i++) {\n        const message = messages[i];\n\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n            if (message.fatal) {\n                stat.fatalErrorCount++;\n            }\n            if (message.fix) {\n                stat.fixableErrorCount++;\n            }\n        } else {\n            stat.warningCount++;\n            if (message.fix) {\n                stat.fixableWarningCount++;\n            }\n        }\n    }\n    return stat;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\n        retVal[id] = rule.meta;\n        return retVal;\n    }, {});\n}\n\n/**\n * Return the absolute path of a file named `\"__placeholder__.js\"` in a given directory.\n * This is used as a replacement for a missing file path.\n * @param {string} cwd An absolute directory path.\n * @returns {string} The absolute path of a file named `\"__placeholder__.js\"` in the given directory.\n */\nfunction getPlaceholderPath(cwd) {\n    return path.join(cwd, \"__placeholder__.js\");\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {\n    const {\n        options: { cwd },\n        configLoader\n    } = privateMembers.get(eslint);\n    const filePath = path.isAbsolute(maybeFilePath)\n        ? maybeFilePath\n        : getPlaceholderPath(cwd);\n    const configs = configLoader.getCachedConfigArrayForFile(filePath);\n    const config = configs.getConfig(filePath);\n\n    // Most files use the same config, so cache it.\n    if (config && !usedDeprecatedRulesCache.has(config)) {\n        const retv = [];\n\n        if (config.rules) {\n            for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n                if (getRuleSeverity(ruleConf) === 0) {\n                    continue;\n                }\n                const rule = getRuleFromConfig(ruleId, config);\n                const meta = rule && rule.meta;\n\n                if (meta && meta.deprecated) {\n                    const usesNewFormat = typeof meta.deprecated === \"object\";\n\n                    retv.push({\n                        ruleId,\n                        replacedBy: usesNewFormat ? meta.deprecated.replacedBy?.map(replacement => `${replacement.plugin?.name !== void 0 ? `${naming.getShorthandName(replacement.plugin.name, \"eslint-plugin\")}/` : \"\"}${replacement.rule?.name ?? \"\"}`) ?? [] : meta.replacedBy || [],\n                        info: usesNewFormat ? meta.deprecated : void 0\n                    });\n                }\n            }\n        }\n\n\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n    }\n\n    return config ? usedDeprecatedRulesCache.get(config) : Object.freeze([]);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processLintReport(eslint, { results }) {\n    const descriptor = {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return getOrFindUsedDeprecatedRules(eslint, this.filePath);\n        }\n    };\n\n    for (const result of results) {\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n    }\n\n    return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n    if (a.filePath < b.filePath) {\n        return -1;\n    }\n\n    if (a.filePath > b.filePath) {\n        return 1;\n    }\n\n    return 0;\n}\n\n\n/**\n * Determines which config file to use. This is determined by seeing if an\n * override config file was passed, and if so, using it; otherwise, as long\n * as override config file is not explicitly set to `false`, it will search\n * upwards from the cwd for a file named `eslint.config.js`.\n *\n * This function is used primarily by the `--inspect-config` option. For now,\n * we will maintain the existing behavior, which is to search up from the cwd.\n * @param {ESLintOptions} options The ESLint instance options.\n * @returns {Promise<{configFilePath:string|undefined;basePath:string}>} Location information for\n *      the config file.\n */\nasync function locateConfigFileToUse({ configFile, cwd }) {\n\n    const configLoader = new ConfigLoader({\n        cwd,\n        configFile\n    });\n\n    const configFilePath = await configLoader.findConfigFileForPath(path.join(cwd, \"__placeholder__.js\"));\n\n    if (!configFilePath) {\n        throw new Error(\"No ESLint configuration file was found.\");\n    }\n\n    return {\n        configFilePath,\n        basePath: configFile ? cwd : path.dirname(configFilePath)\n    };\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {FlatConfigArray} config.configs The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {Function} config.ruleFilter A predicate function to filter which rules should be run.\n * @param {boolean} config.stats If `true`, then if reports extra statistics with the lint results.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n    text,\n    cwd,\n    filePath: providedFilePath,\n    configs,\n    fix,\n    allowInlineConfig,\n    ruleFilter,\n    stats,\n    linter\n}) {\n    const filePath = providedFilePath || \"<text>\";\n\n    debug(`Lint ${filePath}`);\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n    const filePathToVerify = filePath === \"<text>\" ? getPlaceholderPath(cwd) : filePath;\n    const { fixed, messages, output } = linter.verifyAndFix(\n        text,\n        configs,\n        {\n            allowInlineConfig,\n            filename: filePathToVerify,\n            fix,\n            ruleFilter,\n            stats,\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n            filterCodeBlock(blockFilename) {\n                return configs.getConfig(blockFilename) !== void 0;\n            }\n        }\n    );\n\n    // Tweak and return.\n    const result = {\n        filePath: filePath === \"<text>\" ? filePath : path.resolve(filePath),\n        messages,\n        suppressedMessages: linter.getSuppressedMessages(),\n        ...calculateStatsPerFile(messages)\n    };\n\n    if (fixed) {\n        result.output = output;\n    }\n\n    if (\n        result.errorCount + result.warningCount > 0 &&\n        typeof result.output === \"undefined\"\n    ) {\n        result.source = text;\n    }\n\n    if (stats) {\n        result.stats = {\n            times: linter.getTimes(),\n            fixPasses: linter.getFixPassCount()\n        };\n    }\n\n    return result;\n}\n\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\nfunction shouldMessageBeFixed(message, config, fixTypes) {\n    if (!message.ruleId) {\n        return fixTypes.has(\"directive\");\n    }\n\n    const rule = message.ruleId && getRuleFromConfig(message.ruleId, config);\n\n    return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n\n/**\n * Creates an error to be thrown when an array of results passed to `getRulesMetaForResults` was not created by the current engine.\n * @returns {TypeError} An error object.\n */\nfunction createExtraneousResultsError() {\n    return new TypeError(\"Results object was not created from this ESLint instance.\");\n}\n\n/**\n * Creates a fixer function based on the provided fix, fixTypesSet, and config.\n * @param {Function|boolean} fix The original fix option.\n * @param {Set<string>} fixTypesSet A set of fix types to filter messages for fixing.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @returns {Function|boolean} The fixer function or the original fix value.\n */\nfunction getFixerForFixTypes(fix, fixTypesSet, config) {\n    if (!fix || !fixTypesSet) {\n        return fix;\n    }\n\n    const originalFix = (typeof fix === \"function\") ? fix : () => true;\n\n    return message => shouldMessageBeFixed(message, config, fixTypesSet) && originalFix(message);\n}\n\n//-----------------------------------------------------------------------------\n// Main API\n//-----------------------------------------------------------------------------\n\n/**\n * Primary Node.js API for ESLint.\n */\nclass ESLint {\n\n    /**\n     * The type of configuration used by this class.\n     * @type {string}\n     */\n    static configType = \"flat\";\n\n    /**\n     * The loader to use for finding config files.\n     * @type {ConfigLoader|LegacyConfigLoader}\n     */\n    #configLoader;\n\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param {ESLintOptions} options The options for this instance.\n     */\n    constructor(options = {}) {\n\n        const defaultConfigs = [];\n        const processedOptions = processOptions(options);\n        const linter = new Linter({\n            cwd: processedOptions.cwd,\n            configType: \"flat\",\n            flags: processedOptions.flags\n        });\n\n        const cacheFilePath = getCacheFile(\n            processedOptions.cacheLocation,\n            processedOptions.cwd\n        );\n\n        const lintResultCache = processedOptions.cache\n            ? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy)\n            : null;\n\n        const configLoaderOptions = {\n            cwd: processedOptions.cwd,\n            baseConfig: processedOptions.baseConfig,\n            overrideConfig: processedOptions.overrideConfig,\n            configFile: processedOptions.configFile,\n            ignoreEnabled: processedOptions.ignore,\n            ignorePatterns: processedOptions.ignorePatterns,\n            defaultConfigs\n        };\n\n        this.#configLoader = linter.hasFlag(\"unstable_config_lookup_from_file\")\n            ? new ConfigLoader(configLoaderOptions)\n            : new LegacyConfigLoader(configLoaderOptions);\n\n        debug(`Using config loader ${this.#configLoader.constructor.name}`);\n\n        privateMembers.set(this, {\n            options: processedOptions,\n            linter,\n            cacheFilePath,\n            lintResultCache,\n            defaultConfigs,\n            configs: null,\n            configLoader: this.#configLoader\n        });\n\n\n        /**\n         * If additional plugins are passed in, add that to the default\n         * configs for this instance.\n         */\n        if (options.plugins) {\n\n            const plugins = {};\n\n            for (const [pluginName, plugin] of Object.entries(options.plugins)) {\n                plugins[naming.getShorthandName(pluginName, \"eslint-plugin\")] = plugin;\n            }\n\n            defaultConfigs.push({\n                plugins\n            });\n        }\n\n        // Check for the .eslintignore file, and warn if it's present.\n        if (existsSync(path.resolve(processedOptions.cwd, \".eslintignore\"))) {\n            process.emitWarning(\n                \"The \\\".eslintignore\\\" file is no longer supported. Switch to using the \\\"ignores\\\" property in \\\"eslint.config.js\\\": https://eslint.org/docs/latest/use/configure/migration-guide#ignoring-files\",\n                \"ESLintIgnoreWarning\"\n            );\n        }\n    }\n\n    /**\n     * The version text.\n     * @type {string}\n     */\n    static get version() {\n        return version;\n    }\n\n    /**\n     * The default configuration that ESLint uses internally. This is provided for tooling that wants to calculate configurations using the same defaults as ESLint.\n     * Keep in mind that the default configuration may change from version to version, so you shouldn't rely on any particular keys or values to be present.\n     * @type {ConfigArray}\n     */\n    static get defaultConfig() {\n        return defaultConfig;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintResult[]} results The lint results.\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\n     */\n    static async outputFixes(results) {\n        if (!Array.isArray(results)) {\n            throw new Error(\"'results' must be an array\");\n        }\n\n        await Promise.all(\n            results\n                .filter(result => {\n                    if (typeof result !== \"object\" || result === null) {\n                        throw new Error(\"'results' must include only objects\");\n                    }\n                    return (\n                        typeof result.output === \"string\" &&\n                        path.isAbsolute(result.filePath)\n                    );\n                })\n                .map(r => fs.writeFile(r.filePath, r.output))\n        );\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        const filtered = [];\n\n        results.forEach(result => {\n            const filteredMessages = result.messages.filter(isErrorMessage);\n            const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n\n            if (filteredMessages.length > 0) {\n                filtered.push({\n                    ...result,\n                    messages: filteredMessages,\n                    suppressedMessages: filteredSuppressedMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0,\n                    fixableErrorCount: result.fixableErrorCount,\n                    fixableWarningCount: 0\n                });\n            }\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Returns meta objects for each rule represented in the lint results.\n     * @param {LintResult[]} results The results to fetch rules meta for.\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\n     * @throws {TypeError} When the results object wasn't created from this ESLint instance.\n     * @throws {TypeError} When a plugin or rule is missing.\n     */\n    getRulesMetaForResults(results) {\n\n        // short-circuit simple case\n        if (results.length === 0) {\n            return {};\n        }\n\n        const resultRules = new Map();\n        const {\n            configLoader,\n            options: { cwd }\n        } = privateMembers.get(this);\n\n        for (const result of results) {\n\n            /*\n             * Normalize filename for <text>.\n             */\n            const filePath = result.filePath === \"<text>\"\n                ? getPlaceholderPath(cwd) : result.filePath;\n            const allMessages = result.messages.concat(result.suppressedMessages);\n\n            for (const { ruleId } of allMessages) {\n                if (!ruleId) {\n                    continue;\n                }\n\n                /*\n                 * All of the plugin and rule information is contained within the\n                 * calculated config for the given file.\n                 */\n                let configs;\n\n                try {\n                    configs = configLoader.getCachedConfigArrayForFile(filePath);\n                } catch {\n                    throw createExtraneousResultsError();\n                }\n\n                const config = configs.getConfig(filePath);\n\n                if (!config) {\n                    throw createExtraneousResultsError();\n                }\n                const rule = getRuleFromConfig(ruleId, config);\n\n                // ignore unknown rules\n                if (rule) {\n                    resultRules.set(ruleId, rule);\n                }\n            }\n        }\n\n        return createRulesMeta(resultRules);\n    }\n\n    /**\n     * Indicates if the given feature flag is enabled for this instance.\n     * @param {string} flag The feature flag to check.\n     * @returns {boolean} `true` if the feature flag is enabled, `false` if not.\n     */\n    hasFlag(flag) {\n\n        // note: Linter does validation of the flags\n        return privateMembers.get(this).linter.hasFlag(flag);\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string|string[]} patterns An array of file and directory names.\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n     */\n    async lintFiles(patterns) {\n\n        let normalizedPatterns = patterns;\n        const {\n            cacheFilePath,\n            lintResultCache,\n            linter,\n            options: eslintOptions\n        } = privateMembers.get(this);\n\n        /*\n         * Special cases:\n         * 1. `patterns` is an empty string\n         * 2. `patterns` is an empty array\n         *\n         * In both cases, we use the cwd as the directory to lint.\n         */\n        if (patterns === \"\" || Array.isArray(patterns) && patterns.length === 0) {\n\n            /*\n             * Special case: If `passOnNoPatterns` is true, then we just exit\n             * without doing any work.\n             */\n            if (eslintOptions.passOnNoPatterns) {\n                return [];\n            }\n\n            normalizedPatterns = [\".\"];\n        } else {\n\n            if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n                throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n            }\n\n            if (typeof patterns === \"string\") {\n                normalizedPatterns = [patterns];\n            }\n        }\n\n        debug(`Using file patterns: ${normalizedPatterns}`);\n\n        const {\n            allowInlineConfig,\n            cache,\n            cwd,\n            fix,\n            fixTypes,\n            ruleFilter,\n            stats,\n            globInputPaths,\n            errorOnUnmatchedPattern,\n            warnIgnored\n        } = eslintOptions;\n        const startTime = Date.now();\n        const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n\n        // Delete cache file; should this be done here?\n        if (!cache && cacheFilePath) {\n            debug(`Deleting cache file at ${cacheFilePath}`);\n\n            try {\n                await fs.unlink(cacheFilePath);\n            } catch (error) {\n                const errorCode = error && error.code;\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n                if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !existsSync(cacheFilePath))) {\n                    throw error;\n                }\n            }\n        }\n\n        const filePaths = await findFiles({\n            patterns: normalizedPatterns,\n            cwd,\n            globInputPaths,\n            configLoader: this.#configLoader,\n            errorOnUnmatchedPattern\n        });\n        const controller = new AbortController();\n        const retryCodes = new Set([\"ENFILE\", \"EMFILE\"]);\n        const retrier = new Retrier(error => retryCodes.has(error.code), { concurrency: 100 });\n\n        debug(`${filePaths.length} files found in: ${Date.now() - startTime}ms`);\n\n        /*\n         * Because we need to process multiple files, including reading from disk,\n         * it is most efficient to start by reading each file via promises so that\n         * they can be done in parallel. Then, we can lint the returned text. This\n         * ensures we are waiting the minimum amount of time in between lints.\n         */\n        const results = await Promise.all(\n\n            filePaths.map(async filePath => {\n\n                const configs = await this.#configLoader.loadConfigArrayForFile(filePath);\n                const config = configs.getConfig(filePath);\n\n                /*\n                 * If a filename was entered that cannot be matched\n                 * to a config, then notify the user.\n                 */\n                if (!config) {\n                    if (warnIgnored) {\n                        const configStatus = configs.getConfigStatus(filePath);\n\n                        return createIgnoreResult(filePath, cwd, configStatus);\n                    }\n\n                    return void 0;\n                }\n\n                // Skip if there is cached result.\n                if (lintResultCache) {\n                    const cachedResult =\n                        lintResultCache.getCachedLintResults(filePath, config);\n\n                    if (cachedResult) {\n                        const hadMessages =\n                            cachedResult.messages &&\n                            cachedResult.messages.length > 0;\n\n                        if (hadMessages && fix) {\n                            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n                        } else {\n                            debug(`Skipping file since it hasn't changed: ${filePath}`);\n                            return cachedResult;\n                        }\n                    }\n                }\n\n\n                // set up fixer for fixTypes if necessary\n                const fixer = getFixerForFixTypes(fix, fixTypesSet, config);\n\n                return retrier.retry(() => fs.readFile(filePath, { encoding: \"utf8\", signal: controller.signal })\n                    .then(text => {\n\n                        // fail immediately if an error occurred in another file\n                        controller.signal.throwIfAborted();\n\n                        // do the linting\n                        const result = verifyText({\n                            text,\n                            filePath,\n                            configs,\n                            cwd,\n                            fix: fixer,\n                            allowInlineConfig,\n                            ruleFilter,\n                            stats,\n                            linter\n                        });\n\n                        /*\n                         * Store the lint result in the LintResultCache.\n                         * NOTE: The LintResultCache will remove the file source and any\n                         * other properties that are difficult to serialize, and will\n                         * hydrate those properties back in on future lint runs.\n                         */\n                        if (lintResultCache) {\n                            lintResultCache.setCachedLintResults(filePath, config, result);\n                        }\n\n                        return result;\n                    }), { signal: controller.signal })\n                    .catch(error => {\n                        controller.abort(error);\n                        throw error;\n                    });\n            })\n        );\n\n        // Persist the cache to disk.\n        if (lintResultCache) {\n            lintResultCache.reconcile();\n        }\n\n        const finalResults = results.filter(result => !!result);\n\n        return processLintReport(this, {\n            results: finalResults\n        });\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} code A string of JavaScript code to lint.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to the file of the source code.\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n     */\n    async lintText(code, options = {}) {\n\n        // Parameter validation\n\n        if (typeof code !== \"string\") {\n            throw new Error(\"'code' must be a string\");\n        }\n\n        if (typeof options !== \"object\") {\n            throw new Error(\"'options' must be an object, null, or undefined\");\n        }\n\n        // Options validation\n\n        const {\n            filePath,\n            warnIgnored,\n            ...unknownOptions\n        } = options || {};\n\n        const unknownOptionKeys = Object.keys(unknownOptions);\n\n        if (unknownOptionKeys.length > 0) {\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n        }\n\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n        }\n\n        if (typeof warnIgnored !== \"boolean\" && typeof warnIgnored !== \"undefined\") {\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n        }\n\n        // Now we can get down to linting\n\n        const {\n            linter,\n            options: eslintOptions\n        } = privateMembers.get(this);\n        const {\n            allowInlineConfig,\n            cwd,\n            fix,\n            fixTypes,\n            warnIgnored: constructorWarnIgnored,\n            ruleFilter,\n            stats\n        } = eslintOptions;\n        const results = [];\n        const startTime = Date.now();\n        const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n        const resolvedFilename = path.resolve(cwd, filePath || \"__placeholder__.js\");\n        const configs = await this.#configLoader.loadConfigArrayForFile(resolvedFilename);\n        const configStatus = configs?.getConfigStatus(resolvedFilename) ?? \"unconfigured\";\n\n        // Clear the last used config arrays.\n        if (resolvedFilename && configStatus !== \"matched\") {\n            const shouldWarnIgnored = typeof warnIgnored === \"boolean\" ? warnIgnored : constructorWarnIgnored;\n\n            if (shouldWarnIgnored) {\n                results.push(createIgnoreResult(resolvedFilename, cwd, configStatus));\n            }\n        } else {\n\n            const config = configs.getConfig(resolvedFilename);\n            const fixer = getFixerForFixTypes(fix, fixTypesSet, config);\n\n            // Do lint.\n            results.push(verifyText({\n                text: code,\n                filePath: resolvedFilename.endsWith(\"__placeholder__.js\") ? \"<text>\" : resolvedFilename,\n                configs,\n                cwd,\n                fix: fixer,\n                allowInlineConfig,\n                ruleFilter,\n                stats,\n                linter\n            }));\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n\n        return processLintReport(this, {\n            results\n        });\n\n    }\n\n    /**\n     * Returns the formatter representing the given formatter name.\n     * @param {string} [name] The name of the formatter to load.\n     * The following values are allowed:\n     * - `undefined` ... Load `stylish` builtin formatter.\n     * - A builtin formatter name ... Load the builtin formatter.\n     * - A third-party formatter name:\n     *   - `foo` → `eslint-formatter-foo`\n     *   - `@foo` → `@foo/eslint-formatter`\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n     * - A file path ... Load the file.\n     * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n     * This promise will be rejected if the given formatter was not found or not\n     * a function.\n     */\n    async loadFormatter(name = \"stylish\") {\n        if (typeof name !== \"string\") {\n            throw new Error(\"'name' must be a string\");\n        }\n\n        // replace \\ with / for Windows compatibility\n        const normalizedFormatName = name.replace(/\\\\/gu, \"/\");\n        const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n        // grab our options\n        const { cwd } = privateMembers.get(this).options;\n\n\n        let formatterPath;\n\n        // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n        if (!namespace && normalizedFormatName.includes(\"/\")) {\n            formatterPath = path.resolve(cwd, normalizedFormatName);\n        } else {\n            try {\n                const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n                // TODO: This is pretty dirty...would be nice to clean up at some point.\n                formatterPath = ModuleResolver.resolve(npmFormat, getPlaceholderPath(cwd));\n            } catch {\n                formatterPath = path.resolve(__dirname, \"../\", \"cli-engine\", \"formatters\", `${normalizedFormatName}.js`);\n            }\n        }\n\n        let formatter;\n\n        try {\n            formatter = (await import(pathToFileURL(formatterPath))).default;\n        } catch (ex) {\n\n            // check for formatters that have been removed\n            if (removedFormatters.has(name)) {\n                ex.message = `The ${name} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${name}\\``;\n            } else {\n                ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n            }\n\n            throw ex;\n        }\n\n\n        if (typeof formatter !== \"function\") {\n            throw new TypeError(`Formatter must be a function, but got a ${typeof formatter}.`);\n        }\n\n        const eslint = this;\n\n        return {\n\n            /**\n             * The main formatter method.\n             * @param {LintResult[]} results The lint results to format.\n             * @param {ResultsMeta} resultsMeta Warning count and max threshold.\n             * @returns {string} The formatted lint results.\n             */\n            format(results, resultsMeta) {\n                let rulesMeta = null;\n\n                results.sort(compareResultsByFilePath);\n\n                return formatter(results, {\n                    ...resultsMeta,\n                    cwd,\n                    get rulesMeta() {\n                        if (!rulesMeta) {\n                            rulesMeta = eslint.getRulesMetaForResults(results);\n                        }\n\n                        return rulesMeta;\n                    }\n                });\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n     *      or `undefined` if there is no configuration data for the object.\n     */\n    async calculateConfigForFile(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const options = privateMembers.get(this).options;\n        const absolutePath = path.resolve(options.cwd, filePath);\n        const configs = await this.#configLoader.loadConfigArrayForFile(absolutePath);\n\n        if (!configs) {\n            const error = new Error(\"Could not find config file.\");\n\n            error.messageTemplate = \"config-file-missing\";\n            throw error;\n        }\n\n        return configs.getConfig(absolutePath);\n    }\n\n    /**\n     * Finds the config file being used by this instance based on the options\n     * passed to the constructor.\n     * @param {string} [filePath] The path of the file to find the config file for.\n     * @returns {Promise<string|undefined>} The path to the config file being used or\n     *      `undefined` if no config file is being used.\n     */\n    findConfigFile(filePath) {\n        const options = privateMembers.get(this).options;\n\n        /*\n         * Because the new config lookup scheme skips the current directory\n         * and looks into the parent directories, we need to use a placeholder\n         * directory to ensure the file in cwd is checked.\n         */\n        const fakeCwd = path.join(options.cwd, \"__placeholder__\");\n\n        return this.#configLoader.findConfigFileForPath(filePath ?? fakeCwd)\n            .catch(() => void 0);\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\n     */\n    async isPathIgnored(filePath) {\n        const config = await this.calculateConfigForFile(filePath);\n\n        return config === void 0;\n    }\n}\n\n/**\n * Returns whether flat config should be used.\n * @returns {Promise<boolean>} Whether flat config should be used.\n */\nasync function shouldUseFlatConfig() {\n    return (process.env.ESLINT_USE_FLAT_CONFIG !== \"false\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    ESLint,\n    shouldUseFlatConfig,\n    locateConfigFileToUse\n};\n"
        }
    ]
}