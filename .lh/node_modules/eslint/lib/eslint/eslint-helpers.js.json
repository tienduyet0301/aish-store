{
    "sourceFile": "node_modules/eslint/lib/eslint/eslint-helpers.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Helper functions for ESLint class\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst path = require(\"node:path\");\nconst fs = require(\"node:fs\");\nconst fsp = fs.promises;\nconst isGlob = require(\"is-glob\");\nconst hash = require(\"../cli-engine/hash\");\nconst minimatch = require(\"minimatch\");\nconst globParent = require(\"glob-parent\");\n\n//-----------------------------------------------------------------------------\n// Fixup references\n//-----------------------------------------------------------------------------\n\nconst Minimatch = minimatch.Minimatch;\nconst MINIMATCH_OPTIONS = { dot: true };\n\n//-----------------------------------------------------------------------------\n// Types\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef {Object} GlobSearch\n * @property {Array<string>} patterns The normalized patterns to use for a search.\n * @property {Array<string>} rawPatterns The patterns as entered by the user\n *      before doing any normalization.\n */\n\n//-----------------------------------------------------------------------------\n// Errors\n//-----------------------------------------------------------------------------\n\n/**\n * The error type when no files match a glob.\n */\nclass NoFilesFoundError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     * @param {boolean} globEnabled If `false` then the pattern was a glob pattern, but glob was disabled.\n     */\n    constructor(pattern, globEnabled) {\n        super(`No files matching '${pattern}' were found${!globEnabled ? \" (glob was disabled)\" : \"\"}.`);\n        this.messageTemplate = \"file-not-found\";\n        this.messageData = { pattern, globDisabled: !globEnabled };\n    }\n}\n\n/**\n * The error type when a search fails to match multiple patterns.\n */\nclass UnmatchedSearchPatternsError extends Error {\n\n    /**\n     * @param {Object} options The options for the error.\n     * @param {string} options.basePath The directory that was searched.\n     * @param {Array<string>} options.unmatchedPatterns The glob patterns\n     *      which were not found.\n     * @param {Array<string>} options.patterns The glob patterns that were\n     *      searched.\n     * @param {Array<string>} options.rawPatterns The raw glob patterns that\n     *      were searched.\n     */\n    constructor({ basePath, unmatchedPatterns, patterns, rawPatterns }) {\n        super(`No files matching '${rawPatterns}' in '${basePath}' were found.`);\n        this.basePath = basePath;\n        this.unmatchedPatterns = unmatchedPatterns;\n        this.patterns = patterns;\n        this.rawPatterns = rawPatterns;\n    }\n}\n\n/**\n * The error type when there are files matched by a glob, but all of them have been ignored.\n */\nclass AllFilesIgnoredError extends Error {\n\n    /**\n     * @param {string} pattern The glob pattern which was not found.\n     */\n    constructor(pattern) {\n        super(`All files matched by '${pattern}' are ignored.`);\n        this.messageTemplate = \"all-matched-files-ignored\";\n        this.messageData = { pattern };\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// General Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is a non-empty string.\n */\nfunction isNonEmptyString(value) {\n    return typeof value === \"string\" && value.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty strings or not.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is an array of non-empty strings.\n */\nfunction isArrayOfNonEmptyString(value) {\n    return Array.isArray(value) && value.length && value.every(isNonEmptyString);\n}\n\n/**\n * Check if a given value is an empty array or an array of non-empty strings.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is an empty array or an array of non-empty\n *      strings.\n */\nfunction isEmptyArrayOrArrayOfNonEmptyString(value) {\n    return Array.isArray(value) && value.every(isNonEmptyString);\n}\n\n//-----------------------------------------------------------------------------\n// File-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Normalizes slashes in a file pattern to posix-style.\n * @param {string} pattern The pattern to replace slashes in.\n * @returns {string} The pattern with slashes normalized.\n */\nfunction normalizeToPosix(pattern) {\n    return pattern.replace(/\\\\/gu, \"/\");\n}\n\n/**\n * Check if a string is a glob pattern or not.\n * @param {string} pattern A glob pattern.\n * @returns {boolean} `true` if the string is a glob pattern.\n */\nfunction isGlobPattern(pattern) {\n    return isGlob(path.sep === \"\\\\\" ? normalizeToPosix(pattern) : pattern);\n}\n\n\n/**\n * Determines if a given glob pattern will return any results.\n * Used primarily to help with useful error messages.\n * @param {Object} options The options for the function.\n * @param {string} options.basePath The directory to search.\n * @param {string} options.pattern An absolute path glob pattern to match.\n * @returns {Promise<boolean>} True if there is a glob match, false if not.\n */\nasync function globMatch({ basePath, pattern }) {\n\n    let found = false;\n    const { hfs } = await import(\"@humanfs/node\");\n    const patternToUse = normalizeToPosix(path.relative(basePath, pattern));\n\n    const matcher = new Minimatch(patternToUse, MINIMATCH_OPTIONS);\n\n    const walkSettings = {\n\n        directoryFilter(entry) {\n            return !found && matcher.match(entry.path, true);\n        },\n\n        entryFilter(entry) {\n            if (found || entry.isDirectory) {\n                return false;\n            }\n\n            if (matcher.match(entry.path)) {\n                found = true;\n                return true;\n            }\n\n            return false;\n        }\n    };\n\n    if (await hfs.isDirectory(basePath)) {\n        return hfs.walk(basePath, walkSettings).next().then(() => found);\n    }\n\n    return found;\n}\n\n/**\n * Searches a directory looking for matching glob patterns. This uses\n * the config array's logic to determine if a directory or file should\n * be ignored, so it is consistent with how ignoring works throughout\n * ESLint.\n * @param {Object} options The options for this function.\n * @param {string} options.basePath The directory to search.\n * @param {Array<string>} options.patterns An array of absolute path glob patterns\n *      to match.\n * @param {Array<string>} options.rawPatterns An array of glob patterns\n *      as the user inputted them. Used for errors.\n * @param {ConfigLoader|LegacyConfigLoader} options.configLoader The config array to use for\n *      determining what to ignore.\n * @param {boolean} options.errorOnUnmatchedPattern Determines if an error\n *      should be thrown when a pattern is unmatched.\n * @returns {Promise<Array<string>>} An array of matching file paths\n *      or an empty array if there are no matches.\n * @throws {UnmatchedSearchPatternsError} If there is a pattern that doesn't\n *      match any files.\n */\nasync function globSearch({\n    basePath,\n    patterns,\n    rawPatterns,\n    configLoader,\n    errorOnUnmatchedPattern\n}) {\n\n    if (patterns.length === 0) {\n        return [];\n    }\n\n    /*\n     * In this section we are converting the patterns into Minimatch\n     * instances for performance reasons. Because we are doing the same\n     * matches repeatedly, it's best to compile those patterns once and\n     * reuse them multiple times.\n     *\n     * To do that, we convert any patterns with an absolute path into a\n     * relative path and normalize it to Posix-style slashes. We also keep\n     * track of the relative patterns to map them back to the original\n     * patterns, which we need in order to throw an error if there are any\n     * unmatched patterns.\n     */\n    const relativeToPatterns = new Map();\n    const matchers = patterns.map((pattern, i) => {\n        const patternToUse = normalizeToPosix(path.relative(basePath, pattern));\n\n        relativeToPatterns.set(patternToUse, patterns[i]);\n\n        return new Minimatch(patternToUse, MINIMATCH_OPTIONS);\n    });\n\n    /*\n     * We track unmatched patterns because we may want to throw an error when\n     * they occur. To start, this set is initialized with all of the patterns.\n     * Every time a match occurs, the pattern is removed from the set, making\n     * it easy to tell if we have any unmatched patterns left at the end of\n     * search.\n     */\n    const unmatchedPatterns = new Set([...relativeToPatterns.keys()]);\n    const { hfs } = await import(\"@humanfs/node\");\n\n    const walk = hfs.walk(\n        basePath,\n        {\n            async directoryFilter(entry) {\n\n                if (!matchers.some(matcher => matcher.match(entry.path, true))) {\n                    return false;\n                }\n\n                const absolutePath = path.resolve(basePath, entry.path);\n                const configs = await configLoader.loadConfigArrayForDirectory(absolutePath);\n\n                return !configs.isDirectoryIgnored(absolutePath);\n            },\n            async entryFilter(entry) {\n                const absolutePath = path.resolve(basePath, entry.path);\n\n                // entries may be directories or files so filter out directories\n                if (entry.isDirectory) {\n                    return false;\n                }\n\n                const configs = await configLoader.loadConfigArrayForFile(absolutePath);\n                const config = configs.getConfig(absolutePath);\n\n                /*\n                 * Optimization: We need to track when patterns are left unmatched\n                 * and so we use `unmatchedPatterns` to do that. There is a bit of\n                 * complexity here because the same file can be matched by more than\n                 * one pattern. So, when we start, we actually need to test every\n                 * pattern against every file. Once we know there are no remaining\n                 * unmatched patterns, then we can switch to just looking for the\n                 * first matching pattern for improved speed.\n                 */\n                const matchesPattern = unmatchedPatterns.size > 0\n                    ? matchers.reduce((previousValue, matcher) => {\n                        const pathMatches = matcher.match(entry.path);\n\n                        /*\n                         * We updated the unmatched patterns set only if the path\n                         * matches and the file has a config. If the file has no\n                         * config, that means there wasn't a match for the\n                         * pattern so it should not be removed.\n                         *\n                         * Performance note: `getConfig()` aggressively caches\n                         * results so there is no performance penalty for calling\n                         * it multiple times with the same argument.\n                         */\n                        if (pathMatches && config) {\n                            unmatchedPatterns.delete(matcher.pattern);\n                        }\n\n                        return pathMatches || previousValue;\n                    }, false)\n                    : matchers.some(matcher => matcher.match(entry.path));\n\n                return matchesPattern && config !== void 0;\n            }\n        }\n    );\n\n    const filePaths = [];\n\n    if (await hfs.isDirectory(basePath)) {\n        for await (const entry of walk) {\n            filePaths.push(path.resolve(basePath, entry.path));\n        }\n    }\n\n    // now check to see if we have any unmatched patterns\n    if (errorOnUnmatchedPattern && unmatchedPatterns.size > 0) {\n        throw new UnmatchedSearchPatternsError({\n            basePath,\n            unmatchedPatterns: [...unmatchedPatterns].map(\n                pattern => relativeToPatterns.get(pattern)\n            ),\n            patterns,\n            rawPatterns\n        });\n    }\n\n    return filePaths;\n}\n\n/**\n * Throws an error for unmatched patterns. The error will only contain information about the first one.\n * Checks to see if there are any ignored results for a given search.\n * @param {Object} options The options for this function.\n * @param {string} options.basePath The directory to search.\n * @param {Array<string>} options.patterns An array of glob patterns\n *      that were used in the original search.\n * @param {Array<string>} options.rawPatterns An array of glob patterns\n *      as the user inputted them. Used for errors.\n * @param {Array<string>} options.unmatchedPatterns A non-empty array of absolute path glob patterns\n *      that were unmatched in the original search.\n * @returns {void} Always throws an error.\n * @throws {NoFilesFoundError} If the first unmatched pattern\n *      doesn't match any files even when there are no ignores.\n * @throws {AllFilesIgnoredError} If the first unmatched pattern\n *      matches some files when there are no ignores.\n */\nasync function throwErrorForUnmatchedPatterns({\n    basePath,\n    patterns,\n    rawPatterns,\n    unmatchedPatterns\n}) {\n\n    const pattern = unmatchedPatterns[0];\n    const rawPattern = rawPatterns[patterns.indexOf(pattern)];\n\n    const patternHasMatch = await globMatch({\n        basePath,\n        pattern\n    });\n\n    if (patternHasMatch) {\n        throw new AllFilesIgnoredError(rawPattern);\n    }\n\n    // if we get here there are truly no matches\n    throw new NoFilesFoundError(rawPattern, true);\n}\n\n/**\n * Performs multiple glob searches in parallel.\n * @param {Object} options The options for this function.\n * @param {Map<string,GlobSearch>} options.searches\n *      A map of absolute path glob patterns to match.\n * @param {ConfigLoader|LegacyConfigLoader} options.configLoader The config loader to use for\n *      determining what to ignore.\n * @param {boolean} options.errorOnUnmatchedPattern Determines if an\n *      unmatched glob pattern should throw an error.\n * @returns {Promise<Array<string>>} An array of matching file paths\n *      or an empty array if there are no matches.\n */\nasync function globMultiSearch({ searches, configLoader, errorOnUnmatchedPattern }) {\n\n    /*\n     * For convenience, we normalized the search map into an array of objects.\n     * Next, we filter out all searches that have no patterns. This happens\n     * primarily for the cwd, which is prepopulated in the searches map as an\n     * optimization. However, if it has no patterns, it means all patterns\n     * occur outside of the cwd and we can safely filter out that search.\n     */\n    const normalizedSearches = [...searches].map(\n        ([basePath, { patterns, rawPatterns }]) => ({ basePath, patterns, rawPatterns })\n    ).filter(({ patterns }) => patterns.length > 0);\n\n    const results = await Promise.allSettled(\n        normalizedSearches.map(\n            ({ basePath, patterns, rawPatterns }) => globSearch({\n                basePath,\n                patterns,\n                rawPatterns,\n                configLoader,\n                errorOnUnmatchedPattern\n            })\n        )\n    );\n\n    /*\n     * The first loop handles errors from the glob searches. Since we can't\n     * use `await` inside `flatMap`, we process errors separately in this loop.\n     * This results in two iterations over `results`, but since the length is\n     * less than or equal to the number of globs and directories passed on the\n     * command line, the performance impact should be minimal.\n     */\n    for (let i = 0; i < results.length; i++) {\n\n        const result = results[i];\n        const currentSearch = normalizedSearches[i];\n\n        if (result.status === \"fulfilled\") {\n            continue;\n        }\n\n        // if we make it here then there was an error\n        const error = result.reason;\n\n        // unexpected errors should be re-thrown\n        if (!error.basePath) {\n            throw error;\n        }\n\n        if (errorOnUnmatchedPattern) {\n\n            await throwErrorForUnmatchedPatterns({\n                ...currentSearch,\n                unmatchedPatterns: error.unmatchedPatterns\n            });\n\n        }\n\n    }\n\n    // second loop for `fulfulled` results\n    return results.flatMap(result => result.value);\n\n}\n\n/**\n * Finds all files matching the options specified.\n * @param {Object} args The arguments objects.\n * @param {Array<string>} args.patterns An array of glob patterns.\n * @param {boolean} args.globInputPaths true to interpret glob patterns,\n *      false to not interpret glob patterns.\n * @param {string} args.cwd The current working directory to find from.\n * @param {ConfigLoader|LegacyConfigLoader} args.configLoader The config loeader for the current run.\n * @param {boolean} args.errorOnUnmatchedPattern Determines if an unmatched pattern\n *      should throw an error.\n * @returns {Promise<Array<string>>} The fully resolved file paths.\n * @throws {AllFilesIgnoredError} If there are no results due to an ignore pattern.\n * @throws {NoFilesFoundError} If no files matched the given patterns.\n */\nasync function findFiles({\n    patterns,\n    globInputPaths,\n    cwd,\n    configLoader,\n    errorOnUnmatchedPattern\n}) {\n\n    const results = [];\n    const missingPatterns = [];\n    let globbyPatterns = [];\n    let rawPatterns = [];\n    const searches = new Map([[cwd, { patterns: globbyPatterns, rawPatterns: [] }]]);\n\n    /*\n     * This part is a bit involved because we need to account for\n     * the different ways that the patterns can match directories.\n     * For each different way, we need to decide if we should look\n     * for a config file or just use the default config. (Directories\n     * without a config file always use the default config.)\n     *\n     * Here are the cases:\n     *\n     * 1. A directory is passed directly (e.g., \"subdir\"). In this case, we\n     * can assume that the user intends to lint this directory and we should\n     * not look for a config file in the parent directory, because the only\n     * reason to do that would be to ignore this directory (which we already\n     * know we don't want to do). Instead, we use the default config until we\n     * get to the directory that was passed, at which point we start looking\n     * for config files again.\n     *\n     * 2. A dot (\".\") or star (\"*\"). In this case, we want to read\n     * the config file in the current directory because the user is\n     * explicitly asking to lint the current directory. Note that \".\"\n     * will traverse into subdirectories while \"*\" will not.\n     *\n     * 3. A directory is passed in the form of \"subdir/subsubdir\".\n     * In this case, we don't want to look for a config file in the\n     * parent directory (\"subdir\"). We can skip looking for a config\n     * file until `entry.depth` is greater than 1 because there's no\n     * way that the pattern can match `entry.path` yet.\n     *\n     * 4. A directory glob pattern is passed (e.g., \"subd*\"). We want\n     * this case to act like case 2 because it's unclear whether or not\n     * any particular directory is meant to be traversed.\n     *\n     * 5. A recursive glob pattern is passed (e.g., \"**\"). We want this\n     * case to act like case 2.\n     */\n\n    // check to see if we have explicit files and directories\n    const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));\n    const stats = await Promise.all(\n        filePaths.map(\n            filePath => fsp.stat(filePath).catch(() => { })\n        )\n    );\n\n    stats.forEach((stat, index) => {\n\n        const filePath = filePaths[index];\n        const pattern = normalizeToPosix(patterns[index]);\n\n        if (stat) {\n\n            // files are added directly to the list\n            if (stat.isFile()) {\n                results.push(filePath);\n            }\n\n            // directories need extensions attached\n            if (stat.isDirectory()) {\n\n                if (!searches.has(filePath)) {\n                    searches.set(filePath, { patterns: [], rawPatterns: [] });\n                }\n                ({ patterns: globbyPatterns, rawPatterns } = searches.get(filePath));\n\n                globbyPatterns.push(`${normalizeToPosix(filePath)}/**`);\n                rawPatterns.push(pattern);\n            }\n\n            return;\n        }\n\n        // save patterns for later use based on whether globs are enabled\n        if (globInputPaths && isGlobPattern(pattern)) {\n\n            /*\n             * We are grouping patterns by their glob parent. This is done to\n             * make it easier to determine when a config file should be loaded.\n             */\n\n            const basePath = path.resolve(cwd, globParent(pattern));\n\n            if (!searches.has(basePath)) {\n                searches.set(basePath, { patterns: [], rawPatterns: [] });\n            }\n            ({ patterns: globbyPatterns, rawPatterns } = searches.get(basePath));\n\n            globbyPatterns.push(filePath);\n            rawPatterns.push(pattern);\n        } else {\n            missingPatterns.push(pattern);\n        }\n    });\n\n    // there were patterns that didn't match anything, tell the user\n    if (errorOnUnmatchedPattern && missingPatterns.length) {\n        throw new NoFilesFoundError(missingPatterns[0], globInputPaths);\n    }\n\n    // now we are safe to do the search\n    const globbyResults = await globMultiSearch({\n        searches,\n        configLoader,\n        errorOnUnmatchedPattern\n    });\n\n    return [\n        ...new Set([\n            ...results,\n            ...globbyResults\n        ])\n    ];\n}\n\n//-----------------------------------------------------------------------------\n// Results-related Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath Absolute file path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @param {\"ignored\"|\"external\"|\"unconfigured\"} configStatus A status that determines why the file is ignored\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir, configStatus) {\n    let message;\n\n    switch (configStatus) {\n        case \"external\":\n            message = \"File ignored because outside of base path.\";\n            break;\n        case \"unconfigured\":\n            message = \"File ignored because no matching configuration was supplied.\";\n            break;\n        default:\n            {\n                const isInNodeModules = baseDir && path.dirname(path.relative(baseDir, filePath)).split(path.sep).includes(\"node_modules\");\n\n                if (isInNodeModules) {\n                    message = \"File ignored by default because it is located under the node_modules directory. Use ignore pattern \\\"!**/node_modules/\\\" to disable file ignore settings or use \\\"--no-warn-ignored\\\" to suppress this warning.\";\n                } else {\n                    message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to disable file ignore settings or use \\\"--no-warn-ignored\\\" to suppress this warning.\";\n                }\n            }\n            break;\n    }\n\n    return {\n        filePath,\n        messages: [\n            {\n                ruleId: null,\n                fatal: false,\n                severity: 1,\n                message,\n                nodeType: null\n            }\n        ],\n        suppressedMessages: [],\n        errorCount: 0,\n        warningCount: 1,\n        fatalErrorCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    };\n}\n\n//-----------------------------------------------------------------------------\n// Options-related Helpers\n//-----------------------------------------------------------------------------\n\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is valid fix type.\n */\nfunction isFixType(x) {\n    return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if `x` is an array of fix types.\n */\nfunction isFixTypeArray(x) {\n    return Array.isArray(x) && x.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n    constructor(messages) {\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n        this.code = \"ESLINT_INVALID_OPTIONS\";\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\n    }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {ESLintOptions} options The options to process.\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\n * @returns {ESLintOptions} The normalized options.\n */\nfunction processOptions({\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    fix = false,\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    flags = [],\n    globInputPaths = true,\n    ignore = true,\n    ignorePatterns = null,\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    stats = false,\n    warnIgnored = true,\n    passOnNoPatterns = false,\n    ruleFilter = () => true,\n    ...unknownOptions\n}) {\n    const errors = [];\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length >= 1) {\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"configFile\")) {\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"envs\")) {\n            errors.push(\"'envs' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"extensions\")) {\n            errors.push(\"'extensions' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"resolvePluginsRelativeTo\")) {\n            errors.push(\"'resolvePluginsRelativeTo' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"globals\")) {\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.languageOptions.globals' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePath\")) {\n            errors.push(\"'ignorePath' has been removed.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parser\")) {\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.languageOptions.parser' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.languageOptions.parserOptions' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rules\")) {\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rulePaths\")) {\n            errors.push(\"'rulePaths' has been removed. Please define your rules using plugins.\");\n        }\n        if (unknownOptionKeys.includes(\"reportUnusedDisableDirectives\")) {\n            errors.push(\"'reportUnusedDisableDirectives' has been removed. Please use the 'overrideConfig.linterOptions.reportUnusedDisableDirectives' option instead.\");\n        }\n    }\n    if (typeof allowInlineConfig !== \"boolean\") {\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\n    }\n    if (typeof baseConfig !== \"object\") {\n        errors.push(\"'baseConfig' must be an object or null.\");\n    }\n    if (typeof cache !== \"boolean\") {\n        errors.push(\"'cache' must be a boolean.\");\n    }\n    if (!isNonEmptyString(cacheLocation)) {\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\n    }\n    if (\n        cacheStrategy !== \"metadata\" &&\n        cacheStrategy !== \"content\"\n    ) {\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n    }\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n        errors.push(\"'cwd' must be an absolute path.\");\n    }\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n    }\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n        errors.push(\"'fix' must be a boolean or a function.\");\n    }\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n        errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n    }\n    if (!isEmptyArrayOrArrayOfNonEmptyString(flags)) {\n        errors.push(\"'flags' must be an array of non-empty strings.\");\n    }\n    if (typeof globInputPaths !== \"boolean\") {\n        errors.push(\"'globInputPaths' must be a boolean.\");\n    }\n    if (typeof ignore !== \"boolean\") {\n        errors.push(\"'ignore' must be a boolean.\");\n    }\n    if (!isEmptyArrayOrArrayOfNonEmptyString(ignorePatterns) && ignorePatterns !== null) {\n        errors.push(\"'ignorePatterns' must be an array of non-empty strings or null.\");\n    }\n    if (typeof overrideConfig !== \"object\") {\n        errors.push(\"'overrideConfig' must be an object or null.\");\n    }\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null && overrideConfigFile !== true) {\n        errors.push(\"'overrideConfigFile' must be a non-empty string, null, or true.\");\n    }\n    if (typeof passOnNoPatterns !== \"boolean\") {\n        errors.push(\"'passOnNoPatterns' must be a boolean.\");\n    }\n    if (typeof plugins !== \"object\") {\n        errors.push(\"'plugins' must be an object or null.\");\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n        errors.push(\"'plugins' must not include an empty string.\");\n    }\n    if (Array.isArray(plugins)) {\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n    }\n    if (typeof stats !== \"boolean\") {\n        errors.push(\"'stats' must be a boolean.\");\n    }\n    if (typeof warnIgnored !== \"boolean\") {\n        errors.push(\"'warnIgnored' must be a boolean.\");\n    }\n    if (typeof ruleFilter !== \"function\") {\n        errors.push(\"'ruleFilter' must be a function.\");\n    }\n    if (errors.length > 0) {\n        throw new ESLintInvalidOptionsError(errors);\n    }\n\n    return {\n        allowInlineConfig,\n        baseConfig,\n        cache,\n        cacheLocation,\n        cacheStrategy,\n\n        // when overrideConfigFile is true that means don't do config file lookup\n        configFile: overrideConfigFile === true ? false : overrideConfigFile,\n        overrideConfig,\n        cwd: path.normalize(cwd),\n        errorOnUnmatchedPattern,\n        fix,\n        fixTypes,\n        flags: [...flags],\n        globInputPaths,\n        ignore,\n        ignorePatterns,\n        stats,\n        passOnNoPatterns,\n        warnIgnored,\n        ruleFilter\n    };\n}\n\n\n//-----------------------------------------------------------------------------\n// Cache-related helpers\n//-----------------------------------------------------------------------------\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    const normalizedCacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    findFiles,\n\n    isNonEmptyString,\n    isArrayOfNonEmptyString,\n\n    createIgnoreResult,\n    isErrorMessage,\n\n    processOptions,\n\n    getCacheFile\n};\n"
        }
    ]
}