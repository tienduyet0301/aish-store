{
    "sourceFile": "node_modules/eslint/lib/eslint/legacy-eslint.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892209734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "/**\n * @fileoverview Main API Class\n * @author Kai Cataldo\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"node:path\");\nconst fs = require(\"node:fs\");\nconst { promisify } = require(\"node:util\");\nconst { CLIEngine, getCLIEngineInternalSlots } = require(\"../cli-engine/cli-engine\");\nconst BuiltinRules = require(\"../rules\");\nconst {\n    Legacy: {\n        ConfigOps: {\n            getRuleSeverity\n        }\n    }\n} = require(\"@eslint/eslintrc\");\nconst { version } = require(\"../../package.json\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {import(\"../shared/types\").LintResult} LintResult */\n/** @typedef {import(\"../shared/types\").ResultsMeta} ResultsMeta */\n\n/**\n * The main formatter object.\n * @typedef LoadedFormatter\n * @property {(results: LintResult[], resultsMeta: ResultsMeta) => string | Promise<string>} format format function.\n */\n\n/**\n * The options with which to configure the LegacyESLint instance.\n * @typedef {Object} LegacyESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {string[]} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {string} [overrideConfigFile] The configuration file to use.\n * @property {Record<string,Plugin>|null} [plugins] Preloaded plugins. This is a map-like object, keys are plugin IDs and each value is implementation.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\n * @property {boolean} [passOnNoPatterns=false] When set to true, missing patterns cause\n *      the linting operation to short circuit and not report any failures.\n */\n\n/**\n * A rules metadata object.\n * @typedef {Object} RulesMeta\n * @property {string} id The plugin ID.\n * @property {Object} definition The plugin definition.\n */\n\n/**\n * Private members for the `ESLint` instance.\n * @typedef {Object} ESLintPrivateMembers\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\n * @property {LegacyESLintOptions} options The options used to instantiate the ESLint instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst writeFile = promisify(fs.writeFile);\n\n/**\n * The map with which to store private class members.\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\n */\nconst privateMembersMap = new WeakMap();\n\n/**\n * Check if a given value is a non-empty string or not.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is a non-empty string.\n */\nfunction isNonEmptyString(value) {\n    return typeof value === \"string\" && value.trim() !== \"\";\n}\n\n/**\n * Check if a given value is an array of non-empty strings or not.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is an array of non-empty strings.\n */\nfunction isArrayOfNonEmptyString(value) {\n    return Array.isArray(value) && value.length && value.every(isNonEmptyString);\n}\n\n/**\n * Check if a given value is an empty array or an array of non-empty strings.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is an empty array or an array of non-empty\n *      strings.\n */\nfunction isEmptyArrayOrArrayOfNonEmptyString(value) {\n    return Array.isArray(value) && value.every(isNonEmptyString);\n}\n\n/**\n * Check if a given value is a valid fix type or not.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is valid fix type.\n */\nfunction isFixType(value) {\n    return value === \"directive\" || value === \"problem\" || value === \"suggestion\" || value === \"layout\";\n}\n\n/**\n * Check if a given value is an array of fix types or not.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if `value` is an array of fix types.\n */\nfunction isFixTypeArray(value) {\n    return Array.isArray(value) && value.every(isFixType);\n}\n\n/**\n * The error for invalid options.\n */\nclass ESLintInvalidOptionsError extends Error {\n    constructor(messages) {\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n        this.code = \"ESLINT_INVALID_OPTIONS\";\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\n    }\n}\n\n/**\n * Validates and normalizes options for the wrapped CLIEngine instance.\n * @param {LegacyESLintOptions} options The options to process.\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\n * @returns {LegacyESLintOptions} The normalized options.\n */\nfunction processOptions({\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    extensions = null, // ← should be null by default because if it's an array then it suppresses RFC20 feature.\n    fix = false,\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    flags, /* eslint-disable-line no-unused-vars -- leaving for compatibility with ESLint#hasFlag */\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null, // ← should be null by default because if it's a string then it may throw ENOENT.\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null, // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    resolvePluginsRelativeTo = null, // ← should be null by default because if it's a string then it suppresses RFC47 feature.\n    rulePaths = [],\n    useEslintrc = true,\n    passOnNoPatterns = false,\n    ...unknownOptions\n}) {\n    const errors = [];\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length >= 1) {\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"configFile\")) {\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"envs\")) {\n            errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"globals\")) {\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parser\")) {\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\n        }\n        if (unknownOptionKeys.includes(\"rules\")) {\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n        }\n    }\n    if (typeof allowInlineConfig !== \"boolean\") {\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\n    }\n    if (typeof baseConfig !== \"object\") {\n        errors.push(\"'baseConfig' must be an object or null.\");\n    }\n    if (typeof cache !== \"boolean\") {\n        errors.push(\"'cache' must be a boolean.\");\n    }\n    if (!isNonEmptyString(cacheLocation)) {\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\n    }\n    if (\n        cacheStrategy !== \"metadata\" &&\n        cacheStrategy !== \"content\"\n    ) {\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n    }\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n        errors.push(\"'cwd' must be an absolute path.\");\n    }\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n    }\n    if (!isEmptyArrayOrArrayOfNonEmptyString(extensions) && extensions !== null) {\n        errors.push(\"'extensions' must be an array of non-empty strings or null.\");\n    }\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n        errors.push(\"'fix' must be a boolean or a function.\");\n    }\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n        errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n    }\n    if (typeof globInputPaths !== \"boolean\") {\n        errors.push(\"'globInputPaths' must be a boolean.\");\n    }\n    if (typeof ignore !== \"boolean\") {\n        errors.push(\"'ignore' must be a boolean.\");\n    }\n    if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n        errors.push(\"'ignorePath' must be a non-empty string or null.\");\n    }\n    if (typeof overrideConfig !== \"object\") {\n        errors.push(\"'overrideConfig' must be an object or null.\");\n    }\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\n        errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\n    }\n    if (typeof plugins !== \"object\") {\n        errors.push(\"'plugins' must be an object or null.\");\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n        errors.push(\"'plugins' must not include an empty string.\");\n    }\n    if (Array.isArray(plugins)) {\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n    }\n    if (\n        reportUnusedDisableDirectives !== \"error\" &&\n        reportUnusedDisableDirectives !== \"warn\" &&\n        reportUnusedDisableDirectives !== \"off\" &&\n        reportUnusedDisableDirectives !== null\n    ) {\n        errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n    }\n    if (\n        !isNonEmptyString(resolvePluginsRelativeTo) &&\n        resolvePluginsRelativeTo !== null\n    ) {\n        errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\n    }\n    if (!isEmptyArrayOrArrayOfNonEmptyString(rulePaths)) {\n        errors.push(\"'rulePaths' must be an array of non-empty strings.\");\n    }\n    if (typeof useEslintrc !== \"boolean\") {\n        errors.push(\"'useEslintrc' must be a boolean.\");\n    }\n    if (typeof passOnNoPatterns !== \"boolean\") {\n        errors.push(\"'passOnNoPatterns' must be a boolean.\");\n    }\n\n    if (errors.length > 0) {\n        throw new ESLintInvalidOptionsError(errors);\n    }\n\n    return {\n        allowInlineConfig,\n        baseConfig,\n        cache,\n        cacheLocation,\n        cacheStrategy,\n        configFile: overrideConfigFile,\n        cwd: path.normalize(cwd),\n        errorOnUnmatchedPattern,\n        extensions,\n        fix,\n        fixTypes,\n        flags: [], // LegacyESLint does not support flags, so just ignore them.\n        globInputPaths,\n        ignore,\n        ignorePath,\n        reportUnusedDisableDirectives,\n        resolvePluginsRelativeTo,\n        rulePaths,\n        useEslintrc,\n        passOnNoPatterns\n    };\n}\n\n/**\n * Check if a value has one or more properties and that value is not undefined.\n * @param {any} obj The value to check.\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\n */\nfunction hasDefinedProperty(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        for (const key in obj) {\n            if (typeof obj[key] !== \"undefined\") {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\n        retVal[id] = rule.meta;\n        return retVal;\n    }, {});\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\n    const {\n        configArrayFactory,\n        options: { cwd }\n    } = getCLIEngineInternalSlots(cliEngine);\n    const filePath = path.isAbsolute(maybeFilePath)\n        ? maybeFilePath\n        : path.join(cwd, \"__placeholder__.js\");\n    const configArray = configArrayFactory.getConfigArrayForFile(filePath);\n    const config = configArray.extractConfig(filePath);\n\n    // Most files use the same config, so cache it.\n    if (!usedDeprecatedRulesCache.has(config)) {\n        const pluginRules = configArray.pluginRules;\n        const retv = [];\n\n        for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n            if (getRuleSeverity(ruleConf) === 0) {\n                continue;\n            }\n            const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\n            const meta = rule && rule.meta;\n\n            if (meta && meta.deprecated) {\n                retv.push({ ruleId, replacedBy: meta.replacedBy || [] });\n            }\n        }\n\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n    }\n\n    return usedDeprecatedRulesCache.get(config);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} cliEngine The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processCLIEngineLintReport(cliEngine, { results }) {\n    const descriptor = {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\n        }\n    };\n\n    for (const result of results) {\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n    }\n\n    return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n    if (a.filePath < b.filePath) {\n        return -1;\n    }\n\n    if (a.filePath > b.filePath) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Main API.\n */\nclass LegacyESLint {\n\n    /**\n     * The type of configuration used by this class.\n     * @type {string}\n     */\n    static configType = \"eslintrc\";\n\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param {LegacyESLintOptions} options The options for this instance.\n     */\n    constructor(options = {}) {\n        const processedOptions = processOptions(options);\n        const cliEngine = new CLIEngine(processedOptions, { preloadedPlugins: options.plugins });\n        const {\n            configArrayFactory,\n            lastConfigArrays\n        } = getCLIEngineInternalSlots(cliEngine);\n        let updated = false;\n\n        /*\n         * Address `overrideConfig` to set override config.\n         * Operate the `configArrayFactory` internal slot directly because this\n         * functionality doesn't exist as the public API of CLIEngine.\n         */\n        if (hasDefinedProperty(options.overrideConfig)) {\n            configArrayFactory.setOverrideConfig(options.overrideConfig);\n            updated = true;\n        }\n\n        // Update caches.\n        if (updated) {\n            configArrayFactory.clearCache();\n            lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n        }\n\n        // Initialize private properties.\n        privateMembersMap.set(this, {\n            cliEngine,\n            options: processedOptions\n        });\n    }\n\n    /**\n     * The version text.\n     * @type {string}\n     */\n    static get version() {\n        return version;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintResult[]} results The lint results.\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\n     */\n    static async outputFixes(results) {\n        if (!Array.isArray(results)) {\n            throw new Error(\"'results' must be an array\");\n        }\n\n        await Promise.all(\n            results\n                .filter(result => {\n                    if (typeof result !== \"object\" || result === null) {\n                        throw new Error(\"'results' must include only objects\");\n                    }\n                    return (\n                        typeof result.output === \"string\" &&\n                        path.isAbsolute(result.filePath)\n                    );\n                })\n                .map(r => writeFile(r.filePath, r.output))\n        );\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        return CLIEngine.getErrorResults(results);\n    }\n\n    /**\n     * Returns meta objects for each rule represented in the lint results.\n     * @param {LintResult[]} results The results to fetch rules meta for.\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\n     */\n    getRulesMetaForResults(results) {\n\n        const resultRuleIds = new Set();\n\n        // first gather all ruleIds from all results\n\n        for (const result of results) {\n            for (const { ruleId } of result.messages) {\n                resultRuleIds.add(ruleId);\n            }\n            for (const { ruleId } of result.suppressedMessages) {\n                resultRuleIds.add(ruleId);\n            }\n        }\n\n        // create a map of all rules in the results\n\n        const { cliEngine } = privateMembersMap.get(this);\n        const rules = cliEngine.getRules();\n        const resultRules = new Map();\n\n        for (const [ruleId, rule] of rules) {\n            if (resultRuleIds.has(ruleId)) {\n                resultRules.set(ruleId, rule);\n            }\n        }\n\n        return createRulesMeta(resultRules);\n\n    }\n\n    /* eslint-disable no-unused-vars, class-methods-use-this -- leaving for compatibility with ESLint#hasFlag */\n    /**\n     * Indicates if the given feature flag is enabled for this instance. For this\n     * class, this always returns `false` because it does not support feature flags.\n     * @param {string} flag The feature flag to check.\n     * @returns {boolean} Always false.\n     */\n    hasFlag(flag) {\n        return false;\n    }\n    /* eslint-enable no-unused-vars, class-methods-use-this -- reenable rules for the rest of the file */\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n     */\n    async lintFiles(patterns) {\n        const { cliEngine, options } = privateMembersMap.get(this);\n\n        if (options.passOnNoPatterns && (patterns === \"\" || (Array.isArray(patterns) && patterns.length === 0))) {\n            return [];\n        }\n\n        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n            throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n        }\n\n        return processCLIEngineLintReport(\n            cliEngine,\n            cliEngine.executeOnFiles(patterns)\n        );\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} code A string of JavaScript code to lint.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to the file of the source code.\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n     */\n    async lintText(code, options = {}) {\n        if (typeof code !== \"string\") {\n            throw new Error(\"'code' must be a string\");\n        }\n        if (typeof options !== \"object\") {\n            throw new Error(\"'options' must be an object, null, or undefined\");\n        }\n        const {\n            filePath,\n            warnIgnored = false,\n            ...unknownOptions\n        } = options || {};\n\n        const unknownOptionKeys = Object.keys(unknownOptions);\n\n        if (unknownOptionKeys.length > 0) {\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n        }\n\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n        }\n        if (typeof warnIgnored !== \"boolean\") {\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n        }\n\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return processCLIEngineLintReport(\n            cliEngine,\n            cliEngine.executeOnText(code, filePath, warnIgnored)\n        );\n    }\n\n    /**\n     * Returns the formatter representing the given formatter name.\n     * @param {string} [name] The name of the formatter to load.\n     * The following values are allowed:\n     * - `undefined` ... Load `stylish` builtin formatter.\n     * - A builtin formatter name ... Load the builtin formatter.\n     * - A third-party formatter name:\n     *   - `foo` → `eslint-formatter-foo`\n     *   - `@foo` → `@foo/eslint-formatter`\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n     * - A file path ... Load the file.\n     * @returns {Promise<LoadedFormatter>} A promise resolving to the formatter object.\n     * This promise will be rejected if the given formatter was not found or not\n     * a function.\n     */\n    async loadFormatter(name = \"stylish\") {\n        if (typeof name !== \"string\") {\n            throw new Error(\"'name' must be a string\");\n        }\n\n        const { cliEngine, options } = privateMembersMap.get(this);\n        const formatter = cliEngine.getFormatter(name);\n\n        if (typeof formatter !== \"function\") {\n            throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\n        }\n\n        return {\n\n            /**\n             * The main formatter method.\n             * @param {LintResult[]} results The lint results to format.\n             * @param {ResultsMeta} resultsMeta Warning count and max threshold.\n             * @returns {string | Promise<string>} The formatted lint results.\n             */\n            format(results, resultsMeta) {\n                let rulesMeta = null;\n\n                results.sort(compareResultsByFilePath);\n\n                return formatter(results, {\n                    ...resultsMeta,\n                    get cwd() {\n                        return options.cwd;\n                    },\n                    get rulesMeta() {\n                        if (!rulesMeta) {\n                            rulesMeta = createRulesMeta(cliEngine.getRules());\n                        }\n\n                        return rulesMeta;\n                    }\n                });\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Promise<ConfigData>} A configuration object for the file.\n     */\n    async calculateConfigForFile(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return cliEngine.getConfigForFile(filePath);\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\n     */\n    async isPathIgnored(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const { cliEngine } = privateMembersMap.get(this);\n\n        return cliEngine.isPathIgnored(filePath);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    LegacyESLint,\n\n    /**\n     * Get the private class members of a given ESLint instance for tests.\n     * @param {ESLint} instance The ESLint instance to get.\n     * @returns {ESLintPrivateMembers} The instance's private class members.\n     */\n    getESLintPrivateMembers(instance) {\n        return privateMembersMap.get(instance);\n    }\n};\n"
        }
    ]
}