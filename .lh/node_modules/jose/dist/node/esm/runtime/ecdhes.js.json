{
    "sourceFile": "node_modules/jose/dist/node/esm/runtime/ecdhes.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892368762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { diffieHellman, generateKeyPair as generateKeyPairCb, KeyObject } from 'crypto';\nimport { promisify } from 'util';\nimport getNamedCurve from './get_named_curve.js';\nimport { encoder, concat, uint32be, lengthAndInput, concatKdf } from '../lib/buffer_utils.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkEncCryptoKey } from '../lib/crypto_key.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst generateKeyPair = promisify(generateKeyPairCb);\nexport async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    let publicKey;\n    if (isCryptoKey(publicKee)) {\n        checkEncCryptoKey(publicKee, 'ECDH');\n        publicKey = KeyObject.from(publicKee);\n    }\n    else if (isKeyObject(publicKee)) {\n        publicKey = publicKee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(publicKee, ...types));\n    }\n    let privateKey;\n    if (isCryptoKey(privateKee)) {\n        checkEncCryptoKey(privateKee, 'ECDH', 'deriveBits');\n        privateKey = KeyObject.from(privateKee);\n    }\n    else if (isKeyObject(privateKee)) {\n        privateKey = privateKee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(privateKee, ...types));\n    }\n    const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));\n    const sharedSecret = diffieHellman({ privateKey, publicKey });\n    return concatKdf(sharedSecret, keyLength, value);\n}\nexport async function generateEpk(kee) {\n    let key;\n    if (isCryptoKey(kee)) {\n        key = KeyObject.from(kee);\n    }\n    else if (isKeyObject(kee)) {\n        key = kee;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(kee, ...types));\n    }\n    switch (key.asymmetricKeyType) {\n        case 'x25519':\n            return generateKeyPair('x25519');\n        case 'x448': {\n            return generateKeyPair('x448');\n        }\n        case 'ec': {\n            const namedCurve = getNamedCurve(key);\n            return generateKeyPair('ec', { namedCurve });\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EPK');\n    }\n}\nexport const ecdhAllowed = (key) => ['P-256', 'P-384', 'P-521', 'X25519', 'X448'].includes(getNamedCurve(key));\n"
        }
    ]
}