{
    "sourceFile": "node_modules/jose/dist/node/esm/runtime/jwk_to_key.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892369183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "import { Buffer } from 'buffer';\nimport { createPrivateKey, createPublicKey, createSecretKey } from 'crypto';\nimport { decode as base64url } from './base64url.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { setCurve } from './get_named_curve.js';\nimport { setModulusLength } from './check_modulus_length.js';\nimport Asn1SequenceEncoder from './asn1_sequence_encoder.js';\nimport { jwkImport } from './flags.js';\nconst parse = (jwk) => {\n    if (jwkImport && jwk.kty !== 'oct') {\n        return jwk.d\n            ? createPrivateKey({ format: 'jwk', key: jwk })\n            : createPublicKey({ format: 'jwk', key: jwk });\n    }\n    switch (jwk.kty) {\n        case 'oct': {\n            return createSecretKey(base64url(jwk.k));\n        }\n        case 'RSA': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            const modulus = Buffer.from(jwk.n, 'base64');\n            const exponent = Buffer.from(jwk.e, 'base64');\n            if (isPrivate) {\n                enc.zero();\n                enc.unsignedInteger(modulus);\n                enc.unsignedInteger(exponent);\n                enc.unsignedInteger(Buffer.from(jwk.d, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.p, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.q, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.dp, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.dq, 'base64'));\n                enc.unsignedInteger(Buffer.from(jwk.qi, 'base64'));\n            }\n            else {\n                enc.unsignedInteger(modulus);\n                enc.unsignedInteger(exponent);\n            }\n            const der = enc.end();\n            const createInput = {\n                key: der,\n                format: 'der',\n                type: 'pkcs1',\n            };\n            const keyObject = isPrivate ? createPrivateKey(createInput) : createPublicKey(createInput);\n            setModulusLength(keyObject, modulus.length << 3);\n            return keyObject;\n        }\n        case 'EC': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            const pub = Buffer.concat([\n                Buffer.alloc(1, 4),\n                Buffer.from(jwk.x, 'base64'),\n                Buffer.from(jwk.y, 'base64'),\n            ]);\n            if (isPrivate) {\n                enc.zero();\n                const enc$1 = new Asn1SequenceEncoder();\n                enc$1.oidFor('ecPublicKey');\n                enc$1.oidFor(jwk.crv);\n                enc.add(enc$1.end());\n                const enc$2 = new Asn1SequenceEncoder();\n                enc$2.one();\n                enc$2.octStr(Buffer.from(jwk.d, 'base64'));\n                const enc$3 = new Asn1SequenceEncoder();\n                enc$3.bitStr(pub);\n                const f2 = enc$3.end(Buffer.from([0xa1]));\n                enc$2.add(f2);\n                const f = enc$2.end();\n                const enc$4 = new Asn1SequenceEncoder();\n                enc$4.add(f);\n                const f3 = enc$4.end(Buffer.from([0x04]));\n                enc.add(f3);\n                const der = enc.end();\n                const keyObject = createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });\n                setCurve(keyObject, jwk.crv);\n                return keyObject;\n            }\n            const enc$1 = new Asn1SequenceEncoder();\n            enc$1.oidFor('ecPublicKey');\n            enc$1.oidFor(jwk.crv);\n            enc.add(enc$1.end());\n            enc.bitStr(pub);\n            const der = enc.end();\n            const keyObject = createPublicKey({ key: der, format: 'der', type: 'spki' });\n            setCurve(keyObject, jwk.crv);\n            return keyObject;\n        }\n        case 'OKP': {\n            const enc = new Asn1SequenceEncoder();\n            const isPrivate = jwk.d !== undefined;\n            if (isPrivate) {\n                enc.zero();\n                const enc$1 = new Asn1SequenceEncoder();\n                enc$1.oidFor(jwk.crv);\n                enc.add(enc$1.end());\n                const enc$2 = new Asn1SequenceEncoder();\n                enc$2.octStr(Buffer.from(jwk.d, 'base64'));\n                const f = enc$2.end(Buffer.from([0x04]));\n                enc.add(f);\n                const der = enc.end();\n                return createPrivateKey({ key: der, format: 'der', type: 'pkcs8' });\n            }\n            const enc$1 = new Asn1SequenceEncoder();\n            enc$1.oidFor(jwk.crv);\n            enc.add(enc$1.end());\n            enc.bitStr(Buffer.from(jwk.x, 'base64'));\n            const der = enc.end();\n            return createPublicKey({ key: der, format: 'der', type: 'spki' });\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n};\nexport default parse;\n"
        }
    ]
}