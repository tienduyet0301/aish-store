{
    "sourceFile": "node_modules/jose/dist/node/cjs/jws/flattened/sign.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892364029,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlattenedSign = void 0;\nconst base64url_js_1 = require(\"../../runtime/base64url.js\");\nconst sign_js_1 = require(\"../../runtime/sign.js\");\nconst is_disjoint_js_1 = require(\"../../lib/is_disjoint.js\");\nconst errors_js_1 = require(\"../../util/errors.js\");\nconst buffer_utils_js_1 = require(\"../../lib/buffer_utils.js\");\nconst check_key_type_js_1 = require(\"../../lib/check_key_type.js\");\nconst validate_crit_js_1 = require(\"../../lib/validate_crit.js\");\nclass FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new errors_js_1.JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {\n            throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new errors_js_1.JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new errors_js_1.JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        (0, check_key_type_js_1.default)(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = buffer_utils_js_1.encoder.encode('');\n        }\n        const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), payload);\n        const signature = await (0, sign_js_1.default)(alg, key, data);\n        const jws = {\n            signature: (0, base64url_js_1.encode)(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = buffer_utils_js_1.decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\nexports.FlattenedSign = FlattenedSign;\n"
        }
    ]
}