{
    "sourceFile": "node_modules/esquery/dist/esquery.esm.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892285468,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar estraverse = createCommonjsModule(function (module, exports) {\n  /*\n    Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  \n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are met:\n  \n      * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n      * Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n  \n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  */\n  /*jslint vars:false, bitwise:true*/\n  /*jshint indent:4*/\n  /*global exports:true*/\n  (function clone(exports) {\n\n    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;\n    function deepCopy(obj) {\n      var ret = {},\n        key,\n        val;\n      for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          val = obj[key];\n          if (typeof val === 'object' && val !== null) {\n            ret[key] = deepCopy(val);\n          } else {\n            ret[key] = val;\n          }\n        }\n      }\n      return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n      var diff, len, i, current;\n      len = array.length;\n      i = 0;\n      while (len) {\n        diff = len >>> 1;\n        current = i + diff;\n        if (func(array[current])) {\n          len = diff;\n        } else {\n          i = current + 1;\n          len -= diff + 1;\n        }\n      }\n      return i;\n    }\n    Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      AssignmentPattern: 'AssignmentPattern',\n      ArrayExpression: 'ArrayExpression',\n      ArrayPattern: 'ArrayPattern',\n      ArrowFunctionExpression: 'ArrowFunctionExpression',\n      AwaitExpression: 'AwaitExpression',\n      // CAUTION: It's deferred to ES7.\n      BlockStatement: 'BlockStatement',\n      BinaryExpression: 'BinaryExpression',\n      BreakStatement: 'BreakStatement',\n      CallExpression: 'CallExpression',\n      CatchClause: 'CatchClause',\n      ChainExpression: 'ChainExpression',\n      ClassBody: 'ClassBody',\n      ClassDeclaration: 'ClassDeclaration',\n      ClassExpression: 'ClassExpression',\n      ComprehensionBlock: 'ComprehensionBlock',\n      // CAUTION: It's deferred to ES7.\n      ComprehensionExpression: 'ComprehensionExpression',\n      // CAUTION: It's deferred to ES7.\n      ConditionalExpression: 'ConditionalExpression',\n      ContinueStatement: 'ContinueStatement',\n      DebuggerStatement: 'DebuggerStatement',\n      DirectiveStatement: 'DirectiveStatement',\n      DoWhileStatement: 'DoWhileStatement',\n      EmptyStatement: 'EmptyStatement',\n      ExportAllDeclaration: 'ExportAllDeclaration',\n      ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n      ExportNamedDeclaration: 'ExportNamedDeclaration',\n      ExportSpecifier: 'ExportSpecifier',\n      ExpressionStatement: 'ExpressionStatement',\n      ForStatement: 'ForStatement',\n      ForInStatement: 'ForInStatement',\n      ForOfStatement: 'ForOfStatement',\n      FunctionDeclaration: 'FunctionDeclaration',\n      FunctionExpression: 'FunctionExpression',\n      GeneratorExpression: 'GeneratorExpression',\n      // CAUTION: It's deferred to ES7.\n      Identifier: 'Identifier',\n      IfStatement: 'IfStatement',\n      ImportExpression: 'ImportExpression',\n      ImportDeclaration: 'ImportDeclaration',\n      ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n      ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n      ImportSpecifier: 'ImportSpecifier',\n      Literal: 'Literal',\n      LabeledStatement: 'LabeledStatement',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      MetaProperty: 'MetaProperty',\n      MethodDefinition: 'MethodDefinition',\n      ModuleSpecifier: 'ModuleSpecifier',\n      NewExpression: 'NewExpression',\n      ObjectExpression: 'ObjectExpression',\n      ObjectPattern: 'ObjectPattern',\n      PrivateIdentifier: 'PrivateIdentifier',\n      Program: 'Program',\n      Property: 'Property',\n      PropertyDefinition: 'PropertyDefinition',\n      RestElement: 'RestElement',\n      ReturnStatement: 'ReturnStatement',\n      SequenceExpression: 'SequenceExpression',\n      SpreadElement: 'SpreadElement',\n      Super: 'Super',\n      SwitchStatement: 'SwitchStatement',\n      SwitchCase: 'SwitchCase',\n      TaggedTemplateExpression: 'TaggedTemplateExpression',\n      TemplateElement: 'TemplateElement',\n      TemplateLiteral: 'TemplateLiteral',\n      ThisExpression: 'ThisExpression',\n      ThrowStatement: 'ThrowStatement',\n      TryStatement: 'TryStatement',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression',\n      VariableDeclaration: 'VariableDeclaration',\n      VariableDeclarator: 'VariableDeclarator',\n      WhileStatement: 'WhileStatement',\n      WithStatement: 'WithStatement',\n      YieldExpression: 'YieldExpression'\n    };\n    VisitorKeys = {\n      AssignmentExpression: ['left', 'right'],\n      AssignmentPattern: ['left', 'right'],\n      ArrayExpression: ['elements'],\n      ArrayPattern: ['elements'],\n      ArrowFunctionExpression: ['params', 'body'],\n      AwaitExpression: ['argument'],\n      // CAUTION: It's deferred to ES7.\n      BlockStatement: ['body'],\n      BinaryExpression: ['left', 'right'],\n      BreakStatement: ['label'],\n      CallExpression: ['callee', 'arguments'],\n      CatchClause: ['param', 'body'],\n      ChainExpression: ['expression'],\n      ClassBody: ['body'],\n      ClassDeclaration: ['id', 'superClass', 'body'],\n      ClassExpression: ['id', 'superClass', 'body'],\n      ComprehensionBlock: ['left', 'right'],\n      // CAUTION: It's deferred to ES7.\n      ComprehensionExpression: ['blocks', 'filter', 'body'],\n      // CAUTION: It's deferred to ES7.\n      ConditionalExpression: ['test', 'consequent', 'alternate'],\n      ContinueStatement: ['label'],\n      DebuggerStatement: [],\n      DirectiveStatement: [],\n      DoWhileStatement: ['body', 'test'],\n      EmptyStatement: [],\n      ExportAllDeclaration: ['source'],\n      ExportDefaultDeclaration: ['declaration'],\n      ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n      ExportSpecifier: ['exported', 'local'],\n      ExpressionStatement: ['expression'],\n      ForStatement: ['init', 'test', 'update', 'body'],\n      ForInStatement: ['left', 'right', 'body'],\n      ForOfStatement: ['left', 'right', 'body'],\n      FunctionDeclaration: ['id', 'params', 'body'],\n      FunctionExpression: ['id', 'params', 'body'],\n      GeneratorExpression: ['blocks', 'filter', 'body'],\n      // CAUTION: It's deferred to ES7.\n      Identifier: [],\n      IfStatement: ['test', 'consequent', 'alternate'],\n      ImportExpression: ['source'],\n      ImportDeclaration: ['specifiers', 'source'],\n      ImportDefaultSpecifier: ['local'],\n      ImportNamespaceSpecifier: ['local'],\n      ImportSpecifier: ['imported', 'local'],\n      Literal: [],\n      LabeledStatement: ['label', 'body'],\n      LogicalExpression: ['left', 'right'],\n      MemberExpression: ['object', 'property'],\n      MetaProperty: ['meta', 'property'],\n      MethodDefinition: ['key', 'value'],\n      ModuleSpecifier: [],\n      NewExpression: ['callee', 'arguments'],\n      ObjectExpression: ['properties'],\n      ObjectPattern: ['properties'],\n      PrivateIdentifier: [],\n      Program: ['body'],\n      Property: ['key', 'value'],\n      PropertyDefinition: ['key', 'value'],\n      RestElement: ['argument'],\n      ReturnStatement: ['argument'],\n      SequenceExpression: ['expressions'],\n      SpreadElement: ['argument'],\n      Super: [],\n      SwitchStatement: ['discriminant', 'cases'],\n      SwitchCase: ['test', 'consequent'],\n      TaggedTemplateExpression: ['tag', 'quasi'],\n      TemplateElement: [],\n      TemplateLiteral: ['quasis', 'expressions'],\n      ThisExpression: [],\n      ThrowStatement: ['argument'],\n      TryStatement: ['block', 'handler', 'finalizer'],\n      UnaryExpression: ['argument'],\n      UpdateExpression: ['argument'],\n      VariableDeclaration: ['declarations'],\n      VariableDeclarator: ['id', 'init'],\n      WhileStatement: ['test', 'body'],\n      WithStatement: ['object', 'body'],\n      YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n    VisitorOption = {\n      Break: BREAK,\n      Skip: SKIP,\n      Remove: REMOVE\n    };\n    function Reference(parent, key) {\n      this.parent = parent;\n      this.key = key;\n    }\n    Reference.prototype.replace = function replace(node) {\n      this.parent[this.key] = node;\n    };\n    Reference.prototype.remove = function remove() {\n      if (Array.isArray(this.parent)) {\n        this.parent.splice(this.key, 1);\n        return true;\n      } else {\n        this.replace(null);\n        return false;\n      }\n    };\n    function Element(node, path, wrap, ref) {\n      this.node = node;\n      this.path = path;\n      this.wrap = wrap;\n      this.ref = ref;\n    }\n    function Controller() {}\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n      var i, iz, j, jz, result, element;\n      function addToPath(result, path) {\n        if (Array.isArray(path)) {\n          for (j = 0, jz = path.length; j < jz; ++j) {\n            result.push(path[j]);\n          }\n        } else {\n          result.push(path);\n        }\n      }\n\n      // root node\n      if (!this.__current.path) {\n        return null;\n      }\n\n      // first node is sentinel, second node is root element\n      result = [];\n      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n        element = this.__leavelist[i];\n        addToPath(result, element.path);\n      }\n      addToPath(result, this.__current.path);\n      return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n      var node = this.current();\n      return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n      var i, iz, result;\n\n      // first node is sentinel\n      result = [];\n      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n        result.push(this.__leavelist[i].node);\n      }\n      return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n      return this.__current.node;\n    };\n    Controller.prototype.__execute = function __execute(callback, element) {\n      var previous, result;\n      result = undefined;\n      previous = this.__current;\n      this.__current = element;\n      this.__state = null;\n      if (callback) {\n        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n      }\n      this.__current = previous;\n      return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n      this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n      this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n      this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n      this.notify(REMOVE);\n    };\n    Controller.prototype.__initialize = function (root, visitor) {\n      this.visitor = visitor;\n      this.root = root;\n      this.__worklist = [];\n      this.__leavelist = [];\n      this.__current = null;\n      this.__state = null;\n      this.__fallback = null;\n      if (visitor.fallback === 'iteration') {\n        this.__fallback = Object.keys;\n      } else if (typeof visitor.fallback === 'function') {\n        this.__fallback = visitor.fallback;\n      }\n      this.__keys = VisitorKeys;\n      if (visitor.keys) {\n        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n      }\n    };\n    function isNode(node) {\n      if (node == null) {\n        return false;\n      }\n      return typeof node === 'object' && typeof node.type === 'string';\n    }\n    function isProperty(nodeType, key) {\n      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n    function candidateExistsInLeaveList(leavelist, candidate) {\n      for (var i = leavelist.length - 1; i >= 0; --i) {\n        if (leavelist[i].node === candidate) {\n          return true;\n        }\n      }\n      return false;\n    }\n    Controller.prototype.traverse = function traverse(root, visitor) {\n      var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;\n      this.__initialize(root, visitor);\n      sentinel = {};\n\n      // reference\n      worklist = this.__worklist;\n      leavelist = this.__leavelist;\n\n      // initialize\n      worklist.push(new Element(root, null, null, null));\n      leavelist.push(new Element(null, null, null, null));\n      while (worklist.length) {\n        element = worklist.pop();\n        if (element === sentinel) {\n          element = leavelist.pop();\n          ret = this.__execute(visitor.leave, element);\n          if (this.__state === BREAK || ret === BREAK) {\n            return;\n          }\n          continue;\n        }\n        if (element.node) {\n          ret = this.__execute(visitor.enter, element);\n          if (this.__state === BREAK || ret === BREAK) {\n            return;\n          }\n          worklist.push(sentinel);\n          leavelist.push(element);\n          if (this.__state === SKIP || ret === SKIP) {\n            continue;\n          }\n          node = element.node;\n          nodeType = node.type || element.wrap;\n          candidates = this.__keys[nodeType];\n          if (!candidates) {\n            if (this.__fallback) {\n              candidates = this.__fallback(node);\n            } else {\n              throw new Error('Unknown node type ' + nodeType + '.');\n            }\n          }\n          current = candidates.length;\n          while ((current -= 1) >= 0) {\n            key = candidates[current];\n            candidate = node[key];\n            if (!candidate) {\n              continue;\n            }\n            if (Array.isArray(candidate)) {\n              current2 = candidate.length;\n              while ((current2 -= 1) >= 0) {\n                if (!candidate[current2]) {\n                  continue;\n                }\n                if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                  continue;\n                }\n                if (isProperty(nodeType, candidates[current])) {\n                  element = new Element(candidate[current2], [key, current2], 'Property', null);\n                } else if (isNode(candidate[current2])) {\n                  element = new Element(candidate[current2], [key, current2], null, null);\n                } else {\n                  continue;\n                }\n                worklist.push(element);\n              }\n            } else if (isNode(candidate)) {\n              if (candidateExistsInLeaveList(leavelist, candidate)) {\n                continue;\n              }\n              worklist.push(new Element(candidate, key, null, null));\n            }\n          }\n        }\n      }\n    };\n    Controller.prototype.replace = function replace(root, visitor) {\n      var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;\n      function removeElem(element) {\n        var i, key, nextElem, parent;\n        if (element.ref.remove()) {\n          // When the reference is an element of an array.\n          key = element.ref.key;\n          parent = element.ref.parent;\n\n          // If removed from array, then decrease following items' keys.\n          i = worklist.length;\n          while (i--) {\n            nextElem = worklist[i];\n            if (nextElem.ref && nextElem.ref.parent === parent) {\n              if (nextElem.ref.key < key) {\n                break;\n              }\n              --nextElem.ref.key;\n            }\n          }\n        }\n      }\n      this.__initialize(root, visitor);\n      sentinel = {};\n\n      // reference\n      worklist = this.__worklist;\n      leavelist = this.__leavelist;\n\n      // initialize\n      outer = {\n        root: root\n      };\n      element = new Element(root, null, null, new Reference(outer, 'root'));\n      worklist.push(element);\n      leavelist.push(element);\n      while (worklist.length) {\n        element = worklist.pop();\n        if (element === sentinel) {\n          element = leavelist.pop();\n          target = this.__execute(visitor.leave, element);\n\n          // node may be replaced with null,\n          // so distinguish between undefined and null in this place\n          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n            // replace\n            element.ref.replace(target);\n          }\n          if (this.__state === REMOVE || target === REMOVE) {\n            removeElem(element);\n          }\n          if (this.__state === BREAK || target === BREAK) {\n            return outer.root;\n          }\n          continue;\n        }\n        target = this.__execute(visitor.enter, element);\n\n        // node may be replaced with null,\n        // so distinguish between undefined and null in this place\n        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n          // replace\n          element.ref.replace(target);\n          element.node = target;\n        }\n        if (this.__state === REMOVE || target === REMOVE) {\n          removeElem(element);\n          element.node = null;\n        }\n        if (this.__state === BREAK || target === BREAK) {\n          return outer.root;\n        }\n\n        // node may be null\n        node = element.node;\n        if (!node) {\n          continue;\n        }\n        worklist.push(sentinel);\n        leavelist.push(element);\n        if (this.__state === SKIP || target === SKIP) {\n          continue;\n        }\n        nodeType = node.type || element.wrap;\n        candidates = this.__keys[nodeType];\n        if (!candidates) {\n          if (this.__fallback) {\n            candidates = this.__fallback(node);\n          } else {\n            throw new Error('Unknown node type ' + nodeType + '.');\n          }\n        }\n        current = candidates.length;\n        while ((current -= 1) >= 0) {\n          key = candidates[current];\n          candidate = node[key];\n          if (!candidate) {\n            continue;\n          }\n          if (Array.isArray(candidate)) {\n            current2 = candidate.length;\n            while ((current2 -= 1) >= 0) {\n              if (!candidate[current2]) {\n                continue;\n              }\n              if (isProperty(nodeType, candidates[current])) {\n                element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n              } else if (isNode(candidate[current2])) {\n                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n              } else {\n                continue;\n              }\n              worklist.push(element);\n            }\n          } else if (isNode(candidate)) {\n            worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n          }\n        }\n      }\n      return outer.root;\n    };\n    function traverse(root, visitor) {\n      var controller = new Controller();\n      return controller.traverse(root, visitor);\n    }\n    function replace(root, visitor) {\n      var controller = new Controller();\n      return controller.replace(root, visitor);\n    }\n    function extendCommentRange(comment, tokens) {\n      var target;\n      target = upperBound(tokens, function search(token) {\n        return token.range[0] > comment.range[0];\n      });\n      comment.extendedRange = [comment.range[0], comment.range[1]];\n      if (target !== tokens.length) {\n        comment.extendedRange[1] = tokens[target].range[0];\n      }\n      target -= 1;\n      if (target >= 0) {\n        comment.extendedRange[0] = tokens[target].range[1];\n      }\n      return comment;\n    }\n    function attachComments(tree, providedComments, tokens) {\n      // At first, we should calculate extended comment ranges.\n      var comments = [],\n        comment,\n        len,\n        i,\n        cursor;\n      if (!tree.range) {\n        throw new Error('attachComments needs range information');\n      }\n\n      // tokens array is empty, we attach comments to tree as 'leadingComments'\n      if (!tokens.length) {\n        if (providedComments.length) {\n          for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comment = deepCopy(providedComments[i]);\n            comment.extendedRange = [0, tree.range[0]];\n            comments.push(comment);\n          }\n          tree.leadingComments = comments;\n        }\n        return tree;\n      }\n      for (i = 0, len = providedComments.length; i < len; i += 1) {\n        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n      }\n\n      // This is based on John Freeman's implementation.\n      cursor = 0;\n      traverse(tree, {\n        enter: function (node) {\n          var comment;\n          while (cursor < comments.length) {\n            comment = comments[cursor];\n            if (comment.extendedRange[1] > node.range[0]) {\n              break;\n            }\n            if (comment.extendedRange[1] === node.range[0]) {\n              if (!node.leadingComments) {\n                node.leadingComments = [];\n              }\n              node.leadingComments.push(comment);\n              comments.splice(cursor, 1);\n            } else {\n              cursor += 1;\n            }\n          }\n\n          // already out of owned node\n          if (cursor === comments.length) {\n            return VisitorOption.Break;\n          }\n          if (comments[cursor].extendedRange[0] > node.range[1]) {\n            return VisitorOption.Skip;\n          }\n        }\n      });\n      cursor = 0;\n      traverse(tree, {\n        leave: function (node) {\n          var comment;\n          while (cursor < comments.length) {\n            comment = comments[cursor];\n            if (node.range[1] < comment.extendedRange[0]) {\n              break;\n            }\n            if (node.range[1] === comment.extendedRange[0]) {\n              if (!node.trailingComments) {\n                node.trailingComments = [];\n              }\n              node.trailingComments.push(comment);\n              comments.splice(cursor, 1);\n            } else {\n              cursor += 1;\n            }\n          }\n\n          // already out of owned node\n          if (cursor === comments.length) {\n            return VisitorOption.Break;\n          }\n          if (comments[cursor].extendedRange[0] > node.range[1]) {\n            return VisitorOption.Skip;\n          }\n        }\n      });\n      return tree;\n    }\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () {\n      return clone({});\n    };\n    return exports;\n  })(exports);\n  /* vim: set sw=4 ts=4 et tw=80 : */\n});\n\nvar parser = createCommonjsModule(function (module) {\n  /*\n   * Generated by PEG.js 0.10.0.\n   *\n   * http://pegjs.org/\n   */\n  (function (root, factory) {\n    if ( module.exports) {\n      module.exports = factory();\n    }\n  })(commonjsGlobal, function () {\n\n    function peg$subclass(child, parent) {\n      function ctor() {\n        this.constructor = child;\n      }\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      this.message = message;\n      this.expected = expected;\n      this.found = found;\n      this.location = location;\n      this.name = \"SyntaxError\";\n      if (typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(this, peg$SyntaxError);\n      }\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    peg$SyntaxError.buildMessage = function (expected, found) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function literal(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n        \"class\": function _class(expectation) {\n          var escapedParts = \"\",\n            i;\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n          }\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n        any: function any(expectation) {\n          return \"any character\";\n        },\n        end: function end(expectation) {\n          return \"end of input\";\n        },\n        other: function other(expectation) {\n          return expectation.description;\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s) {\n        return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n          return '\\\\x0' + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n          return '\\\\x' + hex(ch);\n        });\n      }\n      function classEscape(s) {\n        return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n          return '\\\\x0' + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n          return '\\\\x' + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected) {\n        var descriptions = new Array(expected.length),\n          i,\n          j;\n        for (i = 0; i < expected.length; i++) {\n          descriptions[i] = describeExpectation(expected[i]);\n        }\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found) {\n        return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {},\n        peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n        peg$startRuleFunction = peg$parsestart,\n        peg$c0 = function peg$c0(ss) {\n          return ss.length === 1 ? ss[0] : {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n        peg$c1 = function peg$c1() {\n          return void 0;\n        },\n        peg$c2 = \" \",\n        peg$c3 = peg$literalExpectation(\" \", false),\n        peg$c4 = /^[^ [\\],():#!=><~+.]/,\n        peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n        peg$c6 = function peg$c6(i) {\n          return i.join('');\n        },\n        peg$c7 = \">\",\n        peg$c8 = peg$literalExpectation(\">\", false),\n        peg$c9 = function peg$c9() {\n          return 'child';\n        },\n        peg$c10 = \"~\",\n        peg$c11 = peg$literalExpectation(\"~\", false),\n        peg$c12 = function peg$c12() {\n          return 'sibling';\n        },\n        peg$c13 = \"+\",\n        peg$c14 = peg$literalExpectation(\"+\", false),\n        peg$c15 = function peg$c15() {\n          return 'adjacent';\n        },\n        peg$c16 = function peg$c16() {\n          return 'descendant';\n        },\n        peg$c17 = \",\",\n        peg$c18 = peg$literalExpectation(\",\", false),\n        peg$c19 = function peg$c19(s, ss) {\n          return [s].concat(ss.map(function (s) {\n            return s[3];\n          }));\n        },\n        peg$c20 = function peg$c20(op, s) {\n          if (!op) return s;\n          return {\n            type: op,\n            left: {\n              type: 'exactNode'\n            },\n            right: s\n          };\n        },\n        peg$c21 = function peg$c21(a, ops) {\n          return ops.reduce(function (memo, rhs) {\n            return {\n              type: rhs[0],\n              left: memo,\n              right: rhs[1]\n            };\n          }, a);\n        },\n        peg$c22 = \"!\",\n        peg$c23 = peg$literalExpectation(\"!\", false),\n        peg$c24 = function peg$c24(subject, as) {\n          var b = as.length === 1 ? as[0] : {\n            type: 'compound',\n            selectors: as\n          };\n          if (subject) b.subject = true;\n          return b;\n        },\n        peg$c25 = \"*\",\n        peg$c26 = peg$literalExpectation(\"*\", false),\n        peg$c27 = function peg$c27(a) {\n          return {\n            type: 'wildcard',\n            value: a\n          };\n        },\n        peg$c28 = \"#\",\n        peg$c29 = peg$literalExpectation(\"#\", false),\n        peg$c30 = function peg$c30(i) {\n          return {\n            type: 'identifier',\n            value: i\n          };\n        },\n        peg$c31 = \"[\",\n        peg$c32 = peg$literalExpectation(\"[\", false),\n        peg$c33 = \"]\",\n        peg$c34 = peg$literalExpectation(\"]\", false),\n        peg$c35 = function peg$c35(v) {\n          return v;\n        },\n        peg$c36 = /^[><!]/,\n        peg$c37 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n        peg$c38 = \"=\",\n        peg$c39 = peg$literalExpectation(\"=\", false),\n        peg$c40 = function peg$c40(a) {\n          return (a || '') + '=';\n        },\n        peg$c41 = /^[><]/,\n        peg$c42 = peg$classExpectation([\">\", \"<\"], false, false),\n        peg$c43 = \".\",\n        peg$c44 = peg$literalExpectation(\".\", false),\n        peg$c45 = function peg$c45(a, as) {\n          return [].concat.apply([a], as).join('');\n        },\n        peg$c46 = function peg$c46(name, op, value) {\n          return {\n            type: 'attribute',\n            name: name,\n            operator: op,\n            value: value\n          };\n        },\n        peg$c47 = function peg$c47(name) {\n          return {\n            type: 'attribute',\n            name: name\n          };\n        },\n        peg$c48 = \"\\\"\",\n        peg$c49 = peg$literalExpectation(\"\\\"\", false),\n        peg$c50 = /^[^\\\\\"]/,\n        peg$c51 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n        peg$c52 = \"\\\\\",\n        peg$c53 = peg$literalExpectation(\"\\\\\", false),\n        peg$c54 = peg$anyExpectation(),\n        peg$c55 = function peg$c55(a, b) {\n          return a + b;\n        },\n        peg$c56 = function peg$c56(d) {\n          return {\n            type: 'literal',\n            value: strUnescape(d.join(''))\n          };\n        },\n        peg$c57 = \"'\",\n        peg$c58 = peg$literalExpectation(\"'\", false),\n        peg$c59 = /^[^\\\\']/,\n        peg$c60 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n        peg$c61 = /^[0-9]/,\n        peg$c62 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c63 = function peg$c63(a, b) {\n          // Can use `a.flat().join('')` once supported\n          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n          return {\n            type: 'literal',\n            value: parseFloat(leadingDecimals + b.join(''))\n          };\n        },\n        peg$c64 = function peg$c64(i) {\n          return {\n            type: 'literal',\n            value: i\n          };\n        },\n        peg$c65 = \"type(\",\n        peg$c66 = peg$literalExpectation(\"type(\", false),\n        peg$c67 = /^[^ )]/,\n        peg$c68 = peg$classExpectation([\" \", \")\"], true, false),\n        peg$c69 = \")\",\n        peg$c70 = peg$literalExpectation(\")\", false),\n        peg$c71 = function peg$c71(t) {\n          return {\n            type: 'type',\n            value: t.join('')\n          };\n        },\n        peg$c72 = /^[imsu]/,\n        peg$c73 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n        peg$c74 = \"/\",\n        peg$c75 = peg$literalExpectation(\"/\", false),\n        peg$c76 = /^[^\\/]/,\n        peg$c77 = peg$classExpectation([\"/\"], true, false),\n        peg$c78 = function peg$c78(d, flgs) {\n          return {\n            type: 'regexp',\n            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')\n          };\n        },\n        peg$c79 = function peg$c79(i, is) {\n          return {\n            type: 'field',\n            name: is.reduce(function (memo, p) {\n              return memo + p[0] + p[1];\n            }, i)\n          };\n        },\n        peg$c80 = \":not(\",\n        peg$c81 = peg$literalExpectation(\":not(\", false),\n        peg$c82 = function peg$c82(ss) {\n          return {\n            type: 'not',\n            selectors: ss\n          };\n        },\n        peg$c83 = \":matches(\",\n        peg$c84 = peg$literalExpectation(\":matches(\", false),\n        peg$c85 = function peg$c85(ss) {\n          return {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n        peg$c86 = \":has(\",\n        peg$c87 = peg$literalExpectation(\":has(\", false),\n        peg$c88 = function peg$c88(ss) {\n          return {\n            type: 'has',\n            selectors: ss\n          };\n        },\n        peg$c89 = \":first-child\",\n        peg$c90 = peg$literalExpectation(\":first-child\", false),\n        peg$c91 = function peg$c91() {\n          return nth(1);\n        },\n        peg$c92 = \":last-child\",\n        peg$c93 = peg$literalExpectation(\":last-child\", false),\n        peg$c94 = function peg$c94() {\n          return nthLast(1);\n        },\n        peg$c95 = \":nth-child(\",\n        peg$c96 = peg$literalExpectation(\":nth-child(\", false),\n        peg$c97 = function peg$c97(n) {\n          return nth(parseInt(n.join(''), 10));\n        },\n        peg$c98 = \":nth-last-child(\",\n        peg$c99 = peg$literalExpectation(\":nth-last-child(\", false),\n        peg$c100 = function peg$c100(n) {\n          return nthLast(parseInt(n.join(''), 10));\n        },\n        peg$c101 = \":\",\n        peg$c102 = peg$literalExpectation(\":\", false),\n        peg$c103 = function peg$c103(c) {\n          return {\n            type: 'class',\n            name: c\n          };\n        },\n        peg$currPos = 0,\n        peg$posDetailsCache = [{\n          line: 1,\n          column: 1\n        }],\n        peg$maxFailPos = 0,\n        peg$maxFailExpected = [],\n        peg$resultsCache = {},\n        peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function peg$literalExpectation(text, ignoreCase) {\n        return {\n          type: \"literal\",\n          text: text,\n          ignoreCase: ignoreCase\n        };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n          type: \"class\",\n          parts: parts,\n          inverted: inverted,\n          ignoreCase: ignoreCase\n        };\n      }\n      function peg$anyExpectation() {\n        return {\n          type: \"any\"\n        };\n      }\n      function peg$endExpectation() {\n        return {\n          type: \"end\"\n        };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos],\n          p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      function peg$computeLocation(startPos, endPos) {\n        var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails = peg$computePosDetails(endPos);\n        return {\n          start: {\n            offset: startPos,\n            line: startPosDetails.line,\n            column: startPosDetails.column\n          },\n          end: {\n            offset: endPos,\n            line: endPosDetails.line,\n            column: endPosDetails.column\n          }\n        };\n      }\n      function peg$fail(expected) {\n        if (peg$currPos < peg$maxFailPos) {\n          return;\n        }\n        if (peg$currPos > peg$maxFailPos) {\n          peg$maxFailPos = peg$currPos;\n          peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected);\n      }\n      function peg$buildStructuredError(expected, found, location) {\n        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n      }\n      function peg$parsestart() {\n        var s0, s1, s2, s3;\n        var key = peg$currPos * 32 + 0,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseselectors();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = peg$c0(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c1();\n          }\n          s0 = s1;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parse_() {\n        var s0, s1;\n        var key = peg$currPos * 32 + 1,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = [];\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c3);\n          }\n        }\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c2;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c3);\n            }\n          }\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseidentifierName() {\n        var s0, s1, s2;\n        var key = peg$currPos * 32 + 2,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$c4.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          {\n            peg$fail(peg$c5);\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$c4.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c5);\n              }\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s1 = peg$c6(s1);\n        }\n        s0 = s1;\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsebinaryOp() {\n        var s0, s1, s2, s3;\n        var key = peg$currPos * 32 + 3,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 62) {\n            s2 = peg$c7;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            {\n              peg$fail(peg$c8);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parse_();\n            if (s3 !== peg$FAILED) {\n              s1 = peg$c9();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 126) {\n              s2 = peg$c10;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c11);\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c12();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 43) {\n                s2 = peg$c13;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c14);\n                }\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c15();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 32) {\n                s1 = peg$c2;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                {\n                  peg$fail(peg$c3);\n                }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                  s1 = peg$c16();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsehasSelectors() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        var key = peg$currPos * 32 + 4,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parsehasSelector();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              {\n                peg$fail(peg$c18);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehasSelector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsehasSelector();\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c19(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseselectors() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        var key = peg$currPos * 32 + 5,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parseselector();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              {\n                peg$fail(peg$c18);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseselector();\n                if (s7 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseselector();\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c19(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsehasSelector() {\n        var s0, s1, s2;\n        var key = peg$currPos * 32 + 6,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parsebinaryOp();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseselector();\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c20(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseselector() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 7,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parsesequence();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          s4 = peg$parsebinaryOp();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesequence();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            s4 = peg$parsebinaryOp();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesequence();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c21(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsesequence() {\n        var s0, s1, s2, s3;\n        var key = peg$currPos * 32 + 8,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s1 = peg$c22;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c23);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseatom();\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parseatom();\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c24(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseatom() {\n        var s0;\n        var key = peg$currPos * 32 + 9,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$parsewildcard();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseidentifier();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseattr();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsefield();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsenegation();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsematches();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsehas();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsefirstChild();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parselastChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parsenthChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthLastChild();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseclass();\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsewildcard() {\n        var s0, s1;\n        var key = peg$currPos * 32 + 10,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c25;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c26);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s1 = peg$c27(s1);\n        }\n        s0 = s1;\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseidentifier() {\n        var s0, s1, s2;\n        var key = peg$currPos * 32 + 11,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s1 = peg$c28;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c29);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseidentifierName();\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c30(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseattr() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 12,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s1 = peg$c31;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c32);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrValue();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 93) {\n                  s5 = peg$c33;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c34);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c35(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseattrOps() {\n        var s0, s1, s2;\n        var key = peg$currPos * 32 + 13,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (peg$c36.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c37);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s2 = peg$c38;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            {\n              peg$fail(peg$c39);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c40(s1);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          if (peg$c41.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            {\n              peg$fail(peg$c42);\n            }\n          }\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseattrEqOps() {\n        var s0, s1, s2;\n        var key = peg$currPos * 32 + 14,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s1 = peg$c22;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c23);\n          }\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s2 = peg$c38;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            {\n              peg$fail(peg$c39);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c40(s1);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseattrName() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 15,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parseidentifierName();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c43;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            {\n              peg$fail(peg$c44);\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidentifierName();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c43;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c44);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseidentifierName();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c45(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseattrValue() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 16,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parseattrName();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseattrEqOps();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsetype();\n                if (s5 === peg$FAILED) {\n                  s5 = peg$parseregex();\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c46(s1, s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrOps();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsestring();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parsenumber();\n                    if (s5 === peg$FAILED) {\n                      s5 = peg$parsepath();\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c46(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseattrName();\n            if (s1 !== peg$FAILED) {\n              s1 = peg$c47(s1);\n            }\n            s0 = s1;\n          }\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsestring() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 17,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s1 = peg$c48;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c49);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c51);\n            }\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s4 = peg$c52;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c53);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s5 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c54);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = peg$c55(s4, s5);\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c51);\n              }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c52;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c53);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c54);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c55(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 34) {\n              s3 = peg$c48;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c49);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s1 = peg$c56(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s1 = peg$c57;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c58);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c59.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c60);\n              }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c52;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c53);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c54);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c55(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              if (peg$c59.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c60);\n                }\n              }\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c52;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c54);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c55(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 39) {\n                s3 = peg$c57;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c58);\n                }\n              }\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c56(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsenumber() {\n        var s0, s1, s2, s3;\n        var key = peg$currPos * 32 + 18,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = [];\n        if (peg$c61.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          {\n            peg$fail(peg$c62);\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c62);\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c43;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c44);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c62);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c62);\n                }\n              }\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c63(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsepath() {\n        var s0, s1;\n        var key = peg$currPos * 32 + 19,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        s1 = peg$parseidentifierName();\n        if (s1 !== peg$FAILED) {\n          s1 = peg$c64(s1);\n        }\n        s0 = s1;\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsetype() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 20,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5) === peg$c65) {\n          s1 = peg$c65;\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c66);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            if (peg$c67.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c68);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                if (peg$c67.test(input.charAt(peg$currPos))) {\n                  s4 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c68);\n                  }\n                }\n              }\n            } else {\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c69;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c70);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c71(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseflags() {\n        var s0, s1;\n        var key = peg$currPos * 32 + 21,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = [];\n        if (peg$c72.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c73);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            if (peg$c72.test(input.charAt(peg$currPos))) {\n              s1 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c73);\n              }\n            }\n          }\n        } else {\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseregex() {\n        var s0, s1, s2, s3, s4;\n        var key = peg$currPos * 32 + 22,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s1 = peg$c74;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c75);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          if (peg$c76.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c77);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              if (peg$c76.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c77);\n                }\n              }\n            }\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c74;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c75);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseflags();\n              if (s4 === peg$FAILED) {\n                s4 = null;\n              }\n              if (s4 !== peg$FAILED) {\n                s1 = peg$c78(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsefield() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var key = peg$currPos * 32 + 23,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c43;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c44);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseidentifierName();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c43;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              {\n                peg$fail(peg$c44);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseidentifierName();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s5 = peg$c43;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c44);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseidentifierName();\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s1 = peg$c79(s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsenegation() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 24,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5) === peg$c80) {\n          s1 = peg$c80;\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c81);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseselectors();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c69;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c70);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c82(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsematches() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 25,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 9) === peg$c83) {\n          s1 = peg$c83;\n          peg$currPos += 9;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c84);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseselectors();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c69;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c70);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c85(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsehas() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 26,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 5) === peg$c86) {\n          s1 = peg$c86;\n          peg$currPos += 5;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c87);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsehasSelectors();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c69;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c70);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c88(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsefirstChild() {\n        var s0, s1;\n        var key = peg$currPos * 32 + 27,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 12) === peg$c89) {\n          s1 = peg$c89;\n          peg$currPos += 12;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c90);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s1 = peg$c91();\n        }\n        s0 = s1;\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parselastChild() {\n        var s0, s1;\n        var key = peg$currPos * 32 + 28,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 11) === peg$c92) {\n          s1 = peg$c92;\n          peg$currPos += 11;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c93);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s1 = peg$c94();\n        }\n        s0 = s1;\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsenthChild() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 29,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 11) === peg$c95) {\n          s1 = peg$c95;\n          peg$currPos += 11;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c96);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c62);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                if (peg$c61.test(input.charAt(peg$currPos))) {\n                  s4 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c62);\n                  }\n                }\n              }\n            } else {\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c69;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c70);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c97(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parsenthLastChild() {\n        var s0, s1, s2, s3, s4, s5;\n        var key = peg$currPos * 32 + 30,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 16) === peg$c98) {\n          s1 = peg$c98;\n          peg$currPos += 16;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c99);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c62);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                if (peg$c61.test(input.charAt(peg$currPos))) {\n                  s4 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c62);\n                  }\n                }\n              }\n            } else {\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s5 = peg$c69;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c70);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s1 = peg$c100(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function peg$parseclass() {\n        var s0, s1, s2;\n        var key = peg$currPos * 32 + 31,\n          cached = peg$resultsCache[key];\n        if (cached) {\n          peg$currPos = cached.nextPos;\n          return cached.result;\n        }\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s1 = peg$c101;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          {\n            peg$fail(peg$c102);\n          }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseidentifierName();\n          if (s2 !== peg$FAILED) {\n            s1 = peg$c103(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$resultsCache[key] = {\n          nextPos: peg$currPos,\n          result: s0\n        };\n        return s0;\n      }\n      function nth(n) {\n        return {\n          type: 'nth-child',\n          index: {\n            type: 'literal',\n            value: n\n          }\n        };\n      }\n      function nthLast(n) {\n        return {\n          type: 'nth-last-child',\n          index: {\n            type: 'literal',\n            value: n\n          }\n        };\n      }\n      function strUnescape(s) {\n        return s.replace(/\\\\(.)/g, function (match, ch) {\n          switch (ch) {\n            case 'b':\n              return '\\b';\n            case 'f':\n              return '\\f';\n            case 'n':\n              return '\\n';\n            case 'r':\n              return '\\r';\n            case 't':\n              return '\\t';\n            case 'v':\n              return '\\v';\n            default:\n              return ch;\n          }\n        });\n      }\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$fail(peg$endExpectation());\n        }\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n      }\n    }\n    return {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  });\n});\n\n/**\n* @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n*/\n\nvar LEFT_SIDE = 'LEFT_SIDE';\nvar RIGHT_SIDE = 'RIGHT_SIDE';\n\n/**\n * @external AST\n * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n */\n\n/**\n * One of the rules of `grammar.pegjs`\n * @typedef {PlainObject} SelectorAST\n * @see grammar.pegjs\n*/\n\n/**\n * The `sequence` production of `grammar.pegjs`\n * @typedef {PlainObject} SelectorSequenceAST\n*/\n\n/**\n * Get the value of a property which may be multiple levels down\n * in the object.\n * @param {?PlainObject} obj\n * @param {string[]} keys\n * @returns {undefined|boolean|string|number|external:AST}\n */\nfunction getPath(obj, keys) {\n  for (var i = 0; i < keys.length; ++i) {\n    if (obj == null) {\n      return obj;\n    }\n    obj = obj[keys[i]];\n  }\n  return obj;\n}\n\n/**\n * Determine whether `node` can be reached by following `path`,\n * starting at `ancestor`.\n * @param {?external:AST} node\n * @param {?external:AST} ancestor\n * @param {string[]} path\n * @param {Integer} fromPathIndex\n * @returns {boolean}\n */\nfunction inPath(node, ancestor, path, fromPathIndex) {\n  var current = ancestor;\n  for (var i = fromPathIndex; i < path.length; ++i) {\n    if (current == null) {\n      return false;\n    }\n    var field = current[path[i]];\n    if (Array.isArray(field)) {\n      for (var k = 0; k < field.length; ++k) {\n        if (inPath(node, field[k], path, i + 1)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    current = field;\n  }\n  return node === current;\n}\n\n/**\n * A generated matcher function for a selector.\n * @callback SelectorMatcher\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @returns {void}\n*/\n\n/**\n * A WeakMap for holding cached matcher functions for selectors.\n * @type {WeakMap<SelectorAST, SelectorMatcher>}\n*/\nvar MATCHER_CACHE = typeof WeakMap === 'function' ? new WeakMap() : null;\n\n/**\n * Look up a matcher function for `selector` in the cache.\n * If it does not exist, generate it with `generateMatcher` and add it to the cache.\n * In engines without WeakMap, the caching is skipped and matchers are generated with every call.\n * @param {?SelectorAST} selector\n * @returns {SelectorMatcher}\n */\nfunction getMatcher(selector) {\n  if (selector == null) {\n    return function () {\n      return true;\n    };\n  }\n  if (MATCHER_CACHE != null) {\n    var matcher = MATCHER_CACHE.get(selector);\n    if (matcher != null) {\n      return matcher;\n    }\n    matcher = generateMatcher(selector);\n    MATCHER_CACHE.set(selector, matcher);\n    return matcher;\n  }\n  return generateMatcher(selector);\n}\n\n/**\n * Create a matcher function for `selector`,\n * @param {?SelectorAST} selector\n * @returns {SelectorMatcher}\n */\nfunction generateMatcher(selector) {\n  switch (selector.type) {\n    case 'wildcard':\n      return function () {\n        return true;\n      };\n    case 'identifier':\n      {\n        var value = selector.value.toLowerCase();\n        return function (node, ancestry, options) {\n          var nodeTypeKey = options && options.nodeTypeKey || 'type';\n          return value === node[nodeTypeKey].toLowerCase();\n        };\n      }\n    case 'exactNode':\n      return function (node, ancestry) {\n        return ancestry.length === 0;\n      };\n    case 'field':\n      {\n        var path = selector.name.split('.');\n        return function (node, ancestry) {\n          var ancestor = ancestry[path.length - 1];\n          return inPath(node, ancestor, path, 0);\n        };\n      }\n    case 'matches':\n      {\n        var matchers = selector.selectors.map(getMatcher);\n        return function (node, ancestry, options) {\n          for (var i = 0; i < matchers.length; ++i) {\n            if (matchers[i](node, ancestry, options)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case 'compound':\n      {\n        var _matchers = selector.selectors.map(getMatcher);\n        return function (node, ancestry, options) {\n          for (var i = 0; i < _matchers.length; ++i) {\n            if (!_matchers[i](node, ancestry, options)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n    case 'not':\n      {\n        var _matchers2 = selector.selectors.map(getMatcher);\n        return function (node, ancestry, options) {\n          for (var i = 0; i < _matchers2.length; ++i) {\n            if (_matchers2[i](node, ancestry, options)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n    case 'has':\n      {\n        var _matchers3 = selector.selectors.map(getMatcher);\n        return function (node, ancestry, options) {\n          var result = false;\n          var a = [];\n          estraverse.traverse(node, {\n            enter: function enter(node, parent) {\n              if (parent != null) {\n                a.unshift(parent);\n              }\n              for (var i = 0; i < _matchers3.length; ++i) {\n                if (_matchers3[i](node, a, options)) {\n                  result = true;\n                  this[\"break\"]();\n                  return;\n                }\n              }\n            },\n            leave: function leave() {\n              a.shift();\n            },\n            keys: options && options.visitorKeys,\n            fallback: options && options.fallback || 'iteration'\n          });\n          return result;\n        };\n      }\n    case 'child':\n      {\n        var left = getMatcher(selector.left);\n        var right = getMatcher(selector.right);\n        return function (node, ancestry, options) {\n          if (ancestry.length > 0 && right(node, ancestry, options)) {\n            return left(ancestry[0], ancestry.slice(1), options);\n          }\n          return false;\n        };\n      }\n    case 'descendant':\n      {\n        var _left = getMatcher(selector.left);\n        var _right = getMatcher(selector.right);\n        return function (node, ancestry, options) {\n          if (_right(node, ancestry, options)) {\n            for (var i = 0, l = ancestry.length; i < l; ++i) {\n              if (_left(ancestry[i], ancestry.slice(i + 1), options)) {\n                return true;\n              }\n            }\n          }\n          return false;\n        };\n      }\n    case 'attribute':\n      {\n        var _path = selector.name.split('.');\n        switch (selector.operator) {\n          case void 0:\n            return function (node) {\n              return getPath(node, _path) != null;\n            };\n          case '=':\n            switch (selector.value.type) {\n              case 'regexp':\n                return function (node) {\n                  var p = getPath(node, _path);\n                  return typeof p === 'string' && selector.value.value.test(p);\n                };\n              case 'literal':\n                {\n                  var literal = \"\".concat(selector.value.value);\n                  return function (node) {\n                    return literal === \"\".concat(getPath(node, _path));\n                  };\n                }\n              case 'type':\n                return function (node) {\n                  return selector.value.value === _typeof(getPath(node, _path));\n                };\n            }\n            throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n          case '!=':\n            switch (selector.value.type) {\n              case 'regexp':\n                return function (node) {\n                  return !selector.value.value.test(getPath(node, _path));\n                };\n              case 'literal':\n                {\n                  var _literal = \"\".concat(selector.value.value);\n                  return function (node) {\n                    return _literal !== \"\".concat(getPath(node, _path));\n                  };\n                }\n              case 'type':\n                return function (node) {\n                  return selector.value.value !== _typeof(getPath(node, _path));\n                };\n            }\n            throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n          case '<=':\n            return function (node) {\n              return getPath(node, _path) <= selector.value.value;\n            };\n          case '<':\n            return function (node) {\n              return getPath(node, _path) < selector.value.value;\n            };\n          case '>':\n            return function (node) {\n              return getPath(node, _path) > selector.value.value;\n            };\n          case '>=':\n            return function (node) {\n              return getPath(node, _path) >= selector.value.value;\n            };\n        }\n        throw new Error(\"Unknown operator: \".concat(selector.operator));\n      }\n    case 'sibling':\n      {\n        var _left2 = getMatcher(selector.left);\n        var _right2 = getMatcher(selector.right);\n        return function (node, ancestry, options) {\n          return _right2(node, ancestry, options) && sibling(node, _left2, ancestry, LEFT_SIDE, options) || selector.left.subject && _left2(node, ancestry, options) && sibling(node, _right2, ancestry, RIGHT_SIDE, options);\n        };\n      }\n    case 'adjacent':\n      {\n        var _left3 = getMatcher(selector.left);\n        var _right3 = getMatcher(selector.right);\n        return function (node, ancestry, options) {\n          return _right3(node, ancestry, options) && adjacent(node, _left3, ancestry, LEFT_SIDE, options) || selector.right.subject && _left3(node, ancestry, options) && adjacent(node, _right3, ancestry, RIGHT_SIDE, options);\n        };\n      }\n    case 'nth-child':\n      {\n        var nth = selector.index.value;\n        var _right4 = getMatcher(selector.right);\n        return function (node, ancestry, options) {\n          return _right4(node, ancestry, options) && nthChild(node, ancestry, nth, options);\n        };\n      }\n    case 'nth-last-child':\n      {\n        var _nth = -selector.index.value;\n        var _right5 = getMatcher(selector.right);\n        return function (node, ancestry, options) {\n          return _right5(node, ancestry, options) && nthChild(node, ancestry, _nth, options);\n        };\n      }\n    case 'class':\n      {\n        var name = selector.name.toLowerCase();\n        return function (node, ancestry, options) {\n          if (options && options.matchClass) {\n            return options.matchClass(selector.name, node, ancestry);\n          }\n          if (options && options.nodeTypeKey) return false;\n          switch (name) {\n            case 'statement':\n              if (node.type.slice(-9) === 'Statement') return true;\n            // fallthrough: interface Declaration <: Statement { }\n            case 'declaration':\n              return node.type.slice(-11) === 'Declaration';\n            case 'pattern':\n              if (node.type.slice(-7) === 'Pattern') return true;\n            // fallthrough: interface Expression <: Node, Pattern { }\n            case 'expression':\n              return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';\n            case 'function':\n              return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n          }\n          throw new Error(\"Unknown class name: \".concat(selector.name));\n        };\n      }\n  }\n  throw new Error(\"Unknown selector type: \".concat(selector.type));\n}\n\n/**\n * @callback TraverseOptionFallback\n * @param {external:AST} node The given node.\n * @returns {string[]} An array of visitor keys for the given node.\n */\n\n/**\n * @callback ClassMatcher\n * @param {string} className The name of the class to match.\n * @param {external:AST} node The node to match against.\n * @param {Array<external:AST>} ancestry The ancestry of the node.\n * @returns {boolean} True if the node matches the class, false if not.\n */\n\n/**\n * @typedef {object} ESQueryOptions\n * @property {string} [nodeTypeKey=\"type\"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.\n * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.\n */\n\n/**\n * Given a `node` and its ancestors, determine if `node` is matched\n * by `selector`.\n * @param {?external:AST} node\n * @param {?SelectorAST} selector\n * @param {external:AST[]} [ancestry=[]]\n * @param {ESQueryOptions} [options]\n * @throws {Error} Unknowns (operator, class name, selector type, or\n * selector value type)\n * @returns {boolean}\n */\nfunction matches(node, selector, ancestry, options) {\n  if (!selector) {\n    return true;\n  }\n  if (!node) {\n    return false;\n  }\n  if (!ancestry) {\n    ancestry = [];\n  }\n  return getMatcher(selector)(node, ancestry, options);\n}\n\n/**\n * Get visitor keys of a given node.\n * @param {external:AST} node The AST node to get keys.\n * @param {ESQueryOptions|undefined} options\n * @returns {string[]} Visitor keys of the node.\n */\nfunction getVisitorKeys(node, options) {\n  var nodeTypeKey = options && options.nodeTypeKey || 'type';\n  var nodeType = node[nodeTypeKey];\n  if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n    return options.visitorKeys[nodeType];\n  }\n  if (estraverse.VisitorKeys[nodeType]) {\n    return estraverse.VisitorKeys[nodeType];\n  }\n  if (options && typeof options.fallback === 'function') {\n    return options.fallback(node);\n  }\n  // 'iteration' fallback\n  return Object.keys(node).filter(function (key) {\n    return key !== nodeTypeKey;\n  });\n}\n\n/**\n * Check whether the given value is an ASTNode or not.\n * @param {any} node The value to check.\n * @param {ESQueryOptions|undefined} options The options to use.\n * @returns {boolean} `true` if the value is an ASTNode.\n */\nfunction isNode(node, options) {\n  var nodeTypeKey = options && options.nodeTypeKey || 'type';\n  return node !== null && _typeof(node) === 'object' && typeof node[nodeTypeKey] === 'string';\n}\n\n/**\n * Determines if the given node has a sibling that matches the\n * given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction sibling(node, matcher, ancestry, side, options) {\n  var _ancestry = _slicedToArray(ancestry, 1),\n    parent = _ancestry[0];\n  if (!parent) {\n    return false;\n  }\n  var keys = getVisitorKeys(parent, options);\n  for (var i = 0; i < keys.length; ++i) {\n    var listProp = parent[keys[i]];\n    if (Array.isArray(listProp)) {\n      var startIndex = listProp.indexOf(node);\n      if (startIndex < 0) {\n        continue;\n      }\n      var lowerBound = void 0,\n        upperBound = void 0;\n      if (side === LEFT_SIDE) {\n        lowerBound = 0;\n        upperBound = startIndex;\n      } else {\n        lowerBound = startIndex + 1;\n        upperBound = listProp.length;\n      }\n      for (var k = lowerBound; k < upperBound; ++k) {\n        if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Determines if the given node has an adjacent sibling that matches\n * the given selector matcher.\n * @param {external:AST} node\n * @param {SelectorMatcher} matcher\n * @param {external:AST[]} ancestry\n * @param {Side} side\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction adjacent(node, matcher, ancestry, side, options) {\n  var _ancestry2 = _slicedToArray(ancestry, 1),\n    parent = _ancestry2[0];\n  if (!parent) {\n    return false;\n  }\n  var keys = getVisitorKeys(parent, options);\n  for (var i = 0; i < keys.length; ++i) {\n    var listProp = parent[keys[i]];\n    if (Array.isArray(listProp)) {\n      var idx = listProp.indexOf(node);\n      if (idx < 0) {\n        continue;\n      }\n      if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {\n        return true;\n      }\n      if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) && matcher(listProp[idx + 1], ancestry, options)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Determines if the given node is the `nth` child.\n * If `nth` is negative then the position is counted\n * from the end of the list of children.\n * @param {external:AST} node\n * @param {external:AST[]} ancestry\n * @param {Integer} nth\n * @param {ESQueryOptions|undefined} options\n * @returns {boolean}\n */\nfunction nthChild(node, ancestry, nth, options) {\n  if (nth === 0) {\n    return false;\n  }\n  var _ancestry3 = _slicedToArray(ancestry, 1),\n    parent = _ancestry3[0];\n  if (!parent) {\n    return false;\n  }\n  var keys = getVisitorKeys(parent, options);\n  for (var i = 0; i < keys.length; ++i) {\n    var listProp = parent[keys[i]];\n    if (Array.isArray(listProp)) {\n      var idx = nth < 0 ? listProp.length + nth : nth - 1;\n      if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * For each selector node marked as a subject, find the portion of the\n * selector that the subject must match.\n * @param {SelectorAST} selector\n * @param {SelectorAST} [ancestor] Defaults to `selector`\n * @returns {SelectorAST[]}\n */\nfunction subjects(selector, ancestor) {\n  if (selector == null || _typeof(selector) != 'object') {\n    return [];\n  }\n  if (ancestor == null) {\n    ancestor = selector;\n  }\n  var results = selector.subject ? [ancestor] : [];\n  var keys = Object.keys(selector);\n  for (var i = 0; i < keys.length; ++i) {\n    var p = keys[i];\n    var sel = selector[p];\n    results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));\n  }\n  return results;\n}\n\n/**\n* @callback TraverseVisitor\n* @param {?external:AST} node\n* @param {?external:AST} parent\n* @param {external:AST[]} ancestry\n*/\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {TraverseVisitor} visitor\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction traverse(ast, selector, visitor, options) {\n  if (!selector) {\n    return;\n  }\n  var ancestry = [];\n  var matcher = getMatcher(selector);\n  var altSubjects = subjects(selector).map(getMatcher);\n  estraverse.traverse(ast, {\n    enter: function enter(node, parent) {\n      if (parent != null) {\n        ancestry.unshift(parent);\n      }\n      if (matcher(node, ancestry, options)) {\n        if (altSubjects.length) {\n          for (var i = 0, l = altSubjects.length; i < l; ++i) {\n            if (altSubjects[i](node, ancestry, options)) {\n              visitor(node, parent, ancestry);\n            }\n            for (var k = 0, m = ancestry.length; k < m; ++k) {\n              var succeedingAncestry = ancestry.slice(k + 1);\n              if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {\n                visitor(ancestry[k], parent, succeedingAncestry);\n              }\n            }\n          }\n        } else {\n          visitor(node, parent, ancestry);\n        }\n      }\n    },\n    leave: function leave() {\n      ancestry.shift();\n    },\n    keys: options && options.visitorKeys,\n    fallback: options && options.fallback || 'iteration'\n  });\n}\n\n/**\n * From a JS AST and a selector AST, collect all JS AST nodes that\n * match the selector.\n * @param {external:AST} ast\n * @param {?SelectorAST} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction match(ast, selector, options) {\n  var results = [];\n  traverse(ast, selector, function (node) {\n    results.push(node);\n  }, options);\n  return results;\n}\n\n/**\n * Parse a selector string and return its AST.\n * @param {string} selector\n * @returns {SelectorAST}\n */\nfunction parse(selector) {\n  return parser.parse(selector);\n}\n\n/**\n * Query the code AST using the selector string.\n * @param {external:AST} ast\n * @param {string} selector\n * @param {ESQueryOptions} [options]\n * @returns {external:AST[]}\n */\nfunction query(ast, selector, options) {\n  return match(ast, parse(selector), options);\n}\nquery.parse = parse;\nquery.match = match;\nquery.traverse = traverse;\nquery.matches = matches;\nquery.query = query;\n\nexport default query;\n"
        }
    ]
}