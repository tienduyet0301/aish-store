{
    "sourceFile": "node_modules/esquery/dist/esquery.lite.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892285766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('estraverse')) :\n  typeof define === 'function' && define.amd ? define(['estraverse'], factory) :\n  (global = global || self, global.esquery = factory(global.estraverse));\n}(this, (function (estraverse) { 'use strict';\n\n  estraverse = estraverse && Object.prototype.hasOwnProperty.call(estraverse, 'default') ? estraverse['default'] : estraverse;\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n      var _s,\n        _e,\n        _x,\n        _r,\n        _arr = [],\n        _n = !0,\n        _d = !1;\n      try {\n        if (_x = (_i = _i.call(arr)).next, 0 === i) {\n          if (Object(_i) !== _i) return;\n          _n = !1;\n        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n      } catch (err) {\n        _d = !0, _e = err;\n      } finally {\n        try {\n          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n  }\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var parser = createCommonjsModule(function (module) {\n    /*\n     * Generated by PEG.js 0.10.0.\n     *\n     * http://pegjs.org/\n     */\n    (function (root, factory) {\n      if ( module.exports) {\n        module.exports = factory();\n      }\n    })(commonjsGlobal, function () {\n\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n      function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n        if (typeof Error.captureStackTrace === \"function\") {\n          Error.captureStackTrace(this, peg$SyntaxError);\n        }\n      }\n      peg$subclass(peg$SyntaxError, Error);\n      peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal: function literal(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          \"class\": function _class(expectation) {\n            var escapedParts = \"\",\n              i;\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n            }\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n          any: function any(expectation) {\n            return \"any character\";\n          },\n          end: function end(expectation) {\n            return \"end of input\";\n          },\n          other: function other(expectation) {\n            return expectation.description;\n          }\n        };\n        function hex(ch) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n        function literalEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n        function classEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n        function describeExpected(expected) {\n          var descriptions = new Array(expected.length),\n            i,\n            j;\n          for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n          }\n          descriptions.sort();\n          if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n            descriptions.length = j;\n          }\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      };\n      function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n        var peg$FAILED = {},\n          peg$startRuleFunctions = {\n            start: peg$parsestart\n          },\n          peg$startRuleFunction = peg$parsestart,\n          peg$c0 = function peg$c0(ss) {\n            return ss.length === 1 ? ss[0] : {\n              type: 'matches',\n              selectors: ss\n            };\n          },\n          peg$c1 = function peg$c1() {\n            return void 0;\n          },\n          peg$c2 = \" \",\n          peg$c3 = peg$literalExpectation(\" \", false),\n          peg$c4 = /^[^ [\\],():#!=><~+.]/,\n          peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n          peg$c6 = function peg$c6(i) {\n            return i.join('');\n          },\n          peg$c7 = \">\",\n          peg$c8 = peg$literalExpectation(\">\", false),\n          peg$c9 = function peg$c9() {\n            return 'child';\n          },\n          peg$c10 = \"~\",\n          peg$c11 = peg$literalExpectation(\"~\", false),\n          peg$c12 = function peg$c12() {\n            return 'sibling';\n          },\n          peg$c13 = \"+\",\n          peg$c14 = peg$literalExpectation(\"+\", false),\n          peg$c15 = function peg$c15() {\n            return 'adjacent';\n          },\n          peg$c16 = function peg$c16() {\n            return 'descendant';\n          },\n          peg$c17 = \",\",\n          peg$c18 = peg$literalExpectation(\",\", false),\n          peg$c19 = function peg$c19(s, ss) {\n            return [s].concat(ss.map(function (s) {\n              return s[3];\n            }));\n          },\n          peg$c20 = function peg$c20(op, s) {\n            if (!op) return s;\n            return {\n              type: op,\n              left: {\n                type: 'exactNode'\n              },\n              right: s\n            };\n          },\n          peg$c21 = function peg$c21(a, ops) {\n            return ops.reduce(function (memo, rhs) {\n              return {\n                type: rhs[0],\n                left: memo,\n                right: rhs[1]\n              };\n            }, a);\n          },\n          peg$c22 = \"!\",\n          peg$c23 = peg$literalExpectation(\"!\", false),\n          peg$c24 = function peg$c24(subject, as) {\n            var b = as.length === 1 ? as[0] : {\n              type: 'compound',\n              selectors: as\n            };\n            if (subject) b.subject = true;\n            return b;\n          },\n          peg$c25 = \"*\",\n          peg$c26 = peg$literalExpectation(\"*\", false),\n          peg$c27 = function peg$c27(a) {\n            return {\n              type: 'wildcard',\n              value: a\n            };\n          },\n          peg$c28 = \"#\",\n          peg$c29 = peg$literalExpectation(\"#\", false),\n          peg$c30 = function peg$c30(i) {\n            return {\n              type: 'identifier',\n              value: i\n            };\n          },\n          peg$c31 = \"[\",\n          peg$c32 = peg$literalExpectation(\"[\", false),\n          peg$c33 = \"]\",\n          peg$c34 = peg$literalExpectation(\"]\", false),\n          peg$c35 = function peg$c35(v) {\n            return v;\n          },\n          peg$c36 = /^[><!]/,\n          peg$c37 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n          peg$c38 = \"=\",\n          peg$c39 = peg$literalExpectation(\"=\", false),\n          peg$c40 = function peg$c40(a) {\n            return (a || '') + '=';\n          },\n          peg$c41 = /^[><]/,\n          peg$c42 = peg$classExpectation([\">\", \"<\"], false, false),\n          peg$c43 = \".\",\n          peg$c44 = peg$literalExpectation(\".\", false),\n          peg$c45 = function peg$c45(a, as) {\n            return [].concat.apply([a], as).join('');\n          },\n          peg$c46 = function peg$c46(name, op, value) {\n            return {\n              type: 'attribute',\n              name: name,\n              operator: op,\n              value: value\n            };\n          },\n          peg$c47 = function peg$c47(name) {\n            return {\n              type: 'attribute',\n              name: name\n            };\n          },\n          peg$c48 = \"\\\"\",\n          peg$c49 = peg$literalExpectation(\"\\\"\", false),\n          peg$c50 = /^[^\\\\\"]/,\n          peg$c51 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n          peg$c52 = \"\\\\\",\n          peg$c53 = peg$literalExpectation(\"\\\\\", false),\n          peg$c54 = peg$anyExpectation(),\n          peg$c55 = function peg$c55(a, b) {\n            return a + b;\n          },\n          peg$c56 = function peg$c56(d) {\n            return {\n              type: 'literal',\n              value: strUnescape(d.join(''))\n            };\n          },\n          peg$c57 = \"'\",\n          peg$c58 = peg$literalExpectation(\"'\", false),\n          peg$c59 = /^[^\\\\']/,\n          peg$c60 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n          peg$c61 = /^[0-9]/,\n          peg$c62 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n          peg$c63 = function peg$c63(a, b) {\n            // Can use `a.flat().join('')` once supported\n            var leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n            return {\n              type: 'literal',\n              value: parseFloat(leadingDecimals + b.join(''))\n            };\n          },\n          peg$c64 = function peg$c64(i) {\n            return {\n              type: 'literal',\n              value: i\n            };\n          },\n          peg$c65 = \"type(\",\n          peg$c66 = peg$literalExpectation(\"type(\", false),\n          peg$c67 = /^[^ )]/,\n          peg$c68 = peg$classExpectation([\" \", \")\"], true, false),\n          peg$c69 = \")\",\n          peg$c70 = peg$literalExpectation(\")\", false),\n          peg$c71 = function peg$c71(t) {\n            return {\n              type: 'type',\n              value: t.join('')\n            };\n          },\n          peg$c72 = /^[imsu]/,\n          peg$c73 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n          peg$c74 = \"/\",\n          peg$c75 = peg$literalExpectation(\"/\", false),\n          peg$c76 = /^[^\\/]/,\n          peg$c77 = peg$classExpectation([\"/\"], true, false),\n          peg$c78 = function peg$c78(d, flgs) {\n            return {\n              type: 'regexp',\n              value: new RegExp(d.join(''), flgs ? flgs.join('') : '')\n            };\n          },\n          peg$c79 = function peg$c79(i, is) {\n            return {\n              type: 'field',\n              name: is.reduce(function (memo, p) {\n                return memo + p[0] + p[1];\n              }, i)\n            };\n          },\n          peg$c80 = \":not(\",\n          peg$c81 = peg$literalExpectation(\":not(\", false),\n          peg$c82 = function peg$c82(ss) {\n            return {\n              type: 'not',\n              selectors: ss\n            };\n          },\n          peg$c83 = \":matches(\",\n          peg$c84 = peg$literalExpectation(\":matches(\", false),\n          peg$c85 = function peg$c85(ss) {\n            return {\n              type: 'matches',\n              selectors: ss\n            };\n          },\n          peg$c86 = \":has(\",\n          peg$c87 = peg$literalExpectation(\":has(\", false),\n          peg$c88 = function peg$c88(ss) {\n            return {\n              type: 'has',\n              selectors: ss\n            };\n          },\n          peg$c89 = \":first-child\",\n          peg$c90 = peg$literalExpectation(\":first-child\", false),\n          peg$c91 = function peg$c91() {\n            return nth(1);\n          },\n          peg$c92 = \":last-child\",\n          peg$c93 = peg$literalExpectation(\":last-child\", false),\n          peg$c94 = function peg$c94() {\n            return nthLast(1);\n          },\n          peg$c95 = \":nth-child(\",\n          peg$c96 = peg$literalExpectation(\":nth-child(\", false),\n          peg$c97 = function peg$c97(n) {\n            return nth(parseInt(n.join(''), 10));\n          },\n          peg$c98 = \":nth-last-child(\",\n          peg$c99 = peg$literalExpectation(\":nth-last-child(\", false),\n          peg$c100 = function peg$c100(n) {\n            return nthLast(parseInt(n.join(''), 10));\n          },\n          peg$c101 = \":\",\n          peg$c102 = peg$literalExpectation(\":\", false),\n          peg$c103 = function peg$c103(c) {\n            return {\n              type: 'class',\n              name: c\n            };\n          },\n          peg$currPos = 0,\n          peg$posDetailsCache = [{\n            line: 1,\n            column: 1\n          }],\n          peg$maxFailPos = 0,\n          peg$maxFailExpected = [],\n          peg$resultsCache = {},\n          peg$result;\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n        function peg$literalExpectation(text, ignoreCase) {\n          return {\n            type: \"literal\",\n            text: text,\n            ignoreCase: ignoreCase\n          };\n        }\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n          return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n          };\n        }\n        function peg$anyExpectation() {\n          return {\n            type: \"any\"\n          };\n        }\n        function peg$endExpectation() {\n          return {\n            type: \"end\"\n          };\n        }\n        function peg$computePosDetails(pos) {\n          var details = peg$posDetailsCache[pos],\n            p;\n          if (details) {\n            return details;\n          } else {\n            p = pos - 1;\n            while (!peg$posDetailsCache[p]) {\n              p--;\n            }\n            details = peg$posDetailsCache[p];\n            details = {\n              line: details.line,\n              column: details.column\n            };\n            while (p < pos) {\n              if (input.charCodeAt(p) === 10) {\n                details.line++;\n                details.column = 1;\n              } else {\n                details.column++;\n              }\n              p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n          }\n        }\n        function peg$computeLocation(startPos, endPos) {\n          var startPosDetails = peg$computePosDetails(startPos),\n            endPosDetails = peg$computePosDetails(endPos);\n          return {\n            start: {\n              offset: startPos,\n              line: startPosDetails.line,\n              column: startPosDetails.column\n            },\n            end: {\n              offset: endPos,\n              line: endPosDetails.line,\n              column: endPosDetails.column\n            }\n          };\n        }\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n          peg$maxFailExpected.push(expected);\n        }\n        function peg$buildStructuredError(expected, found, location) {\n          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n        }\n        function peg$parsestart() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 32 + 0,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseselectors();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c0(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n            if (s1 !== peg$FAILED) {\n              s1 = peg$c1();\n            }\n            s0 = s1;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parse_() {\n          var s0, s1;\n          var key = peg$currPos * 32 + 1,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = [];\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c2;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c3);\n            }\n          }\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c3);\n              }\n            }\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseidentifierName() {\n          var s0, s1, s2;\n          var key = peg$currPos * 32 + 2,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = [];\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            {\n              peg$fail(peg$c5);\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              if (peg$c4.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c5);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c6(s1);\n          }\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsebinaryOp() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 32 + 3,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 62) {\n              s2 = peg$c7;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c8);\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c9();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 126) {\n                s2 = peg$c10;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c11);\n                }\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c12();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n              if (s1 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 43) {\n                  s2 = peg$c13;\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  {\n                    peg$fail(peg$c14);\n                  }\n                }\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n                  if (s3 !== peg$FAILED) {\n                    s1 = peg$c15();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 32) {\n                  s1 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  {\n                    peg$fail(peg$c3);\n                  }\n                }\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parse_();\n                  if (s2 !== peg$FAILED) {\n                    s1 = peg$c16();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsehasSelectors() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          var key = peg$currPos * 32 + 4,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parsehasSelector();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsehasSelector();\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c17;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c18);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parsehasSelector();\n                    if (s7 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseselectors() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          var key = peg$currPos * 32 + 5,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parseselector();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseselector();\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c17;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c18);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseselector();\n                    if (s7 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsehasSelector() {\n          var s0, s1, s2;\n          var key = peg$currPos * 32 + 6,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parsebinaryOp();\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseselector();\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c20(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseselector() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 7,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parsesequence();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parsebinaryOp();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesequence();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parsebinaryOp();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesequence();\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c21(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsesequence() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 32 + 8,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c22;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c23);\n            }\n          }\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseatom();\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseatom();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c24(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseatom() {\n          var s0;\n          var key = peg$currPos * 32 + 9,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$parsewildcard();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseidentifier();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseattr();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsefield();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsenegation();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsematches();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsehas();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsefirstChild();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parselastChild();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthChild();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsenthLastChild();\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseclass();\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsewildcard() {\n          var s0, s1;\n          var key = peg$currPos * 32 + 10,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c25;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c26);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c27(s1);\n          }\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseidentifier() {\n          var s0, s1, s2;\n          var key = peg$currPos * 32 + 11,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c28;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c29);\n            }\n          }\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c30(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseattr() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 12,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c31;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c32);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrValue();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s5 = peg$c33;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c34);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c35(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseattrOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 32 + 13,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (peg$c36.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c37);\n            }\n          }\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c38;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c39);\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c40(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            if (peg$c41.test(input.charAt(peg$currPos))) {\n              s0 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              {\n                peg$fail(peg$c42);\n              }\n            }\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseattrEqOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 32 + 14,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c22;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c23);\n            }\n          }\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c38;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c39);\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c40(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseattrName() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 15,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c43;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c44);\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseidentifierName();\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s4 = peg$c43;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c44);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseidentifierName();\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c45(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseattrValue() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 16,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrEqOps();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsetype();\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parseregex();\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c46(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseattrName();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseattrOps();\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsestring();\n                    if (s5 === peg$FAILED) {\n                      s5 = peg$parsenumber();\n                      if (s5 === peg$FAILED) {\n                        s5 = peg$parsepath();\n                      }\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s1 = peg$c46(s1, s3, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseattrName();\n              if (s1 !== peg$FAILED) {\n                s1 = peg$c47(s1);\n              }\n              s0 = s1;\n            }\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsestring() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 17,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c48;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c49);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c51);\n              }\n            }\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c52;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c53);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c54);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c55(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              if (peg$c50.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c51);\n                }\n              }\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c52;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c54);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c55(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c48;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c49);\n                }\n              }\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c56(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s1 = peg$c57;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c58);\n              }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n              if (peg$c59.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c60);\n                }\n              }\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c52;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c54);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c55(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (peg$c59.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c60);\n                  }\n                }\n                if (s3 === peg$FAILED) {\n                  s3 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 92) {\n                    s4 = peg$c52;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n                  if (s4 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s5 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      {\n                        peg$fail(peg$c54);\n                      }\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s4 = peg$c55(s4, s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              }\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 39) {\n                  s3 = peg$c57;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c58);\n                  }\n                }\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c56(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsenumber() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 32 + 18,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          s2 = [];\n          if (peg$c61.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c62);\n            }\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c62);\n              }\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s3 = peg$c43;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c44);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c61.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c62);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (peg$c61.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c62);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c63(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsepath() {\n          var s0, s1;\n          var key = peg$currPos * 32 + 19,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c64(s1);\n          }\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsetype() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 20,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5) === peg$c65) {\n            s1 = peg$c65;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c66);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              if (peg$c67.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c68);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  if (peg$c67.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c68);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c69;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c70);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c71(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseflags() {\n          var s0, s1;\n          var key = peg$currPos * 32 + 21,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = [];\n          if (peg$c72.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c73);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            while (s1 !== peg$FAILED) {\n              s0.push(s1);\n              if (peg$c72.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                {\n                  peg$fail(peg$c73);\n                }\n              }\n            }\n          } else {\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseregex() {\n          var s0, s1, s2, s3, s4;\n          var key = peg$currPos * 32 + 22,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c74;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c75);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            if (peg$c76.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c77);\n              }\n            }\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                if (peg$c76.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c77);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s3 = peg$c74;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c75);\n                }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseflags();\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n                if (s4 !== peg$FAILED) {\n                  s1 = peg$c78(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsefield() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          var key = peg$currPos * 32 + 23,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s1 = peg$c43;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c44);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s5 = peg$c43;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c44);\n                }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseidentifierName();\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s5 = peg$c43;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c44);\n                  }\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseidentifierName();\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              }\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c79(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsenegation() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 24,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5) === peg$c80) {\n            s1 = peg$c80;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c81);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c69;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c70);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c82(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsematches() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 25,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 9) === peg$c83) {\n            s1 = peg$c83;\n            peg$currPos += 9;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c84);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c69;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c70);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c85(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsehas() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 26,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5) === peg$c86) {\n            s1 = peg$c86;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c87);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsehasSelectors();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c69;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c70);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c88(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsefirstChild() {\n          var s0, s1;\n          var key = peg$currPos * 32 + 27,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 12) === peg$c89) {\n            s1 = peg$c89;\n            peg$currPos += 12;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c90);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c91();\n          }\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parselastChild() {\n          var s0, s1;\n          var key = peg$currPos * 32 + 28,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 11) === peg$c92) {\n            s1 = peg$c92;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c93);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c94();\n          }\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsenthChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 29,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 11) === peg$c95) {\n            s1 = peg$c95;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c96);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c62);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  if (peg$c61.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c62);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c69;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c70);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c97(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parsenthLastChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 32 + 30,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 16) === peg$c98) {\n            s1 = peg$c98;\n            peg$currPos += 16;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c99);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              if (peg$c61.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c62);\n                }\n              }\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  if (peg$c61.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c62);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c69;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c70);\n                    }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c100(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function peg$parseclass() {\n          var s0, s1, s2;\n          var key = peg$currPos * 32 + 31,\n            cached = peg$resultsCache[key];\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s1 = peg$c101;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c102);\n            }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c103(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n        function nth(n) {\n          return {\n            type: 'nth-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n        function nthLast(n) {\n          return {\n            type: 'nth-last-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n        function strUnescape(s) {\n          return s.replace(/\\\\(.)/g, function (match, ch) {\n            switch (ch) {\n              case 'b':\n                return '\\b';\n              case 'f':\n                return '\\f';\n              case 'n':\n                return '\\n';\n              case 'r':\n                return '\\r';\n              case 't':\n                return '\\t';\n              case 'v':\n                return '\\v';\n              default:\n                return ch;\n            }\n          });\n        }\n        peg$result = peg$startRuleFunction();\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n          }\n          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n        }\n      }\n      return {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n      };\n    });\n  });\n\n  /**\n  * @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n  */\n\n  var LEFT_SIDE = 'LEFT_SIDE';\n  var RIGHT_SIDE = 'RIGHT_SIDE';\n\n  /**\n   * @external AST\n   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n   */\n\n  /**\n   * One of the rules of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorAST\n   * @see grammar.pegjs\n  */\n\n  /**\n   * The `sequence` production of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorSequenceAST\n  */\n\n  /**\n   * Get the value of a property which may be multiple levels down\n   * in the object.\n   * @param {?PlainObject} obj\n   * @param {string[]} keys\n   * @returns {undefined|boolean|string|number|external:AST}\n   */\n  function getPath(obj, keys) {\n    for (var i = 0; i < keys.length; ++i) {\n      if (obj == null) {\n        return obj;\n      }\n      obj = obj[keys[i]];\n    }\n    return obj;\n  }\n\n  /**\n   * Determine whether `node` can be reached by following `path`,\n   * starting at `ancestor`.\n   * @param {?external:AST} node\n   * @param {?external:AST} ancestor\n   * @param {string[]} path\n   * @param {Integer} fromPathIndex\n   * @returns {boolean}\n   */\n  function inPath(node, ancestor, path, fromPathIndex) {\n    var current = ancestor;\n    for (var i = fromPathIndex; i < path.length; ++i) {\n      if (current == null) {\n        return false;\n      }\n      var field = current[path[i]];\n      if (Array.isArray(field)) {\n        for (var k = 0; k < field.length; ++k) {\n          if (inPath(node, field[k], path, i + 1)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      current = field;\n    }\n    return node === current;\n  }\n\n  /**\n   * A generated matcher function for a selector.\n   * @callback SelectorMatcher\n   * @param {?SelectorAST} selector\n   * @param {external:AST[]} [ancestry=[]]\n   * @param {ESQueryOptions} [options]\n   * @returns {void}\n  */\n\n  /**\n   * A WeakMap for holding cached matcher functions for selectors.\n   * @type {WeakMap<SelectorAST, SelectorMatcher>}\n  */\n  var MATCHER_CACHE = typeof WeakMap === 'function' ? new WeakMap() : null;\n\n  /**\n   * Look up a matcher function for `selector` in the cache.\n   * If it does not exist, generate it with `generateMatcher` and add it to the cache.\n   * In engines without WeakMap, the caching is skipped and matchers are generated with every call.\n   * @param {?SelectorAST} selector\n   * @returns {SelectorMatcher}\n   */\n  function getMatcher(selector) {\n    if (selector == null) {\n      return function () {\n        return true;\n      };\n    }\n    if (MATCHER_CACHE != null) {\n      var matcher = MATCHER_CACHE.get(selector);\n      if (matcher != null) {\n        return matcher;\n      }\n      matcher = generateMatcher(selector);\n      MATCHER_CACHE.set(selector, matcher);\n      return matcher;\n    }\n    return generateMatcher(selector);\n  }\n\n  /**\n   * Create a matcher function for `selector`,\n   * @param {?SelectorAST} selector\n   * @returns {SelectorMatcher}\n   */\n  function generateMatcher(selector) {\n    switch (selector.type) {\n      case 'wildcard':\n        return function () {\n          return true;\n        };\n      case 'identifier':\n        {\n          var value = selector.value.toLowerCase();\n          return function (node, ancestry, options) {\n            var nodeTypeKey = options && options.nodeTypeKey || 'type';\n            return value === node[nodeTypeKey].toLowerCase();\n          };\n        }\n      case 'exactNode':\n        return function (node, ancestry) {\n          return ancestry.length === 0;\n        };\n      case 'field':\n        {\n          var path = selector.name.split('.');\n          return function (node, ancestry) {\n            var ancestor = ancestry[path.length - 1];\n            return inPath(node, ancestor, path, 0);\n          };\n        }\n      case 'matches':\n        {\n          var matchers = selector.selectors.map(getMatcher);\n          return function (node, ancestry, options) {\n            for (var i = 0; i < matchers.length; ++i) {\n              if (matchers[i](node, ancestry, options)) {\n                return true;\n              }\n            }\n            return false;\n          };\n        }\n      case 'compound':\n        {\n          var _matchers = selector.selectors.map(getMatcher);\n          return function (node, ancestry, options) {\n            for (var i = 0; i < _matchers.length; ++i) {\n              if (!_matchers[i](node, ancestry, options)) {\n                return false;\n              }\n            }\n            return true;\n          };\n        }\n      case 'not':\n        {\n          var _matchers2 = selector.selectors.map(getMatcher);\n          return function (node, ancestry, options) {\n            for (var i = 0; i < _matchers2.length; ++i) {\n              if (_matchers2[i](node, ancestry, options)) {\n                return false;\n              }\n            }\n            return true;\n          };\n        }\n      case 'has':\n        {\n          var _matchers3 = selector.selectors.map(getMatcher);\n          return function (node, ancestry, options) {\n            var result = false;\n            var a = [];\n            estraverse.traverse(node, {\n              enter: function enter(node, parent) {\n                if (parent != null) {\n                  a.unshift(parent);\n                }\n                for (var i = 0; i < _matchers3.length; ++i) {\n                  if (_matchers3[i](node, a, options)) {\n                    result = true;\n                    this[\"break\"]();\n                    return;\n                  }\n                }\n              },\n              leave: function leave() {\n                a.shift();\n              },\n              keys: options && options.visitorKeys,\n              fallback: options && options.fallback || 'iteration'\n            });\n            return result;\n          };\n        }\n      case 'child':\n        {\n          var left = getMatcher(selector.left);\n          var right = getMatcher(selector.right);\n          return function (node, ancestry, options) {\n            if (ancestry.length > 0 && right(node, ancestry, options)) {\n              return left(ancestry[0], ancestry.slice(1), options);\n            }\n            return false;\n          };\n        }\n      case 'descendant':\n        {\n          var _left = getMatcher(selector.left);\n          var _right = getMatcher(selector.right);\n          return function (node, ancestry, options) {\n            if (_right(node, ancestry, options)) {\n              for (var i = 0, l = ancestry.length; i < l; ++i) {\n                if (_left(ancestry[i], ancestry.slice(i + 1), options)) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          };\n        }\n      case 'attribute':\n        {\n          var _path = selector.name.split('.');\n          switch (selector.operator) {\n            case void 0:\n              return function (node) {\n                return getPath(node, _path) != null;\n              };\n            case '=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return function (node) {\n                    var p = getPath(node, _path);\n                    return typeof p === 'string' && selector.value.value.test(p);\n                  };\n                case 'literal':\n                  {\n                    var literal = \"\".concat(selector.value.value);\n                    return function (node) {\n                      return literal === \"\".concat(getPath(node, _path));\n                    };\n                  }\n                case 'type':\n                  return function (node) {\n                    return selector.value.value === _typeof(getPath(node, _path));\n                  };\n              }\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n            case '!=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return function (node) {\n                    return !selector.value.value.test(getPath(node, _path));\n                  };\n                case 'literal':\n                  {\n                    var _literal = \"\".concat(selector.value.value);\n                    return function (node) {\n                      return _literal !== \"\".concat(getPath(node, _path));\n                    };\n                  }\n                case 'type':\n                  return function (node) {\n                    return selector.value.value !== _typeof(getPath(node, _path));\n                  };\n              }\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n            case '<=':\n              return function (node) {\n                return getPath(node, _path) <= selector.value.value;\n              };\n            case '<':\n              return function (node) {\n                return getPath(node, _path) < selector.value.value;\n              };\n            case '>':\n              return function (node) {\n                return getPath(node, _path) > selector.value.value;\n              };\n            case '>=':\n              return function (node) {\n                return getPath(node, _path) >= selector.value.value;\n              };\n          }\n          throw new Error(\"Unknown operator: \".concat(selector.operator));\n        }\n      case 'sibling':\n        {\n          var _left2 = getMatcher(selector.left);\n          var _right2 = getMatcher(selector.right);\n          return function (node, ancestry, options) {\n            return _right2(node, ancestry, options) && sibling(node, _left2, ancestry, LEFT_SIDE, options) || selector.left.subject && _left2(node, ancestry, options) && sibling(node, _right2, ancestry, RIGHT_SIDE, options);\n          };\n        }\n      case 'adjacent':\n        {\n          var _left3 = getMatcher(selector.left);\n          var _right3 = getMatcher(selector.right);\n          return function (node, ancestry, options) {\n            return _right3(node, ancestry, options) && adjacent(node, _left3, ancestry, LEFT_SIDE, options) || selector.right.subject && _left3(node, ancestry, options) && adjacent(node, _right3, ancestry, RIGHT_SIDE, options);\n          };\n        }\n      case 'nth-child':\n        {\n          var nth = selector.index.value;\n          var _right4 = getMatcher(selector.right);\n          return function (node, ancestry, options) {\n            return _right4(node, ancestry, options) && nthChild(node, ancestry, nth, options);\n          };\n        }\n      case 'nth-last-child':\n        {\n          var _nth = -selector.index.value;\n          var _right5 = getMatcher(selector.right);\n          return function (node, ancestry, options) {\n            return _right5(node, ancestry, options) && nthChild(node, ancestry, _nth, options);\n          };\n        }\n      case 'class':\n        {\n          var name = selector.name.toLowerCase();\n          return function (node, ancestry, options) {\n            if (options && options.matchClass) {\n              return options.matchClass(selector.name, node, ancestry);\n            }\n            if (options && options.nodeTypeKey) return false;\n            switch (name) {\n              case 'statement':\n                if (node.type.slice(-9) === 'Statement') return true;\n              // fallthrough: interface Declaration <: Statement { }\n              case 'declaration':\n                return node.type.slice(-11) === 'Declaration';\n              case 'pattern':\n                if (node.type.slice(-7) === 'Pattern') return true;\n              // fallthrough: interface Expression <: Node, Pattern { }\n              case 'expression':\n                return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';\n              case 'function':\n                return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n            }\n            throw new Error(\"Unknown class name: \".concat(selector.name));\n          };\n        }\n    }\n    throw new Error(\"Unknown selector type: \".concat(selector.type));\n  }\n\n  /**\n   * @callback TraverseOptionFallback\n   * @param {external:AST} node The given node.\n   * @returns {string[]} An array of visitor keys for the given node.\n   */\n\n  /**\n   * @callback ClassMatcher\n   * @param {string} className The name of the class to match.\n   * @param {external:AST} node The node to match against.\n   * @param {Array<external:AST>} ancestry The ancestry of the node.\n   * @returns {boolean} True if the node matches the class, false if not.\n   */\n\n  /**\n   * @typedef {object} ESQueryOptions\n   * @property {string} [nodeTypeKey=\"type\"] By passing `nodeTypeKey`, we can allow other ASTs to use ESQuery.\n   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n   * @property {ClassMatcher} [matchClass] By passing `matchClass` option, we can customize the interpretation of classes.\n   */\n\n  /**\n   * Given a `node` and its ancestors, determine if `node` is matched\n   * by `selector`.\n   * @param {?external:AST} node\n   * @param {?SelectorAST} selector\n   * @param {external:AST[]} [ancestry=[]]\n   * @param {ESQueryOptions} [options]\n   * @throws {Error} Unknowns (operator, class name, selector type, or\n   * selector value type)\n   * @returns {boolean}\n   */\n  function matches(node, selector, ancestry, options) {\n    if (!selector) {\n      return true;\n    }\n    if (!node) {\n      return false;\n    }\n    if (!ancestry) {\n      ancestry = [];\n    }\n    return getMatcher(selector)(node, ancestry, options);\n  }\n\n  /**\n   * Get visitor keys of a given node.\n   * @param {external:AST} node The AST node to get keys.\n   * @param {ESQueryOptions|undefined} options\n   * @returns {string[]} Visitor keys of the node.\n   */\n  function getVisitorKeys(node, options) {\n    var nodeTypeKey = options && options.nodeTypeKey || 'type';\n    var nodeType = node[nodeTypeKey];\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n      return options.visitorKeys[nodeType];\n    }\n    if (estraverse.VisitorKeys[nodeType]) {\n      return estraverse.VisitorKeys[nodeType];\n    }\n    if (options && typeof options.fallback === 'function') {\n      return options.fallback(node);\n    }\n    // 'iteration' fallback\n    return Object.keys(node).filter(function (key) {\n      return key !== nodeTypeKey;\n    });\n  }\n\n  /**\n   * Check whether the given value is an ASTNode or not.\n   * @param {any} node The value to check.\n   * @param {ESQueryOptions|undefined} options The options to use.\n   * @returns {boolean} `true` if the value is an ASTNode.\n   */\n  function isNode(node, options) {\n    var nodeTypeKey = options && options.nodeTypeKey || 'type';\n    return node !== null && _typeof(node) === 'object' && typeof node[nodeTypeKey] === 'string';\n  }\n\n  /**\n   * Determines if the given node has a sibling that matches the\n   * given selector matcher.\n   * @param {external:AST} node\n   * @param {SelectorMatcher} matcher\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n  function sibling(node, matcher, ancestry, side, options) {\n    var _ancestry = _slicedToArray(ancestry, 1),\n      parent = _ancestry[0];\n    if (!parent) {\n      return false;\n    }\n    var keys = getVisitorKeys(parent, options);\n    for (var i = 0; i < keys.length; ++i) {\n      var listProp = parent[keys[i]];\n      if (Array.isArray(listProp)) {\n        var startIndex = listProp.indexOf(node);\n        if (startIndex < 0) {\n          continue;\n        }\n        var lowerBound = void 0,\n          upperBound = void 0;\n        if (side === LEFT_SIDE) {\n          lowerBound = 0;\n          upperBound = startIndex;\n        } else {\n          lowerBound = startIndex + 1;\n          upperBound = listProp.length;\n        }\n        for (var k = lowerBound; k < upperBound; ++k) {\n          if (isNode(listProp[k], options) && matcher(listProp[k], ancestry, options)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the given node has an adjacent sibling that matches\n   * the given selector matcher.\n   * @param {external:AST} node\n   * @param {SelectorMatcher} matcher\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n  function adjacent(node, matcher, ancestry, side, options) {\n    var _ancestry2 = _slicedToArray(ancestry, 1),\n      parent = _ancestry2[0];\n    if (!parent) {\n      return false;\n    }\n    var keys = getVisitorKeys(parent, options);\n    for (var i = 0; i < keys.length; ++i) {\n      var listProp = parent[keys[i]];\n      if (Array.isArray(listProp)) {\n        var idx = listProp.indexOf(node);\n        if (idx < 0) {\n          continue;\n        }\n        if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1], options) && matcher(listProp[idx - 1], ancestry, options)) {\n          return true;\n        }\n        if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1], options) && matcher(listProp[idx + 1], ancestry, options)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the given node is the `nth` child.\n   * If `nth` is negative then the position is counted\n   * from the end of the list of children.\n   * @param {external:AST} node\n   * @param {external:AST[]} ancestry\n   * @param {Integer} nth\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n  function nthChild(node, ancestry, nth, options) {\n    if (nth === 0) {\n      return false;\n    }\n    var _ancestry3 = _slicedToArray(ancestry, 1),\n      parent = _ancestry3[0];\n    if (!parent) {\n      return false;\n    }\n    var keys = getVisitorKeys(parent, options);\n    for (var i = 0; i < keys.length; ++i) {\n      var listProp = parent[keys[i]];\n      if (Array.isArray(listProp)) {\n        var idx = nth < 0 ? listProp.length + nth : nth - 1;\n        if (idx >= 0 && idx < listProp.length && listProp[idx] === node) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * For each selector node marked as a subject, find the portion of the\n   * selector that the subject must match.\n   * @param {SelectorAST} selector\n   * @param {SelectorAST} [ancestor] Defaults to `selector`\n   * @returns {SelectorAST[]}\n   */\n  function subjects(selector, ancestor) {\n    if (selector == null || _typeof(selector) != 'object') {\n      return [];\n    }\n    if (ancestor == null) {\n      ancestor = selector;\n    }\n    var results = selector.subject ? [ancestor] : [];\n    var keys = Object.keys(selector);\n    for (var i = 0; i < keys.length; ++i) {\n      var p = keys[i];\n      var sel = selector[p];\n      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));\n    }\n    return results;\n  }\n\n  /**\n  * @callback TraverseVisitor\n  * @param {?external:AST} node\n  * @param {?external:AST} parent\n  * @param {external:AST[]} ancestry\n  */\n\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {TraverseVisitor} visitor\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n  function traverse(ast, selector, visitor, options) {\n    if (!selector) {\n      return;\n    }\n    var ancestry = [];\n    var matcher = getMatcher(selector);\n    var altSubjects = subjects(selector).map(getMatcher);\n    estraverse.traverse(ast, {\n      enter: function enter(node, parent) {\n        if (parent != null) {\n          ancestry.unshift(parent);\n        }\n        if (matcher(node, ancestry, options)) {\n          if (altSubjects.length) {\n            for (var i = 0, l = altSubjects.length; i < l; ++i) {\n              if (altSubjects[i](node, ancestry, options)) {\n                visitor(node, parent, ancestry);\n              }\n              for (var k = 0, m = ancestry.length; k < m; ++k) {\n                var succeedingAncestry = ancestry.slice(k + 1);\n                if (altSubjects[i](ancestry[k], succeedingAncestry, options)) {\n                  visitor(ancestry[k], parent, succeedingAncestry);\n                }\n              }\n            }\n          } else {\n            visitor(node, parent, ancestry);\n          }\n        }\n      },\n      leave: function leave() {\n        ancestry.shift();\n      },\n      keys: options && options.visitorKeys,\n      fallback: options && options.fallback || 'iteration'\n    });\n  }\n\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n  function match(ast, selector, options) {\n    var results = [];\n    traverse(ast, selector, function (node) {\n      results.push(node);\n    }, options);\n    return results;\n  }\n\n  /**\n   * Parse a selector string and return its AST.\n   * @param {string} selector\n   * @returns {SelectorAST}\n   */\n  function parse(selector) {\n    return parser.parse(selector);\n  }\n\n  /**\n   * Query the code AST using the selector string.\n   * @param {external:AST} ast\n   * @param {string} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n  function query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n  }\n  query.parse = parse;\n  query.match = match;\n  query.traverse = traverse;\n  query.matches = matches;\n  query.query = query;\n\n  return query;\n\n})));\n"
        }
    ]
}