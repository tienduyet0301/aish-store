{
    "sourceFile": "node_modules/eslint-plugin-react/node_modules/resolve/test/resolver.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1746892282806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1746891704042,
            "name": "cart",
            "content": "var path = require('path');\nvar fs = require('fs');\nvar test = require('tape');\nvar resolve = require('../');\nvar async = require('../async');\n\ntest('`./async` entry point', function (t) {\n    t.equal(resolve, async, '`./async` entry point is the same as `main`');\n    t.end();\n});\n\ntest('async foo', function (t) {\n    t.plan(12);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./foo', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg && pkg.name, 'resolve');\n    });\n\n    resolve('./foo.js', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg && pkg.name, 'resolve');\n    });\n\n    resolve('./foo', { basedir: dir, 'package': { main: 'resolver' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg && pkg.main, 'resolver');\n    });\n\n    resolve('./foo.js', { basedir: dir, 'package': { main: 'resolver' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n        t.equal(pkg.main, 'resolver');\n    });\n\n    resolve('./foo', { basedir: dir, filename: path.join(dir, 'baz.js') }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo.js'));\n    });\n\n    resolve('foo', { basedir: dir }, function (err) {\n        t.equal(err.message, \"Cannot find module 'foo' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    // Test that filename is reported as the \"from\" value when passed.\n    resolve('foo', { basedir: dir, filename: path.join(dir, 'baz.js') }, function (err) {\n        t.equal(err.message, \"Cannot find module 'foo' from '\" + path.join(dir, 'baz.js') + \"'\");\n    });\n});\n\ntest('bar', function (t) {\n    t.plan(6);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('foo', { basedir: dir + '/bar' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'bar/node_modules/foo/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('foo', { basedir: dir + '/bar' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'bar/node_modules/foo/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('foo', { basedir: dir + '/bar', 'package': { main: 'bar' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'bar/node_modules/foo/index.js'));\n        t.equal(pkg.main, 'bar');\n    });\n});\n\ntest('baz', function (t) {\n    t.plan(4);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./baz', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'baz/quux.js'));\n        t.equal(pkg.main, 'quux.js');\n    });\n\n    resolve('./baz', { basedir: dir, 'package': { main: 'resolver' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'baz/quux.js'));\n        t.equal(pkg.main, 'quux.js');\n    });\n});\n\ntest('biz', function (t) {\n    t.plan(24);\n    var dir = path.join(__dirname, 'resolver/biz/node_modules');\n\n    resolve('./grux', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('./grux', { basedir: dir, 'package': { main: 'biz' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg.main, 'biz');\n    });\n\n    resolve('./garply', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('./garply', { basedir: dir, 'package': { main: 'biz' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('tiv', { basedir: dir + '/grux' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('tiv', { basedir: dir + '/grux', 'package': { main: 'grux' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg.main, 'grux');\n    });\n\n    resolve('tiv', { basedir: dir + '/garply' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('tiv', { basedir: dir + '/garply', 'package': { main: './lib' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'tiv/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('grux', { basedir: dir + '/tiv' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg, undefined);\n    });\n\n    resolve('grux', { basedir: dir + '/tiv', 'package': { main: 'tiv' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'grux/index.js'));\n        t.equal(pkg.main, 'tiv');\n    });\n\n    resolve('garply', { basedir: dir + '/tiv' }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n\n    resolve('garply', { basedir: dir + '/tiv', 'package': { main: 'tiv' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'garply/lib/index.js'));\n        t.equal(pkg.main, './lib');\n    });\n});\n\ntest('quux', function (t) {\n    t.plan(2);\n    var dir = path.join(__dirname, 'resolver/quux');\n\n    resolve('./foo', { basedir: dir, 'package': { main: 'quux' } }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'foo/index.js'));\n        t.equal(pkg.main, 'quux');\n    });\n});\n\ntest('normalize', function (t) {\n    t.plan(2);\n    var dir = path.join(__dirname, 'resolver/biz/node_modules/grux');\n\n    resolve('../grux', { basedir: dir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n        t.equal(pkg, undefined);\n    });\n});\n\ntest('cup', function (t) {\n    t.plan(5);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./cup', { basedir: dir, extensions: ['.js', '.coffee'] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'cup.coffee'));\n    });\n\n    resolve('./cup.coffee', { basedir: dir }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'cup.coffee'));\n    });\n\n    resolve('./cup', { basedir: dir, extensions: ['.js'] }, function (err, res) {\n        t.equal(err.message, \"Cannot find module './cup' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    // Test that filename is reported as the \"from\" value when passed.\n    resolve('./cup', { basedir: dir, extensions: ['.js'], filename: path.join(dir, 'cupboard.js') }, function (err, res) {\n        t.equal(err.message, \"Cannot find module './cup' from '\" + path.join(dir, 'cupboard.js') + \"'\");\n    });\n});\n\ntest('mug', function (t) {\n    t.plan(3);\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./mug', { basedir: dir }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'mug.js'));\n    });\n\n    resolve('./mug', { basedir: dir, extensions: ['.coffee', '.js'] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, '/mug.coffee'));\n    });\n\n    resolve('./mug', { basedir: dir, extensions: ['.js', '.coffee'] }, function (err, res) {\n        t.equal(res, path.join(dir, '/mug.js'));\n    });\n});\n\ntest('other path', function (t) {\n    t.plan(6);\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'bar');\n    var otherDir = path.join(resolverDir, 'other_path');\n\n    resolve('root', { basedir: dir, paths: [otherDir] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(resolverDir, 'other_path/root.js'));\n    });\n\n    resolve('lib/other-lib', { basedir: dir, paths: [otherDir] }, function (err, res) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(resolverDir, 'other_path/lib/other-lib.js'));\n    });\n\n    resolve('root', { basedir: dir }, function (err, res) {\n        t.equal(err.message, \"Cannot find module 'root' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n\n    resolve('zzz', { basedir: dir, paths: [otherDir] }, function (err, res) {\n        t.equal(err.message, \"Cannot find module 'zzz' from '\" + path.resolve(dir) + \"'\");\n        t.equal(err.code, 'MODULE_NOT_FOUND');\n    });\n});\n\ntest('path iterator', function (t) {\n    t.plan(2);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n\n    var exactIterator = function (x, start, getPackageCandidates, opts) {\n        return [path.join(resolverDir, x)];\n    };\n\n    resolve('baz', { packageIterator: exactIterator }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(resolverDir, 'baz/quux.js'));\n        t.equal(pkg && pkg.name, 'baz');\n    });\n});\n\ntest('empty main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'empty_main');\n\n    resolve('./empty_main', { basedir: resolverDir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n    });\n});\n\ntest('incorrect main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'incorrect_main');\n\n    resolve('./incorrect_main', { basedir: resolverDir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n    });\n});\n\ntest('missing index', function (t) {\n    t.plan(2);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    resolve('./missing_index', { basedir: resolverDir }, function (err, res, pkg) {\n        t.ok(err instanceof Error);\n        t.equal(err && err.code, 'INCORRECT_PACKAGE_MAIN', 'error has correct error code');\n    });\n});\n\ntest('missing main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'missing_main');\n\n    resolve('./missing_main', { basedir: resolverDir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n    });\n});\n\ntest('null main', function (t) {\n    t.plan(1);\n\n    var resolverDir = path.join(__dirname, 'resolver');\n    var dir = path.join(resolverDir, 'null_main');\n\n    resolve('./null_main', { basedir: resolverDir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'index.js'));\n    });\n});\n\ntest('main: false', function (t) {\n    t.plan(2);\n\n    var basedir = path.join(__dirname, 'resolver');\n    var dir = path.join(basedir, 'false_main');\n    resolve('./false_main', { basedir: basedir }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(\n            res,\n            path.join(dir, 'index.js'),\n            '`\"main\": false`: resolves to `index.js`'\n        );\n        t.deepEqual(pkg, {\n            name: 'false_main',\n            main: false\n        });\n    });\n});\n\ntest('without basedir', function (t) {\n    t.plan(1);\n\n    var dir = path.join(__dirname, 'resolver/without_basedir');\n    var tester = require(path.join(dir, 'main.js')); // eslint-disable-line global-require\n\n    tester(t, function (err, res, pkg) {\n        if (err) {\n            t.fail(err);\n        } else {\n            t.equal(res, path.join(dir, 'node_modules/mymodule.js'));\n        }\n    });\n});\n\ntest('#52 - incorrectly resolves module-paths like \"./someFolder/\" when there is a file of the same name', function (t) {\n    t.plan(2);\n\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./foo', { basedir: path.join(dir, 'same_names') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo.js'));\n    });\n\n    resolve('./foo/', { basedir: path.join(dir, 'same_names') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo/index.js'));\n    });\n});\n\ntest('#211 - incorrectly resolves module-paths like \".\" when from inside a folder with a sibling file of the same name', function (t) {\n    t.plan(2);\n\n    var dir = path.join(__dirname, 'resolver');\n\n    resolve('./', { basedir: path.join(dir, 'same_names/foo') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo/index.js'));\n    });\n\n    resolve('.', { basedir: path.join(dir, 'same_names/foo') }, function (err, res, pkg) {\n        if (err) t.fail(err);\n        t.equal(res, path.join(dir, 'same_names/foo/index.js'));\n    });\n});\n\ntest('async: #121 - treating an existing file as a dir when no basedir', function (t) {\n    var testFile = path.basename(__filename);\n\n    t.test('sanity check', function (st) {\n        st.plan(1);\n        resolve('./' + testFile, function (err, res, pkg) {\n            if (err) t.fail(err);\n            st.equal(res, __filename, 'sanity check');\n        });\n    });\n\n    t.test('with a fake directory', function (st) {\n        st.plan(4);\n\n        resolve('./' + testFile + '/blah', function (err, res, pkg) {\n            st.ok(err, 'there is an error');\n            st.notOk(res, 'no result');\n\n            st.equal(err && err.code, 'MODULE_NOT_FOUND', 'error code matches require.resolve');\n            st.equal(\n                err && err.message,\n                'Cannot find module \\'./' + testFile + '/blah\\' from \\'' + __dirname + '\\'',\n                'can not find nonexistent module'\n            );\n            st.end();\n        });\n    });\n\n    t.end();\n});\n\ntest('async dot main', function (t) {\n    var start = new Date();\n    t.plan(3);\n    resolve('./resolver/dot_main', function (err, ret) {\n        t.notOk(err);\n        t.equal(ret, path.join(__dirname, 'resolver/dot_main/index.js'));\n        t.ok(new Date() - start < 50, 'resolve.sync timedout');\n        t.end();\n    });\n});\n\ntest('async dot slash main', function (t) {\n    var start = new Date();\n    t.plan(3);\n    resolve('./resolver/dot_slash_main', function (err, ret) {\n        t.notOk(err);\n        t.equal(ret, path.join(__dirname, 'resolver/dot_slash_main/index.js'));\n        t.ok(new Date() - start < 50, 'resolve.sync timedout');\n        t.end();\n    });\n});\n\ntest('not a directory', function (t) {\n    t.plan(6);\n    var path = './foo';\n    resolve(path, { basedir: __filename }, function (err, res, pkg) {\n        t.ok(err, 'a non-directory errors');\n        t.equal(arguments.length, 1);\n        t.equal(res, undefined);\n        t.equal(pkg, undefined);\n\n        t.equal(err && err.message, 'Provided basedir \"' + __filename + '\" is not a directory, or a symlink to a directory');\n        t.equal(err && err.code, 'INVALID_BASEDIR');\n    });\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    t.plan(5);\n\n    var dir = path.join(__dirname, 'resolver');\n    resolve('./invalid_main', { basedir: dir }, function (err, res, pkg) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n        t.equal(res, undefined, 'res is undefined');\n        t.equal(pkg, undefined, 'pkg is undefined');\n    });\n});\n\ntest('non-string \"main\" field in package.json', function (t) {\n    t.plan(5);\n\n    var dir = path.join(__dirname, 'resolver');\n    resolve('./invalid_main', { basedir: dir }, function (err, res, pkg) {\n        t.ok(err, 'errors on non-string main');\n        t.equal(err.message, 'package “invalid_main” `main` must be a string');\n        t.equal(err.code, 'INVALID_PACKAGE_MAIN');\n        t.equal(res, undefined, 'res is undefined');\n        t.equal(pkg, undefined, 'pkg is undefined');\n    });\n});\n\ntest('browser field in package.json', function (t) {\n    t.plan(3);\n\n    var dir = path.join(__dirname, 'resolver');\n    resolve(\n        './browser_field',\n        {\n            basedir: dir,\n            packageFilter: function packageFilter(pkg) {\n                if (pkg.browser) {\n                    pkg.main = pkg.browser; // eslint-disable-line no-param-reassign\n                    delete pkg.browser; // eslint-disable-line no-param-reassign\n                }\n                return pkg;\n            }\n        },\n        function (err, res, pkg) {\n            if (err) t.fail(err);\n            t.equal(res, path.join(dir, 'browser_field', 'b.js'));\n            t.equal(pkg && pkg.main, 'b');\n            t.equal(pkg && pkg.browser, undefined);\n        }\n    );\n});\n\ntest('absolute paths', function (t) {\n    t.plan(4);\n\n    var extensionless = __filename.slice(0, -path.extname(__filename).length);\n\n    resolve(__filename, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'absolute path to this file resolves'\n        );\n    });\n    resolve(extensionless, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'extensionless absolute path to this file resolves'\n        );\n    });\n    resolve(__filename, { basedir: process.cwd() }, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'absolute path to this file with a basedir resolves'\n        );\n    });\n    resolve(extensionless, { basedir: process.cwd() }, function (err, res) {\n        t.equal(\n            res,\n            __filename,\n            'extensionless absolute path to this file with a basedir resolves'\n        );\n    });\n});\n\nvar malformedDir = path.join(__dirname, 'resolver/malformed_package_json');\ntest('malformed package.json', { skip: !fs.existsSync(malformedDir) }, function (t) {\n    /* eslint operator-linebreak: [\"error\", \"before\"], function-paren-newline: \"off\" */\n    t.plan(\n        (3 * 3) // 3 sets of 3 assertions in the final callback\n        + 2 // 1 readPackage call with malformed package.json\n    );\n\n    var basedir = malformedDir;\n    var expected = path.join(basedir, 'index.js');\n\n    resolve('./index.js', { basedir: basedir }, function (err, res, pkg) {\n        t.error(err, 'no error');\n        t.equal(res, expected, 'malformed package.json is silently ignored');\n        t.equal(pkg, undefined, 'malformed package.json gives an undefined `pkg` argument');\n    });\n\n    resolve(\n        './index.js',\n        {\n            basedir: basedir,\n            packageFilter: function (pkg, pkgfile, dir) {\n                t.fail('should not reach here');\n            }\n        },\n        function (err, res, pkg) {\n            t.error(err, 'with packageFilter: no error');\n            t.equal(res, expected, 'with packageFilter: malformed package.json is silently ignored');\n            t.equal(pkg, undefined, 'with packageFilter: malformed package.json gives an undefined `pkg` argument');\n        }\n    );\n\n    resolve(\n        './index.js',\n        {\n            basedir: basedir,\n            readPackage: function (readFile, pkgfile, cb) {\n                t.equal(pkgfile, path.join(basedir, 'package.json'), 'readPackageSync: `pkgfile` is package.json path');\n                readFile(pkgfile, function (err, result) {\n                    try {\n                        cb(null, JSON.parse(result));\n                    } catch (e) {\n                        t.ok(e instanceof SyntaxError, 'readPackage: malformed package.json parses as a syntax error');\n                        cb(e);\n                    }\n                });\n            }\n        },\n        function (err, res, pkg) {\n            t.error(err, 'with readPackage: no error');\n            t.equal(res, expected, 'with readPackage: malformed package.json is silently ignored');\n            t.equal(pkg, undefined, 'with readPackage: malformed package.json gives an undefined `pkg` argument');\n        }\n    );\n});\n"
        }
    ]
}